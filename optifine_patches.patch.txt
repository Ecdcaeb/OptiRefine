diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/BlockAir.java ../optifine_patch/src/main/java/net/minecraft/block/BlockAir.java
4a5
>  *  java.lang.Integer
5a7,8
>  *  java.util.IdentityHashMap
>  *  java.util.Map
19a23,24
> import java.util.IdentityHashMap;
> import java.util.Map;
33a39,40
>     private static Map mapOriginalOpacity = new IdentityHashMap();
> 
38c45
<     public EnumBlockRenderType getRenderType(IBlockState iBlockState) {
---
>     public EnumBlockRenderType getRenderType(IBlockState state) {
43c50
<     public AxisAlignedBB getCollisionBoundingBox(IBlockState iBlockState, IBlockAccess iBlockAccess, BlockPos blockPos) {
---
>     public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos) {
47c54
<     public boolean isOpaqueCube(IBlockState iBlockState) {
---
>     public boolean isOpaqueCube(IBlockState state) {
51c58
<     public boolean canCollideCheck(IBlockState iBlockState, boolean bl) {
---
>     public boolean canCollideCheck(IBlockState state, boolean hitIfLiquid) {
55c62
<     public void dropBlockAsItemWithChance(World world, BlockPos blockPos, IBlockState iBlockState, float f, int n) {
---
>     public void dropBlockAsItemWithChance(World worldIn, BlockPos pos, IBlockState state, float chance, int fortune) {
58c65
<     public boolean isReplaceable(IBlockAccess iBlockAccess, BlockPos blockPos) {
---
>     public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos) {
62c69
<     public boolean isFullCube(IBlockState iBlockState) {
---
>     public boolean isFullCube(IBlockState state) {
66c73,88
<     public BlockFaceShape getBlockFaceShape(IBlockAccess iBlockAccess, IBlockState iBlockState, BlockPos blockPos, EnumFacing enumFacing) {
---
>     public static void setLightOpacity(Block block, int opacity) {
>         if (!mapOriginalOpacity.containsKey((Object)block)) {
>             mapOriginalOpacity.put((Object)block, (Object)block.lightOpacity);
>         }
>         block.lightOpacity = opacity;
>     }
> 
>     public static void restoreLightOpacity(Block block) {
>         if (!mapOriginalOpacity.containsKey((Object)block)) {
>             return;
>         }
>         int opacity = (Integer)mapOriginalOpacity.get((Object)block);
>         BlockAir.setLightOpacity(block, opacity);
>     }
> 
>     public BlockFaceShape getBlockFaceShape(IBlockAccess p_193383_1_, IBlockState p_193383_2_, BlockPos p_193383_3_, EnumFacing p_193383_4_) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/material/MapColor.java ../optifine_patch/src/main/java/net/minecraft/block/material/MapColor.java
68c68
<     public final int colorValue;
---
>     public int colorValue;
71,72c71,72
<     private MapColor(int n, int n2) {
<         if (n < 0 || n > 63) {
---
>     private MapColor(int index, int color) {
>         if (index < 0 || index > 63) {
75,77c75,77
<         this.colorIndex = n;
<         this.colorValue = n2;
<         MapColor.COLORS[n] = this;
---
>         this.colorIndex = index;
>         this.colorValue = color;
>         MapColor.COLORS[index] = this;
80,83c80,83
<     public int getMapColor(int n) {
<         \u2603 = 220;
<         if (n == 3) {
<             \u2603 = 135;
---
>     public int getMapColor(int index) {
>         int i = 220;
>         if (index == 3) {
>             i = 135;
85,86c85,86
<         if (n == 2) {
<             \u2603 = 255;
---
>         if (index == 2) {
>             i = 255;
88,89c88,89
<         if (n == 1) {
<             \u2603 = 220;
---
>         if (index == 1) {
>             i = 220;
91,92c91,92
<         if (n == 0) {
<             \u2603 = 180;
---
>         if (index == 0) {
>             i = 180;
94,97c94,97
<         \u2603 = (this.colorValue >> 16 & 0xFF) * \u2603 / 255;
<         \u2603 = (this.colorValue >> 8 & 0xFF) * \u2603 / 255;
<         \u2603 = (this.colorValue & 0xFF) * \u2603 / 255;
<         return 0xFF000000 | \u2603 << 16 | \u2603 << 8 | \u2603;
---
>         int j = (this.colorValue >> 16 & 0xFF) * i / 255;
>         int k = (this.colorValue >> 8 & 0xFF) * i / 255;
>         int l = (this.colorValue & 0xFF) * i / 255;
>         return 0xFF000000 | j << 16 | k << 8 | l;
100,101c100,101
<     public static MapColor getBlockColor(EnumDyeColor enumDyeColor) {
<         return BLOCK_COLORS[enumDyeColor.getMetadata()];
---
>     public static MapColor getBlockColor(EnumDyeColor dyeColorIn) {
>         return BLOCK_COLORS[dyeColorIn.getMetadata()];
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/state/BlockStateBase$1.java ../optifine_patch/src/main/java/net/minecraft/block/state/BlockStateBase$1.java
20c20
< class BlockStateBase.1
---
> static final class BlockStateBase.1
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/state/BlockStateBase.java ../optifine_patch/src/main/java/net/minecraft/block/state/BlockStateBase.java
17d16
<  *  javax.annotation.Nullable
20a20
>  *  net.minecraft.util.ResourceLocation
31d30
< import javax.annotation.Nullable;
34a34
> import net.minecraft.util.ResourceLocation;
39a40,75
>     private int blockId = -1;
>     private int blockStateId = -1;
>     private int metadata = -1;
>     private ResourceLocation blockLocation = null;
> 
>     public int getBlockId() {
>         if (this.blockId < 0) {
>             this.blockId = Block.getIdFromBlock((Block)this.u());
>         }
>         return this.blockId;
>     }
> 
>     public int getBlockStateId() {
>         if (this.blockStateId < 0) {
>             this.blockStateId = Block.getStateId((IBlockState)this);
>         }
>         return this.blockStateId;
>     }
> 
>     public int getMetadata() {
>         if (this.metadata < 0) {
>             this.metadata = this.u().getMetaFromState((IBlockState)this);
>         }
>         return this.metadata;
>     }
> 
>     public ResourceLocation getBlockLocation() {
>         if (this.blockLocation == null) {
>             this.blockLocation = (ResourceLocation)Block.REGISTRY.getNameForObject((Object)this.u());
>         }
>         return this.blockLocation;
>     }
> 
>     public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
>         return null;
>     }
66,70d101
<     }
< 
<     @Nullable
<     public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
<         return null;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/state/BlockStateContainer$1.java ../optifine_patch/src/main/java/net/minecraft/block/state/BlockStateContainer$1.java
17c17
< class BlockStateContainer.1
---
> static final class BlockStateContainer.1
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/state/BlockStateContainer$StateImplementation.java ../optifine_patch/src/main/java/net/minecraft/block/state/BlockStateContainer$StateImplementation.java
14d13
<  *  java.lang.String
22a22,23
>  *  net.minecraft.block.Block$EnumOffsetType
>  *  net.minecraft.block.BlockFlower
42,43c43,45
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.model.BlockModelUtils
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
58a61
> import net.minecraft.block.BlockFlower;
78,79c81,83
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.model.BlockModelUtils;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
81c85
< public static class BlockStateContainer.StateImplementation
---
> static class BlockStateContainer.StateImplementation
85c89
<     protected ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> propertyValueTable;
---
>     private ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> propertyValueTable;
87c91
<     protected BlockStateContainer.StateImplementation(Block blockIn, ImmutableMap<IProperty<?>, Comparable<?>> propertiesIn) {
---
>     private BlockStateContainer.StateImplementation(Block blockIn, ImmutableMap<IProperty<?>, Comparable<?>> propertiesIn) {
105c109
<             throw new IllegalArgumentException("Cannot get property " + String.valueOf(property) + " as it does not exist in " + String.valueOf((Object)this.block.getBlockState()));
---
>             throw new IllegalArgumentException("Cannot get property " + property + " as it does not exist in " + this.block.getBlockState());
113c117
<             throw new IllegalArgumentException("Cannot set property " + String.valueOf(property) + " as it does not exist in " + String.valueOf((Object)this.block.getBlockState()));
---
>             throw new IllegalArgumentException("Cannot set property " + property + " as it does not exist in " + this.block.getBlockState());
120c124
<             throw new IllegalArgumentException("Cannot set property " + String.valueOf(property) + " to " + String.valueOf(value) + " on block " + String.valueOf((Object)Block.REGISTRY.getNameForObject((Object)this.block)) + ", it is not an allowed value");
---
>             throw new IllegalArgumentException("Cannot set property " + property + " to " + value + " on block " + Block.REGISTRY.getNameForObject((Object)this.block) + ", it is not an allowed value");
150c154
<                 table.put((Object)iproperty, (Object)comparable, (Object)((IBlockState)map.get(this.getPropertiesWithValue(iproperty, comparable))));
---
>                 table.put((Object)iproperty, (Object)comparable, map.get(this.getPropertiesWithValue(iproperty, comparable)));
182d185
<     @SideOnly(value=Side.CLIENT)
207d209
<     @SideOnly(value=Side.CLIENT)
216d217
<     @SideOnly(value=Side.CLIENT)
221d221
<     @SideOnly(value=Side.CLIENT)
270d269
<     @SideOnly(value=Side.CLIENT)
275d273
<     @SideOnly(value=Side.CLIENT)
293a292,297
>         Block.EnumOffsetType offsetType = this.block.getOffsetType();
>         if (offsetType != Block.EnumOffsetType.NONE && !(this.block instanceof BlockFlower)) {
>             AxisAlignedBB aabb = this.block.getBoundingBox((IBlockState)this, blockAccess, pos);
>             aabb = BlockModelUtils.getOffsetBoundingBox((AxisAlignedBB)aabb, (Block.EnumOffsetType)offsetType, (BlockPos)pos);
>             return aabb;
>         }
321,324d324
<     public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, BlockPos pos, EnumFacing facing) {
<         return this.block.getBlockFaceShape(worldIn, (IBlockState)this, pos, facing);
<     }
< 
330c330
<         return this.block.getLightOpacity((IBlockState)this, world, pos);
---
>         return Reflector.callInt((Object)this.block, (ReflectorMethod)Reflector.ForgeBlock_getLightOpacity, (Object[])new Object[]{this, world, pos});
334c334
<         return this.block.getLightValue((IBlockState)this, world, pos);
---
>         return Reflector.callInt((Object)this.block, (ReflectorMethod)Reflector.ForgeBlock_getLightValue, (Object[])new Object[]{this, world, pos});
338c338
<         return this.block.isSideSolid((IBlockState)this, world, pos, side);
---
>         return Reflector.callBoolean((Object)this.block, (ReflectorMethod)Reflector.ForgeBlock_isSideSolid, (Object[])new Object[]{this, world, pos, side});
342c342
<         return this.block.doesSideBlockChestOpening((IBlockState)this, world, pos, side);
---
>         return Reflector.callBoolean((Object)this.block, (ReflectorMethod)Reflector.ForgeBlock_doesSideBlockChestOpening, (Object[])new Object[]{this, world, pos, side});
346c346,350
<         return this.block.doesSideBlockRendering((IBlockState)this, world, pos, side);
---
>         return Reflector.callBoolean((Object)this.block, (ReflectorMethod)Reflector.ForgeBlock_doesSideBlockRendering, (Object[])new Object[]{this, world, pos, side});
>     }
> 
>     public BlockFaceShape getBlockFaceShape(IBlockAccess p_193401_1_, BlockPos p_193401_2_, EnumFacing p_193401_3_) {
>         return this.block.getBlockFaceShape(p_193401_1_, (IBlockState)this, p_193401_2_, p_193401_3_);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/block/state/BlockStateContainer.java ../optifine_patch/src/main/java/net/minecraft/block/state/BlockStateContainer.java
77c77
<         return new StateImplementation(block, properties);
---
>         return new StateImplementation(block, properties, null);
105c105
<             throw new IllegalArgumentException("Block: " + String.valueOf((Object)block.getClass()) + " has invalidly named property: " + s);
---
>             throw new IllegalArgumentException("Block: " + block.getClass() + " has invalidly named property: " + s);
110c110
<             throw new IllegalArgumentException("Block: " + String.valueOf((Object)block.getClass()) + " has property: " + s + " with invalidly named value: " + s1);
---
>             throw new IllegalArgumentException("Block: " + block.getClass() + " has property: " + s + " with invalidly named value: " + s1);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/LoadingScreenRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/LoadingScreenRenderer.java
5d4
<  *  java.io.IOException
8d6
<  *  java.lang.RuntimeException
11d8
<  *  java.lang.Throwable
25,27c22,25
<  *  net.minecraftforge.fml.client.FMLClientHandler
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomLoadingScreen
>  *  net.optifine.CustomLoadingScreens
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
31d28
< import java.io.IOException;
43,45c40,43
< import net.minecraftforge.fml.client.FMLClientHandler;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomLoadingScreen;
> import net.optifine.CustomLoadingScreens;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
47d44
< @SideOnly(value=Side.CLIENT)scaledresolution.getScaledWidth(), scaledresolution.getScaledHeight()
118a116
>                 Object fch;
139,142c137,147
<                 try {
<                     if (!FMLClientHandler.instance().handleLoadingScreen(scaledresolution)) {
<                         Tessellator tessellator = Tessellator.getInstance();
<                         BufferBuilder bufferbuilder = tessellator.getBuffer();
---
>                 boolean render = true;
>                 if (Reflector.FMLClientHandler_handleLoadingScreen.exists() && (fch = Reflector.call((ReflectorMethod)Reflector.FMLClientHandler_instance, (Object[])new Object[0])) != null) {
>                     boolean bl = render = !Reflector.callBoolean((Object)fch, (ReflectorMethod)Reflector.FMLClientHandler_handleLoadingScreen, (Object[])new Object[]{scaledresolution});
>                 }
>                 if (render) {
>                     Tessellator tessellator = Tessellator.getInstance();
>                     BufferBuilder bufferbuilder = tessellator.getBuffer();
>                     CustomLoadingScreen scr = CustomLoadingScreens.getCustomLoadingScreen();
>                     if (scr != null) {
>                         scr.drawBackground(scaledresolution.getScaledWidth(), scaledresolution.getScaledHeight());
>                     } else {
151,172d155
<                         if (progress >= 0) {
<                             int i1 = 100;
<                             int j1 = 2;
<                             int k1 = k / 2 - 50;
<                             int l1 = l / 2 + 16;
<                             GlStateManager.disableTexture2D();
<                             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
<                             bufferbuilder.pos((double)k1, (double)l1, 0.0).color(128, 128, 128, 255).endVertex();
<                             bufferbuilder.pos((double)k1, (double)(l1 + 2), 0.0).color(128, 128, 128, 255).endVertex();
<                             bufferbuilder.pos((double)(k1 + 100), (double)(l1 + 2), 0.0).color(128, 128, 128, 255).endVertex();
<                             bufferbuilder.pos((double)(k1 + 100), (double)l1, 0.0).color(128, 128, 128, 255).endVertex();
<                             bufferbuilder.pos((double)k1, (double)l1, 0.0).color(128, 255, 128, 255).endVertex();
<                             bufferbuilder.pos((double)k1, (double)(l1 + 2), 0.0).color(128, 255, 128, 255).endVertex();
<                             bufferbuilder.pos((double)(k1 + progress), (double)(l1 + 2), 0.0).color(128, 255, 128, 255).endVertex();
<                             bufferbuilder.pos((double)(k1 + progress), (double)l1, 0.0).color(128, 255, 128, 255).endVertex();
<                             tessellator.draw();
<                             GlStateManager.enableTexture2D();
<                         }
<                         GlStateManager.enableBlend();
<                         GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
<                         this.mc.fontRenderer.drawStringWithShadow(this.currentlyDisplayedText, (float)((k - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2), (float)(l / 2 - 4 - 16), 0xFFFFFF);
<                         this.mc.fontRenderer.drawStringWithShadow(this.message, (float)((k - this.mc.fontRenderer.getStringWidth(this.message)) / 2), (float)(l / 2 - 4 + 8), 0xFFFFFF);
174,176c157,178
<                 }
<                 catch (IOException e) {
<                     throw new RuntimeException((Throwable)e);
---
>                     if (progress >= 0) {
>                         int i1 = 100;
>                         int j1 = 2;
>                         int k1 = k / 2 - 50;
>                         int l1 = l / 2 + 16;
>                         GlStateManager.disableTexture2D();
>                         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
>                         bufferbuilder.pos((double)k1, (double)l1, 0.0).color(128, 128, 128, 255).endVertex();
>                         bufferbuilder.pos((double)k1, (double)(l1 + 2), 0.0).color(128, 128, 128, 255).endVertex();
>                         bufferbuilder.pos((double)(k1 + 100), (double)(l1 + 2), 0.0).color(128, 128, 128, 255).endVertex();
>                         bufferbuilder.pos((double)(k1 + 100), (double)l1, 0.0).color(128, 128, 128, 255).endVertex();
>                         bufferbuilder.pos((double)k1, (double)l1, 0.0).color(128, 255, 128, 255).endVertex();
>                         bufferbuilder.pos((double)k1, (double)(l1 + 2), 0.0).color(128, 255, 128, 255).endVertex();
>                         bufferbuilder.pos((double)(k1 + progress), (double)(l1 + 2), 0.0).color(128, 255, 128, 255).endVertex();
>                         bufferbuilder.pos((double)(k1 + progress), (double)l1, 0.0).color(128, 255, 128, 255).endVertex();
>                         tessellator.draw();
>                         GlStateManager.enableTexture2D();
>                     }
>                     GlStateManager.enableBlend();
>                     GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
>                     this.mc.fontRenderer.drawStringWithShadow(this.currentlyDisplayedText, (float)((k - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2), (float)(l / 2 - 4 - 16), 0xFFFFFF);
>                     this.mc.fontRenderer.drawStringWithShadow(this.message, (float)((k - this.mc.fontRenderer.getStringWidth(this.message)) / 2), (float)(l / 2 - 4 + 8), 0xFFFFFF);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/entity/AbstractClientPlayer.java ../optifine_patch/src/main/java/net/minecraft/client/entity/AbstractClientPlayer.java
4a5
>  *  Config
9a11
>  *  java.lang.System
21a24
>  *  net.minecraft.entity.passive.EntityShoulderRiding
28,30c31,34
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.player.CapeUtils
>  *  net.optifine.player.PlayerConfigurations
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
47a52
> import net.minecraft.entity.passive.EntityShoulderRiding;
54,56c59,62
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.player.CapeUtils;
> import net.optifine.player.PlayerConfigurations;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
58d63
< @SideOnly(value=Side.CLIENT)
64a70,76
>     private ResourceLocation locationOfCape = null;
>     private long reloadCapeTimeMs = 0L;
>     private boolean elytraOfCape = false;
>     private String nameClear = null;
>     public EntityShoulderRiding entityShoulderLeft;
>     public EntityShoulderRiding entityShoulderRight;
>     private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");
67a80,85
>         this.nameClear = playerProfile.getName();
>         if (this.nameClear != null && !this.nameClear.isEmpty()) {
>             this.nameClear = StringUtils.stripControlCodes((String)this.nameClear);
>         }
>         CapeUtils.downloadCape((AbstractClientPlayer)this);
>         PlayerConfigurations.getPlayerConfiguration((AbstractClientPlayer)this);
103a122,131
>         if (!Config.isShowCapes()) {
>             return null;
>         }
>         if (this.reloadCapeTimeMs != 0L && System.currentTimeMillis() > this.reloadCapeTimeMs) {
>             CapeUtils.reloadCape((AbstractClientPlayer)this);
>             this.reloadCapeTimeMs = 0L;
>         }
>         if (this.locationOfCape != null) {
>             return this.locationOfCape;
>         }
153c181,223
<         return ForgeHooksClient.getOffsetFOV((EntityPlayer)this, (float)f);
---
>         if (Reflector.ForgeHooksClient_getOffsetFOV.exists()) {
>             return Reflector.callFloat((ReflectorMethod)Reflector.ForgeHooksClient_getOffsetFOV, (Object[])new Object[]{this, Float.valueOf((float)f)});
>         }
>         return f;
>     }
> 
>     public String getNameClear() {
>         return this.nameClear;
>     }
> 
>     public ResourceLocation getLocationOfCape() {
>         return this.locationOfCape;
>     }
> 
>     public void setLocationOfCape(ResourceLocation locationOfCape) {
>         this.locationOfCape = locationOfCape;
>     }
> 
>     public boolean hasElytraCape() {
>         ResourceLocation loc = this.getLocationCape();
>         if (loc == null) {
>             return false;
>         }
>         if (loc == this.locationOfCape) {
>             return this.elytraOfCape;
>         }
>         return true;
>     }
> 
>     public void setElytraOfCape(boolean elytraOfCape) {
>         this.elytraOfCape = elytraOfCape;
>     }
> 
>     public boolean isElytraOfCape() {
>         return this.elytraOfCape;
>     }
> 
>     public long getReloadCapeTimeMs() {
>         return this.reloadCapeTimeMs;
>     }
> 
>     public void setReloadCapeTimeMs(long reloadCapeTimeMs) {
>         this.reloadCapeTimeMs = reloadCapeTimeMs;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/FontRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/gui/FontRenderer.java
5c5
<  *  com.cleanroommc.client.BreakIteratorHolder
---
>  *  Config
13,14d12
<  *  java.lang.CharSequence
<  *  java.lang.Deprecated
21,22c19
<  *  java.util.ArrayList
<  *  java.util.Collections
---
>  *  java.util.Arrays
24a22
>  *  java.util.Properties
28a27,28
>  *  net.minecraft.client.renderer.GlStateManager$DestFactor
>  *  net.minecraft.client.renderer.GlStateManager$SourceFactor
38,39c38,40
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomColors
>  *  net.optifine.render.GlBlendState
>  *  net.optifine.util.FontUtils
44d44
< import com.cleanroommc.client.BreakIteratorHolder;
52,53c52
< import java.util.ArrayList;
< import java.util.Collections;
---
> import java.util.Arrays;
55a55
> import java.util.Properties;
69,70c69,71
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomColors;
> import net.optifine.render.GlBlendState;
> import net.optifine.util.FontUtils;
73d73
< @SideOnly(value=Side.CLIENT)
77c77
<     protected final int[] charWidth = new int[256];
---
>     private final int[] charWidth = new int[256];
80c80
<     protected final byte[] glyphWidth = new byte[65536];
---
>     private final byte[] glyphWidth = new byte[65536];
82c82
<     protected final ResourceLocation locationFontTexture;
---
>     private ResourceLocation locationFontTexture;
84,85c84,85
<     protected float posX;
<     protected float posY;
---
>     private float posX;
>     private float posY;
97a98,103
>     public GameSettings gameSettings;
>     public ResourceLocation locationFontTextureBase;
>     public float offsetBold = 1.0f;
>     private float[] charWidthFloat = new float[256];
>     private boolean blend = false;
>     private GlBlendState oldBlendState = new GlBlendState();
99a106,107
>         this.gameSettings = gameSettingsIn;
>         this.locationFontTextureBase = location;
102a111
>         this.locationFontTexture = FontUtils.getHdFontLocation((ResourceLocation)this.locationFontTextureBase);
130a140,143
>         this.locationFontTexture = FontUtils.getHdFontLocation((ResourceLocation)this.locationFontTextureBase);
>         for (int i = 0; i < UNICODE_PAGE_LOCATIONS.length; ++i) {
>             FontRenderer.UNICODE_PAGE_LOCATIONS[i] = null;
>         }
152,173c165,192
<         int lvt_3_2_ = bufferedimage.getWidth();
<         int lvt_4_1_ = bufferedimage.getHeight();
<         int[] lvt_5_1_ = new int[lvt_3_2_ * lvt_4_1_];
<         bufferedimage.getRGB(0, 0, lvt_3_2_, lvt_4_1_, lvt_5_1_, 0, lvt_3_2_);
<         int lvt_6_1_ = lvt_4_1_ / 16;
<         int lvt_7_1_ = lvt_3_2_ / 16;
<         boolean lvt_8_1_ = true;
<         float lvt_9_1_ = 8.0f / (float)lvt_7_1_;
<         for (int lvt_10_1_ = 0; lvt_10_1_ < 256; ++lvt_10_1_) {
<             int l1;
<             int j1 = lvt_10_1_ % 16;
<             int k1 = lvt_10_1_ / 16;
<             if (lvt_10_1_ == 32) {
<                 this.charWidth[lvt_10_1_] = 4;
<             }
<             for (l1 = lvt_7_1_ - 1; l1 >= 0; --l1) {
<                 int i2 = j1 * lvt_7_1_ + l1;
<                 boolean flag1 = true;
<                 for (int j2 = 0; j2 < lvt_6_1_ && flag1; ++j2) {
<                     int k2 = (k1 * lvt_7_1_ + j2) * lvt_3_2_;
<                     if ((lvt_5_1_[i2 + k2] >> 24 & 0xFF) == 0) continue;
<                     flag1 = false;
---
>         Properties props = FontUtils.readFontProperties((ResourceLocation)this.locationFontTexture);
>         this.blend = FontUtils.readBoolean((Properties)props, (String)"blend", (boolean)false);
>         int imgWidth = bufferedimage.getWidth();
>         int imgHeight = bufferedimage.getHeight();
>         int charW = imgWidth / 16;
>         int charH = imgHeight / 16;
>         float kx = (float)imgWidth / 128.0f;
>         float boldScaleFactor = Config.limit((float)kx, (float)1.0f, (float)2.0f);
>         this.offsetBold = 1.0f / boldScaleFactor;
>         float offsetBoldConfig = FontUtils.readFloat((Properties)props, (String)"offsetBold", (float)-1.0f);
>         if (offsetBoldConfig >= 0.0f) {
>             this.offsetBold = offsetBoldConfig;
>         }
>         int[] ai = new int[imgWidth * imgHeight];
>         bufferedimage.getRGB(0, 0, imgWidth, imgHeight, ai, 0, imgWidth);
>         for (int k = 0; k < 256; ++k) {
>             int cx = k % 16;
>             int cy = k / 16;
>             int px = 0;
>             for (px = charW - 1; px >= 0; --px) {
>                 int x = cx * charW + px;
>                 boolean flag = true;
>                 for (int py = 0; py < charH && flag; ++py) {
>                     int ypos = (cy * charH + py) * imgWidth;
>                     int col = ai[x + ypos];
>                     int al = col >> 24 & 0xFF;
>                     if (al <= 16) continue;
>                     flag = false;
175c194,200
<                 if (!flag1) break;
---
>                 if (!flag) break;
>             }
>             if (k == 65) {
>                 // empty if block
>             }
>             if (k == 32) {
>                 px = charW <= 8 ? (int)(2.0f * kx) : (int)(1.5f * kx);
177c202,206
<             this.charWidth[lvt_10_1_] = (int)(0.5 + (double)((float)(++l1) * lvt_9_1_)) + 1;
---
>             this.charWidthFloat[k] = (float)(px + 1) / kx + 1.0f;
>         }
>         FontUtils.readCustomCharWidths((Properties)props, (float[])this.charWidthFloat);
>         for (int i = 0; i < this.charWidth.length; ++i) {
>             this.charWidth[i] = Math.round((float)this.charWidthFloat[i]);
200,203c229,232
<         if (ch == '\u00a0') {
<             return 4.0f;
<         }
<         if (ch == ' ') {
---
>         if (ch == ' ' || ch == '\u00a0') {
>             if (!this.unicodeFlag) {
>                 return this.charWidthFloat[ch];
>             }
210c239
<     protected float renderDefaultChar(int ch, boolean italic) {
---
>     private float renderDefaultChar(int ch, boolean italic) {
215,216c244,245
<         int l = this.charWidth[ch];
<         float f = (float)l - 0.01f;
---
>         float l = this.charWidthFloat[ch];
>         float f = 7.99f;
232a262
>             FontRenderer.UNICODE_PAGE_LOCATIONS[page] = FontUtils.getHdFontLocation((ResourceLocation)UNICODE_PAGE_LOCATIONS[page]);
241c271
<     protected float renderUnicodeChar(char ch, boolean italic) {
---
>     private float renderUnicodeChar(char ch, boolean italic) {
279a310,314
>         if (this.blend) {
>             GlStateManager.getBlendState((GlBlendState)this.oldBlendState);
>             GlStateManager.enableBlend();
>             GlStateManager.blendFunc((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
>         }
286a322,324
>         if (this.blend) {
>             GlStateManager.setBlendState((GlBlendState)this.oldBlendState);
>         }
296c334
<         catch (ArabicShapingException arabicshapingexception) {
---
>         catch (ArabicShapingException var3) {
313c351
<             if (c0 == '\u00a7' && i + 1 < text.length() && (FontRenderer.isFormatColor(text.charAt(i + 1)) || FontRenderer.isFormatSpecial(text.charAt(i + 1)))) {
---
>             if (c0 == '\u00a7' && i + 1 < text.length()) {
316d353
<                     int j1;
321a359,361
>                     if (i1 < 0 || i1 > 15) {
>                         i1 = 15;
>                     }
325c365,369
<                     this.textColor = j1 = this.colorCode[i1];
---
>                     int j1 = this.colorCode[i1];
>                     if (Config.isCustomColors()) {
>                         j1 = CustomColors.getTextColor((int)i1, (int)j1);
>                     }
>                     this.textColor = j1;
356c400
<             float f1 = j == -1 || this.unicodeFlag ? 0.5f : 1.0f;
---
>             float f1 = j == -1 || this.unicodeFlag ? 0.5f : this.offsetBold;
379c423
<                 f += 1.0f;
---
>                 f += f1;
411c455
<         this.posX += (float)((int)f);
---
>         this.posX += f;
450c494
<         int i = 0;
---
>         float i = 0.0f;
454,456c498,504
<             int k = this.getCharWidth(c0);
<             if (k < 0 && j < text.length() - 1) {
<                 if ((c0 = text.charAt(++j)) == 'l' || c0 == 'L') {
---
>             float k = this.getCharWidthFloat(c0);
>             if (k < 0.0f && j < text.length() - 1) {
>                 if ((c0 = text.charAt(++j)) != 'l' && c0 != 'L') {
>                     if (c0 == 'r' || c0 == 'R') {
>                         flag = false;
>                     }
>                 } else {
458,459d505
<                 } else if (c0 == 'r' || c0 == 'R') {
<                     flag = false;
461c507
<                 k = 0;
---
>                 k = 0.0f;
464,465c510,511
<             if (!flag || k <= 0) continue;
<             ++i;
---
>             if (!flag || !(k > 0.0f)) continue;
>             i += this.unicodeFlag ? 1.0f : this.offsetBold;
467c513
<         return i;
---
>         return Math.round((float)i);
471,473c517,520
<         if (character == '\u00a0') {
<             return 4;
<         }
---
>         return Math.round((float)this.getCharWidthFloat(character));
>     }
> 
>     private float getCharWidthFloat(char character) {
475c522
<             return -1;
---
>             return -1.0f;
477,478c524,525
<         if (character == ' ') {
<             return 4;
---
>         if (character == ' ' || character == '\u00a0') {
>             return this.charWidthFloat[32];
482c529
<             return this.charWidth[i];
---
>             return this.charWidthFloat[i];
490c537
<         return 0;
---
>         return 0.0f;
499c546
<         int i = 0;
---
>         float i = 0.0f;
504c551
<         for (int l = j; l >= 0 && l < text.length() && i < width; l += k) {
---
>         for (int l = j; l >= 0 && l < text.length() && i < (float)width; l += k) {
506c553
<             int i1 = this.getCharWidth(c0);
---
>             float i1 = this.getCharWidthFloat(c0);
516c563
<             } else if (i1 < 0) {
---
>             } else if (i1 < 0.0f) {
521c568
<                     ++i;
---
>                     i += 1.0f;
524c571
<             if (i > width) break;
---
>             if (i > (float)width) break;
535c582
<         while (text.endsWith("\n")) {
---
>         while (text != null && text.endsWith("\n")) {
541a589,593
>         if (this.blend) {
>             GlStateManager.getBlendState((GlBlendState)this.oldBlendState);
>             GlStateManager.enableBlend();
>             GlStateManager.blendFunc((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
>         }
545a598,600
>         if (this.blend) {
>             GlStateManager.setBlendState((GlBlendState)this.oldBlendState);
>         }
572,654c627
<         if (str.isEmpty()) {
<             return Collections.singletonList((Object)"");
<         }
<         BreakIteratorHolder.BREAK_ITERATOR.setText(str);
<         ArrayList list = new ArrayList();
<         int lineWidth = 0;
<         int fed = 0;
<         int prevFormat = 0;
<         StringBuilder format = new StringBuilder();
<         int[] widths = new int[str.length()];
<         String[] formats = new String[str.length()];
<         StringBuilder line = new StringBuilder();
<         char[] chars = str.toCharArray();
<         boolean bold = false;
<         block4: for (int i = 0; i < chars.length; ++i) {
<             char current = chars[i];
<             switch (current) {
<                 case '\n': {
<                     list.add((Object)line.toString());
<                     fed = i + 1;
<                     line.delete(0, line.length()).append((CharSequence)format);
<                     prevFormat = format.length();
<                     widths[0] = lineWidth = 0;
<                     formats[0] = format.toString();
<                     continue block4;
<                 }
<                 case '\u00a7': {
<                     char f;
<                     boolean isC;
<                     if (i + 1 < chars.length && ((isC = FontRenderer.isFormatColor(f = chars[i + 1])) || FontRenderer.isFormatSpecial(f))) {
<                         if (f != 'l' && f != 'L') {
<                             if (f == 'r' || f == 'R') {
<                                 bold = false;
<                                 format.delete(0, format.length());
<                             } else if (isC) {
<                                 bold = false;
<                             }
<                         } else {
<                             bold = true;
<                         }
<                         format.append('\u00a7').append(f);
<                         line.append('\u00a7').append(f);
<                         widths[i - fed] = lineWidth;
<                         widths[i - fed + 1] = lineWidth;
<                         formats[i - fed] = format.toString();
<                         formats[i - fed + 1] = format.toString();
<                         ++i;
<                         continue block4;
<                     }
<                 }
<                 default: {
<                     line.append(current);
<                     lineWidth += this.getCharWidth(current);
<                     if (bold) {
<                         // empty if block
<                     }
<                     widths[i - fed] = ++lineWidth;
<                     formats[i - fed] = format.toString();
<                     if (lineWidth <= wrapWidth) continue block4;
<                     int icui = BreakIteratorHolder.BREAK_ITERATOR.isBoundary(i) ? i : BreakIteratorHolder.BREAK_ITERATOR.preceding(i);
<                     if (icui <= fed + 1 || i == icui) {
<                         list.add((Object)line.substring(0, line.length() - 1));
<                         fed = i;
<                         line.delete(0, line.length()).append((CharSequence)format).append(current);
<                         prevFormat = format.length();
<                         lineWidth = this.getCharWidth(current);
<                         continue block4;
<                     }
<                     int d = icui - fed;
<                     if (line.charAt(d + prevFormat - 2) == '\u00a7') {
<                         ++d;
<                     }
<                     list.add((Object)line.substring(0, d + prevFormat));
<                     String temp = line.substring(d + prevFormat);
<                     fed += d;
<                     line.delete(0, line.length()).append(formats[d]).append(temp);
<                     prevFormat = formats[d].length();
<                     lineWidth -= widths[d - 1];
<                 }
<             }
<         }
<         list.add((Object)line.toString());
<         return list;
---
>         return Arrays.asList((Object[])this.wrapFormattedStringToWidth(str, wrapWidth).split("\n"));
657d629
<     @Deprecated
658a631,633
>         if (str.length() <= 1) {
>             return str;
>         }
670d644
<     @Deprecated
674c648
<         int j = 0;
---
>         float j = 0.0f;
684,692d657
<                 case ' ': {
<                     l = k;
<                 }
<                 default: {
<                     j += this.getCharWidth(c0);
<                     if (!flag) break;
<                     ++j;
<                     break;
<                 }
696,697c661,663
<                     if ((c1 = str.charAt(++k)) == 'l' || c1 == 'L') {
<                         flag = true;
---
>                     if ((c1 = str.charAt(++k)) != 'l' && c1 != 'L') {
>                         if (c1 != 'r' && c1 != 'R' && !FontRenderer.isFormatColor(c1)) break;
>                         flag = false;
700,701c666,675
<                     if (c1 != 'r' && c1 != 'R' && !FontRenderer.isFormatColor(c1)) break;
<                     flag = false;
---
>                     flag = true;
>                     break;
>                 }
>                 case ' ': {
>                     l = k;
>                 }
>                 default: {
>                     j += this.getCharWidthFloat(c0);
>                     if (!flag) break;
>                     j += 1.0f;
708c682
<             if (j > wrapWidth) break;
---
>             if (Math.round((float)j) > wrapWidth) break;
741a716,727
>     public int getColorCode(char character) {
>         int i = "0123456789abcdef".indexOf((int)character);
>         if (i < 0 || i >= this.colorCode.length) {
>             return 0xFFFFFF;
>         }
>         int color = this.colorCode[i];
>         if (Config.isCustomColors()) {
>             color = CustomColors.getTextColor((int)i, (int)color);
>         }
>         return color;
>     }
> 
756,760d741
<     }
< 
<     public int getColorCode(char character) {
<         int i = "0123456789abcdef".indexOf((int)character);
<         return i >= 0 && i < this.colorCode.length ? this.colorCode[i] : -1;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiCustomizeSkin.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiCustomizeSkin.java
4a5
>  *  java.io.IOException
13a15,16
>  *  net.optifine.gui.GuiButtonOF
>  *  net.optifine.gui.GuiScreenCapeOF
16a20
> import java.io.IOException;
23a28,29
> import net.optifine.gui.GuiButtonOF;
> import net.optifine.gui.GuiScreenCapeOF;
33,34c39,40
<     public GuiCustomizeSkin(GuiScreen guiScreen) {
<         this.parentScreen = guiScreen;
---
>     public GuiCustomizeSkin(GuiScreen parentScreenIn) {
>         this.parentScreen = parentScreenIn;
38c44
<         int n = 0;
---
>         int i = 0;
40,42c46,48
<         for (EnumPlayerModelParts enumPlayerModelParts : EnumPlayerModelParts.values()) {
<             this.buttonList.add((Object)new ButtonPart(this, enumPlayerModelParts.getPartId(), this.width / 2 - 155 + n % 2 * 160, this.height / 6 + 24 * (n >> 1), 150, 20, enumPlayerModelParts, null));
<             ++n;
---
>         for (EnumPlayerModelParts enumplayermodelparts : EnumPlayerModelParts.values()) {
>             this.buttonList.add((Object)new ButtonPart(this, enumplayermodelparts.getPartId(), this.width / 2 - 155 + i % 2 * 160, this.height / 6 + 24 * (i >> 1), 150, 20, enumplayermodelparts, null));
>             ++i;
44,46c50,52
<         this.buttonList.add((Object)new GuiOptionButton(199, this.width / 2 - 155 + n % 2 * 160, this.height / 6 + 24 * (n >> 1), GameSettings.Options.MAIN_HAND, this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND)));
<         if (++n % 2 == 1) {
<             ++n;
---
>         this.buttonList.add((Object)new GuiOptionButton(199, this.width / 2 - 155 + i % 2 * 160, this.height / 6 + 24 * (i >> 1), GameSettings.Options.MAIN_HAND, this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND)));
>         if (++i % 2 == 1) {
>             ++i;
48c54,55
<         this.buttonList.add((Object)new GuiButton(200, this.width / 2 - 100, this.height / 6 + 24 * (n >> 1), I18n.format((String)"gui.done", (Object[])new Object[0])));
---
>         this.buttonList.add((Object)new GuiButtonOF(210, this.width / 2 - 100, this.height / 6 + 24 * (i >> 1), I18n.format((String)"of.options.skinCustomisation.ofCape", (Object[])new Object[0])));
>         this.buttonList.add((Object)new GuiButton(200, this.width / 2 - 100, this.height / 6 + 24 * ((i += 2) >> 1), I18n.format((String)"gui.done", (Object[])new Object[0])));
51,52c58,59
<     protected void keyTyped(char c, int n) {
<         if (n == 1) {
---
>     protected void keyTyped(char typedChar, int keyCode) throws IOException {
>         if (keyCode == 1) {
55c62
<         super.keyTyped(c, n);
---
>         super.keyTyped(typedChar, keyCode);
58,72c65,81
<     protected void actionPerformed(GuiButton guiButton) {
<         if (!guiButton.enabled) {
<             return;
<         }
<         if (guiButton.id == 200) {
<             this.mc.gameSettings.saveOptions();
<             this.mc.displayGuiScreen(this.parentScreen);
<         } else if (guiButton.id == 199) {
<             this.mc.gameSettings.setOptionValue(GameSettings.Options.MAIN_HAND, 1);
<             guiButton.displayString = this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND);
<             this.mc.gameSettings.sendSettingsToServer();
<         } else if (guiButton instanceof ButtonPart) {
<             EnumPlayerModelParts enumPlayerModelParts = ButtonPart.access$100((ButtonPart)((ButtonPart)guiButton));
<             this.mc.gameSettings.switchModelPartEnabled(enumPlayerModelParts);
<             guiButton.displayString = this.getMessage(enumPlayerModelParts);
---
>     protected void actionPerformed(GuiButton button) throws IOException {
>         if (button.enabled) {
>             if (button.id == 210) {
>                 this.mc.displayGuiScreen((GuiScreen)new GuiScreenCapeOF((GuiScreen)this));
>             }
>             if (button.id == 200) {
>                 this.mc.gameSettings.saveOptions();
>                 this.mc.displayGuiScreen(this.parentScreen);
>             } else if (button.id == 199) {
>                 this.mc.gameSettings.setOptionValue(GameSettings.Options.MAIN_HAND, 1);
>                 button.displayString = this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND);
>                 this.mc.gameSettings.sendSettingsToServer();
>             } else if (button instanceof ButtonPart) {
>                 EnumPlayerModelParts enumplayermodelparts = ButtonPart.access$100((ButtonPart)((ButtonPart)button));
>                 this.mc.gameSettings.switchModelPartEnabled(enumplayermodelparts);
>                 button.displayString = this.getMessage(enumplayermodelparts);
>             }
76c85
<     public void drawScreen(int n, int n2, float f) {
---
>     public void drawScreen(int mouseX, int mouseY, float partialTicks) {
79c88
<         super.drawScreen(n, n2, f);
---
>         super.drawScreen(mouseX, mouseY, partialTicks);
82,84c91,93
<     private String getMessage(EnumPlayerModelParts enumPlayerModelParts) {
<         String string = this.mc.gameSettings.getModelParts().contains((Object)enumPlayerModelParts) ? I18n.format((String)"options.on", (Object[])new Object[0]) : I18n.format((String)"options.off", (Object[])new Object[0]);
<         return enumPlayerModelParts.getName().getFormattedText() + ": " + string;
---
>     private String getMessage(EnumPlayerModelParts playerModelParts) {
>         String s = this.mc.gameSettings.getModelParts().contains((Object)playerModelParts) ? I18n.format((String)"options.on", (Object[])new Object[0]) : I18n.format((String)"options.off", (Object[])new Object[0]);
>         return playerModelParts.getName().getFormattedText() + ": " + s;
87,88c96,97
<     static /* synthetic */ String access$200(GuiCustomizeSkin guiCustomizeSkin, EnumPlayerModelParts enumPlayerModelParts) {
<         return guiCustomizeSkin.getMessage(enumPlayerModelParts);
---
>     static /* synthetic */ String access$200(GuiCustomizeSkin x0, EnumPlayerModelParts x1) {
>         return x0.getMessage(x1);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiDownloadTerrain.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiDownloadTerrain.java
8a9,10
>  *  net.optifine.CustomLoadingScreen
>  *  net.optifine.CustomLoadingScreens
13a16,17
> import net.optifine.CustomLoadingScreen;
> import net.optifine.CustomLoadingScreens;
16a21,22
>     private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
> 
21,22c27,32
<     public void drawScreen(int n, int n2, float f) {
<         this.drawBackground(0);
---
>     public void drawScreen(int mouseX, int mouseY, float partialTicks) {
>         if (this.customLoadingScreen != null) {
>             this.customLoadingScreen.drawBackground(this.width, this.height);
>         } else {
>             this.drawBackground(0);
>         }
24c34
<         super.drawScreen(n, n2, f);
---
>         super.drawScreen(mouseX, mouseY, partialTicks);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiIngame.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiIngame.java
4a5
>  *  Config
9a11
>  *  java.lang.Float
79,80c81,86
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomColors
>  *  net.optifine.CustomItems
>  *  net.optifine.TextureAnimations
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
151,152c157,162
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomColors;
> import net.optifine.CustomItems;
> import net.optifine.TextureAnimations;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
154d163
< @SideOnly(value=Side.CLIENT)
157,167c166,176
<     protected static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
<     protected static final ResourceLocation WIDGETS_TEX_PATH = new ResourceLocation("textures/gui/widgets.png");
<     protected static final ResourceLocation PUMPKIN_BLUR_TEX_PATH = new ResourceLocation("textures/misc/pumpkinblur.png");
<     protected final Random rand = new Random();
<     protected final Minecraft mc;
<     protected final RenderItem itemRenderer;
<     protected final GuiNewChat persistantChatGUI;
<     protected int updateCounter;
<     protected String overlayMessage = "";
<     protected int overlayMessageTime;
<     protected boolean animateOverlayMessageColor;
---
>     private static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
>     private static final ResourceLocation WIDGETS_TEX_PATH = new ResourceLocation("textures/gui/widgets.png");
>     private static final ResourceLocation PUMPKIN_BLUR_TEX_PATH = new ResourceLocation("textures/misc/pumpkinblur.png");
>     private final Random rand = new Random();
>     private final Minecraft mc;
>     private final RenderItem itemRenderer;
>     private final GuiNewChat persistantChatGUI;
>     private int updateCounter;
>     private String overlayMessage = "";
>     private int overlayMessageTime;
>     private boolean animateOverlayMessageColor;
169,186c178,195
<     protected int remainingHighlightTicks;
<     protected ItemStack highlightingItemStack = ItemStack.EMPTY;
<     protected final GuiOverlayDebug overlayDebug;
<     protected final GuiSubtitleOverlay overlaySubtitle;
<     protected final GuiSpectator spectatorGui;
<     protected final GuiPlayerTabOverlay overlayPlayerList;
<     protected final GuiBossOverlay overlayBoss;
<     protected int titlesTimer;
<     protected String displayedTitle = "";
<     protected String displayedSubTitle = "";
<     protected int titleFadeIn;
<     protected int titleDisplayTime;
<     protected int titleFadeOut;
<     protected int playerHealth;
<     protected int lastPlayerHealth;
<     protected long lastSystemTime;
<     protected long healthUpdateCounter;
<     protected final Map<ChatType, List<IChatListener>> chatListeners = Maps.newHashMap();
---
>     private int remainingHighlightTicks;
>     private ItemStack highlightingItemStack = ItemStack.EMPTY;
>     private final GuiOverlayDebug overlayDebug;
>     private final GuiSubtitleOverlay overlaySubtitle;
>     private final GuiSpectator spectatorGui;
>     private final GuiPlayerTabOverlay overlayPlayerList;
>     private final GuiBossOverlay overlayBoss;
>     private int titlesTimer;
>     private String displayedTitle = "";
>     private String displayedSubTitle = "";
>     private int titleFadeIn;
>     private int titleDisplayTime;
>     private int titleFadeOut;
>     private int playerHealth;
>     private int lastPlayerHealth;
>     private long lastSystemTime;
>     private long healthUpdateCounter;
>     private final Map<ChatType, List<IChatListener>> chatListeners = Maps.newHashMap();
224c233
<         if (Minecraft.isFancyGraphicsEnabled()) {
---
>         if (Config.isVignetteEnabled()) {
245a255
>         GlStateManager.enableAlpha();
375c385
<     protected void renderAttackIndicator(float partialTicks, ScaledResolution p_184045_2_) {
---
>     private void renderAttackIndicator(float p_184045_1_, ScaledResolution p_184045_2_) {
385c395
<                 if (!state.getBlock().hasTileEntity(state) || !(this.mc.world.getTileEntity(blockpos) instanceof IInventory)) {
---
>                 if (!ReflectorForge.blockHasTileEntity((IBlockState)state) || !(this.mc.world.getTileEntity(blockpos) instanceof IInventory)) {
395,396c405,406
<                 GlStateManager.rotate((float)(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks), (float)-1.0f, (float)0.0f, (float)0.0f);
<                 GlStateManager.rotate((float)(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks), (float)0.0f, (float)1.0f, (float)0.0f);
---
>                 GlStateManager.rotate((float)(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * p_184045_1_), (float)-1.0f, (float)0.0f, (float)0.0f);
>                 GlStateManager.rotate((float)(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * p_184045_1_), (float)0.0f, (float)1.0f, (float)0.0f);
434,436c444,450
<                 if (!potion.shouldRenderHUD(potioneffect)) continue;
<                 this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
<                 if (!potioneffect.doesShowParticles()) continue;
---
>                 boolean potionHasIcon = potion.hasStatusIcon();
>                 if (Reflector.ForgePotion_shouldRenderHUD.exists()) {
>                     if (!Reflector.callBoolean((Object)potion, (ReflectorMethod)Reflector.ForgePotion_shouldRenderHUD, (Object[])new Object[]{potioneffect})) continue;
>                     this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
>                     potionHasIcon = true;
>                 }
>                 if (!potionHasIcon || !potioneffect.doesShowParticles()) continue;
461,462c475,480
<                 if (potion.hasStatusIcon()) {
<                     this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
---
>                 if (Reflector.ForgePotion_renderHUDEffect.exists()) {
>                     if (potion.hasStatusIcon()) {
>                         this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
>                     }
>                     Reflector.call((Object)potion, (ReflectorMethod)Reflector.ForgePotion_renderHUDEffect, (Object[])new Object[]{potioneffect, this, k, l, Float.valueOf((float)this.zLevel), Float.valueOf((float)f)});
>                     continue;
464c482
<                 potion.renderHUDEffect(potioneffect, (Gui)this, k, l, this.zLevel, f);
---
>                 this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
495a514
>             CustomItems.setRenderOffHand((boolean)false);
501a521
>                 CustomItems.setRenderOffHand((boolean)true);
507a528
>                 CustomItems.setRenderOffHand((boolean)false);
556a578,581
>             int col = 8453920;
>             if (Config.isCustomColors()) {
>                 col = CustomColors.getExpBarTextColor((int)col);
>             }
564c589
<             this.getFontRenderer().drawString(s, i1, j1, 8453920);
---
>             this.getFontRenderer().drawString(s, i1, j1, col);
575c600
<                 s = String.valueOf((Object)TextFormatting.ITALIC) + s;
---
>                 s = TextFormatting.ITALIC + s;
605c630
<     protected void renderScoreboard(ScoreObjective objective, ScaledResolution scaledRes) {
---
>     private void renderScoreboard(ScoreObjective objective, ScaledResolution scaledRes) {
613c638
<             String s = ScorePlayerTeam.formatPlayerName((Team)scoreplayerteam, (String)score.getPlayerName()) + ": " + String.valueOf((Object)TextFormatting.RED) + score.getScorePoints();
---
>             String s = ScorePlayerTeam.formatPlayerName((Team)scoreplayerteam, (String)score.getPlayerName()) + ": " + TextFormatting.RED + score.getScorePoints();
624c649
<             String s2 = String.valueOf((Object)TextFormatting.RED) + score1.getScorePoints();
---
>             String s2 = TextFormatting.RED + "" + score1.getScorePoints();
638c663
<     protected void renderPlayerStats(ScaledResolution scaledRes) {
---
>     private void renderPlayerStats(ScaledResolution scaledRes) {
780c805
<     protected void renderMountHealth(ScaledResolution p_184047_1_) {
---
>     private void renderMountHealth(ScaledResolution p_184047_1_) {
817c842
<     protected void renderPumpkinOverlay(ScaledResolution scaledRes) {
---
>     private void renderPumpkinOverlay(ScaledResolution scaledRes) {
838c863,868
<     protected void renderVignette(float lightLevel, ScaledResolution scaledRes) {
---
>     private void renderVignette(float lightLevel, ScaledResolution scaledRes) {
>         if (!Config.isVignetteEnabled()) {
>             GlStateManager.enableDepth();
>             GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
>             return;
>         }
870c900
<     protected void renderPortal(float timeInPortal, ScaledResolution scaledRes) {
---
>     private void renderPortal(float timeInPortal, ScaledResolution scaledRes) {
901c931
<     protected void renderHotbarItem(int x, int y, float partialTicks, EntityPlayer player, ItemStack stack) {
---
>     private void renderHotbarItem(int p_184044_1_, int p_184044_2_, float p_184044_3_, EntityPlayer player, ItemStack stack) {
903c933
<             float f = (float)stack.getAnimationsToGo() - partialTicks;
---
>             float f = (float)stack.getAnimationsToGo() - p_184044_3_;
907c937
<                 GlStateManager.translate((float)(x + 8), (float)(y + 12), (float)0.0f);
---
>                 GlStateManager.translate((float)(p_184044_1_ + 8), (float)(p_184044_2_ + 12), (float)0.0f);
909c939
<                 GlStateManager.translate((float)(-(x + 8)), (float)(-(y + 12)), (float)0.0f);
---
>                 GlStateManager.translate((float)(-(p_184044_1_ + 8)), (float)(-(p_184044_2_ + 12)), (float)0.0f);
911c941
<             this.itemRenderer.renderItemAndEffectIntoGUI((EntityLivingBase)player, stack, x, y);
---
>             this.itemRenderer.renderItemAndEffectIntoGUI((EntityLivingBase)player, stack, p_184044_1_, p_184044_2_);
915c945
<             this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, stack, x, y);
---
>             this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, stack, p_184044_1_, p_184044_2_);
919a950,952
>         if (this.mc.world == null) {
>             TextureAnimations.updateAnimations();
>         }
986,988c1019,1021
<     public void addChatMessage(ChatType chatTypeIn, ITextComponent message) {
<         for (IChatListener ichatlistener : (List)this.chatListeners.get((Object)chatTypeIn)) {
<             ichatlistener.say(chatTypeIn, message);
---
>     public void addChatMessage(ChatType p_191742_1_, ITextComponent p_191742_2_) {
>         for (IChatListener ichatlistener : (List)this.chatListeners.get((Object)p_191742_1_)) {
>             ichatlistener.say(p_191742_1_, p_191742_2_);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiMainMenu.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiMainMenu.java
12a13
>  *  java.lang.CharSequence
27d27
<  *  net.minecraft.client.gui.FontRenderer
48a49,50
>  *  net.minecraft.client.settings.GameSettings$Options
>  *  net.minecraft.realms.RealmsBridge
56,61c58,62
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.client.gui.NotificationModUpdateScreen
<  *  net.minecraftforge.fml.client.GuiModList
<  *  net.minecraftforge.fml.common.FMLCommonHandler
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomPanorama
>  *  net.optifine.CustomPanoramaProperties
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorMethod
87d87
< import net.minecraft.client.gui.FontRenderer;
106a107,108
> import net.minecraft.client.settings.GameSettings;
> import net.minecraft.realms.RealmsBridge;
114,119c116,120
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.client.gui.NotificationModUpdateScreen;
< import net.minecraftforge.fml.client.GuiModList;
< import net.minecraftforge.fml.common.FMLCommonHandler;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomPanorama;
> import net.optifine.CustomPanoramaProperties;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorMethod;
127d127
< @SideOnly(value=Side.CLIENT)
138c138
<     public static final String MORE_INFO_TEXT = "Please click " + String.valueOf((Object)TextFormatting.UNDERLINE) + "here" + String.valueOf((Object)TextFormatting.RESET) + " for more information.";
---
>     public static final String MORE_INFO_TEXT = "Please click " + TextFormatting.UNDERLINE + "here" + TextFormatting.RESET + " for more information.";
159c159
<     private NotificationModUpdateScreen modUpdateNotification;
---
>     private GuiScreen modUpdateNotification;
204c204,210
<         return false;
---
>         return Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && this.realmsNotification != null;
>     }
> 
>     public void updateScreen() {
>         if (this.areRealmsNotificationsEnabled()) {
>             this.realmsNotification.updateScreen();
>         }
252c258,269
<         this.modUpdateNotification = NotificationModUpdateScreen.init((GuiMainMenu)this, (GuiButton)this.modButton);
---
>         if (Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && !this.hasCheckedForRealmsNotification) {
>             RealmsBridge realmsbridge = new RealmsBridge();
>             this.realmsNotification = realmsbridge.getNotificationScreen((GuiScreen)this);
>             this.hasCheckedForRealmsNotification = true;
>         }
>         if (this.areRealmsNotificationsEnabled()) {
>             this.realmsNotification.setGuiSize(this.width, this.height);
>             this.realmsNotification.initGui();
>         }
>         if (Reflector.NotificationModUpdateScreen_init.exists()) {
>             this.modUpdateNotification = (GuiScreen)Reflector.call((ReflectorMethod)Reflector.NotificationModUpdateScreen_init, (Object[])new Object[]{this, this.modButton});
>         }
258,259c275,281
<         this.modButton = new GuiButton(6, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 2, I18n.format((String)"fml.menu.mods", (Object[])new Object[0]));
<         this.buttonList.add((Object)this.modButton);
---
>         if (Reflector.GuiModList_Constructor.exists()) {
>             this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 + 2, p_73969_1_ + p_73969_2_ * 2, 98, 20, I18n.format((String)"menu.online", (Object[])new Object[0]).replace((CharSequence)"Minecraft", (CharSequence)"").trim()));
>             this.modButton = new GuiButton(6, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 2, 98, 20, I18n.format((String)"fml.menu.mods", (Object[])new Object[0]));
>             this.buttonList.add((Object)this.modButton);
>         } else {
>             this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 2, I18n.format((String)"menu.online", (Object[])new Object[0])));
>         }
286a309,311
>         if (button.id == 14 && this.realmsButton.visible) {
>             this.switchToRealms();
>         }
290,291c315,316
<         if (button.id == 6) {
<             this.mc.displayGuiScreen((GuiScreen)new GuiModList((GuiScreen)this));
---
>         if (button.id == 6 && Reflector.GuiModList_Constructor.exists()) {
>             this.mc.displayGuiScreen((GuiScreen)Reflector.newInstance((ReflectorConstructor)Reflector.GuiModList_Constructor, (Object[])new Object[]{this}));
301a327,328
>         RealmsBridge realmsbridge = new RealmsBridge();
>         realmsbridge.switchToRealms((GuiScreen)this);
346c373,378
<         for (int j = 0; j < 64; ++j) {
---
>         int blurCount1 = 64;
>         CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
>         if (cpp != null) {
>             blurCount1 = cpp.getBlur1();
>         }
>         for (int j = 0; j < blurCount1; ++j) {
371c403,407
<                 this.mc.getTextureManager().bindTexture(TITLE_PANORAMA_PATHS[k]);
---
>                 ResourceLocation[] panoramaLocations = TITLE_PANORAMA_PATHS;
>                 if (cpp != null) {
>                     panoramaLocations = cpp.getPanoramaLocations();
>                 }
>                 this.mc.getTextureManager().bindTexture(panoramaLocations[k]);
409c445,450
<         for (int j = 0; j < 3; ++j) {
---
>         int blurCount2 = 3;
>         CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
>         if (cpp != null) {
>             blurCount2 = cpp.getBlur2();
>         }
>         for (int j = 0; j < blurCount2; ++j) {
429,434c470,478
<         this.rotateAndBlurSkybox();
<         this.rotateAndBlurSkybox();
<         this.rotateAndBlurSkybox();
<         this.rotateAndBlurSkybox();
<         this.rotateAndBlurSkybox();
<         this.rotateAndBlurSkybox();
---
>         int blurCount3 = 3;
>         CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
>         if (cpp != null) {
>             blurCount3 = cpp.getBlur3();
>         }
>         for (int i = 0; i < blurCount3; ++i) {
>             this.rotateAndBlurSkybox();
>             this.rotateAndBlurSkybox();
>         }
460,461c504,520
<         this.a(0, 0, this.width, this.height, -2130706433, 0xFFFFFF);
<         this.a(0, 0, this.width, this.height, 0, Integer.MIN_VALUE);
---
>         int overlay1Top = -2130706433;
>         int overlay1Bottom = 0xFFFFFF;
>         int overlay2Top = 0;
>         int overlay2Bottom = Integer.MIN_VALUE;
>         CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
>         if (cpp != null) {
>             overlay1Top = cpp.getOverlay1Top();
>             overlay1Bottom = cpp.getOverlay1Bottom();
>             overlay2Top = cpp.getOverlay2Top();
>             overlay2Bottom = cpp.getOverlay2Bottom();
>         }
>         if (overlay1Top != 0 || overlay1Bottom != 0) {
>             this.a(0, 0, this.width, this.height, overlay1Top, overlay1Bottom);
>         }
>         if (overlay2Top != 0 || overlay2Bottom != 0) {
>             this.a(0, 0, this.width, this.height, overlay2Top, overlay2Bottom);
>         }
476c535,537
<         this.splashText = ForgeHooksClient.renderMainMenu((GuiMainMenu)this, (FontRenderer)this.fontRenderer, (int)this.width, (int)this.height, (String)this.splashText);
---
>         if (Reflector.ForgeHooksClient_renderMainMenu.exists()) {
>             this.splashText = Reflector.callString((ReflectorMethod)Reflector.ForgeHooksClient_renderMainMenu, (Object[])new Object[]{this, this.fontRenderer, this.width, this.height, this.splashText});
>         }
487,491c548,557
<         List brandings = Lists.reverse((List)FMLCommonHandler.instance().getBrandings(true));
<         for (int brdline = 0; brdline < brandings.size(); ++brdline) {
<             String brd = (String)brandings.get(brdline);
<             if (Strings.isNullOrEmpty((String)brd)) continue;
<             this.c(this.fontRenderer, brd, 2, this.height - (10 + brdline * (this.fontRenderer.FONT_HEIGHT + 1)), 0xFFFFFF);
---
>         if (Reflector.FMLCommonHandler_getBrandings.exists()) {
>             Object instance = Reflector.call((ReflectorMethod)Reflector.FMLCommonHandler_instance, (Object[])new Object[0]);
>             List brandings = Lists.reverse((List)((List)Reflector.call((Object)instance, (ReflectorMethod)Reflector.FMLCommonHandler_getBrandings, (Object[])new Object[]{true})));
>             for (int brdline = 0; brdline < brandings.size(); ++brdline) {
>                 String brd = (String)brandings.get(brdline);
>                 if (Strings.isNullOrEmpty((String)brd)) continue;
>                 this.c(this.fontRenderer, brd, 2, this.height - (10 + brdline * (this.fontRenderer.FONT_HEIGHT + 1)), 0xFFFFFF);
>             }
>         } else {
>             this.c(this.fontRenderer, s, 2, this.height - 10, -1);
503c569,574
<         this.modUpdateNotification.a(mouseX, mouseY, partialTicks);
---
>         if (this.areRealmsNotificationsEnabled()) {
>             this.realmsNotification.drawScreen(mouseX, mouseY, partialTicks);
>         }
>         if (this.modUpdateNotification != null) {
>             this.modUpdateNotification.drawScreen(mouseX, mouseY, partialTicks);
>         }
518a590,592
>         if (this.areRealmsNotificationsEnabled()) {
>             this.realmsNotification.mouseClicked(mouseX, mouseY, mouseButton);
>         }
520a595,600
>         }
>     }
> 
>     public void onGuiClosed() {
>         if (this.realmsNotification != null) {
>             this.realmsNotification.onGuiClosed();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiOverlayDebug.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiOverlayDebug.java
4a5
>  *  Config
12a14,15
>  *  java.lang.StringBuffer
>  *  java.lang.StringBuilder
28a32
>  *  net.minecraft.client.renderer.texture.TextureMap
32d35
<  *  net.minecraft.util.FrameTimer
42,45c45,50
<  *  net.minecraftforge.fml.common.FMLCommonHandler
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
<  *  org.lwjgl.Sys
---
>  *  net.optifine.SmartAnimations
>  *  net.optifine.TextureAnimations
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.util.MemoryMonitor
>  *  net.optifine.util.NativeMemory
66a72
> import net.minecraft.client.renderer.texture.TextureMap;
70d75
< import net.minecraft.util.FrameTimer;
80,83c85,90
< import net.minecraftforge.fml.common.FMLCommonHandler;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
< import org.lwjgl.Sys;
---
> import net.optifine.SmartAnimations;
> import net.optifine.TextureAnimations;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.util.MemoryMonitor;
> import net.optifine.util.NativeMemory;
86d92
< @SideOnly(value=Side.CLIENT)
90a97,101
>     private String debugOF = null;
>     private List<String> debugInfoLeft = null;
>     private List<String> debugInfoRight = null;
>     private long updateInfoLeftTimeMs = 0L;
>     private long updateInfoRightTimeMs = 0L;
110,113c121,129
<         List<String> list = this.call();
<         list.add((Object)"");
<         list.add((Object)("Debug: Pie [shift]: " + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden") + " FPS [alt]: " + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")));
<         list.add((Object)"For help: press F3 + Q");
---
>         List<String> list = this.debugInfoLeft;
>         if (list == null || System.currentTimeMillis() > this.updateInfoLeftTimeMs) {
>             list = this.call();
>             list.add((Object)"");
>             list.add((Object)("Debug: Pie [shift]: " + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden") + " FPS [alt]: " + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")));
>             list.add((Object)"For help: press F3 + Q");
>             this.debugInfoLeft = list;
>             this.updateInfoLeftTimeMs = System.currentTimeMillis() + 100L;
>         }
127c143,147
<         List<String> list = this.getDebugInfoRight();
---
>         List<String> list = this.debugInfoRight;
>         if (list == null || System.currentTimeMillis() > this.updateInfoRightTimeMs) {
>             this.debugInfoRight = list = this.getDebugInfoRight();
>             this.updateInfoRightTimeMs = System.currentTimeMillis() + 100L;
>         }
140a161
>         StringBuilder sb;
141a163,198
>         if (this.mc.debug != this.debugOF) {
>             sb = new StringBuffer(this.mc.debug);
>             int fpsMin = Config.getFpsMin();
>             int posFps = this.mc.debug.indexOf(" fps ");
>             if (posFps >= 0) {
>                 sb.insert(posFps, "/" + fpsMin);
>             }
>             if (Config.isSmoothFps()) {
>                 sb.append(" sf");
>             }
>             if (Config.isFastRender()) {
>                 sb.append(" mods.Hileb.optirefine.mixinx.fr");
>             }
>             if (Config.isAnisotropicFiltering()) {
>                 sb.append(" af");
>             }
>             if (Config.isAntialiasing()) {
>                 sb.append(" aa");
>             }
>             if (Config.isRenderRegions()) {
>                 sb.append(" reg");
>             }
>             if (Config.isShaders()) {
>                 sb.append(" sh");
>             }
>             this.debugOF = this.mc.debug = sb.toString();
>         }
>         sb = new StringBuilder();
>         TextureMap tm = Config.getTextureMap();
>         sb.append(", A: ");
>         if (SmartAnimations.isActive()) {
>             sb.append(tm.getCountAnimationsActive() + TextureAnimations.getCountAnimationsActive());
>             sb.append("/");
>         }
>         sb.append(tm.getCountAnimations() + TextureAnimations.getCountAnimations());
>         String ofInfo = sb.toString();
143c200
<             return Lists.newArrayList((Object[])new String[]{"Minecraft 1.12.2 (" + this.mc.getVersion() + "/" + ClientBrandRetriever.getClientModName() + ")", this.mc.debug, this.mc.renderGlobal.getDebugInfoRenders(), this.mc.renderGlobal.getDebugInfoEntities(), "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(), this.mc.world.getProviderName(), "", String.format((String)"Chunk-relative: %d %d %d", (Object[])new Object[]{blockpos.p() & 0xF, blockpos.q() & 0xF, blockpos.r() & 0xF})});
---
>             return Lists.newArrayList((Object[])new String[]{"Minecraft 1.12.2 (" + this.mc.getVersion() + "/" + ClientBrandRetriever.getClientModName() + ")", this.mc.debug, this.mc.renderGlobal.getDebugInfoRenders(), this.mc.renderGlobal.getDebugInfoEntities(), "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + ofInfo, this.mc.world.getProviderName(), "", String.format((String)"Chunk-relative: %d %d %d", (Object[])new Object[]{blockpos.p() & 0xF, blockpos.q() & 0xF, blockpos.r() & 0xF})});
165c222
<         ArrayList list = Lists.newArrayList((Object[])new String[]{"Minecraft 1.12.2 (" + this.mc.getVersion() + "/" + ClientBrandRetriever.getClientModName() + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType()) + ")", this.mc.debug, this.mc.renderGlobal.getDebugInfoRenders(), this.mc.renderGlobal.getDebugInfoEntities(), "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(), this.mc.world.getProviderName(), "", String.format((String)"XYZ: %.3f / %.5f / %.3f", (Object[])new Object[]{this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().getEntityBoundingBox().minY, this.mc.getRenderViewEntity().posZ}), String.format((String)"Block: %d %d %d", (Object[])new Object[]{blockpos.p(), blockpos.q(), blockpos.r()}), String.format((String)"Chunk: %d %d %d in %d %d %d", (Object[])new Object[]{blockpos.p() & 0xF, blockpos.q() & 0xF, blockpos.r() & 0xF, blockpos.p() >> 4, blockpos.q() >> 4, blockpos.r() >> 4}), String.format((String)"Facing: %s (%s) (%.1f / %.1f)", (Object[])new Object[]{enumfacing, s, Float.valueOf((float)MathHelper.wrapDegrees((float)entity.rotationYaw)), Float.valueOf((float)MathHelper.wrapDegrees((float)entity.rotationPitch))})});
---
>         ArrayList list = Lists.newArrayList((Object[])new String[]{"Minecraft 1.12.2 (" + this.mc.getVersion() + "/" + ClientBrandRetriever.getClientModName() + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType()) + ")", this.mc.debug, this.mc.renderGlobal.getDebugInfoRenders(), this.mc.renderGlobal.getDebugInfoEntities(), "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + ofInfo, this.mc.world.getProviderName(), "", String.format((String)"XYZ: %.3f / %.5f / %.3f", (Object[])new Object[]{this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().getEntityBoundingBox().minY, this.mc.getRenderViewEntity().posZ}), String.format((String)"Block: %d %d %d", (Object[])new Object[]{blockpos.p(), blockpos.q(), blockpos.r()}), String.format((String)"Chunk: %d %d %d in %d %d %d", (Object[])new Object[]{blockpos.p() & 0xF, blockpos.q() & 0xF, blockpos.r() & 0xF, blockpos.p() >> 4, blockpos.q() >> 4, blockpos.r() >> 4}), String.format((String)"Facing: %s (%s) (%.1f / %.1f)", (Object[])new Object[]{enumfacing, s, Float.valueOf((float)MathHelper.wrapDegrees((float)entity.rotationYaw)), Float.valueOf((float)MathHelper.wrapDegrees((float)entity.rotationPitch))})});
169a227
>                     DifficultyInstance difficultyServer;
174,175c232,233
<                     if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null && (entityplayermp = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.bm())) != null) {
<                         difficultyinstance = entityplayermp.l.getDifficultyForLocation(new BlockPos((Entity)entityplayermp));
---
>                     if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null && (entityplayermp = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.bm())) != null && (difficultyServer = this.mc.getIntegratedServer().getDifficultyAsync(entityplayermp.l, new BlockPos((Entity)entityplayermp))) != null) {
>                         difficultyinstance = difficultyServer;
200,202c258,268
<         ArrayList list = Lists.newArrayList((Object[])new String[]{String.format((String)"Java: %s %dbit", (Object[])new Object[]{System.getProperty((String)"java.version"), this.mc.isJava64bit() ? 64 : 32}), "LWJGL: " + Sys.getVersion(), String.format((String)"Mem: % 2d%% %03d/%03dMB", (Object[])new Object[]{l * 100L / i, GuiOverlayDebug.bytesToMb(l), GuiOverlayDebug.bytesToMb(i)}), String.format((String)"Allocated: % 2d%% %03dMB", (Object[])new Object[]{j * 100L / i, GuiOverlayDebug.bytesToMb(j)}), "", String.format((String)"CPU: %s", (Object[])new Object[]{OpenGlHelper.getCpu()}), "", String.format((String)"Display: %dx%d (%s)", (Object[])new Object[]{Display.getWidth(), Display.getHeight(), GlStateManager.glGetString((int)7936)}), GlStateManager.glGetString((int)7937), GlStateManager.glGetString((int)7938)});
<         list.add((Object)"");
<         list.addAll((Collection)FMLCommonHandler.instance().getBrandings(false));
---
>         ArrayList list = Lists.newArrayList((Object[])new String[]{String.format((String)"Java: %s %dbit", (Object[])new Object[]{System.getProperty((String)"java.version"), this.mc.isJava64bit() ? 64 : 32}), String.format((String)"Mem: % 2d%% %03d/%03dMB", (Object[])new Object[]{l * 100L / i, GuiOverlayDebug.bytesToMb(l), GuiOverlayDebug.bytesToMb(i)}), String.format((String)"Allocated: % 2d%% %03dMB", (Object[])new Object[]{j * 100L / i, GuiOverlayDebug.bytesToMb(j)}), "", String.format((String)"CPU: %s", (Object[])new Object[]{OpenGlHelper.getCpu()}), "", String.format((String)"Display: %dx%d (%s)", (Object[])new Object[]{Display.getWidth(), Display.getHeight(), GlStateManager.glGetString((int)7936)}), GlStateManager.glGetString((int)7937), GlStateManager.glGetString((int)7938)});
>         long bufferAllocated = NativeMemory.getBufferAllocated();
>         long bufferMaximum = NativeMemory.getBufferMaximum();
>         String strNative = "Native: " + GuiOverlayDebug.bytesToMb(bufferAllocated) + "/" + GuiOverlayDebug.bytesToMb(bufferMaximum) + "MB";
>         list.add(4, (Object)strNative);
>         list.set(5, (Object)("GC: " + MemoryMonitor.getAllocationRateMb() + "MB/s"));
>         if (Reflector.FMLCommonHandler_getBrandings.exists()) {
>             Object instance = Reflector.call((ReflectorMethod)Reflector.FMLCommonHandler_instance, (Object[])new Object[0]);
>             list.add((Object)"");
>             list.addAll((Collection)Reflector.call((Object)instance, (ReflectorMethod)Reflector.FMLCommonHandler_getBrandings, (Object[])new Object[]{false}));
>         }
219c285
<                     s = String.valueOf((Object)TextFormatting.GREEN) + s;
---
>                     s = TextFormatting.GREEN + s;
221c287
<                     s = String.valueOf((Object)TextFormatting.RED) + s;
---
>                     s = TextFormatting.RED + s;
229,258c295
<     public void renderLagometer() {
<         GlStateManager.disableDepth();
<         FrameTimer frametimer = this.mc.getFrameTimer();
<         int i = frametimer.getLastIndex();
<         int j = frametimer.getIndex();
<         long[] along = frametimer.getFrames();
<         ScaledResolution scaledresolution = new ScaledResolution(this.mc);
<         int k = i;
<         int l = 0;
<         GuiOverlayDebug.drawRect((int)0, (int)(scaledresolution.getScaledHeight() - 60), (int)240, (int)scaledresolution.getScaledHeight(), (int)-1873784752);
<         while (k != j) {
<             int i1 = frametimer.getLagometerValue(along[k], 30);
<             int j1 = this.getFrameColor(MathHelper.clamp((int)i1, (int)0, (int)60), 0, 30, 60);
<             this.drawVerticalLine(l, scaledresolution.getScaledHeight(), scaledresolution.getScaledHeight() - i1, j1);
<             ++l;
<             k = frametimer.parseIndex(k + 1);
<         }
<         GuiOverlayDebug.drawRect((int)1, (int)(scaledresolution.getScaledHeight() - 30 + 1), (int)14, (int)(scaledresolution.getScaledHeight() - 30 + 10), (int)-1873784752);
<         this.fontRenderer.drawString("60", 2, scaledresolution.getScaledHeight() - 30 + 2, 0xE0E0E0);
<         this.drawHorizontalLine(0, 239, scaledresolution.getScaledHeight() - 30, -1);
<         GuiOverlayDebug.drawRect((int)1, (int)(scaledresolution.getScaledHeight() - 60 + 1), (int)14, (int)(scaledresolution.getScaledHeight() - 60 + 10), (int)-1873784752);
<         this.fontRenderer.drawString("30", 2, scaledresolution.getScaledHeight() - 60 + 2, 0xE0E0E0);
<         this.drawHorizontalLine(0, 239, scaledresolution.getScaledHeight() - 60, -1);
<         this.drawHorizontalLine(0, 239, scaledresolution.getScaledHeight() - 1, -1);
<         this.drawVerticalLine(0, scaledresolution.getScaledHeight() - 60, scaledresolution.getScaledHeight(), -1);
<         this.drawVerticalLine(239, scaledresolution.getScaledHeight() - 60, scaledresolution.getScaledHeight(), -1);
<         if (this.mc.gameSettings.limitFramerate <= 120) {
<             this.drawHorizontalLine(0, 239, scaledresolution.getScaledHeight() - 60 + this.mc.gameSettings.limitFramerate / 2, -16711681);
<         }
<         GlStateManager.enableDepth();
---
>     private void renderLagometer() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiScreenWorking.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiScreenWorking.java
8a9,10
>  *  net.optifine.CustomLoadingScreen
>  *  net.optifine.CustomLoadingScreens
13a16,17
> import net.optifine.CustomLoadingScreen;
> import net.optifine.CustomLoadingScreens;
21a26
>     private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
23,24c28,29
<     public void displaySavingString(String string) {
<         this.resetProgressAndMessage(string);
---
>     public void displaySavingString(String message) {
>         this.resetProgressAndMessage(message);
27,28c32,33
<     public void resetProgressAndMessage(String string) {
<         this.title = string;
---
>     public void resetProgressAndMessage(String message) {
>         this.title = message;
32,33c37,38
<     public void displayLoadingString(String string) {
<         this.stage = string;
---
>     public void displayLoadingString(String message) {
>         this.stage = message;
37,38c42,43
<     public void setLoadingProgress(int n) {
<         this.progress = n;
---
>     public void setLoadingProgress(int progress) {
>         this.progress = progress;
45c50
<     public void drawScreen(int n, int n2, float f) {
---
>     public void drawScreen(int mouseX, int mouseY, float partialTicks) {
48c53
<                 this.mc.displayGuiScreen(null);
---
>                 this.mc.displayGuiScreen((GuiScreen)null);
50c55,65
<             return;
---
>         } else {
>             if (this.customLoadingScreen != null && this.mc.world == null) {
>                 this.customLoadingScreen.drawBackground(this.width, this.height);
>             } else {
>                 this.drawDefaultBackground();
>             }
>             if (this.progress > 0) {
>                 this.a(this.fontRenderer, this.title, this.width / 2, 70, 0xFFFFFF);
>                 this.a(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 0xFFFFFF);
>             }
>             super.drawScreen(mouseX, mouseY, partialTicks);
52,55d66
<         this.drawDefaultBackground();
<         this.a(this.fontRenderer, this.title, this.width / 2, 70, 0xFFFFFF);
<         this.a(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 0xFFFFFF);
<         super.drawScreen(n, n2, f);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiSlot.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiSlot.java
9a10
>  *  net.minecraft.client.gui.GuiResourcePackList
17,18d17
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
25a25
> import net.minecraft.client.gui.GuiResourcePackList;
31,32d30
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
35d32
< @SideOnly(value=Side.CLIENT)
38,44c35,41
<     public int width;
<     public int height;
<     public int top;
<     public int bottom;
<     public int right;
<     public int left;
<     public final int slotHeight;
---
>     protected int width;
>     protected int height;
>     protected int top;
>     protected int bottom;
>     protected int right;
>     protected int left;
>     protected final int slotHeight;
58c55
<     public int headerPadding;
---
>     protected int headerPadding;
348a346
>             if (this instanceof GuiResourcePackList && (k < this.top - this.slotHeight || k > this.bottom)) continue;
381c379
<         BufferBuilder buffer = tessellator.getBuffer();
---
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
385,389c383,387
<         buffer.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
<         buffer.pos((double)this.left, (double)this.bottom, 0.0).tex((double)((float)this.left / f), (double)((float)(this.bottom + (int)this.amountScrolled) / f)).color(32, 32, 32, 255).endVertex();
<         buffer.pos((double)this.right, (double)this.bottom, 0.0).tex((double)((float)this.right / f), (double)((float)(this.bottom + (int)this.amountScrolled) / f)).color(32, 32, 32, 255).endVertex();
<         buffer.pos((double)this.right, (double)this.top, 0.0).tex((double)((float)this.right / f), (double)((float)(this.top + (int)this.amountScrolled) / f)).color(32, 32, 32, 255).endVertex();
<         buffer.pos((double)this.left, (double)this.top, 0.0).tex((double)((float)this.left / f), (double)((float)(this.top + (int)this.amountScrolled) / f)).color(32, 32, 32, 255).endVertex();
---
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
>         bufferbuilder.pos((double)this.left, (double)this.bottom, 0.0).tex((double)((float)this.left / 32.0f), (double)((float)(this.bottom + (int)this.amountScrolled) / 32.0f)).color(32, 32, 32, 255).endVertex();
>         bufferbuilder.pos((double)this.right, (double)this.bottom, 0.0).tex((double)((float)this.right / 32.0f), (double)((float)(this.bottom + (int)this.amountScrolled) / 32.0f)).color(32, 32, 32, 255).endVertex();
>         bufferbuilder.pos((double)this.right, (double)this.top, 0.0).tex((double)((float)this.right / 32.0f), (double)((float)(this.top + (int)this.amountScrolled) / 32.0f)).color(32, 32, 32, 255).endVertex();
>         bufferbuilder.pos((double)this.left, (double)this.top, 0.0).tex((double)((float)this.left / 32.0f), (double)((float)(this.top + (int)this.amountScrolled) / 32.0f)).color(32, 32, 32, 255).endVertex();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/gui/GuiVideoSettings.java ../optifine_patch/src/main/java/net/minecraft/client/gui/GuiVideoSettings.java
5c5
<  *  java.io.IOException
---
>  *  Config
9,10c9,10
<  *  net.minecraft.client.gui.GuiListExtended
<  *  net.minecraft.client.gui.GuiOptionsRowList
---
>  *  net.minecraft.client.gui.GuiChat
>  *  net.minecraft.client.gui.GuiOptionButton
13d12
<  *  net.minecraft.client.renderer.OpenGlHelper
17,18c16,28
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.Lang
>  *  net.optifine.gui.GuiAnimationSettingsOF
>  *  net.optifine.gui.GuiDetailSettingsOF
>  *  net.optifine.gui.GuiOptionButtonOF
>  *  net.optifine.gui.GuiOptionSliderOF
>  *  net.optifine.gui.GuiOtherSettingsOF
>  *  net.optifine.gui.GuiPerformanceSettingsOF
>  *  net.optifine.gui.GuiQualitySettingsOF
>  *  net.optifine.gui.GuiScreenOF
>  *  net.optifine.gui.TooltipManager
>  *  net.optifine.gui.TooltipProvider
>  *  net.optifine.gui.TooltipProviderOptions
>  *  net.optifine.shaders.gui.GuiShaders
22d31
< import java.io.IOException;
24,25c33,34
< import net.minecraft.client.gui.GuiListExtended;
< import net.minecraft.client.gui.GuiOptionsRowList;
---
> import net.minecraft.client.gui.GuiChat;
> import net.minecraft.client.gui.GuiOptionButton;
28d36
< import net.minecraft.client.renderer.OpenGlHelper;
31,32c39,51
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.Lang;
> import net.optifine.gui.GuiAnimationSettingsOF;
> import net.optifine.gui.GuiDetailSettingsOF;
> import net.optifine.gui.GuiOptionButtonOF;
> import net.optifine.gui.GuiOptionSliderOF;
> import net.optifine.gui.GuiOtherSettingsOF;
> import net.optifine.gui.GuiPerformanceSettingsOF;
> import net.optifine.gui.GuiQualitySettingsOF;
> import net.optifine.gui.GuiScreenOF;
> import net.optifine.gui.TooltipManager;
> import net.optifine.gui.TooltipProvider;
> import net.optifine.gui.TooltipProviderOptions;
> import net.optifine.shaders.gui.GuiShaders;
34d52
< @SideOnly(value=Side.CLIENT)
36,37c54,55
< extends GuiScreen {
<     private final GuiScreen parentGuiScreen;
---
> extends GuiScreenOF {
>     private GuiScreen parentGuiScreen;
39,45c57,64
<     private final GameSettings guiGameSettings;
<     private GuiListExtended optionsRowList;
<     private static final GameSettings.Options[] VIDEO_OPTIONS = new GameSettings.Options[]{GameSettings.Options.GRAPHICS, GameSettings.Options.RENDER_DISTANCE, GameSettings.Options.AMBIENT_OCCLUSION, GameSettings.Options.FRAMERATE_LIMIT, GameSettings.Options.ANAGLYPH, GameSettings.Options.VIEW_BOBBING, GameSettings.Options.GUI_SCALE, GameSettings.Options.ATTACK_INDICATOR, GameSettings.Options.GAMMA, GameSettings.Options.RENDER_CLOUDS, GameSettings.Options.PARTICLES, GameSettings.Options.USE_FULLSCREEN, GameSettings.Options.ENABLE_VSYNC, GameSettings.Options.MIPMAP_LEVELS, GameSettings.Options.USE_VBO, GameSettings.Options.ENTITY_SHADOWS};
< 
<     public GuiVideoSettings(GuiScreen parentScreenIn, GameSettings gameSettingsIn) {
<         this.parentGuiScreen = parentScreenIn;
<         this.guiGameSettings = gameSettingsIn;
---
>     private GameSettings guiGameSettings;
>     private static GameSettings.Options[] videoOptions = new GameSettings.Options[]{GameSettings.Options.GRAPHICS, GameSettings.Options.RENDER_DISTANCE, GameSettings.Options.AMBIENT_OCCLUSION, GameSettings.Options.FRAMERATE_LIMIT, GameSettings.Options.AO_LEVEL, GameSettings.Options.VIEW_BOBBING, GameSettings.Options.GUI_SCALE, GameSettings.Options.USE_VBO, GameSettings.Options.GAMMA, GameSettings.Options.ATTACK_INDICATOR, GameSettings.Options.DYNAMIC_LIGHTS, GameSettings.Options.DYNAMIC_FOV};
>     private static final String __OBFID = "CL_00000718";
>     private TooltipManager tooltipManager = new TooltipManager((GuiScreen)this, (TooltipProvider)new TooltipProviderOptions());
> 
>     public GuiVideoSettings(GuiScreen par1GuiScreen, GameSettings par2GameSettings) {
>         this.parentGuiScreen = par1GuiScreen;
>         this.guiGameSettings = par2GameSettings;
50,60c69,77
<         this.buttonList.clear();
<         this.buttonList.add((Object)new GuiButton(200, this.width / 2 - 100, this.height - 27, I18n.format((String)"gui.done", (Object[])new Object[0])));
<         if (OpenGlHelper.vboSupported) {
<             this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, VIDEO_OPTIONS);
<         } else {
<             GameSettings.Options[] agamesettings$options = new GameSettings.Options[VIDEO_OPTIONS.length - 1];
<             int i = 0;
<             for (GameSettings.Options gamesettings$options : VIDEO_OPTIONS) {
<                 if (gamesettings$options == GameSettings.Options.USE_VBO) break;
<                 agamesettings$options[i] = gamesettings$options;
<                 ++i;
---
>         this.n.clear();
>         for (int i = 0; i < videoOptions.length; ++i) {
>             GameSettings.Options opt = videoOptions[i];
>             if (opt == null) continue;
>             int x = this.l / 2 - 155 + i % 2 * 160;
>             int y = this.m / 6 + 21 * (i / 2) - 12;
>             if (opt.isFloat()) {
>                 this.n.add((Object)new GuiOptionSliderOF(opt.getOrdinal(), x, y, opt));
>                 continue;
62c79,105
<             this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, agamesettings$options);
---
>             this.n.add((Object)new GuiOptionButtonOF(opt.getOrdinal(), x, y, opt, this.guiGameSettings.getKeyBinding(opt)));
>         }
>         int y = this.m / 6 + 21 * (videoOptions.length / 2) - 12;
>         int x = 0;
>         x = this.l / 2 - 155 + 0;
>         this.n.add((Object)new GuiOptionButton(231, x, y, Lang.get((String)"of.options.shaders")));
>         x = this.l / 2 - 155 + 160;
>         this.n.add((Object)new GuiOptionButton(202, x, y, Lang.get((String)"of.options.quality")));
>         x = this.l / 2 - 155 + 0;
>         this.n.add((Object)new GuiOptionButton(201, x, y += 21, Lang.get((String)"of.options.details")));
>         x = this.l / 2 - 155 + 160;
>         this.n.add((Object)new GuiOptionButton(212, x, y, Lang.get((String)"of.options.performance")));
>         x = this.l / 2 - 155 + 0;
>         this.n.add((Object)new GuiOptionButton(211, x, y += 21, Lang.get((String)"of.options.animations")));
>         x = this.l / 2 - 155 + 160;
>         this.n.add((Object)new GuiOptionButton(222, x, y, Lang.get((String)"of.options.other")));
>         y += 21;
>         this.n.add((Object)new GuiButton(200, this.l / 2 - 100, this.m / 6 + 168 + 11, I18n.format((String)"gui.done", (Object[])new Object[0])));
>     }
> 
>     protected void actionPerformed(GuiButton button) {
>         this.actionPerformed(button, 1);
>     }
> 
>     protected void actionPerformedRightClick(GuiButton button) {
>         if (button.id == GameSettings.Options.GUI_SCALE.ordinal()) {
>             this.actionPerformed(button, -1);
66,73c109,173
<     public void handleMouseInput() throws IOException {
<         super.handleMouseInput();
<         this.optionsRowList.p();
<     }
< 
<     protected void keyTyped(char typedChar, int keyCode) throws IOException {
<         if (keyCode == 1) {
<             this.mc.gameSettings.saveOptions();
---
>     private void actionPerformed(GuiButton button, int val) {
>         GuiDetailSettingsOF scr;
>         if (!button.enabled) {
>             return;
>         }
>         int guiScale = this.guiGameSettings.guiScale;
>         if (button.id < 200 && button instanceof GuiOptionButton) {
>             this.guiGameSettings.setOptionValue(((GuiOptionButton)button).getOption(), val);
>             button.displayString = this.guiGameSettings.getKeyBinding(GameSettings.Options.byOrdinal((int)button.id));
>         }
>         if (button.id == 200) {
>             this.j.gameSettings.saveOptions();
>             this.j.displayGuiScreen(this.parentGuiScreen);
>         }
>         if (this.guiGameSettings.guiScale != guiScale) {
>             ScaledResolution var3 = new ScaledResolution(this.j);
>             int var4 = var3.getScaledWidth();
>             int var5 = var3.getScaledHeight();
>             this.a(this.j, var4, var5);
>         }
>         if (button.id == 201) {
>             this.j.gameSettings.saveOptions();
>             scr = new GuiDetailSettingsOF((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
>         }
>         if (button.id == 202) {
>             this.j.gameSettings.saveOptions();
>             scr = new GuiQualitySettingsOF((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
>         }
>         if (button.id == 211) {
>             this.j.gameSettings.saveOptions();
>             scr = new GuiAnimationSettingsOF((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
>         }
>         if (button.id == 212) {
>             this.j.gameSettings.saveOptions();
>             scr = new GuiPerformanceSettingsOF((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
>         }
>         if (button.id == 222) {
>             this.j.gameSettings.saveOptions();
>             scr = new GuiOtherSettingsOF((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
>         }
>         if (button.id == 231) {
>             if (Config.isAntialiasing() || Config.isAntialiasingConfigured()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.shaders.aa1"), (String)Lang.get((String)"of.message.shaders.aa2"));
>                 return;
>             }
>             if (Config.isAnisotropicFiltering()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.shaders.af1"), (String)Lang.get((String)"of.message.shaders.af2"));
>                 return;
>             }
>             if (Config.isFastRender()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.shaders.fr1"), (String)Lang.get((String)"of.message.shaders.fr2"));
>                 return;
>             }
>             if (Config.getGameSettings().anaglyph) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.shaders.an1"), (String)Lang.get((String)"of.message.shaders.an2"));
>                 return;
>             }
>             this.j.gameSettings.saveOptions();
>             scr = new GuiShaders((GuiScreen)this, this.guiGameSettings);
>             this.j.displayGuiScreen((GuiScreen)scr);
75d174
<         super.keyTyped(typedChar, keyCode);
78,81c177,189
<     protected void actionPerformed(GuiButton button) throws IOException {
<         if (button.enabled && button.id == 200) {
<             this.mc.gameSettings.saveOptions();
<             this.mc.displayGuiScreen(this.parentGuiScreen);
---
>     public void drawScreen(int x, int y, float z) {
>         this.c();
>         this.a(this.q, this.screenTitle, this.l / 2, 15, 0xFFFFFF);
>         String ver = Config.getVersion();
>         String ed = "HD_U";
>         if (ed.equals((Object)"HD")) {
>             ver = "OptiFine HD G5";
>         }
>         if (ed.equals((Object)"HD_U")) {
>             ver = "OptiFine HD G5 Ultra";
>         }
>         if (ed.equals((Object)"L")) {
>             ver = "OptiFine G5 Light";
82a191,196
>         this.c(this.q, ver, 2, this.m - 10, 0x808080);
>         String verMc = "Minecraft 1.12.2";
>         int lenMc = this.q.getStringWidth(verMc);
>         this.c(this.q, verMc, this.l - lenMc - 2, this.m - 10, 0x808080);
>         super.a(x, y, z);
>         this.tooltipManager.drawTooltips(x, y, this.n);
85,94c199,200
<     protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
<         int i = this.guiGameSettings.guiScale;
<         super.mouseClicked(mouseX, mouseY, mouseButton);
<         this.optionsRowList.mouseClicked(mouseX, mouseY, mouseButton);
<         if (this.guiGameSettings.guiScale != i) {
<             ScaledResolution scaledresolution = new ScaledResolution(this.mc);
<             int j = scaledresolution.getScaledWidth();
<             int k = scaledresolution.getScaledHeight();
<             this.setWorldAndResolution(this.mc, j, k);
<         }
---
>     public static int getButtonWidth(GuiButton btn) {
>         return btn.width;
97,106c203,204
<     protected void mouseReleased(int mouseX, int mouseY, int state) {
<         int i = this.guiGameSettings.guiScale;
<         super.mouseReleased(mouseX, mouseY, state);
<         this.optionsRowList.mouseReleased(mouseX, mouseY, state);
<         if (this.guiGameSettings.guiScale != i) {
<             ScaledResolution scaledresolution = new ScaledResolution(this.mc);
<             int j = scaledresolution.getScaledWidth();
<             int k = scaledresolution.getScaledHeight();
<             this.setWorldAndResolution(this.mc, j, k);
<         }
---
>     public static int getButtonHeight(GuiButton btn) {
>         return btn.height;
109,113c207,208
<     public void drawScreen(int mouseX, int mouseY, float partialTicks) {
<         this.drawDefaultBackground();
<         this.optionsRowList.a(mouseX, mouseY, partialTicks);
<         this.a(this.fontRenderer, this.screenTitle, this.width / 2, 5, 0xFFFFFF);
<         super.drawScreen(mouseX, mouseY, partialTicks);
---
>     public static void drawGradientRect(GuiScreen guiScreen, int left, int top, int right, int bottom, int startColor, int endColor) {
>         guiScreen.a(left, top, right, bottom, startColor, endColor);
116,118c211,212
<     public void onGuiClosed() {
<         super.onGuiClosed();
<         this.mc.gameSettings.onGuiClosed();
---
>     public static String getGuiChatText(GuiChat guiChat) {
>         return guiChat.inputField.getText();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/model/ModelBox.java ../optifine_patch/src/main/java/net/minecraft/client/model/ModelBox.java
11,12d10
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
20,21d17
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
37a34,95
>     public ModelBox(ModelRenderer renderer, int[][] faceUvs, float x, float y, float z, float dx, float dy, float dz, float delta, boolean mirror) {
>         this.posX1 = x;
>         this.posY1 = y;
>         this.posZ1 = z;
>         this.posX2 = x + dx;
>         this.posY2 = y + dy;
>         this.posZ2 = z + dz;
>         this.vertexPositions = new PositionTextureVertex[8];
>         this.quadList = new TexturedQuad[6];
>         float f = x + dx;
>         float f1 = y + dy;
>         float f2 = z + dz;
>         x -= delta;
>         y -= delta;
>         z -= delta;
>         f += delta;
>         f1 += delta;
>         f2 += delta;
>         if (mirror) {
>             float f3 = f;
>             f = x;
>             x = f3;
>         }
>         PositionTextureVertex pos0 = new PositionTextureVertex(x, y, z, 0.0f, 0.0f);
>         PositionTextureVertex pos1 = new PositionTextureVertex(f, y, z, 0.0f, 8.0f);
>         PositionTextureVertex pos2 = new PositionTextureVertex(f, f1, z, 8.0f, 8.0f);
>         PositionTextureVertex pos3 = new PositionTextureVertex(x, f1, z, 8.0f, 0.0f);
>         PositionTextureVertex pos4 = new PositionTextureVertex(x, y, f2, 0.0f, 0.0f);
>         PositionTextureVertex pos5 = new PositionTextureVertex(f, y, f2, 0.0f, 8.0f);
>         PositionTextureVertex pos6 = new PositionTextureVertex(f, f1, f2, 8.0f, 8.0f);
>         PositionTextureVertex pos7 = new PositionTextureVertex(x, f1, f2, 8.0f, 0.0f);
>         this.vertexPositions[0] = pos0;
>         this.vertexPositions[1] = pos1;
>         this.vertexPositions[2] = pos2;
>         this.vertexPositions[3] = pos3;
>         this.vertexPositions[4] = pos4;
>         this.vertexPositions[5] = pos5;
>         this.vertexPositions[6] = pos6;
>         this.vertexPositions[7] = pos7;
>         this.quadList[0] = this.makeTexturedQuad(new PositionTextureVertex[]{pos5, pos1, pos2, pos6}, faceUvs[4], false, renderer.textureWidth, renderer.textureHeight);
>         this.quadList[1] = this.makeTexturedQuad(new PositionTextureVertex[]{pos0, pos4, pos7, pos3}, faceUvs[5], false, renderer.textureWidth, renderer.textureHeight);
>         this.quadList[2] = this.makeTexturedQuad(new PositionTextureVertex[]{pos5, pos4, pos0, pos1}, faceUvs[1], true, renderer.textureWidth, renderer.textureHeight);
>         this.quadList[3] = this.makeTexturedQuad(new PositionTextureVertex[]{pos2, pos3, pos7, pos6}, faceUvs[0], true, renderer.textureWidth, renderer.textureHeight);
>         this.quadList[4] = this.makeTexturedQuad(new PositionTextureVertex[]{pos1, pos0, pos3, pos2}, faceUvs[2], false, renderer.textureWidth, renderer.textureHeight);
>         this.quadList[5] = this.makeTexturedQuad(new PositionTextureVertex[]{pos4, pos5, pos6, pos7}, faceUvs[3], false, renderer.textureWidth, renderer.textureHeight);
>         if (mirror) {
>             for (TexturedQuad texturedquad : this.quadList) {
>                 texturedquad.flipFace();
>             }
>         }
>     }
> 
>     private TexturedQuad makeTexturedQuad(PositionTextureVertex[] positionTextureVertexs, int[] faceUvs, boolean reverseUV, float textureWidth, float textureHeight) {
>         if (faceUvs == null) {
>             return null;
>         }
>         if (reverseUV) {
>             return new TexturedQuad(positionTextureVertexs, faceUvs[2], faceUvs[3], faceUvs[0], faceUvs[1], textureWidth, textureHeight);
>         }
>         return new TexturedQuad(positionTextureVertexs, faceUvs[0], faceUvs[1], faceUvs[2], faceUvs[3], textureWidth, textureHeight);
>     }
> 
90d147
<     @SideOnly(value=Side.CLIENT)
92a150
>             if (texturedquad == null) continue;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/model/ModelPlayer.java ../optifine_patch/src/main/java/net/minecraft/client/model/ModelPlayer.java
33,35c33,35
<     public ModelPlayer(float f, boolean bl) {
<         super(f, 0.0f, 64, 64);
<         this.smallArms = bl;
---
>     public ModelPlayer(float modelSize, boolean smallArmsIn) {
>         super(modelSize, 0.0f, 64, 64);
>         this.smallArms = smallArmsIn;
37c37
<         this.bipedDeadmau5Head.addBox(-3.0f, -6.0f, -1.0f, 6, 6, 1, f);
---
>         this.bipedDeadmau5Head.addBox(-3.0f, -6.0f, -1.0f, 6, 6, 1, modelSize);
40,41c40,41
<         this.bipedCape.addBox(-5.0f, 0.0f, -1.0f, 10, 16, 1, f);
<         if (bl) {
---
>         this.bipedCape.addBox(-5.0f, 0.0f, -1.0f, 10, 16, 1, modelSize);
>         if (smallArmsIn) {
43c43
<             this.bipedLeftArm.addBox(-1.0f, -2.0f, -2.0f, 3, 12, 4, f);
---
>             this.bipedLeftArm.addBox(-1.0f, -2.0f, -2.0f, 3, 12, 4, modelSize);
46c46
<             this.bipedRightArm.addBox(-2.0f, -2.0f, -2.0f, 3, 12, 4, f);
---
>             this.bipedRightArm.addBox(-2.0f, -2.0f, -2.0f, 3, 12, 4, modelSize);
49c49
<             this.bipedLeftArmwear.addBox(-1.0f, -2.0f, -2.0f, 3, 12, 4, f + 0.25f);
---
>             this.bipedLeftArmwear.addBox(-1.0f, -2.0f, -2.0f, 3, 12, 4, modelSize + 0.25f);
52c52
<             this.bipedRightArmwear.addBox(-2.0f, -2.0f, -2.0f, 3, 12, 4, f + 0.25f);
---
>             this.bipedRightArmwear.addBox(-2.0f, -2.0f, -2.0f, 3, 12, 4, modelSize + 0.25f);
56c56
<             this.bipedLeftArm.addBox(-1.0f, -2.0f, -2.0f, 4, 12, 4, f);
---
>             this.bipedLeftArm.addBox(-1.0f, -2.0f, -2.0f, 4, 12, 4, modelSize);
59c59
<             this.bipedLeftArmwear.addBox(-1.0f, -2.0f, -2.0f, 4, 12, 4, f + 0.25f);
---
>             this.bipedLeftArmwear.addBox(-1.0f, -2.0f, -2.0f, 4, 12, 4, modelSize + 0.25f);
62c62
<             this.bipedRightArmwear.addBox(-3.0f, -2.0f, -2.0f, 4, 12, 4, f + 0.25f);
---
>             this.bipedRightArmwear.addBox(-3.0f, -2.0f, -2.0f, 4, 12, 4, modelSize + 0.25f);
66c66
<         this.bipedLeftLeg.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, f);
---
>         this.bipedLeftLeg.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, modelSize);
69c69
<         this.bipedLeftLegwear.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, f + 0.25f);
---
>         this.bipedLeftLegwear.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, modelSize + 0.25f);
72c72
<         this.bipedRightLegwear.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, f + 0.25f);
---
>         this.bipedRightLegwear.addBox(-2.0f, 0.0f, -2.0f, 4, 12, 4, modelSize + 0.25f);
75c75
<         this.bipedBodyWear.addBox(-4.0f, 0.0f, -2.0f, 8, 12, 4, f + 0.25f);
---
>         this.bipedBodyWear.addBox(-4.0f, 0.0f, -2.0f, 8, 12, 4, modelSize + 0.25f);
79,80c79,80
<     public void render(Entity entity, float f, float f2, float f3, float f4, float f5, float f6) {
<         super.render(entity, f, f2, f3, f4, f5, f6);
---
>     public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         super.render(entityIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
83c83
<             \u2603 = 2.0f;
---
>             float f = 2.0f;
85,90c85,90
<             GlStateManager.translate((float)0.0f, (float)(24.0f * f6), (float)0.0f);
<             this.bipedLeftLegwear.render(f6);
<             this.bipedRightLegwear.render(f6);
<             this.bipedLeftArmwear.render(f6);
<             this.bipedRightArmwear.render(f6);
<             this.bipedBodyWear.render(f6);
---
>             GlStateManager.translate((float)0.0f, (float)(24.0f * scale), (float)0.0f);
>             this.bipedLeftLegwear.render(scale);
>             this.bipedRightLegwear.render(scale);
>             this.bipedLeftArmwear.render(scale);
>             this.bipedRightArmwear.render(scale);
>             this.bipedBodyWear.render(scale);
92c92
<             if (entity.isSneaking()) {
---
>             if (entityIn.isSneaking()) {
95,99c95,99
<             this.bipedLeftLegwear.render(f6);
<             this.bipedRightLegwear.render(f6);
<             this.bipedLeftArmwear.render(f6);
<             this.bipedRightArmwear.render(f6);
<             this.bipedBodyWear.render(f6);
---
>             this.bipedLeftLegwear.render(scale);
>             this.bipedRightLegwear.render(scale);
>             this.bipedLeftArmwear.render(scale);
>             this.bipedRightArmwear.render(scale);
>             this.bipedBodyWear.render(scale);
104c104
<     public void renderDeadmau5Head(float f) {
---
>     public void renderDeadmau5Head(float scale) {
108c108
<         this.bipedDeadmau5Head.render(f);
---
>         this.bipedDeadmau5Head.render(scale);
111,112c111,112
<     public void renderCape(float f) {
<         this.bipedCape.render(f);
---
>     public void renderCape(float scale) {
>         this.bipedCape.render(scale);
115,116c115,116
<     public void setRotationAngles(float f, float f2, float f3, float f4, float f5, float f6, Entity entity) {
<         super.setRotationAngles(f, f2, f3, f4, f5, f6, entity);
---
>     public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn) {
>         super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);
122d121
<         this.bipedCape.rotationPointY = entity.isSneaking() ? 2.0f : 0.0f;
125,133c124,132
<     public void setVisible(boolean bl) {
<         super.setVisible(bl);
<         this.bipedLeftArmwear.showModel = bl;
<         this.bipedRightArmwear.showModel = bl;
<         this.bipedLeftLegwear.showModel = bl;
<         this.bipedRightLegwear.showModel = bl;
<         this.bipedBodyWear.showModel = bl;
<         this.bipedCape.showModel = bl;
<         this.bipedDeadmau5Head.showModel = bl;
---
>     public void setVisible(boolean visible) {
>         super.setVisible(visible);
>         this.bipedLeftArmwear.showModel = visible;
>         this.bipedRightArmwear.showModel = visible;
>         this.bipedLeftLegwear.showModel = visible;
>         this.bipedRightLegwear.showModel = visible;
>         this.bipedBodyWear.showModel = visible;
>         this.bipedCape.showModel = visible;
>         this.bipedDeadmau5Head.showModel = visible;
136,137c135,136
<     public void postRenderArm(float f, EnumHandSide enumHandSide) {
<         ModelRenderer modelRenderer = this.getArmForSide(enumHandSide);
---
>     public void postRenderArm(float scale, EnumHandSide side) {
>         ModelRenderer modelrenderer = this.getArmForSide(side);
139,142c138,141
<             float f2 = 0.5f * (float)(enumHandSide == EnumHandSide.RIGHT ? 1 : -1);
<             modelRenderer.rotationPointX += f2;
<             modelRenderer.postRender(f);
<             modelRenderer.rotationPointX -= f2;
---
>             float f = 0.5f * (float)(side == EnumHandSide.RIGHT ? 1 : -1);
>             modelrenderer.rotationPointX += f;
>             modelrenderer.postRender(scale);
>             modelrenderer.rotationPointX -= f;
144c143
<             modelRenderer.postRender(f);
---
>             modelrenderer.postRender(scale);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/model/ModelRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/model/ModelRenderer.java
4a5
>  *  Config
5a7
>  *  java.lang.Integer
7a10,11
>  *  java.lang.StringBuffer
>  *  java.util.ArrayList
14a19
>  *  net.minecraft.client.renderer.RenderGlobal
16,17c21,24
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.minecraft.util.ResourceLocation
>  *  net.optifine.entity.model.anim.ModelUpdater
>  *  net.optifine.model.ModelSprite
>  *  net.optifine.shaders.Shaders
21a29
> import java.util.ArrayList;
28a37
> import net.minecraft.client.renderer.RenderGlobal;
30,31c39,42
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.minecraft.util.ResourceLocation;
> import net.optifine.entity.model.anim.ModelUpdater;
> import net.optifine.model.ModelSprite;
> import net.optifine.shaders.Shaders;
49c60
<     public List<ModelBox> cubeList = Lists.newArrayList();
---
>     public List<ModelBox> cubeList;
55a67,76
>     public List spriteList = new ArrayList();
>     public boolean mirrorV = false;
>     public float scaleX = 1.0f;
>     public float scaleY = 1.0f;
>     public float scaleZ = 1.0f;
>     private int countResetDisplayList;
>     private ResourceLocation textureLocation = null;
>     private String id = null;
>     private ModelUpdater modelUpdater;
>     private RenderGlobal renderGlobal = Config.getRenderGlobal();
57a79
>         this.cubeList = Lists.newArrayList();
114d135
<     @SideOnly(value=Side.CLIENT)
116a138
>             this.checkResetDisplayList();
119a142,153
>             int lastTextureId = 0;
>             if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
>                 if (this.renderGlobal.renderOverlayEyes) {
>                     return;
>                 }
>                 lastTextureId = GlStateManager.getBoundTexture();
>                 Config.getTextureManager().bindTexture(this.textureLocation);
>             }
>             if (this.modelUpdater != null) {
>                 this.modelUpdater.update();
>             }
>             boolean scaleXYZ = this.scaleX != 1.0f || this.scaleY != 1.0f || this.scaleZ != 1.0f;
122a157,159
>                     if (scaleXYZ) {
>                         GlStateManager.scale((float)this.scaleX, (float)this.scaleY, (float)this.scaleZ);
>                     }
128a166,168
>                     if (scaleXYZ) {
>                         GlStateManager.scale((float)(1.0f / this.scaleX), (float)(1.0f / this.scaleY), (float)(1.0f / this.scaleZ));
>                     }
130a171,173
>                     if (scaleXYZ) {
>                         GlStateManager.scale((float)this.scaleX, (float)this.scaleY, (float)this.scaleZ);
>                     }
136a180,182
>                     if (scaleXYZ) {
>                         GlStateManager.scale((float)(1.0f / this.scaleX), (float)(1.0f / this.scaleY), (float)(1.0f / this.scaleZ));
>                     }
150a197,199
>                 if (scaleXYZ) {
>                     GlStateManager.scale((float)this.scaleX, (float)this.scaleY, (float)this.scaleZ);
>                 }
159a209,211
>             if (lastTextureId != 0) {
>                 GlStateManager.bindTexture((int)lastTextureId);
>             }
163d214
<     @SideOnly(value=Side.CLIENT)
165a217
>             this.checkResetDisplayList();
168a221,232
>             int lastTextureId = 0;
>             if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
>                 if (this.renderGlobal.renderOverlayEyes) {
>                     return;
>                 }
>                 lastTextureId = GlStateManager.getBoundTexture();
>                 Config.getTextureManager().bindTexture(this.textureLocation);
>             }
>             if (this.modelUpdater != null) {
>                 this.modelUpdater.update();
>             }
>             boolean scaleXYZ = this.scaleX != 1.0f || this.scaleY != 1.0f || this.scaleZ != 1.0f;
179a244,246
>             if (scaleXYZ) {
>                 GlStateManager.scale((float)this.scaleX, (float)this.scaleY, (float)this.scaleZ);
>             }
180a248,252
>             if (this.childModels != null) {
>                 for (int i = 0; i < this.childModels.size(); ++i) {
>                     ((ModelRenderer)this.childModels.get(i)).render(scale);
>                 }
>             }
181a254,256
>             if (lastTextureId != 0) {
>                 GlStateManager.bindTexture((int)lastTextureId);
>             }
185d259
<     @SideOnly(value=Side.CLIENT)
187a262
>             this.checkResetDisplayList();
210d284
<     @SideOnly(value=Side.CLIENT)
212c286,289
<         this.displayList = GLAllocation.generateDisplayLists((int)1);
---
>         int i;
>         if (this.displayList == 0) {
>             this.displayList = GLAllocation.generateDisplayLists((int)1);
>         }
215c292
<         for (int i = 0; i < this.cubeList.size(); ++i) {
---
>         for (i = 0; i < this.cubeList.size(); ++i) {
217a295,298
>         for (i = 0; i < this.spriteList.size(); ++i) {
>             ModelSprite sprite = (ModelSprite)this.spriteList.get(i);
>             sprite.render(Tessellator.getInstance(), scale);
>         }
225a307,388
>     }
> 
>     public void addSprite(float posX, float posY, float posZ, int sizeX, int sizeY, int sizeZ, float sizeAdd) {
>         this.spriteList.add((Object)new ModelSprite(this, this.textureOffsetX, this.textureOffsetY, posX, posY, posZ, sizeX, sizeY, sizeZ, sizeAdd));
>     }
> 
>     public boolean getCompiled() {
>         return this.compiled;
>     }
> 
>     public int getDisplayList() {
>         return this.displayList;
>     }
> 
>     private void checkResetDisplayList() {
>         if (this.countResetDisplayList != Shaders.countResetDisplayLists) {
>             this.compiled = false;
>             this.countResetDisplayList = Shaders.countResetDisplayLists;
>         }
>     }
> 
>     public ResourceLocation getTextureLocation() {
>         return this.textureLocation;
>     }
> 
>     public void setTextureLocation(ResourceLocation textureLocation) {
>         this.textureLocation = textureLocation;
>     }
> 
>     public String getId() {
>         return this.id;
>     }
> 
>     public void setId(String id) {
>         this.id = id;
>     }
> 
>     public void addBox(int[][] faceUvs, float x, float y, float z, float dx, float dy, float dz, float delta) {
>         this.cubeList.add((Object)new ModelBox(this, faceUvs, x, y, z, dx, dy, dz, delta, this.mirror));
>     }
> 
>     public ModelRenderer getChild(String name) {
>         if (name == null) {
>             return null;
>         }
>         if (this.childModels != null) {
>             for (int i = 0; i < this.childModels.size(); ++i) {
>                 ModelRenderer child = (ModelRenderer)this.childModels.get(i);
>                 if (!name.equals((Object)child.getId())) continue;
>                 return child;
>             }
>         }
>         return null;
>     }
> 
>     public ModelRenderer getChildDeep(String name) {
>         if (name == null) {
>             return null;
>         }
>         ModelRenderer mrChild = this.getChild(name);
>         if (mrChild != null) {
>             return mrChild;
>         }
>         if (this.childModels != null) {
>             for (int i = 0; i < this.childModels.size(); ++i) {
>                 ModelRenderer child = (ModelRenderer)this.childModels.get(i);
>                 ModelRenderer mr = child.getChildDeep(name);
>                 if (mr == null) continue;
>                 return mr;
>             }
>         }
>         return null;
>     }
> 
>     public void setModelUpdater(ModelUpdater modelUpdater) {
>         this.modelUpdater = modelUpdater;
>     }
> 
>     public String toString() {
>         StringBuffer sb = new StringBuffer();
>         sb.append("id: " + this.id + ", boxes: " + (this.cubeList != null ? Integer.valueOf((int)this.cubeList.size()) : null) + ", submodels: " + (this.childModels != null ? Integer.valueOf((int)this.childModels.size()) : null));
>         return sb.toString();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/model/TexturedQuad.java ../optifine_patch/src/main/java/net/minecraft/client/model/TexturedQuad.java
4a5
>  *  Config
11,12c12
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.shaders.SVertexFormat
21,22c21
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.shaders.SVertexFormat;
52d50
<     @SideOnly(value=Side.CLIENT)
65c63,67
<         renderer.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
---
>         if (Config.isShaders()) {
>             renderer.begin(7, SVertexFormat.defVertexFormatTextured);
>         } else {
>             renderer.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/multiplayer/WorldClient.java ../optifine_patch/src/main/java/net/minecraft/client/multiplayer/WorldClient.java
4a5
>  *  Config
6a8
>  *  java.lang.Integer
19a22
>  *  net.minecraft.client.entity.EntityPlayerSP
20a24
>  *  net.minecraft.client.multiplayer.PlayerControllerMP
46a51
>  *  net.minecraft.world.DimensionType
50a56
>  *  net.minecraft.world.WorldProvider
58,63c64,69
<  *  net.minecraftforge.common.DimensionManager
<  *  net.minecraftforge.common.MinecraftForge
<  *  net.minecraftforge.event.world.WorldEvent$Load
<  *  net.minecraftforge.fml.common.eventhandler.Event
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomGuis
>  *  net.optifine.DynamicLights
>  *  net.optifine.override.PlayerControllerOF
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorMethod
78a85
> import net.minecraft.client.entity.EntityPlayerSP;
79a87
> import net.minecraft.client.multiplayer.PlayerControllerMP;
104a113
> import net.minecraft.world.DimensionType;
108a118
> import net.minecraft.world.WorldProvider;
116,121c126,131
< import net.minecraftforge.common.DimensionManager;
< import net.minecraftforge.common.MinecraftForge;
< import net.minecraftforge.event.world.WorldEvent;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomGuis;
> import net.optifine.DynamicLights;
> import net.optifine.override.PlayerControllerOF;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorMethod;
123d132
< @SideOnly(value=Side.CLIENT)
132,133c141,145
<     private int ambienceTicks = this.rand.nextInt(12000);
<     protected Set<ChunkPos> visibleChunks = Sets.newHashSet();
---
>     private int ambienceTicks;
>     protected Set<ChunkPos> visibleChunks;
>     private int playerChunkX = Integer.MIN_VALUE;
>     private int playerChunkY = Integer.MIN_VALUE;
>     private boolean playerUpdate = false;
136c148,150
<         super((ISaveHandler)new SaveHandlerMP(), new WorldInfo(settings, "MpServer"), DimensionManager.createProviderFor((int)dimension), profilerIn, true);
---
>         super((ISaveHandler)new SaveHandlerMP(), new WorldInfo(settings, "MpServer"), WorldClient.makeWorldProvider(dimension), profilerIn, true);
>         this.ambienceTicks = this.rand.nextInt(12000);
>         this.visibleChunks = Sets.newHashSet();
145,146c159,171
<         this.initCapabilities();
<         MinecraftForge.EVENT_BUS.post((Event)new WorldEvent.Load((World)this));
---
>         Reflector.call((Object)((Object)this), (ReflectorMethod)Reflector.ForgeWorld_initCapabilities, (Object[])new Object[0]);
>         Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.WorldEvent_Load_Constructor, (Object[])new Object[]{this});
>         if (this.mc.playerController != null && this.mc.playerController.getClass() == PlayerControllerMP.class) {
>             this.mc.playerController = new PlayerControllerOF(this.mc, netHandler);
>             CustomGuis.setPlayerControllerOF((PlayerControllerOF)((PlayerControllerOF)this.mc.playerController));
>         }
>     }
> 
>     private static WorldProvider makeWorldProvider(int dimension) {
>         if (Reflector.DimensionManager_createProviderFor.exists()) {
>             return (WorldProvider)Reflector.call((ReflectorMethod)Reflector.DimensionManager_createProviderFor, (Object[])new Object[]{dimension});
>         }
>         return DimensionType.getById((int)dimension).createDimension();
181a207,213
>         int cx = MathHelper.floor((double)(this.mc.player.p / 16.0));
>         int cy = MathHelper.floor((double)(this.mc.player.r / 16.0));
>         if (cx == this.playerChunkX && cy == this.playerChunkY) {
>             return;
>         }
>         this.playerChunkX = cx;
>         this.playerChunkY = cy;
246c278
<     public void onEntityAdded(Entity entityIn) {
---
>     protected void onEntityAdded(Entity entityIn) {
253c285
<     public void onEntityRemoved(Entity entityIn) {
---
>     protected void onEntityRemoved(Entity entityIn) {
307,308c339,340
<     protected void playMoodSoundAndCheckLight(int x, int z, Chunk chunkIn) {
<         super.playMoodSoundAndCheckLight(x, z, chunkIn);
---
>     protected void playMoodSoundAndCheckLight(int p_147467_1_, int p_147467_2_, Chunk chunkIn) {
>         super.playMoodSoundAndCheckLight(p_147467_1_, p_147467_2_, chunkIn);
309a342,348
>             EntityPlayerSP player = this.mc.player;
>             if (player == null) {
>                 return;
>             }
>             if (Math.abs((int)(player.ab - chunkIn.x)) > 1 || Math.abs((int)(player.ad - chunkIn.z)) > 1) {
>                 return;
>             }
315c354,360
<             BlockPos blockpos = new BlockPos(j + x, l, k + z);
---
>             l /= 2;
>             if (player.q > 160.0) {
>                 l += 128;
>             } else if (player.q > 96.0) {
>                 l += 64;
>             }
>             BlockPos blockpos = new BlockPos(j + p_147467_1_, l, k + p_147467_2_);
317,318c362,368
<             j += x;
<             k += z;
---
>             double distSq = this.mc.player.d((double)(j += p_147467_1_) + 0.5, (double)l + 0.5, (double)(k += p_147467_2_) + 0.5);
>             if (distSq < 4.0) {
>                 return;
>             }
>             if (distSq > 255.0) {
>                 return;
>             }
320,324c370,371
<                 double d0 = this.mc.player.d((double)j + 0.5, (double)l + 0.5, (double)k + 0.5);
<                 if (this.mc.player != null && d0 > 4.0 && d0 < 256.0) {
<                     this.playSound((double)j + 0.5, (double)l + 0.5, (double)k + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7f, 0.8f + this.rand.nextFloat() * 0.2f, false);
<                     this.ambienceTicks = this.rand.nextInt(12000) + 6000;
<                 }
---
>                 this.playSound((double)j + 0.5, (double)l + 0.5, (double)k + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7f, 0.8f + this.rand.nextFloat() * 0.2f, false);
>                 this.ambienceTicks = this.rand.nextInt(12000) + 6000;
332a380,382
>         if (itemstack == null || Block.getBlockFromItem((Item)itemstack.getItem()) != Blocks.BARRIER) {
>             itemstack = this.mc.player.cp();
>         }
414,415c464,465
<     public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable NBTTagCompound compound) {
<         this.mc.effectRenderer.addEffect((Particle)new ParticleFirework.Starter((World)this, x, y, z, motionX, motionY, motionZ, this.mc.effectRenderer, compound));
---
>     public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable NBTTagCompound compund) {
>         this.mc.effectRenderer.addEffect((Particle)new ParticleFirework.Starter((World)this, x, y, z, motionX, motionY, motionZ, this.mc.effectRenderer, compund));
437a488,526
>     }
> 
>     public int getCombinedLight(BlockPos pos, int lightValue) {
>         int combinedLight = super.getCombinedLight(pos, lightValue);
>         if (Config.isDynamicLights()) {
>             combinedLight = DynamicLights.getCombinedLight((BlockPos)pos, (int)combinedLight);
>         }
>         return combinedLight;
>     }
> 
>     public boolean setBlockState(BlockPos pos, IBlockState newState, int flags) {
>         this.playerUpdate = this.isPlayerActing();
>         boolean res = super.setBlockState(pos, newState, flags);
>         this.playerUpdate = false;
>         return res;
>     }
> 
>     private boolean isPlayerActing() {
>         if (this.mc.playerController instanceof PlayerControllerOF) {
>             PlayerControllerOF pcof = (PlayerControllerOF)this.mc.playerController;
>             return pcof.isActing();
>         }
>         return false;
>     }
> 
>     public boolean isPlayerUpdate() {
>         return this.playerUpdate;
>     }
> 
>     static /* synthetic */ Set access$000(WorldClient x0) {
>         return x0.entityList;
>     }
> 
>     static /* synthetic */ Set access$100(WorldClient x0) {
>         return x0.entitySpawnQueue;
>     }
> 
>     static /* synthetic */ Minecraft access$200(WorldClient x0) {
>         return x0.mc;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/particle/ParticleItemPickup.java ../optifine_patch/src/main/java/net/minecraft/client/particle/ParticleItemPickup.java
4a5
>  *  Config
13a15,16
>  *  net.optifine.shaders.Program
>  *  net.optifine.shaders.Shaders
24a28,29
> import net.optifine.shaders.Program;
> import net.optifine.shaders.Shaders;
35,38c40,43
<     public ParticleItemPickup(World world, Entity entity, Entity entity2, float f) {
<         super(world, entity.posX, entity.posY, entity.posZ, entity.motionX, entity.motionY, entity.motionZ);
<         this.item = entity;
<         this.target = entity2;
---
>     public ParticleItemPickup(World worldIn, Entity p_i1233_2_, Entity p_i1233_3_, float p_i1233_4_) {
>         super(worldIn, p_i1233_2_.posX, p_i1233_2_.posY, p_i1233_2_.posZ, p_i1233_2_.motionX, p_i1233_2_.motionY, p_i1233_2_.motionZ);
>         this.item = p_i1233_2_;
>         this.target = p_i1233_3_;
40c45
<         this.yOffset = f;
---
>         this.yOffset = p_i1233_4_;
43,58c48,68
<     public void renderParticle(BufferBuilder bufferBuilder, Entity entity, float f, float f2, float f3, float f4, float f5, float f6) {
<         \u2603 = ((float)this.age + f) / (float)this.maxAge;
<         \u2603 *= \u2603;
<         double d = this.item.posX;
<         \u2603 = this.item.posY;
<         \u2603 = this.item.posZ;
<         \u2603 = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * (double)f;
<         \u2603 = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * (double)f + (double)this.yOffset;
<         \u2603 = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * (double)f;
<         \u2603 = d + (\u2603 - d) * (double)\u2603;
<         \u2603 = \u2603 + (\u2603 - \u2603) * (double)\u2603;
<         \u2603 = \u2603 + (\u2603 - \u2603) * (double)\u2603;
<         int \u26032 = this.getBrightnessForRender(f);
<         int \u26033 = \u26032 % 65536;
<         int \u26034 = \u26032 / 65536;
<         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)\u26033, (float)\u26034);
---
>     public void renderParticle(BufferBuilder buffer, Entity entityIn, float partialTicks, float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ) {
>         Program oldShadersProgram = null;
>         if (Config.isShaders()) {
>             oldShadersProgram = Shaders.activeProgram;
>             Shaders.nextEntity((Entity)this.item);
>         }
>         float f = ((float)this.age + partialTicks) / (float)this.maxAge;
>         f *= f;
>         double d0 = this.item.posX;
>         double d1 = this.item.posY;
>         double d2 = this.item.posZ;
>         double d3 = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * (double)partialTicks;
>         double d4 = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * (double)partialTicks + (double)this.yOffset;
>         double d5 = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * (double)partialTicks;
>         double d6 = d0 + (d3 - d0) * (double)f;
>         double d7 = d1 + (d4 - d1) * (double)f;
>         double d8 = d2 + (d5 - d2) * (double)f;
>         int i = this.getBrightnessForRender(partialTicks);
>         int j = i % 65536;
>         int k = i / 65536;
>         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
61c71,75
<         this.renderManager.renderEntity(this.item, \u2603 -= interpPosX, \u2603 -= interpPosY, \u2603 -= interpPosZ, this.item.rotationYaw, f, false);
---
>         this.renderManager.renderEntity(this.item, d6 -= interpPosX, d7 -= interpPosY, d8 -= interpPosZ, this.item.rotationYaw, partialTicks, false);
>         if (Config.isShaders()) {
>             Shaders.setEntityId(null);
>             Shaders.useProgram((Program)oldShadersProgram);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/particle/ParticleManager.java ../optifine_patch/src/main/java/net/minecraft/client/particle/ParticleManager.java
4a5
>  *  Config
11a13
>  *  java.lang.System
20a23,24
>  *  net.minecraft.block.Block
>  *  net.minecraft.block.material.Material
21a26
>  *  net.minecraft.client.particle.Barrier
46a52
>  *  net.minecraft.client.particle.ParticleFirework$Spark
66a73
>  *  net.minecraft.client.particle.ParticleSuspend
97,98c104,105
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
112a120,121
> import net.minecraft.block.Block;
> import net.minecraft.block.material.Material;
175,176c184,185
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
178d186
< @SideOnly(value=Side.CLIENT)
278a287,289
>         if (effect instanceof ParticleFirework.Spark && !Config.isFireworkParticles()) {
>             return;
>         }
304c315,317
<                 this.fxLayers[j][k].add((Object)particle);
---
>                 if (!(particle instanceof Barrier) || !this.reuseBarrierParticle(particle, this.fxLayers[j][k])) {
>                     this.fxLayers[j][k].add((Object)particle);
>                 }
321a335,337
>             Queue<Particle> particlesIn = p_187240_1_;
>             long timeStartMs = System.currentTimeMillis();
>             int countLeft = particlesIn.size();
326,327c342,355
<                 if (particle.isAlive()) continue;
<                 iterator.remove();
---
>                 if (!particle.isAlive()) {
>                     iterator.remove();
>                 }
>                 --countLeft;
>                 if (System.currentTimeMillis() <= timeStartMs + 20L) continue;
>                 break;
>             }
>             if (countLeft > 0) {
>                 Iterator it = particlesIn.iterator();
>                 for (int countToRemove = countLeft; it.hasNext() && countToRemove > 0; --countToRemove) {
>                     Particle particle = (Particle)it.next();
>                     particle.setExpired();
>                     it.remove();
>                 }
358a387,388
>         IBlockState cameraBlockState = ActiveRenderInfo.getBlockStateAtEntityViewpoint((World)this.world, (Entity)entityIn, (float)partialTicks);
>         boolean isEyeInWater = cameraBlockState.a() == Material.WATER;
386a417
>                         if (!isEyeInWater && particle instanceof ParticleSuspend) continue;
434c465,472
<         if (!state.getBlock().isAir(state, (IBlockAccess)this.world, pos) && !state.getBlock().addDestroyEffects(this.world, pos, this)) {
---
>         boolean notAir;
>         if (Reflector.ForgeBlock_addDestroyEffects.exists() && Reflector.ForgeBlock_isAir.exists()) {
>             Block block = state.getBlock();
>             notAir = !Reflector.callBoolean((Object)block, (ReflectorMethod)Reflector.ForgeBlock_isAir, (Object[])new Object[]{state, this.world, pos}) && !Reflector.callBoolean((Object)block, (ReflectorMethod)Reflector.ForgeBlock_addDestroyEffects, (Object[])new Object[]{this.world, pos, this});
>         } else {
>             boolean bl = notAir = state.a() != Material.AIR;
>         }
>         if (notAir) {
492a531,539
>     private boolean reuseBarrierParticle(Particle entityfx, ArrayDeque<Particle> deque) {
>         for (Particle efx : deque) {
>             if (!(efx instanceof Barrier) || entityfx.prevPosX != efx.prevPosX || entityfx.prevPosY != efx.prevPosY || entityfx.prevPosZ != efx.prevPosZ) continue;
>             efx.particleAge = 0;
>             return true;
>         }
>         return false;
>     }
> 
495c542,546
<         if (state != null && !state.getBlock().addHitEffects(state, this.world, target, this)) {
---
>         if (state == null) {
>             return;
>         }
>         boolean blockAddHitEffects = Reflector.callBoolean((Object)state.getBlock(), (ReflectorMethod)Reflector.ForgeBlock_addHitEffects, (Object[])new Object[]{state, this.world, target, this});
>         if (state != null && !blockAddHitEffects) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockFluidRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockFluidRenderer.java
4a5
>  *  Config
5a7
>  *  java.lang.Math
6a9
>  *  net.minecraft.block.Block
7a11,12
>  *  net.minecraft.block.BlockSlab
>  *  net.minecraft.block.BlockSlab$EnumBlockHalf
10d14
<  *  net.minecraft.block.state.BlockFaceShape
13a18
>  *  net.minecraft.client.renderer.block.model.FaceBakery
16a22
>  *  net.minecraft.init.Blocks
21,22c27,29
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomColors
>  *  net.optifine.render.RenderEnv
>  *  net.optifine.shaders.SVertexBuilder
25a33
> import net.minecraft.block.Block;
26a35
> import net.minecraft.block.BlockSlab;
29d37
< import net.minecraft.block.state.BlockFaceShape;
32a41
> import net.minecraft.client.renderer.block.model.FaceBakery;
35a45
> import net.minecraft.init.Blocks;
40,41c50,52
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomColors;
> import net.optifine.render.RenderEnv;
> import net.optifine.shaders.SVertexBuilder;
43d53
< @SideOnly(value=Side.CLIENT)
64,144c74,80
<     public boolean renderFluid(IBlockAccess blockAccess, IBlockState blockStateIn, BlockPos blockPosIn, BufferBuilder bufferBuilderIn) {
<         BlockLiquid blockliquid = (BlockLiquid)blockStateIn.getBlock();
<         boolean flag = blockStateIn.a() == Material.LAVA;
<         TextureAtlasSprite[] atextureatlassprite = flag ? this.atlasSpritesLava : this.atlasSpritesWater;
<         int i = this.blockColors.colorMultiplier(blockStateIn, blockAccess, blockPosIn, 0);
<         float f = (float)(i >> 16 & 0xFF) / 255.0f;
<         float f1 = (float)(i >> 8 & 0xFF) / 255.0f;
<         float f2 = (float)(i & 0xFF) / 255.0f;
<         boolean flag1 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.UP);
<         boolean flag2 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.DOWN);
<         boolean[] aboolean = new boolean[]{blockStateIn.c(blockAccess, blockPosIn, EnumFacing.NORTH), blockStateIn.c(blockAccess, blockPosIn, EnumFacing.SOUTH), blockStateIn.c(blockAccess, blockPosIn, EnumFacing.WEST), blockStateIn.c(blockAccess, blockPosIn, EnumFacing.EAST)};
<         if (!(flag1 || flag2 || aboolean[0] || aboolean[1] || aboolean[2] || aboolean[3])) {
<             return false;
<         }
<         boolean flag3 = false;
<         float f3 = 0.5f;
<         float f4 = 1.0f;
<         float f5 = 0.8f;
<         float f6 = 0.6f;
<         Material material = blockStateIn.a();
<         float f7 = this.getFluidHeight(blockAccess, blockPosIn, material);
<         float f8 = this.getFluidHeight(blockAccess, blockPosIn.south(), material);
<         float f9 = this.getFluidHeight(blockAccess, blockPosIn.east().south(), material);
<         float f10 = this.getFluidHeight(blockAccess, blockPosIn.east(), material);
<         double d0 = blockPosIn.p();
<         double d1 = blockPosIn.q();
<         double d2 = blockPosIn.r();
<         float f11 = 0.001f;
<         if (flag1) {
<             float f20;
<             float f16;
<             float f19;
<             float f15;
<             float f18;
<             float f14;
<             float f17;
<             float f13;
<             flag3 = true;
<             float f12 = BlockLiquid.getSlopeAngle((IBlockAccess)blockAccess, (BlockPos)blockPosIn, (Material)material, (IBlockState)blockStateIn);
<             TextureAtlasSprite textureatlassprite = f12 > -999.0f ? atextureatlassprite[1] : atextureatlassprite[0];
<             f7 -= 0.001f;
<             f8 -= 0.001f;
<             f9 -= 0.001f;
<             f10 -= 0.001f;
<             if (f12 < -999.0f) {
<                 f13 = textureatlassprite.getInterpolatedU(0.0);
<                 f17 = textureatlassprite.getInterpolatedV(0.0);
<                 f14 = f13;
<                 f18 = textureatlassprite.getInterpolatedV(16.0);
<                 f15 = textureatlassprite.getInterpolatedU(16.0);
<                 f19 = f18;
<                 f16 = f15;
<                 f20 = f17;
<             } else {
<                 float f21 = MathHelper.sin((float)f12) * 0.25f;
<                 float f22 = MathHelper.cos((float)f12) * 0.25f;
<                 float f23 = 8.0f;
<                 f13 = textureatlassprite.getInterpolatedU((double)(8.0f + (-f22 - f21) * 16.0f));
<                 f17 = textureatlassprite.getInterpolatedV((double)(8.0f + (-f22 + f21) * 16.0f));
<                 f14 = textureatlassprite.getInterpolatedU((double)(8.0f + (-f22 + f21) * 16.0f));
<                 f18 = textureatlassprite.getInterpolatedV((double)(8.0f + (f22 + f21) * 16.0f));
<                 f15 = textureatlassprite.getInterpolatedU((double)(8.0f + (f22 + f21) * 16.0f));
<                 f19 = textureatlassprite.getInterpolatedV((double)(8.0f + (f22 - f21) * 16.0f));
<                 f16 = textureatlassprite.getInterpolatedU((double)(8.0f + (f22 - f21) * 16.0f));
<                 f20 = textureatlassprite.getInterpolatedV((double)(8.0f + (-f22 - f21) * 16.0f));
<             }
<             int k2 = blockStateIn.b(blockAccess, blockPosIn);
<             int l2 = k2 >> 16 & 0xFFFF;
<             int i3 = k2 & 0xFFFF;
<             float f24 = 1.0f * f;
<             float f25 = 1.0f * f1;
<             float f26 = 1.0f * f2;
<             bufferBuilderIn.pos(d0 + 0.0, d1 + (double)f7, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f13, (double)f17).lightmap(l2, i3).endVertex();
<             bufferBuilderIn.pos(d0 + 0.0, d1 + (double)f8, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f14, (double)f18).lightmap(l2, i3).endVertex();
<             bufferBuilderIn.pos(d0 + 1.0, d1 + (double)f9, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f15, (double)f19).lightmap(l2, i3).endVertex();
<             bufferBuilderIn.pos(d0 + 1.0, d1 + (double)f10, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f16, (double)f20).lightmap(l2, i3).endVertex();
<             if (blockliquid.shouldRenderSides(blockAccess, blockPosIn.up())) {
<                 bufferBuilderIn.pos(d0 + 0.0, d1 + (double)f7, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f13, (double)f17).lightmap(l2, i3).endVertex();
<                 bufferBuilderIn.pos(d0 + 1.0, d1 + (double)f10, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f16, (double)f20).lightmap(l2, i3).endVertex();
<                 bufferBuilderIn.pos(d0 + 1.0, d1 + (double)f9, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f15, (double)f19).lightmap(l2, i3).endVertex();
<                 bufferBuilderIn.pos(d0 + 0.0, d1 + (double)f8, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f14, (double)f18).lightmap(l2, i3).endVertex();
---
>     /*
>      * WARNING - Removed try catching itself - possible behaviour change.
>      */
>     public boolean renderFluid(IBlockAccess blockAccess, IBlockState blockStateIn, BlockPos blockPosIn, BufferBuilder worldRendererIn) {
>         try {
>             if (Config.isShaders()) {
>                 SVertexBuilder.pushEntity((IBlockState)blockStateIn, (BlockPos)blockPosIn, (IBlockAccess)blockAccess, (BufferBuilder)worldRendererIn);
145a82,296
>             BlockLiquid blockliquid = (BlockLiquid)blockStateIn.getBlock();
>             boolean flag = blockStateIn.a() == Material.LAVA;
>             TextureAtlasSprite[] atextureatlassprite = flag ? this.atlasSpritesLava : this.atlasSpritesWater;
>             RenderEnv renderEnv = worldRendererIn.getRenderEnv(blockStateIn, blockPosIn);
>             int i = CustomColors.getFluidColor((IBlockAccess)blockAccess, (IBlockState)blockStateIn, (BlockPos)blockPosIn, (RenderEnv)renderEnv);
>             float f = (float)(i >> 16 & 0xFF) / 255.0f;
>             float f1 = (float)(i >> 8 & 0xFF) / 255.0f;
>             float f2 = (float)(i & 0xFF) / 255.0f;
>             boolean flag1 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.UP);
>             boolean flag2 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.DOWN);
>             boolean[] aboolean = renderEnv.getBorderFlags();
>             aboolean[0] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.NORTH);
>             aboolean[1] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.SOUTH);
>             aboolean[2] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.WEST);
>             aboolean[3] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.EAST);
>             if (!(flag1 || flag2 || aboolean[0] || aboolean[1] || aboolean[2] || aboolean[3])) {
>                 boolean bl = false;
>                 return bl;
>             }
>             boolean flag3 = false;
>             float f3 = 0.5f;
>             float f4 = 1.0f;
>             float f5 = 0.8f;
>             float f6 = 0.6f;
>             Material material = blockStateIn.a();
>             float f7 = this.getFluidHeight(blockAccess, blockPosIn, material);
>             float f8 = this.getFluidHeight(blockAccess, blockPosIn.south(), material);
>             float f9 = this.getFluidHeight(blockAccess, blockPosIn.east().south(), material);
>             float f10 = this.getFluidHeight(blockAccess, blockPosIn.east(), material);
>             double d0 = blockPosIn.p();
>             double d1 = blockPosIn.q();
>             double d2 = blockPosIn.r();
>             float f11 = 0.001f;
>             if (flag1) {
>                 float f20;
>                 float f16;
>                 float f19;
>                 float f15;
>                 float f18;
>                 float f14;
>                 float f17;
>                 float f13;
>                 flag3 = true;
>                 float f12 = BlockLiquid.getSlopeAngle((IBlockAccess)blockAccess, (BlockPos)blockPosIn, (Material)material, (IBlockState)blockStateIn);
>                 TextureAtlasSprite textureatlassprite = f12 > -999.0f ? atextureatlassprite[1] : atextureatlassprite[0];
>                 worldRendererIn.setSprite(textureatlassprite);
>                 f7 -= 0.001f;
>                 f8 -= 0.001f;
>                 f9 -= 0.001f;
>                 f10 -= 0.001f;
>                 if (f12 < -999.0f) {
>                     f13 = textureatlassprite.getInterpolatedU(0.0);
>                     f17 = textureatlassprite.getInterpolatedV(0.0);
>                     f14 = f13;
>                     f18 = textureatlassprite.getInterpolatedV(16.0);
>                     f15 = textureatlassprite.getInterpolatedU(16.0);
>                     f19 = f18;
>                     f16 = f15;
>                     f20 = f17;
>                 } else {
>                     float f21 = MathHelper.sin((float)f12) * 0.25f;
>                     float f22 = MathHelper.cos((float)f12) * 0.25f;
>                     float f23 = 8.0f;
>                     f13 = textureatlassprite.getInterpolatedU((double)(8.0f + (-f22 - f21) * 16.0f));
>                     f17 = textureatlassprite.getInterpolatedV((double)(8.0f + (-f22 + f21) * 16.0f));
>                     f14 = textureatlassprite.getInterpolatedU((double)(8.0f + (-f22 + f21) * 16.0f));
>                     f18 = textureatlassprite.getInterpolatedV((double)(8.0f + (f22 + f21) * 16.0f));
>                     f15 = textureatlassprite.getInterpolatedU((double)(8.0f + (f22 + f21) * 16.0f));
>                     f19 = textureatlassprite.getInterpolatedV((double)(8.0f + (f22 - f21) * 16.0f));
>                     f16 = textureatlassprite.getInterpolatedU((double)(8.0f + (f22 - f21) * 16.0f));
>                     f20 = textureatlassprite.getInterpolatedV((double)(8.0f + (-f22 - f21) * 16.0f));
>                 }
>                 int k2 = blockStateIn.b(blockAccess, blockPosIn);
>                 int l2 = k2 >> 16 & 0xFFFF;
>                 int i3 = k2 & 0xFFFF;
>                 float f24 = 1.0f * f;
>                 float f25 = 1.0f * f1;
>                 float f26 = 1.0f * f2;
>                 worldRendererIn.pos(d0 + 0.0, d1 + (double)f7, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f13, (double)f17).lightmap(l2, i3).endVertex();
>                 worldRendererIn.pos(d0 + 0.0, d1 + (double)f8, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f14, (double)f18).lightmap(l2, i3).endVertex();
>                 worldRendererIn.pos(d0 + 1.0, d1 + (double)f9, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f15, (double)f19).lightmap(l2, i3).endVertex();
>                 worldRendererIn.pos(d0 + 1.0, d1 + (double)f10, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f16, (double)f20).lightmap(l2, i3).endVertex();
>                 if (blockliquid.shouldRenderSides(blockAccess, blockPosIn.up())) {
>                     worldRendererIn.pos(d0 + 0.0, d1 + (double)f7, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f13, (double)f17).lightmap(l2, i3).endVertex();
>                     worldRendererIn.pos(d0 + 1.0, d1 + (double)f10, d2 + 0.0).color(f24, f25, f26, 1.0f).tex((double)f16, (double)f20).lightmap(l2, i3).endVertex();
>                     worldRendererIn.pos(d0 + 1.0, d1 + (double)f9, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f15, (double)f19).lightmap(l2, i3).endVertex();
>                     worldRendererIn.pos(d0 + 0.0, d1 + (double)f8, d2 + 1.0).color(f24, f25, f26, 1.0f).tex((double)f14, (double)f18).lightmap(l2, i3).endVertex();
>                 }
>             }
>             if (flag2) {
>                 worldRendererIn.setSprite(atextureatlassprite[0]);
>                 float f35 = atextureatlassprite[0].getMinU();
>                 float f36 = atextureatlassprite[0].getMaxU();
>                 float f37 = atextureatlassprite[0].getMinV();
>                 float f38 = atextureatlassprite[0].getMaxV();
>                 int l1 = blockStateIn.b(blockAccess, blockPosIn.down());
>                 int i2 = l1 >> 16 & 0xFFFF;
>                 int j2 = l1 & 0xFFFF;
>                 float fbr = FaceBakery.getFaceBrightness((EnumFacing)EnumFacing.DOWN);
>                 worldRendererIn.pos(d0, d1, d2 + 1.0).color(f * fbr, f1 * fbr, f2 * fbr, 1.0f).tex((double)f35, (double)f38).lightmap(i2, j2).endVertex();
>                 worldRendererIn.pos(d0, d1, d2).color(f * fbr, f1 * fbr, f2 * fbr, 1.0f).tex((double)f35, (double)f37).lightmap(i2, j2).endVertex();
>                 worldRendererIn.pos(d0 + 1.0, d1, d2).color(f * fbr, f1 * fbr, f2 * fbr, 1.0f).tex((double)f36, (double)f37).lightmap(i2, j2).endVertex();
>                 worldRendererIn.pos(d0 + 1.0, d1, d2 + 1.0).color(f * fbr, f1 * fbr, f2 * fbr, 1.0f).tex((double)f36, (double)f38).lightmap(i2, j2).endVertex();
>                 flag3 = true;
>             }
>             for (int i1 = 0; i1 < 4; ++i1) {
>                 double d6;
>                 double d4;
>                 double d5;
>                 double d3;
>                 float f40;
>                 float f39;
>                 int j1 = 0;
>                 int k1 = 0;
>                 if (i1 == 0) {
>                     --k1;
>                 }
>                 if (i1 == 1) {
>                     ++k1;
>                 }
>                 if (i1 == 2) {
>                     --j1;
>                 }
>                 if (i1 == 3) {
>                     ++j1;
>                 }
>                 BlockPos blockpos = blockPosIn.add(j1, 0, k1);
>                 TextureAtlasSprite textureatlassprite1 = atextureatlassprite[1];
>                 worldRendererIn.setSprite(textureatlassprite1);
>                 float yMin1 = 0.0f;
>                 float yMin2 = 0.0f;
>                 if (!flag) {
>                     BlockSlab blockSlab;
>                     IBlockState blockState = blockAccess.getBlockState(blockpos);
>                     Block block = blockState.getBlock();
>                     if (block == Blocks.GLASS || block == Blocks.STAINED_GLASS || block == Blocks.BEACON || block == Blocks.SLIME_BLOCK) {
>                         textureatlassprite1 = this.atlasSpriteWaterOverlay;
>                         worldRendererIn.setSprite(textureatlassprite1);
>                     }
>                     if (block == Blocks.FARMLAND || block == Blocks.GRASS_PATH) {
>                         yMin1 = 0.9375f;
>                         yMin2 = 0.9375f;
>                     }
>                     if (block instanceof BlockSlab && !(blockSlab = (BlockSlab)block).isDouble() && blockState.getValue((IProperty)BlockSlab.HALF) == BlockSlab.EnumBlockHalf.BOTTOM) {
>                         yMin1 = 0.5f;
>                         yMin2 = 0.5f;
>                     }
>                 }
>                 if (!aboolean[i1]) continue;
>                 if (i1 == 0) {
>                     f39 = f7;
>                     f40 = f10;
>                     d3 = d0;
>                     d5 = d0 + 1.0;
>                     d4 = d2 + (double)0.001f;
>                     d6 = d2 + (double)0.001f;
>                 } else if (i1 == 1) {
>                     f39 = f9;
>                     f40 = f8;
>                     d3 = d0 + 1.0;
>                     d5 = d0;
>                     d4 = d2 + 1.0 - (double)0.001f;
>                     d6 = d2 + 1.0 - (double)0.001f;
>                 } else if (i1 == 2) {
>                     f39 = f8;
>                     f40 = f7;
>                     d3 = d0 + (double)0.001f;
>                     d5 = d0 + (double)0.001f;
>                     d4 = d2 + 1.0;
>                     d6 = d2;
>                 } else {
>                     f39 = f10;
>                     f40 = f9;
>                     d3 = d0 + 1.0 - (double)0.001f;
>                     d5 = d0 + 1.0 - (double)0.001f;
>                     d4 = d2;
>                     d6 = d2 + 1.0;
>                 }
>                 if (f39 <= yMin1 && f40 <= yMin2) continue;
>                 yMin1 = Math.min((float)yMin1, (float)f39);
>                 yMin2 = Math.min((float)yMin2, (float)f40);
>                 if (yMin1 > f11) {
>                     yMin1 -= f11;
>                 }
>                 if (yMin2 > f11) {
>                     yMin2 -= f11;
>                 }
>                 flag3 = true;
>                 float f41 = textureatlassprite1.getInterpolatedU(0.0);
>                 float f27 = textureatlassprite1.getInterpolatedU(8.0);
>                 float f28 = textureatlassprite1.getInterpolatedV((double)((1.0f - f39) * 16.0f * 0.5f));
>                 float f29 = textureatlassprite1.getInterpolatedV((double)((1.0f - f40) * 16.0f * 0.5f));
>                 float f30 = textureatlassprite1.getInterpolatedV(8.0);
>                 float vMin1 = textureatlassprite1.getInterpolatedV((double)((1.0f - yMin1) * 16.0f * 0.5f));
>                 float vMin2 = textureatlassprite1.getInterpolatedV((double)((1.0f - yMin2) * 16.0f * 0.5f));
>                 int j = blockStateIn.b(blockAccess, blockpos);
>                 int k = j >> 16 & 0xFFFF;
>                 int l = j & 0xFFFF;
>                 float f31 = i1 < 2 ? FaceBakery.getFaceBrightness((EnumFacing)EnumFacing.NORTH) : FaceBakery.getFaceBrightness((EnumFacing)EnumFacing.WEST);
>                 float f32 = 1.0f * f31 * f;
>                 float f33 = 1.0f * f31 * f1;
>                 float f34 = 1.0f * f31 * f2;
>                 worldRendererIn.pos(d3, d1 + (double)f39, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f28).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d5, d1 + (double)f40, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f29).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d5, d1 + (double)yMin2, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)vMin2).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d3, d1 + (double)yMin1, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)vMin1).lightmap(k, l).endVertex();
>                 if (textureatlassprite1 == this.atlasSpriteWaterOverlay) continue;
>                 worldRendererIn.pos(d3, d1 + (double)yMin1, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)vMin1).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d5, d1 + (double)yMin2, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)vMin2).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d5, d1 + (double)f40, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f29).lightmap(k, l).endVertex();
>                 worldRendererIn.pos(d3, d1 + (double)f39, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f28).lightmap(k, l).endVertex();
>             }
>             worldRendererIn.setSprite(null);
>             boolean bl = flag3;
>             return bl;
147,239c298,301
<         if (flag2) {
<             float f35 = atextureatlassprite[0].getMinU();
<             float f36 = atextureatlassprite[0].getMaxU();
<             float f37 = atextureatlassprite[0].getMinV();
<             float f38 = atextureatlassprite[0].getMaxV();
<             int l1 = blockStateIn.b(blockAccess, blockPosIn.down());
<             int i2 = l1 >> 16 & 0xFFFF;
<             int j2 = l1 & 0xFFFF;
<             bufferBuilderIn.pos(d0, d1, d2 + 1.0).color(0.5f, 0.5f, 0.5f, 1.0f).tex((double)f35, (double)f38).lightmap(i2, j2).endVertex();
<             bufferBuilderIn.pos(d0, d1, d2).color(0.5f, 0.5f, 0.5f, 1.0f).tex((double)f35, (double)f37).lightmap(i2, j2).endVertex();
<             bufferBuilderIn.pos(d0 + 1.0, d1, d2).color(0.5f, 0.5f, 0.5f, 1.0f).tex((double)f36, (double)f37).lightmap(i2, j2).endVertex();
<             bufferBuilderIn.pos(d0 + 1.0, d1, d2 + 1.0).color(0.5f, 0.5f, 0.5f, 1.0f).tex((double)f36, (double)f38).lightmap(i2, j2).endVertex();
<             flag3 = true;
<         }
<         for (int i1 = 0; i1 < 4; ++i1) {
<             double d6;
<             double d4;
<             double d5;
<             double d3;
<             float f40;
<             float f39;
<             IBlockState state;
<             int j1 = 0;
<             int k1 = 0;
<             if (i1 == 0) {
<                 --k1;
<             }
<             if (i1 == 1) {
<                 ++k1;
<             }
<             if (i1 == 2) {
<                 --j1;
<             }
<             if (i1 == 3) {
<                 ++j1;
<             }
<             BlockPos blockpos = blockPosIn.add(j1, 0, k1);
<             TextureAtlasSprite textureatlassprite1 = atextureatlassprite[1];
<             if (!flag && (state = blockAccess.getBlockState(blockpos)).d(blockAccess, blockpos, EnumFacing.VALUES[i1 + 2].getOpposite()) == BlockFaceShape.SOLID) {
<                 textureatlassprite1 = this.atlasSpriteWaterOverlay;
<             }
<             if (!aboolean[i1]) continue;
<             if (i1 == 0) {
<                 f39 = f7;
<                 f40 = f10;
<                 d3 = d0;
<                 d5 = d0 + 1.0;
<                 d4 = d2 + (double)0.001f;
<                 d6 = d2 + (double)0.001f;
<             } else if (i1 == 1) {
<                 f39 = f9;
<                 f40 = f8;
<                 d3 = d0 + 1.0;
<                 d5 = d0;
<                 d4 = d2 + 1.0 - (double)0.001f;
<                 d6 = d2 + 1.0 - (double)0.001f;
<             } else if (i1 == 2) {
<                 f39 = f8;
<                 f40 = f7;
<                 d3 = d0 + (double)0.001f;
<                 d5 = d0 + (double)0.001f;
<                 d4 = d2 + 1.0;
<                 d6 = d2;
<             } else {
<                 f39 = f10;
<                 f40 = f9;
<                 d3 = d0 + 1.0 - (double)0.001f;
<                 d5 = d0 + 1.0 - (double)0.001f;
<                 d4 = d2;
<                 d6 = d2 + 1.0;
<             }
<             flag3 = true;
<             float f41 = textureatlassprite1.getInterpolatedU(0.0);
<             float f27 = textureatlassprite1.getInterpolatedU(8.0);
<             float f28 = textureatlassprite1.getInterpolatedV((double)((1.0f - f39) * 16.0f * 0.5f));
<             float f29 = textureatlassprite1.getInterpolatedV((double)((1.0f - f40) * 16.0f * 0.5f));
<             float f30 = textureatlassprite1.getInterpolatedV(8.0);
<             int j = blockStateIn.b(blockAccess, blockpos);
<             int k = j >> 16 & 0xFFFF;
<             int l = j & 0xFFFF;
<             float f31 = i1 < 2 ? 0.8f : 0.6f;
<             float f32 = 1.0f * f31 * f;
<             float f33 = 1.0f * f31 * f1;
<             float f34 = 1.0f * f31 * f2;
<             bufferBuilderIn.pos(d3, d1 + (double)f39, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f28).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d5, d1 + (double)f40, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f29).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d5, d1 + 0.0, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f30).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d3, d1 + 0.0, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f30).lightmap(k, l).endVertex();
<             if (textureatlassprite1 == this.atlasSpriteWaterOverlay) continue;
<             bufferBuilderIn.pos(d3, d1 + 0.0, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f30).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d5, d1 + 0.0, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f30).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d5, d1 + (double)f40, d6).color(f32, f33, f34, 1.0f).tex((double)f27, (double)f29).lightmap(k, l).endVertex();
<             bufferBuilderIn.pos(d3, d1 + (double)f39, d4).color(f32, f33, f34, 1.0f).tex((double)f41, (double)f28).lightmap(k, l).endVertex();
---
>         finally {
>             if (Config.isShaders()) {
>                 SVertexBuilder.popEntity((BufferBuilder)worldRendererIn);
>             }
241d302
<         return flag3;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$AmbientOcclusionFace.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$AmbientOcclusionFace.java
9a10
>  *  net.minecraft.client.renderer.BlockModelRenderer$Orientation
13c14
<  *  net.minecraft.util.math.BlockPos$PooledMutableBlockPos
---
>  *  net.minecraft.util.math.BlockPos$MutableBlockPos
16,17d16
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
28,29d26
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
34,35c31
< @SideOnly(value=Side.CLIENT)
< class BlockModelRenderer.AmbientOcclusionFace {
---
> public static class BlockModelRenderer.AmbientOcclusionFace {
37a34
>     private BlockPos.MutableBlockPos[] blockPosArr = new BlockPos.MutableBlockPos[5];
39c36,55
<     BlockModelRenderer.AmbientOcclusionFace(BlockModelRenderer this$0) {
---
>     public BlockModelRenderer.AmbientOcclusionFace() {
>         this(null);
>     }
> 
>     public BlockModelRenderer.AmbientOcclusionFace(BlockModelRenderer bmr) {
>         for (int i = 0; i < this.blockPosArr.length; ++i) {
>             this.blockPosArr[i] = new BlockPos.MutableBlockPos();
>         }
>     }
> 
>     public void setMaxBlockLight() {
>         int maxBlockLight = 240;
>         this.vertexBrightness[0] = this.vertexBrightness[0] | maxBlockLight;
>         this.vertexBrightness[1] = this.vertexBrightness[1] | maxBlockLight;
>         this.vertexBrightness[2] = this.vertexBrightness[2] | maxBlockLight;
>         this.vertexBrightness[3] = this.vertexBrightness[3] | maxBlockLight;
>         this.vertexColorMultiplier[0] = 1.0f;
>         this.vertexColorMultiplier[1] = 1.0f;
>         this.vertexColorMultiplier[2] = 1.0f;
>         this.vertexColorMultiplier[3] = 1.0f;
52c68
<         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
---
>         BlockPos.MutableBlockPos blockpos$pooledmutableblockpos = this.blockPosArr[0].setPos(0, 0, 0);
54,57c70,73
<         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos1 = BlockPos.PooledMutableBlockPos.retain((Vec3i)blockpos).move(blockmodelrenderer$enumneighborinfo.corners[0]);
<         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos2 = BlockPos.PooledMutableBlockPos.retain((Vec3i)blockpos).move(blockmodelrenderer$enumneighborinfo.corners[1]);
<         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos3 = BlockPos.PooledMutableBlockPos.retain((Vec3i)blockpos).move(blockmodelrenderer$enumneighborinfo.corners[2]);
<         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos4 = BlockPos.PooledMutableBlockPos.retain((Vec3i)blockpos).move(blockmodelrenderer$enumneighborinfo.corners[3]);
---
>         BlockPos.MutableBlockPos blockpos$pooledmutableblockpos1 = this.blockPosArr[1].setPos((Vec3i)blockpos).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[0]);
>         BlockPos.MutableBlockPos blockpos$pooledmutableblockpos2 = this.blockPosArr[2].setPos((Vec3i)blockpos).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[1]);
>         BlockPos.MutableBlockPos blockpos$pooledmutableblockpos3 = this.blockPosArr[3].setPos((Vec3i)blockpos).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2]);
>         BlockPos.MutableBlockPos blockpos$pooledmutableblockpos4 = this.blockPosArr[4].setPos((Vec3i)blockpos).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3]);
65a82,85
>         f = BlockModelRenderer.fixAoLightValue((float)f);
>         f1 = BlockModelRenderer.fixAoLightValue((float)f1);
>         f2 = BlockModelRenderer.fixAoLightValue((float)f2);
>         f3 = BlockModelRenderer.fixAoLightValue((float)f3);
74c94
<             BlockPos.PooledMutableBlockPos blockpos1 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos1).move(blockmodelrenderer$enumneighborinfo.corners[2]);
---
>             BlockPos.MutableBlockPos blockpos1 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos1).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2]);
75a96
>             f4 = BlockModelRenderer.fixAoLightValue((float)f4);
82c103
<             BlockPos.PooledMutableBlockPos blockpos2 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos1).move(blockmodelrenderer$enumneighborinfo.corners[3]);
---
>             BlockPos.MutableBlockPos blockpos2 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos1).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3]);
83a105
>             f5 = BlockModelRenderer.fixAoLightValue((float)f5);
90c112
<             BlockPos.PooledMutableBlockPos blockpos3 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos2).move(blockmodelrenderer$enumneighborinfo.corners[2]);
---
>             BlockPos.MutableBlockPos blockpos3 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos2).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2]);
91a114
>             f6 = BlockModelRenderer.fixAoLightValue((float)f6);
98c121
<             BlockPos.PooledMutableBlockPos blockpos4 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos2).move(blockmodelrenderer$enumneighborinfo.corners[3]);
---
>             BlockPos.MutableBlockPos blockpos4 = blockpos$pooledmutableblockpos.setPos((Vec3i)blockpos$pooledmutableblockpos2).move(BlockModelRenderer.EnumNeighborInfo.access$200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3]);
99a123
>             f7 = BlockModelRenderer.fixAoLightValue((float)f7);
106a131
>         f8 = BlockModelRenderer.fixAoLightValue((float)f8);
108,113c133
<         blockpos$pooledmutableblockpos.release();
<         blockpos$pooledmutableblockpos1.release();
<         blockpos$pooledmutableblockpos2.release();
<         blockpos$pooledmutableblockpos3.release();
<         blockpos$pooledmutableblockpos4.release();
<         if (shapeState.get(1) && blockmodelrenderer$enumneighborinfo.doNonCubicWeight) {
---
>         if (shapeState.get(1) && BlockModelRenderer.EnumNeighborInfo.access$300((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)) {
118,137c138,157
<             float f13 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[0].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[1].shape];
<             float f14 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[2].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[3].shape];
<             float f15 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[4].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[5].shape];
<             float f16 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[6].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[7].shape];
<             float f17 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[0].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[1].shape];
<             float f18 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[2].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[3].shape];
<             float f19 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[4].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[5].shape];
<             float f20 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[6].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[7].shape];
<             float f21 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[0].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[1].shape];
<             float f22 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[2].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[3].shape];
<             float f23 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[4].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[5].shape];
<             float f24 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[6].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[7].shape];
<             float f25 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[0].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[1].shape];
<             float f26 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[2].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[3].shape];
<             float f27 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[4].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[5].shape];
<             float f28 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[6].shape] * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[7].shape];
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert0] = f29 * f13 + f30 * f14 + f31 * f15 + f32 * f16;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert1] = f29 * f17 + f30 * f18 + f31 * f19 + f32 * f20;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert2] = f29 * f21 + f30 * f22 + f31 * f23 + f32 * f24;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert3] = f29 * f25 + f30 * f26 + f31 * f27 + f32 * f28;
---
>             float f13 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[0])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[1])];
>             float f14 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3])];
>             float f15 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[4])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[5])];
>             float f16 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[6])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$800((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[7])];
>             float f17 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[0])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[1])];
>             float f18 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3])];
>             float f19 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[4])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[5])];
>             float f20 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[6])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1000((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[7])];
>             float f21 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[0])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[1])];
>             float f22 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3])];
>             float f23 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[4])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[5])];
>             float f24 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[6])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1100((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[7])];
>             float f25 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[0])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[1])];
>             float f26 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[2])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[3])];
>             float f27 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[4])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[5])];
>             float f28 = faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[6])] * faceShape[BlockModelRenderer.Orientation.access$900((BlockModelRenderer.Orientation)BlockModelRenderer.EnumNeighborInfo.access$1200((BlockModelRenderer.EnumNeighborInfo)blockmodelrenderer$enumneighborinfo)[7])];
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$400((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f29 * f13 + f30 * f14 + f31 * f15 + f32 * f16;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$500((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f29 * f17 + f30 * f18 + f31 * f19 + f32 * f20;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$600((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f29 * f21 + f30 * f22 + f31 * f23 + f32 * f24;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$700((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f29 * f25 + f30 * f26 + f31 * f27 + f32 * f28;
142,145c162,165
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert0] = this.getVertexBrightness(i2, j2, k2, l2, f13, f14, f15, f16);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert1] = this.getVertexBrightness(i2, j2, k2, l2, f17, f18, f19, f20);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert2] = this.getVertexBrightness(i2, j2, k2, l2, f21, f22, f23, f24);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert3] = this.getVertexBrightness(i2, j2, k2, l2, f25, f26, f27, f28);
---
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$400((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getVertexBrightness(i2, j2, k2, l2, f13, f14, f15, f16);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$500((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getVertexBrightness(i2, j2, k2, l2, f17, f18, f19, f20);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$600((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getVertexBrightness(i2, j2, k2, l2, f21, f22, f23, f24);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$700((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getVertexBrightness(i2, j2, k2, l2, f25, f26, f27, f28);
151,158c171,178
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert0] = this.getAoBrightness(l, i, j1, i3);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert1] = this.getAoBrightness(k, i, i1, i3);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert2] = this.getAoBrightness(k, j, k1, i3);
<             this.vertexBrightness[blockmodelrenderer$vertextranslations.vert3] = this.getAoBrightness(l, j, l1, i3);
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert0] = f9;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert1] = f10;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert2] = f11;
<             this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert3] = f12;
---
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$400((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getAoBrightness(l, i, j1, i3);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$500((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getAoBrightness(k, i, i1, i3);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$600((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getAoBrightness(k, j, k1, i3);
>             this.vertexBrightness[BlockModelRenderer.VertexTranslations.access$700((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = this.getAoBrightness(l, j, l1, i3);
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$400((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f9;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$500((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f10;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$600((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f11;
>             this.vertexColorMultiplier[BlockModelRenderer.VertexTranslations.access$700((BlockModelRenderer.VertexTranslations)blockmodelrenderer$vertextranslations)] = f12;
178a199,206
>     }
> 
>     static /* synthetic */ int[] access$000(BlockModelRenderer.AmbientOcclusionFace x0) {
>         return x0.vertexBrightness;
>     }
> 
>     static /* synthetic */ float[] access$100(BlockModelRenderer.AmbientOcclusionFace x0) {
>         return x0.vertexColorMultiplier;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$EnumNeighborInfo.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$EnumNeighborInfo.java
8,9d7
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
15,16d12
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
18d13
< @SideOnly(value=Side.CLIENT)
47a43,66
>     }
> 
>     static /* synthetic */ EnumFacing[] access$200(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.corners;
>     }
> 
>     static /* synthetic */ boolean access$300(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.doNonCubicWeight;
>     }
> 
>     static /* synthetic */ BlockModelRenderer.Orientation[] access$800(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.vert0Weights;
>     }
> 
>     static /* synthetic */ BlockModelRenderer.Orientation[] access$1000(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.vert1Weights;
>     }
> 
>     static /* synthetic */ BlockModelRenderer.Orientation[] access$1100(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.vert2Weights;
>     }
> 
>     static /* synthetic */ BlockModelRenderer.Orientation[] access$1200(BlockModelRenderer.EnumNeighborInfo x0) {
>         return x0.vert3Weights;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$Orientation.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$Orientation.java
7,8d6
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
13,14d10
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
16d11
< @SideOnly(value=Side.CLIENT)
34a30,33
>     }
> 
>     static /* synthetic */ int access$900(BlockModelRenderer.Orientation x0) {
>         return x0.shape;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$VertexTranslations.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer$VertexTranslations.java
7,8d6
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
13,14d10
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
16d11
< @SideOnly(value=Side.CLIENT)
39a35,50
>     }
> 
>     static /* synthetic */ int access$400(BlockModelRenderer.VertexTranslations x0) {
>         return x0.vert0;
>     }
> 
>     static /* synthetic */ int access$500(BlockModelRenderer.VertexTranslations x0) {
>         return x0.vert1;
>     }
> 
>     static /* synthetic */ int access$600(BlockModelRenderer.VertexTranslations x0) {
>         return x0.vert2;
>     }
> 
>     static /* synthetic */ int access$700(BlockModelRenderer.VertexTranslations x0) {
>         return x0.vert3;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BlockModelRenderer.java
4a5
>  *  Config
20a22
>  *  net.minecraft.client.renderer.RegionRenderCacheBuilder
22a25
>  *  net.minecraft.client.renderer.block.model.FaceBakery
28a32
>  *  net.minecraft.util.BlockRenderLayer
36,38c40,49
<  *  net.minecraftforge.client.model.pipeline.LightUtil
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.BetterSnow
>  *  net.optifine.CustomColors
>  *  net.optifine.model.BlockModelCustomizer
>  *  net.optifine.model.ListQuadsOverlay
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.render.RenderEnv
>  *  net.optifine.shaders.SVertexBuilder
>  *  net.optifine.shaders.Shaders
51a63
> import net.minecraft.client.renderer.RegionRenderCacheBuilder;
53a66
> import net.minecraft.client.renderer.block.model.FaceBakery;
59a73
> import net.minecraft.util.BlockRenderLayer;
67,69c81,90
< import net.minecraftforge.client.model.pipeline.LightUtil;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.BetterSnow;
> import net.optifine.CustomColors;
> import net.optifine.model.BlockModelCustomizer;
> import net.optifine.model.ListQuadsOverlay;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.render.RenderEnv;
> import net.optifine.shaders.SVertexBuilder;
> import net.optifine.shaders.Shaders;
71c92,94
< @SideOnly(value=Side.CLIENT)
---
> /*
>  * Exception performing whole class analysis ignored.
>  */
73a97,99
>     private static float aoLightValueOpaque = 0.2f;
>     private static boolean separateAoLightValue = false;
>     private static final BlockRenderLayer[] OVERLAY_LAYERS = new BlockRenderLayer[]{BlockRenderLayer.CUTOUT, BlockRenderLayer.CUTOUT_MIPPED, BlockRenderLayer.TRANSLUCENT};
76a103,105
>         if (Reflector.ForgeModContainer_forgeLightPipelineEnabled.exists()) {
>             Reflector.setFieldValue((ReflectorField)Reflector.ForgeModContainer_forgeLightPipelineEnabled, (Object)false);
>         }
84c113
<         boolean flag = Minecraft.isAmbientOcclusionEnabled() && stateIn.getLightValue(worldIn, posIn) == 0 && modelIn.isAmbientOcclusion(stateIn);
---
>         boolean flag = Minecraft.isAmbientOcclusionEnabled() && ReflectorForge.getLightValue((IBlockState)stateIn, (IBlockAccess)worldIn, (BlockPos)posIn) == 0 && ReflectorForge.isAmbientOcclusion((IBakedModel)modelIn, (IBlockState)stateIn);
86c115,131
<             return flag ? this.renderModelSmooth(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand) : this.renderModelFlat(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand);
---
>             boolean rendered;
>             if (Config.isShaders()) {
>                 SVertexBuilder.pushEntity((IBlockState)stateIn, (BlockPos)posIn, (IBlockAccess)worldIn, (BufferBuilder)buffer);
>             }
>             if (!Config.isAlternateBlocks()) {
>                 rand = 0L;
>             }
>             RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
>             modelIn = BlockModelCustomizer.getRenderModel((IBakedModel)modelIn, (IBlockState)stateIn, (RenderEnv)renderEnv);
>             boolean bl = rendered = flag ? this.renderModelSmooth(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand) : this.renderModelFlat(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand);
>             if (rendered) {
>                 this.renderOverlayModels(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand, renderEnv, flag);
>             }
>             if (Config.isShaders()) {
>                 SVertexBuilder.popEntity((BufferBuilder)buffer);
>             }
>             return rendered;
99,102c144,146
<         float[] afloat = new float[EnumFacing.values().length * 2];
<         BitSet bitset = new BitSet(3);
<         AmbientOcclusionFace blockmodelrenderer$ambientocclusionface = new AmbientOcclusionFace(this);
<         for (EnumFacing enumfacing : EnumFacing.values()) {
---
>         RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
>         BlockRenderLayer layer = buffer.getBlockLayer();
>         for (EnumFacing enumfacing : EnumFacing.VALUES) {
105c149,150
<             this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, (List<BakedQuad>)list, afloat, bitset, blockmodelrenderer$ambientocclusionface);
---
>             list = BlockModelCustomizer.getRenderQuads((List)list, (IBlockAccess)worldIn, (IBlockState)stateIn, (BlockPos)posIn, (EnumFacing)enumfacing, (BlockRenderLayer)layer, (long)rand, (RenderEnv)renderEnv);
>             this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, (List<BakedQuad>)list, renderEnv);
110c155,156
<             this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, (List<BakedQuad>)list1, afloat, bitset, blockmodelrenderer$ambientocclusionface);
---
>             list1 = BlockModelCustomizer.getRenderQuads((List)list1, (IBlockAccess)worldIn, (IBlockState)stateIn, (BlockPos)posIn, null, (BlockRenderLayer)layer, (long)rand, (RenderEnv)renderEnv);
>             this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, (List<BakedQuad>)list1, renderEnv);
118,119c164,166
<         BitSet bitset = new BitSet(3);
<         for (EnumFacing enumfacing : EnumFacing.values()) {
---
>         RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
>         BlockRenderLayer layer = buffer.getBlockLayer();
>         for (EnumFacing enumfacing : EnumFacing.VALUES) {
123c170,171
<             this.renderQuadsFlat(worldIn, stateIn, posIn, i, false, buffer, (List<BakedQuad>)list, bitset);
---
>             list = BlockModelCustomizer.getRenderQuads((List)list, (IBlockAccess)worldIn, (IBlockState)stateIn, (BlockPos)posIn, (EnumFacing)enumfacing, (BlockRenderLayer)layer, (long)rand, (RenderEnv)renderEnv);
>             this.renderQuadsFlat(worldIn, stateIn, posIn, i, false, buffer, (List<BakedQuad>)list, renderEnv);
128c176,177
<             this.renderQuadsFlat(worldIn, stateIn, posIn, -1, true, buffer, (List<BakedQuad>)list1, bitset);
---
>             list1 = BlockModelCustomizer.getRenderQuads((List)list1, (IBlockAccess)worldIn, (IBlockState)stateIn, (BlockPos)posIn, null, (BlockRenderLayer)layer, (long)rand, (RenderEnv)renderEnv);
>             this.renderQuadsFlat(worldIn, stateIn, posIn, -1, true, buffer, (List<BakedQuad>)list1, renderEnv);
134c183,186
<     private void renderQuadsSmooth(IBlockAccess blockAccessIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, List<BakedQuad> list, float[] quadBounds, BitSet bitSet, AmbientOcclusionFace aoFace) {
---
>     private void renderQuadsSmooth(IBlockAccess blockAccessIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, List<BakedQuad> list, RenderEnv renderEnv) {
>         float[] quadBounds = renderEnv.getQuadBounds();
>         BitSet bitSet = renderEnv.getBoundsFlags();
>         AmbientOcclusionFace aoFace = renderEnv.getAoFace();
144,151c196,197
<             buffer.addVertexData(bakedquad.getVertexData());
<             buffer.putBrightness4(aoFace.vertexBrightness[0], aoFace.vertexBrightness[1], aoFace.vertexBrightness[2], aoFace.vertexBrightness[3]);
<             if (bakedquad.shouldApplyDiffuseLighting()) {
<                 float diffuse = LightUtil.diffuseLight((EnumFacing)bakedquad.getFace());
<                 aoFace.vertexColorMultiplier[0] = aoFace.vertexColorMultiplier[0] * diffuse;
<                 aoFace.vertexColorMultiplier[1] = aoFace.vertexColorMultiplier[1] * diffuse;
<                 aoFace.vertexColorMultiplier[2] = aoFace.vertexColorMultiplier[2] * diffuse;
<                 aoFace.vertexColorMultiplier[3] = aoFace.vertexColorMultiplier[3] * diffuse;
---
>             if (bakedquad.getSprite().isEmissive) {
>                 aoFace.setMaxBlockLight();
153,154c199,222
<             if (bakedquad.hasTintIndex()) {
<                 int k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
---
>             if (buffer.isMultiTexture()) {
>                 buffer.addVertexData(bakedquad.getVertexDataSingle());
>             } else {
>                 buffer.addVertexData(bakedquad.getVertexData());
>             }
>             buffer.putSprite(bakedquad.getSprite());
>             buffer.putBrightness4(AmbientOcclusionFace.access$000((AmbientOcclusionFace)aoFace)[0], AmbientOcclusionFace.access$000((AmbientOcclusionFace)aoFace)[1], AmbientOcclusionFace.access$000((AmbientOcclusionFace)aoFace)[2], AmbientOcclusionFace.access$000((AmbientOcclusionFace)aoFace)[3]);
>             if (bakedquad.shouldApplyDiffuseLighting()) {
>                 float diffuse = FaceBakery.getFaceBrightness((EnumFacing)bakedquad.getFace());
>                 float[] fArray = AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace);
>                 fArray[0] = fArray[0] * diffuse;
>                 float[] fArray2 = AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace);
>                 fArray2[1] = fArray2[1] * diffuse;
>                 float[] fArray3 = AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace);
>                 fArray3[2] = fArray3[2] * diffuse;
>                 float[] fArray4 = AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace);
>                 fArray4[3] = fArray4[3] * diffuse;
>             }
>             int colorMultiplier = CustomColors.getColorMultiplier((BakedQuad)bakedquad, (IBlockState)stateIn, (IBlockAccess)blockAccessIn, (BlockPos)posIn, (RenderEnv)renderEnv);
>             if (bakedquad.hasTintIndex() || colorMultiplier != -1) {
>                 int k = colorMultiplier;
>                 if (colorMultiplier == -1) {
>                     k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
>                 }
161,164c229,244
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[0] * f, aoFace.vertexColorMultiplier[0] * f1, aoFace.vertexColorMultiplier[0] * f2, 4);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[1] * f, aoFace.vertexColorMultiplier[1] * f1, aoFace.vertexColorMultiplier[1] * f2, 3);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[2] * f, aoFace.vertexColorMultiplier[2] * f1, aoFace.vertexColorMultiplier[2] * f2, 2);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[3] * f, aoFace.vertexColorMultiplier[3] * f1, aoFace.vertexColorMultiplier[3] * f2, 1);
---
>                 if (separateAoLightValue) {
>                     buffer.putColorMultiplierRgba(f, f1, f2, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0], 4);
>                     buffer.putColorMultiplierRgba(f, f1, f2, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1], 3);
>                     buffer.putColorMultiplierRgba(f, f1, f2, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2], 2);
>                     buffer.putColorMultiplierRgba(f, f1, f2, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3], 1);
>                 } else {
>                     buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0] * f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0] * f1, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0] * f2, 4);
>                     buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1] * f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1] * f1, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1] * f2, 3);
>                     buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2] * f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2] * f1, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2] * f2, 2);
>                     buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3] * f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3] * f1, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3] * f2, 1);
>                 }
>             } else if (separateAoLightValue) {
>                 buffer.putColorMultiplierRgba(1.0f, 1.0f, 1.0f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0], 4);
>                 buffer.putColorMultiplierRgba(1.0f, 1.0f, 1.0f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1], 3);
>                 buffer.putColorMultiplierRgba(1.0f, 1.0f, 1.0f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2], 2);
>                 buffer.putColorMultiplierRgba(1.0f, 1.0f, 1.0f, AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3], 1);
166,169c246,249
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[0], aoFace.vertexColorMultiplier[0], aoFace.vertexColorMultiplier[0], 4);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[1], aoFace.vertexColorMultiplier[1], aoFace.vertexColorMultiplier[1], 3);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[2], aoFace.vertexColorMultiplier[2], aoFace.vertexColorMultiplier[2], 2);
<                 buffer.putColorMultiplier(aoFace.vertexColorMultiplier[3], aoFace.vertexColorMultiplier[3], aoFace.vertexColorMultiplier[3], 1);
---
>                 buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[0], 4);
>                 buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[1], 3);
>                 buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[2], 2);
>                 buffer.putColorMultiplier(AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3], AmbientOcclusionFace.access$100((AmbientOcclusionFace)aoFace)[3], 1);
181a262
>         int step = vertexData.length / 4;
183,185c264,266
<             float f6 = Float.intBitsToFloat((int)vertexData[i * 7]);
<             float f7 = Float.intBitsToFloat((int)vertexData[i * 7 + 1]);
<             float f8 = Float.intBitsToFloat((int)vertexData[i * 7 + 2]);
---
>             float f6 = Float.intBitsToFloat((int)vertexData[i * step]);
>             float f7 = Float.intBitsToFloat((int)vertexData[i * step + 1]);
>             float f8 = Float.intBitsToFloat((int)vertexData[i * step + 2]);
200c281
<             int j = EnumFacing.values().length;
---
>             int j = EnumFacing.VALUES.length;
243c324,325
<     private void renderQuadsFlat(IBlockAccess blockAccessIn, IBlockState stateIn, BlockPos posIn, int brightnessIn, boolean ownBrightness, BufferBuilder buffer, List<BakedQuad> list, BitSet bitSet) {
---
>     private void renderQuadsFlat(IBlockAccess blockAccessIn, IBlockState stateIn, BlockPos posIn, int brightnessIn, boolean ownBrightness, BufferBuilder buffer, List<BakedQuad> list, RenderEnv renderEnv) {
>         BitSet bitSet = renderEnv.getBoundsFlags();
256c338,346
<             buffer.addVertexData(bakedquad.getVertexData());
---
>             if (bakedquad.getSprite().isEmissive) {
>                 brightnessIn |= 0xF0;
>             }
>             if (buffer.isMultiTexture()) {
>                 buffer.addVertexData(bakedquad.getVertexDataSingle());
>             } else {
>                 buffer.addVertexData(bakedquad.getVertexData());
>             }
>             buffer.putSprite(bakedquad.getSprite());
258,259c348,353
<             if (bakedquad.hasTintIndex()) {
<                 int k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
---
>             int colorMultiplier = CustomColors.getColorMultiplier((BakedQuad)bakedquad, (IBlockState)stateIn, (IBlockAccess)blockAccessIn, (BlockPos)posIn, (RenderEnv)renderEnv);
>             if (bakedquad.hasTintIndex() || colorMultiplier != -1) {
>                 int k = colorMultiplier;
>                 if (colorMultiplier == -1) {
>                     k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
>                 }
267c361
<                     float diffuse = LightUtil.diffuseLight((EnumFacing)bakedquad.getFace());
---
>                     float diffuse = FaceBakery.getFaceBrightness((EnumFacing)bakedquad.getFace());
277c371
<                 float diffuse = LightUtil.diffuseLight((EnumFacing)bakedquad.getFace());
---
>                 float diffuse = FaceBakery.getFaceBrightness((EnumFacing)bakedquad.getFace());
292c386
<         for (EnumFacing enumfacing : EnumFacing.values()) {
---
>         for (EnumFacing enumfacing : EnumFacing.VALUES) {
321a416
>             bufferbuilder.putSprite(bakedquad.getSprite());
329a425,475
>         }
>     }
> 
>     public static float fixAoLightValue(float val) {
>         if (val == 0.2f) {
>             return aoLightValueOpaque;
>         }
>         return val;
>     }
> 
>     public static void updateAoLightValue() {
>         aoLightValueOpaque = 1.0f - Config.getAmbientOcclusionLevel() * 0.8f;
>         separateAoLightValue = Config.isShaders() && Shaders.isSeparateAo();
>     }
> 
>     private void renderOverlayModels(IBlockAccess worldIn, IBakedModel modelIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, boolean checkSides, long rand, RenderEnv renderEnv, boolean smooth) {
>         if (renderEnv.isOverlaysRendered()) {
>             for (int l = 0; l < OVERLAY_LAYERS.length; ++l) {
>                 BlockRenderLayer layer = OVERLAY_LAYERS[l];
>                 ListQuadsOverlay listQuadsOverlay = renderEnv.getListQuadsOverlay(layer);
>                 if (listQuadsOverlay.size() <= 0) continue;
>                 RegionRenderCacheBuilder rrcb = renderEnv.getRegionRenderCacheBuilder();
>                 if (rrcb != null) {
>                     BufferBuilder overlayBuffer = rrcb.getWorldRendererByLayer(layer);
>                     if (!overlayBuffer.isDrawing()) {
>                         overlayBuffer.begin(7, DefaultVertexFormats.BLOCK);
>                         overlayBuffer.setTranslation(buffer.getXOffset(), buffer.getYOffset(), buffer.getZOffset());
>                     }
>                     for (int q = 0; q < listQuadsOverlay.size(); ++q) {
>                         BakedQuad quad = listQuadsOverlay.getQuad(q);
>                         List listQuadSingle = listQuadsOverlay.getListQuadsSingle(quad);
>                         IBlockState quadBlockState = listQuadsOverlay.getBlockState(q);
>                         if (quad.getQuadEmissive() != null) {
>                             listQuadsOverlay.addQuad(quad.getQuadEmissive(), quadBlockState);
>                         }
>                         renderEnv.reset(quadBlockState, posIn);
>                         if (smooth) {
>                             this.renderQuadsSmooth(worldIn, quadBlockState, posIn, overlayBuffer, (List<BakedQuad>)listQuadSingle, renderEnv);
>                             continue;
>                         }
>                         int col = quadBlockState.b(worldIn, posIn.offset(quad.getFace()));
>                         this.renderQuadsFlat(worldIn, quadBlockState, posIn, col, false, overlayBuffer, (List<BakedQuad>)listQuadSingle, renderEnv);
>                     }
>                 }
>                 listQuadsOverlay.clear();
>             }
>         }
>         if (Config.isBetterSnow() && !renderEnv.isBreakingAnimation() && BetterSnow.shouldRender((IBlockAccess)worldIn, (IBlockState)stateIn, (BlockPos)posIn)) {
>             IBakedModel modelSnow = BetterSnow.getModelSnowLayer();
>             IBlockState stateSnow = BetterSnow.getStateSnowLayer();
>             this.renderModel(worldIn, modelSnow, stateSnow, posIn, buffer, checkSides, rand);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BufferBuilder$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BufferBuilder$1.java
19c19
<     BufferBuilder.1() {
---
>     BufferBuilder.1(float[] fArray) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BufferBuilder$State.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BufferBuilder$State.java
6c6
<  *  net.minecraft.client.renderer.BufferBuilder
---
>  *  net.minecraft.client.renderer.texture.TextureAtlasSprite
8,9d7
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
13c11
< import net.minecraft.client.renderer.BufferBuilder;
---
> import net.minecraft.client.renderer.texture.TextureAtlasSprite;
15,16d12
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
18d13
< @SideOnly(value=Side.CLIENT)
21a17
>     private TextureAtlasSprite[] stateQuadSprites;
23c19,25
<     public BufferBuilder.State(BufferBuilder this$0, int[] buffer, VertexFormat format) {
---
>     public BufferBuilder.State(int[] buffer, VertexFormat format, TextureAtlasSprite[] quadSprites) {
>         this.stateRawBuffer = buffer;
>         this.stateVertexFormat = format;
>         this.stateQuadSprites = quadSprites;
>     }
> 
>     public BufferBuilder.State(int[] buffer, VertexFormat format) {
37a40,43
>     }
> 
>     static /* synthetic */ TextureAtlasSprite[] access$000(BufferBuilder.State x0) {
>         return x0.stateQuadSprites;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/BufferBuilder.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/BufferBuilder.java
4a5
>  *  Config
7a9
>  *  java.lang.Math
8a11
>  *  java.lang.System
16a20
>  *  net.minecraft.block.state.IBlockState
19a24
>  *  net.minecraft.client.renderer.texture.TextureAtlasSprite
22a28,29
>  *  net.minecraft.util.BlockRenderLayer
>  *  net.minecraft.util.math.BlockPos
24,25c31,34
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.SmartAnimations
>  *  net.optifine.render.RenderEnv
>  *  net.optifine.shaders.SVertexBuilder
>  *  net.optifine.util.TextureUtils
27a37
>  *  org.lwjgl.opengl.GL11
38a49
> import net.minecraft.block.state.IBlockState;
40a52
> import net.minecraft.client.renderer.texture.TextureAtlasSprite;
42a55,56
> import net.minecraft.util.BlockRenderLayer;
> import net.minecraft.util.math.BlockPos;
44,45c58,61
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.SmartAnimations;
> import net.optifine.render.RenderEnv;
> import net.optifine.shaders.SVertexBuilder;
> import net.optifine.util.TextureUtils;
47a64
> import org.lwjgl.opengl.GL11;
49c66,68
< @SideOnly(value=Side.CLIENT)
---
> /*
>  * Exception performing whole class analysis ignored.
>  */
53c72
<     private IntBuffer rawIntBuffer;
---
>     public IntBuffer rawIntBuffer;
55,56c74,75
<     private FloatBuffer rawFloatBuffer;
<     private int vertexCount;
---
>     public FloatBuffer rawFloatBuffer;
>     public int vertexCount;
60c79
<     private int drawMode;
---
>     public int drawMode;
65a85,95
>     private BlockRenderLayer blockLayer = null;
>     private boolean[] drawnIcons = new boolean[256];
>     private TextureAtlasSprite[] quadSprites = null;
>     private TextureAtlasSprite[] quadSpritesPrev = null;
>     private TextureAtlasSprite quadSprite = null;
>     public SVertexBuilder sVertexBuilder;
>     public RenderEnv renderEnv = null;
>     public BitSet animatedSprites = null;
>     public BitSet animatedSpritesCached = new BitSet();
>     private boolean modeTriangles = false;
>     private ByteBuffer byteBufferTriangles;
71a102
>         SVertexBuilder.initVertexBuilder((BufferBuilder)this);
74,75c105,106
<     private void growBuffer(int increaseAmount) {
<         if (MathHelper.roundUp((int)increaseAmount, (int)4) / 4 > this.rawIntBuffer.remaining() || this.vertexCount * this.vertexFormat.getSize() + increaseAmount > this.byteBuffer.capacity()) {
---
>     private void growBuffer(int p_181670_1_) {
>         if (MathHelper.roundUp((int)p_181670_1_, (int)4) / 4 > this.rawIntBuffer.remaining() || this.vertexCount * this.vertexFormat.getSize() + p_181670_1_ > this.byteBuffer.capacity()) {
77c108
<             int j = i + MathHelper.roundUp((int)increaseAmount, (int)0x200000);
---
>             int j = i + MathHelper.roundUp((int)p_181670_1_, (int)0x200000);
85c116
<             this.rawFloatBuffer = this.byteBuffer.asFloatBuffer().asReadOnlyBuffer();
---
>             this.rawFloatBuffer = this.byteBuffer.asFloatBuffer();
89a121,127
>             if (this.quadSprites != null) {
>                 TextureAtlasSprite[] sprites = this.quadSprites;
>                 int quadSize = this.getBufferQuadSize();
>                 this.quadSprites = new TextureAtlasSprite[quadSize];
>                 System.arraycopy((Object)sprites, (int)0, (Object)this.quadSprites, (int)0, (int)Math.min((int)sprites.length, (int)this.quadSprites.length));
>                 this.quadSpritesPrev = null;
>             }
93c131
<     public void sortVertexData(float cameraX, float cameraY, float cameraZ) {
---
>     public void sortVertexData(float p_181674_1_, float p_181674_2_, float p_181674_3_) {
97c135
<             afloat[j] = BufferBuilder.getDistanceSq(this.rawFloatBuffer, (float)((double)cameraX + this.xOffset), (float)((double)cameraY + this.yOffset), (float)((double)cameraZ + this.zOffset), this.vertexFormat.getIntegerSize(), j * this.vertexFormat.getSize());
---
>             afloat[j] = BufferBuilder.getDistanceSq(this.rawFloatBuffer, (float)((double)p_181674_1_ + this.xOffset), (float)((double)p_181674_2_ + this.yOffset), (float)((double)p_181674_3_ + this.zOffset), this.vertexFormat.getIntegerSize(), j * this.vertexFormat.getSize());
135a174,184
>         if (this.quadSprites != null) {
>             TextureAtlasSprite[] quadSpritesSorted = new TextureAtlasSprite[this.vertexCount / 4];
>             int quadStep = this.vertexFormat.getSize() / 4 * 4;
>             int ix = 0;
>             while (ix < ainteger.length) {
>                 int indexQuad = ainteger[ix].intValue();
>                 int indexQuadSorted = ix++;
>                 quadSpritesSorted[indexQuadSorted] = this.quadSprites[indexQuad];
>             }
>             System.arraycopy((Object)quadSpritesSorted, (int)0, (Object)this.quadSprites, (int)0, (int)quadSpritesSorted.length);
>         }
146c195,201
<         return new State(this, aint, new VertexFormat(this.vertexFormat));
---
>         TextureAtlasSprite[] quadSpritesCopy = null;
>         if (this.quadSprites != null) {
>             int countQuads = this.vertexCount / 4;
>             quadSpritesCopy = new TextureAtlasSprite[countQuads];
>             System.arraycopy((Object)this.quadSprites, (int)0, (Object)quadSpritesCopy, (int)0, (int)countQuads);
>         }
>         return new State(this, aint, new VertexFormat(this.vertexFormat), quadSpritesCopy);
149c204
<     private int getBufferSize() {
---
>     public int getBufferSize() {
153,168c208,223
<     private static float getDistanceSq(FloatBuffer floatBufferIn, float x, float y, float z, int integerSize, int offset) {
<         float f = floatBufferIn.get(offset + integerSize * 0 + 0);
<         float f1 = floatBufferIn.get(offset + integerSize * 0 + 1);
<         float f2 = floatBufferIn.get(offset + integerSize * 0 + 2);
<         float f3 = floatBufferIn.get(offset + integerSize * 1 + 0);
<         float f4 = floatBufferIn.get(offset + integerSize * 1 + 1);
<         float f5 = floatBufferIn.get(offset + integerSize * 1 + 2);
<         float f6 = floatBufferIn.get(offset + integerSize * 2 + 0);
<         float f7 = floatBufferIn.get(offset + integerSize * 2 + 1);
<         float f8 = floatBufferIn.get(offset + integerSize * 2 + 2);
<         float f9 = floatBufferIn.get(offset + integerSize * 3 + 0);
<         float f10 = floatBufferIn.get(offset + integerSize * 3 + 1);
<         float f11 = floatBufferIn.get(offset + integerSize * 3 + 2);
<         float f12 = (f + f3 + f6 + f9) * 0.25f - x;
<         float f13 = (f1 + f4 + f7 + f10) * 0.25f - y;
<         float f14 = (f2 + f5 + f8 + f11) * 0.25f - z;
---
>     private static float getDistanceSq(FloatBuffer p_181665_0_, float p_181665_1_, float p_181665_2_, float p_181665_3_, int p_181665_4_, int p_181665_5_) {
>         float f = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 0);
>         float f1 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 1);
>         float f2 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 2);
>         float f3 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 0);
>         float f4 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 1);
>         float f5 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 2);
>         float f6 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 0);
>         float f7 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 1);
>         float f8 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 2);
>         float f9 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 0);
>         float f10 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 1);
>         float f11 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 2);
>         float f12 = (f + f3 + f6 + f9) * 0.25f - p_181665_1_;
>         float f13 = (f1 + f4 + f7 + f10) * 0.25f - p_181665_2_;
>         float f14 = (f2 + f5 + f8 + f11) * 0.25f - p_181665_3_;
177a233,247
>         if (State.access$000((State)state) != null) {
>             if (this.quadSprites == null) {
>                 this.quadSprites = this.quadSpritesPrev;
>             }
>             if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
>                 this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
>             }
>             TextureAtlasSprite[] src = State.access$000((State)state);
>             System.arraycopy((Object)src, (int)0, (Object)this.quadSprites, (int)0, (int)src.length);
>         } else {
>             if (this.quadSprites != null) {
>                 this.quadSpritesPrev = this.quadSprites;
>             }
>             this.quadSprites = null;
>         }
183a254,263
>         this.quadSprite = null;
>         if (SmartAnimations.isActive()) {
>             if (this.animatedSprites == null) {
>                 this.animatedSprites = this.animatedSpritesCached;
>             }
>             this.animatedSprites.clear();
>         } else if (this.animatedSprites != null) {
>             this.animatedSprites = null;
>         }
>         this.modeTriangles = false;
196a277,294
>         if (Config.isShaders()) {
>             SVertexBuilder.endSetVertexFormat((BufferBuilder)this);
>         }
>         if (Config.isMultiTexture()) {
>             if (this.blockLayer != null) {
>                 if (this.quadSprites == null) {
>                     this.quadSprites = this.quadSpritesPrev;
>                 }
>                 if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
>                     this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
>                 }
>             }
>         } else {
>             if (this.quadSprites != null) {
>                 this.quadSpritesPrev = this.quadSprites;
>             }
>             this.quadSprites = null;
>         }
199a298,302
>         if (this.quadSprite != null && this.quadSprites != null) {
>             u = this.quadSprite.toSingleU((float)u);
>             v = this.quadSprite.toSingleV((float)v);
>             this.quadSprites[this.vertexCount / 4] = this.quadSprite;
>         }
229c332
<     public BufferBuilder lightmap(int skyLight, int blockLight) {
---
>     public BufferBuilder lightmap(int p_187314_1_, int p_187314_2_) {
233,234c336,337
<                 this.byteBuffer.putFloat(i, (float)skyLight);
<                 this.byteBuffer.putFloat(i + 4, (float)blockLight);
---
>                 this.byteBuffer.putFloat(i, (float)p_187314_1_);
>                 this.byteBuffer.putFloat(i + 4, (float)p_187314_2_);
239,240c342,343
<                 this.byteBuffer.putInt(i, skyLight);
<                 this.byteBuffer.putInt(i + 4, blockLight);
---
>                 this.byteBuffer.putInt(i, p_187314_1_);
>                 this.byteBuffer.putInt(i + 4, p_187314_2_);
245,246c348,349
<                 this.byteBuffer.putShort(i, (short)blockLight);
<                 this.byteBuffer.putShort(i + 2, (short)skyLight);
---
>                 this.byteBuffer.putShort(i, (short)p_187314_2_);
>                 this.byteBuffer.putShort(i + 2, (short)p_187314_1_);
251,252c354,355
<                 this.byteBuffer.put(i, (byte)blockLight);
<                 this.byteBuffer.put(i + 1, (byte)skyLight);
---
>                 this.byteBuffer.put(i, (byte)p_187314_2_);
>                 this.byteBuffer.put(i + 1, (byte)p_187314_1_);
259c362
<     public void putBrightness4(int vertex0, int vertex1, int vertex2, int vertex3) {
---
>     public void putBrightness4(int p_178962_1_, int p_178962_2_, int p_178962_3_, int p_178962_4_) {
262,265c365,368
<         this.rawIntBuffer.put(i, vertex0);
<         this.rawIntBuffer.put(i + j, vertex1);
<         this.rawIntBuffer.put(i + j * 2, vertex2);
<         this.rawIntBuffer.put(i + j * 3, vertex3);
---
>         this.rawIntBuffer.put(i, p_178962_1_);
>         this.rawIntBuffer.put(i + j, p_178962_2_);
>         this.rawIntBuffer.put(i + j * 2, p_178962_3_);
>         this.rawIntBuffer.put(i + j * 3, p_178962_4_);
387a491,493
>         if (Config.isShaders()) {
>             SVertexBuilder.beginAddVertexData((BufferBuilder)this, (int[])vertexData);
>         }
391a498,500
>         if (Config.isShaders()) {
>             SVertexBuilder.endAddVertexData((BufferBuilder)this);
>         }
396a506,510
>         this.vertexFormatIndex = 0;
>         this.vertexFormatElement = this.vertexFormat.getElement(this.vertexFormatIndex);
>         if (Config.isShaders()) {
>             SVertexBuilder.endAddVertex((BufferBuilder)this);
>         }
399a514,516
>         if (Config.isShaders()) {
>             SVertexBuilder.beginAddVertex((BufferBuilder)this);
>         }
504a622,624
>         if (this.modeTriangles) {
>             return this.byteBufferTriangles;
>         }
512a633,635
>         if (this.modeTriangles) {
>             return this.vertexCount / 4 * 6;
>         }
516a640,642
>         if (this.modeTriangles) {
>             return 4;
>         }
531a658,853
>     public void putSprite(TextureAtlasSprite sprite) {
>         if (this.animatedSprites != null && sprite != null && sprite.getAnimationIndex() >= 0) {
>             this.animatedSprites.set(sprite.getAnimationIndex());
>         }
>         if (this.quadSprites != null) {
>             int countQuads = this.vertexCount / 4;
>             this.quadSprites[countQuads - 1] = sprite;
>         }
>     }
> 
>     public void setSprite(TextureAtlasSprite sprite) {
>         if (this.animatedSprites != null && sprite != null && sprite.getAnimationIndex() >= 0) {
>             this.animatedSprites.set(sprite.getAnimationIndex());
>         }
>         if (this.quadSprites != null) {
>             this.quadSprite = sprite;
>         }
>     }
> 
>     public boolean isMultiTexture() {
>         return this.quadSprites != null;
>     }
> 
>     public void drawMultiTexture() {
>         if (this.quadSprites == null) {
>             return;
>         }
>         int maxTextureIndex = Config.getMinecraft().getTextureMapBlocks().getCountRegisteredSprites();
>         if (this.drawnIcons.length <= maxTextureIndex) {
>             this.drawnIcons = new boolean[maxTextureIndex + 1];
>         }
>         Arrays.fill((boolean[])this.drawnIcons, (boolean)false);
>         int texSwitch = 0;
>         int grassOverlayIndex = -1;
>         int countQuads = this.vertexCount / 4;
>         for (int i = 0; i < countQuads; ++i) {
>             int iconIndex;
>             TextureAtlasSprite icon = this.quadSprites[i];
>             if (icon == null || this.drawnIcons[iconIndex = icon.getIndexInMap()]) continue;
>             if (icon == TextureUtils.iconGrassSideOverlay) {
>                 if (grassOverlayIndex >= 0) continue;
>                 grassOverlayIndex = i;
>                 continue;
>             }
>             i = this.drawForIcon(icon, i) - 1;
>             ++texSwitch;
>             if (this.blockLayer == BlockRenderLayer.TRANSLUCENT) continue;
>             this.drawnIcons[iconIndex] = true;
>         }
>         if (grassOverlayIndex >= 0) {
>             this.drawForIcon(TextureUtils.iconGrassSideOverlay, grassOverlayIndex);
>             ++texSwitch;
>         }
>         if (texSwitch > 0) {
>             // empty if block
>         }
>     }
> 
>     private int drawForIcon(TextureAtlasSprite sprite, int startQuadPos) {
>         GL11.glBindTexture((int)3553, (int)sprite.glSpriteTextureId);
>         int firstRegionEnd = -1;
>         int lastPos = -1;
>         int countQuads = this.vertexCount / 4;
>         for (int i = startQuadPos; i < countQuads; ++i) {
>             TextureAtlasSprite ts = this.quadSprites[i];
>             if (ts == sprite) {
>                 if (lastPos >= 0) continue;
>                 lastPos = i;
>                 continue;
>             }
>             if (lastPos < 0) continue;
>             this.draw(lastPos, i);
>             if (this.blockLayer == BlockRenderLayer.TRANSLUCENT) {
>                 return i;
>             }
>             lastPos = -1;
>             if (firstRegionEnd >= 0) continue;
>             firstRegionEnd = i;
>         }
>         if (lastPos >= 0) {
>             this.draw(lastPos, countQuads);
>         }
>         if (firstRegionEnd < 0) {
>             firstRegionEnd = countQuads;
>         }
>         return firstRegionEnd;
>     }
> 
>     private void draw(int startQuadVertex, int endQuadVertex) {
>         int vxQuadCount = endQuadVertex - startQuadVertex;
>         if (vxQuadCount <= 0) {
>             return;
>         }
>         int startVertex = startQuadVertex * 4;
>         int vxCount = vxQuadCount * 4;
>         GL11.glDrawArrays((int)this.drawMode, (int)startVertex, (int)vxCount);
>     }
> 
>     public void setBlockLayer(BlockRenderLayer blockLayer) {
>         this.blockLayer = blockLayer;
>         if (blockLayer == null) {
>             if (this.quadSprites != null) {
>                 this.quadSpritesPrev = this.quadSprites;
>             }
>             this.quadSprites = null;
>             this.quadSprite = null;
>         }
>     }
> 
>     private int getBufferQuadSize() {
>         int quadSize = this.rawIntBuffer.capacity() * 4 / (this.vertexFormat.getIntegerSize() * 4);
>         return quadSize;
>     }
> 
>     public RenderEnv getRenderEnv(IBlockState blockStateIn, BlockPos blockPosIn) {
>         if (this.renderEnv == null) {
>             this.renderEnv = new RenderEnv(blockStateIn, blockPosIn);
>             return this.renderEnv;
>         }
>         this.renderEnv.reset(blockStateIn, blockPosIn);
>         return this.renderEnv;
>     }
> 
>     public boolean isDrawing() {
>         return this.isDrawing;
>     }
> 
>     public double getXOffset() {
>         return this.xOffset;
>     }
> 
>     public double getYOffset() {
>         return this.yOffset;
>     }
> 
>     public double getZOffset() {
>         return this.zOffset;
>     }
> 
>     public BlockRenderLayer getBlockLayer() {
>         return this.blockLayer;
>     }
> 
>     public void putColorMultiplierRgba(float red, float green, float blue, float alpha, int vertexIndex) {
>         int index = this.getColorIndex(vertexIndex);
>         int col = -1;
>         if (!this.noColor) {
>             col = this.rawIntBuffer.get(index);
>             if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
>                 int r = (int)((float)(col & 0xFF) * red);
>                 int g = (int)((float)(col >> 8 & 0xFF) * green);
>                 int b = (int)((float)(col >> 16 & 0xFF) * blue);
>                 int a = (int)((float)(col >> 24 & 0xFF) * alpha);
>                 col = a << 24 | b << 16 | g << 8 | r;
>             } else {
>                 int r = (int)((float)(col >> 24 & 0xFF) * red);
>                 int g = (int)((float)(col >> 16 & 0xFF) * green);
>                 int b = (int)((float)(col >> 8 & 0xFF) * blue);
>                 int a = (int)((float)(col & 0xFF) * alpha);
>                 col = r << 24 | g << 16 | b << 8 | a;
>             }
>         }
>         this.rawIntBuffer.put(index, col);
>     }
> 
>     public void quadsToTriangles() {
>         if (this.drawMode != 7) {
>             return;
>         }
>         if (this.byteBufferTriangles == null) {
>             this.byteBufferTriangles = GLAllocation.createDirectByteBuffer((int)(this.byteBuffer.capacity() * 2));
>         }
>         if (this.byteBufferTriangles.capacity() < this.byteBuffer.capacity() * 2) {
>             this.byteBufferTriangles = GLAllocation.createDirectByteBuffer((int)(this.byteBuffer.capacity() * 2));
>         }
>         int vertexSize = this.vertexFormat.getSize();
>         int limit = this.byteBuffer.limit();
>         this.byteBuffer.rewind();
>         this.byteBufferTriangles.clear();
>         for (int v = 0; v < this.vertexCount; v += 4) {
>             this.byteBuffer.limit((v + 3) * vertexSize);
>             this.byteBuffer.position(v * vertexSize);
>             this.byteBufferTriangles.put(this.byteBuffer);
>             this.byteBuffer.limit((v + 1) * vertexSize);
>             this.byteBuffer.position(v * vertexSize);
>             this.byteBufferTriangles.put(this.byteBuffer);
>             this.byteBuffer.limit((v + 2 + 2) * vertexSize);
>             this.byteBuffer.position((v + 2) * vertexSize);
>             this.byteBufferTriangles.put(this.byteBuffer);
>         }
>         this.byteBuffer.limit(limit);
>         this.byteBuffer.rewind();
>         this.byteBufferTriangles.flip();
>         this.modeTriangles = true;
>     }
> 
544a867,869
>         if (Config.isShaders()) {
>             SVertexBuilder.beginAddVertexData((BufferBuilder)this, (ByteBuffer)buffer);
>         }
548a874,876
>         if (Config.isShaders()) {
>             SVertexBuilder.endAddVertexData((BufferBuilder)this);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ChunkRenderContainer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ChunkRenderContainer.java
6a7
>  *  java.util.BitSet
11a13
>  *  net.optifine.SmartAnimations
15a18
> import java.util.BitSet;
20a24
> import net.optifine.SmartAnimations;
27a32,33
>     private BitSet animatedSpritesRendered;
>     private final BitSet animatedSpritesCached = new BitSet();
29c35
<     public void initialize(double d, double d2, double d3) {
---
>     public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
32,34c38,51
<         this.viewEntityX = d;
<         this.viewEntityY = d2;
<         this.viewEntityZ = d3;
---
>         this.viewEntityX = viewEntityXIn;
>         this.viewEntityY = viewEntityYIn;
>         this.viewEntityZ = viewEntityZIn;
>         if (SmartAnimations.isActive()) {
>             if (this.animatedSpritesRendered != null) {
>                 SmartAnimations.spritesRendered((BitSet)this.animatedSpritesRendered);
>             } else {
>                 this.animatedSpritesRendered = this.animatedSpritesCached;
>             }
>             this.animatedSpritesRendered.clear();
>         } else if (this.animatedSpritesRendered != null) {
>             SmartAnimations.spritesRendered((BitSet)this.animatedSpritesRendered);
>             this.animatedSpritesRendered = null;
>         }
37,39c54,56
<     public void preRenderChunk(RenderChunk renderChunk) {
<         BlockPos blockPos = renderChunk.getPosition();
<         GlStateManager.translate((float)((float)((double)blockPos.p() - this.viewEntityX)), (float)((float)((double)blockPos.q() - this.viewEntityY)), (float)((float)((double)blockPos.r() - this.viewEntityZ)));
---
>     public void preRenderChunk(RenderChunk renderChunkIn) {
>         BlockPos blockpos = renderChunkIn.getPosition();
>         GlStateManager.translate((float)((float)((double)blockpos.p() - this.viewEntityX)), (float)((float)((double)blockpos.q() - this.viewEntityY)), (float)((float)((double)blockpos.r() - this.viewEntityZ)));
42,43c59,64
<     public void addRenderChunk(RenderChunk renderChunk, BlockRenderLayer blockRenderLayer) {
<         this.renderChunks.add((Object)renderChunk);
---
>     public void addRenderChunk(RenderChunk renderChunkIn, BlockRenderLayer layer) {
>         BitSet animatedSprites;
>         this.renderChunks.add((Object)renderChunkIn);
>         if (this.animatedSpritesRendered != null && (animatedSprites = renderChunkIn.compiledChunk.getAnimatedSprites(layer)) != null) {
>             this.animatedSpritesRendered.or(animatedSprites);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/EntityRenderer$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/EntityRenderer$1.java
8d7
<  *  net.minecraft.client.renderer.EntityRenderer
15d13
< import net.minecraft.client.renderer.EntityRenderer;
20c18
<     EntityRenderer.1(EntityRenderer this$0) {
---
>     EntityRenderer.1() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/EntityRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/EntityRenderer.java
4a5
>  *  Config
14a16,17
>  *  java.lang.Boolean
>  *  java.lang.CharSequence
21a25,26
>  *  java.util.Calendar
>  *  java.util.Date
26a32
>  *  net.minecraft.block.BlockBed
27a34
>  *  net.minecraft.block.properties.IProperty
31a39,41
>  *  net.minecraft.client.gui.GuiChat
>  *  net.minecraft.client.gui.GuiDownloadTerrain
>  *  net.minecraft.client.gui.GuiMainMenu
34a45
>  *  net.minecraft.client.gui.advancements.GuiScreenAdvancements
49a61,62
>  *  net.minecraft.client.renderer.chunk.RenderChunk
>  *  net.minecraft.client.renderer.culling.ClippingHelper
56a70
>  *  net.minecraft.client.resources.I18n
58a73,74
>  *  net.minecraft.client.settings.GameSettings
>  *  net.minecraft.client.settings.KeyBinding
78a95
>  *  net.minecraft.server.integrated.IntegratedServer
94a112,116
>  *  net.minecraft.util.text.ITextComponent
>  *  net.minecraft.util.text.Style
>  *  net.minecraft.util.text.TextComponentString
>  *  net.minecraft.util.text.event.ClickEvent
>  *  net.minecraft.util.text.event.ClickEvent$Action
97a120
>  *  net.minecraft.world.WorldProvider
99,106c122,137
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.client.IRenderHandler
<  *  net.minecraftforge.client.event.EntityViewRenderEvent$CameraSetup
<  *  net.minecraftforge.client.event.EntityViewRenderEvent$FogColors
<  *  net.minecraftforge.common.MinecraftForge
<  *  net.minecraftforge.fml.common.eventhandler.Event
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomColors
>  *  net.optifine.GlErrors
>  *  net.optifine.Lagometer
>  *  net.optifine.RandomEntities
>  *  net.optifine.gui.GuiChatOF
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.reflect.ReflectorResolver
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.shaders.ShadersRender
>  *  net.optifine.util.MemoryMonitor
>  *  net.optifine.util.TextureUtils
>  *  net.optifine.util.TimedEvent
108a140
>  *  org.lwjgl.input.Keyboard
110a143
>  *  org.lwjgl.opengl.GL11
126a160,161
> import java.util.Calendar;
> import java.util.Date;
131a167
> import net.minecraft.block.BlockBed;
132a169
> import net.minecraft.block.properties.IProperty;
136a174,176
> import net.minecraft.client.gui.GuiChat;
> import net.minecraft.client.gui.GuiDownloadTerrain;
> import net.minecraft.client.gui.GuiMainMenu;
139a180
> import net.minecraft.client.gui.advancements.GuiScreenAdvancements;
151a193,194
> import net.minecraft.client.renderer.chunk.RenderChunk;
> import net.minecraft.client.renderer.culling.ClippingHelper;
158a202
> import net.minecraft.client.resources.I18n;
160a205,206
> import net.minecraft.client.settings.GameSettings;
> import net.minecraft.client.settings.KeyBinding;
180a227
> import net.minecraft.server.integrated.IntegratedServer;
194a242,245
> import net.minecraft.util.text.ITextComponent;
> import net.minecraft.util.text.Style;
> import net.minecraft.util.text.TextComponentString;
> import net.minecraft.util.text.event.ClickEvent;
197a249
> import net.minecraft.world.WorldProvider;
199,205c251,266
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.client.IRenderHandler;
< import net.minecraftforge.client.event.EntityViewRenderEvent;
< import net.minecraftforge.common.MinecraftForge;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomColors;
> import net.optifine.GlErrors;
> import net.optifine.Lagometer;
> import net.optifine.RandomEntities;
> import net.optifine.gui.GuiChatOF;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.reflect.ReflectorResolver;
> import net.optifine.shaders.Shaders;
> import net.optifine.shaders.ShadersRender;
> import net.optifine.util.MemoryMonitor;
> import net.optifine.util.TextureUtils;
> import net.optifine.util.TimedEvent;
207a269
> import org.lwjgl.input.Keyboard;
209a272
> import org.lwjgl.opengl.GL11;
213d275
< @SideOnly(value=Side.CLIENT)
225c287
<     public final ItemRenderer itemRenderer;
---
>     public ItemRenderer itemRenderer;
229,230c291,292
<     private final MouseFilter mouseFilterXAxis = new MouseFilter();
<     private final MouseFilter mouseFilterYAxis = new MouseFilter();
---
>     private MouseFilter mouseFilterXAxis = new MouseFilter();
>     private MouseFilter mouseFilterYAxis = new MouseFilter();
258,260c320,322
<     private float fogColorRed;
<     private float fogColorGreen;
<     private float fogColorBlue;
---
>     public float fogColorRed;
>     public float fogColorGreen;
>     public float fogColorBlue;
275c337
<     private int shaderIndex = SHADER_COUNT;
---
>     private int shaderIndex;
277c339,351
<     private int frameCount;
---
>     public int frameCount;
>     private boolean initialized = false;
>     private World updatedWorld = null;
>     public boolean fogStandard = false;
>     private float clipDistance = 128.0f;
>     private long lastServerTime = 0L;
>     private int lastServerTicks = 0;
>     private int serverWaitTime = 0;
>     private int serverWaitTimeCurrent = 0;
>     private float avgServerTimeDiff = 0.0f;
>     private float avgServerTickDiff = 0.0f;
>     private ShaderGroup[] fxaaShaders = new ShaderGroup[10];
>     private boolean loadVisibleChunks = false;
279a354
>         this.shaderIndex = SHADER_COUNT;
327,328c402,403
<             } else {
<                 ForgeHooksClient.loadEntityShader((Entity)entityIn, (EntityRenderer)this);
---
>             } else if (Reflector.ForgeHooksClient_loadEntityShader.exists()) {
>                 Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_loadEntityShader, (Object[])new Object[]{entityIn, this});
333c408,411
<     public void loadShader(ResourceLocation resourceLocationIn) {
---
>     private void loadShader(ResourceLocation resourceLocationIn) {
>         if (!OpenGlHelper.isFramebufferEnabled()) {
>             return;
>         }
388,389c466,472
<         float f3 = this.mc.world.getLightBrightness(new BlockPos(this.mc.getRenderViewEntity().getPositionEyes(1.0f)));
<         float f4 = (float)this.mc.gameSettings.renderDistanceChunks / 32.0f;
---
>         Entity viewEntity = this.mc.getRenderViewEntity();
>         double vx = viewEntity.posX;
>         double vy = viewEntity.posY + (double)viewEntity.getEyeHeight();
>         double vz = viewEntity.posZ;
>         float f3 = this.mc.world.getLightBrightness(new BlockPos(vx, vy, vz));
>         float f4 = (float)this.mc.gameSettings.renderDistanceChunks / 16.0f;
>         f4 = MathHelper.clamp((float)f4, (float)0.0f, (float)1.0f);
464c547,551
<                 if (entity1.getLowestRidingEntity() == entity.getLowestRidingEntity() && !entity1.canRiderInteract()) {
---
>                 boolean canRiderInteract = false;
>                 if (Reflector.ForgeEntity_canRiderInteract.exists()) {
>                     canRiderInteract = Reflector.callBoolean((Object)entity1, (ReflectorMethod)Reflector.ForgeEntity_canRiderInteract, (Object[])new Object[0]);
>                 }
>                 if (!canRiderInteract && entity1.getLowestRidingEntity() == entity.getLowestRidingEntity()) {
513c600,624
<             f *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * partialTicks;
---
>             if (Config.isDynamicFov()) {
>                 f *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * partialTicks;
>             }
>         }
>         boolean zoomActive = false;
>         if (this.mc.currentScreen == null) {
>             GameSettings cfr_ignored_0 = this.mc.gameSettings;
>             zoomActive = GameSettings.isKeyDown((KeyBinding)this.mc.gameSettings.ofKeyBindZoom);
>         }
>         if (zoomActive) {
>             if (!Config.zoomMode) {
>                 Config.zoomMode = true;
>                 Config.zoomSmoothCamera = this.mc.gameSettings.smoothCamera;
>                 this.mc.gameSettings.smoothCamera = true;
>                 this.mc.renderGlobal.displayListEntitiesDirty = true;
>             }
>             if (Config.zoomMode) {
>                 f /= 4.0f;
>             }
>         } else if (Config.zoomMode) {
>             Config.zoomMode = false;
>             this.mc.gameSettings.smoothCamera = Config.zoomSmoothCamera;
>             this.mouseFilterXAxis = new MouseFilter();
>             this.mouseFilterYAxis = new MouseFilter();
>             this.mc.renderGlobal.displayListEntitiesDirty = true;
522c633,636
<         return ForgeHooksClient.getFOVModifier((EntityRenderer)this, (Entity)entity, (IBlockState)iblockstate, (double)partialTicks, (float)f);
---
>         if (Reflector.ForgeHooksClient_getFOVModifier.exists()) {
>             return Reflector.callFloat((ReflectorMethod)Reflector.ForgeHooksClient_getFOVModifier, (Object[])new Object[]{this, entity, iblockstate, Float.valueOf((float)partialTicks), Float.valueOf((float)f)});
>         }
>         return f;
571c685,691
<                 ForgeHooksClient.orientBedCamera((IBlockAccess)this.mc.world, (BlockPos)blockpos, (IBlockState)iblockstate, (Entity)entity);
---
>                 Block block = iblockstate.getBlock();
>                 if (Reflector.ForgeHooksClient_orientBedCamera.exists()) {
>                     Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_orientBedCamera, (Object[])new Object[]{this.mc.world, blockpos, iblockstate, entity});
>                 } else if (block == Blocks.BED) {
>                     int j = ((EnumFacing)iblockstate.getValue((IProperty)BlockBed.D)).getHorizontalIndex();
>                     GlStateManager.rotate((float)(j * 90), (float)0.0f, (float)1.0f, (float)0.0f);
>                 }
609,612c729,749
<         if (!this.mc.gameSettings.debugCamEnable) {
<             float yaw = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0f;
<             float pitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
<             float roll = 0.0f;
---
>         if (Reflector.EntityViewRenderEvent_CameraSetup_Constructor.exists()) {
>             if (!this.mc.gameSettings.debugCamEnable) {
>                 float yaw = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0f;
>                 float pitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
>                 float roll = 0.0f;
>                 if (entity instanceof EntityAnimal) {
>                     EntityAnimal entityanimal = (EntityAnimal)entity;
>                     yaw = entityanimal.aQ + (entityanimal.aP - entityanimal.aQ) * partialTicks + 180.0f;
>                 }
>                 IBlockState state = ActiveRenderInfo.getBlockStateAtEntityViewpoint((World)this.mc.world, (Entity)entity, (float)partialTicks);
>                 Object event = Reflector.newInstance((ReflectorConstructor)Reflector.EntityViewRenderEvent_CameraSetup_Constructor, (Object[])new Object[]{this, entity, state, Float.valueOf((float)partialTicks), Float.valueOf((float)yaw), Float.valueOf((float)pitch), Float.valueOf((float)roll)});
>                 Reflector.postForgeBusEvent((Object)event);
>                 roll = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_CameraSetup_getRoll, (Object[])new Object[0]);
>                 pitch = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_CameraSetup_getPitch, (Object[])new Object[0]);
>                 yaw = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_CameraSetup_getYaw, (Object[])new Object[0]);
>                 GlStateManager.rotate((float)roll, (float)0.0f, (float)0.0f, (float)1.0f);
>                 GlStateManager.rotate((float)pitch, (float)1.0f, (float)0.0f, (float)0.0f);
>                 GlStateManager.rotate((float)yaw, (float)0.0f, (float)1.0f, (float)0.0f);
>             }
>         } else if (!this.mc.gameSettings.debugCamEnable) {
>             GlStateManager.rotate((float)(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks), (float)1.0f, (float)0.0f, (float)0.0f);
615c752,754
<                 yaw = entityanimal.aQ + (entityanimal.aP - entityanimal.aQ) * partialTicks + 180.0f;
---
>                 GlStateManager.rotate((float)(entityanimal.aQ + (entityanimal.aP - entityanimal.aQ) * partialTicks + 180.0f), (float)0.0f, (float)1.0f, (float)0.0f);
>             } else {
>                 GlStateManager.rotate((float)(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0f), (float)0.0f, (float)1.0f, (float)0.0f);
617,622d755
<             IBlockState state = ActiveRenderInfo.getBlockStateAtEntityViewpoint((World)this.mc.world, (Entity)entity, (float)partialTicks);
<             EntityViewRenderEvent.CameraSetup event = new EntityViewRenderEvent.CameraSetup(this, entity, state, (double)partialTicks, yaw, pitch, roll);
<             MinecraftForge.EVENT_BUS.post((Event)event);
<             GlStateManager.rotate((float)event.getRoll(), (float)0.0f, (float)0.0f, (float)1.0f);
<             GlStateManager.rotate((float)event.getPitch(), (float)1.0f, (float)0.0f, (float)0.0f);
<             GlStateManager.rotate((float)event.getYaw(), (float)0.0f, (float)1.0f, (float)0.0f);
631c764
<     private void setupCameraTransform(float partialTicks, int pass) {
---
>     public void setupCameraTransform(float partialTicks, int pass) {
633a767,772
>         if (Config.isFogFancy()) {
>             this.farPlaneDistance *= 0.95f;
>         }
>         if (Config.isFogFast()) {
>             this.farPlaneDistance *= 0.83f;
>         }
639a779,782
>         this.clipDistance = this.farPlaneDistance * 2.0f;
>         if (this.clipDistance < 173.0f) {
>             this.clipDistance = 173.0f;
>         }
644c787
<         Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.farPlaneDistance * MathHelper.SQRT_2));
---
>         Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)this.clipDistance);
691a835,838
>         this.renderHand(partialTicks, pass, true, true, false);
>     }
> 
>     public void renderHand(float partialTicks, int pass, boolean renderItem, boolean renderOverlay, boolean renderTranslucent) {
693d839
<             boolean flag;
699a846,848
>             if (Config.isShaders()) {
>                 Shaders.applyHandDepth();
>             }
706,709c855,874
<             GlStateManager.pushMatrix();
<             this.hurtCameraEffect(partialTicks);
<             if (this.mc.gameSettings.viewBobbing) {
<                 this.applyBobbing(partialTicks);
---
>             boolean flag = false;
>             if (renderItem) {
>                 boolean shouldRenderHand;
>                 GlStateManager.pushMatrix();
>                 this.hurtCameraEffect(partialTicks);
>                 if (this.mc.gameSettings.viewBobbing) {
>                     this.applyBobbing(partialTicks);
>                 }
>                 flag = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
>                 boolean bl = shouldRenderHand = !ReflectorForge.renderFirstPersonHand((RenderGlobal)this.mc.renderGlobal, (float)partialTicks, (int)pass);
>                 if (shouldRenderHand && this.mc.gameSettings.thirdPersonView == 0 && !flag && !this.mc.gameSettings.hideGUI && !this.mc.playerController.isSpectator()) {
>                     this.enableLightmap();
>                     if (Config.isShaders()) {
>                         ShadersRender.renderItemFP((ItemRenderer)this.itemRenderer, (float)partialTicks, (boolean)renderTranslucent);
>                     } else {
>                         this.itemRenderer.renderItemInFirstPerson(partialTicks);
>                     }
>                     this.disableLightmap();
>                 }
>                 GlStateManager.popMatrix();
711,715c876,877
<             boolean bl = flag = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
<             if (!(ForgeHooksClient.renderFirstPersonHand((RenderGlobal)this.mc.renderGlobal, (float)partialTicks, (int)pass) || this.mc.gameSettings.thirdPersonView != 0 || flag || this.mc.gameSettings.hideGUI || this.mc.playerController.isSpectator())) {
<                 this.enableLightmap();
<                 this.itemRenderer.renderItemInFirstPerson(partialTicks);
<                 this.disableLightmap();
---
>             if (!renderOverlay) {
>                 return;
717c879
<             GlStateManager.popMatrix();
---
>             this.disableLightmap();
731a894,896
>         if (Config.isShaders()) {
>             Shaders.disableLightmap();
>         }
745,746c910,911
<         GlStateManager.glTexParameteri((int)3553, (int)10242, (int)10496);
<         GlStateManager.glTexParameteri((int)3553, (int)10243, (int)10496);
---
>         GlStateManager.glTexParameteri((int)3553, (int)10242, (int)33071);
>         GlStateManager.glTexParameteri((int)3553, (int)10243, (int)33071);
749a915,917
>         if (Config.isShaders()) {
>             Shaders.enableLightmap();
>         }
763a932,937
>                 if (Config.isCustomColors() && CustomColors.updateLightmap((World)world, (float)this.torchFlickerX, (int[])this.lightmapColors, (boolean)this.mc.player.a(MobEffects.NIGHT_VISION), (float)partialTicks)) {
>                     this.lightmapTexture.updateDynamicTexture();
>                     this.lightmapUpdateNeeded = false;
>                     this.mc.profiler.endSection();
>                     return;
>                 }
793,797c967,973
<                     float[] colors = new float[]{f8, f9, f10};
<                     world.provider.getLightmapColors(partialTicks, f, f2, f3, colors);
<                     f8 = colors[0];
<                     f9 = colors[1];
<                     f10 = colors[2];
---
>                     if (Reflector.ForgeWorldProvider_getLightmapColors.exists()) {
>                         float[] colors = new float[]{f8, f9, f10};
>                         Reflector.call((Object)world.provider, (ReflectorMethod)Reflector.ForgeWorldProvider_getLightmapColors, (Object[])new Object[]{Float.valueOf((float)partialTicks), Float.valueOf((float)f), Float.valueOf((float)f2), Float.valueOf((float)f3), colors});
>                         f8 = colors[0];
>                         f9 = colors[1];
>                         f10 = colors[2];
>                     }
867c1043
<     private float getNightVisionBrightness(EntityLivingBase entitylivingbaseIn, float partialTicks) {
---
>     public float getNightVisionBrightness(EntityLivingBase entitylivingbaseIn, float partialTicks) {
872a1049
>         this.frameInit();
951a1129,1134
>                     if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo) {
>                         Config.drawFps();
>                     }
>                     if (this.mc.gameSettings.showDebugInfo) {
>                         Lagometer.showLagometer((ScaledResolution)scaledresolution);
>                     }
968c1151,1155
<                     ForgeHooksClient.drawScreen((GuiScreen)this.mc.currentScreen, (int)k1, (int)l1, (float)this.mc.getTickLength());
---
>                     if (Reflector.ForgeHooksClient_drawScreen.exists()) {
>                         Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_drawScreen, (Object[])new Object[]{this.mc.currentScreen, k1, l1, Float.valueOf((float)this.mc.getTickLength())});
>                     } else {
>                         this.mc.currentScreen.drawScreen(k1, l1, this.mc.getTickLength());
>                     }
979a1167,1173
>         this.frameFinish();
>         this.waitForServerThread();
>         MemoryMonitor.update();
>         Lagometer.updateLagometer();
>         if (this.mc.gameSettings.ofProfiler) {
>             this.mc.gameSettings.showDebugProfilerChart = true;
>         }
1023,1024c1217,1219
<                 Block block = this.mc.world.getBlockState(blockpos).getBlock();
<                 flag = this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR ? block.hasTileEntity(this.mc.world.getBlockState(blockpos)) && this.mc.world.getTileEntity(blockpos) instanceof IInventory : !itemstack.isEmpty() && (itemstack.canDestroy(block) || itemstack.canPlaceOn(block));
---
>                 IBlockState state = this.mc.world.getBlockState(blockpos);
>                 Block block = state.getBlock();
>                 flag = this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR ? ReflectorForge.blockHasTileEntity((IBlockState)state) && this.mc.world.getTileEntity(blockpos) instanceof IInventory : !itemstack.isEmpty() && (itemstack.canDestroy(block) || itemstack.canPlaceOn(block));
1035a1231,1233
>         if (Config.isShaders()) {
>             Shaders.beginRender((Minecraft)this.mc, (float)partialTicks, (long)finishTimeNano);
>         }
1038c1236
<         GlStateManager.alphaFunc((int)516, (float)0.5f);
---
>         GlStateManager.alphaFunc((int)516, (float)0.1f);
1054a1253,1256
>         boolean isShaders = Config.isShaders();
>         if (isShaders) {
>             Shaders.beginRenderPass((int)pass, (float)partialTicks, (long)finishTimeNano);
>         }
1060c1262,1266
<         GlStateManager.viewport((int)0, (int)0, (int)this.mc.displayWidth, (int)this.mc.displayHeight);
---
>         if (isShaders) {
>             Shaders.setViewport((int)0, (int)0, (int)this.mc.displayWidth, (int)this.mc.displayHeight);
>         } else {
>             GlStateManager.viewport((int)0, (int)0, (int)this.mc.displayWidth, (int)this.mc.displayHeight);
>         }
1062a1269,1271
>         if (isShaders) {
>             Shaders.clearRenderBuffer();
>         }
1065c1274,1281
<         ActiveRenderInfo.updateRenderInfo((Entity)this.mc.getRenderViewEntity(), (this.mc.gameSettings.thirdPersonView == 2 ? 1 : 0) != 0);
---
>         if (isShaders) {
>             Shaders.setCamera((float)partialTicks);
>         }
>         if (Reflector.ActiveRenderInfo_updateRenderInfo2.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.ActiveRenderInfo_updateRenderInfo2, (Object[])new Object[]{this.mc.getRenderViewEntity(), this.mc.gameSettings.thirdPersonView == 2});
>         } else {
>             ActiveRenderInfo.updateRenderInfo((EntityPlayer)this.mc.player, (this.mc.gameSettings.thirdPersonView == 2 ? 1 : 0) != 0);
>         }
1067c1283
<         ClippingHelperImpl.getInstance();
---
>         ClippingHelper clippingHelper = ClippingHelperImpl.getInstance();
1069c1285,1286
<         Frustum icamera = new Frustum();
---
>         clippingHelper.disabled = Config.isShaders() && !Shaders.isFrustumCulling();
>         Frustum icamera = new Frustum(clippingHelper);
1074,1075c1291,1296
<         icamera.setPosition(d0, d1, d2);
<         if (this.mc.gameSettings.renderDistanceChunks >= 4) {
---
>         if (isShaders) {
>             ShadersRender.setFrustrumPosition((ICamera)icamera, (double)d0, (double)d1, (double)d2);
>         } else {
>             icamera.setPosition(d0, d1, d2);
>         }
>         if ((Config.isSkyEnabled() || Config.isSunMoonEnabled() || Config.isStarsEnabled()) && !Shaders.isShadowPass) {
1080c1301
<             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.farPlaneDistance * 2.0f));
---
>             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)this.clipDistance);
1081a1303,1305
>             if (isShaders) {
>                 Shaders.beginSky();
>             }
1082a1307,1309
>             if (isShaders) {
>                 Shaders.endSky();
>             }
1085c1312
<             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.farPlaneDistance * MathHelper.SQRT_2));
---
>             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)this.clipDistance);
1086a1314,1315
>         } else {
>             GlStateManager.disableBlend();
1090c1319
<         if (entity.posY + (double)entity.getEyeHeight() < 128.0) {
---
>         if (entity.posY + (double)entity.getEyeHeight() < 128.0 + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0f)) {
1098c1327,1332
<         renderglobal.setupTerrain(entity, (double)partialTicks, (ICamera)icamera, this.frameCount++, this.mc.player.y());
---
>         this.checkLoadVisibleChunks(entity, partialTicks, (ICamera)icamera, this.mc.player.y());
>         if (isShaders) {
>             ShadersRender.setupTerrain((RenderGlobal)renderglobal, (Entity)entity, (double)partialTicks, (ICamera)icamera, (int)this.frameCount++, (boolean)this.mc.player.y());
>         } else {
>             renderglobal.setupTerrain(entity, (double)partialTicks, (ICamera)icamera, this.frameCount++, this.mc.player.y());
>         }
1100a1335
>             Lagometer.timerChunkUpload.start();
1101a1337
>             Lagometer.timerChunkUpload.end();
1103a1340,1345
>         Lagometer.timerTerrain.start();
>         if (this.mc.gameSettings.ofSmoothFps && pass > 0) {
>             this.mc.profiler.endStartSection("finish");
>             GL11.glFinish();
>             this.mc.profiler.endStartSection("terrain");
>         }
1106a1349,1351
>         if (isShaders) {
>             ShadersRender.beginTerrainSolid();
>         }
1108a1354,1356
>         if (isShaders) {
>             ShadersRender.beginTerrainCutoutMipped();
>         }
1112a1361,1363
>         if (isShaders) {
>             ShadersRender.beginTerrainCutout();
>         }
1114a1366,1369
>         if (isShaders) {
>             ShadersRender.endTerrain();
>         }
>         Lagometer.timerTerrain.end();
1123c1378,1380
<             ForgeHooksClient.setRenderPass((int)0);
---
>             if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
>                 Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderPass, (Object[])new Object[]{0});
>             }
1125c1382,1384
<             ForgeHooksClient.setRenderPass((int)0);
---
>             if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
>                 Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderPass, (Object[])new Object[]{-1});
>             }
1135c1394
<             if (!ForgeHooksClient.onDrawBlockHighlight((RenderGlobal)renderglobal, (EntityPlayer)entityplayer, (RayTraceResult)this.mc.objectMouseOver, (int)0, (float)partialTicks)) {
---
>             if (!Reflector.ForgeHooksClient_onDrawBlockHighlight.exists() || !Reflector.callBoolean((ReflectorMethod)Reflector.ForgeHooksClient_onDrawBlockHighlight, (Object[])new Object[]{renderglobal, entityplayer, this.mc.objectMouseOver, 0, Float.valueOf((float)partialTicks)})) {
1140a1400,1401
>             boolean preDebugFog = GlStateManager.isFogEnabled();
>             GlStateManager.disableFog();
1141a1403
>             GlStateManager.setFogEnabled((boolean)preDebugFog);
1143,1148c1405,1414
<         this.mc.profiler.endStartSection("destroyProgress");
<         GlStateManager.enableBlend();
<         GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
<         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
<         renderglobal.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), entity, partialTicks);
<         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
---
>         if (!renderglobal.damagedBlocks.isEmpty()) {
>             this.mc.profiler.endStartSection("destroyProgress");
>             GlStateManager.enableBlend();
>             GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
>             this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
>             renderglobal.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), entity, partialTicks);
>             this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
>             GlStateManager.disableBlend();
>         }
>         GlStateManager.tryBlendFuncSeparate((int)770, (int)771, (int)1, (int)0);
1152a1419,1421
>             if (isShaders) {
>                 Shaders.beginLitParticles();
>             }
1156a1426,1428
>             if (isShaders) {
>                 Shaders.beginParticles();
>             }
1157a1430,1432
>             if (isShaders) {
>                 Shaders.endParticles();
>             }
1160a1436,1438
>         if (Config.isShaders()) {
>             GlStateManager.depthMask((boolean)Shaders.isRainDepth());
>         }
1162a1441,1443
>         if (isShaders) {
>             Shaders.beginWeather();
>         }
1163a1445,1447
>         if (isShaders) {
>             Shaders.endWeather();
>         }
1165a1450,1453
>         if (isShaders) {
>             ShadersRender.renderHand0((EntityRenderer)this, (float)partialTicks, (int)pass);
>             Shaders.preWater();
>         }
1175a1464,1466
>         if (isShaders) {
>             Shaders.beginWater();
>         }
1177c1468,1471
<         if (!this.debugView) {
---
>         if (isShaders) {
>             Shaders.endWater();
>         }
>         if (Reflector.ForgeHooksClient_setRenderPass.exists() && !this.debugView) {
1180,1181c1474,1475
<             ForgeHooksClient.setRenderPass((int)1);
<             renderglobal.renderEntities(entity, (ICamera)icamera, partialTicks);
---
>             Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderPass, (Object[])new Object[]{1});
>             this.mc.renderGlobal.renderEntities(entity, (ICamera)icamera, partialTicks);
1183c1477
<             ForgeHooksClient.setRenderPass((int)-1);
---
>             Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderPass, (Object[])new Object[]{-1});
1191c1485
<         if (entity.posY + (double)entity.getEyeHeight() >= 128.0) {
---
>         if (entity.posY + (double)entity.getEyeHeight() >= 128.0 + (double)(this.mc.gameSettings.ofCloudsHeight * 128.0f)) {
1195,1196c1489,1492
<         this.mc.profiler.endStartSection("forge_render_last");
<         ForgeHooksClient.dispatchRenderLast((RenderGlobal)renderglobal, (float)partialTicks);
---
>         if (Reflector.ForgeHooksClient_dispatchRenderLast.exists()) {
>             this.mc.profiler.endStartSection("forge_render_last");
>             Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_dispatchRenderLast, (Object[])new Object[]{renderglobal, Float.valueOf((float)partialTicks)});
>         }
1198c1494,1498
<         if (this.renderHand) {
---
>         if (this.renderHand && !Shaders.isShadowPass) {
>             if (isShaders) {
>                 ShadersRender.renderHand1((EntityRenderer)this, (float)partialTicks, (int)pass);
>                 Shaders.renderCompositeFinal();
>             }
1200c1500,1507
<             this.renderHand(partialTicks, pass);
---
>             if (isShaders) {
>                 ShadersRender.renderFPOverlay((EntityRenderer)this, (float)partialTicks, (int)pass);
>             } else {
>                 this.renderHand(partialTicks, pass);
>             }
>         }
>         if (isShaders) {
>             Shaders.endRender();
1205c1512
<         if (this.mc.gameSettings.shouldRenderClouds() != 0) {
---
>         if (this.mc.gameSettings.renderDistanceChunks >= 4 && !Config.isCloudsOff() && Shaders.shouldRenderClouds((GameSettings)this.mc.gameSettings)) {
1209c1516
<             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.farPlaneDistance * 4.0f));
---
>             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.clipDistance * 4.0f));
1218c1525
<             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)(this.farPlaneDistance * MathHelper.SQRT_2));
---
>             Project.gluPerspective((float)this.getFOVModifier(partialTicks, true), (float)((float)this.mc.displayWidth / (float)this.mc.displayHeight), (float)0.05f, (float)this.clipDistance);
1225c1532
<         if (!this.mc.gameSettings.fancyGraphics) {
---
>         if (!Config.isRainFancy()) {
1228c1535
<         if (f != 0.0f) {
---
>         if (f != 0.0f && Config.isRainSplash()) {
1277,1279c1584,1587
<         IRenderHandler renderer = this.mc.world.provider.getWeatherRenderer();
<         if (renderer != null) {
<             renderer.render(partialTicks, this.mc.world, this.mc);
---
>         WorldProvider worldProvider;
>         Object weatherRenderer;
>         if (Reflector.ForgeWorldProvider_getWeatherRenderer.exists() && (weatherRenderer = Reflector.call((Object)(worldProvider = this.mc.world.provider), (ReflectorMethod)Reflector.ForgeWorldProvider_getWeatherRenderer, (Object[])new Object[0])) != null) {
>             Reflector.callVoid((Object)weatherRenderer, (ReflectorMethod)Reflector.IRenderHandler_render, (Object[])new Object[]{Float.valueOf((float)partialTicks), this.mc.world, this.mc});
1283a1592,1594
>             if (Config.isRainOff()) {
>                 return;
>             }
1302c1613
<             if (this.mc.gameSettings.fancyGraphics) {
---
>             if (Config.isRainFancy()) {
1406a1718
>         Vec3d colUnderlava;
1412a1725
>         vec3d = CustomColors.getWorldSkyColor((Vec3d)vec3d, (World)world, (Entity)this.mc.getRenderViewEntity(), (float)partialTicks);
1416a1730
>         vec3d1 = CustomColors.getWorldFogColor((Vec3d)vec3d1, (World)world, (Entity)this.mc.getRenderViewEntity(), (float)partialTicks);
1457c1771
<         } else {
---
>         } else if (Reflector.ForgeBlock_getFogColor.exists()) {
1461c1775
<             Vec3d inMaterialColor = viewportState.getBlock().getFogColor((World)this.mc.world, viewportPos, viewportState, entity, new Vec3d((double)this.fogColorRed, (double)this.fogColorGreen, (double)this.fogColorBlue), partialTicks);
---
>             Vec3d inMaterialColor = (Vec3d)Reflector.call((Object)viewportState.getBlock(), (ReflectorMethod)Reflector.ForgeBlock_getFogColor, (Object[])new Object[]{this.mc.world, viewportPos, viewportState, entity, new Vec3d((double)this.fogColorRed, (double)this.fogColorGreen, (double)this.fogColorBlue), Float.valueOf((float)partialTicks)});
1464a1779,1806
>         } else if (iblockstate.a() == Material.WATER) {
>             float f12 = 0.0f;
>             if (entity instanceof EntityLivingBase) {
>                 f12 = (float)EnchantmentHelper.getRespirationModifier((EntityLivingBase)((EntityLivingBase)entity)) * 0.2f;
>                 f12 = Config.limit((float)f12, (float)0.0f, (float)0.6f);
>                 if (((EntityLivingBase)entity).isPotionActive(MobEffects.WATER_BREATHING)) {
>                     f12 = f12 * 0.3f + 0.6f;
>                 }
>             }
>             this.fogColorRed = 0.02f + f12;
>             this.fogColorGreen = 0.02f + f12;
>             this.fogColorBlue = 0.2f + f12;
>         } else if (iblockstate.a() == Material.LAVA) {
>             this.fogColorRed = 0.6f;
>             this.fogColorGreen = 0.1f;
>             this.fogColorBlue = 0.0f;
>         }
>         if (iblockstate.a() == Material.WATER) {
>             Vec3d colUnderwater = CustomColors.getUnderwaterColor((IBlockAccess)this.mc.world, (double)this.mc.getRenderViewEntity().posX, (double)(this.mc.getRenderViewEntity().posY + 1.0), (double)this.mc.getRenderViewEntity().posZ);
>             if (colUnderwater != null) {
>                 this.fogColorRed = (float)colUnderwater.x;
>                 this.fogColorGreen = (float)colUnderwater.y;
>                 this.fogColorBlue = (float)colUnderwater.z;
>             }
>         } else if (iblockstate.a() == Material.LAVA && (colUnderlava = CustomColors.getUnderlavaColor((IBlockAccess)this.mc.world, (double)this.mc.getRenderViewEntity().posX, (double)(this.mc.getRenderViewEntity().posY + 1.0), (double)this.mc.getRenderViewEntity().posZ)) != null) {
>             this.fogColorRed = (float)colUnderlava.x;
>             this.fogColorGreen = (float)colUnderlava.y;
>             this.fogColorBlue = (float)colUnderlava.z;
1514,1519c1856,1863
<         EntityViewRenderEvent.FogColors event = new EntityViewRenderEvent.FogColors(this, entity, iblockstate, (double)partialTicks, this.fogColorRed, this.fogColorGreen, this.fogColorBlue);
<         MinecraftForge.EVENT_BUS.post((Event)event);
<         this.fogColorRed = event.getRed();
<         this.fogColorGreen = event.getGreen();
<         this.fogColorBlue = event.getBlue();
<         GlStateManager.clearColor((float)this.fogColorRed, (float)this.fogColorGreen, (float)this.fogColorBlue, (float)0.0f);
---
>         if (Reflector.EntityViewRenderEvent_FogColors_Constructor.exists()) {
>             Object event = Reflector.newInstance((ReflectorConstructor)Reflector.EntityViewRenderEvent_FogColors_Constructor, (Object[])new Object[]{this, entity, iblockstate, Float.valueOf((float)partialTicks), Float.valueOf((float)this.fogColorRed), Float.valueOf((float)this.fogColorGreen), Float.valueOf((float)this.fogColorBlue)});
>             Reflector.postForgeBusEvent((Object)event);
>             this.fogColorRed = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_FogColors_getRed, (Object[])new Object[0]);
>             this.fogColorGreen = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_FogColors_getGreen, (Object[])new Object[0]);
>             this.fogColorBlue = Reflector.callFloat((Object)event, (ReflectorMethod)Reflector.EntityViewRenderEvent_FogColors_getBlue, (Object[])new Object[0]);
>         }
>         Shaders.setClearColor((float)this.fogColorRed, (float)this.fogColorGreen, (float)this.fogColorBlue, (float)0.0f);
1522a1867
>         this.fogStandard = false;
1528,1530c1873,1878
<         float hook = ForgeHooksClient.getFogDensity((EntityRenderer)this, (Entity)entity, (IBlockState)iblockstate, (float)partialTicks, (float)0.1f);
<         if (hook >= 0.0f) {
<             GlStateManager.setFogDensity((float)hook);
---
>         float forgeFogDensity = -1.0f;
>         if (Reflector.ForgeHooksClient_getFogDensity.exists()) {
>             forgeFogDensity = Reflector.callFloat((ReflectorMethod)Reflector.ForgeHooksClient_getFogDensity, (Object[])new Object[]{this, entity, iblockstate, Float.valueOf((float)partialTicks), Float.valueOf((float)0.1f)});
>         }
>         if (forgeFogDensity >= 0.0f) {
>             GlStateManager.setFogDensity((float)forgeFogDensity);
1545c1893
<             if (GLContext.getCapabilities().GL_NV_fog_distance) {
---
>             if (GLContext.getCapabilities().GL_NV_fog_distance && Config.isFogFancy()) {
1551a1900
>             float waterFogDensityMax;
1552a1902
>             float f = waterFogDensityMax = Config.isClearWater() ? 0.02f : 0.1f;
1557c1907,1908
<                     GlStateManager.setFogDensity((float)(0.1f - (float)EnchantmentHelper.getRespirationModifier((EntityLivingBase)((EntityLivingBase)entity)) * 0.03f));
---
>                     float waterFogDensity = 0.1f - (float)EnchantmentHelper.getRespirationModifier((EntityLivingBase)((EntityLivingBase)entity)) * 0.03f;
>                     GlStateManager.setFogDensity((float)Config.limit((float)waterFogDensity, (float)0.0f, (float)waterFogDensityMax));
1560c1911
<                 GlStateManager.setFogDensity((float)0.1f);
---
>                 GlStateManager.setFogDensity((float)waterFogDensityMax);
1566a1918
>             this.fogStandard = true;
1572c1924
<                 GlStateManager.setFogStart((float)(f * 0.75f));
---
>                 GlStateManager.setFogStart((float)(f * Config.getFogStart()));
1576c1928,1933
<                 GlStateManager.glFogi((int)34138, (int)34139);
---
>                 if (Config.isFogFancy()) {
>                     GlStateManager.glFogi((int)34138, (int)34139);
>                 }
>                 if (Config.isFogFast()) {
>                     GlStateManager.glFogi((int)34138, (int)34140);
>                 }
1580c1937,1940
<                 GlStateManager.setFogEnd((float)(Math.min((float)f, (float)192.0f) * 0.5f));
---
>                 GlStateManager.setFogEnd((float)f);
>             }
>             if (Reflector.ForgeHooksClient_onFogRender.exists()) {
>                 Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_onFogRender, (Object[])new Object[]{this, entity, iblockstate, Float.valueOf((float)partialTicks), startCoords, Float.valueOf((float)f)});
1582d1941
<             ForgeHooksClient.onFogRender((EntityRenderer)this, (Entity)entity, (IBlockState)iblockstate, (float)partialTicks, (int)startCoords, (float)f);
1597a1957,1959
>         if (Config.isShaders()) {
>             Shaders.setFogColor((float)red, (float)green, (float)blue);
>         }
1612a1975,2212
>     private void waitForServerThread() {
>         this.serverWaitTimeCurrent = 0;
>         if (!Config.isSmoothWorld() || !Config.isSingleProcessor()) {
>             this.lastServerTime = 0L;
>             this.lastServerTicks = 0;
>             return;
>         }
>         if (!this.mc.isIntegratedServerRunning()) {
>             return;
>         }
>         IntegratedServer srv = this.mc.getIntegratedServer();
>         if (srv == null) {
>             return;
>         }
>         boolean paused = this.mc.isGamePaused();
>         if (paused || this.mc.currentScreen instanceof GuiDownloadTerrain) {
>             if (this.mc.currentScreen instanceof GuiDownloadTerrain) {
>                 Config.sleep((long)20L);
>             }
>             this.lastServerTime = 0L;
>             this.lastServerTicks = 0;
>             return;
>         }
>         if (this.serverWaitTime > 0) {
>             Lagometer.timerServer.start();
>             Config.sleep((long)this.serverWaitTime);
>             Lagometer.timerServer.end();
>             this.serverWaitTimeCurrent = this.serverWaitTime;
>         }
>         long timeNow = System.nanoTime() / 1000000L;
>         if (this.lastServerTime == 0L || this.lastServerTicks == 0) {
>             this.lastServerTime = timeNow;
>             this.lastServerTicks = srv.getTickCounter();
>             this.avgServerTickDiff = 1.0f;
>             this.avgServerTimeDiff = 50.0f;
>             return;
>         }
>         long timeDiff = timeNow - this.lastServerTime;
>         if (timeDiff < 0L) {
>             this.lastServerTime = timeNow;
>             timeDiff = 0L;
>         }
>         if (timeDiff < 50L) {
>             return;
>         }
>         this.lastServerTime = timeNow;
>         int ticks = srv.getTickCounter();
>         int tickDiff = ticks - this.lastServerTicks;
>         if (tickDiff < 0) {
>             this.lastServerTicks = ticks;
>             tickDiff = 0;
>         }
>         if (tickDiff < 1 && this.serverWaitTime < 100) {
>             this.serverWaitTime += 2;
>         }
>         if (tickDiff > 1 && this.serverWaitTime > 0) {
>             --this.serverWaitTime;
>         }
>         this.lastServerTicks = ticks;
>     }
> 
>     private void frameInit() {
>         GlErrors.frameStart();
>         if (!this.initialized) {
>             ReflectorResolver.resolve();
>             TextureUtils.registerResourceListener();
>             if (Config.getBitsOs() == 64 && Config.getBitsJre() == 32) {
>                 Config.setNotify64BitJava((boolean)true);
>             }
>             this.initialized = true;
>         }
>         Config.checkDisplayMode();
>         WorldClient world = this.mc.world;
>         if (world != null) {
>             if (Config.getNewRelease() != null) {
>                 String userEdition = "HD_U".replace((CharSequence)"HD_U", (CharSequence)"HD Ultra").replace((CharSequence)"L", (CharSequence)"Light");
>                 String fullNewVer = userEdition + " " + Config.getNewRelease();
>                 TextComponentString msg = new TextComponentString(I18n.format((String)"of.message.newVersion", (Object[])new Object[]{"\u00a7n" + fullNewVer + "\u00a7r"}));
>                 msg.a(new Style().setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "https://optifine.net/downloads")));
>                 this.mc.ingameGUI.getChatGUI().printChatMessage((ITextComponent)msg);
>                 Config.setNewRelease(null);
>             }
>             if (Config.isNotify64BitJava()) {
>                 Config.setNotify64BitJava((boolean)false);
>                 TextComponentString msg = new TextComponentString(I18n.format((String)"of.message.java64Bit", (Object[])new Object[0]));
>                 this.mc.ingameGUI.getChatGUI().printChatMessage((ITextComponent)msg);
>             }
>         }
>         if (this.mc.currentScreen instanceof GuiMainMenu) {
>             this.updateMainMenu((GuiMainMenu)this.mc.currentScreen);
>         }
>         if (this.updatedWorld != world) {
>             RandomEntities.worldChanged((World)this.updatedWorld, (World)world);
>             Config.updateThreadPriorities();
>             this.lastServerTime = 0L;
>             this.lastServerTicks = 0;
>             this.updatedWorld = world;
>         }
>         if (!this.setFxaaShader(Shaders.configAntialiasingLevel)) {
>             Shaders.configAntialiasingLevel = 0;
>         }
>         if (this.mc.currentScreen != null && this.mc.currentScreen.getClass() == GuiChat.class) {
>             this.mc.displayGuiScreen((GuiScreen)new GuiChatOF((GuiChat)this.mc.currentScreen));
>         }
>     }
> 
>     private void frameFinish() {
>         int err;
>         if (this.mc.world != null && Config.isShowGlErrors() && TimedEvent.isActive((String)"CheckGlErrorFrameFinish", (long)10000L) && (err = GlStateManager.glGetError()) != 0 && GlErrors.isEnabled((int)err)) {
>             String text = Config.getGlErrorString((int)err);
>             TextComponentString msg = new TextComponentString(I18n.format((String)"of.message.openglError", (Object[])new Object[]{err, text}));
>             this.mc.ingameGUI.getChatGUI().printChatMessage((ITextComponent)msg);
>         }
>     }
> 
>     private void updateMainMenu(GuiMainMenu mainGui) {
>         try {
>             String str = null;
>             Calendar calendar = Calendar.getInstance();
>             calendar.setTime(new Date());
>             int day = calendar.get(5);
>             int month = calendar.get(2) + 1;
>             if (day == 8 && month == 4) {
>                 str = "Happy birthday, OptiFine!";
>             }
>             if (day == 14 && month == 8) {
>                 str = "Happy birthday, sp614x!";
>             }
>             if (str == null) {
>                 return;
>             }
>             Reflector.setFieldValue((Object)mainGui, (ReflectorField)Reflector.GuiMainMenu_splashText, (Object)str);
>         }
>         catch (Throwable throwable) {
>             // empty catch block
>         }
>     }
> 
>     public boolean setFxaaShader(int fxaaLevel) {
>         if (!OpenGlHelper.isFramebufferEnabled()) {
>             return false;
>         }
>         if (this.shaderGroup != null && this.shaderGroup != this.fxaaShaders[2] && this.shaderGroup != this.fxaaShaders[4]) {
>             return true;
>         }
>         if (fxaaLevel == 2 || fxaaLevel == 4) {
>             if (this.shaderGroup != null && this.shaderGroup == this.fxaaShaders[fxaaLevel]) {
>                 return true;
>             }
>             if (this.mc.world == null) {
>                 return true;
>             }
>             this.loadShader(new ResourceLocation("shaders/post/fxaa_of_" + fxaaLevel + "x.json"));
>             this.fxaaShaders[fxaaLevel] = this.shaderGroup;
>             return this.useShader;
>         }
>         if (this.shaderGroup == null) {
>             return true;
>         }
>         this.shaderGroup.deleteShaderGroup();
>         this.shaderGroup = null;
>         return true;
>     }
> 
>     private void checkLoadVisibleChunks(Entity entity, float partialTicks, ICamera icamera, boolean spectator) {
>         int messageId = 201435902;
>         if (this.loadVisibleChunks) {
>             this.loadVisibleChunks = false;
>             this.loadAllVisibleChunks(entity, partialTicks, icamera, spectator);
>             this.mc.ingameGUI.getChatGUI().deleteChatLine(messageId);
>         }
>         if (Keyboard.isKeyDown((int)61) && Keyboard.isKeyDown((int)38)) {
>             if (this.mc.gameSettings.keyBindAdvancements.getKeyCode() == 38) {
>                 if (this.mc.currentScreen instanceof GuiScreenAdvancements) {
>                     this.mc.displayGuiScreen(null);
>                 }
>                 while (Keyboard.next()) {
>                 }
>             }
>             if (this.mc.currentScreen != null) {
>                 return;
>             }
>             this.loadVisibleChunks = true;
>             TextComponentString msg = new TextComponentString(I18n.format((String)"of.message.loadingVisibleChunks", (Object[])new Object[0]));
>             this.mc.ingameGUI.getChatGUI().printChatMessageWithOptionalDeletion((ITextComponent)msg, messageId);
>             Reflector.Minecraft_actionKeyF3.setValue((Object)this.mc, (Object)Boolean.TRUE);
>         }
>     }
> 
>     /*
>      * WARNING - Removed try catching itself - possible behaviour change.
>      */
>     private void loadAllVisibleChunks(Entity entity, double partialTicks, ICamera icamera, boolean spectator) {
>         int chunkUpdatesConfig = this.mc.gameSettings.ofChunkUpdates;
>         boolean lazyChunkLoadingConfig = this.mc.gameSettings.ofLazyChunkLoading;
>         try {
>             this.mc.gameSettings.ofChunkUpdates = 1000;
>             this.mc.gameSettings.ofLazyChunkLoading = false;
>             RenderGlobal renderGlobal = Config.getRenderGlobal();
>             int countLoadedChunks = renderGlobal.getCountLoadedChunks();
>             long timeStart = System.currentTimeMillis();
>             Config.dbg((String)"Loading visible chunks");
>             long timeLog = System.currentTimeMillis() + 5000L;
>             int chunksUpdated = 0;
>             boolean hasUpdates = false;
>             do {
>                 hasUpdates = false;
>                 for (int i = 0; i < 100; ++i) {
>                     renderGlobal.displayListEntitiesDirty = true;
>                     renderGlobal.setupTerrain(entity, partialTicks, icamera, this.frameCount++, spectator);
>                     if (!renderGlobal.hasNoChunkUpdates()) {
>                         hasUpdates = true;
>                     }
>                     chunksUpdated += renderGlobal.getCountChunksToUpdate();
>                     while (!renderGlobal.hasNoChunkUpdates()) {
>                         renderGlobal.updateChunks(System.nanoTime() + 1000000000L);
>                     }
>                     chunksUpdated -= renderGlobal.getCountChunksToUpdate();
>                     if (!hasUpdates) break;
>                 }
>                 if (renderGlobal.getCountLoadedChunks() != countLoadedChunks) {
>                     hasUpdates = true;
>                     countLoadedChunks = renderGlobal.getCountLoadedChunks();
>                 }
>                 if (System.currentTimeMillis() <= timeLog) continue;
>                 Config.log((String)("Chunks loaded: " + chunksUpdated));
>                 timeLog = System.currentTimeMillis() + 5000L;
>             } while (hasUpdates);
>             Config.log((String)("Chunks loaded: " + chunksUpdated));
>             Config.log((String)"Finished loading visible chunks");
>             RenderChunk.renderChunksUpdated = 0;
>         }
>         finally {
>             this.mc.gameSettings.ofChunkUpdates = chunkUpdatesConfig;
>             this.mc.gameSettings.ofLazyChunkLoading = lazyChunkLoadingConfig;
>         }
>     }
> 
1650,1651c2250,2251
<     public void displayItemActivation(ItemStack stack) {
<         this.itemActivationItem = stack;
---
>     public void displayItemActivation(ItemStack p_190565_1_) {
>         this.itemActivationItem = p_190565_1_;
1685a2286,2289
>     }
> 
>     static /* synthetic */ Minecraft access$000(EntityRenderer x0) {
>         return x0.mc;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$BooleanState.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$BooleanState.java
16,17c16,17
<     public GlStateManager.BooleanState(int n) {
<         this.capability = n;
---
>     public GlStateManager.BooleanState(int capabilityIn) {
>         this.capability = capabilityIn;
28,31c28,31
<     public void setState(boolean bl) {
<         if (bl != this.currentState) {
<             this.currentState = bl;
<             if (bl) {
---
>     public void setState(boolean state) {
>         if (state != this.currentState) {
>             this.currentState = state;
>             if (state) {
36a37,40
>     }
> 
>     static /* synthetic */ boolean access$100(GlStateManager.BooleanState x0) {
>         return x0.currentState;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$Color.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$Color.java
19,23c19,23
<     public GlStateManager.Color(float f, float f2, float f3, float f4) {
<         this.red = f;
<         this.green = f2;
<         this.blue = f3;
<         this.alpha = f4;
---
>     public GlStateManager.Color(float redIn, float greenIn, float blueIn, float alphaIn) {
>         this.red = redIn;
>         this.green = greenIn;
>         this.blue = blueIn;
>         this.alpha = alphaIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$CullFace.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$CullFace.java
16,17c16,17
<     private GlStateManager.CullFace(int n2) {
<         this.mode = n2;
---
>     private GlStateManager.CullFace(int modeIn) {
>         this.mode = modeIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$DestFactor.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$DestFactor.java
27,28c27,28
<     private GlStateManager.DestFactor(int n2) {
<         this.factor = n2;
---
>     private GlStateManager.DestFactor(int factorIn) {
>         this.factor = factorIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$FogMode.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$FogMode.java
16,17c16,17
<     private GlStateManager.FogMode(int n2) {
<         this.capabilityId = n2;
---
>     private GlStateManager.FogMode(int capabilityIn) {
>         this.capabilityId = capabilityIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$Profile$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$Profile$1.java
12a13,14
>  *  org.lwjgl.opengl.GL11
>  *  org.lwjgl.opengl.GL14
19a22,23
> import org.lwjgl.opengl.GL11;
> import org.lwjgl.opengl.GL14;
35c39
<         GlStateManager.glLightModel((int)2899, (FloatBuffer)RenderHelper.setColorBuffer((float)0.2f, (float)0.2f, (float)0.2f, (float)1.0f));
---
>         GL11.glLightModel((int)2899, (FloatBuffer)RenderHelper.setColorBuffer((float)0.2f, (float)0.2f, (float)0.2f, (float)1.0f));
38,39c42,43
<             GlStateManager.glLight((int)(16384 + i), (int)4608, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
<             GlStateManager.glLight((int)(16384 + i), (int)4611, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)1.0f, (float)0.0f));
---
>             GL11.glLight((int)(16384 + i), (int)4608, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
>             GL11.glLight((int)(16384 + i), (int)4611, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)1.0f, (float)0.0f));
41,42c45,46
<                 GlStateManager.glLight((int)(16384 + i), (int)4609, (FloatBuffer)RenderHelper.setColorBuffer((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f));
<                 GlStateManager.glLight((int)(16384 + i), (int)4610, (FloatBuffer)RenderHelper.setColorBuffer((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f));
---
>                 GL11.glLight((int)(16384 + i), (int)4609, (FloatBuffer)RenderHelper.setColorBuffer((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f));
>                 GL11.glLight((int)(16384 + i), (int)4610, (FloatBuffer)RenderHelper.setColorBuffer((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f));
45,46c49,50
<             GlStateManager.glLight((int)(16384 + i), (int)4609, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
<             GlStateManager.glLight((int)(16384 + i), (int)4610, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
---
>             GL11.glLight((int)(16384 + i), (int)4609, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
>             GL11.glLight((int)(16384 + i), (int)4610, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)1.0f));
56c60
<         GlStateManager.glBlendEquation((int)32774);
---
>         GL14.glBlendEquation((int)32774);
58c62
<         GlStateManager.glFogi((int)2917, (int)2048);
---
>         GL11.glFogi((int)2917, (int)2048);
62c66
<         GlStateManager.glFog((int)2918, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)0.0f));
---
>         GL11.glFog((int)2918, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)0.0f));
64c68
<             GlStateManager.glFogi((int)2917, (int)34140);
---
>             GL11.glFogi((int)2917, (int)34140);
86,111c90,115
<         GlStateManager.glTexParameteri((int)3553, (int)10240, (int)9729);
<         GlStateManager.glTexParameteri((int)3553, (int)10241, (int)9986);
<         GlStateManager.glTexParameteri((int)3553, (int)10242, (int)10497);
<         GlStateManager.glTexParameteri((int)3553, (int)10243, (int)10497);
<         GlStateManager.glTexParameteri((int)3553, (int)33085, (int)1000);
<         GlStateManager.glTexParameteri((int)3553, (int)33083, (int)1000);
<         GlStateManager.glTexParameteri((int)3553, (int)33082, (int)-1000);
<         GlStateManager.glTexParameterf((int)3553, (int)34049, (float)0.0f);
<         GlStateManager.glTexEnvi((int)8960, (int)8704, (int)8448);
<         GlStateManager.glTexEnv((int)8960, (int)8705, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)0.0f));
<         GlStateManager.glTexEnvi((int)8960, (int)34161, (int)8448);
<         GlStateManager.glTexEnvi((int)8960, (int)34162, (int)8448);
<         GlStateManager.glTexEnvi((int)8960, (int)34176, (int)5890);
<         GlStateManager.glTexEnvi((int)8960, (int)34177, (int)34168);
<         GlStateManager.glTexEnvi((int)8960, (int)34178, (int)34166);
<         GlStateManager.glTexEnvi((int)8960, (int)34184, (int)5890);
<         GlStateManager.glTexEnvi((int)8960, (int)34185, (int)34168);
<         GlStateManager.glTexEnvi((int)8960, (int)34186, (int)34166);
<         GlStateManager.glTexEnvi((int)8960, (int)34192, (int)768);
<         GlStateManager.glTexEnvi((int)8960, (int)34193, (int)768);
<         GlStateManager.glTexEnvi((int)8960, (int)34194, (int)770);
<         GlStateManager.glTexEnvi((int)8960, (int)34200, (int)770);
<         GlStateManager.glTexEnvi((int)8960, (int)34201, (int)770);
<         GlStateManager.glTexEnvi((int)8960, (int)34202, (int)770);
<         GlStateManager.glTexEnvf((int)8960, (int)34163, (float)1.0f);
<         GlStateManager.glTexEnvf((int)8960, (int)3356, (float)1.0f);
---
>         GL11.glTexParameteri((int)3553, (int)10240, (int)9729);
>         GL11.glTexParameteri((int)3553, (int)10241, (int)9986);
>         GL11.glTexParameteri((int)3553, (int)10242, (int)10497);
>         GL11.glTexParameteri((int)3553, (int)10243, (int)10497);
>         GL11.glTexParameteri((int)3553, (int)33085, (int)1000);
>         GL11.glTexParameteri((int)3553, (int)33083, (int)1000);
>         GL11.glTexParameteri((int)3553, (int)33082, (int)-1000);
>         GL11.glTexParameterf((int)3553, (int)34049, (float)0.0f);
>         GL11.glTexEnvi((int)8960, (int)8704, (int)8448);
>         GL11.glTexEnv((int)8960, (int)8705, (FloatBuffer)RenderHelper.setColorBuffer((float)0.0f, (float)0.0f, (float)0.0f, (float)0.0f));
>         GL11.glTexEnvi((int)8960, (int)34161, (int)8448);
>         GL11.glTexEnvi((int)8960, (int)34162, (int)8448);
>         GL11.glTexEnvi((int)8960, (int)34176, (int)5890);
>         GL11.glTexEnvi((int)8960, (int)34177, (int)34168);
>         GL11.glTexEnvi((int)8960, (int)34178, (int)34166);
>         GL11.glTexEnvi((int)8960, (int)34184, (int)5890);
>         GL11.glTexEnvi((int)8960, (int)34185, (int)34168);
>         GL11.glTexEnvi((int)8960, (int)34186, (int)34166);
>         GL11.glTexEnvi((int)8960, (int)34192, (int)768);
>         GL11.glTexEnvi((int)8960, (int)34193, (int)768);
>         GL11.glTexEnvi((int)8960, (int)34194, (int)770);
>         GL11.glTexEnvi((int)8960, (int)34200, (int)770);
>         GL11.glTexEnvi((int)8960, (int)34201, (int)770);
>         GL11.glTexEnvi((int)8960, (int)34202, (int)770);
>         GL11.glTexEnvf((int)8960, (int)34163, (float)1.0f);
>         GL11.glTexEnvf((int)8960, (int)3356, (float)1.0f);
117,120c121,124
<         GlStateManager.glLineWidth((float)1.0f);
<         GlStateManager.glNormal3f((float)0.0f, (float)0.0f, (float)1.0f);
<         GlStateManager.glPolygonMode((int)1028, (int)6914);
<         GlStateManager.glPolygonMode((int)1029, (int)6914);
---
>         GL11.glLineWidth((float)1.0f);
>         GL11.glNormal3f((float)0.0f, (float)0.0f, (float)1.0f);
>         GL11.glPolygonMode((int)1028, (int)6914);
>         GL11.glPolygonMode((int)1029, (int)6914);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$SourceFactor.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$SourceFactor.java
28,29c28,29
<     private GlStateManager.SourceFactor(int n2) {
<         this.factor = n2;
---
>     private GlStateManager.SourceFactor(int factorIn) {
>         this.factor = factorIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager$TexGenCoord.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager$TexGenCoord.java
17,19c17,19
<     public GlStateManager.TexGenCoord(int n, int n2) {
<         this.coord = n;
<         this.textureGen = new GlStateManager.BooleanState(n2);
---
>     public GlStateManager.TexGenCoord(int coordIn, int capabilityIn) {
>         this.coord = coordIn;
>         this.textureGen = new GlStateManager.BooleanState(capabilityIn);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/GlStateManager.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/GlStateManager.java
4a5
>  *  Config
35a37,41
>  *  net.optifine.SmartAnimations
>  *  net.optifine.render.GlAlphaState
>  *  net.optifine.render.GlBlendState
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.util.LockCounter
48a55,59
> import net.optifine.SmartAnimations;
> import net.optifine.render.GlAlphaState;
> import net.optifine.render.GlBlendState;
> import net.optifine.shaders.Shaders;
> import net.optifine.util.LockCounter;
53a65,67
> /*
>  * Exception performing whole class analysis ignored.
>  */
55,59c69,73
<     private static final FloatBuffer BUF_FLOAT_16;
<     private static final FloatBuffer BUF_FLOAT_4;
<     private static final AlphaState alphaState;
<     private static final BooleanState lightingState;
<     private static final BooleanState[] lightState;
---
>     private static final FloatBuffer BUF_FLOAT_16 = BufferUtils.createFloatBuffer((int)16);
>     private static final FloatBuffer BUF_FLOAT_4 = BufferUtils.createFloatBuffer((int)4);
>     private static final AlphaState alphaState = new AlphaState(null);
>     private static final BooleanState lightingState = new BooleanState(2896);
>     private static final BooleanState[] lightState = new BooleanState[8];
76a91,96
>     public static boolean clearEnabled;
>     private static LockCounter alphaLock;
>     private static GlAlphaState alphaLockState;
>     private static LockCounter blendLock;
>     private static GlBlendState blendLockState;
>     private static boolean creatingDisplayList;
86a107,110
>         if (alphaLock.isLocked()) {
>             alphaLockState.setDisabled();
>             return;
>         }
90a115,118
>         if (alphaLock.isLocked()) {
>             alphaLockState.setEnabled();
>             return;
>         }
94,98c122,130
<     public static void alphaFunc(int n, float f) {
<         if (n != GlStateManager.alphaState.func || f != GlStateManager.alphaState.ref) {
<             GlStateManager.alphaState.func = n;
<             GlStateManager.alphaState.ref = f;
<             GL11.glAlphaFunc((int)n, (float)f);
---
>     public static void alphaFunc(int func, float ref) {
>         if (alphaLock.isLocked()) {
>             alphaLockState.setFuncRef(func, ref);
>             return;
>         }
>         if (func != GlStateManager.alphaState.func || ref != GlStateManager.alphaState.ref) {
>             GlStateManager.alphaState.func = func;
>             GlStateManager.alphaState.ref = ref;
>             GL11.glAlphaFunc((int)func, (float)ref);
110,111c142,143
<     public static void enableLight(int n) {
<         lightState[n].setEnabled();
---
>     public static void enableLight(int light) {
>         lightState[light].setEnabled();
114,115c146,147
<     public static void disableLight(int n) {
<         lightState[n].setDisabled();
---
>     public static void disableLight(int light) {
>         lightState[light].setDisabled();
126,130c158,162
<     public static void colorMaterial(int n, int n2) {
<         if (n != GlStateManager.colorMaterialState.face || n2 != GlStateManager.colorMaterialState.mode) {
<             GlStateManager.colorMaterialState.face = n;
<             GlStateManager.colorMaterialState.mode = n2;
<             GL11.glColorMaterial((int)n, (int)n2);
---
>     public static void colorMaterial(int face, int mode) {
>         if (face != GlStateManager.colorMaterialState.face || mode != GlStateManager.colorMaterialState.mode) {
>             GlStateManager.colorMaterialState.face = face;
>             GlStateManager.colorMaterialState.mode = mode;
>             GL11.glColorMaterial((int)face, (int)mode);
134,135c166,167
<     public static void glLight(int n, int n2, FloatBuffer floatBuffer) {
<         GL11.glLight((int)n, (int)n2, (FloatBuffer)floatBuffer);
---
>     public static void glLight(int light, int pname, FloatBuffer params) {
>         GL11.glLight((int)light, (int)pname, (FloatBuffer)params);
138,139c170,171
<     public static void glLightModel(int n, FloatBuffer floatBuffer) {
<         GL11.glLightModel((int)n, (FloatBuffer)floatBuffer);
---
>     public static void glLightModel(int pname, FloatBuffer params) {
>         GL11.glLightModel((int)pname, (FloatBuffer)params);
142,143c174,175
<     public static void glNormal3f(float f, float f2, float f3) {
<         GL11.glNormal3f((float)f, (float)f2, (float)f3);
---
>     public static void glNormal3f(float nx, float ny, float nz) {
>         GL11.glNormal3f((float)nx, (float)ny, (float)nz);
154,157c186,189
<     public static void depthFunc(int n) {
<         if (n != GlStateManager.depthState.depthFunc) {
<             GlStateManager.depthState.depthFunc = n;
<             GL11.glDepthFunc((int)n);
---
>     public static void depthFunc(int depthFunc) {
>         if (depthFunc != GlStateManager.depthState.depthFunc) {
>             GlStateManager.depthState.depthFunc = depthFunc;
>             GL11.glDepthFunc((int)depthFunc);
161,164c193,196
<     public static void depthMask(boolean bl) {
<         if (bl != GlStateManager.depthState.maskEnabled) {
<             GlStateManager.depthState.maskEnabled = bl;
<             GL11.glDepthMask((boolean)bl);
---
>     public static void depthMask(boolean flagIn) {
>         if (flagIn != GlStateManager.depthState.maskEnabled) {
>             GlStateManager.depthState.maskEnabled = flagIn;
>             GL11.glDepthMask((boolean)flagIn);
168a201,204
>         if (blendLock.isLocked()) {
>             blendLockState.setDisabled();
>             return;
>         }
172a209,212
>         if (blendLock.isLocked()) {
>             blendLockState.setEnabled();
>             return;
>         }
176,177c216,217
<     public static void blendFunc(SourceFactor sourceFactor, DestFactor destFactor) {
<         GlStateManager.blendFunc(sourceFactor.factor, destFactor.factor);
---
>     public static void blendFunc(SourceFactor srcFactor, DestFactor dstFactor) {
>         GlStateManager.blendFunc(srcFactor.factor, dstFactor.factor);
180,184c220,233
<     public static void blendFunc(int n, int n2) {
<         if (n != GlStateManager.blendState.srcFactor || n2 != GlStateManager.blendState.dstFactor) {
<             GlStateManager.blendState.srcFactor = n;
<             GlStateManager.blendState.dstFactor = n2;
<             GL11.glBlendFunc((int)n, (int)n2);
---
>     public static void blendFunc(int srcFactor, int dstFactor) {
>         if (blendLock.isLocked()) {
>             blendLockState.setFactors(srcFactor, dstFactor);
>             return;
>         }
>         if (srcFactor != GlStateManager.blendState.srcFactor || dstFactor != GlStateManager.blendState.dstFactor || srcFactor != GlStateManager.blendState.srcFactorAlpha || dstFactor != GlStateManager.blendState.dstFactorAlpha) {
>             GlStateManager.blendState.srcFactor = srcFactor;
>             GlStateManager.blendState.dstFactor = dstFactor;
>             GlStateManager.blendState.srcFactorAlpha = srcFactor;
>             GlStateManager.blendState.dstFactorAlpha = dstFactor;
>             if (Config.isShaders()) {
>                 Shaders.uniform_blendFunc.setValue(srcFactor, dstFactor, srcFactor, dstFactor);
>             }
>             GL11.glBlendFunc((int)srcFactor, (int)dstFactor);
188,189c237,238
<     public static void tryBlendFuncSeparate(SourceFactor sourceFactor, DestFactor destFactor, SourceFactor sourceFactor2, DestFactor destFactor2) {
<         GlStateManager.tryBlendFuncSeparate(sourceFactor.factor, destFactor.factor, sourceFactor2.factor, destFactor2.factor);
---
>     public static void tryBlendFuncSeparate(SourceFactor srcFactor, DestFactor dstFactor, SourceFactor srcFactorAlpha, DestFactor dstFactorAlpha) {
>         GlStateManager.tryBlendFuncSeparate(srcFactor.factor, dstFactor.factor, srcFactorAlpha.factor, dstFactorAlpha.factor);
192,198c241,254
<     public static void tryBlendFuncSeparate(int n, int n2, int n3, int n4) {
<         if (n != GlStateManager.blendState.srcFactor || n2 != GlStateManager.blendState.dstFactor || n3 != GlStateManager.blendState.srcFactorAlpha || n4 != GlStateManager.blendState.dstFactorAlpha) {
<             GlStateManager.blendState.srcFactor = n;
<             GlStateManager.blendState.dstFactor = n2;
<             GlStateManager.blendState.srcFactorAlpha = n3;
<             GlStateManager.blendState.dstFactorAlpha = n4;
<             OpenGlHelper.glBlendFunc((int)n, (int)n2, (int)n3, (int)n4);
---
>     public static void tryBlendFuncSeparate(int srcFactor, int dstFactor, int srcFactorAlpha, int dstFactorAlpha) {
>         if (blendLock.isLocked()) {
>             blendLockState.setFactors(srcFactor, dstFactor, srcFactorAlpha, dstFactorAlpha);
>             return;
>         }
>         if (srcFactor != GlStateManager.blendState.srcFactor || dstFactor != GlStateManager.blendState.dstFactor || srcFactorAlpha != GlStateManager.blendState.srcFactorAlpha || dstFactorAlpha != GlStateManager.blendState.dstFactorAlpha) {
>             GlStateManager.blendState.srcFactor = srcFactor;
>             GlStateManager.blendState.dstFactor = dstFactor;
>             GlStateManager.blendState.srcFactorAlpha = srcFactorAlpha;
>             GlStateManager.blendState.dstFactorAlpha = dstFactorAlpha;
>             if (Config.isShaders()) {
>                 Shaders.uniform_blendFunc.setValue(srcFactor, dstFactor, srcFactorAlpha, dstFactorAlpha);
>             }
>             OpenGlHelper.glBlendFunc((int)srcFactor, (int)dstFactor, (int)srcFactorAlpha, (int)dstFactorAlpha);
202,203c258,259
<     public static void glBlendEquation(int n) {
<         GL14.glBlendEquation((int)n);
---
>     public static void glBlendEquation(int blendEquation) {
>         GL14.glBlendEquation((int)blendEquation);
206,210c262,266
<     public static void enableOutlineMode(int n) {
<         BUF_FLOAT_4.put(0, (float)(n >> 16 & 0xFF) / 255.0f);
<         BUF_FLOAT_4.put(1, (float)(n >> 8 & 0xFF) / 255.0f);
<         BUF_FLOAT_4.put(2, (float)(n >> 0 & 0xFF) / 255.0f);
<         BUF_FLOAT_4.put(3, (float)(n >> 24 & 0xFF) / 255.0f);
---
>     public static void enableOutlineMode(int p_187431_0_) {
>         BUF_FLOAT_4.put(0, (float)(p_187431_0_ >> 16 & 0xFF) / 255.0f);
>         BUF_FLOAT_4.put(1, (float)(p_187431_0_ >> 8 & 0xFF) / 255.0f);
>         BUF_FLOAT_4.put(2, (float)(p_187431_0_ >> 0 & 0xFF) / 255.0f);
>         BUF_FLOAT_4.put(3, (float)(p_187431_0_ >> 24 & 0xFF) / 255.0f);
243,246c299,305
<     private static void setFog(int n) {
<         if (n != GlStateManager.fogState.mode) {
<             GlStateManager.fogState.mode = n;
<             GL11.glFogi((int)2917, (int)n);
---
>     private static void setFog(int param) {
>         if (param != GlStateManager.fogState.mode) {
>             GlStateManager.fogState.mode = param;
>             GL11.glFogi((int)2917, (int)param);
>             if (Config.isShaders()) {
>                 Shaders.setFogMode((int)param);
>             }
250,253c309,318
<     public static void setFogDensity(float f) {
<         if (f != GlStateManager.fogState.density) {
<             GlStateManager.fogState.density = f;
<             GL11.glFogf((int)2914, (float)f);
---
>     public static void setFogDensity(float param) {
>         if (param < 0.0f) {
>             param = 0.0f;
>         }
>         if (param != GlStateManager.fogState.density) {
>             GlStateManager.fogState.density = param;
>             GL11.glFogf((int)2914, (float)param);
>             if (Config.isShaders()) {
>                 Shaders.setFogDensity((float)param);
>             }
257,260c322,325
<     public static void setFogStart(float f) {
<         if (f != GlStateManager.fogState.start) {
<             GlStateManager.fogState.start = f;
<             GL11.glFogf((int)2915, (float)f);
---
>     public static void setFogStart(float param) {
>         if (param != GlStateManager.fogState.start) {
>             GlStateManager.fogState.start = param;
>             GL11.glFogf((int)2915, (float)param);
264,267c329,332
<     public static void setFogEnd(float f) {
<         if (f != GlStateManager.fogState.end) {
<             GlStateManager.fogState.end = f;
<             GL11.glFogf((int)2916, (float)f);
---
>     public static void setFogEnd(float param) {
>         if (param != GlStateManager.fogState.end) {
>             GlStateManager.fogState.end = param;
>             GL11.glFogf((int)2916, (float)param);
271,272c336,337
<     public static void glFog(int n, FloatBuffer floatBuffer) {
<         GL11.glFog((int)n, (FloatBuffer)floatBuffer);
---
>     public static void glFog(int pname, FloatBuffer param) {
>         GL11.glFog((int)pname, (FloatBuffer)param);
275,276c340,341
<     public static void glFogi(int n, int n2) {
<         GL11.glFogi((int)n, (int)n2);
---
>     public static void glFogi(int pname, int param) {
>         GL11.glFogi((int)pname, (int)param);
291,294c356,359
<     private static void cullFace(int n) {
<         if (n != GlStateManager.cullState.mode) {
<             GlStateManager.cullState.mode = n;
<             GL11.glCullFace((int)n);
---
>     private static void cullFace(int mode) {
>         if (mode != GlStateManager.cullState.mode) {
>             GlStateManager.cullState.mode = mode;
>             GL11.glCullFace((int)mode);
298,299c363,364
<     public static void glPolygonMode(int n, int n2) {
<         GL11.glPolygonMode((int)n, (int)n2);
---
>     public static void glPolygonMode(int face, int mode) {
>         GL11.glPolygonMode((int)face, (int)mode);
310,314c375,379
<     public static void doPolygonOffset(float f, float f2) {
<         if (f != GlStateManager.polygonOffsetState.factor || f2 != GlStateManager.polygonOffsetState.units) {
<             GlStateManager.polygonOffsetState.factor = f;
<             GlStateManager.polygonOffsetState.units = f2;
<             GL11.glPolygonOffset((float)f, (float)f2);
---
>     public static void doPolygonOffset(float factor, float units) {
>         if (factor != GlStateManager.polygonOffsetState.factor || units != GlStateManager.polygonOffsetState.units) {
>             GlStateManager.polygonOffsetState.factor = factor;
>             GlStateManager.polygonOffsetState.units = units;
>             GL11.glPolygonOffset((float)factor, (float)units);
326,327c391,392
<     public static void colorLogicOp(LogicOp logicOp) {
<         GlStateManager.colorLogicOp(logicOp.opcode);
---
>     public static void colorLogicOp(LogicOp logicOperation) {
>         GlStateManager.colorLogicOp(logicOperation.opcode);
330,333c395,398
<     public static void colorLogicOp(int n) {
<         if (n != GlStateManager.colorLogicState.opcode) {
<             GlStateManager.colorLogicState.opcode = n;
<             GL11.glLogicOp((int)n);
---
>     public static void colorLogicOp(int opcode) {
>         if (opcode != GlStateManager.colorLogicState.opcode) {
>             GlStateManager.colorLogicState.opcode = opcode;
>             GL11.glLogicOp((int)opcode);
345,349c410,414
<     public static void texGen(TexGen texGen, int n) {
<         TexGenCoord texGenCoord = GlStateManager.texGenCoord(texGen);
<         if (n != texGenCoord.param) {
<             texGenCoord.param = n;
<             GL11.glTexGeni((int)texGenCoord.coord, (int)9472, (int)n);
---
>     public static void texGen(TexGen texGen, int param) {
>         TexGenCoord glstatemanager$texgencoord = GlStateManager.texGenCoord(texGen);
>         if (param != glstatemanager$texgencoord.param) {
>             glstatemanager$texgencoord.param = param;
>             GL11.glTexGeni((int)glstatemanager$texgencoord.coord, (int)9472, (int)param);
353,354c418,419
<     public static void texGen(TexGen texGen, int n, FloatBuffer floatBuffer) {
<         GL11.glTexGen((int)GlStateManager.texGenCoord((TexGen)texGen).coord, (int)n, (FloatBuffer)floatBuffer);
---
>     public static void texGen(TexGen texGen, int pname, FloatBuffer params) {
>         GL11.glTexGen((int)GlStateManager.texGenCoord((TexGen)texGen).coord, (int)pname, (FloatBuffer)params);
358c423
<         switch (1.field_179175_a[texGen.ordinal()]) {
---
>         switch (1.$SwitchMap$net$minecraft$client$renderer$GlStateManager$TexGen[texGen.ordinal()]) {
375,378c440,443
<     public static void setActiveTexture(int n) {
<         if (activeTextureUnit != n - OpenGlHelper.defaultTexUnit) {
<             activeTextureUnit = n - OpenGlHelper.defaultTexUnit;
<             OpenGlHelper.setActiveTexture((int)n);
---
>     public static void setActiveTexture(int texture) {
>         if (activeTextureUnit != texture - OpenGlHelper.defaultTexUnit) {
>             activeTextureUnit = texture - OpenGlHelper.defaultTexUnit;
>             OpenGlHelper.setActiveTexture((int)texture);
390,391c455,456
<     public static void glTexEnv(int n, int n2, FloatBuffer floatBuffer) {
<         GL11.glTexEnv((int)n, (int)n2, (FloatBuffer)floatBuffer);
---
>     public static void glTexEnv(int target, int parameterName, FloatBuffer parameters) {
>         GL11.glTexEnv((int)target, (int)parameterName, (FloatBuffer)parameters);
394,395c459,460
<     public static void glTexEnvi(int n, int n2, int n3) {
<         GL11.glTexEnvi((int)n, (int)n2, (int)n3);
---
>     public static void glTexEnvi(int target, int parameterName, int parameter) {
>         GL11.glTexEnvi((int)target, (int)parameterName, (int)parameter);
398,399c463,464
<     public static void glTexEnvf(int n, int n2, float f) {
<         GL11.glTexEnvf((int)n, (int)n2, (float)f);
---
>     public static void glTexEnvf(int target, int parameterName, float parameter) {
>         GL11.glTexEnvf((int)target, (int)parameterName, (float)parameter);
402,403c467,468
<     public static void glTexParameterf(int n, int n2, float f) {
<         GL11.glTexParameterf((int)n, (int)n2, (float)f);
---
>     public static void glTexParameterf(int target, int parameterName, float parameter) {
>         GL11.glTexParameterf((int)target, (int)parameterName, (float)parameter);
406,407c471,472
<     public static void glTexParameteri(int n, int n2, int n3) {
<         GL11.glTexParameteri((int)n, (int)n2, (int)n3);
---
>     public static void glTexParameteri(int target, int parameterName, int parameter) {
>         GL11.glTexParameteri((int)target, (int)parameterName, (int)parameter);
410,411c475,476
<     public static int glGetTexLevelParameteri(int n, int n2, int n3) {
<         return GL11.glGetTexLevelParameteri((int)n, (int)n2, (int)n3);
---
>     public static int glGetTexLevelParameteri(int target, int level, int parameterName) {
>         return GL11.glGetTexLevelParameteri((int)target, (int)level, (int)parameterName);
418,422c483,490
<     public static void deleteTexture(int n) {
<         GL11.glDeleteTextures((int)n);
<         for (TextureState textureState : GlStateManager.textureState) {
<             if (textureState.textureName != n) continue;
<             textureState.textureName = -1;
---
>     public static void deleteTexture(int texture) {
>         if (texture == 0) {
>             return;
>         }
>         GL11.glDeleteTextures((int)texture);
>         for (TextureState glstatemanager$texturestate : textureState) {
>             if (glstatemanager$texturestate.textureName != texture) continue;
>             glstatemanager$texturestate.textureName = 0;
426,429c494,500
<     public static void bindTexture(int n) {
<         if (n != GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName) {
<             GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName = n;
<             GL11.glBindTexture((int)3553, (int)n);
---
>     public static void bindTexture(int texture) {
>         if (texture != GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName) {
>             GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName = texture;
>             GL11.glBindTexture((int)3553, (int)texture);
>             if (SmartAnimations.isActive()) {
>                 SmartAnimations.textureRendered((int)texture);
>             }
433,434c504,505
<     public static void glTexImage2D(int n, int n2, int n3, int n4, int n5, int n6, int n7, int n8, @Nullable IntBuffer intBuffer) {
<         GL11.glTexImage2D((int)n, (int)n2, (int)n3, (int)n4, (int)n5, (int)n6, (int)n7, (int)n8, (IntBuffer)intBuffer);
---
>     public static void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, @Nullable IntBuffer pixels) {
>         GL11.glTexImage2D((int)target, (int)level, (int)internalFormat, (int)width, (int)height, (int)border, (int)format, (int)type, (IntBuffer)pixels);
437,438c508,509
<     public static void glTexSubImage2D(int n, int n2, int n3, int n4, int n5, int n6, int n7, int n8, IntBuffer intBuffer) {
<         GL11.glTexSubImage2D((int)n, (int)n2, (int)n3, (int)n4, (int)n5, (int)n6, (int)n7, (int)n8, (IntBuffer)intBuffer);
---
>     public static void glTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, IntBuffer pixels) {
>         GL11.glTexSubImage2D((int)target, (int)level, (int)xOffset, (int)yOffset, (int)width, (int)height, (int)format, (int)type, (IntBuffer)pixels);
441,442c512,513
<     public static void glCopyTexSubImage2D(int n, int n2, int n3, int n4, int n5, int n6, int n7, int n8) {
<         GL11.glCopyTexSubImage2D((int)n, (int)n2, (int)n3, (int)n4, (int)n5, (int)n6, (int)n7, (int)n8);
---
>     public static void glCopyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height) {
>         GL11.glCopyTexSubImage2D((int)target, (int)level, (int)xOffset, (int)yOffset, (int)x, (int)y, (int)width, (int)height);
445,446c516,517
<     public static void glGetTexImage(int n, int n2, int n3, int n4, IntBuffer intBuffer) {
<         GL11.glGetTexImage((int)n, (int)n2, (int)n3, (int)n4, (IntBuffer)intBuffer);
---
>     public static void glGetTexImage(int target, int level, int format, int type, IntBuffer pixels) {
>         GL11.glGetTexImage((int)target, (int)level, (int)format, (int)type, (IntBuffer)pixels);
457,460c528,531
<     public static void shadeModel(int n) {
<         if (n != activeShadeModel) {
<             activeShadeModel = n;
<             GL11.glShadeModel((int)n);
---
>     public static void shadeModel(int mode) {
>         if (mode != activeShadeModel) {
>             activeShadeModel = mode;
>             GL11.glShadeModel((int)mode);
472,473c543,544
<     public static void viewport(int n, int n2, int n3, int n4) {
<         GL11.glViewport((int)n, (int)n2, (int)n3, (int)n4);
---
>     public static void viewport(int x, int y, int width, int height) {
>         GL11.glViewport((int)x, (int)y, (int)width, (int)height);
476,482c547,553
<     public static void colorMask(boolean bl, boolean bl2, boolean bl3, boolean bl4) {
<         if (bl != GlStateManager.colorMaskState.red || bl2 != GlStateManager.colorMaskState.green || bl3 != GlStateManager.colorMaskState.blue || bl4 != GlStateManager.colorMaskState.alpha) {
<             GlStateManager.colorMaskState.red = bl;
<             GlStateManager.colorMaskState.green = bl2;
<             GlStateManager.colorMaskState.blue = bl3;
<             GlStateManager.colorMaskState.alpha = bl4;
<             GL11.glColorMask((boolean)bl, (boolean)bl2, (boolean)bl3, (boolean)bl4);
---
>     public static void colorMask(boolean red, boolean green, boolean blue, boolean alpha) {
>         if (red != GlStateManager.colorMaskState.red || green != GlStateManager.colorMaskState.green || blue != GlStateManager.colorMaskState.blue || alpha != GlStateManager.colorMaskState.alpha) {
>             GlStateManager.colorMaskState.red = red;
>             GlStateManager.colorMaskState.green = green;
>             GlStateManager.colorMaskState.blue = blue;
>             GlStateManager.colorMaskState.alpha = alpha;
>             GL11.glColorMask((boolean)red, (boolean)green, (boolean)blue, (boolean)alpha);
486,489c557,560
<     public static void clearDepth(double d) {
<         if (d != GlStateManager.clearState.depth) {
<             GlStateManager.clearState.depth = d;
<             GL11.glClearDepth((double)d);
---
>     public static void clearDepth(double depth) {
>         if (depth != GlStateManager.clearState.depth) {
>             GlStateManager.clearState.depth = depth;
>             GL11.glClearDepth((double)depth);
493,499c564,570
<     public static void clearColor(float f, float f2, float f3, float f4) {
<         if (f != GlStateManager.clearState.color.red || f2 != GlStateManager.clearState.color.green || f3 != GlStateManager.clearState.color.blue || f4 != GlStateManager.clearState.color.alpha) {
<             GlStateManager.clearState.color.red = f;
<             GlStateManager.clearState.color.green = f2;
<             GlStateManager.clearState.color.blue = f3;
<             GlStateManager.clearState.color.alpha = f4;
<             GL11.glClearColor((float)f, (float)f2, (float)f3, (float)f4);
---
>     public static void clearColor(float red, float green, float blue, float alpha) {
>         if (red != GlStateManager.clearState.color.red || green != GlStateManager.clearState.color.green || blue != GlStateManager.clearState.color.blue || alpha != GlStateManager.clearState.color.alpha) {
>             GlStateManager.clearState.color.red = red;
>             GlStateManager.clearState.color.green = green;
>             GlStateManager.clearState.color.blue = blue;
>             GlStateManager.clearState.color.alpha = alpha;
>             GL11.glClearColor((float)red, (float)green, (float)blue, (float)alpha);
503,504c574,578
<     public static void clear(int n) {
<         GL11.glClear((int)n);
---
>     public static void clear(int mask) {
>         if (!clearEnabled) {
>             return;
>         }
>         GL11.glClear((int)mask);
507,508c581,582
<     public static void matrixMode(int n) {
<         GL11.glMatrixMode((int)n);
---
>     public static void matrixMode(int mode) {
>         GL11.glMatrixMode((int)mode);
523,524c597,598
<     public static void getFloat(int n, FloatBuffer floatBuffer) {
<         GL11.glGetFloat((int)n, (FloatBuffer)floatBuffer);
---
>     public static void getFloat(int pname, FloatBuffer params) {
>         GL11.glGetFloat((int)pname, (FloatBuffer)params);
527,528c601,602
<     public static void ortho(double d, double d2, double d3, double d4, double d5, double d6) {
<         GL11.glOrtho((double)d, (double)d2, (double)d3, (double)d4, (double)d5, (double)d6);
---
>     public static void ortho(double left, double right, double bottom, double top, double zNear, double zFar) {
>         GL11.glOrtho((double)left, (double)right, (double)bottom, (double)top, (double)zNear, (double)zFar);
531,532c605,606
<     public static void rotate(float f, float f2, float f3, float f4) {
<         GL11.glRotatef((float)f, (float)f2, (float)f3, (float)f4);
---
>     public static void rotate(float angle, float x, float y, float z) {
>         GL11.glRotatef((float)angle, (float)x, (float)y, (float)z);
535,536c609,610
<     public static void scale(float f, float f2, float f3) {
<         GL11.glScalef((float)f, (float)f2, (float)f3);
---
>     public static void scale(float x, float y, float z) {
>         GL11.glScalef((float)x, (float)y, (float)z);
539,540c613,614
<     public static void scale(double d, double d2, double d3) {
<         GL11.glScaled((double)d, (double)d2, (double)d3);
---
>     public static void scale(double x, double y, double z) {
>         GL11.glScaled((double)x, (double)y, (double)z);
543,544c617,618
<     public static void translate(float f, float f2, float f3) {
<         GL11.glTranslatef((float)f, (float)f2, (float)f3);
---
>     public static void translate(float x, float y, float z) {
>         GL11.glTranslatef((float)x, (float)y, (float)z);
547,548c621,622
<     public static void translate(double d, double d2, double d3) {
<         GL11.glTranslated((double)d, (double)d2, (double)d3);
---
>     public static void translate(double x, double y, double z) {
>         GL11.glTranslated((double)x, (double)y, (double)z);
551,552c625,626
<     public static void multMatrix(FloatBuffer floatBuffer) {
<         GL11.glMultMatrix((FloatBuffer)floatBuffer);
---
>     public static void multMatrix(FloatBuffer matrix) {
>         GL11.glMultMatrix((FloatBuffer)matrix);
555,556c629,630
<     public static void rotate(Quaternion quaternion) {
<         GlStateManager.multMatrix(GlStateManager.quatToGlMatrix(BUF_FLOAT_16, quaternion));
---
>     public static void rotate(Quaternion quaternionIn) {
>         GlStateManager.multMatrix(GlStateManager.quatToGlMatrix(BUF_FLOAT_16, quaternionIn));
559,587c633,661
<     public static FloatBuffer quatToGlMatrix(FloatBuffer floatBuffer, Quaternion quaternion) {
<         floatBuffer.clear();
<         float f = quaternion.x * quaternion.x;
<         \u2603 = quaternion.x * quaternion.y;
<         \u2603 = quaternion.x * quaternion.z;
<         \u2603 = quaternion.x * quaternion.w;
<         \u2603 = quaternion.y * quaternion.y;
<         \u2603 = quaternion.y * quaternion.z;
<         \u2603 = quaternion.y * quaternion.w;
<         \u2603 = quaternion.z * quaternion.z;
<         \u2603 = quaternion.z * quaternion.w;
<         floatBuffer.put(1.0f - 2.0f * (\u2603 + \u2603));
<         floatBuffer.put(2.0f * (\u2603 + \u2603));
<         floatBuffer.put(2.0f * (\u2603 - \u2603));
<         floatBuffer.put(0.0f);
<         floatBuffer.put(2.0f * (\u2603 - \u2603));
<         floatBuffer.put(1.0f - 2.0f * (f + \u2603));
<         floatBuffer.put(2.0f * (\u2603 + \u2603));
<         floatBuffer.put(0.0f);
<         floatBuffer.put(2.0f * (\u2603 + \u2603));
<         floatBuffer.put(2.0f * (\u2603 - \u2603));
<         floatBuffer.put(1.0f - 2.0f * (f + \u2603));
<         floatBuffer.put(0.0f);
<         floatBuffer.put(0.0f);
<         floatBuffer.put(0.0f);
<         floatBuffer.put(0.0f);
<         floatBuffer.put(1.0f);
<         floatBuffer.rewind();
<         return floatBuffer;
---
>     public static FloatBuffer quatToGlMatrix(FloatBuffer buffer, Quaternion quaternionIn) {
>         buffer.clear();
>         float f = quaternionIn.x * quaternionIn.x;
>         float f1 = quaternionIn.x * quaternionIn.y;
>         float f2 = quaternionIn.x * quaternionIn.z;
>         float f3 = quaternionIn.x * quaternionIn.w;
>         float f4 = quaternionIn.y * quaternionIn.y;
>         float f5 = quaternionIn.y * quaternionIn.z;
>         float f6 = quaternionIn.y * quaternionIn.w;
>         float f7 = quaternionIn.z * quaternionIn.z;
>         float f8 = quaternionIn.z * quaternionIn.w;
>         buffer.put(1.0f - 2.0f * (f4 + f7));
>         buffer.put(2.0f * (f1 + f8));
>         buffer.put(2.0f * (f2 - f6));
>         buffer.put(0.0f);
>         buffer.put(2.0f * (f1 - f8));
>         buffer.put(1.0f - 2.0f * (f + f7));
>         buffer.put(2.0f * (f5 + f3));
>         buffer.put(0.0f);
>         buffer.put(2.0f * (f2 + f6));
>         buffer.put(2.0f * (f5 - f3));
>         buffer.put(1.0f - 2.0f * (f + f4));
>         buffer.put(0.0f);
>         buffer.put(0.0f);
>         buffer.put(0.0f);
>         buffer.put(0.0f);
>         buffer.put(1.0f);
>         buffer.rewind();
>         return buffer;
590,596c664,670
<     public static void color(float f, float f2, float f3, float f4) {
<         if (f != GlStateManager.colorState.red || f2 != GlStateManager.colorState.green || f3 != GlStateManager.colorState.blue || f4 != GlStateManager.colorState.alpha) {
<             GlStateManager.colorState.red = f;
<             GlStateManager.colorState.green = f2;
<             GlStateManager.colorState.blue = f3;
<             GlStateManager.colorState.alpha = f4;
<             GL11.glColor4f((float)f, (float)f2, (float)f3, (float)f4);
---
>     public static void color(float colorRed, float colorGreen, float colorBlue, float colorAlpha) {
>         if (colorRed != GlStateManager.colorState.red || colorGreen != GlStateManager.colorState.green || colorBlue != GlStateManager.colorState.blue || colorAlpha != GlStateManager.colorState.alpha) {
>             GlStateManager.colorState.red = colorRed;
>             GlStateManager.colorState.green = colorGreen;
>             GlStateManager.colorState.blue = colorBlue;
>             GlStateManager.colorState.alpha = colorAlpha;
>             GL11.glColor4f((float)colorRed, (float)colorGreen, (float)colorBlue, (float)colorAlpha);
600,601c674,675
<     public static void color(float f, float f2, float f3) {
<         GlStateManager.color(f, f2, f3, 1.0f);
---
>     public static void color(float colorRed, float colorGreen, float colorBlue) {
>         GlStateManager.color(colorRed, colorGreen, colorBlue, 1.0f);
604,605c678,679
<     public static void glTexCoord2f(float f, float f2) {
<         GL11.glTexCoord2f((float)f, (float)f2);
---
>     public static void glTexCoord2f(float sCoord, float tCoord) {
>         GL11.glTexCoord2f((float)sCoord, (float)tCoord);
608,609c682,683
<     public static void glVertex3f(float f, float f2, float f3) {
<         GL11.glVertex3f((float)f, (float)f2, (float)f3);
---
>     public static void glVertex3f(float x, float y, float z) {
>         GL11.glVertex3f((float)x, (float)y, (float)z);
619,620c693,694
<     public static void glNormalPointer(int n, int n2, ByteBuffer byteBuffer) {
<         GL11.glNormalPointer((int)n, (int)n2, (ByteBuffer)byteBuffer);
---
>     public static void glNormalPointer(int type, int stride, ByteBuffer buffer) {
>         GL11.glNormalPointer((int)type, (int)stride, (ByteBuffer)buffer);
623,624c697,698
<     public static void glTexCoordPointer(int n, int n2, int n3, int n4) {
<         GL11.glTexCoordPointer((int)n, (int)n2, (int)n3, (long)n4);
---
>     public static void glTexCoordPointer(int size, int type, int stride, int buffer_offset) {
>         GL11.glTexCoordPointer((int)size, (int)type, (int)stride, (long)buffer_offset);
627,628c701,702
<     public static void glTexCoordPointer(int n, int n2, int n3, ByteBuffer byteBuffer) {
<         GL11.glTexCoordPointer((int)n, (int)n2, (int)n3, (ByteBuffer)byteBuffer);
---
>     public static void glTexCoordPointer(int size, int type, int stride, ByteBuffer buffer) {
>         GL11.glTexCoordPointer((int)size, (int)type, (int)stride, (ByteBuffer)buffer);
631,632c705,706
<     public static void glVertexPointer(int n, int n2, int n3, int n4) {
<         GL11.glVertexPointer((int)n, (int)n2, (int)n3, (long)n4);
---
>     public static void glVertexPointer(int size, int type, int stride, int buffer_offset) {
>         GL11.glVertexPointer((int)size, (int)type, (int)stride, (long)buffer_offset);
635,636c709,710
<     public static void glVertexPointer(int n, int n2, int n3, ByteBuffer byteBuffer) {
<         GL11.glVertexPointer((int)n, (int)n2, (int)n3, (ByteBuffer)byteBuffer);
---
>     public static void glVertexPointer(int size, int type, int stride, ByteBuffer buffer) {
>         GL11.glVertexPointer((int)size, (int)type, (int)stride, (ByteBuffer)buffer);
639,640c713,714
<     public static void glColorPointer(int n, int n2, int n3, int n4) {
<         GL11.glColorPointer((int)n, (int)n2, (int)n3, (long)n4);
---
>     public static void glColorPointer(int size, int type, int stride, int buffer_offset) {
>         GL11.glColorPointer((int)size, (int)type, (int)stride, (long)buffer_offset);
643,644c717,718
<     public static void glColorPointer(int n, int n2, int n3, ByteBuffer byteBuffer) {
<         GL11.glColorPointer((int)n, (int)n2, (int)n3, (ByteBuffer)byteBuffer);
---
>     public static void glColorPointer(int size, int type, int stride, ByteBuffer buffer) {
>         GL11.glColorPointer((int)size, (int)type, (int)stride, (ByteBuffer)buffer);
647,648c721,722
<     public static void glDisableClientState(int n) {
<         GL11.glDisableClientState((int)n);
---
>     public static void glDisableClientState(int cap) {
>         GL11.glDisableClientState((int)cap);
651,652c725,726
<     public static void glEnableClientState(int n) {
<         GL11.glEnableClientState((int)n);
---
>     public static void glEnableClientState(int cap) {
>         GL11.glEnableClientState((int)cap);
655,656c729,730
<     public static void glBegin(int n) {
<         GL11.glBegin((int)n);
---
>     public static void glBegin(int mode) {
>         GL11.glBegin((int)mode);
663,664c737,750
<     public static void glDrawArrays(int n, int n2, int n3) {
<         GL11.glDrawArrays((int)n, (int)n2, (int)n3);
---
>     public static void glDrawArrays(int mode, int first, int count) {
>         int countInstances;
>         GL11.glDrawArrays((int)mode, (int)first, (int)count);
>         if (Config.isShaders() && !creatingDisplayList && (countInstances = Shaders.activeProgram.getCountInstances()) > 1) {
>             for (int i = 1; i < countInstances; ++i) {
>                 Shaders.uniform_instanceId.setValue(i);
>                 GL11.glDrawArrays((int)mode, (int)first, (int)count);
>             }
>             Shaders.uniform_instanceId.setValue(0);
>         }
>     }
> 
>     public static void glLineWidth(float width) {
>         GL11.glLineWidth((float)width);
667,668c753,762
<     public static void glLineWidth(float f) {
<         GL11.glLineWidth((float)f);
---
>     public static void callList(int list) {
>         int countInstances;
>         GL11.glCallList((int)list);
>         if (Config.isShaders() && !creatingDisplayList && (countInstances = Shaders.activeProgram.getCountInstances()) > 1) {
>             for (int i = 1; i < countInstances; ++i) {
>                 Shaders.uniform_instanceId.setValue(i);
>                 GL11.glCallList((int)list);
>             }
>             Shaders.uniform_instanceId.setValue(0);
>         }
671,672c765,774
<     public static void callList(int n) {
<         GL11.glCallList((int)n);
---
>     public static void callLists(IntBuffer lists) {
>         int countInstances;
>         GL11.glCallLists((IntBuffer)lists);
>         if (Config.isShaders() && !creatingDisplayList && (countInstances = Shaders.activeProgram.getCountInstances()) > 1) {
>             for (int i = 1; i < countInstances; ++i) {
>                 Shaders.uniform_instanceId.setValue(i);
>                 GL11.glCallLists((IntBuffer)lists);
>             }
>             Shaders.uniform_instanceId.setValue(0);
>         }
675,676c777,778
<     public static void glDeleteLists(int n, int n2) {
<         GL11.glDeleteLists((int)n, (int)n2);
---
>     public static void glDeleteLists(int list, int range) {
>         GL11.glDeleteLists((int)list, (int)range);
679,680c781,783
<     public static void glNewList(int n, int n2) {
<         GL11.glNewList((int)n, (int)n2);
---
>     public static void glNewList(int list, int mode) {
>         GL11.glNewList((int)list, (int)mode);
>         creatingDisplayList = true;
684a788
>         creatingDisplayList = false;
687,688c791,792
<     public static int glGenLists(int n) {
<         return GL11.glGenLists((int)n);
---
>     public static int glGenLists(int range) {
>         return GL11.glGenLists((int)range);
691,692c795,796
<     public static void glPixelStorei(int n, int n2) {
<         GL11.glPixelStorei((int)n, (int)n2);
---
>     public static void glPixelStorei(int parameterName, int param) {
>         GL11.glPixelStorei((int)parameterName, (int)param);
695,696c799,800
<     public static void glReadPixels(int n, int n2, int n3, int n4, int n5, int n6, IntBuffer intBuffer) {
<         GL11.glReadPixels((int)n, (int)n2, (int)n3, (int)n4, (int)n5, (int)n6, (IntBuffer)intBuffer);
---
>     public static void glReadPixels(int x, int y, int width, int height, int format, int type, IntBuffer pixels) {
>         GL11.glReadPixels((int)x, (int)y, (int)width, (int)height, (int)format, (int)type, (IntBuffer)pixels);
703,704c807,820
<     public static String glGetString(int n) {
<         return GL11.glGetString((int)n);
---
>     public static String glGetString(int name) {
>         return GL11.glGetString((int)name);
>     }
> 
>     public static void glGetInteger(int parameterName, IntBuffer parameters) {
>         GL11.glGetInteger((int)parameterName, (IntBuffer)parameters);
>     }
> 
>     public static int glGetInteger(int parameterName) {
>         return GL11.glGetInteger((int)parameterName);
>     }
> 
>     public static void enableBlendProfile(Profile p_187408_0_) {
>         p_187408_0_.apply();
707,708c823,824
<     public static void glGetInteger(int n, IntBuffer intBuffer) {
<         GL11.glGetInteger((int)n, (IntBuffer)intBuffer);
---
>     public static void disableBlendProfile(Profile p_187440_0_) {
>         p_187440_0_.clean();
711,712c827,828
<     public static int glGetInteger(int n) {
<         return GL11.glGetInteger((int)n);
---
>     public static int getActiveTextureUnit() {
>         return OpenGlHelper.defaultTexUnit + activeTextureUnit;
715,716c831,832
<     public static void enableBlendProfile(Profile profile) {
<         profile.apply();
---
>     public static void bindCurrentTexture() {
>         GL11.glBindTexture((int)3553, (int)GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName);
719,720c835,951
<     public static void disableBlendProfile(Profile profile) {
<         profile.clean();
---
>     public static int getBoundTexture() {
>         return GlStateManager.textureState[GlStateManager.activeTextureUnit].textureName;
>     }
> 
>     public static void checkBoundTexture() {
>         if (!Config.isMinecraftThread()) {
>             return;
>         }
>         int glAct = GL11.glGetInteger((int)34016);
>         int glTex = GL11.glGetInteger((int)32873);
>         int act = GlStateManager.getActiveTextureUnit();
>         int tex = GlStateManager.getBoundTexture();
>         if (tex <= 0) {
>             return;
>         }
>         if (glAct != act || glTex != tex) {
>             Config.dbg((String)("checkTexture: act: " + act + ", glAct: " + glAct + ", tex: " + tex + ", glTex: " + glTex));
>         }
>     }
> 
>     public static void deleteTextures(IntBuffer buf) {
>         buf.rewind();
>         while (buf.position() < buf.limit()) {
>             int texId = buf.get();
>             GlStateManager.deleteTexture(texId);
>         }
>         buf.rewind();
>     }
> 
>     public static boolean isFogEnabled() {
>         return BooleanState.access$100((BooleanState)GlStateManager.fogState.fog);
>     }
> 
>     public static void setFogEnabled(boolean state) {
>         GlStateManager.fogState.fog.setState(state);
>     }
> 
>     public static void lockAlpha(GlAlphaState stateNew) {
>         if (alphaLock.isLocked()) {
>             return;
>         }
>         GlStateManager.getAlphaState(alphaLockState);
>         GlStateManager.setAlphaState(stateNew);
>         alphaLock.lock();
>     }
> 
>     public static void unlockAlpha() {
>         if (!alphaLock.unlock()) {
>             return;
>         }
>         GlStateManager.setAlphaState(alphaLockState);
>     }
> 
>     public static void getAlphaState(GlAlphaState state) {
>         if (alphaLock.isLocked()) {
>             state.setState(alphaLockState);
>             return;
>         }
>         state.setState(BooleanState.access$100((BooleanState)GlStateManager.alphaState.alphaTest), GlStateManager.alphaState.func, GlStateManager.alphaState.ref);
>     }
> 
>     public static void setAlphaState(GlAlphaState state) {
>         if (alphaLock.isLocked()) {
>             alphaLockState.setState(state);
>             return;
>         }
>         GlStateManager.alphaState.alphaTest.setState(state.isEnabled());
>         GlStateManager.alphaFunc(state.getFunc(), state.getRef());
>     }
> 
>     public static void lockBlend(GlBlendState stateNew) {
>         if (blendLock.isLocked()) {
>             return;
>         }
>         GlStateManager.getBlendState(blendLockState);
>         GlStateManager.setBlendState(stateNew);
>         blendLock.lock();
>     }
> 
>     public static void unlockBlend() {
>         if (!blendLock.unlock()) {
>             return;
>         }
>         GlStateManager.setBlendState(blendLockState);
>     }
> 
>     public static void getBlendState(GlBlendState gbs) {
>         if (blendLock.isLocked()) {
>             gbs.setState(blendLockState);
>             return;
>         }
>         gbs.setState(BooleanState.access$100((BooleanState)GlStateManager.blendState.blend), GlStateManager.blendState.srcFactor, GlStateManager.blendState.dstFactor, GlStateManager.blendState.srcFactorAlpha, GlStateManager.blendState.dstFactorAlpha);
>     }
> 
>     public static void setBlendState(GlBlendState gbs) {
>         if (blendLock.isLocked()) {
>             blendLockState.setState(gbs);
>             return;
>         }
>         GlStateManager.blendState.blend.setState(gbs.isEnabled());
>         if (!gbs.isSeparate()) {
>             GlStateManager.blendFunc(gbs.getSrcFactor(), gbs.getDstFactor());
>         } else {
>             GlStateManager.tryBlendFuncSeparate(gbs.getSrcFactor(), gbs.getDstFactor(), gbs.getSrcFactorAlpha(), gbs.getDstFactorAlpha());
>         }
>     }
> 
>     public static void glMultiDrawArrays(int mode, IntBuffer bFirst, IntBuffer bCount) {
>         int countInstances;
>         GL14.glMultiDrawArrays((int)mode, (IntBuffer)bFirst, (IntBuffer)bCount);
>         if (Config.isShaders() && !creatingDisplayList && (countInstances = Shaders.activeProgram.getCountInstances()) > 1) {
>             for (int i = 1; i < countInstances; ++i) {
>                 Shaders.uniform_instanceId.setValue(i);
>                 GL14.glMultiDrawArrays((int)mode, (IntBuffer)bFirst, (IntBuffer)bCount);
>             }
>             Shaders.uniform_instanceId.setValue(0);
>         }
724,731c955,962
<         int n;
<         BUF_FLOAT_16 = BufferUtils.createFloatBuffer((int)16);
<         BUF_FLOAT_4 = BufferUtils.createFloatBuffer((int)4);
<         alphaState = new AlphaState(null);
<         lightingState = new BooleanState(2896);
<         lightState = new BooleanState[8];
<         for (n = 0; n < 8; ++n) {
<             GlStateManager.lightState[n] = new BooleanState(16384 + n);
---
>         clearEnabled = true;
>         alphaLock = new LockCounter();
>         alphaLockState = new GlAlphaState();
>         blendLock = new LockCounter();
>         blendLockState = new GlBlendState();
>         creatingDisplayList = false;
>         for (int i = 0; i < 8; ++i) {
>             GlStateManager.lightState[i] = new BooleanState(16384 + i);
744,746c975,977
<         textureState = new TextureState[8];
<         for (n = 0; n < 8; ++n) {
<             GlStateManager.textureState[n] = new TextureState(null);
---
>         textureState = new TextureState[32];
>         for (int j = 0; j < textureState.length; ++j) {
>             GlStateManager.textureState[j] = new TextureState(null);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ImageBufferDownload.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ImageBufferDownload.java
9a10
>  *  java.awt.image.ImageObserver
20a22
> import java.awt.image.ImageObserver;
31,32c33,35
<     public BufferedImage parseUserSkin(BufferedImage bufferedImage) {
<         if (bufferedImage == null) {
---
>     public BufferedImage parseUserSkin(BufferedImage image) {
>         boolean flag;
>         if (image == null) {
37,41c40,53
<         \u2603 = new BufferedImage(this.imageWidth, this.imageHeight, 2);
<         Graphics graphics = \u2603.getGraphics();
<         graphics.drawImage((Image)bufferedImage, 0, 0, null);
<         boolean bl = \u2603 = bufferedImage.getHeight() == 32;
<         if (\u2603) {
---
>         BufferedImage srcImage = image;
>         int srcWidth = srcImage.getWidth();
>         int srcHeight = srcImage.getHeight();
>         int k = 1;
>         while (this.imageWidth < srcWidth || this.imageHeight < srcHeight) {
>             this.imageWidth *= 2;
>             this.imageHeight *= 2;
>             k *= 2;
>         }
>         BufferedImage bufferedimage = new BufferedImage(this.imageWidth, this.imageHeight, 2);
>         Graphics graphics = bufferedimage.getGraphics();
>         graphics.drawImage((Image)image, 0, 0, (ImageObserver)null);
>         boolean bl = flag = image.getHeight() == 32 * k;
>         if (flag) {
43,55c55,67
<             graphics.fillRect(0, 32, 64, 32);
<             graphics.drawImage((Image)\u2603, 24, 48, 20, 52, 4, 16, 8, 20, null);
<             graphics.drawImage((Image)\u2603, 28, 48, 24, 52, 8, 16, 12, 20, null);
<             graphics.drawImage((Image)\u2603, 20, 52, 16, 64, 8, 20, 12, 32, null);
<             graphics.drawImage((Image)\u2603, 24, 52, 20, 64, 4, 20, 8, 32, null);
<             graphics.drawImage((Image)\u2603, 28, 52, 24, 64, 0, 20, 4, 32, null);
<             graphics.drawImage((Image)\u2603, 32, 52, 28, 64, 12, 20, 16, 32, null);
<             graphics.drawImage((Image)\u2603, 40, 48, 36, 52, 44, 16, 48, 20, null);
<             graphics.drawImage((Image)\u2603, 44, 48, 40, 52, 48, 16, 52, 20, null);
<             graphics.drawImage((Image)\u2603, 36, 52, 32, 64, 48, 20, 52, 32, null);
<             graphics.drawImage((Image)\u2603, 40, 52, 36, 64, 44, 20, 48, 32, null);
<             graphics.drawImage((Image)\u2603, 44, 52, 40, 64, 40, 20, 44, 32, null);
<             graphics.drawImage((Image)\u2603, 48, 52, 44, 64, 52, 20, 56, 32, null);
---
>             graphics.fillRect(0 * k, 32 * k, 64 * k, 32 * k);
>             graphics.drawImage((Image)bufferedimage, 24 * k, 48 * k, 20 * k, 52 * k, 4 * k, 16 * k, 8 * k, 20 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 28 * k, 48 * k, 24 * k, 52 * k, 8 * k, 16 * k, 12 * k, 20 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 20 * k, 52 * k, 16 * k, 64 * k, 8 * k, 20 * k, 12 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 24 * k, 52 * k, 20 * k, 64 * k, 4 * k, 20 * k, 8 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 28 * k, 52 * k, 24 * k, 64 * k, 0 * k, 20 * k, 4 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 32 * k, 52 * k, 28 * k, 64 * k, 12 * k, 20 * k, 16 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 40 * k, 48 * k, 36 * k, 52 * k, 44 * k, 16 * k, 48 * k, 20 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 44 * k, 48 * k, 40 * k, 52 * k, 48 * k, 16 * k, 52 * k, 20 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 36 * k, 52 * k, 32 * k, 64 * k, 48 * k, 20 * k, 52 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 40 * k, 52 * k, 36 * k, 64 * k, 44 * k, 20 * k, 48 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 44 * k, 52 * k, 40 * k, 64 * k, 40 * k, 20 * k, 44 * k, 32 * k, (ImageObserver)null);
>             graphics.drawImage((Image)bufferedimage, 48 * k, 52 * k, 44 * k, 64 * k, 52 * k, 20 * k, 56 * k, 32 * k, (ImageObserver)null);
58,65c70,77
<         this.imageData = ((DataBufferInt)\u2603.getRaster().getDataBuffer()).getData();
<         this.setAreaOpaque(0, 0, 32, 16);
<         if (\u2603) {
<             this.setAreaTransparent(32, 0, 64, 32);
<         }
<         this.setAreaOpaque(0, 16, 64, 32);
<         this.setAreaOpaque(16, 48, 48, 64);
<         return \u2603;
---
>         this.imageData = ((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
>         this.setAreaOpaque(0 * k, 0 * k, 32 * k, 16 * k);
>         if (flag) {
>             this.setAreaTransparent(32 * k, 0 * k, 64 * k, 32 * k);
>         }
>         this.setAreaOpaque(0 * k, 16 * k, 64 * k, 32 * k);
>         this.setAreaOpaque(16 * k, 48 * k, 48 * k, 64 * k);
>         return bufferedimage;
71,75c83,87
<     private void setAreaTransparent(int n, int n2, int n3, int n4) {
<         for (\u2603 = n; \u2603 < n3; ++\u2603) {
<             for (\u2603 = n2; \u2603 < n4; ++\u2603) {
<                 \u2603 = this.imageData[\u2603 + \u2603 * this.imageWidth];
<                 if ((\u2603 >> 24 & 0xFF) >= 128) continue;
---
>     private void setAreaTransparent(int x, int y, int width, int height) {
>         for (int i = x; i < width; ++i) {
>             for (int j = y; j < height; ++j) {
>                 int k = this.imageData[i + j * this.imageWidth];
>                 if ((k >> 24 & 0xFF) >= 128) continue;
79,82c91,94
<         for (\u2603 = n; \u2603 < n3; ++\u2603) {
<             for (\u2603 = n2; \u2603 < n4; ++\u2603) {
<                 int n5 = \u2603 + \u2603 * this.imageWidth;
<                 this.imageData[n5] = this.imageData[n5] & 0xFFFFFF;
---
>         for (int l = x; l < width; ++l) {
>             for (int i1 = y; i1 < height; ++i1) {
>                 int n = l + i1 * this.imageWidth;
>                 this.imageData[n] = this.imageData[n] & 0xFFFFFF;
87,91c99,103
<     private void setAreaOpaque(int n, int n2, int n3, int n4) {
<         for (\u2603 = n; \u2603 < n3; ++\u2603) {
<             for (\u2603 = n2; \u2603 < n4; ++\u2603) {
<                 int n5 = \u2603 + \u2603 * this.imageWidth;
<                 this.imageData[n5] = this.imageData[n5] | 0xFF000000;
---
>     private void setAreaOpaque(int x, int y, int width, int height) {
>         for (int i = x; i < width; ++i) {
>             for (int j = y; j < height; ++j) {
>                 int n = i + j * this.imageWidth;
>                 this.imageData[n] = this.imageData[n] | 0xFF000000;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ItemRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ItemRenderer.java
4a5
>  *  Config
5a7
>  *  java.lang.Float
33c35
<  *  net.minecraft.entity.player.EntityPlayer
---
>  *  net.minecraft.init.Items
47,51c49,54
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.client.event.RenderBlockOverlayEvent$OverlayType
<  *  net.minecraftforge.event.ForgeEventFactory
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.DynamicLights
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
79c82
< import net.minecraft.entity.player.EntityPlayer;
---
> import net.minecraft.init.Items;
93,97c96,101
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.client.event.RenderBlockOverlayEvent;
< import net.minecraftforge.event.ForgeEventFactory;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.DynamicLights;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
99d102
< @SideOnly(value=Side.CLIENT)
130c133
<             if (flag) {
---
>             if (!(!flag || Config.isShaders() && Shaders.renderItemKeepDepthMask)) {
151a155,157
>         if (Config.isDynamicLights()) {
>             i = DynamicLights.getCombinedLight((Entity)this.mc.getRenderViewEntity(), (int)i);
>         }
202,203c208,209
<     private void renderMapFirstPersonSide(float p_187465_1_, EnumHandSide hand, float p_187465_3_, ItemStack stack) {
<         float f = hand == EnumHandSide.RIGHT ? 1.0f : -1.0f;
---
>     private void renderMapFirstPersonSide(float p_187465_1_, EnumHandSide p_187465_2_, float p_187465_3_, ItemStack p_187465_4_) {
>         float f = p_187465_2_ == EnumHandSide.RIGHT ? 1.0f : -1.0f;
208c214
<             this.renderArmFirstPerson(p_187465_1_, p_187465_3_, hand);
---
>             this.renderArmFirstPerson(p_187465_1_, p_187465_3_, p_187465_2_);
221c227
<         this.renderMapFirstPerson(stack);
---
>         this.renderMapFirstPerson(p_187465_4_);
256c262
<         MapData mapdata = ((ItemMap)stack.getItem()).getMapData(stack, (World)this.mc.world);
---
>         MapData mapdata = ReflectorForge.getMapData((ItemMap)Items.FILLED_MAP, (ItemStack)stack, (World)this.mc.world);
293c299
<     private void transformEatFirstPerson(float p_187454_1_, EnumHandSide hand, ItemStack stack) {
---
>     private void transformEatFirstPerson(float p_187454_1_, EnumHandSide p_187454_2_, ItemStack p_187454_3_) {
295c301
<         float f1 = f / (float)stack.getMaxItemUseDuration();
---
>         float f1 = f / (float)p_187454_3_.getMaxItemUseDuration();
301c307
<         int i = hand == EnumHandSide.RIGHT ? 1 : -1;
---
>         int i = p_187454_2_ == EnumHandSide.RIGHT ? 1 : -1;
308,309c314,315
<     private void transformFirstPerson(EnumHandSide hand, float p_187453_2_) {
<         int i = hand == EnumHandSide.RIGHT ? 1 : -1;
---
>     private void transformFirstPerson(EnumHandSide p_187453_1_, float p_187453_2_) {
>         int i = p_187453_1_ == EnumHandSide.RIGHT ? 1 : -1;
318,319c324,325
<     private void transformSideFirstPerson(EnumHandSide hand, float p_187459_2_) {
<         int i = hand == EnumHandSide.RIGHT ? 1 : -1;
---
>     private void transformSideFirstPerson(EnumHandSide p_187459_1_, float p_187459_2_) {
>         int i = p_187459_1_ == EnumHandSide.RIGHT ? 1 : -1;
324,327d329
<         float f6;
<         float f4;
<         float f5;
<         float f3;
345,346c347,352
<         if (flag && !ForgeHooksClient.renderSpecificFirstPersonHand((EnumHand)EnumHand.MAIN_HAND, (float)partialTicks, (float)f1, (float)(f3 = enumhand == EnumHand.MAIN_HAND ? f : 0.0f), (float)(f5 = 1.0f - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks)), (ItemStack)this.itemStackMainHand)) {
<             this.renderItemInFirstPerson((AbstractClientPlayer)abstractclientplayer, partialTicks, f1, EnumHand.MAIN_HAND, f3, this.itemStackMainHand, f5);
---
>         if (flag) {
>             float f3 = enumhand == EnumHand.MAIN_HAND ? f : 0.0f;
>             float f5 = 1.0f - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
>             if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists() || !Reflector.callBoolean((ReflectorMethod)Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, (Object[])new Object[]{EnumHand.MAIN_HAND, Float.valueOf((float)partialTicks), Float.valueOf((float)f1), Float.valueOf((float)f3), Float.valueOf((float)f5), this.itemStackMainHand})) {
>                 this.renderItemInFirstPerson((AbstractClientPlayer)abstractclientplayer, partialTicks, f1, EnumHand.MAIN_HAND, f3, this.itemStackMainHand, f5);
>             }
348,349c354,359
<         if (flag1 && !ForgeHooksClient.renderSpecificFirstPersonHand((EnumHand)EnumHand.OFF_HAND, (float)partialTicks, (float)f1, (float)(f4 = enumhand == EnumHand.OFF_HAND ? f : 0.0f), (float)(f6 = 1.0f - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks)), (ItemStack)this.itemStackOffHand)) {
<             this.renderItemInFirstPerson((AbstractClientPlayer)abstractclientplayer, partialTicks, f1, EnumHand.OFF_HAND, f4, this.itemStackOffHand, f6);
---
>         if (flag1) {
>             float f4 = enumhand == EnumHand.OFF_HAND ? f : 0.0f;
>             float f6 = 1.0f - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
>             if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists() || !Reflector.callBoolean((ReflectorMethod)Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, (Object[])new Object[]{EnumHand.OFF_HAND, Float.valueOf((float)partialTicks), Float.valueOf((float)f1), Float.valueOf((float)f4), Float.valueOf((float)f6), this.itemStackOffHand})) {
>                 this.renderItemInFirstPerson((AbstractClientPlayer)abstractclientplayer, partialTicks, f1, EnumHand.OFF_HAND, f4, this.itemStackOffHand, f6);
>             }
355,357c365,370
<     public void renderItemInFirstPerson(AbstractClientPlayer player, float p_187457_2_, float p_187457_3_, EnumHand hand, float p_187457_5_, ItemStack stack, float p_187457_7_) {
<         boolean flag = hand == EnumHand.MAIN_HAND;
<         EnumHandSide enumhandside = flag ? player.getPrimaryHand() : player.getPrimaryHand().opposite();
---
>     public void renderItemInFirstPerson(AbstractClientPlayer p_187457_1_, float p_187457_2_, float p_187457_3_, EnumHand p_187457_4_, float p_187457_5_, ItemStack p_187457_6_, float p_187457_7_) {
>         if (Config.isShaders() && Shaders.isSkipRenderHand((EnumHand)p_187457_4_)) {
>             return;
>         }
>         boolean flag = p_187457_4_ == EnumHand.MAIN_HAND;
>         EnumHandSide enumhandside = flag ? p_187457_1_.getPrimaryHand() : p_187457_1_.getPrimaryHand().opposite();
359,360c372,373
<         if (stack.isEmpty()) {
<             if (flag && !player.aX()) {
---
>         if (p_187457_6_.isEmpty()) {
>             if (flag && !p_187457_1_.aX()) {
363c376
<         } else if (stack.getItem() instanceof ItemMap) {
---
>         } else if (p_187457_6_.getItem() instanceof ItemMap) {
367c380
<                 this.renderMapFirstPersonSide(p_187457_7_, enumhandside, p_187457_5_, stack);
---
>                 this.renderMapFirstPersonSide(p_187457_7_, enumhandside, p_187457_5_, p_187457_6_);
372c385
<             if (player.cG() && player.cK() > 0 && player.cH() == hand) {
---
>             if (p_187457_1_.cG() && p_187457_1_.cK() > 0 && p_187457_1_.cH() == p_187457_4_) {
374c387
<                 switch (1.$SwitchMap$net$minecraft$item$EnumAction[stack.getItemUseAction().ordinal()]) {
---
>                 switch (1.$SwitchMap$net$minecraft$item$EnumAction[p_187457_6_.getItemUseAction().ordinal()]) {
381c394
<                         this.transformEatFirstPerson(p_187457_2_, enumhandside, stack);
---
>                         this.transformEatFirstPerson(p_187457_2_, enumhandside, p_187457_6_);
395c408
<                         float f5 = (float)stack.getMaxItemUseDuration() - ((float)this.mc.player.cK() - p_187457_2_ + 1.0f);
---
>                         float f5 = (float)p_187457_6_.getMaxItemUseDuration() - ((float)this.mc.player.cK() - p_187457_2_ + 1.0f);
421c434
<             this.renderItemSide((EntityLivingBase)player, stack, flag1 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag1);
---
>             this.renderItemSide((EntityLivingBase)p_187457_1_, p_187457_6_, flag1 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !flag1);
442,443c455,459
<             if (iblockstate.i() != EnumBlockRenderType.INVISIBLE && !ForgeEventFactory.renderBlockOverlay((EntityPlayer)this.mc.player, (float)partialTicks, (RenderBlockOverlayEvent.OverlayType)RenderBlockOverlayEvent.OverlayType.BLOCK, (IBlockState)iblockstate, (BlockPos)overlayPos)) {
<                 this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
---
>             if (iblockstate.i() != EnumBlockRenderType.INVISIBLE) {
>                 Object overlayType = Reflector.getFieldValue((ReflectorField)Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
>                 if (!Reflector.callBoolean((ReflectorMethod)Reflector.ForgeEventFactory_renderBlockOverlay, (Object[])new Object[]{this.mc.player, Float.valueOf((float)partialTicks), overlayType, iblockstate, overlayPos})) {
>                     this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
>                 }
447c463
<             if (this.mc.player.a(Material.WATER) && !ForgeEventFactory.renderWaterOverlay((EntityPlayer)this.mc.player, (float)partialTicks)) {
---
>             if (this.mc.player.a(Material.WATER) && !Reflector.callBoolean((ReflectorMethod)Reflector.ForgeEventFactory_renderWaterOverlay, (Object[])new Object[]{this.mc.player, Float.valueOf((float)partialTicks)})) {
450c466
<             if (this.mc.player.aR() && !ForgeEventFactory.renderFireOverlay((EntityPlayer)this.mc.player, (float)partialTicks)) {
---
>             if (this.mc.player.aR() && !Reflector.callBoolean((ReflectorMethod)Reflector.ForgeEventFactory_renderFireOverlay, (Object[])new Object[]{this.mc.player, Float.valueOf((float)partialTicks)})) {
483a500,502
>         if (Config.isShaders() && !Shaders.isUnderwaterOverlay()) {
>             return;
>         }
535a555
>             bufferbuilder.setSprite(textureatlassprite);
560,566c580,593
<             boolean requipM = ForgeHooksClient.shouldCauseReequipAnimation((ItemStack)this.itemStackMainHand, (ItemStack)itemstack, (int)entityplayersp.bv.currentItem);
<             boolean requipO = ForgeHooksClient.shouldCauseReequipAnimation((ItemStack)this.itemStackOffHand, (ItemStack)itemstack1, (int)-1);
<             if (!requipM && !Objects.equals((Object)this.itemStackMainHand, (Object)itemstack)) {
<                 this.itemStackMainHand = itemstack;
<             }
<             if (!requipM && !Objects.equals((Object)this.itemStackOffHand, (Object)itemstack1)) {
<                 this.itemStackOffHand = itemstack1;
---
>             if (Reflector.ForgeHooksClient_shouldCauseReequipAnimation.exists()) {
>                 boolean requipM = Reflector.callBoolean((ReflectorMethod)Reflector.ForgeHooksClient_shouldCauseReequipAnimation, (Object[])new Object[]{this.itemStackMainHand, itemstack, entityplayersp.bv.currentItem});
>                 boolean requipO = Reflector.callBoolean((ReflectorMethod)Reflector.ForgeHooksClient_shouldCauseReequipAnimation, (Object[])new Object[]{this.itemStackOffHand, itemstack1, -1});
>                 if (!requipM && !Objects.equals((Object)this.itemStackMainHand, (Object)itemstack)) {
>                     this.itemStackMainHand = itemstack;
>                 }
>                 if (!requipM && !Objects.equals((Object)this.itemStackOffHand, (Object)itemstack1)) {
>                     this.itemStackOffHand = itemstack1;
>                 }
>                 this.equippedProgressMainHand += MathHelper.clamp((float)((!requipM ? f * f * f : 0.0f) - this.equippedProgressMainHand), (float)-0.4f, (float)0.4f);
>                 this.equippedProgressOffHand += MathHelper.clamp((float)((float)(!requipO ? 1 : 0) - this.equippedProgressOffHand), (float)-0.4f, (float)0.4f);
>             } else {
>                 this.equippedProgressMainHand += MathHelper.clamp((float)((Objects.equals((Object)this.itemStackMainHand, (Object)itemstack) ? f * f * f : 0.0f) - this.equippedProgressMainHand), (float)-0.4f, (float)0.4f);
>                 this.equippedProgressOffHand += MathHelper.clamp((float)((float)(Objects.equals((Object)this.itemStackOffHand, (Object)itemstack1) ? 1 : 0) - this.equippedProgressOffHand), (float)-0.4f, (float)0.4f);
568,569d594
<             this.equippedProgressMainHand += MathHelper.clamp((float)((!requipM ? f * f * f : 0.0f) - this.equippedProgressMainHand), (float)-0.4f, (float)0.4f);
<             this.equippedProgressOffHand += MathHelper.clamp((float)((float)(!requipO ? 1 : 0) - this.equippedProgressOffHand), (float)-0.4f, (float)0.4f);
572a598,600
>             if (Config.isShaders()) {
>                 Shaders.setItemToRenderMain((ItemStack)this.itemStackMainHand);
>             }
575a604,606
>             if (Config.isShaders()) {
>                 Shaders.setItemToRenderOff((ItemStack)this.itemStackOffHand);
>             }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/Matrix4f.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/Matrix4f.java
12,28c12,28
<     public Matrix4f(float[] fArray) {
<         this.m00 = fArray[0];
<         this.m01 = fArray[1];
<         this.m02 = fArray[2];
<         this.m03 = fArray[3];
<         this.m10 = fArray[4];
<         this.m11 = fArray[5];
<         this.m12 = fArray[6];
<         this.m13 = fArray[7];
<         this.m20 = fArray[8];
<         this.m21 = fArray[9];
<         this.m22 = fArray[10];
<         this.m23 = fArray[11];
<         this.m30 = fArray[12];
<         this.m31 = fArray[13];
<         this.m32 = fArray[14];
<         this.m33 = fArray[15];
---
>     public Matrix4f(float[] matrix) {
>         this.m00 = matrix[0];
>         this.m01 = matrix[1];
>         this.m02 = matrix[2];
>         this.m03 = matrix[3];
>         this.m10 = matrix[4];
>         this.m11 = matrix[5];
>         this.m12 = matrix[6];
>         this.m13 = matrix[7];
>         this.m20 = matrix[8];
>         this.m21 = matrix[9];
>         this.m22 = matrix[10];
>         this.m23 = matrix[11];
>         this.m30 = matrix[12];
>         this.m31 = matrix[13];
>         this.m32 = matrix[14];
>         this.m33 = matrix[15];
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/OpenGlHelper$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/OpenGlHelper$1.java
17c17
<     static final /* synthetic */ int[] field_188784_a;
---
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode;
20c20
<         field_188784_a = new int[OpenGlHelper.FboMode.values().length];
---
>         $SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode = new int[OpenGlHelper.FboMode.values().length];
22c22
<             OpenGlHelper.1.field_188784_a[OpenGlHelper.FboMode.BASE.ordinal()] = 1;
---
>             OpenGlHelper.1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[OpenGlHelper.FboMode.BASE.ordinal()] = 1;
28c28
<             OpenGlHelper.1.field_188784_a[OpenGlHelper.FboMode.ARB.ordinal()] = 2;
---
>             OpenGlHelper.1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[OpenGlHelper.FboMode.ARB.ordinal()] = 2;
34c34
<             OpenGlHelper.1.field_188784_a[OpenGlHelper.FboMode.EXT.ordinal()] = 3;
---
>             OpenGlHelper.1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[OpenGlHelper.FboMode.EXT.ordinal()] = 3;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/OpenGlHelper$FboMode.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/OpenGlHelper$FboMode.java
6,7d5
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
11,14d8
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
< 
< @SideOnly(value=Side.CLIENT)
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/OpenGlHelper.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/OpenGlHelper.java
4a5
>  *  Config
16a18,19
>  *  java.util.ArrayList
>  *  java.util.List
20a24
>  *  net.minecraft.client.renderer.OpenGlHelper$1
27,28d30
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
31a34
>  *  org.lwjgl.opengl.ARBCopyBuffer
45a49
>  *  org.lwjgl.opengl.GL31
48c52
<  *  oshi.hardware.CentralProcessor
---
>  *  oshi.hardware.Processor
57a62,63
> import java.util.ArrayList;
> import java.util.List;
67,68d72
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
71a76
> import org.lwjgl.opengl.ARBCopyBuffer;
85a91
> import org.lwjgl.opengl.GL31;
88c94
< import oshi.hardware.CentralProcessor;
---
> import oshi.hardware.Processor;
90d95
< @SideOnly(value=Side.CLIENT)
148a154,159
>     public static boolean openGL31;
>     public static boolean vboRegions;
>     public static int GL_COPY_READ_BUFFER;
>     public static int GL_COPY_WRITE_BUFFER;
>     public static final int GL_QUADS = 7;
>     public static final int GL_TRIANGLES = 4;
150a162
>         Config.initDisplay();
153c165,188
<         boolean bl = arbTextureEnvCombine = contextcapabilities.GL_ARB_texture_env_combine && !contextcapabilities.OpenGL13;
---
>         arbTextureEnvCombine = contextcapabilities.GL_ARB_texture_env_combine && !contextcapabilities.OpenGL13;
>         openGL31 = contextcapabilities.OpenGL31;
>         if (openGL31) {
>             GL_COPY_READ_BUFFER = 36662;
>             GL_COPY_WRITE_BUFFER = 36663;
>         } else {
>             GL_COPY_READ_BUFFER = 36662;
>             GL_COPY_WRITE_BUFFER = 36663;
>         }
>         boolean copyBuffer = openGL31 || contextcapabilities.GL_ARB_copy_buffer;
>         boolean multiDrawArrays = contextcapabilities.OpenGL14;
>         boolean bl = vboRegions = copyBuffer && multiDrawArrays;
>         if (!vboRegions) {
>             ArrayList list = new ArrayList();
>             if (!copyBuffer) {
>                 list.add((Object)"OpenGL 1.3, ARB_copy_buffer");
>             }
>             if (!multiDrawArrays) {
>                 list.add((Object)"OpenGL 1.4");
>             }
>             String vboRegionWarn = "VboRegions not supported, missing: " + Config.listToString((List)list);
>             Config.dbg((String)vboRegionWarn);
>             logText = logText + vboRegionWarn + "\n";
>         }
308,309c343,344
<             CentralProcessor aprocessor = new SystemInfo().getHardware().getProcessor();
<             cpu = String.format((String)"%dx %s", (Object[])new Object[]{aprocessor.getLogicalProcessorCount(), aprocessor.getProcessorIdentifier().getName()}).replaceAll("\\s+", " ");
---
>             Processor[] aprocessor = new SystemInfo().getHardware().getProcessors();
>             cpu = String.format((String)"%dx %s", (Object[])new Object[]{aprocessor.length, aprocessor[0]}).replaceAll("\\s+", " ");
536a572,577
>         if (Config.isMultiTexture()) {
>             return false;
>         }
>         if (Config.isRenderRegions() && !vboRegions) {
>             return false;
>         }
542,543c583,584
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
547c588
<                 case 1: {
---
>                 case 2: {
551c592
<                 case 2: {
---
>                 case 3: {
560,561c601,602
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
565c606
<                 case 1: {
---
>                 case 2: {
569c610
<                 case 2: {
---
>                 case 3: {
578,579c619,620
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
583c624
<                 case 1: {
---
>                 case 2: {
587c628
<                 case 2: {
---
>                 case 3: {
596,597c637,638
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
601c642
<                 case 1: {
---
>                 case 2: {
605c646
<                 case 2: {
---
>                 case 3: {
616,617c657,658
<         switch (framebufferType.ordinal()) {
<             case 0: {
---
>         switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>             case 1: {
620c661
<             case 1: {
---
>             case 2: {
623c664
<             case 2: {
---
>             case 3: {
634,635c675,676
<         switch (framebufferType.ordinal()) {
<             case 0: {
---
>         switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>             case 1: {
638c679
<             case 1: {
---
>             case 2: {
641c682
<             case 2: {
---
>             case 3: {
650,651c691,692
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
655c696
<                 case 1: {
---
>                 case 2: {
659c700
<                 case 2: {
---
>                 case 3: {
668,669c709,710
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
673c714
<                 case 1: {
---
>                 case 2: {
677c718
<                 case 2: {
---
>                 case 3: {
688,689c729,730
<         switch (framebufferType.ordinal()) {
<             case 0: {
---
>         switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>             case 1: {
692c733
<             case 1: {
---
>             case 2: {
695c736
<             case 2: {
---
>             case 3: {
704,705c745,746
<             switch (framebufferType.ordinal()) {
<                 case 0: {
---
>             switch (1.$SwitchMap$net$minecraft$client$renderer$OpenGlHelper$FboMode[framebufferType.ordinal()]) {
>                 case 1: {
709c750
<                 case 1: {
---
>                 case 2: {
713c754
<                 case 2: {
---
>                 case 3: {
736c777
<     public static void setLightmapTextureCoords(int target, float x, float y) {
---
>     public static void setLightmapTextureCoords(int target, float p_77475_1_, float t) {
738c779
<             ARBMultitexture.glMultiTexCoord2fARB((int)target, (float)x, (float)y);
---
>             ARBMultitexture.glMultiTexCoord2fARB((int)target, (float)p_77475_1_, (float)t);
740c781
<             GL13.glMultiTexCoord2f((int)target, (float)x, (float)y);
---
>             GL13.glMultiTexCoord2f((int)target, (float)p_77475_1_, (float)t);
743,744c784,785
<             lastBrightnessX = x;
<             lastBrightnessY = y;
---
>             lastBrightnessX = p_77475_1_;
>             lastBrightnessY = t;
760a802,807
>         if (Config.isFastRender()) {
>             return false;
>         }
>         if (Config.isAntialiasing()) {
>             return false;
>         }
761a809,832
>     }
> 
>     public static void glBufferData(int target, long size, int usage) {
>         if (arbVbo) {
>             ARBVertexBufferObject.glBufferDataARB((int)target, (long)size, (int)usage);
>         } else {
>             GL15.glBufferData((int)target, (long)size, (int)usage);
>         }
>     }
> 
>     public static void glBufferSubData(int target, long offset, ByteBuffer data) {
>         if (arbVbo) {
>             ARBVertexBufferObject.glBufferSubDataARB((int)target, (long)offset, (ByteBuffer)data);
>         } else {
>             GL15.glBufferSubData((int)target, (long)offset, (ByteBuffer)data);
>         }
>     }
> 
>     public static void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size) {
>         if (openGL31) {
>             GL31.glCopyBufferSubData((int)readTarget, (int)writeTarget, (long)readOffset, (long)writeOffset, (long)size);
>         } else {
>             ARBCopyBuffer.glCopyBufferSubData((int)readTarget, (int)writeTarget, (long)readOffset, (long)writeOffset, (long)size);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderGlobal$ContainerLocalRenderInformation.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderGlobal$ContainerLocalRenderInformation.java
6,7d5
<  *  javax.annotation.Nullable
<  *  net.minecraft.client.renderer.RenderGlobal
10,11d7
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
15,16d10
< import javax.annotation.Nullable;
< import net.minecraft.client.renderer.RenderGlobal;
19,20d12
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
22,23c14
< @SideOnly(value=Side.CLIENT)
< class RenderGlobal.ContainerLocalRenderInformation {
---
> public static class RenderGlobal.ContainerLocalRenderInformation {
25,27c16,17
<     final EnumFacing facing;
<     byte setFacing;
<     final int counter;
---
>     EnumFacing facing;
>     int setFacing;
29c19
<     private RenderGlobal.ContainerLocalRenderInformation(RenderGlobal this$0, @Nullable RenderChunk renderChunkIn, EnumFacing facingIn, int counterIn) {
---
>     public RenderGlobal.ContainerLocalRenderInformation(RenderChunk renderChunkIn, EnumFacing facingIn, int setFacingIn) {
32c22
<         this.counter = counterIn;
---
>         this.setFacing = setFacingIn;
36c26
<         this.setFacing = (byte)(this.setFacing | p_189561_1_ | 1 << p_189561_2_.ordinal());
---
>         this.setFacing = this.setFacing | p_189561_1_ | 1 << p_189561_2_.ordinal();
40a31,39
>     }
> 
>     private void initialize(EnumFacing facingIn, int setFacingIn) {
>         this.facing = facingIn;
>         this.setFacing = setFacingIn;
>     }
> 
>     static /* synthetic */ void access$000(RenderGlobal.ContainerLocalRenderInformation x0, EnumFacing x1, int x2) {
>         x0.initialize(x1, x2);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderGlobal.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderGlobal.java
4a5
>  *  Config
7d7
<  *  com.google.common.collect.Queues
9a10,11
>  *  it.unimi.dsi.fastutil.longs.Long2ObjectMap
>  *  it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet
10a13
>  *  java.lang.Boolean
11a15
>  *  java.lang.Float
16d19
<  *  java.lang.System
19a23
>  *  java.util.Arrays
20a25,27
>  *  java.util.Collections
>  *  java.util.Deque
>  *  java.util.HashSet
21a29
>  *  java.util.LinkedHashSet
37a46,47
>  *  net.minecraft.client.gui.GuiScreen
>  *  net.minecraft.client.multiplayer.ChunkProviderClient
39a50
>  *  net.minecraft.client.renderer.BlockModelRenderer
68a80
>  *  net.minecraft.client.renderer.entity.RenderItemFrame
73a86
>  *  net.minecraft.client.renderer.tileentity.TileEntitySignRenderer
115c128
<  *  net.minecraft.util.math.Vec3i
---
>  *  net.minecraft.world.DimensionType
118a132
>  *  net.minecraft.world.WorldProvider
121,126c135,154
<  *  net.minecraftforge.client.IRenderHandler
<  *  net.minecraftforge.client.MinecraftForgeClient
<  *  net.minecraftforge.common.ForgeModContainer
<  *  net.minecraftforge.fml.client.FMLClientHandler
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.minecraft.world.chunk.IChunkProvider
>  *  net.optifine.CustomColors
>  *  net.optifine.CustomSky
>  *  net.optifine.DynamicLights
>  *  net.optifine.Lagometer
>  *  net.optifine.RandomEntities
>  *  net.optifine.SmartAnimations
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.render.ChunkVisibility
>  *  net.optifine.render.CloudRenderer
>  *  net.optifine.render.RenderEnv
>  *  net.optifine.shaders.Program
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.shaders.ShadersRender
>  *  net.optifine.shaders.ShadowUtils
>  *  net.optifine.shaders.gui.GuiShaderOptions
>  *  net.optifine.util.ChunkUtils
>  *  net.optifine.util.RenderChunkUtils
128a157
>  *  org.lwjgl.input.Keyboard
137d165
< import com.google.common.collect.Queues;
139a168,169
> import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
> import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
142a173
> import java.util.Arrays;
143a175,177
> import java.util.Collections;
> import java.util.Deque;
> import java.util.HashSet;
144a179
> import java.util.LinkedHashSet;
160a196,197
> import net.minecraft.client.gui.GuiScreen;
> import net.minecraft.client.multiplayer.ChunkProviderClient;
162a200
> import net.minecraft.client.renderer.BlockModelRenderer;
188a227
> import net.minecraft.client.renderer.entity.RenderItemFrame;
193a233
> import net.minecraft.client.renderer.tileentity.TileEntitySignRenderer;
230c270
< import net.minecraft.util.math.Vec3i;
---
> import net.minecraft.world.DimensionType;
233a274
> import net.minecraft.world.WorldProvider;
236,241c277,296
< import net.minecraftforge.client.IRenderHandler;
< import net.minecraftforge.client.MinecraftForgeClient;
< import net.minecraftforge.common.ForgeModContainer;
< import net.minecraftforge.fml.client.FMLClientHandler;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.minecraft.world.chunk.IChunkProvider;
> import net.optifine.CustomColors;
> import net.optifine.CustomSky;
> import net.optifine.DynamicLights;
> import net.optifine.Lagometer;
> import net.optifine.RandomEntities;
> import net.optifine.SmartAnimations;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.render.ChunkVisibility;
> import net.optifine.render.CloudRenderer;
> import net.optifine.render.RenderEnv;
> import net.optifine.shaders.Program;
> import net.optifine.shaders.Shaders;
> import net.optifine.shaders.ShadersRender;
> import net.optifine.shaders.ShadowUtils;
> import net.optifine.shaders.gui.GuiShaderOptions;
> import net.optifine.util.ChunkUtils;
> import net.optifine.util.RenderChunkUtils;
243a299
> import org.lwjgl.input.Keyboard;
247c303,305
< @SideOnly(value=Side.CLIENT)
---
> /*
>  * Exception performing whole class analysis ignored.
>  */
257c315
<     private final Minecraft mc;
---
>     public final Minecraft mc;
261c319
<     private Set<RenderChunk> chunksToUpdate = Sets.newLinkedHashSet();
---
>     private Set<RenderChunk> chunksToUpdate = new ObjectLinkedOpenHashSet();
273c331
<     private final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
---
>     public final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
305c363
<     private boolean displayListEntitiesDirty = true;
---
>     public boolean displayListEntitiesDirty = true;
307a366,391
>     private CloudRenderer cloudRenderer;
>     public Entity renderedEntity;
>     public Set chunksToResortTransparency = new LinkedHashSet();
>     public Set chunksToUpdateForced = new LinkedHashSet();
>     private Set<RenderChunk> chunksToUpdatePrev = new ObjectLinkedOpenHashSet();
>     private Deque visibilityDeque = new ArrayDeque();
>     private List renderInfosEntities = new ArrayList(1024);
>     private List renderInfosTileEntities = new ArrayList(1024);
>     private List renderInfosNormal = new ArrayList(1024);
>     private List renderInfosEntitiesNormal = new ArrayList(1024);
>     private List renderInfosTileEntitiesNormal = new ArrayList(1024);
>     private List renderInfosShadow = new ArrayList(1024);
>     private List renderInfosEntitiesShadow = new ArrayList(1024);
>     private List renderInfosTileEntitiesShadow = new ArrayList(1024);
>     private int renderDistance = 0;
>     private int renderDistanceSq = 0;
>     private static final Set SET_ALL_FACINGS = Collections.unmodifiableSet((Set)new HashSet((Collection)Arrays.asList((Object[])EnumFacing.VALUES)));
>     private int countTileEntitiesRendered;
>     private IChunkProvider worldChunkProvider = null;
>     private Long2ObjectMap<Chunk> worldChunkProviderMap = null;
>     private int countLoadedChunksPrev = 0;
>     private RenderEnv renderEnv = new RenderEnv(Blocks.AIR.getDefaultState(), new BlockPos(0, 0, 0));
>     public boolean renderOverlayDamaged = false;
>     public boolean renderOverlayEyes = false;
>     private boolean firstWorldLoad = false;
>     private static int renderEntitiesCounter = 0;
309a394
>         this.cloudRenderer = new CloudRenderer(mcIn);
380a466,468
>         if (Config.isFastRender() || Config.isShaders() || Config.isAntialiasing()) {
>             return false;
>         }
434c522
<     private void renderSky(BufferBuilder bufferBuilderIn, float posY, boolean reverseX) {
---
>     private void renderSky(BufferBuilder worldRendererIn, float posY, boolean reverseX) {
437,439c525,528
<         bufferBuilderIn.begin(7, DefaultVertexFormats.POSITION);
<         for (int k = -384; k <= 384; k += 64) {
<             for (int l = -384; l <= 384; l += 64) {
---
>         worldRendererIn.begin(7, DefaultVertexFormats.POSITION);
>         int skyDist = (this.renderDistance / 64 + 1) * 64 + 64;
>         for (int k = -skyDist; k <= skyDist; k += 64) {
>             for (int l = -skyDist; l <= skyDist; l += 64) {
446,449c535,538
<                 bufferBuilderIn.pos((double)f, (double)posY, (double)l).endVertex();
<                 bufferBuilderIn.pos((double)f1, (double)posY, (double)l).endVertex();
<                 bufferBuilderIn.pos((double)f1, (double)posY, (double)(l + 64)).endVertex();
<                 bufferBuilderIn.pos((double)f, (double)posY, (double)(l + 64)).endVertex();
---
>                 worldRendererIn.pos((double)f, (double)posY, (double)l).endVertex();
>                 worldRendererIn.pos((double)f1, (double)posY, (double)l).endVertex();
>                 worldRendererIn.pos((double)f1, (double)posY, (double)(l + 64)).endVertex();
>                 worldRendererIn.pos((double)f, (double)posY, (double)(l + 64)).endVertex();
481c570
<     private void renderStars(BufferBuilder bufferBuilderIn) {
---
>     private void renderStars(BufferBuilder worldRendererIn) {
483c572
<         bufferBuilderIn.begin(7, DefaultVertexFormats.POSITION);
---
>         worldRendererIn.begin(7, DefaultVertexFormats.POSITION);
515c604
<                 bufferBuilderIn.pos(d5 + d25, d6 + d23, d7 + d26).endVertex();
---
>                 worldRendererIn.pos(d5 + d25, d6 + d23, d7 + d26).endVertex();
531a621,628
>         if (Config.isDynamicLights()) {
>             DynamicLights.clear();
>         }
>         ChunkVisibility.reset();
>         this.worldChunkProvider = null;
>         this.worldChunkProviderMap = null;
>         this.renderEnv.reset(null, null);
>         Shaders.checkWorldChanged((World)this.world);
537c634,635
<             this.renderInfos.clear();
---
>             this.chunksToUpdatePrev.clear();
>             this.clearRenderInfos();
559,560c657,663
<             Blocks.LEAVES.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
<             Blocks.LEAVES2.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
---
>             Blocks.LEAVES.setGraphicsLevel(Config.isTreesFancy());
>             Blocks.LEAVES2.setGraphicsLevel(Config.isTreesFancy());
>             BlockModelRenderer.updateAoLightValue();
>             if (Config.isDynamicLights()) {
>                 DynamicLights.clear();
>             }
>             SmartAnimations.update();
561a665,666
>             this.renderDistance = this.renderDistanceChunks * 16;
>             this.renderDistanceSq = this.renderDistance * this.renderDistance;
571,575c676,678
<             if (flag != this.vboEnabled) {
<                 this.generateStars();
<                 this.generateSky();
<                 this.generateSky2();
<             }
---
>             this.generateStars();
>             this.generateSky();
>             this.generateSky2();
589a693,695
>         if (this.mc.player == null) {
>             this.firstWorldLoad = true;
>         }
607c713,716
<         int pass = MinecraftForgeClient.getRenderPass();
---
>         int pass = 0;
>         if (Reflector.MinecraftForgeClient_getRenderPass.exists()) {
>             pass = Reflector.callInt((ReflectorMethod)Reflector.MinecraftForgeClient_getRenderPass, (Object[])new Object[0]);
>         }
613a723
>             Entity entityOutline;
619a730
>             ++renderEntitiesCounter;
623a735
>                 this.countTileEntitiesRendered = 0;
638a751,755
>             if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
>                 GlStateManager.disableFog();
>             }
>             boolean forgeEntityPass = Reflector.ForgeEntity_shouldRenderInPass.exists();
>             boolean forgeTileEntityPass = Reflector.ForgeTileEntity_shouldRenderInPass.exists();
641c758
<                 if (!entity1.shouldRenderInPass(pass)) continue;
---
>                 if (forgeEntityPass && !Reflector.callBoolean((Object)entity1, (ReflectorMethod)Reflector.ForgeEntity_shouldRenderInPass, (Object[])new Object[]{pass})) continue;
646a764,768
>             boolean isShaders = Config.isShaders();
>             if (isShaders) {
>                 Shaders.beginEntities();
>             }
>             RenderItemFrame.updateItemRenderDistance();
650,651c772,774
<             for (ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation : this.renderInfos) {
<                 Chunk chunk = this.world.getChunk(renderglobal$containerlocalrenderinformation.renderChunk.getPosition());
---
>             boolean playerShadowPass = Shaders.isShadowPass && !this.mc.player.y();
>             for (ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation : this.renderInfosEntities) {
>                 Chunk chunk = renderglobal$containerlocalrenderinformation.renderChunk.getChunk();
657c780
<                     if (!entity2.shouldRenderInPass(pass) || !(flag = this.renderManager.shouldRender(entity2, camera, d0, d1, d2) || entity2.isRidingOrBeingRiddenBy((Entity)this.mc.player))) continue;
---
>                     if (forgeEntityPass && !Reflector.callBoolean((Object)entity2, (ReflectorMethod)Reflector.ForgeEntity_shouldRenderInPass, (Object[])new Object[]{pass}) || !(flag = this.renderManager.shouldRender(entity2, camera, d0, d1, d2) || entity2.isRidingOrBeingRiddenBy((Entity)this.mc.player))) continue;
659c782
<                     if (entity2 == this.mc.getRenderViewEntity() && this.mc.gameSettings.thirdPersonView == 0 && !flag1 || !(entity2.posY < 0.0) && !(entity2.posY >= 256.0) && !this.world.isBlockLoaded((BlockPos)blockpos$pooledmutableblockpos.setPos(entity2))) continue;
---
>                     if (entity2 == this.mc.getRenderViewEntity() && !playerShadowPass && this.mc.gameSettings.thirdPersonView == 0 && !flag1 || !(entity2.posY < 0.0) && !(entity2.posY >= 256.0) && !this.world.isBlockLoaded((BlockPos)blockpos$pooledmutableblockpos.setPos(entity2))) continue;
660a784,787
>                     this.renderedEntity = entity2;
>                     if (isShaders) {
>                         Shaders.nextEntity((Entity)entity2);
>                     }
661a789
>                     this.renderedEntity = null;
671a800,803
>                     if (forgeEntityPass && !Reflector.callBoolean((Object)entity3, (ReflectorMethod)Reflector.ForgeEntity_shouldRenderInPass, (Object[])new Object[]{pass})) continue;
>                     if (isShaders) {
>                         Shaders.nextEntity((Entity)entity3);
>                     }
686c818,823
<                         this.renderManager.renderEntityStatic((Entity)list1.get(j), partialTicks, false);
---
>                         entityOutline = (Entity)list1.get(j);
>                         if (forgeEntityPass && !Reflector.callBoolean((Object)entityOutline, (ReflectorMethod)Reflector.ForgeEntity_shouldRenderInPass, (Object[])new Object[]{pass})) continue;
>                         if (isShaders) {
>                             Shaders.nextEntity((Entity)entityOutline);
>                         }
>                         this.renderManager.renderEntityStatic(entityOutline, partialTicks, false);
702a840,873
>             if (!(this.isRenderEntityOutlines() || list1.isEmpty() && !this.entityOutlinesRendered)) {
>                 this.world.profiler.endStartSection("entityOutlines");
>                 boolean bl = this.entityOutlinesRendered = !list1.isEmpty();
>                 if (!list1.isEmpty()) {
>                     if (isShaders) {
>                         Shaders.beginEntitiesGlowing();
>                     }
>                     GlStateManager.disableFog();
>                     GlStateManager.disableDepth();
>                     this.mc.entityRenderer.disableLightmap();
>                     RenderHelper.disableStandardItemLighting();
>                     this.renderManager.setRenderOutlines(true);
>                     for (int j = 0; j < list1.size(); ++j) {
>                         entityOutline = (Entity)list1.get(j);
>                         if (forgeEntityPass && !Reflector.callBoolean((Object)entityOutline, (ReflectorMethod)Reflector.ForgeEntity_shouldRenderInPass, (Object[])new Object[]{pass})) continue;
>                         if (isShaders) {
>                             Shaders.nextEntity((Entity)entityOutline);
>                         }
>                         this.renderManager.renderEntityStatic(entityOutline, partialTicks, false);
>                     }
>                     this.renderManager.setRenderOutlines(false);
>                     RenderHelper.enableStandardItemLighting();
>                     this.mc.entityRenderer.enableLightmap();
>                     GlStateManager.enableDepth();
>                     GlStateManager.enableFog();
>                     if (isShaders) {
>                         Shaders.endEntitiesGlowing();
>                     }
>                 }
>             }
>             if (isShaders) {
>                 Shaders.endEntities();
>                 Shaders.beginBlockEntities();
>             }
705,706c876,880
<             TileEntityRendererDispatcher.instance.preDrawBatch();
<             for (ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation1 : this.renderInfos) {
---
>             if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
>                 TileEntityRendererDispatcher.instance.preDrawBatch();
>             }
>             TileEntitySignRenderer.updateTextRenderDistance();
>             for (ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation1 : this.renderInfosTileEntities) {
710c884,888
<                     if (!tileentity2.shouldRenderInPass(pass) || !camera.isBoundingBoxInFrustum(tileentity2.getRenderBoundingBox())) continue;
---
>                     AxisAlignedBB aabb;
>                     if (forgeTileEntityPass && (!Reflector.callBoolean((Object)tileentity2, (ReflectorMethod)Reflector.ForgeTileEntity_shouldRenderInPass, (Object[])new Object[]{pass}) || (aabb = (AxisAlignedBB)Reflector.call((Object)tileentity2, (ReflectorMethod)Reflector.ForgeTileEntity_getRenderBoundingBox, (Object[])new Object[0])) != null && !camera.isBoundingBoxInFrustum(aabb))) continue;
>                     if (isShaders) {
>                         Shaders.nextBlockEntity((TileEntity)tileentity2);
>                     }
711a890
>                     ++this.countTileEntitiesRendered;
717c896,899
<                     if (!tileentity.shouldRenderInPass(pass) || !camera.isBoundingBoxInFrustum(tileentity.getRenderBoundingBox())) continue;
---
>                     if (forgeTileEntityPass && !Reflector.callBoolean((Object)tileentity, (ReflectorMethod)Reflector.ForgeTileEntity_shouldRenderInPass, (Object[])new Object[]{pass})) continue;
>                     if (isShaders) {
>                         Shaders.nextBlockEntity((TileEntity)tileentity);
>                     }
721c903,906
<             TileEntityRendererDispatcher.instance.drawBatch(pass);
---
>             if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
>                 TileEntityRendererDispatcher.instance.drawBatch(pass);
>             }
>             this.renderOverlayDamaged = true;
738a924,926
>                 if (isShaders) {
>                     Shaders.nextBlockEntity((TileEntity)tileentity1);
>                 }
741a930,934
>             this.renderOverlayDamaged = false;
>             if (isShaders) {
>                 Shaders.endBlockEntities();
>             }
>             --renderEntitiesCounter;
779c972
<         return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden;
---
>         return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden + ", " + Config.getVersionDebug();
798a992,994
>         if (Config.isDynamicLights()) {
>             DynamicLights.update((RenderGlobal)this);
>         }
822c1018,1061
<         if (!flag && this.displayListEntitiesDirty) {
---
>         Lagometer.timerVisibility.start();
>         int countLoadedChunks = this.getCountLoadedChunks();
>         if (countLoadedChunks != this.countLoadedChunksPrev) {
>             this.countLoadedChunksPrev = countLoadedChunks;
>             this.displayListEntitiesDirty = true;
>         }
>         int maxChunkY = 256;
>         if (!ChunkVisibility.isFinished()) {
>             this.displayListEntitiesDirty = true;
>         }
>         if (!flag && this.displayListEntitiesDirty && Config.isIntegratedServerRunning()) {
>             maxChunkY = ChunkVisibility.getMaxChunkY((World)this.world, (Entity)viewEntity, (int)this.renderDistanceChunks);
>         }
>         RenderChunk renderChunkPlayer = this.viewFrustum.getRenderChunk(new BlockPos(viewEntity.posX, viewEntity.posY, viewEntity.posZ));
>         if (Shaders.isShadowPass) {
>             this.renderInfos = this.renderInfosShadow;
>             this.renderInfosEntities = this.renderInfosEntitiesShadow;
>             this.renderInfosTileEntities = this.renderInfosTileEntitiesShadow;
>             if (!flag && this.displayListEntitiesDirty) {
>                 this.clearRenderInfos();
>                 if (renderChunkPlayer != null && renderChunkPlayer.getPosition().q() > maxChunkY) {
>                     this.renderInfosEntities.add((Object)renderChunkPlayer.getRenderInfo());
>                 }
>                 Iterator it = ShadowUtils.makeShadowChunkIterator((WorldClient)this.world, (double)partialTicks, (Entity)viewEntity, (int)this.renderDistanceChunks, (ViewFrustum)this.viewFrustum);
>                 while (it.hasNext()) {
>                     RenderChunk chunk = (RenderChunk)it.next();
>                     if (chunk == null || chunk.getPosition().q() > maxChunkY) continue;
>                     ContainerLocalRenderInformation renderInfo = chunk.getRenderInfo();
>                     if (!chunk.compiledChunk.isEmpty()) {
>                         this.renderInfos.add((Object)renderInfo);
>                     }
>                     if (ChunkUtils.hasEntities((Chunk)chunk.getChunk())) {
>                         this.renderInfosEntities.add((Object)renderInfo);
>                     }
>                     if (chunk.getCompiledChunk().getTileEntities().size() <= 0) continue;
>                     this.renderInfosTileEntities.add((Object)renderInfo);
>                 }
>             }
>         } else {
>             this.renderInfos = this.renderInfosNormal;
>             this.renderInfosEntities = this.renderInfosEntitiesNormal;
>             this.renderInfosTileEntities = this.renderInfosTileEntitiesNormal;
>         }
>         if (!flag && this.displayListEntitiesDirty && !Shaders.isShadowPass) {
824,825c1063,1065
<             this.renderInfos = Lists.newArrayList();
<             ArrayDeque queue = Queues.newArrayDeque();
---
>             this.clearRenderInfos();
>             this.visibilityDeque.clear();
>             Deque queue = this.visibilityDeque;
828c1068
<             if (renderchunk != null) {
---
>             if (renderchunk != null && renderchunk.getPosition().q() <= maxChunkY) {
830,831c1070,1071
<                 ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation3 = new ContainerLocalRenderInformation(this, renderchunk, (EnumFacing)null, 0);
<                 Set<EnumFacing> set1 = this.getVisibleFacings(blockpos1);
---
>                 ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation3 = new ContainerLocalRenderInformation(renderchunk, (EnumFacing)null, 0);
>                 Set set1 = SET_ALL_FACINGS;
850c1090,1094
<                 int i = blockpos1.q() > 0 ? 248 : 8;
---
>                 int i;
>                 int n = i = blockpos1.q() > 0 ? Math.min((int)maxChunkY, (int)248) : 8;
>                 if (renderChunkPlayer != null) {
>                     this.renderInfosEntities.add((Object)renderChunkPlayer.getRenderInfo());
>                 }
854c1098
<                         if (renderchunk1 == null || !camera.isBoundingBoxInFrustum(renderchunk1.boundingBox.expand(0.0, blockpos1.q() > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY, 0.0))) continue;
---
>                         if (renderchunk1 == null || !renderchunk1.isBoundingBoxInFrustum(camera, frameCount)) continue;
856c1100,1102
<                         queue.add((Object)new ContainerLocalRenderInformation(this, renderchunk1, (EnumFacing)null, 0));
---
>                         ContainerLocalRenderInformation info = renderchunk1.getRenderInfo();
>                         ContainerLocalRenderInformation.access$000((ContainerLocalRenderInformation)info, null, (int)0);
>                         queue.add((Object)info);
860a1107
>             boolean fog = Config.isFogOn();
865,870c1112,1127
<                 this.renderInfos.add((Object)renderglobal$containerlocalrenderinformation1);
<                 for (RenderChunk enumfacing1 : EnumFacing.values()) {
<                     RenderChunk renderchunk2 = this.getRenderChunkOffset(blockpos, renderchunk3, (EnumFacing)enumfacing1);
<                     if (flag1 && renderglobal$containerlocalrenderinformation1.hasDirection(enumfacing1.getOpposite()) || flag1 && enumfacing2 != null && !renderchunk3.getCompiledChunk().isVisible(enumfacing2.getOpposite(), (EnumFacing)enumfacing1) || renderchunk2 == null || !renderchunk2.setFrameIndex(frameCount) || !camera.isBoundingBoxInFrustum(renderchunk2.boundingBox)) continue;
<                     ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation = new ContainerLocalRenderInformation(this, renderchunk2, (EnumFacing)enumfacing1, renderglobal$containerlocalrenderinformation1.counter + 1);
<                     renderglobal$containerlocalrenderinformation.setDirection(renderglobal$containerlocalrenderinformation1.setFacing, (EnumFacing)enumfacing1);
---
>                 CompiledChunk compiledChunk3 = renderchunk3.compiledChunk;
>                 if (!compiledChunk3.isEmpty() || renderchunk3.needsUpdate()) {
>                     this.renderInfos.add((Object)renderglobal$containerlocalrenderinformation1);
>                 }
>                 if (ChunkUtils.hasEntities((Chunk)renderchunk3.getChunk())) {
>                     this.renderInfosEntities.add((Object)renderglobal$containerlocalrenderinformation1);
>                 }
>                 if (compiledChunk3.getTileEntities().size() > 0) {
>                     this.renderInfosTileEntities.add((Object)renderglobal$containerlocalrenderinformation1);
>                 }
>                 for (EnumFacing enumfacing1 : flag1 ? ChunkVisibility.getFacingsNotOpposite((int)renderglobal$containerlocalrenderinformation1.setFacing) : EnumFacing.VALUES) {
>                     RenderChunk renderchunk2;
>                     if (flag1 && enumfacing2 != null && !compiledChunk3.isVisible(enumfacing2.getOpposite(), enumfacing1) || (renderchunk2 = this.getRenderChunkOffset(blockpos1, renderchunk3, enumfacing1, fog, maxChunkY)) == null || !renderchunk2.setFrameIndex(frameCount) || !renderchunk2.isBoundingBoxInFrustum(camera, frameCount)) continue;
>                     int setFacing = renderglobal$containerlocalrenderinformation1.setFacing | 1 << enumfacing1.ordinal();
>                     ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation = renderchunk2.getRenderInfo();
>                     ContainerLocalRenderInformation.access$000((ContainerLocalRenderInformation)renderglobal$containerlocalrenderinformation, (EnumFacing)enumfacing1, (int)setFacing);
880a1138,1142
>         Lagometer.timerVisibility.end();
>         if (Shaders.isShadowPass) {
>             Shaders.mcProfilerEndSection();
>             return;
>         }
883c1145,1148
<         this.chunksToUpdate = Sets.newLinkedHashSet();
---
>         this.chunksToUpdate = this.chunksToUpdatePrev;
>         this.chunksToUpdatePrev = set;
>         this.chunksToUpdate.clear();
>         Lagometer.timerChunkUpdate.start();
889,891c1154,1156
<             BlockPos blockpos2 = renderchunk4.getPosition().add(8, 8, 8);
<             boolean bl = flag3 = blockpos2.n((Vec3i)blockpos1) < 768.0;
<             if (ForgeModContainer.alwaysSetupTerrainOffThread || !renderchunk4.needsImmediateUpdate() && !flag3) {
---
>             BlockPos posChunk = renderchunk4.getPosition();
>             boolean bl = flag3 = blockpos1.f((double)(posChunk.p() + 8), (double)(posChunk.q() + 8), (double)(posChunk.r() + 8)) < 768.0;
>             if (!flag3) {
894a1160,1163
>             if (!renderchunk4.isPlayerUpdate()) {
>                 this.chunksToUpdateForced.add((Object)renderchunk4);
>                 continue;
>             }
899a1169
>         Lagometer.timerChunkUpdate.end();
916,918c1186,1188
<     private RenderChunk getRenderChunkOffset(BlockPos playerPos, RenderChunk renderChunkBase, EnumFacing facing) {
<         BlockPos blockpos = renderChunkBase.getBlockPosOffset16(facing);
<         if (MathHelper.abs((int)(playerPos.p() - blockpos.p())) > this.renderDistanceChunks * 16) {
---
>     private RenderChunk getRenderChunkOffset(BlockPos playerPos, RenderChunk renderChunkBase, EnumFacing facing, boolean fog, int yMax) {
>         RenderChunk neighbour = renderChunkBase.getRenderChunkNeighbour(facing);
>         if (neighbour == null) {
921,922c1191,1192
<         if (blockpos.q() >= 0 && blockpos.q() < 256) {
<             return MathHelper.abs((int)(playerPos.r() - blockpos.r())) > this.renderDistanceChunks * 16 ? null : this.viewFrustum.getRenderChunk(blockpos);
---
>         if (neighbour.getPosition().q() > yMax) {
>             return null;
924c1194,1203
<         return null;
---
>         if (fog) {
>             int dzs;
>             BlockPos var4 = neighbour.getPosition();
>             int dxs = playerPos.p() - var4.p();
>             int distSq = dxs * dxs + (dzs = playerPos.r() - var4.r()) * dzs;
>             if (distSq > this.renderDistanceSq) {
>                 return null;
>             }
>         }
>         return neighbour;
972c1251
<         if (blockLayerIn == BlockRenderLayer.TRANSLUCENT) {
---
>         if (blockLayerIn == BlockRenderLayer.TRANSLUCENT && !Shaders.isShadowPass) {
981a1261
>                 this.chunksToResortTransparency.clear();
984c1264
<                     this.renderDispatcher.updateTransparencyLater(renderglobal$containerlocalrenderinformation.renderChunk);
---
>                     this.chunksToResortTransparency.add((Object)renderglobal$containerlocalrenderinformation.renderChunk);
1001c1281,1288
<         this.mc.profiler.func_194339_b(() -> "render_" + String.valueOf((Object)blockLayerIn));
---
>         if (l == 0) {
>             this.mc.profiler.endSection();
>             return l;
>         }
>         if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
>             GlStateManager.disableFog();
>         }
>         this.mc.profiler.func_194339_b(() -> "render_" + blockLayerIn);
1017a1305,1307
>         if (Config.isShaders()) {
>             ShadersRender.preRenderChunkLayer((BlockRenderLayer)blockLayerIn);
>         }
1018a1309,1311
>         if (Config.isShaders()) {
>             ShadersRender.postRenderChunkLayer((BlockRenderLayer)blockLayerIn);
>         }
1053a1347,1357
>         if (Config.isShaders()) {
>             if (Keyboard.isKeyDown((int)61) && Keyboard.isKeyDown((int)24)) {
>                 GuiShaderOptions gui = new GuiShaderOptions(null, Config.getGameSettings());
>                 Config.getMinecraft().displayGuiScreen((GuiScreen)gui);
>             }
>             if (Keyboard.isKeyDown((int)61) && Keyboard.isKeyDown((int)19)) {
>                 Shaders.uninit();
>                 Shaders.loadShaderPack();
>                 Reflector.Minecraft_actionKeyF3.setValue((Object)this.mc, (Object)Boolean.TRUE);
>             }
>         }
1071a1376,1378
>         if (!Config.isSkyEnabled()) {
>             return;
>         }
1099,1102c1406,1419
<             bufferbuilder.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(40, 40, 40, 255).endVertex();
<             bufferbuilder.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(40, 40, 40, 255).endVertex();
<             bufferbuilder.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(40, 40, 40, 255).endVertex();
<             bufferbuilder.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(40, 40, 40, 255).endVertex();
---
>             int r = 40;
>             int g = 40;
>             int b = 40;
>             if (Config.isCustomColors()) {
>                 Vec3d vec3d = new Vec3d((double)r / 255.0, (double)g / 255.0, (double)b / 255.0);
>                 vec3d = CustomColors.getWorldSkyColor((Vec3d)vec3d, (World)this.world, (Entity)this.mc.getRenderViewEntity(), (float)0.0f);
>                 r = (int)(vec3d.x * 255.0);
>                 g = (int)(vec3d.y * 255.0);
>                 b = (int)(vec3d.z * 255.0);
>             }
>             bufferbuilder.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(r, g, b, 255).endVertex();
>             bufferbuilder.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(r, g, b, 255).endVertex();
>             bufferbuilder.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(r, g, b, 255).endVertex();
>             bufferbuilder.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(r, g, b, 255).endVertex();
1108a1426
>         GlStateManager.disableBlend();
1112,1114c1430,1433
<         IRenderHandler renderer = this.world.provider.getSkyRenderer();
<         if (renderer != null) {
<             renderer.render(partialTicks, this.world, this.mc);
---
>         WorldProvider wp;
>         Object skyRenderer;
>         if (Reflector.ForgeWorldProvider_getSkyRenderer.exists() && (skyRenderer = Reflector.call((Object)(wp = this.mc.world.provider), (ReflectorMethod)Reflector.ForgeWorldProvider_getSkyRenderer, (Object[])new Object[0])) != null) {
>             Reflector.callVoid((Object)skyRenderer, (ReflectorMethod)Reflector.IRenderHandler_render, (Object[])new Object[]{Float.valueOf((float)partialTicks), this.world, this.mc});
1117c1436
<         if (this.mc.world.provider.getDimensionType().getId() == 1) {
---
>         if (this.mc.world.provider.getDimensionType() == DimensionType.THE_END) {
1119a1439
>             float f15;
1120a1441,1444
>             boolean isShaders = Config.isShaders();
>             if (isShaders) {
>                 Shaders.disableTexture2D();
>             }
1121a1446,1449
>             vec3d = CustomColors.getSkyColor((Vec3d)vec3d, (IBlockAccess)this.mc.world, (double)this.mc.getRenderViewEntity().posX, (double)(this.mc.getRenderViewEntity().posY + 1.0), (double)this.mc.getRenderViewEntity().posZ);
>             if (isShaders) {
>                 Shaders.setSkyColor((Vec3d)vec3d);
>             }
1137a1466,1468
>             if (isShaders) {
>                 Shaders.enableFog();
>             }
1139,1147c1470,1483
<             if (this.vboEnabled) {
<                 this.skyVBO.bindBuffer();
<                 GlStateManager.glEnableClientState((int)32884);
<                 GlStateManager.glVertexPointer((int)3, (int)5126, (int)12, (int)0);
<                 this.skyVBO.drawArrays(7);
<                 this.skyVBO.unbindBuffer();
<                 GlStateManager.glDisableClientState((int)32884);
<             } else {
<                 GlStateManager.callList((int)this.glSkyList);
---
>             if (isShaders) {
>                 Shaders.preSkyList();
>             }
>             if (Config.isSkyEnabled()) {
>                 if (this.vboEnabled) {
>                     this.skyVBO.bindBuffer();
>                     GlStateManager.glEnableClientState((int)32884);
>                     GlStateManager.glVertexPointer((int)3, (int)5126, (int)12, (int)0);
>                     this.skyVBO.drawArrays(7);
>                     this.skyVBO.unbindBuffer();
>                     GlStateManager.glDisableClientState((int)32884);
>                 } else {
>                     GlStateManager.callList((int)this.glSkyList);
>                 }
1149a1486,1488
>             if (isShaders) {
>                 Shaders.disableFog();
>             }
1155c1494
<             if (afloat != null) {
---
>             if (afloat != null && Config.isSunMoonEnabled()) {
1156a1496,1498
>                 if (isShaders) {
>                     Shaders.disableTexture2D();
>                 }
1186a1529,1531
>             if (isShaders) {
>                 Shaders.enableTexture2D();
>             }
1191a1537,1540
>             CustomSky.renderSky((World)this.world, (TextureManager)this.renderEngine, (float)partialTicks);
>             if (isShaders) {
>                 Shaders.preCelestialRotate();
>             }
1192a1542,1544
>             if (isShaders) {
>                 Shaders.postCelestialRotate();
>             }
1194,1200c1546,1554
<             this.renderEngine.bindTexture(SUN_TEXTURES);
<             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
<             bufferbuilder.pos((double)(-f17), 100.0, (double)(-f17)).tex(0.0, 0.0).endVertex();
<             bufferbuilder.pos((double)f17, 100.0, (double)(-f17)).tex(1.0, 0.0).endVertex();
<             bufferbuilder.pos((double)f17, 100.0, (double)f17).tex(1.0, 1.0).endVertex();
<             bufferbuilder.pos((double)(-f17), 100.0, (double)f17).tex(0.0, 1.0).endVertex();
<             tessellator.draw();
---
>             if (Config.isSunTexture()) {
>                 this.renderEngine.bindTexture(SUN_TEXTURES);
>                 bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
>                 bufferbuilder.pos((double)(-f17), 100.0, (double)(-f17)).tex(0.0, 0.0).endVertex();
>                 bufferbuilder.pos((double)f17, 100.0, (double)(-f17)).tex(1.0, 0.0).endVertex();
>                 bufferbuilder.pos((double)f17, 100.0, (double)f17).tex(1.0, 1.0).endVertex();
>                 bufferbuilder.pos((double)(-f17), 100.0, (double)f17).tex(0.0, 1.0).endVertex();
>                 tessellator.draw();
>             }
1202,1215c1556,1571
<             this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
<             int k1 = this.world.getMoonPhase();
<             int i2 = k1 % 4;
<             int k2 = k1 / 4 % 2;
<             float f22 = (float)(i2 + 0) / 4.0f;
<             float f23 = (float)(k2 + 0) / 2.0f;
<             float f24 = (float)(i2 + 1) / 4.0f;
<             float f14 = (float)(k2 + 1) / 2.0f;
<             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
<             bufferbuilder.pos((double)(-f17), -100.0, (double)f17).tex((double)f24, (double)f14).endVertex();
<             bufferbuilder.pos((double)f17, -100.0, (double)f17).tex((double)f22, (double)f14).endVertex();
<             bufferbuilder.pos((double)f17, -100.0, (double)(-f17)).tex((double)f22, (double)f23).endVertex();
<             bufferbuilder.pos((double)(-f17), -100.0, (double)(-f17)).tex((double)f24, (double)f23).endVertex();
<             tessellator.draw();
---
>             if (Config.isMoonTexture()) {
>                 this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
>                 int k1 = this.world.getMoonPhase();
>                 int i2 = k1 % 4;
>                 int k2 = k1 / 4 % 2;
>                 float f22 = (float)(i2 + 0) / 4.0f;
>                 float f23 = (float)(k2 + 0) / 2.0f;
>                 float f24 = (float)(i2 + 1) / 4.0f;
>                 float f14 = (float)(k2 + 1) / 2.0f;
>                 bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
>                 bufferbuilder.pos((double)(-f17), -100.0, (double)f17).tex((double)f24, (double)f14).endVertex();
>                 bufferbuilder.pos((double)f17, -100.0, (double)f17).tex((double)f22, (double)f14).endVertex();
>                 bufferbuilder.pos((double)f17, -100.0, (double)(-f17)).tex((double)f22, (double)f23).endVertex();
>                 bufferbuilder.pos((double)(-f17), -100.0, (double)(-f17)).tex((double)f24, (double)f23).endVertex();
>                 tessellator.draw();
>             }
1217,1218c1573,1576
<             float f15 = this.world.getStarBrightness(partialTicks) * f16;
<             if (f15 > 0.0f) {
---
>             if (isShaders) {
>                 Shaders.disableTexture2D();
>             }
>             if ((f15 = this.world.getStarBrightness(partialTicks) * f16) > 0.0f && Config.isStarsEnabled() && !CustomSky.hasSkyLayers((World)this.world)) {
1234a1593,1595
>             if (isShaders) {
>                 Shaders.enableFog();
>             }
1236a1598,1600
>             if (isShaders) {
>                 Shaders.disableTexture2D();
>             }
1283a1648,1650
>             if (this.mc.gameSettings.renderDistanceChunks <= 4) {
>                 GlStateManager.color((float)this.mc.entityRenderer.fogColorRed, (float)this.mc.entityRenderer.fogColorGreen, (float)this.mc.entityRenderer.fogColorBlue);
>             }
1286c1653,1664
<             GlStateManager.callList((int)this.glSkyList2);
---
>             if (Config.isSkyEnabled()) {
>                 if (this.vboEnabled) {
>                     this.sky2VBO.bindBuffer();
>                     GlStateManager.glEnableClientState((int)32884);
>                     GlStateManager.glVertexPointer((int)3, (int)5126, (int)12, (int)0);
>                     this.sky2VBO.drawArrays(7);
>                     this.sky2VBO.unbindBuffer();
>                     GlStateManager.glDisableClientState((int)32884);
>                 } else {
>                     GlStateManager.callList((int)this.glSkyList2);
>                 }
>             }
1288a1667,1669
>             if (isShaders) {
>                 Shaders.enableTexture2D();
>             }
1293,1294c1674,1681
<     public void renderClouds(float partialTicks, int pass, double x, double y, double z) {
<         if (FMLClientHandler.instance().renderClouds(this.cloudTickCounter, partialTicks)) {
---
>     public void renderClouds(float partialTicks, int pass, double p_180447_3_, double p_180447_5_, double p_180447_7_) {
>         WorldProvider wp;
>         Object cloudRenderer;
>         if (Config.isCloudsOff()) {
>             return;
>         }
>         if (Reflector.ForgeWorldProvider_getCloudRenderer.exists() && (cloudRenderer = Reflector.call((Object)(wp = this.mc.world.provider), (ReflectorMethod)Reflector.ForgeWorldProvider_getCloudRenderer, (Object[])new Object[0])) != null) {
>             Reflector.callVoid((Object)cloudRenderer, (ReflectorMethod)Reflector.IRenderHandler_render, (Object[])new Object[]{Float.valueOf((float)partialTicks), this.world, this.mc});
1298,1299c1685,1689
<             if (this.mc.gameSettings.shouldRenderClouds() == 2) {
<                 this.renderCloudsFancy(partialTicks, pass, x, y, z);
---
>             if (Config.isShaders()) {
>                 Shaders.beginClouds();
>             }
>             if (Config.isCloudsFancy()) {
>                 this.renderCloudsFancy(partialTicks, pass, p_180447_3_, p_180447_5_, p_180447_7_);
1300a1691,1692
>                 float partialTicksPrev = partialTicks;
>                 partialTicks = 0.0f;
1313,1336c1705,1733
<                 if (pass != 2) {
<                     float f3 = (f * 30.0f + f1 * 59.0f + f2 * 11.0f) / 100.0f;
<                     float f4 = (f * 30.0f + f1 * 70.0f) / 100.0f;
<                     float f5 = (f * 30.0f + f2 * 70.0f) / 100.0f;
<                     f = f3;
<                     f1 = f4;
<                     f2 = f5;
<                 }
<                 float f9 = 4.8828125E-4f;
<                 double d5 = (float)this.cloudTickCounter + partialTicks;
<                 double d3 = x + d5 * (double)0.03f;
<                 int i2 = MathHelper.floor((double)(d3 / 2048.0));
<                 int j2 = MathHelper.floor((double)(z / 2048.0));
<                 double lvt_22_1_ = z - (double)(j2 * 2048);
<                 float f6 = this.world.provider.getCloudHeight() - (float)y + 0.33f;
<                 float f7 = (float)((d3 -= (double)(i2 * 2048)) * 4.8828125E-4);
<                 float f8 = (float)(lvt_22_1_ * 4.8828125E-4);
<                 bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
<                 for (int k2 = -256; k2 < 256; k2 += 32) {
<                     for (int l2 = -256; l2 < 256; l2 += 32) {
<                         bufferbuilder.pos((double)(k2 + 0), (double)f6, (double)(l2 + 32)).tex((double)((float)(k2 + 0) * 4.8828125E-4f + f7), (double)((float)(l2 + 32) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
<                         bufferbuilder.pos((double)(k2 + 32), (double)f6, (double)(l2 + 32)).tex((double)((float)(k2 + 32) * 4.8828125E-4f + f7), (double)((float)(l2 + 32) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
<                         bufferbuilder.pos((double)(k2 + 32), (double)f6, (double)(l2 + 0)).tex((double)((float)(k2 + 32) * 4.8828125E-4f + f7), (double)((float)(l2 + 0) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
<                         bufferbuilder.pos((double)(k2 + 0), (double)f6, (double)(l2 + 0)).tex((double)((float)(k2 + 0) * 4.8828125E-4f + f7), (double)((float)(l2 + 0) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
---
>                 this.cloudRenderer.prepareToRender(false, this.cloudTickCounter, partialTicksPrev, vec3d);
>                 if (this.cloudRenderer.shouldUpdateGlList()) {
>                     this.cloudRenderer.startUpdateGlList();
>                     if (pass != 2) {
>                         float f3 = (f * 30.0f + f1 * 59.0f + f2 * 11.0f) / 100.0f;
>                         float f4 = (f * 30.0f + f1 * 70.0f) / 100.0f;
>                         float f5 = (f * 30.0f + f2 * 70.0f) / 100.0f;
>                         f = f3;
>                         f1 = f4;
>                         f2 = f5;
>                     }
>                     float f9 = 4.8828125E-4f;
>                     double d5 = (float)this.cloudTickCounter + partialTicks;
>                     double d3 = p_180447_3_ + d5 * (double)0.03f;
>                     int i2 = MathHelper.floor((double)(d3 / 2048.0));
>                     int j2 = MathHelper.floor((double)(p_180447_7_ / 2048.0));
>                     double lvt_22_1_ = p_180447_7_ - (double)(j2 * 2048);
>                     float f6 = this.world.provider.getCloudHeight() - (float)p_180447_5_ + 0.33f;
>                     f6 += this.mc.gameSettings.ofCloudsHeight * 128.0f;
>                     float f7 = (float)((d3 -= (double)(i2 * 2048)) * 4.8828125E-4);
>                     float f8 = (float)(lvt_22_1_ * 4.8828125E-4);
>                     bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
>                     for (int k2 = -256; k2 < 256; k2 += 32) {
>                         for (int l2 = -256; l2 < 256; l2 += 32) {
>                             bufferbuilder.pos((double)(k2 + 0), (double)f6, (double)(l2 + 32)).tex((double)((float)(k2 + 0) * 4.8828125E-4f + f7), (double)((float)(l2 + 32) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
>                             bufferbuilder.pos((double)(k2 + 32), (double)f6, (double)(l2 + 32)).tex((double)((float)(k2 + 32) * 4.8828125E-4f + f7), (double)((float)(l2 + 32) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
>                             bufferbuilder.pos((double)(k2 + 32), (double)f6, (double)(l2 + 0)).tex((double)((float)(k2 + 32) * 4.8828125E-4f + f7), (double)((float)(l2 + 0) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
>                             bufferbuilder.pos((double)(k2 + 0), (double)f6, (double)(l2 + 0)).tex((double)((float)(k2 + 0) * 4.8828125E-4f + f7), (double)((float)(l2 + 0) * 4.8828125E-4f + f8)).color(f, f1, f2, 0.8f).endVertex();
>                         }
1337a1735,1736
>                     tessellator.draw();
>                     this.cloudRenderer.endUpdateGlList();
1339c1738
<                 tessellator.draw();
---
>                 this.cloudRenderer.renderGlList();
1343a1743,1745
>             if (Config.isShaders()) {
>                 Shaders.endClouds();
>             }
1351a1754,1755
>         float partialTicksPrev = partialTicks;
>         partialTicks = 0.0f;
1360a1765
>         f2 += this.mc.gameSettings.ofCloudsHeight * 128.0f;
1371a1777
>         this.cloudRenderer.prepareToRender(true, this.cloudTickCounter, partialTicksPrev, vec3d);
1415a1822,1825
>             this.cloudRenderer.renderGlList();
>         }
>         if (this.cloudRenderer.shouldUpdateGlList()) {
>             this.cloudRenderer.startUpdateGlList();
1469a1880
>             this.cloudRenderer.endUpdateGlList();
1476a1888,1890
>         RenderChunk renderChunk;
>         Iterator itTransparency;
>         finishTimeNano = (long)((double)finishTimeNano + 1.0E8);
1477a1892,1906
>         if (this.chunksToUpdateForced.size() > 0) {
>             RenderChunk rc;
>             Iterator itForced = this.chunksToUpdateForced.iterator();
>             while (itForced.hasNext() && this.renderDispatcher.updateChunkLater(rc = (RenderChunk)itForced.next())) {
>                 rc.clearNeedsUpdate();
>                 itForced.remove();
>                 this.chunksToUpdate.remove((Object)rc);
>                 this.chunksToResortTransparency.remove((Object)rc);
>             }
>         }
>         if (this.chunksToResortTransparency.size() > 0 && (itTransparency = this.chunksToResortTransparency.iterator()).hasNext() && this.renderDispatcher.updateTransparencyLater(renderChunk = (RenderChunk)itTransparency.next())) {
>             itTransparency.remove();
>         }
>         double weightTotal = 0.0;
>         int updatesPerFrame = Config.getUpdatesPerFrame();
1479,1480d1907
<             RenderChunk renderchunk1;
<             boolean flag1;
1482c1909,1914
<             while (iterator.hasNext() && (flag1 = (renderchunk1 = (RenderChunk)iterator.next()).needsImmediateUpdate() ? this.renderDispatcher.updateChunkNow(renderchunk1) : this.renderDispatcher.updateChunkLater(renderchunk1))) {
---
>             while (iterator.hasNext()) {
>                 double weight;
>                 RenderChunk renderchunk1 = (RenderChunk)iterator.next();
>                 boolean empty = renderchunk1.isChunkRegionEmpty();
>                 boolean flag1 = renderchunk1.needsImmediateUpdate() || empty ? this.renderDispatcher.updateChunkNow(renderchunk1) : this.renderDispatcher.updateChunkLater(renderchunk1);
>                 if (!flag1) break;
1485,1486c1917
<                 long k1 = finishTimeNano - System.nanoTime();
<                 if (k1 >= 0L) continue;
---
>                 if (empty || !((weightTotal += (weight = 2.0 * RenderChunkUtils.getRelativeBufferSize((RenderChunk)renderchunk1))) > (double)updatesPerFrame)) continue;
1497a1929,1932
>             if (Config.isShaders()) {
>                 Shaders.pushProgram();
>                 Shaders.useProgram((Program)Shaders.ProgramTexturedLit);
>             }
1590a2026
>             GlStateManager.tryBlendFuncSeparate((GlStateManager.SourceFactor)GlStateManager.SourceFactor.SRC_ALPHA, (GlStateManager.DestFactor)GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, (GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
1593a2030,2032
>             if (Config.isShaders()) {
>                 Shaders.popProgram();
>             }
1605a2045,2047
>         if (Config.isShaders()) {
>             ShadersRender.beginBlockDamage();
>         }
1614a2057,2059
>         if (Config.isShaders()) {
>             ShadersRender.endBlockDamage();
>         }
1617c2062
<     public void drawBlockDamageTexture(Tessellator tessellatorIn, BufferBuilder bufferBuilderIn, Entity entityIn, float partialTicks) {
---
>     public void drawBlockDamageTexture(Tessellator tessellatorIn, BufferBuilder worldRendererIn, Entity entityIn, float partialTicks) {
1624,1626c2069,2071
<             bufferBuilderIn.begin(7, DefaultVertexFormats.BLOCK);
<             bufferBuilderIn.setTranslation(-d3, -d4, -d5);
<             bufferBuilderIn.noColor();
---
>             worldRendererIn.begin(7, DefaultVertexFormats.BLOCK);
>             worldRendererIn.setTranslation(-d3, -d4, -d5);
>             worldRendererIn.noColor();
1629c2074
<                 boolean hasBreak;
---
>                 boolean renderBreaking;
1636,1639c2081,2090
<                 TileEntity te = this.world.getTileEntity(blockpos);
<                 boolean bl = hasBreak = block instanceof BlockChest || block instanceof BlockEnderChest || block instanceof BlockSign || block instanceof BlockSkull;
<                 if (!hasBreak) {
<                     boolean bl2 = hasBreak = te != null && te.canRenderBreaking();
---
>                 if (Reflector.ForgeTileEntity_canRenderBreaking.exists()) {
>                     TileEntity te;
>                     boolean tileEntityRenderBreaking;
>                     boolean bl = tileEntityRenderBreaking = block instanceof BlockChest || block instanceof BlockEnderChest || block instanceof BlockSign || block instanceof BlockSkull;
>                     if (!tileEntityRenderBreaking && (te = this.world.getTileEntity(blockpos)) != null) {
>                         tileEntityRenderBreaking = Reflector.callBoolean((Object)te, (ReflectorMethod)Reflector.ForgeTileEntity_canRenderBreaking, (Object[])new Object[0]);
>                     }
>                     renderBreaking = !tileEntityRenderBreaking;
>                 } else {
>                     boolean bl = renderBreaking = !(block instanceof BlockChest) && !(block instanceof BlockEnderChest) && !(block instanceof BlockSign) && !(block instanceof BlockSkull);
1641c2092
<                 if (hasBreak) continue;
---
>                 if (!renderBreaking) continue;
1654c2105
<             bufferBuilderIn.setTranslation(0.0, 0.0, 0.0);
---
>             worldRendererIn.setTranslation(0.0, 0.0, 0.0);
1664a2116,2118
>             if (Config.isShaders()) {
>                 Shaders.disableTexture2D();
>             }
1675a2130,2132
>             if (Config.isShaders()) {
>                 Shaders.enableTexture2D();
>             }
1703,1704c2160,2161
<         buffer.pos(minX, maxY, minZ).color(red, green, blue, alpha).endVertex();
<         buffer.pos(minX, maxY, maxZ).color(red, green, blue, 0.0f).endVertex();
---
>         buffer.pos(minX, maxY, minZ).color(red, green, blue, 0.0f).endVertex();
>         buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
1706,1707c2163,2164
<         buffer.pos(maxX, maxY, maxZ).color(red, green, blue, 0.0f).endVertex();
<         buffer.pos(maxX, minY, maxZ).color(red, green, blue, alpha).endVertex();
---
>         buffer.pos(maxX, minY, maxZ).color(red, green, blue, 0.0f).endVertex();
>         buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
1710d2166
<         buffer.pos(maxX, minY, minZ).color(red, green, blue, 0.0f).endVertex();
1713,1714c2169,2170
<     public static void renderFilledBox(AxisAlignedBB aabb, float red, float green, float blue, float alpha) {
<         RenderGlobal.renderFilledBox(aabb.minX, aabb.minY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ, red, green, blue, alpha);
---
>     public static void renderFilledBox(AxisAlignedBB p_189696_0_, float p_189696_1_, float p_189696_2_, float p_189696_3_, float p_189696_4_) {
>         RenderGlobal.renderFilledBox(p_189696_0_.minX, p_189696_0_.minY, p_189696_0_.minZ, p_189696_0_.maxX, p_189696_0_.maxY, p_189696_0_.maxZ, p_189696_1_, p_189696_2_, p_189696_3_, p_189696_4_);
1717c2173
<     public static void renderFilledBox(double minX, double minY, double minZ, double maxX, double maxY, double maxZ, float red, float green, float blue, float alpha) {
---
>     public static void renderFilledBox(double p_189695_0_, double p_189695_2_, double p_189695_4_, double p_189695_6_, double p_189695_8_, double p_189695_10_, float p_189695_12_, float p_189695_13_, float p_189695_14_, float p_189695_15_) {
1721c2177
<         RenderGlobal.addChainedFilledBoxVertices(bufferbuilder, minX, minY, minZ, maxX, maxY, maxZ, red, green, blue, alpha);
---
>         RenderGlobal.addChainedFilledBoxVertices(bufferbuilder, p_189695_0_, p_189695_2_, p_189695_4_, p_189695_6_, p_189695_8_, p_189695_10_, p_189695_12_, p_189695_13_, p_189695_14_, p_189695_15_);
1725,1755c2181,2211
<     public static void addChainedFilledBoxVertices(BufferBuilder builder, double x1, double y1, double z1, double x2, double y2, double z2, float red, float green, float blue, float alpha) {
<         builder.pos(x1, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y1, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x1, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z1).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z2).color(red, green, blue, alpha).endVertex();
<         builder.pos(x2, y2, z2).color(red, green, blue, alpha).endVertex();
---
>     public static void addChainedFilledBoxVertices(BufferBuilder builder, double p_189693_1_, double p_189693_3_, double p_189693_5_, double p_189693_7_, double p_189693_9_, double p_189693_11_, float red, float green, float blue, float alpha) {
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
>         builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
1795,1797c2251,2253
<     private void setPartying(World worldIn, BlockPos pos, boolean isPartying) {
<         for (EntityLivingBase entitylivingbase : worldIn.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(pos).grow(3.0))) {
<             entitylivingbase.setPartying(pos, isPartying);
---
>     private void setPartying(World p_193054_1_, BlockPos pos, boolean p_193054_3_) {
>         for (EntityLivingBase entitylivingbase : p_193054_1_.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(pos).grow(3.0))) {
>             entitylivingbase.setPartying(pos, p_193054_3_);
1808c2264
<     public void spawnParticle(int id, boolean ignoreRange, boolean minimiseParticleLevel, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed, int ... parameters) {
---
>     public void spawnParticle(int id, boolean ignoreRange, boolean p_190570_3_, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed, int ... parameters) {
1810c2266
<             this.spawnParticle0(id, ignoreRange, minimiseParticleLevel, x, y, z, xSpeed, ySpeed, zSpeed, parameters);
---
>             this.spawnParticle0(id, ignoreRange, p_190570_3_, x, y, z, xSpeed, ySpeed, zSpeed, parameters);
1841,1842c2297,2329
<             if (ignoreRange) {
<                 return this.mc.effectRenderer.spawnEffectParticle(particleID, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
---
>             int id = particleID;
>             if (id == EnumParticleTypes.EXPLOSION_HUGE.getParticleID() && !Config.isAnimatedExplosion()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.EXPLOSION_LARGE.getParticleID() && !Config.isAnimatedExplosion()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.EXPLOSION_NORMAL.getParticleID() && !Config.isAnimatedExplosion()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SUSPENDED.getParticleID() && !Config.isWaterParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SUSPENDED_DEPTH.getParticleID() && !Config.isVoidParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SMOKE_NORMAL.getParticleID() && !Config.isAnimatedSmoke()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SMOKE_LARGE.getParticleID() && !Config.isAnimatedSmoke()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SPELL_MOB.getParticleID() && !Config.isPotionParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID() && !Config.isPotionParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SPELL.getParticleID() && !Config.isPotionParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.SPELL_INSTANT.getParticleID() && !Config.isPotionParticles()) {
>                 return null;
1844c2331
<             if (d3 * d3 + d4 * d4 + d5 * d5 > 1024.0) {
---
>             if (id == EnumParticleTypes.SPELL_WITCH.getParticleID() && !Config.isPotionParticles()) {
1847c2334,2383
<             return k1 > 1 ? null : this.mc.effectRenderer.spawnEffectParticle(particleID, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
---
>             if (id == EnumParticleTypes.PORTAL.getParticleID() && !Config.isPortalParticles()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.FLAME.getParticleID() && !Config.isAnimatedFlame()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.REDSTONE.getParticleID() && !Config.isAnimatedRedstone()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.DRIP_WATER.getParticleID() && !Config.isDrippingWaterLava()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.DRIP_LAVA.getParticleID() && !Config.isDrippingWaterLava()) {
>                 return null;
>             }
>             if (id == EnumParticleTypes.FIREWORKS_SPARK.getParticleID() && !Config.isFireworkParticles()) {
>                 return null;
>             }
>             if (!ignoreRange) {
>                 double maxDistSq = 1024.0;
>                 if (id == EnumParticleTypes.CRIT.getParticleID()) {
>                     maxDistSq = 38416.0;
>                 }
>                 if (d3 * d3 + d4 * d4 + d5 * d5 > maxDistSq) {
>                     return null;
>                 }
>                 if (k1 > 1) {
>                     return null;
>                 }
>             }
>             Particle entityFx = this.mc.effectRenderer.spawnEffectParticle(particleID, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
>             if (id == EnumParticleTypes.WATER_BUBBLE.getParticleID()) {
>                 CustomColors.updateWaterFX((Particle)entityFx, (IBlockAccess)this.world, (double)xCoord, (double)yCoord, (double)zCoord, (RenderEnv)this.renderEnv);
>             }
>             if (id == EnumParticleTypes.WATER_SPLASH.getParticleID()) {
>                 CustomColors.updateWaterFX((Particle)entityFx, (IBlockAccess)this.world, (double)xCoord, (double)yCoord, (double)zCoord, (RenderEnv)this.renderEnv);
>             }
>             if (id == EnumParticleTypes.WATER_DROP.getParticleID()) {
>                 CustomColors.updateWaterFX((Particle)entityFx, (IBlockAccess)this.world, (double)xCoord, (double)yCoord, (double)zCoord, (RenderEnv)this.renderEnv);
>             }
>             if (id == EnumParticleTypes.TOWN_AURA.getParticleID()) {
>                 CustomColors.updateMyceliumFX((Particle)entityFx);
>             }
>             if (id == EnumParticleTypes.PORTAL.getParticleID()) {
>                 CustomColors.updatePortalFX((Particle)entityFx);
>             }
>             if (id == EnumParticleTypes.REDSTONE.getParticleID()) {
>                 CustomColors.updateReddustFX((Particle)entityFx, (IBlockAccess)this.world, (double)xCoord, (double)yCoord, (double)zCoord);
>             }
>             return entityFx;
1852c2388
<     private int calculateParticleLevel(boolean minimiseLevel) {
---
>     private int calculateParticleLevel(boolean p_190572_1_) {
1854c2390
<         if (minimiseLevel && k1 == 2 && this.world.rand.nextInt(10) == 0) {
---
>         if (p_190572_1_ && k1 == 2 && this.world.rand.nextInt(10) == 0) {
1863a2400,2403
>         RandomEntities.entityLoaded((Entity)entityIn, (World)this.world);
>         if (Config.isDynamicLights()) {
>             DynamicLights.entityAdded((Entity)entityIn, (RenderGlobal)this);
>         }
1866a2407,2410
>         RandomEntities.entityUnloaded((Entity)entityIn, (World)this.world);
>         if (Config.isDynamicLights()) {
>             DynamicLights.entityRemoved((Entity)entityIn, (RenderGlobal)this);
>         }
2076c2620,2623
<                     SoundType soundtype = block.getSoundType(Block.getStateById((int)data), (World)this.world, blockPosIn, null);
---
>                     SoundType soundtype = block.getSoundType();
>                     if (Reflector.ForgeBlock_getSoundType.exists()) {
>                         soundtype = (SoundType)Reflector.call((Object)block, (ReflectorMethod)Reflector.ForgeBlock_getSoundType, (Object[])new Object[]{Block.getStateById((int)data), this.world, blockPosIn, null});
>                     }
2180a2728,2808
>     }
> 
>     public void resetClouds() {
>         this.cloudRenderer.reset();
>     }
> 
>     public int getCountRenderers() {
>         return this.viewFrustum.renderChunks.length;
>     }
> 
>     public int getCountActiveRenderers() {
>         return this.renderInfos.size();
>     }
> 
>     public int getCountEntitiesRendered() {
>         return this.countEntitiesRendered;
>     }
> 
>     public int getCountTileEntitiesRendered() {
>         return this.countTileEntitiesRendered;
>     }
> 
>     public int getCountLoadedChunks() {
>         if (this.world == null) {
>             return 0;
>         }
>         ChunkProviderClient chunkProvider = this.world.getChunkProvider();
>         if (chunkProvider == null) {
>             return 0;
>         }
>         if (chunkProvider != this.worldChunkProvider) {
>             this.worldChunkProvider = chunkProvider;
>             this.worldChunkProviderMap = (Long2ObjectMap)Reflector.getFieldValue((Object)chunkProvider, (ReflectorField)Reflector.ChunkProviderClient_chunkMapping);
>         }
>         if (this.worldChunkProviderMap == null) {
>             return 0;
>         }
>         return this.worldChunkProviderMap.size();
>     }
> 
>     public int getCountChunksToUpdate() {
>         return this.chunksToUpdate.size();
>     }
> 
>     public RenderChunk getRenderChunk(BlockPos pos) {
>         return this.viewFrustum.getRenderChunk(pos);
>     }
> 
>     public WorldClient getWorld() {
>         return this.world;
>     }
> 
>     private void clearRenderInfos() {
>         if (renderEntitiesCounter > 0) {
>             this.renderInfos = new ArrayList(this.renderInfos.size() + 16);
>             this.renderInfosEntities = new ArrayList(this.renderInfosEntities.size() + 16);
>             this.renderInfosTileEntities = new ArrayList(this.renderInfosTileEntities.size() + 16);
>         } else {
>             this.renderInfos.clear();
>             this.renderInfosEntities.clear();
>             this.renderInfosTileEntities.clear();
>         }
>     }
> 
>     public void onPlayerPositionSet() {
>         if (this.firstWorldLoad) {
>             this.loadRenderers();
>             this.firstWorldLoad = false;
>         }
>     }
> 
>     public void pauseChunkUpdates() {
>         if (this.renderDispatcher != null) {
>             this.renderDispatcher.pauseChunkUpdates();
>         }
>     }
> 
>     public void resumeChunkUpdates() {
>         if (this.renderDispatcher != null) {
>             this.renderDispatcher.resumeChunkUpdates();
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$10.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$10.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.10(RenderItem this$0) {
---
>     RenderItem.10() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$5.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$5.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.5(RenderItem this$0) {
---
>     RenderItem.5() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$6.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$6.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.6(RenderItem this$0) {
---
>     RenderItem.6() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$7.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$7.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.7(RenderItem this$0) {
---
>     RenderItem.7() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$8.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$8.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.8(RenderItem this$0) {
---
>     RenderItem.8() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem$9.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem$9.java
7d6
<  *  net.minecraft.client.renderer.RenderItem
14d12
< import net.minecraft.client.renderer.RenderItem;
20c18
<     RenderItem.9(RenderItem this$0) {
---
>     RenderItem.9() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderItem.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderItem.java
4a5
>  *  Config
40a42
>  *  net.minecraft.client.renderer.OpenGlHelper
43a46
>  *  net.minecraft.client.renderer.block.model.ItemCameraTransforms
51a55
>  *  net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer
65a70
>  *  net.minecraft.util.BlockRenderLayer
72,78c77,85
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.client.ItemModelMesherForge
<  *  net.minecraftforge.client.model.ModelLoader
<  *  net.minecraftforge.client.model.pipeline.LightUtil
<  *  net.minecraftforge.common.ForgeModContainer
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomColors
>  *  net.optifine.CustomItems
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.shaders.ShadersRender
110a118
> import net.minecraft.client.renderer.OpenGlHelper;
121a130
> import net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer;
135a145
> import net.minecraft.util.BlockRenderLayer;
142,148c152,160
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.client.ItemModelMesherForge;
< import net.minecraftforge.client.model.ModelLoader;
< import net.minecraftforge.client.model.pipeline.LightUtil;
< import net.minecraftforge.common.ForgeModContainer;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomColors;
> import net.optifine.CustomItems;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
> import net.optifine.shaders.ShadersRender;
150d161
< @SideOnly(value=Side.CLIENT)
158a170,175
>     private ResourceLocation modelLocation = null;
>     private boolean renderItemGui = false;
>     public ModelManager modelManager = null;
>     private boolean renderModelHasEmissive = false;
>     private boolean renderModelEmissive = false;
>     private boolean forgeAllowEmissiveItems = Reflector.getFieldValueBoolean((ReflectorField)Reflector.ForgeModContainer_allowEmissiveItems, (boolean)false);
162c179,180
<         this.itemModelMesher = new ItemModelMesherForge(p_i46552_2_);
---
>         this.modelManager = p_i46552_2_;
>         this.itemModelMesher = Reflector.ItemModelMesherForge_Constructor.exists() ? (ItemModelMesher)Reflector.newInstance((ReflectorConstructor)Reflector.ItemModelMesherForge_Constructor, (Object[])new Object[]{p_i46552_2_}) : new ItemModelMesher(p_i46552_2_);
191c209
<     private void renderModel(IBakedModel model, int color) {
---
>     public void renderModel(IBakedModel model, int color) {
196,199c214
<         if (ForgeModContainer.allowEmissiveItems) {
<             ForgeHooksClient.renderLitItem((RenderItem)this, (IBakedModel)model, (int)color, (ItemStack)stack);
<             return;
<         }
---
>         boolean multiTexture;
201a217,221
>         boolean renderTextureMap = Minecraft.getMinecraft().getTextureMapBlocks().isTextureBound();
>         boolean bl = multiTexture = Config.isMultiTexture() && renderTextureMap;
>         if (multiTexture) {
>             bufferbuilder.setBlockLayer(BlockRenderLayer.SOLID);
>         }
203c223
<         for (EnumFacing enumfacing : EnumFacing.values()) {
---
>         for (EnumFacing enumfacing : EnumFacing.VALUES) {
207a228,231
>         if (multiTexture) {
>             bufferbuilder.setBlockLayer(null);
>             GlStateManager.bindCurrentTexture();
>         }
217c241,246
<                 stack.getItem().getTileEntityItemStackRenderer().renderByItem(stack);
---
>                 if (Reflector.ForgeItem_getTileEntityItemStackRenderer.exists()) {
>                     TileEntityItemStackRenderer teisr = (TileEntityItemStackRenderer)Reflector.call((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getTileEntityItemStackRenderer, (Object[])new Object[0]);
>                     teisr.renderByItem(stack);
>                 } else {
>                     TileEntityItemStackRenderer.instance.renderByItem(stack);
>                 }
218a248,252
>                 if (Config.isCustomItems()) {
>                     model = CustomItems.getCustomItemModel((ItemStack)stack, (IBakedModel)model, (ResourceLocation)this.modelLocation, (boolean)false);
>                     this.modelLocation = null;
>                 }
>                 this.renderModelHasEmissive = false;
220c254,263
<                 if (stack.hasEffect()) {
---
>                 if (this.renderModelHasEmissive) {
>                     float lightMapX = OpenGlHelper.lastBrightnessX;
>                     float lightMapY = OpenGlHelper.lastBrightnessY;
>                     OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)240.0f, (float)lightMapY);
>                     this.renderModelEmissive = true;
>                     this.renderModel(model, stack);
>                     this.renderModelEmissive = false;
>                     OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)lightMapX, (float)lightMapY);
>                 }
>                 if (!(!stack.hasEffect() || Config.isCustomItems() && CustomItems.renderCustomEffect((RenderItem)this, (ItemStack)stack, (IBakedModel)model))) {
228a272,277
>         if (Config.isCustomItems() && !CustomItems.isUseGlint()) {
>             return;
>         }
>         if (Config.isShaders() && Shaders.isShadowPass) {
>             return;
>         }
233a283,285
>         if (Config.isShaders() && !this.renderItemGui) {
>             ShadersRender.renderEnchantedGlintBegin();
>         }
254a307,309
>         if (Config.isShaders() && !this.renderItemGui) {
>             ShadersRender.renderEnchantedGlintEnd();
>         }
263,264c318,336
<         renderer.addVertexData(quad.getVertexData());
<         renderer.putColor4(color);
---
>         if (this.renderModelEmissive) {
>             if (quad.getQuadEmissive() == null) {
>                 return;
>             }
>             quad = quad.getQuadEmissive();
>         } else if (quad.getQuadEmissive() != null) {
>             this.renderModelHasEmissive = true;
>         }
>         if (renderer.isMultiTexture()) {
>             renderer.addVertexData(quad.getVertexDataSingle());
>         } else {
>             renderer.addVertexData(quad.getVertexData());
>         }
>         renderer.putSprite(quad.getSprite());
>         if (Reflector.ForgeHooksClient_putQuadColor.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_putQuadColor, (Object[])new Object[]{renderer, quad, color});
>         } else {
>             renderer.putColor4(color);
>         }
268c340
<     public void renderQuads(BufferBuilder renderer, List<BakedQuad> quads, int color, ItemStack stack) {
---
>     private void renderQuads(BufferBuilder renderer, List<BakedQuad> quads, int color, ItemStack stack) {
275a348,350
>                 if (Config.isCustomColors()) {
>                     k = CustomColors.getColorFromItemStack((ItemStack)stack, (int)bakedquad.getTintIndex(), (int)k);
>                 }
281c356
<             LightUtil.renderQuadColor((BufferBuilder)renderer, (BakedQuad)bakedquad, (int)k);
---
>             this.renderQuad(renderer, bakedquad, k);
299c374,391
<         return ibakedmodel.getOverrides().handleItemState(ibakedmodel, stack, worldIn, entitylivingbaseIn);
---
>         Item item = stack.getItem();
>         if (Config.isCustomItems()) {
>             IBakedModel modelFull;
>             if (item != null && item.hasCustomProperties()) {
>                 this.modelLocation = ibakedmodel.getOverrides().applyOverride(stack, worldIn, entitylivingbaseIn);
>             }
>             if ((modelFull = CustomItems.getCustomItemModel((ItemStack)stack, (IBakedModel)ibakedmodel, (ResourceLocation)this.modelLocation, (boolean)true)) != ibakedmodel) {
>                 return modelFull;
>             }
>         }
>         if (Reflector.ModelLoader_getInventoryVariant.exists()) {
>             return ibakedmodel.getOverrides().handleItemState(ibakedmodel, stack, worldIn, entitylivingbaseIn);
>         }
>         if (item != null && item.hasCustomProperties()) {
>             ResourceLocation resourcelocation = ibakedmodel.getOverrides().applyOverride(stack, worldIn, entitylivingbaseIn);
>             return resourcelocation == null ? ibakedmodel : this.itemModelMesher.getModelManager().getModel(new ModelResourceLocation(resourcelocation, "inventory"));
>         }
>         return ibakedmodel;
319c411,420
<             bakedmodel = ForgeHooksClient.handleCameraTransforms((IBakedModel)bakedmodel, (ItemCameraTransforms.TransformType)transform, (boolean)leftHanded);
---
>             if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
>                 bakedmodel = (IBakedModel)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_handleCameraTransforms, (Object[])new Object[]{bakedmodel, transform, leftHanded});
>             } else {
>                 ItemCameraTransforms itemcameratransforms = bakedmodel.getItemCameraTransforms();
>                 ItemCameraTransforms.applyTransformSide((ItemTransformVec3f)itemcameratransforms.getTransform(transform), (boolean)leftHanded);
>                 if (this.isThereOneNegativeScale(itemcameratransforms.getTransform(transform))) {
>                     GlStateManager.cullFace((GlStateManager.CullFace)GlStateManager.CullFace.FRONT);
>                 }
>             }
>             CustomItems.setRenderOffHand((boolean)leftHanded);
320a422
>             CustomItems.setRenderOffHand((boolean)false);
338a441
>         this.renderItemGui = true;
349c452,456
<         bakedmodel = ForgeHooksClient.handleCameraTransforms((IBakedModel)bakedmodel, (ItemCameraTransforms.TransformType)ItemCameraTransforms.TransformType.GUI, (boolean)false);
---
>         if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
>             bakedmodel = (IBakedModel)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_handleCameraTransforms, (Object[])new Object[]{bakedmodel, ItemCameraTransforms.TransformType.GUI, false});
>         } else {
>             bakedmodel.getItemCameraTransforms().applyTransform(ItemCameraTransforms.TransformType.GUI);
>         }
356a464
>         this.renderItemGui = false;
385c493,495
<                 crashreportcategory.addDetail("Registry Name", () -> String.valueOf((Object)p_184391_2_.getItem().getRegistryName()));
---
>                 if (Reflector.IForgeRegistryEntry_Impl_getRegistryName.exists()) {
>                     crashreportcategory.addDetail("Registry Name", ReflectorForge.getDetailItemRegistryName((Item)p_184391_2_.getItem()));
>                 }
413c523,525
<             if (stack.getItem().showDurabilityBar(stack)) {
---
>             if (ReflectorForge.isItemDamaged((ItemStack)stack)) {
>                 int rgbfordisplay;
>                 double health;
421,424c533,555
<                 double health = stack.getItem().getDurabilityForDisplay(stack);
<                 int rgbfordisplay = stack.getItem().getRGBDurabilityForDisplay(stack);
<                 int i = Math.round((float)(13.0f - (float)health * 13.0f));
<                 int j = rgbfordisplay;
---
>                 float f = stack.getItemDamage();
>                 float f1 = stack.getMaxDamage();
>                 float f2 = Math.max((float)0.0f, (float)((f1 - f) / f1));
>                 int i = Math.round((float)(13.0f - f * 13.0f / f1));
>                 int j = MathHelper.hsvToRGB((float)(f2 / 3.0f), (float)1.0f, (float)1.0f);
>                 if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
>                     health = Reflector.callDouble((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getDurabilityForDisplay, (Object[])new Object[]{stack});
>                     rgbfordisplay = Reflector.callInt((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getRGBDurabilityForDisplay, (Object[])new Object[]{stack});
>                     i = Math.round((float)(13.0f - (float)health * 13.0f));
>                     j = rgbfordisplay;
>                 }
>                 if (Config.isCustomColors()) {
>                     j = CustomColors.getDurabilityColor((float)f2, (int)j);
>                 }
>                 if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
>                     health = Reflector.callDouble((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getDurabilityForDisplay, (Object[])new Object[]{stack});
>                     rgbfordisplay = Reflector.callInt((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getRGBDurabilityForDisplay, (Object[])new Object[]{stack});
>                     i = Math.round((float)(13.0f - (float)health * 13.0f));
>                     j = rgbfordisplay;
>                 }
>                 if (Config.isCustomColors()) {
>                     j = CustomColors.getDurabilityColor((float)f2, (int)j);
>                 }
1050c1181,1183
<         ModelLoader.onRegisterItems((ItemModelMesher)this.itemModelMesher);
---
>         if (Reflector.ModelLoader_onRegisterItems.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.ModelLoader_onRegisterItems, (Object[])new Object[]{this.itemModelMesher});
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/RenderList.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/RenderList.java
4a5,6
>  *  Config
>  *  java.lang.Integer
5a8
>  *  java.nio.IntBuffer
6a10
>  *  net.minecraft.client.renderer.GLAllocation
13a18
> import java.nio.IntBuffer;
14a20
> import net.minecraft.client.renderer.GLAllocation;
22,31c28,71
<     public void renderChunkLayer(BlockRenderLayer blockRenderLayer) {
<         if (!this.initialized) {
<             return;
<         }
<         for (RenderChunk renderChunk : this.renderChunks) {
<             ListedRenderChunk listedRenderChunk = (ListedRenderChunk)renderChunk;
<             GlStateManager.pushMatrix();
<             this.preRenderChunk(renderChunk);
<             GlStateManager.callList((int)listedRenderChunk.getDisplayList(blockRenderLayer, listedRenderChunk.h()));
<             GlStateManager.popMatrix();
---
>     private double viewEntityX;
>     private double viewEntityY;
>     private double viewEntityZ;
>     IntBuffer bufferLists = GLAllocation.createDirectIntBuffer((int)16);
> 
>     public void renderChunkLayer(BlockRenderLayer layer) {
>         if (this.initialized) {
>             if (Config.isRenderRegions()) {
>                 int regionX = Integer.MIN_VALUE;
>                 int regionZ = Integer.MIN_VALUE;
>                 for (RenderChunk renderchunk : this.renderChunks) {
>                     ListedRenderChunk listedrenderchunk = (ListedRenderChunk)renderchunk;
>                     if (regionX != renderchunk.regionX || regionZ != renderchunk.regionZ) {
>                         if (this.bufferLists.position() > 0) {
>                             this.drawRegion(regionX, regionZ, this.bufferLists);
>                         }
>                         regionX = renderchunk.regionX;
>                         regionZ = renderchunk.regionZ;
>                     }
>                     if (this.bufferLists.position() >= this.bufferLists.capacity()) {
>                         IntBuffer bufferListsNew = GLAllocation.createDirectIntBuffer((int)(this.bufferLists.capacity() * 2));
>                         this.bufferLists.flip();
>                         bufferListsNew.put(this.bufferLists);
>                         this.bufferLists = bufferListsNew;
>                     }
>                     this.bufferLists.put(listedrenderchunk.getDisplayList(layer, listedrenderchunk.h()));
>                 }
>                 if (this.bufferLists.position() > 0) {
>                     this.drawRegion(regionX, regionZ, this.bufferLists);
>                 }
>             } else {
>                 for (RenderChunk renderchunk : this.renderChunks) {
>                     ListedRenderChunk listedrenderchunk = (ListedRenderChunk)renderchunk;
>                     GlStateManager.pushMatrix();
>                     this.preRenderChunk(renderchunk);
>                     GlStateManager.callList((int)listedrenderchunk.getDisplayList(layer, listedrenderchunk.h()));
>                     GlStateManager.popMatrix();
>                 }
>             }
>             if (Config.isMultiTexture()) {
>                 GlStateManager.bindCurrentTexture();
>             }
>             GlStateManager.resetColor();
>             this.renderChunks.clear();
33,34c73,92
<         GlStateManager.resetColor();
<         this.renderChunks.clear();
---
>     }
> 
>     public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
>         this.viewEntityX = viewEntityXIn;
>         this.viewEntityY = viewEntityYIn;
>         this.viewEntityZ = viewEntityZIn;
>         super.initialize(viewEntityXIn, viewEntityYIn, viewEntityZIn);
>     }
> 
>     private void drawRegion(int regionX, int regionZ, IntBuffer buffer) {
>         GlStateManager.pushMatrix();
>         this.preRenderRegion(regionX, 0, regionZ);
>         buffer.flip();
>         GlStateManager.callLists((IntBuffer)buffer);
>         buffer.clear();
>         GlStateManager.popMatrix();
>     }
> 
>     public void preRenderRegion(int x, int y, int z) {
>         GlStateManager.translate((float)((float)((double)x - this.viewEntityX)), (float)((float)((double)y - this.viewEntityY)), (float)((float)((double)z - this.viewEntityZ)));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/Tessellator.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/Tessellator.java
5a6
>  *  java.util.BitSet
7a9
>  *  net.optifine.SmartAnimations
10a13
> import java.util.BitSet;
12a16
> import net.optifine.SmartAnimations;
23,24c27,28
<     public Tessellator(int n) {
<         this.buffer = new BufferBuilder(n);
---
>     public Tessellator(int bufferSize) {
>         this.buffer = new BufferBuilder(bufferSize);
27a32,34
>         if (this.buffer.animatedSprites != null) {
>             SmartAnimations.spritesRendered((BitSet)this.buffer.animatedSprites);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ThreadDownloadImageData$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ThreadDownloadImageData$1.java
4a5
>  *  Config
12d12
<  *  java.lang.Throwable
39,40c39,40
<     ThreadDownloadImageData.1(String string) {
<         super(string);
---
>     ThreadDownloadImageData.1(String x0) {
>         super(x0);
44c44
<         HttpURLConnection httpURLConnection = null;
---
>         HttpURLConnection httpurlconnection = null;
45a46,49
>         if (ThreadDownloadImageData.access$300((ThreadDownloadImageData)ThreadDownloadImageData.this)) {
>             ThreadDownloadImageData.access$400((ThreadDownloadImageData)ThreadDownloadImageData.this);
>             return;
>         }
47,52c51,66
<             BufferedImage \u26032;
<             httpURLConnection = (HttpURLConnection)new URL(ThreadDownloadImageData.access$000((ThreadDownloadImageData)ThreadDownloadImageData.this)).openConnection(Minecraft.getMinecraft().getProxy());
<             httpURLConnection.setDoInput(true);
<             httpURLConnection.setDoOutput(false);
<             httpURLConnection.connect();
<             if (httpURLConnection.getResponseCode() / 100 != 2) {
---
>             httpurlconnection = (HttpURLConnection)new URL(ThreadDownloadImageData.access$000((ThreadDownloadImageData)ThreadDownloadImageData.this)).openConnection(Minecraft.getMinecraft().getProxy());
>             httpurlconnection.setDoInput(true);
>             httpurlconnection.setDoOutput(false);
>             httpurlconnection.connect();
>             if (httpurlconnection.getResponseCode() / 100 == 2) {
>                 BufferedImage bufferedimage;
>                 if (ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this) != null) {
>                     FileUtils.copyInputStreamToFile((InputStream)httpurlconnection.getInputStream(), (File)ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this));
>                     bufferedimage = ImageIO.read((File)ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this));
>                 } else {
>                     bufferedimage = TextureUtil.readBufferedImage((InputStream)httpurlconnection.getInputStream());
>                 }
>                 if (ThreadDownloadImageData.access$300((ThreadDownloadImageData)ThreadDownloadImageData.this) != null) {
>                     bufferedimage = ThreadDownloadImageData.access$300((ThreadDownloadImageData)ThreadDownloadImageData.this).parseUserSkin(bufferedimage);
>                 }
>                 ThreadDownloadImageData.this.setBufferedImage(bufferedimage);
55,62c69,70
<             if (ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this) != null) {
<                 FileUtils.copyInputStreamToFile((InputStream)httpURLConnection.getInputStream(), (File)ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this));
<                 \u26032 = ImageIO.read((File)ThreadDownloadImageData.access$100((ThreadDownloadImageData)ThreadDownloadImageData.this));
<             } else {
<                 \u26032 = TextureUtil.readBufferedImage((InputStream)httpURLConnection.getInputStream());
<             }
<             if (ThreadDownloadImageData.access$300((ThreadDownloadImageData)ThreadDownloadImageData.this) != null) {
<                 \u26032 = ThreadDownloadImageData.access$300((ThreadDownloadImageData)ThreadDownloadImageData.this).parseUserSkin(\u26032);
---
>             if (httpurlconnection.getErrorStream() != null) {
>                 Config.readAll((InputStream)httpurlconnection.getErrorStream());
64d71
<             ThreadDownloadImageData.this.setBufferedImage(\u26032);
67c74,75
<             ThreadDownloadImageData.access$200().error("Couldn't download http texture", (Throwable)exception);
---
>             ThreadDownloadImageData.access$200().error("Couldn't download http texture: " + exception.getMessage());
>             return;
70,71c78,79
<             if (httpURLConnection != null) {
<                 httpURLConnection.disconnect();
---
>             if (httpurlconnection != null) {
>                 httpurlconnection.disconnect();
72a81
>             ThreadDownloadImageData.access$600((ThreadDownloadImageData)ThreadDownloadImageData.this);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ThreadDownloadImageData.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ThreadDownloadImageData.java
4a5
>  *  Config
5a7
>  *  java.io.ByteArrayInputStream
7a10,12
>  *  java.io.InputStream
>  *  java.lang.Boolean
>  *  java.lang.Exception
10a16,17
>  *  java.net.Proxy
>  *  java.net.Proxy$Type
13a21
>  *  net.minecraft.client.Minecraft
18a27,33
>  *  net.optifine.http.HttpPipeline
>  *  net.optifine.http.HttpRequest
>  *  net.optifine.http.HttpResponse
>  *  net.optifine.player.CapeImageBuffer
>  *  net.optifine.shaders.MultiTexID
>  *  net.optifine.shaders.ShadersTex
>  *  org.apache.commons.io.FileUtils
24a40
> import java.io.ByteArrayInputStream;
26a43,44
> import java.io.InputStream;
> import java.net.Proxy;
29a48
> import net.minecraft.client.Minecraft;
34a54,60
> import net.optifine.http.HttpPipeline;
> import net.optifine.http.HttpRequest;
> import net.optifine.http.HttpResponse;
> import net.optifine.player.CapeImageBuffer;
> import net.optifine.shaders.MultiTexID;
> import net.optifine.shaders.ShadersTex;
> import org.apache.commons.io.FileUtils;
51a78,79
>     public Boolean imageFound = null;
>     public boolean pipeline = false;
53,57c81,85
<     public ThreadDownloadImageData(@Nullable File file, String string, ResourceLocation resourceLocation, @Nullable IImageBuffer iImageBuffer) {
<         super(resourceLocation);
<         this.cacheFile = file;
<         this.imageUrl = string;
<         this.imageBuffer = iImageBuffer;
---
>     public ThreadDownloadImageData(@Nullable File cacheFileIn, String imageUrlIn, ResourceLocation textureResourceLocation, @Nullable IImageBuffer imageBufferIn) {
>         super(textureResourceLocation);
>         this.cacheFile = cacheFileIn;
>         this.imageUrl = imageUrlIn;
>         this.imageBuffer = imageBufferIn;
61,64c89,90
<         if (this.textureUploaded) {
<             return;
<         }
<         if (this.bufferedImage != null) {
---
>         if (!this.textureUploaded && this.bufferedImage != null) {
>             this.textureUploaded = true;
68,69c94,98
<             TextureUtil.uploadTextureImage((int)super.getGlTextureId(), (BufferedImage)this.bufferedImage);
<             this.textureUploaded = true;
---
>             if (Config.isShaders()) {
>                 ShadersTex.loadSimpleTexture((int)super.getGlTextureId(), (BufferedImage)this.bufferedImage, (boolean)false, (boolean)false, (IResourceManager)Config.getResourceManager(), (ResourceLocation)this.textureLocation, (MultiTexID)this.getMultiTexID());
>             } else {
>                 TextureUtil.uploadTextureImage((int)super.getGlTextureId(), (BufferedImage)this.bufferedImage);
>             }
78,79c107,108
<     public void setBufferedImage(BufferedImage bufferedImage) {
<         this.bufferedImage = bufferedImage;
---
>     public void setBufferedImage(BufferedImage bufferedImageIn) {
>         this.bufferedImage = bufferedImageIn;
82a112
>         this.imageFound = this.bufferedImage != null;
85c115
<     public void loadTexture(IResourceManager iResourceManager) throws IOException {
---
>     public void loadTexture(IResourceManager resourceManager) throws IOException {
87c117
<             super.loadTexture(iResourceManager);
---
>             super.loadTexture(resourceManager);
96a127
>                     this.loadingFinished();
98,99c129,130
<                 catch (IOException iOException) {
<                     LOGGER.error("Couldn't load skin {}", (Object)this.cacheFile, (Object)iOException);
---
>                 catch (IOException ioexception) {
>                     LOGGER.error("Couldn't load skin {}", (Object)this.cacheFile, (Object)ioexception);
114,115c145,198
<     static /* synthetic */ String access$000(ThreadDownloadImageData threadDownloadImageData) {
<         return threadDownloadImageData.imageUrl;
---
>     private boolean shouldPipeline() {
>         if (!this.pipeline) {
>             return false;
>         }
>         Proxy proxy = Minecraft.getMinecraft().getProxy();
>         if (proxy.type() != Proxy.Type.DIRECT && proxy.type() != Proxy.Type.SOCKS) {
>             return false;
>         }
>         return this.imageUrl.startsWith("http://");
>     }
> 
>     /*
>      * WARNING - Removed try catching itself - possible behaviour change.
>      */
>     private void loadPipelined() {
>         try {
>             HttpRequest req = HttpPipeline.makeRequest((String)this.imageUrl, (Proxy)Minecraft.getMinecraft().getProxy());
>             HttpResponse resp = HttpPipeline.executeRequest((HttpRequest)req);
>             if (resp.getStatus() / 100 == 2) {
>                 BufferedImage var2;
>                 byte[] body = resp.getBody();
>                 ByteArrayInputStream bais = new ByteArrayInputStream(body);
>                 if (this.cacheFile != null) {
>                     FileUtils.copyInputStreamToFile((InputStream)bais, (File)this.cacheFile);
>                     var2 = ImageIO.read((File)this.cacheFile);
>                 } else {
>                     var2 = TextureUtil.readBufferedImage((InputStream)bais);
>                 }
>                 if (this.imageBuffer != null) {
>                     var2 = this.imageBuffer.parseUserSkin(var2);
>                 }
>                 this.setBufferedImage(var2);
>                 return;
>             }
>         }
>         catch (Exception var6) {
>             LOGGER.error("Couldn't download http texture: " + var6.getClass().getName() + ": " + var6.getMessage());
>             return;
>         }
>         finally {
>             this.loadingFinished();
>         }
>     }
> 
>     private void loadingFinished() {
>         this.imageFound = this.bufferedImage != null;
>         if (this.imageBuffer instanceof CapeImageBuffer) {
>             CapeImageBuffer cib = (CapeImageBuffer)this.imageBuffer;
>             cib.cleanup();
>         }
>     }
> 
>     public IImageBuffer getImageBuffer() {
>         return this.imageBuffer;
118,119c201,206
<     static /* synthetic */ File access$100(ThreadDownloadImageData threadDownloadImageData) {
<         return threadDownloadImageData.cacheFile;
---
>     static /* synthetic */ String access$000(ThreadDownloadImageData x0) {
>         return x0.imageUrl;
>     }
> 
>     static /* synthetic */ File access$100(ThreadDownloadImageData x0) {
>         return x0.cacheFile;
126,127c213,226
<     static /* synthetic */ IImageBuffer access$300(ThreadDownloadImageData threadDownloadImageData) {
<         return threadDownloadImageData.imageBuffer;
---
>     static /* synthetic */ boolean access$300(ThreadDownloadImageData x0) {
>         return x0.shouldPipeline();
>     }
> 
>     static /* synthetic */ void access$400(ThreadDownloadImageData x0) {
>         x0.loadPipelined();
>     }
> 
>     static /* synthetic */ IImageBuffer access$300(ThreadDownloadImageData x0) {
>         return x0.imageBuffer;
>     }
> 
>     static /* synthetic */ void access$600(ThreadDownloadImageData x0) {
>         x0.loadingFinished();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/VboRenderList.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/VboRenderList.java
4a5,6
>  *  Config
>  *  java.lang.Integer
11a14,15
>  *  net.optifine.render.VboRegion
>  *  net.optifine.shaders.ShadersRender
20a25,26
> import net.optifine.render.VboRegion;
> import net.optifine.shaders.ShadersRender;
24,36c30,70
<     public void renderChunkLayer(BlockRenderLayer blockRenderLayer) {
<         if (!this.initialized) {
<             return;
<         }
<         for (RenderChunk renderChunk : this.renderChunks) {
<             VertexBuffer vertexBuffer = renderChunk.getVertexBufferByLayer(blockRenderLayer.ordinal());
<             GlStateManager.pushMatrix();
<             this.preRenderChunk(renderChunk);
<             renderChunk.multModelviewMatrix();
<             vertexBuffer.bindBuffer();
<             this.setupArrayPointers();
<             vertexBuffer.drawArrays(7);
<             GlStateManager.popMatrix();
---
>     private double viewEntityX;
>     private double viewEntityY;
>     private double viewEntityZ;
> 
>     public void renderChunkLayer(BlockRenderLayer layer) {
>         if (this.initialized) {
>             if (Config.isRenderRegions()) {
>                 int regionX = Integer.MIN_VALUE;
>                 int regionZ = Integer.MIN_VALUE;
>                 VboRegion lastVboRegion = null;
>                 for (RenderChunk renderchunk : this.renderChunks) {
>                     VertexBuffer vertexbuffer = renderchunk.getVertexBufferByLayer(layer.ordinal());
>                     VboRegion vboRegion = vertexbuffer.getVboRegion();
>                     if (vboRegion != lastVboRegion || regionX != renderchunk.regionX || regionZ != renderchunk.regionZ) {
>                         if (lastVboRegion != null) {
>                             this.drawRegion(regionX, regionZ, lastVboRegion);
>                         }
>                         regionX = renderchunk.regionX;
>                         regionZ = renderchunk.regionZ;
>                         lastVboRegion = vboRegion;
>                     }
>                     vertexbuffer.drawArrays(7);
>                 }
>                 if (lastVboRegion != null) {
>                     this.drawRegion(regionX, regionZ, lastVboRegion);
>                 }
>             } else {
>                 for (RenderChunk renderchunk : this.renderChunks) {
>                     VertexBuffer vertexbuffer = renderchunk.getVertexBufferByLayer(layer.ordinal());
>                     GlStateManager.pushMatrix();
>                     this.preRenderChunk(renderchunk);
>                     renderchunk.multModelviewMatrix();
>                     vertexbuffer.bindBuffer();
>                     this.setupArrayPointers();
>                     vertexbuffer.drawArrays(7);
>                     GlStateManager.popMatrix();
>                 }
>             }
>             OpenGlHelper.glBindBuffer((int)OpenGlHelper.GL_ARRAY_BUFFER, (int)0);
>             GlStateManager.resetColor();
>             this.renderChunks.clear();
38,40d71
<         OpenGlHelper.glBindBuffer((int)OpenGlHelper.GL_ARRAY_BUFFER, (int)0);
<         GlStateManager.resetColor();
<         this.renderChunks.clear();
43c74,78
<     private void setupArrayPointers() {
---
>     public void setupArrayPointers() {
>         if (Config.isShaders()) {
>             ShadersRender.setupArrayPointersVbo();
>             return;
>         }
49a85,102
>     }
> 
>     public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
>         this.viewEntityX = viewEntityXIn;
>         this.viewEntityY = viewEntityYIn;
>         this.viewEntityZ = viewEntityZIn;
>         super.initialize(viewEntityXIn, viewEntityYIn, viewEntityZIn);
>     }
> 
>     private void drawRegion(int regionX, int regionZ, VboRegion vboRegion) {
>         GlStateManager.pushMatrix();
>         this.preRenderRegion(regionX, 0, regionZ);
>         vboRegion.finishDraw(this);
>         GlStateManager.popMatrix();
>     }
> 
>     public void preRenderRegion(int x, int y, int z) {
>         GlStateManager.translate((float)((float)((double)x - this.viewEntityX)), (float)((float)((double)y - this.viewEntityY)), (float)((float)((double)z - this.viewEntityZ)));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/VertexBufferUploader.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/VertexBufferUploader.java
4a5
>  *  Config
20,22c21,27
<     public void draw(BufferBuilder bufferBuilder) {
<         bufferBuilder.reset();
<         this.vertexBuffer.bufferData(bufferBuilder.getByteBuffer());
---
>     public void draw(BufferBuilder vertexBufferIn) {
>         if (vertexBufferIn.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
>             vertexBufferIn.quadsToTriangles();
>             this.vertexBuffer.setDrawMode(vertexBufferIn.getDrawMode());
>         }
>         this.vertexBuffer.bufferData(vertexBufferIn.getByteBuffer());
>         vertexBufferIn.reset();
25,26c30,31
<     public void setVertexBuffer(VertexBuffer vertexBuffer) {
<         this.vertexBuffer = vertexBuffer;
---
>     public void setVertexBuffer(VertexBuffer vertexBufferIn) {
>         this.vertexBuffer = vertexBufferIn;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/ViewFrustum.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/ViewFrustum.java
4a5
>  *  Config
5a7,9
>  *  java.util.HashMap
>  *  java.util.Map
>  *  java.util.Set
9a14,15
>  *  net.minecraft.util.BlockRenderLayer
>  *  net.minecraft.util.EnumFacing
10a17
>  *  net.minecraft.util.math.ChunkPos
12a20
>  *  net.optifine.render.VboRegion
15a24,26
> import java.util.HashMap;
> import java.util.Map;
> import java.util.Set;
19a31,32
> import net.minecraft.util.BlockRenderLayer;
> import net.minecraft.util.EnumFacing;
20a34
> import net.minecraft.util.math.ChunkPos;
22a37
> import net.optifine.render.VboRegion;
30a46
>     private Map<ChunkPos, VboRegion[]> mapVboRegions = new HashMap();
32,48c48,67
<     public ViewFrustum(World world, int n, RenderGlobal renderGlobal, IRenderChunkFactory iRenderChunkFactory) {
<         this.renderGlobal = renderGlobal;
<         this.world = world;
<         this.setCountChunksXYZ(n);
<         this.createRenderChunks(iRenderChunkFactory);
<     }
< 
<     protected void createRenderChunks(IRenderChunkFactory iRenderChunkFactory) {
<         int n = this.countChunksX * this.countChunksY * this.countChunksZ;
<         this.renderChunks = new RenderChunk[n];
<         \u2603 = 0;
<         for (\u2603 = 0; \u2603 < this.countChunksX; ++\u2603) {
<             for (\u2603 = 0; \u2603 < this.countChunksY; ++\u2603) {
<                 for (\u2603 = 0; \u2603 < this.countChunksZ; ++\u2603) {
<                     \u2603 = (\u2603 * this.countChunksY + \u2603) * this.countChunksX + \u2603;
<                     this.renderChunks[\u2603] = iRenderChunkFactory.create(this.world, this.renderGlobal, \u2603++);
<                     this.renderChunks[\u2603].setPosition(\u2603 * 16, \u2603 * 16, \u2603 * 16);
---
>     public ViewFrustum(World worldIn, int renderDistanceChunks, RenderGlobal renderGlobalIn, IRenderChunkFactory renderChunkFactory) {
>         this.renderGlobal = renderGlobalIn;
>         this.world = worldIn;
>         this.setCountChunksXYZ(renderDistanceChunks);
>         this.createRenderChunks(renderChunkFactory);
>     }
> 
>     protected void createRenderChunks(IRenderChunkFactory renderChunkFactory) {
>         int k;
>         int i = this.countChunksX * this.countChunksY * this.countChunksZ;
>         this.renderChunks = new RenderChunk[i];
>         int j = 0;
>         for (k = 0; k < this.countChunksX; ++k) {
>             for (int l = 0; l < this.countChunksY; ++l) {
>                 for (int i1 = 0; i1 < this.countChunksZ; ++i1) {
>                     int j1 = (i1 * this.countChunksY + l) * this.countChunksX + k;
>                     this.renderChunks[j1] = renderChunkFactory.create(this.world, this.renderGlobal, j++);
>                     this.renderChunks[j1].setPosition(k * 16, l * 16, i1 * 16);
>                     if (!Config.isVbo() || !Config.isRenderRegions()) continue;
>                     this.updateVboRegion(this.renderChunks[j1]);
51a71,79
>         for (k = 0; k < this.renderChunks.length; ++k) {
>             RenderChunk renderChunk = this.renderChunks[k];
>             for (int l = 0; l < EnumFacing.VALUES.length; ++l) {
>                 EnumFacing facing = EnumFacing.VALUES[l];
>                 BlockPos posOffset16 = renderChunk.getBlockPosOffset16(facing);
>                 RenderChunk neighbour = this.getRenderChunk(posOffset16);
>                 renderChunk.setRenderChunkNeighbour(facing, neighbour);
>             }
>         }
55,56c83,84
<         for (RenderChunk renderChunk : this.renderChunks) {
<             renderChunk.deleteGlResources();
---
>         for (RenderChunk renderchunk : this.renderChunks) {
>             renderchunk.deleteGlResources();
57a86
>         this.deleteVboRegions();
60,61c89,91
<     protected void setCountChunksXYZ(int n) {
<         this.countChunksX = \u2603 = n * 2 + 1;
---
>     protected void setCountChunksXYZ(int renderDistanceChunks) {
>         int i;
>         this.countChunksX = i = renderDistanceChunks * 2 + 1;
63c93
<         this.countChunksZ = \u2603;
---
>         this.countChunksZ = i;
66,77c96,107
<     public void updateChunkPositions(double d, double d2) {
<         int n = MathHelper.floor((double)d) - 8;
<         \u2603 = MathHelper.floor((double)d2) - 8;
<         \u2603 = this.countChunksX * 16;
<         for (\u2603 = 0; \u2603 < this.countChunksX; ++\u2603) {
<             \u2603 = this.getBaseCoordinate(n, \u2603, \u2603);
<             for (\u2603 = 0; \u2603 < this.countChunksZ; ++\u2603) {
<                 \u2603 = this.getBaseCoordinate(\u2603, \u2603, \u2603);
<                 for (\u2603 = 0; \u2603 < this.countChunksY; ++\u2603) {
<                     \u2603 = \u2603 * 16;
<                     RenderChunk renderChunk = this.renderChunks[(\u2603 * this.countChunksY + \u2603) * this.countChunksX + \u2603];
<                     renderChunk.setPosition(\u2603, \u2603, \u2603);
---
>     public void updateChunkPositions(double viewEntityX, double viewEntityZ) {
>         int i = MathHelper.floor((double)viewEntityX) - 8;
>         int j = MathHelper.floor((double)viewEntityZ) - 8;
>         int k = this.countChunksX * 16;
>         for (int l = 0; l < this.countChunksX; ++l) {
>             int i1 = this.getBaseCoordinate(i, k, l);
>             for (int j1 = 0; j1 < this.countChunksZ; ++j1) {
>                 int k1 = this.getBaseCoordinate(j, k, j1);
>                 for (int l1 = 0; l1 < this.countChunksY; ++l1) {
>                     int i2 = l1 * 16;
>                     RenderChunk renderchunk = this.renderChunks[(j1 * this.countChunksY + l1) * this.countChunksX + l];
>                     renderchunk.setPosition(i1, i2, k1);
83,107c113,137
<     private int getBaseCoordinate(int n, int n2, int n3) {
<         \u2603 = n3 * 16;
<         \u2603 = \u2603 - n + n2 / 2;
<         if (\u2603 < 0) {
<             \u2603 -= n2 - 1;
<         }
<         return \u2603 - \u2603 / n2 * n2;
<     }
< 
<     public void markBlocksForUpdate(int n, int n2, int n3, int n4, int n5, int n6, boolean bl) {
<         int n7 = MathHelper.intFloorDiv((int)n, (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)n2, (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)n3, (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)n4, (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)n5, (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)n6, (int)16);
<         for (\u2603 = n7; \u2603 <= \u2603; ++\u2603) {
<             \u2603 = \u2603 % this.countChunksX;
<             if (\u2603 < 0) {
<                 \u2603 += this.countChunksX;
<             }
<             for (\u2603 = \u2603; \u2603 <= \u2603; ++\u2603) {
<                 \u2603 = \u2603 % this.countChunksY;
<                 if (\u2603 < 0) {
<                     \u2603 += this.countChunksY;
---
>     private int getBaseCoordinate(int p_178157_1_, int p_178157_2_, int p_178157_3_) {
>         int i = p_178157_3_ * 16;
>         int j = i - p_178157_1_ + p_178157_2_ / 2;
>         if (j < 0) {
>             j -= p_178157_2_ - 1;
>         }
>         return i - j / p_178157_2_ * p_178157_2_;
>     }
> 
>     public void markBlocksForUpdate(int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean updateImmediately) {
>         int i = MathHelper.intFloorDiv((int)minX, (int)16);
>         int j = MathHelper.intFloorDiv((int)minY, (int)16);
>         int k = MathHelper.intFloorDiv((int)minZ, (int)16);
>         int l = MathHelper.intFloorDiv((int)maxX, (int)16);
>         int i1 = MathHelper.intFloorDiv((int)maxY, (int)16);
>         int j1 = MathHelper.intFloorDiv((int)maxZ, (int)16);
>         for (int k1 = i; k1 <= l; ++k1) {
>             int l1 = k1 % this.countChunksX;
>             if (l1 < 0) {
>                 l1 += this.countChunksX;
>             }
>             for (int i2 = j; i2 <= i1; ++i2) {
>                 int j2 = i2 % this.countChunksY;
>                 if (j2 < 0) {
>                     j2 += this.countChunksY;
109,112c139,142
<                 for (\u2603 = \u2603; \u2603 <= \u2603; ++\u2603) {
<                     \u2603 = \u2603 % this.countChunksZ;
<                     if (\u2603 < 0) {
<                         \u2603 += this.countChunksZ;
---
>                 for (int k2 = k; k2 <= j1; ++k2) {
>                     int l2 = k2 % this.countChunksZ;
>                     if (l2 < 0) {
>                         l2 += this.countChunksZ;
114,116c144,146
<                     \u2603 = (\u2603 * this.countChunksY + \u2603) * this.countChunksX + \u2603;
<                     RenderChunk renderChunk = this.renderChunks[\u2603];
<                     renderChunk.setNeedsUpdate(bl);
---
>                     int i3 = (l2 * this.countChunksY + j2) * this.countChunksX + l1;
>                     RenderChunk renderchunk = this.renderChunks[i3];
>                     renderchunk.setNeedsUpdate(updateImmediately);
123,128c153,165
<     protected RenderChunk getRenderChunk(BlockPos blockPos) {
<         int n = MathHelper.intFloorDiv((int)blockPos.p(), (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)blockPos.q(), (int)16);
<         \u2603 = MathHelper.intFloorDiv((int)blockPos.r(), (int)16);
<         if (\u2603 < 0 || \u2603 >= this.countChunksY) {
<             return null;
---
>     public RenderChunk getRenderChunk(BlockPos pos) {
>         int i = pos.p() >> 4;
>         int j = pos.q() >> 4;
>         int k = pos.r() >> 4;
>         if (j >= 0 && j < this.countChunksY) {
>             if ((i %= this.countChunksX) < 0) {
>                 i += this.countChunksX;
>             }
>             if ((k %= this.countChunksZ) < 0) {
>                 k += this.countChunksZ;
>             }
>             int l = (k * this.countChunksY + j) * this.countChunksX + i;
>             return this.renderChunks[l];
130,131c167,188
<         if ((n %= this.countChunksX) < 0) {
<             n += this.countChunksX;
---
>         return null;
>     }
> 
>     private void updateVboRegion(RenderChunk renderChunk) {
>         int ix;
>         BlockPos pos = renderChunk.getPosition();
>         int rx = pos.p() >> 8 << 8;
>         int rz = pos.r() >> 8 << 8;
>         ChunkPos cp = new ChunkPos(rx, rz);
>         BlockRenderLayer[] layers = BlockRenderLayer.values();
>         VboRegion[] regions = (VboRegion[])this.mapVboRegions.get((Object)cp);
>         if (regions == null) {
>             regions = new VboRegion[layers.length];
>             for (ix = 0; ix < layers.length; ++ix) {
>                 regions[ix] = new VboRegion(layers[ix]);
>             }
>             this.mapVboRegions.put((Object)cp, (Object)regions);
>         }
>         for (ix = 0; ix < layers.length; ++ix) {
>             VboRegion vr = regions[ix];
>             if (vr == null) continue;
>             renderChunk.getVertexBufferByLayer(ix).setVboRegion(vr);
133,134c190,202
<         if ((\u2603 %= this.countChunksZ) < 0) {
<             \u2603 += this.countChunksZ;
---
>     }
> 
>     public void deleteVboRegions() {
>         Set keys = this.mapVboRegions.keySet();
>         for (ChunkPos cp : keys) {
>             VboRegion[] vboRegions = (VboRegion[])this.mapVboRegions.get((Object)cp);
>             for (int i = 0; i < vboRegions.length; ++i) {
>                 VboRegion vboRegion = vboRegions[i];
>                 if (vboRegion != null) {
>                     vboRegion.deleteGlBuffers();
>                 }
>                 vboRegions[i] = null;
>             }
136,137c204
<         \u2603 = (\u2603 * this.countChunksY + \u2603) * this.countChunksX + n;
<         return this.renderChunks[\u2603];
---
>         this.mapVboRegions.clear();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/WorldVertexBufferUploader.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/WorldVertexBufferUploader.java
4a5
>  *  Config
9a11,12
>  *  net.minecraft.client.renderer.OpenGlHelper
>  *  net.minecraft.client.renderer.WorldVertexBufferUploader$1
13,14c16,18
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.SVertexBuilder
21a26,27
> import net.minecraft.client.renderer.OpenGlHelper;
> import net.minecraft.client.renderer.WorldVertexBufferUploader;
24,25c30,32
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.SVertexBuilder;
27d33
< @SideOnly(value=Side.CLIENT)
29,31c35,40
<     public void draw(BufferBuilder bufferBuilderIn) {
<         if (bufferBuilderIn.getVertexCount() > 0) {
<             VertexFormat vertexformat = bufferBuilderIn.getVertexFormat();
---
>     public void draw(BufferBuilder vertexBufferIn) {
>         if (vertexBufferIn.getVertexCount() > 0) {
>             if (vertexBufferIn.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
>                 vertexBufferIn.quadsToTriangles();
>             }
>             VertexFormat vertexformat = vertexBufferIn.getVertexFormat();
33c42
<             ByteBuffer bytebuffer = bufferBuilderIn.getByteBuffer();
---
>             ByteBuffer bytebuffer = vertexBufferIn.getByteBuffer();
35c44,46
<             for (int j = 0; j < list.size(); ++j) {
---
>             boolean forgePreDrawExists = Reflector.ForgeVertexFormatElementEnumUseage_preDraw.exists();
>             boolean forgePostDrawExists = Reflector.ForgeVertexFormatElementEnumUseage_postDraw.exists();
>             block12: for (int j = 0; j < list.size(); ++j) {
37a49,52
>                 if (forgePreDrawExists) {
>                     Reflector.callVoid((Object)vertexformatelement$enumusage, (ReflectorMethod)Reflector.ForgeVertexFormatElementEnumUseage_preDraw, (Object[])new Object[]{vertexformat, j, i, bytebuffer});
>                     continue;
>                 }
41c56,86
<                 vertexformatelement.getUsage().preDraw(vertexformat, j, i, bytebuffer);
---
>                 switch (1.$SwitchMap$net$minecraft$client$renderer$vertex$VertexFormatElement$EnumUsage[vertexformatelement$enumusage.ordinal()]) {
>                     case 1: {
>                         GlStateManager.glVertexPointer((int)vertexformatelement.getElementCount(), (int)k, (int)i, (ByteBuffer)bytebuffer);
>                         GlStateManager.glEnableClientState((int)32884);
>                         continue block12;
>                     }
>                     case 2: {
>                         OpenGlHelper.setClientActiveTexture((int)(OpenGlHelper.defaultTexUnit + l));
>                         GlStateManager.glTexCoordPointer((int)vertexformatelement.getElementCount(), (int)k, (int)i, (ByteBuffer)bytebuffer);
>                         GlStateManager.glEnableClientState((int)32888);
>                         OpenGlHelper.setClientActiveTexture((int)OpenGlHelper.defaultTexUnit);
>                         continue block12;
>                     }
>                     case 3: {
>                         GlStateManager.glColorPointer((int)vertexformatelement.getElementCount(), (int)k, (int)i, (ByteBuffer)bytebuffer);
>                         GlStateManager.glEnableClientState((int)32886);
>                         continue block12;
>                     }
>                     case 4: {
>                         GlStateManager.glNormalPointer((int)k, (int)i, (ByteBuffer)bytebuffer);
>                         GlStateManager.glEnableClientState((int)32885);
>                     }
>                 }
>             }
>             BufferBuilder wr = vertexBufferIn;
>             if (wr.isMultiTexture()) {
>                 wr.drawMultiTexture();
>             } else if (Config.isShaders()) {
>                 SVertexBuilder.drawArrays((int)vertexBufferIn.getDrawMode(), (int)0, (int)vertexBufferIn.getVertexCount(), (BufferBuilder)vertexBufferIn);
>             } else {
>                 GlStateManager.glDrawArrays((int)vertexBufferIn.getDrawMode(), (int)0, (int)vertexBufferIn.getVertexCount());
43d87
<             GlStateManager.glDrawArrays((int)bufferBuilderIn.getDrawMode(), (int)0, (int)bufferBuilderIn.getVertexCount());
45c89
<             for (int i1 = 0; i1 < j1; ++i1) {
---
>             block13: for (int i1 = 0; i1 < j1; ++i1) {
47a92,95
>                 if (forgePostDrawExists) {
>                     Reflector.callVoid((Object)vertexformatelement$enumusage1, (ReflectorMethod)Reflector.ForgeVertexFormatElementEnumUseage_postDraw, (Object[])new Object[]{vertexformat, i1, i, bytebuffer});
>                     continue;
>                 }
49c97,116
<                 vertexformatelement1.getUsage().postDraw(vertexformat, i1, i, bytebuffer);
---
>                 switch (1.$SwitchMap$net$minecraft$client$renderer$vertex$VertexFormatElement$EnumUsage[vertexformatelement$enumusage1.ordinal()]) {
>                     case 1: {
>                         GlStateManager.glDisableClientState((int)32884);
>                         continue block13;
>                     }
>                     case 2: {
>                         OpenGlHelper.setClientActiveTexture((int)(OpenGlHelper.defaultTexUnit + k1));
>                         GlStateManager.glDisableClientState((int)32888);
>                         OpenGlHelper.setClientActiveTexture((int)OpenGlHelper.defaultTexUnit);
>                         continue block13;
>                     }
>                     case 3: {
>                         GlStateManager.glDisableClientState((int)32886);
>                         GlStateManager.resetColor();
>                         continue block13;
>                     }
>                     case 4: {
>                         GlStateManager.glDisableClientState((int)32885);
>                     }
>                 }
52c119
<         bufferBuilderIn.reset();
---
>         vertexBufferIn.reset();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/BakedQuad.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/BakedQuad.java
5c5,7
<  *  java.lang.Deprecated
---
>  *  Config
>  *  java.lang.Float
>  *  java.lang.Math
6a9,13
>  *  java.lang.String
>  *  java.lang.System
>  *  net.minecraft.client.Minecraft
>  *  net.minecraft.client.renderer.block.model.BakedQuadRetextured
>  *  net.minecraft.client.renderer.block.model.FaceBakery
13,15c20,22
<  *  net.minecraftforge.client.model.pipeline.LightUtil
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.model.QuadBounds
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
18a26,28
> import net.minecraft.client.Minecraft;
> import net.minecraft.client.renderer.block.model.BakedQuadRetextured;
> import net.minecraft.client.renderer.block.model.FaceBakery;
25,27c35,37
< import net.minecraftforge.client.model.pipeline.LightUtil;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.model.QuadBounds;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
29d38
< @SideOnly(value=Side.CLIENT)
32c41
<     protected final int[] vertexData;
---
>     protected int[] vertexData;
34,42c43,50
<     protected final EnumFacing face;
<     protected final TextureAtlasSprite sprite;
<     protected final VertexFormat format;
<     protected final boolean applyDiffuseLighting;
< 
<     @Deprecated
<     public BakedQuad(int[] vertexDataIn, int tintIndexIn, EnumFacing faceIn, TextureAtlasSprite spriteIn) {
<         this(vertexDataIn, tintIndexIn, faceIn, spriteIn, true, DefaultVertexFormats.ITEM);
<     }
---
>     protected EnumFacing face;
>     protected TextureAtlasSprite sprite;
>     private int[] vertexDataSingle = null;
>     protected boolean applyDiffuseLighting = Reflector.ForgeHooksClient_fillNormal.exists();
>     protected VertexFormat format = DefaultVertexFormats.ITEM;
>     private QuadBounds quadBounds;
>     private boolean quadEmissiveChecked;
>     private BakedQuad quadEmissive;
45c53,56
<         this.format = format;
---
>         this.vertexData = vertexDataIn;
>         this.tintIndex = tintIndexIn;
>         this.face = faceIn;
>         this.sprite = spriteIn;
46a58,62
>         this.format = format;
>         this.fixVertexData();
>     }
> 
>     public BakedQuad(int[] vertexDataIn, int tintIndexIn, EnumFacing faceIn, TextureAtlasSprite spriteIn) {
50a67
>         this.fixVertexData();
53a71,73
>         if (this.sprite == null) {
>             this.sprite = BakedQuad.getSpriteByUv(this.getVertexData());
>         }
57a78
>         this.fixVertexData();
69a91,93
>         if (this.face == null) {
>             this.face = FaceBakery.getFacingFromVertexData((int[])this.getVertexData());
>         }
72a97,118
>     public int[] getVertexDataSingle() {
>         if (this.vertexDataSingle == null) {
>             this.vertexDataSingle = BakedQuad.makeVertexDataSingle(this.getVertexData(), this.getSprite());
>         }
>         return this.vertexDataSingle;
>     }
> 
>     private static int[] makeVertexDataSingle(int[] vd, TextureAtlasSprite sprite) {
>         int[] vdSingle = (int[])vd.clone();
>         int step = vdSingle.length / 4;
>         for (int i = 0; i < 4; ++i) {
>             int pos = i * step;
>             float tu = Float.intBitsToFloat((int)vdSingle[pos + 4]);
>             float tv = Float.intBitsToFloat((int)vdSingle[pos + 4 + 1]);
>             float u = sprite.toSingleU(tu);
>             float v = sprite.toSingleV(tv);
>             vdSingle[pos + 4] = Float.floatToRawIntBits((float)u);
>             vdSingle[pos + 4 + 1] = Float.floatToRawIntBits((float)v);
>         }
>         return vdSingle;
>     }
> 
74c120
<         LightUtil.putBakedQuad((IVertexConsumer)consumer, (BakedQuad)this);
---
>         Reflector.callVoid((ReflectorMethod)Reflector.LightUtil_putBakedQuad, (Object[])new Object[]{consumer, this});
82a129,230
>     }
> 
>     private static TextureAtlasSprite getSpriteByUv(int[] vertexData) {
>         float uMin = 1.0f;
>         float vMin = 1.0f;
>         float uMax = 0.0f;
>         float vMax = 0.0f;
>         int step = vertexData.length / 4;
>         for (int i = 0; i < 4; ++i) {
>             int pos = i * step;
>             float tu = Float.intBitsToFloat((int)vertexData[pos + 4]);
>             float tv = Float.intBitsToFloat((int)vertexData[pos + 4 + 1]);
>             uMin = Math.min((float)uMin, (float)tu);
>             vMin = Math.min((float)vMin, (float)tv);
>             uMax = Math.max((float)uMax, (float)tu);
>             vMax = Math.max((float)vMax, (float)tv);
>         }
>         float uMid = (uMin + uMax) / 2.0f;
>         float vMid = (vMin + vMax) / 2.0f;
>         TextureAtlasSprite spriteUv = Minecraft.getMinecraft().getTextureMapBlocks().getIconByUV((double)uMid, (double)vMid);
>         return spriteUv;
>     }
> 
>     protected void fixVertexData() {
>         if (Config.isShaders()) {
>             if (this.vertexData.length == 28) {
>                 this.vertexData = BakedQuad.expandVertexData(this.vertexData);
>             }
>         } else if (this.vertexData.length == 56) {
>             this.vertexData = BakedQuad.compactVertexData(this.vertexData);
>         }
>     }
> 
>     private static int[] expandVertexData(int[] vd) {
>         int step = vd.length / 4;
>         int stepNew = step * 2;
>         int[] vdNew = new int[stepNew * 4];
>         for (int i = 0; i < 4; ++i) {
>             System.arraycopy((Object)vd, (int)(i * step), (Object)vdNew, (int)(i * stepNew), (int)step);
>         }
>         return vdNew;
>     }
> 
>     private static int[] compactVertexData(int[] vd) {
>         int step = vd.length / 4;
>         int stepNew = step / 2;
>         int[] vdNew = new int[stepNew * 4];
>         for (int i = 0; i < 4; ++i) {
>             System.arraycopy((Object)vd, (int)(i * step), (Object)vdNew, (int)(i * stepNew), (int)stepNew);
>         }
>         return vdNew;
>     }
> 
>     public QuadBounds getQuadBounds() {
>         if (this.quadBounds == null) {
>             this.quadBounds = new QuadBounds(this.getVertexData());
>         }
>         return this.quadBounds;
>     }
> 
>     public float getMidX() {
>         QuadBounds qb = this.getQuadBounds();
>         return (qb.getMaxX() + qb.getMinX()) / 2.0f;
>     }
> 
>     public double getMidY() {
>         QuadBounds qb = this.getQuadBounds();
>         return (qb.getMaxY() + qb.getMinY()) / 2.0f;
>     }
> 
>     public double getMidZ() {
>         QuadBounds qb = this.getQuadBounds();
>         return (qb.getMaxZ() + qb.getMinZ()) / 2.0f;
>     }
> 
>     public boolean isFaceQuad() {
>         QuadBounds qb = this.getQuadBounds();
>         return qb.isFaceQuad(this.face);
>     }
> 
>     public boolean isFullQuad() {
>         QuadBounds qb = this.getQuadBounds();
>         return qb.isFullQuad(this.face);
>     }
> 
>     public boolean isFullFaceQuad() {
>         return this.isFullQuad() && this.isFaceQuad();
>     }
> 
>     public BakedQuad getQuadEmissive() {
>         if (this.quadEmissiveChecked) {
>             return this.quadEmissive;
>         }
>         if (this.quadEmissive == null && this.sprite != null && this.sprite.spriteEmissive != null) {
>             this.quadEmissive = new BakedQuadRetextured(this, this.sprite.spriteEmissive);
>         }
>         this.quadEmissiveChecked = true;
>         return this.quadEmissive;
>     }
> 
>     public String toString() {
>         return "vertex: " + this.vertexData.length / 7 + ", tint: " + this.tintIndex + ", facing: " + this.face + ", sprite: " + this.sprite;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java
11,12d10
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
20,21d17
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
23d18
< @SideOnly(value=Side.CLIENT)
26a22
>     private final TextureAtlasSprite spriteOld;
29c25
<         super(Arrays.copyOf((int[])quad.getVertexData(), (int)quad.getVertexData().length), quad.tintIndex, FaceBakery.getFacingFromVertexData((int[])quad.getVertexData()), quad.getSprite(), quad.applyDiffuseLighting, quad.format);
---
>         super(Arrays.copyOf((int[])quad.getVertexData(), (int)quad.getVertexData().length), quad.tintIndex, FaceBakery.getFacingFromVertexData((int[])quad.getVertexData()), textureIn, quad.applyDiffuseLighting, quad.format);
30a27,29
>         this.format = quad.format;
>         this.applyDiffuseLighting = quad.applyDiffuseLighting;
>         this.spriteOld = quad.getSprite();
31a31
>         this.fixVertexData();
38,39c38,39
<             this.vertexData[j + uvIndex] = Float.floatToRawIntBits((float)this.texture.getInterpolatedU((double)this.sprite.getUnInterpolatedU(Float.intBitsToFloat((int)this.vertexData[j + uvIndex]))));
<             this.vertexData[j + uvIndex + 1] = Float.floatToRawIntBits((float)this.texture.getInterpolatedV((double)this.sprite.getUnInterpolatedV(Float.intBitsToFloat((int)this.vertexData[j + uvIndex + 1]))));
---
>             this.vertexData[j + uvIndex] = Float.floatToRawIntBits((float)this.texture.getInterpolatedU((double)this.spriteOld.getUnInterpolatedU(Float.intBitsToFloat((int)this.vertexData[j + uvIndex]))));
>             this.vertexData[j + uvIndex + 1] = Float.floatToRawIntBits((float)this.texture.getInterpolatedV((double)this.spriteOld.getUnInterpolatedV(Float.intBitsToFloat((int)this.vertexData[j + uvIndex + 1]))));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$1.java
14c14
< class FaceBakery.1
---
> static final class FaceBakery.1
16a17
>         super(null);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$2.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$2.java
14c14
< class FaceBakery.2
---
> static final class FaceBakery.2
16a17
>         super(null);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$3.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$3.java
14c14
< class FaceBakery.3
---
> static final class FaceBakery.3
16a17
>         super(null);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$4.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$4.java
14c14
< class FaceBakery.4
---
> static final class FaceBakery.4
16a17
>         super(null);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$Rotation.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery$Rotation.java
7,8d6
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
13,14d10
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
16d11
< @SideOnly(value=Side.CLIENT)
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/FaceBakery.java
4a5
>  *  Config
10d10
<  *  javax.vecmath.Matrix4f
26d25
<  *  net.minecraftforge.client.ForgeHooksClient
28,29c27,30
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.model.BlockModelUtils
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
50d50
< import net.minecraftforge.client.ForgeHooksClient;
52,53c52,55
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.model.BlockModelUtils;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
59d60
< @SideOnly(value=Side.CLIENT)
76c77
<             blockfaceuv = ForgeHooksClient.applyUVLock((BlockFaceUV)face.blockFaceUV, (EnumFacing)facing, (ITransformation)modelRotationIn);
---
>             blockfaceuv = Reflector.ForgeHooksClient_applyUVLock.exists() ? (BlockFaceUV)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_applyUVLock, (Object[])new Object[]{face.blockFaceUV, facing, modelRotationIn}) : this.applyUVLock(face.blockFaceUV, facing, (ModelRotation)modelRotationIn);
78c79,80
<         int[] aint = this.makeQuadVertexData(blockfaceuv, sprite, facing, this.getPositionsDiv16(posFrom, posTo), modelRotationIn, partRotation, false);
---
>         boolean quadShade = shade && !Reflector.ForgeHooksClient_fillNormal.exists();
>         int[] aint = this.makeQuadVertexData(blockfaceuv, sprite, facing, this.getPositionsDiv16(posFrom, posTo), modelRotationIn, partRotation, quadShade);
83,84c85,89
<         ForgeHooksClient.fillNormal((int[])aint, (EnumFacing)enumfacing);
<         return new BakedQuad(aint, face.tintIndex, enumfacing, sprite, shade, DefaultVertexFormats.ITEM);
---
>         if (Reflector.ForgeHooksClient_fillNormal.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_fillNormal, (Object[])new Object[]{aint, enumfacing});
>             return new BakedQuad(aint, face.tintIndex, enumfacing, sprite, shade, DefaultVertexFormats.ITEM);
>         }
>         return new BakedQuad(aint, face.tintIndex, enumfacing, sprite);
91,96c96,101
<     private int[] makeQuadVertexData(BlockFaceUV uvs, TextureAtlasSprite sprite, EnumFacing orientation, float[] p_188012_4_, ModelRotation rotationIn, @Nullable BlockPartRotation partRotation, boolean shade) {
<         return this.makeQuadVertexData(uvs, sprite, orientation, p_188012_4_, (ITransformation)rotationIn, partRotation, shade);
<     }
< 
<     private int[] makeQuadVertexData(BlockFaceUV uvs, TextureAtlasSprite sprite, EnumFacing orientation, float[] p_188012_4_, ITransformation rotationIn, BlockPartRotation partRotation, boolean shade) {
<         int[] aint = new int[28];
---
>     private int[] makeQuadVertexData(BlockFaceUV uvs, TextureAtlasSprite sprite, EnumFacing orientation, float[] p_188012_4_, ITransformation rotationIn, @Nullable BlockPartRotation partRotation, boolean shade) {
>         int vertexSize = 28;
>         if (Config.isShaders()) {
>             vertexSize = 56;
>         }
>         int[] aint = new int[vertexSize];
104c109
<         float f = this.getFaceBrightness(facing);
---
>         float f = FaceBakery.getFaceBrightness(facing);
109c114
<     private float getFaceBrightness(EnumFacing facing) {
---
>     public static float getFaceBrightness(EnumFacing facing) {
111a117,119
>                 if (Config.isShaders()) {
>                     return Shaders.blockLightLevel05;
>                 }
118a127,129
>                 if (Config.isShaders()) {
>                     return Shaders.blockLightLevel08;
>                 }
122a134,136
>                 if (Config.isShaders()) {
>                     return Shaders.blockLightLevel06;
>                 }
140,144c154
<     private void fillVertexData(int[] p_188015_1_, int p_188015_2_, EnumFacing p_188015_3_, BlockFaceUV p_188015_4_, float[] p_188015_5_, TextureAtlasSprite p_188015_6_, ModelRotation p_188015_7_, @Nullable BlockPartRotation p_188015_8_, boolean p_188015_9_) {
<         this.fillVertexData(p_188015_1_, p_188015_2_, p_188015_3_, p_188015_4_, p_188015_5_, p_188015_6_, (ITransformation)p_188015_7_, p_188015_8_, p_188015_9_);
<     }
< 
<     private void fillVertexData(int[] p_188015_1_, int p_188015_2_, EnumFacing p_188015_3_, BlockFaceUV p_188015_4_, float[] p_188015_5_, TextureAtlasSprite p_188015_6_, ITransformation p_188015_7_, BlockPartRotation p_188015_8_, boolean p_188015_9_) {
---
>     private void fillVertexData(int[] p_188015_1_, int p_188015_2_, EnumFacing p_188015_3_, BlockFaceUV p_188015_4_, float[] p_188015_5_, TextureAtlasSprite p_188015_6_, ITransformation p_188015_7_, @Nullable BlockPartRotation p_188015_8_, boolean p_188015_9_) {
150a161
>         BlockModelUtils.snapVertexPosition((Vector3f)vector3f);
155c166,167
<         int i = storeIndex * 7;
---
>         int step = faceData.length / 4;
>         int i = storeIndex * step;
202,204c214,221
<     public int rotateVertex(Vector3f p_188011_1_, EnumFacing p_188011_2_, int p_188011_3_, ITransformation p_188011_4_) {
<         if (p_188011_4_ == ModelRotation.X0_Y0) {
<             return p_188011_3_;
---
>     public int rotateVertex(Vector3f position, EnumFacing facing, int vertexIndex, ITransformation modelRotationIn) {
>         if (modelRotationIn == ModelRotation.X0_Y0) {
>             return vertexIndex;
>         }
>         if (Reflector.ForgeHooksClient_transform.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_transform, (Object[])new Object[]{position, modelRotationIn.getMatrix()});
>         } else {
>             this.rotateScale(position, new Vector3f(0.5f, 0.5f, 0.5f), ((ModelRotation)modelRotationIn).matrix(), new Vector3f(1.0f, 1.0f, 1.0f));
206,207c223
<         ForgeHooksClient.transform((Vector3f)p_188011_1_, (javax.vecmath.Matrix4f)p_188011_4_.getMatrix());
<         return p_188011_4_.rotate(p_188011_2_, p_188011_3_);
---
>         return modelRotationIn.rotate(facing, vertexIndex);
225a242,243
>         int step = faceData.length / 4;
>         int step2 = step * 2;
227,228c245,246
<         Vector3f vector3f1 = new Vector3f(Float.intBitsToFloat((int)faceData[7]), Float.intBitsToFloat((int)faceData[8]), Float.intBitsToFloat((int)faceData[9]));
<         Vector3f vector3f2 = new Vector3f(Float.intBitsToFloat((int)faceData[14]), Float.intBitsToFloat((int)faceData[15]), Float.intBitsToFloat((int)faceData[16]));
---
>         Vector3f vector3f1 = new Vector3f(Float.intBitsToFloat((int)faceData[step]), Float.intBitsToFloat((int)faceData[step + 1]), Float.intBitsToFloat((int)faceData[step + 2]));
>         Vector3f vector3f2 = new Vector3f(Float.intBitsToFloat((int)faceData[step2]), Float.intBitsToFloat((int)faceData[step2 + 1]), Float.intBitsToFloat((int)faceData[step2 + 2]));
264a283
>         int step = p_178408_1_.length / 4;
266c285
<             int j = 7 * i;
---
>             int j = step * i;
290c309
<             int j1 = 7 * i1;
---
>             int j1 = step * i1;
299c318
<                 int l = 7 * k;
---
>                 int l = step * k;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/ItemOverrideList.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/ItemOverrideList.java
7d6
<  *  java.lang.Deprecated
9d7
<  *  java.lang.String
14a13
>  *  net.minecraft.client.renderer.block.model.ModelResourceLocation
19,21c18,20
<  *  net.minecraftforge.client.model.ModelLoader
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.ItemOverrideCache
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
31a31
> import net.minecraft.client.renderer.block.model.ModelResourceLocation;
36,38c36,38
< import net.minecraftforge.client.model.ModelLoader;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.ItemOverrideCache;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
40d39
< @SideOnly(value=Side.CLIENT)
43a43
>     private ItemOverrideCache itemOverrideCache;
50c50,53
<             this.overrides.add((Object)((ItemOverride)overridesIn.get(i)));
---
>             this.overrides.add(overridesIn.get(i));
>         }
>         if (this.overrides.size() > 65) {
>             this.itemOverrideCache = ItemOverrideCache.make(this.overrides);
55d57
<     @Deprecated
57a60,63
>             ResourceLocation locationCached;
>             if (this.itemOverrideCache != null && (locationCached = this.itemOverrideCache.getModelLocation(stack, worldIn, entityIn)) != null) {
>                 return locationCached == ItemOverrideCache.LOCATION_NULL ? null : locationCached;
>             }
59a66,68
>                 if (this.itemOverrideCache != null) {
>                     this.itemOverrideCache.putModelLocation(stack, worldIn, entityIn, itemoverride.getLocation());
>                 }
61a71,73
>             if (this.itemOverrideCache != null) {
>                 this.itemOverrideCache.putModelLocation(stack, worldIn, entityIn, ItemOverrideCache.LOCATION_NULL);
>             }
68,69c80,82
<         if (!stack.isEmpty() && stack.getItem().hasCustomProperties() && (location = this.applyOverride(stack, world, entity)) != null) {
<             return Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager().getModel(ModelLoader.getInventoryVariant((String)location.toString()));
---
>         if (!stack.isEmpty() && stack.getItem().hasCustomProperties() && (location = this.applyOverride(stack, world, entity)) != null && Reflector.ModelLoader_getInventoryVariant.exists()) {
>             ModelResourceLocation locationVariant = (ModelResourceLocation)Reflector.call((ReflectorMethod)Reflector.ModelLoader_getInventoryVariant, (Object[])new Object[]{location.toString()});
>             return Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager().getModel(locationVariant);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/ModelBakery$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/ModelBakery$1.java
22c22
<     ModelBakery.1() {
---
>     ModelBakery.1(ResourceLocation resourceLocation) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/ModelBakery.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/ModelBakery.java
74d73
<  *  net.minecraftforge.client.model.ModelLoader
77,78d75
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
79a77,82
>  *  net.optifine.CustomItems
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.util.StrUtils
>  *  net.optifine.util.TextureUtils
148d150
< import net.minecraftforge.client.model.ModelLoader;
151,152d152
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
153a154,159
> import net.optifine.CustomItems;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.util.StrUtils;
> import net.optifine.util.TextureUtils;
158d163
< @SideOnly(value=Side.CLIENT)
160c165
<     protected static final Set<ResourceLocation> LOCATIONS_BUILTIN_TEXTURES = Sets.newHashSet((Object[])new ResourceLocation[]{new ResourceLocation("blocks/water_flow"), new ResourceLocation("blocks/water_still"), new ResourceLocation("blocks/lava_flow"), new ResourceLocation("blocks/lava_still"), new ResourceLocation("blocks/water_overlay"), new ResourceLocation("blocks/destroy_stage_0"), new ResourceLocation("blocks/destroy_stage_1"), new ResourceLocation("blocks/destroy_stage_2"), new ResourceLocation("blocks/destroy_stage_3"), new ResourceLocation("blocks/destroy_stage_4"), new ResourceLocation("blocks/destroy_stage_5"), new ResourceLocation("blocks/destroy_stage_6"), new ResourceLocation("blocks/destroy_stage_7"), new ResourceLocation("blocks/destroy_stage_8"), new ResourceLocation("blocks/destroy_stage_9"), new ResourceLocation("items/empty_armor_slot_helmet"), new ResourceLocation("items/empty_armor_slot_chestplate"), new ResourceLocation("items/empty_armor_slot_leggings"), new ResourceLocation("items/empty_armor_slot_boots"), new ResourceLocation("items/empty_armor_slot_shield"), new ResourceLocation("blocks/shulker_top_white"), new ResourceLocation("blocks/shulker_top_orange"), new ResourceLocation("blocks/shulker_top_magenta"), new ResourceLocation("blocks/shulker_top_light_blue"), new ResourceLocation("blocks/shulker_top_yellow"), new ResourceLocation("blocks/shulker_top_lime"), new ResourceLocation("blocks/shulker_top_pink"), new ResourceLocation("blocks/shulker_top_gray"), new ResourceLocation("blocks/shulker_top_silver"), new ResourceLocation("blocks/shulker_top_cyan"), new ResourceLocation("blocks/shulker_top_purple"), new ResourceLocation("blocks/shulker_top_blue"), new ResourceLocation("blocks/shulker_top_brown"), new ResourceLocation("blocks/shulker_top_green"), new ResourceLocation("blocks/shulker_top_red"), new ResourceLocation("blocks/shulker_top_black")});
---
>     private static final Set<ResourceLocation> LOCATIONS_BUILTIN_TEXTURES = Sets.newHashSet((Object[])new ResourceLocation[]{new ResourceLocation("blocks/water_flow"), new ResourceLocation("blocks/water_still"), new ResourceLocation("blocks/lava_flow"), new ResourceLocation("blocks/lava_still"), new ResourceLocation("blocks/water_overlay"), new ResourceLocation("blocks/destroy_stage_0"), new ResourceLocation("blocks/destroy_stage_1"), new ResourceLocation("blocks/destroy_stage_2"), new ResourceLocation("blocks/destroy_stage_3"), new ResourceLocation("blocks/destroy_stage_4"), new ResourceLocation("blocks/destroy_stage_5"), new ResourceLocation("blocks/destroy_stage_6"), new ResourceLocation("blocks/destroy_stage_7"), new ResourceLocation("blocks/destroy_stage_8"), new ResourceLocation("blocks/destroy_stage_9"), new ResourceLocation("items/empty_armor_slot_helmet"), new ResourceLocation("items/empty_armor_slot_chestplate"), new ResourceLocation("items/empty_armor_slot_leggings"), new ResourceLocation("items/empty_armor_slot_boots"), new ResourceLocation("items/empty_armor_slot_shield"), new ResourceLocation("blocks/shulker_top_white"), new ResourceLocation("blocks/shulker_top_orange"), new ResourceLocation("blocks/shulker_top_magenta"), new ResourceLocation("blocks/shulker_top_light_blue"), new ResourceLocation("blocks/shulker_top_yellow"), new ResourceLocation("blocks/shulker_top_lime"), new ResourceLocation("blocks/shulker_top_pink"), new ResourceLocation("blocks/shulker_top_gray"), new ResourceLocation("blocks/shulker_top_silver"), new ResourceLocation("blocks/shulker_top_cyan"), new ResourceLocation("blocks/shulker_top_purple"), new ResourceLocation("blocks/shulker_top_blue"), new ResourceLocation("blocks/shulker_top_brown"), new ResourceLocation("blocks/shulker_top_green"), new ResourceLocation("blocks/shulker_top_red"), new ResourceLocation("blocks/shulker_top_black")});
162c167
<     public static final ModelResourceLocation MODEL_MISSING = new ModelResourceLocation("builtin/missing", "missing");
---
>     protected static final ModelResourceLocation MODEL_MISSING = new ModelResourceLocation("builtin/missing", "missing");
166,167c171,172
<     protected final IResourceManager resourceManager;
<     protected final Map<ResourceLocation, TextureAtlasSprite> sprites = Maps.newHashMap();
---
>     private final IResourceManager resourceManager;
>     private final Map<ResourceLocation, TextureAtlasSprite> sprites = Maps.newHashMap();
171,172c176,177
<     protected final TextureMap textureMap;
<     protected final BlockModelShapes blockModelShapes;
---
>     private final TextureMap textureMap;
>     private final BlockModelShapes blockModelShapes;
175c180
<     protected final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple();
---
>     private final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple();
177,178c182,183
<     protected static final ModelBlock MODEL_GENERATED = ModelBlock.deserialize((String)EMPTY_MODEL_RAW);
<     protected static final ModelBlock MODEL_ENTITY = ModelBlock.deserialize((String)EMPTY_MODEL_RAW);
---
>     private static final ModelBlock MODEL_GENERATED = ModelBlock.deserialize((String)EMPTY_MODEL_RAW);
>     private static final ModelBlock MODEL_ENTITY = ModelBlock.deserialize((String)EMPTY_MODEL_RAW);
201c206
<     protected void loadBlocks() {
---
>     private void loadBlocks() {
209c214
<                     LOGGER.warn("Unable to load definition " + String.valueOf((Object)resourcelocation), (Throwable)exception);
---
>                     LOGGER.warn("Unable to load definition " + resourcelocation, (Throwable)exception);
232c237,241
<                 this.registerVariant(modelblockdefinition, modelresourcelocation);
---
>                 if (Reflector.ForgeItem_delegate.exists()) {
>                     this.registerVariant(modelblockdefinition, modelresourcelocation);
>                     continue;
>                 }
>                 this.variants.put((Object)modelresourcelocation, (Object)modelblockdefinition.getVariant(modelresourcelocation.getVariant()));
236c245
<                 LOGGER.warn("Unable to load variant: " + modelresourcelocation.getVariant() + " from " + String.valueOf((Object)modelresourcelocation), (Throwable)var12);
---
>                 LOGGER.warn("Unable to load variant: " + modelresourcelocation.getVariant() + " from " + modelresourcelocation, (Throwable)var12);
241c250
<     protected void loadVariantItemModels() {
---
>     private void loadVariantItemModels() {
246a256,257
>         CustomItems.update();
>         CustomItems.loadModels((ModelBakery)this);
256c267
<     protected void registerVariant(ModelBlockDefinition blockstateDefinition, ModelResourceLocation location) {
---
>     private void registerVariant(ModelBlockDefinition blockstateDefinition, ModelResourceLocation location) {
268c279
<     protected ModelBlockDefinition getModelBlockDefinition(ResourceLocation location) {
---
>     private ModelBlockDefinition getModelBlockDefinition(ResourceLocation location) {
286c297
<             throw new RuntimeException("Encountered an exception when loading model definition of model " + String.valueOf((Object)fileIn), (Throwable)ioexception);
---
>             throw new RuntimeException("Encountered an exception when loading model definition of model " + fileIn, (Throwable)ioexception);
296c307
<             lvt_4_1_ = ModelBlockDefinition.parseFromReader((Reader)new InputStreamReader(inputstream, StandardCharsets.UTF_8), (ResourceLocation)location);
---
>             lvt_4_1_ = Reflector.ForgeModelBlockDefinition_parseFromReader2.exists() ? (ModelBlockDefinition)Reflector.call((ReflectorMethod)Reflector.ForgeModelBlockDefinition_parseFromReader2, (Object[])new Object[]{new InputStreamReader(inputstream, StandardCharsets.UTF_8), location}) : ModelBlockDefinition.parseFromReader((Reader)new InputStreamReader(inputstream, StandardCharsets.UTF_8));
299c310
<             throw new RuntimeException("Encountered an exception when loading model definition of '" + String.valueOf((Object)location) + "' from: '" + String.valueOf((Object)resource.getResourceLocation()) + "' in resourcepack: '" + resource.getResourcePackName() + "'", (Throwable)exception);
---
>             throw new RuntimeException("Encountered an exception when loading model definition of '" + location + "' from: '" + resource.getResourceLocation() + "' in resourcepack: '" + resource.getResourcePackName() + "'", (Throwable)exception);
311c322
<     protected void loadVariantModels() {
---
>     private void loadVariantModels() {
317c328
<     protected void loadMultipartVariantModels() {
---
>     private void loadMultipartVariantModels() {
326c337
<     protected void loadVariantList(ModelResourceLocation p_188638_1_, VariantList p_188638_2_) {
---
>     private void loadVariantList(ModelResourceLocation p_188638_1_, VariantList p_188638_2_) {
342c353
<     protected ModelBlock loadModel(ResourceLocation location) throws IOException {
---
>     private ModelBlock loadModel(ResourceLocation location) throws IOException {
347d357
<             ModelBlock modelblock1;
369c379,380
<                 iresource = this.resourceManager.getResource(this.getModelLocation(location));
---
>                 location = this.getModelLocation(location);
>                 iresource = this.resourceManager.getResource(location);
374c385,388
<             ModelBlock modelBlock = modelblock1 = lvt_5_2_3;
---
>             ModelBlock modelblock1 = lvt_5_2_3;
>             String basePath = TextureUtils.getBasePath((String)location.getPath());
>             ModelBakery.fixModelLocations(modelblock1, basePath);
>             ModelBlock modelBlock = modelblock1;
389c403,410
<     protected ResourceLocation getModelLocation(ResourceLocation location) {
---
>     private ResourceLocation getModelLocation(ResourceLocation location) {
>         String path = location.getPath();
>         if (path.startsWith("mcpatcher") || path.startsWith("optifine")) {
>             if (!path.endsWith(".json")) {
>                 location = new ResourceLocation(location.getNamespace(), path + ".json");
>             }
>             return location;
>         }
393c414
<     protected void loadItemModels() {
---
>     private void loadItemModels() {
409c430
<     private void loadItemModel(String variantName, ResourceLocation location, ResourceLocation itemName) {
---
>     public void loadItemModel(String variantName, ResourceLocation location, ResourceLocation itemName) {
417c438,439
<                 LOGGER.warn("Unable to load item model: '{}' for item: '{}'", (Object)location, (Object)itemName, (Object)exception);
---
>                 LOGGER.warn("Unable to load item model: '{}' for item: '{}'", new Object[]{location, itemName});
>                 LOGGER.warn(exception.getClass().getName() + ": " + exception.getMessage());
422c444
<     protected void registerVariantNames() {
---
>     private void registerVariantNames() {
472c494
<             this.variantNames.put((Object)((Item)((IRegistryDelegate)e.getKey()).get()), (Object)Lists.newArrayList((Iterator)((Set)e.getValue()).iterator()));
---
>             this.variantNames.put(((IRegistryDelegate)e.getKey()).get(), (Object)Lists.newArrayList((Iterator)((Set)e.getValue()).iterator()));
476c498
<     protected List<String> getVariantNames(Item stack) {
---
>     private List<String> getVariantNames(Item stack) {
484,485c506,510
<     protected ResourceLocation getItemLocation(String location) {
<         ResourceLocation resourcelocation = new ResourceLocation(location.replaceAll("#.*", ""));
---
>     private ResourceLocation getItemLocation(String location) {
>         ResourceLocation resourcelocation = new ResourceLocation(location);
>         if (Reflector.ForgeHooksClient.exists()) {
>             resourcelocation = new ResourceLocation(location.replaceAll("#.*", ""));
>         }
545a571
>             ModelBlock modelblock;
547,549c573,577
<             ModelResourceLocation modelresourcelocation = ModelLoader.getInventoryVariant((String)((String)entry.getKey()));
<             ModelBlock modelblock = (ModelBlock)this.models.get((Object)resourcelocation);
<             if (modelblock != null && modelblock.isResolved()) {
---
>             ModelResourceLocation modelresourcelocation = new ModelResourceLocation((String)entry.getKey(), "inventory");
>             if (Reflector.ForgeHooksClient.exists()) {
>                 modelresourcelocation = (ModelResourceLocation)Reflector.call((ReflectorMethod)Reflector.ModelLoader_getInventoryVariant, (Object[])new Object[]{entry.getKey()});
>             }
>             if ((modelblock = (ModelBlock)this.models.get((Object)resourcelocation)) != null && modelblock.isResolved()) {
599c627
<     private IBakedModel bakeModel(ModelBlock modelBlockIn, ModelRotation modelRotationIn, boolean uvLocked) {
---
>     public IBakedModel bakeModel(ModelBlock modelBlockIn, ModelRotation modelRotationIn, boolean uvLocked) {
613c641,645
<                 if (blockpartface.cullFace == null || !TRSRTransformation.isInteger((Matrix4f)modelRotationIn.getMatrix())) {
---
>                 boolean isMatrixInteger = true;
>                 if (Reflector.ForgeHooksClient.exists()) {
>                     isMatrixInteger = TRSRTransformation.isInteger((Matrix4f)modelRotationIn.getMatrix());
>                 }
>                 if (blockpartface.cullFace == null || !isMatrixInteger) {
623,624c655,659
<     private BakedQuad makeBakedQuad(BlockPart blockPartt, BlockPartFace blockPartFaceIn, TextureAtlasSprite sprite, EnumFacing face, ModelRotation transform, boolean uvLocked) {
<         return this.makeBakedQuad(blockPartt, blockPartFaceIn, sprite, face, (ITransformation)transform, uvLocked);
---
>     private BakedQuad makeBakedQuad(BlockPart p_177589_1_, BlockPartFace p_177589_2_, TextureAtlasSprite p_177589_3_, EnumFacing p_177589_4_, ModelRotation p_177589_5_, boolean p_177589_6_) {
>         if (Reflector.ForgeHooksClient.exists()) {
>             return this.makeBakedQuad(p_177589_1_, p_177589_2_, p_177589_3_, p_177589_4_, (ITransformation)p_177589_5_, p_177589_6_);
>         }
>         return this.faceBakery.makeBakedQuad(p_177589_1_.positionFrom, p_177589_1_.positionTo, p_177589_2_, p_177589_3_, p_177589_4_, p_177589_5_, p_177589_1_.partRotation, p_177589_6_, p_177589_1_.shade);
627,628c662,663
<     protected BakedQuad makeBakedQuad(BlockPart blockPartt, BlockPartFace blockPartFaceIn, TextureAtlasSprite sprite, EnumFacing face, ITransformation transform, boolean uvLocked) {
<         return this.faceBakery.makeBakedQuad(blockPartt.positionFrom, blockPartt.positionTo, blockPartFaceIn, sprite, face, transform, blockPartt.partRotation, uvLocked, blockPartt.shade);
---
>     protected BakedQuad makeBakedQuad(BlockPart p_177589_1_, BlockPartFace p_177589_2_, TextureAtlasSprite p_177589_3_, EnumFacing p_177589_4_, ITransformation p_177589_5_, boolean p_177589_6_) {
>         return this.faceBakery.makeBakedQuad(p_177589_1_.positionFrom, p_177589_1_.positionTo, p_177589_2_, p_177589_3_, p_177589_4_, p_177589_5_, p_177589_1_.partRotation, p_177589_6_, p_177589_1_.shade);
655c690
<                 LOGGER.warn("In parent chain: {}; unable to load model: '{}'", (Object)JOINER.join(this.getParentPath(resourcelocation1)), (Object)resourcelocation1, (Object)exception);
---
>                 LOGGER.warn("In parent chain: {}; unable to load model: '{}'", new Object[]{JOINER.join(this.getParentPath(resourcelocation1)), resourcelocation1});
687c722
<     protected Set<ResourceLocation> getTextureLocations(ModelBlock p_177585_1_) {
---
>     private Set<ResourceLocation> getTextureLocations(ModelBlock p_177585_1_) {
731c766
<     protected boolean hasItemModel(@Nullable ModelBlock p_177581_1_) {
---
>     private boolean hasItemModel(@Nullable ModelBlock p_177581_1_) {
738c773
<     protected boolean isCustomRenderer(@Nullable ModelBlock p_177587_1_) {
---
>     private boolean isCustomRenderer(@Nullable ModelBlock p_177587_1_) {
766c801
<     protected ModelBlock makeItemModel(ModelBlock p_177582_1_) {
---
>     private ModelBlock makeItemModel(ModelBlock p_177582_1_) {
769a805,846
>     public ModelBlock getModelBlock(ResourceLocation resourceLocation) {
>         ModelBlock modelblock = (ModelBlock)this.models.get((Object)resourceLocation);
>         return modelblock;
>     }
> 
>     public static void fixModelLocations(ModelBlock modelBlock, String basePath) {
>         ResourceLocation parentLocFixed = ModelBakery.fixModelLocation(modelBlock.parentLocation, basePath);
>         if (parentLocFixed != modelBlock.parentLocation) {
>             modelBlock.parentLocation = parentLocFixed;
>         }
>         if (modelBlock.textures != null) {
>             for (Map.Entry entry : modelBlock.textures.entrySet()) {
>                 String path = (String)entry.getValue();
>                 String pathFixed = ModelBakery.fixResourcePath(path, basePath);
>                 if (pathFixed == path) continue;
>                 entry.setValue((Object)pathFixed);
>             }
>         }
>     }
> 
>     public static ResourceLocation fixModelLocation(ResourceLocation loc, String basePath) {
>         if (loc == null || basePath == null) {
>             return loc;
>         }
>         if (!loc.getNamespace().equals((Object)"minecraft")) {
>             return loc;
>         }
>         String path = loc.getPath();
>         String pathFixed = ModelBakery.fixResourcePath(path, basePath);
>         if (pathFixed != path) {
>             loc = new ResourceLocation(loc.getNamespace(), pathFixed);
>         }
>         return loc;
>     }
> 
>     private static String fixResourcePath(String path, String basePath) {
>         path = TextureUtils.fixResourcePath((String)path, (String)basePath);
>         path = StrUtils.removeSuffix((String)path, (String)".json");
>         path = StrUtils.removeSuffix((String)path, (String)".png");
>         return path;
>     }
> 
775,776c852,854
<         if (!customVariantNames.containsKey((Object)item.delegate)) {
<             customVariantNames.put((Object)item.delegate, (Object)Sets.newHashSet());
---
>         IRegistryDelegate delegate = (IRegistryDelegate)Reflector.getFieldValue((Object)item, (ReflectorField)Reflector.ForgeItem_delegate);
>         if (!customVariantNames.containsKey((Object)delegate)) {
>             customVariantNames.put((Object)delegate, (Object)Sets.newHashSet());
779c857
<             ((Set)customVariantNames.get((Object)item.delegate)).add((Object)name.toString());
---
>             ((Set)customVariantNames.get((Object)delegate)).add((Object)name.toString());
780a859,862
>     }
> 
>     static /* synthetic */ Map access$000(ModelBakery x0) {
>         return x0.sprites;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/block/model/ModelRotation.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/block/model/ModelRotation.java
15d14
<  *  net.minecraftforge.client.ForgeHooksClient
20,21c19,20
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
33d31
< import net.minecraftforge.client.ForgeHooksClient;
38,39c36,37
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
42d39
< @SideOnly(value=Side.CLIENT)
124c121,124
<         return ForgeHooksClient.applyTransform((ModelRotation)this, part);
---
>         if (Reflector.ForgeHooksClient_applyTransform_MR.exists()) {
>             return (Optional)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_applyTransform_MR, (Object[])new Object[]{this, part});
>         }
>         return (Optional)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_applyTransform_M4, (Object[])new Object[]{this.getMatrix(), part});
128c128,134
<         return TRSRTransformation.from((ModelRotation)this).getMatrix();
---
>         if (Reflector.ForgeHooksClient_applyTransform_MR.exists()) {
>             return TRSRTransformation.from((ModelRotation)this).getMatrix();
>         }
>         if (Reflector.ForgeHooksClient_getMatrix.exists()) {
>             return (Matrix4f)Reflector.call((ReflectorMethod)Reflector.ForgeHooksClient_getMatrix, (Object[])new Object[]{this});
>         }
>         return new Matrix4f(this.matrix());
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$1.java
7a8
>  *  net.minecraft.client.renderer.chunk.ChunkRenderDispatcher
11a13
> import net.minecraft.client.renderer.chunk.ChunkRenderDispatcher;
12a15,17
> /*
>  * Exception performing whole class analysis ignored.
>  */
17c22
<     ChunkRenderDispatcher.1() {
---
>     ChunkRenderDispatcher.1(ChunkCompileTaskGenerator chunkCompileTaskGenerator) {
22c27
<         ChunkRenderDispatcher.this.queueChunkUpdates.remove((Object)this.val$chunkcompiletaskgenerator);
---
>         ChunkRenderDispatcher.access$100((ChunkRenderDispatcher)ChunkRenderDispatcher.this).remove((Object)this.val$chunkcompiletaskgenerator);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$2.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$2.java
7a8
>  *  net.minecraft.client.renderer.chunk.ChunkRenderDispatcher
11a13
> import net.minecraft.client.renderer.chunk.ChunkRenderDispatcher;
12a15,17
> /*
>  * Exception performing whole class analysis ignored.
>  */
17c22
<     ChunkRenderDispatcher.2() {
---
>     ChunkRenderDispatcher.2(ChunkCompileTaskGenerator chunkCompileTaskGenerator) {
22c27
<         ChunkRenderDispatcher.this.queueChunkUpdates.remove((Object)this.val$chunkcompiletaskgenerator);
---
>         ChunkRenderDispatcher.access$100((ChunkRenderDispatcher)ChunkRenderDispatcher.this).remove((Object)this.val$chunkcompiletaskgenerator);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$3.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$3.java
27c27
<     ChunkRenderDispatcher.3() {
---
>     ChunkRenderDispatcher.3(BlockRenderLayer blockRenderLayer, BufferBuilder bufferBuilder, RenderChunk renderChunk, CompiledChunk compiledChunk, double d) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$PendingUpload.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher$PendingUpload.java
9,11d8
<  *  net.minecraft.client.renderer.chunk.ChunkRenderDispatcher
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
17,19d13
< import net.minecraft.client.renderer.chunk.ChunkRenderDispatcher;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
21d14
< @SideOnly(value=Side.CLIENT)
27c20
<     public ChunkRenderDispatcher.PendingUpload(ChunkRenderDispatcher this$0, ListenableFutureTask<Object> uploadTaskIn, double distanceSqIn) {
---
>     public ChunkRenderDispatcher.PendingUpload(ListenableFutureTask<Object> uploadTaskIn, double distanceSqIn) {
33a27,30
>     }
> 
>     static /* synthetic */ ListenableFutureTask access$000(ChunkRenderDispatcher.PendingUpload x0) {
>         return x0.uploadTask;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
27a28
>  *  java.util.concurrent.TimeUnit
44,45d44
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
63a63
> import java.util.concurrent.TimeUnit;
80,81d79
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
85c83,85
< @SideOnly(value=Side.CLIENT)
---
> /*
>  * Exception performing whole class analysis ignored.
>  */
97a98
>     private List<RegionRenderCacheBuilder> listPausedBuilders = new ArrayList();
105,109c106,107
<         int j = Math.max((int)1, (int)MathHelper.clamp((int)Runtime.getRuntime().availableProcessors(), (int)1, (int)(i / 5)));
<         if (countRenderBuilders < 0) {
<             countRenderBuilders = MathHelper.clamp((int)(j * 10), (int)1, (int)i);
<         }
<         this.countRenderBuilders = countRenderBuilders;
---
>         int j = Math.max((int)1, (int)MathHelper.clamp((int)(Runtime.getRuntime().availableProcessors() - 2), (int)1, (int)(i / 5)));
>         this.countRenderBuilders = countRenderBuilders < 0 ? MathHelper.clamp((int)(j * 8), (int)1, (int)i) : countRenderBuilders;
147a146
>             PendingUpload pendingUpload = null;
150,154c149
<                 if (!this.queueChunkUploads.isEmpty()) {
<                     ((PendingUpload)this.queueChunkUploads.poll()).uploadTask.run();
<                     flag1 = true;
<                     flag = true;
<                 }
---
>                 pendingUpload = (PendingUpload)this.queueChunkUploads.poll();
155a151,154
>             if (pendingUpload == null) continue;
>             PendingUpload.access$000((PendingUpload)pendingUpload).run();
>             flag1 = true;
>             flag = true;
271c270
<     private void uploadDisplayList(BufferBuilder bufferBuilderIn, int list, RenderChunk chunkRenderer) {
---
>     private void uploadDisplayList(BufferBuilder vertexBufferIn, int list, RenderChunk chunkRenderer) {
275c274
<         this.worldVertexUploader.draw(bufferBuilderIn);
---
>         this.worldVertexUploader.draw(vertexBufferIn);
315a315,335
>     }
> 
>     public void pauseChunkUpdates() {
>         while (this.listPausedBuilders.size() != this.countRenderBuilders) {
>             try {
>                 this.runChunkUploads(Long.MAX_VALUE);
>                 RegionRenderCacheBuilder builder = (RegionRenderCacheBuilder)this.queueFreeRenderBuilders.poll(100L, TimeUnit.MILLISECONDS);
>                 if (builder == null) continue;
>                 this.listPausedBuilders.add((Object)builder);
>             }
>             catch (InterruptedException interruptedException) {}
>         }
>     }
> 
>     public void resumeChunkUpdates() {
>         this.queueFreeRenderBuilders.addAll(this.listPausedBuilders);
>         this.listPausedBuilders.clear();
>     }
> 
>     static /* synthetic */ PriorityBlockingQueue access$100(ChunkRenderDispatcher x0) {
>         return x0.queueChunkUpdates;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/CompiledChunk$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/CompiledChunk$1.java
6a7
>  *  java.util.BitSet
12a14
> import java.util.BitSet;
22c24
<     protected void setLayerUsed(BlockRenderLayer blockRenderLayer) {
---
>     protected void setLayerUsed(BlockRenderLayer layer) {
26c28
<     public void setLayerStarted(BlockRenderLayer blockRenderLayer) {
---
>     public void setLayerStarted(BlockRenderLayer layer) {
30c32
<     public boolean isVisible(EnumFacing enumFacing, EnumFacing enumFacing2) {
---
>     public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
31a34,37
>     }
> 
>     public void setAnimatedSprites(BlockRenderLayer layer, BitSet animatedSprites) {
>         throw new UnsupportedOperationException();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/CompiledChunk.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/CompiledChunk.java
6a7
>  *  java.util.BitSet
8a10
>  *  net.minecraft.client.renderer.chunk.RenderChunk
16a19
> import java.util.BitSet;
18a22
> import net.minecraft.client.renderer.chunk.RenderChunk;
26,27c30,31
<     private final boolean[] layersUsed = new boolean[BlockRenderLayer.values().length];
<     private final boolean[] layersStarted = new boolean[BlockRenderLayer.values().length];
---
>     private final boolean[] layersUsed = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
>     private final boolean[] layersStarted = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
31a36
>     private BitSet[] animatedSprites = new BitSet[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
37c42
<     protected void setLayerUsed(BlockRenderLayer blockRenderLayer) {
---
>     protected void setLayerUsed(BlockRenderLayer layer) {
39c44
<         this.layersUsed[blockRenderLayer.ordinal()] = true;
---
>         this.layersUsed[layer.ordinal()] = true;
42,43c47,48
<     public boolean isLayerEmpty(BlockRenderLayer blockRenderLayer) {
<         return !this.layersUsed[blockRenderLayer.ordinal()];
---
>     public boolean isLayerEmpty(BlockRenderLayer layer) {
>         return !this.layersUsed[layer.ordinal()];
46,47c51,52
<     public void setLayerStarted(BlockRenderLayer blockRenderLayer) {
<         this.layersStarted[blockRenderLayer.ordinal()] = true;
---
>     public void setLayerStarted(BlockRenderLayer layer) {
>         this.layersStarted[layer.ordinal()] = true;
50,51c55,56
<     public boolean isLayerStarted(BlockRenderLayer blockRenderLayer) {
<         return this.layersStarted[blockRenderLayer.ordinal()];
---
>     public boolean isLayerStarted(BlockRenderLayer layer) {
>         return this.layersStarted[layer.ordinal()];
58,59c63,64
<     public void addTileEntity(TileEntity tileEntity) {
<         this.tileEntities.add((Object)tileEntity);
---
>     public void addTileEntity(TileEntity tileEntityIn) {
>         this.tileEntities.add((Object)tileEntityIn);
62,63c67,68
<     public boolean isVisible(EnumFacing enumFacing, EnumFacing enumFacing2) {
<         return this.setVisibility.isVisible(enumFacing, enumFacing2);
---
>     public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
>         return this.setVisibility.isVisible(facing, facing2);
66,67c71,72
<     public void setVisibility(SetVisibility setVisibility) {
<         this.setVisibility = setVisibility;
---
>     public void setVisibility(SetVisibility visibility) {
>         this.setVisibility = visibility;
74,75c79,88
<     public void setState(BufferBuilder.State state) {
<         this.state = state;
---
>     public void setState(BufferBuilder.State stateIn) {
>         this.state = stateIn;
>     }
> 
>     public BitSet getAnimatedSprites(BlockRenderLayer layer) {
>         return this.animatedSprites[layer.ordinal()];
>     }
> 
>     public void setAnimatedSprites(BlockRenderLayer layer, BitSet animatedSprites) {
>         this.animatedSprites[layer.ordinal()] = animatedSprites;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/RenderChunk.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/RenderChunk.java
4a5
>  *  Config
7a9
>  *  java.lang.String
8a11
>  *  java.util.BitSet
14a18,19
>  *  net.minecraft.block.BlockCactus
>  *  net.minecraft.block.BlockRedstoneWire
17a23
>  *  net.minecraft.client.multiplayer.WorldClient
22a29
>  *  net.minecraft.client.renderer.RegionRenderCacheBuilder
23a31,32
>  *  net.minecraft.client.renderer.RenderGlobal$ContainerLocalRenderInformation
>  *  net.minecraft.client.renderer.ViewFrustum
28a38
>  *  net.minecraft.client.renderer.culling.ICamera
43a54
>  *  net.minecraft.world.chunk.Chunk
45,48c56,64
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.client.MinecraftForgeClient
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.BlockPosM
>  *  net.optifine.CustomBlockLayers
>  *  net.optifine.override.ChunkCacheOF
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.render.AabbFrame
>  *  net.optifine.render.RenderEnv
>  *  net.optifine.shaders.SVertexBuilder
53a70
> import java.util.BitSet;
59a77,78
> import net.minecraft.block.BlockCactus;
> import net.minecraft.block.BlockRedstoneWire;
62a82
> import net.minecraft.client.multiplayer.WorldClient;
67a88
> import net.minecraft.client.renderer.RegionRenderCacheBuilder;
68a90
> import net.minecraft.client.renderer.ViewFrustum;
71a94
> import net.minecraft.client.renderer.culling.ICamera;
87,90c110,118
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.client.MinecraftForgeClient;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.BlockPosM;
> import net.optifine.CustomBlockLayers;
> import net.optifine.override.ChunkCacheOF;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.render.AabbFrame;
> import net.optifine.render.RenderEnv;
> import net.optifine.shaders.SVertexBuilder;
92d119
< @SideOnly(value=Side.CLIENT)
94c121
<     private World world;
---
>     private final World world;
111c138,152
<     private ChunkCache worldView;
---
>     public static final BlockRenderLayer[] ENUM_WORLD_BLOCK_LAYERS;
>     private final BlockRenderLayer[] blockLayersSingle = new BlockRenderLayer[1];
>     private final boolean isMipmaps = Config.isMipmaps();
>     private final boolean fixBlockLayer = !Reflector.BetterFoliageClient.exists();
>     private boolean playerUpdate = false;
>     public int regionX;
>     public int regionZ;
>     private final RenderChunk[] renderChunksOfset16 = new RenderChunk[6];
>     private boolean renderChunksOffset16Updated = false;
>     private Chunk chunk;
>     private RenderChunk[] renderChunkNeighbours = new RenderChunk[EnumFacing.VALUES.length];
>     private RenderChunk[] renderChunkNeighboursValid = new RenderChunk[EnumFacing.VALUES.length];
>     private boolean renderChunkNeighboursUpated = false;
>     private RenderGlobal.ContainerLocalRenderInformation renderInfo = new RenderGlobal.ContainerLocalRenderInformation(this, null, 0);
>     public AabbFrame boundingBoxParent;
142a184,186
>             int bits = 8;
>             this.regionX = x >> bits << bits;
>             this.regionZ = z >> bits << bits;
144c188
<             for (EnumFacing enumfacing : EnumFacing.values()) {
---
>             for (EnumFacing enumfacing : EnumFacing.VALUES) {
146a191,199
>             this.renderChunksOffset16Updated = false;
>             this.renderChunkNeighboursUpated = false;
>             for (int i = 0; i < this.renderChunkNeighbours.length; ++i) {
>                 RenderChunk neighbour = this.renderChunkNeighbours[i];
>                 if (neighbour == null) continue;
>                 neighbour.renderChunkNeighboursUpated = false;
>             }
>             this.chunk = null;
>             this.boundingBoxParent = null;
154,156c207,210
<             this.preRenderBlocks(generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), (BlockPos)this.position);
<             generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT).setVertexState(compiledchunk.getState());
<             this.postRenderBlocks(BlockRenderLayer.TRANSLUCENT, x, y, z, generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), compiledchunk);
---
>             BufferBuilder bufferTranslucent = generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT);
>             this.preRenderBlocks(bufferTranslucent, (BlockPos)this.position);
>             bufferTranslucent.setVertexState(compiledchunk.getState());
>             this.postRenderBlocks(BlockRenderLayer.TRANSLUCENT, x, y, z, bufferTranslucent, compiledchunk);
166c220
<         BlockPos.MutableBlockPos blockpos = this.position;
---
>         BlockPos blockpos = new BlockPos((Vec3i)this.position);
180c234
<         if (!this.worldView.isEmpty()) {
---
>         if (!this.isChunkRegionEmpty(blockpos)) {
182c236,238
<             boolean[] aboolean = new boolean[BlockRenderLayer.values().length];
---
>             ChunkCacheOF blockAccess = this.makeChunkCacheOF(blockpos);
>             blockAccess.renderStart();
>             boolean[] aboolean = new boolean[ENUM_WORLD_BLOCK_LAYERS.length];
184c240,243
<             for (BlockPos.MutableBlockPos blockpos$mutableblockpos : BlockPos.getAllInBoxMutable((BlockPos)blockpos, (BlockPos)blockpos1)) {
---
>             boolean forgeBlockCanRenderInLayerExists = Reflector.ForgeBlock_canRenderInLayer.exists();
>             boolean forgeHooksSetRenderLayerExists = Reflector.ForgeHooksClient_setRenderLayer.exists();
>             for (BlockPosM blockpos$mutableblockpos : BlockPosM.getAllInBoxMutable((BlockPos)blockpos, (BlockPos)blockpos1)) {
>                 BlockRenderLayer[] blockLayers;
187c246
<                 IBlockState iblockstate = this.worldView.getBlockState((BlockPos)blockpos$mutableblockpos);
---
>                 IBlockState iblockstate = blockAccess.o((BlockPos)blockpos$mutableblockpos);
192c251
<                 if (block.hasTileEntity(iblockstate) && (tileentity = this.worldView.getTileEntity((BlockPos)blockpos$mutableblockpos, Chunk.EnumCreateEntityType.CHECK)) != null && (tileentityspecialrenderer = TileEntityRendererDispatcher.instance.getRenderer(tileentity)) != null) {
---
>                 if (ReflectorForge.blockHasTileEntity((IBlockState)iblockstate) && (tileentity = blockAccess.getTileEntity((BlockPos)blockpos$mutableblockpos, Chunk.EnumCreateEntityType.CHECK)) != null && (tileentityspecialrenderer = TileEntityRendererDispatcher.instance.getRenderer(tileentity)) != null) {
199,201c258,271
<                 for (BlockRenderLayer blockrenderlayer1 : BlockRenderLayer.values()) {
<                     if (!block.canRenderInLayer(iblockstate, blockrenderlayer1)) continue;
<                     ForgeHooksClient.setRenderLayer((BlockRenderLayer)blockrenderlayer1);
---
>                 if (forgeBlockCanRenderInLayerExists) {
>                     blockLayers = ENUM_WORLD_BLOCK_LAYERS;
>                 } else {
>                     blockLayers = this.blockLayersSingle;
>                     blockLayers[0] = block.getRenderLayer();
>                 }
>                 for (int ix = 0; ix < blockLayers.length; ++ix) {
>                     boolean canRenderInLayer;
>                     BlockRenderLayer blockrenderlayer1 = blockLayers[ix];
>                     if (forgeBlockCanRenderInLayerExists && !(canRenderInLayer = Reflector.callBoolean((Object)block, (ReflectorMethod)Reflector.ForgeBlock_canRenderInLayer, (Object[])new Object[]{iblockstate, blockrenderlayer1}))) continue;
>                     if (forgeHooksSetRenderLayerExists) {
>                         Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderLayer, (Object[])new Object[]{blockrenderlayer1});
>                     }
>                     blockrenderlayer1 = this.fixBlockLayer(iblockstate, blockrenderlayer1);
204a275,277
>                     bufferbuilder.setBlockLayer(blockrenderlayer1);
>                     RenderEnv renderEnv = bufferbuilder.getRenderEnv(iblockstate, (BlockPos)blockpos$mutableblockpos);
>                     renderEnv.setRegionRenderCacheBuilder(generator.getRegionRenderCacheBuilder());
207c280
<                         this.preRenderBlocks(bufferbuilder, (BlockPos)blockpos);
---
>                         this.preRenderBlocks(bufferbuilder, blockpos);
210c283,286
<                     aboolean[n] = aboolean[n] | blockrendererdispatcher.renderBlock(iblockstate, (BlockPos)blockpos$mutableblockpos, (IBlockAccess)this.worldView, bufferbuilder);
---
>                     aboolean[n] = aboolean[n] | blockrendererdispatcher.renderBlock(iblockstate, (BlockPos)blockpos$mutableblockpos, (IBlockAccess)blockAccess, bufferbuilder);
>                     if (!renderEnv.isOverlaysRendered()) continue;
>                     this.postRenderOverlays(generator.getRegionRenderCacheBuilder(), compiledchunk, aboolean);
>                     renderEnv.setOverlaysRendered(false);
212c288,289
<                 ForgeHooksClient.setRenderLayer(null);
---
>                 if (!forgeHooksSetRenderLayerExists) continue;
>                 Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_setRenderLayer, (Object[])new Object[]{null});
214c291
<             for (BlockRenderLayer blockrenderlayer : BlockRenderLayer.values()) {
---
>             for (BlockRenderLayer blockrenderlayer : ENUM_WORLD_BLOCK_LAYERS) {
218,219c295,305
<                 if (!compiledchunk.isLayerStarted(blockrenderlayer)) continue;
<                 this.postRenderBlocks(blockrenderlayer, x, y, z, generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(blockrenderlayer), compiledchunk);
---
>                 if (compiledchunk.isLayerStarted(blockrenderlayer)) {
>                     if (Config.isShaders()) {
>                         SVertexBuilder.calcNormalChunkLayer((BufferBuilder)generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(blockrenderlayer));
>                     }
>                     BufferBuilder bufferBuilder = generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(blockrenderlayer);
>                     this.postRenderBlocks(blockrenderlayer, x, y, z, bufferBuilder, compiledchunk);
>                     if (bufferBuilder.animatedSprites == null) continue;
>                     compiledchunk.setAnimatedSprites(blockrenderlayer, (BitSet)bufferBuilder.animatedSprites.clone());
>                     continue;
>                 }
>                 compiledchunk.setAnimatedSprites(blockrenderlayer, null);
220a307
>             blockAccess.renderFinish();
272,274d358
<         ChunkCache cache = this.createRegionRenderCache(this.world, this.position.add(-1, -1, -1), this.position.add(16, 16, 16), 1);
<         MinecraftForgeClient.onRebuildChunk((World)this.world, (BlockPos)this.position, (ChunkCache)cache);
<         this.worldView = cache;
309,311c393,405
<     private void preRenderBlocks(BufferBuilder bufferBuilderIn, BlockPos pos) {
<         bufferBuilderIn.begin(7, DefaultVertexFormats.BLOCK);
<         bufferBuilderIn.setTranslation((double)(-pos.p()), (double)(-pos.q()), (double)(-pos.r()));
---
>     private void preRenderBlocks(BufferBuilder worldRendererIn, BlockPos pos) {
>         worldRendererIn.begin(7, DefaultVertexFormats.BLOCK);
>         if (Config.isRenderRegions()) {
>             int bits = 8;
>             int dx = pos.p() >> bits << bits;
>             int dy = pos.q() >> bits << bits;
>             int dz = pos.r() >> bits << bits;
>             dx = this.regionX;
>             dz = this.regionZ;
>             worldRendererIn.setTranslation((double)(-dx), (double)(-dy), (double)(-dz));
>         } else {
>             worldRendererIn.setTranslation((double)(-pos.p()), (double)(-pos.q()), (double)(-pos.r()));
>         }
314c408
<     private void postRenderBlocks(BlockRenderLayer layer, float x, float y, float z, BufferBuilder bufferBuilderIn, CompiledChunk compiledChunkIn) {
---
>     private void postRenderBlocks(BlockRenderLayer layer, float x, float y, float z, BufferBuilder worldRendererIn, CompiledChunk compiledChunkIn) {
316,317c410,411
<             bufferBuilderIn.sortVertexData(x, y, z);
<             compiledChunkIn.setState(bufferBuilderIn.getVertexState());
---
>             worldRendererIn.sortVertexData(x, y, z);
>             compiledChunkIn.setState(worldRendererIn.getVertexState());
319c413
<         bufferBuilderIn.finishDrawing();
---
>         worldRendererIn.finishDrawing();
358d451
<         this.world = null;
374a468,470
>         if (this.isWorldPlayerUpdate()) {
>             this.playerUpdate = true;
>         }
379a476
>         this.playerUpdate = false;
390,393d486
<     protected ChunkCache createRegionRenderCache(World world, BlockPos from, BlockPos to, int subtract) {
<         return new ChunkCache(world, from, to, subtract);
<     }
< 
399a493,660
>     }
> 
>     private boolean isWorldPlayerUpdate() {
>         if (this.world instanceof WorldClient) {
>             WorldClient worldClient = (WorldClient)this.world;
>             return worldClient.isPlayerUpdate();
>         }
>         return false;
>     }
> 
>     public boolean isPlayerUpdate() {
>         return this.playerUpdate;
>     }
> 
>     private BlockRenderLayer fixBlockLayer(IBlockState blockState, BlockRenderLayer layer) {
>         BlockRenderLayer layerCustom;
>         if (CustomBlockLayers.isActive() && (layerCustom = CustomBlockLayers.getRenderLayer((IBlockState)blockState)) != null) {
>             return layerCustom;
>         }
>         if (!this.fixBlockLayer) {
>             return layer;
>         }
>         if (this.isMipmaps) {
>             if (layer == BlockRenderLayer.CUTOUT) {
>                 Block block = blockState.getBlock();
>                 if (block instanceof BlockRedstoneWire) {
>                     return layer;
>                 }
>                 if (block instanceof BlockCactus) {
>                     return layer;
>                 }
>                 return BlockRenderLayer.CUTOUT_MIPPED;
>             }
>         } else if (layer == BlockRenderLayer.CUTOUT_MIPPED) {
>             return BlockRenderLayer.CUTOUT;
>         }
>         return layer;
>     }
> 
>     private void postRenderOverlays(RegionRenderCacheBuilder regionRenderCacheBuilder, CompiledChunk compiledChunk, boolean[] layerFlags) {
>         this.postRenderOverlay(BlockRenderLayer.CUTOUT, regionRenderCacheBuilder, compiledChunk, layerFlags);
>         this.postRenderOverlay(BlockRenderLayer.CUTOUT_MIPPED, regionRenderCacheBuilder, compiledChunk, layerFlags);
>         this.postRenderOverlay(BlockRenderLayer.TRANSLUCENT, regionRenderCacheBuilder, compiledChunk, layerFlags);
>     }
> 
>     private void postRenderOverlay(BlockRenderLayer layer, RegionRenderCacheBuilder regionRenderCacheBuilder, CompiledChunk compiledchunk, boolean[] layerFlags) {
>         BufferBuilder bufferOverlay = regionRenderCacheBuilder.getWorldRendererByLayer(layer);
>         if (bufferOverlay.isDrawing()) {
>             compiledchunk.setLayerStarted(layer);
>             layerFlags[layer.ordinal()] = true;
>         }
>     }
> 
>     private ChunkCacheOF makeChunkCacheOF(BlockPos posIn) {
>         BlockPos posFrom = posIn.add(-1, -1, -1);
>         BlockPos posTo = posIn.add(16, 16, 16);
>         ChunkCache chunkCache = this.createRegionRenderCache(this.world, posFrom, posTo, 1);
>         if (Reflector.MinecraftForgeClient_onRebuildChunk.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.MinecraftForgeClient_onRebuildChunk, (Object[])new Object[]{this.world, posIn, chunkCache});
>         }
>         ChunkCacheOF chunkCacheOF = new ChunkCacheOF(chunkCache, posFrom, posTo, 1);
>         return chunkCacheOF;
>     }
> 
>     public RenderChunk getRenderChunkOffset16(ViewFrustum viewFrustum, EnumFacing facing) {
>         if (!this.renderChunksOffset16Updated) {
>             for (int i = 0; i < EnumFacing.VALUES.length; ++i) {
>                 EnumFacing ef = EnumFacing.VALUES[i];
>                 BlockPos posOffset16 = this.getBlockPosOffset16(ef);
>                 this.renderChunksOfset16[i] = viewFrustum.getRenderChunk(posOffset16);
>             }
>             this.renderChunksOffset16Updated = true;
>         }
>         return this.renderChunksOfset16[facing.ordinal()];
>     }
> 
>     public Chunk getChunk() {
>         return this.getChunk((BlockPos)this.position);
>     }
> 
>     private Chunk getChunk(BlockPos posIn) {
>         Chunk chunkLocal = this.chunk;
>         if (chunkLocal != null && chunkLocal.isLoaded()) {
>             return chunkLocal;
>         }
>         this.chunk = chunkLocal = this.world.getChunk(posIn);
>         return chunkLocal;
>     }
> 
>     public boolean isChunkRegionEmpty() {
>         return this.isChunkRegionEmpty((BlockPos)this.position);
>     }
> 
>     private boolean isChunkRegionEmpty(BlockPos posIn) {
>         int yStart = posIn.q();
>         int yEnd = yStart + 15;
>         return this.getChunk(posIn).isEmptyBetween(yStart, yEnd);
>     }
> 
>     public void setRenderChunkNeighbour(EnumFacing facing, RenderChunk neighbour) {
>         this.renderChunkNeighbours[facing.ordinal()] = neighbour;
>         this.renderChunkNeighboursValid[facing.ordinal()] = neighbour;
>     }
> 
>     public RenderChunk getRenderChunkNeighbour(EnumFacing facing) {
>         if (!this.renderChunkNeighboursUpated) {
>             this.updateRenderChunkNeighboursValid();
>         }
>         return this.renderChunkNeighboursValid[facing.ordinal()];
>     }
> 
>     public RenderGlobal.ContainerLocalRenderInformation getRenderInfo() {
>         return this.renderInfo;
>     }
> 
>     private void updateRenderChunkNeighboursValid() {
>         int x = this.getPosition().p();
>         int z = this.getPosition().r();
>         int north = EnumFacing.NORTH.ordinal();
>         int south = EnumFacing.SOUTH.ordinal();
>         int west = EnumFacing.WEST.ordinal();
>         int east = EnumFacing.EAST.ordinal();
>         this.renderChunkNeighboursValid[north] = this.renderChunkNeighbours[north].getPosition().r() == z - 16 ? this.renderChunkNeighbours[north] : null;
>         this.renderChunkNeighboursValid[south] = this.renderChunkNeighbours[south].getPosition().r() == z + 16 ? this.renderChunkNeighbours[south] : null;
>         this.renderChunkNeighboursValid[west] = this.renderChunkNeighbours[west].getPosition().p() == x - 16 ? this.renderChunkNeighbours[west] : null;
>         this.renderChunkNeighboursValid[east] = this.renderChunkNeighbours[east].getPosition().p() == x + 16 ? this.renderChunkNeighbours[east] : null;
>         this.renderChunkNeighboursUpated = true;
>     }
> 
>     public boolean isBoundingBoxInFrustum(ICamera camera, int frameCount) {
>         if (this.getBoundingBoxParent().isBoundingBoxInFrustumFully(camera, frameCount)) {
>             return true;
>         }
>         return camera.isBoundingBoxInFrustum(this.boundingBox);
>     }
> 
>     public AabbFrame getBoundingBoxParent() {
>         if (this.boundingBoxParent == null) {
>             AabbFrame bbp;
>             BlockPos pos = this.getPosition();
>             int x = pos.p();
>             int y = pos.q();
>             int z = pos.r();
>             int bits = 5;
>             int xp = x >> bits << bits;
>             int yp = y >> bits << bits;
>             int zp = z >> bits << bits;
>             if ((xp != x || yp != y || zp != z) && (bbp = this.renderGlobal.getRenderChunk(new BlockPos(xp, yp, zp)).getBoundingBoxParent()) != null && bbp.a == (double)xp && bbp.b == (double)yp && bbp.c == (double)zp) {
>                 this.boundingBoxParent = bbp;
>             }
>             if (this.boundingBoxParent == null) {
>                 int delta = 1 << bits;
>                 this.boundingBoxParent = new AabbFrame((double)xp, (double)yp, (double)zp, (double)(xp + delta), (double)(yp + delta), (double)(zp + delta));
>             }
>         }
>         return this.boundingBoxParent;
>     }
> 
>     public String toString() {
>         return "pos: " + this.getPosition() + ", frameIndex: " + this.frameIndex;
>     }
> 
>     protected ChunkCache createRegionRenderCache(World world, BlockPos from, BlockPos to, int subtract) {
>         return new ChunkCache(world, from, to, subtract);
>     }
> 
>     static {
>         ENUM_WORLD_BLOCK_LAYERS = BlockRenderLayer.values();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/SetVisibility.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/SetVisibility.java
8d7
<  *  java.util.BitSet
14d12
< import java.util.BitSet;
20c18
<     private final BitSet bitSet = new BitSet(COUNT_FACES * COUNT_FACES);
---
>     private long bits;
22,25c20,23
<     public void setManyVisible(Set<EnumFacing> set) {
<         for (EnumFacing enumFacing : set) {
<             for (EnumFacing enumFacing2 : set) {
<                 this.setVisible(enumFacing, enumFacing2, true);
---
>     public void setManyVisible(Set<EnumFacing> facing) {
>         for (EnumFacing enumfacing : facing) {
>             for (EnumFacing enumfacing1 : facing) {
>                 this.setVisible(enumfacing, enumfacing1, true);
30,32c28,30
<     public void setVisible(EnumFacing enumFacing, EnumFacing enumFacing2, boolean bl) {
<         this.bitSet.set(enumFacing.ordinal() + enumFacing2.ordinal() * COUNT_FACES, bl);
<         this.bitSet.set(enumFacing2.ordinal() + enumFacing.ordinal() * COUNT_FACES, bl);
---
>     public void setVisible(EnumFacing facing, EnumFacing facing2, boolean p_178619_3_) {
>         this.setBit(facing.ordinal() + facing2.ordinal() * COUNT_FACES, p_178619_3_);
>         this.setBit(facing2.ordinal() + facing.ordinal() * COUNT_FACES, p_178619_3_);
35,36c33,34
<     public void setAllVisible(boolean bl) {
<         this.bitSet.set(0, this.bitSet.size(), bl);
---
>     public void setAllVisible(boolean visible) {
>         this.bits = visible ? -1L : 0L;
39,40c37,38
<     public boolean isVisible(EnumFacing enumFacing, EnumFacing enumFacing2) {
<         return this.bitSet.get(enumFacing.ordinal() + enumFacing2.ordinal() * COUNT_FACES);
---
>     public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
>         return this.getBit(facing.ordinal() + facing2.ordinal() * COUNT_FACES);
44,47c42,45
<         StringBuilder stringBuilder = new StringBuilder();
<         stringBuilder.append(' ');
<         for (EnumFacing enumFacing : EnumFacing.values()) {
<             stringBuilder.append(' ').append(enumFacing.toString().toUpperCase().charAt(0));
---
>         StringBuilder stringbuilder = new StringBuilder();
>         stringbuilder.append(' ');
>         for (EnumFacing enumfacing : EnumFacing.values()) {
>             stringbuilder.append(' ').append(enumfacing.toString().toUpperCase().charAt(0));
49,54c47,52
<         stringBuilder.append('\n');
<         for (EnumFacing enumFacing : EnumFacing.values()) {
<             stringBuilder.append(enumFacing.toString().toUpperCase().charAt(0));
<             for (EnumFacing enumFacing2 : EnumFacing.values()) {
<                 if (enumFacing == enumFacing2) {
<                     stringBuilder.append("  ");
---
>         stringbuilder.append('\n');
>         for (EnumFacing enumfacing2 : EnumFacing.values()) {
>             stringbuilder.append(enumfacing2.toString().toUpperCase().charAt(0));
>             for (EnumFacing enumfacing1 : EnumFacing.values()) {
>                 if (enumfacing2 == enumfacing1) {
>                     stringbuilder.append("  ");
57,58c55,56
<                 boolean bl = this.isVisible(enumFacing, enumFacing2);
<                 stringBuilder.append(' ').append(bl ? (char)'Y' : 'n');
---
>                 boolean flag = this.isVisible(enumfacing2, enumfacing1);
>                 stringbuilder.append(' ').append(flag ? (char)'Y' : 'n');
60c58
<             stringBuilder.append('\n');
---
>             stringbuilder.append('\n');
62c60,80
<         return stringBuilder.toString();
---
>         return stringbuilder.toString();
>     }
> 
>     private boolean getBit(int i) {
>         return (this.bits & (long)(1 << i)) != 0L;
>     }
> 
>     private void setBit(int i, boolean on) {
>         if (on) {
>             this.setBit(i);
>         } else {
>             this.clearBit(i);
>         }
>     }
> 
>     private void setBit(int i) {
>         this.bits |= (long)(1 << i);
>     }
> 
>     private void clearBit(int i) {
>         this.bits &= (long)(~(1 << i));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/VisGraph$1.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/VisGraph$1.java
14c14
<     static final /* synthetic */ int[] field_178617_a;
---
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$util$EnumFacing;
17c17
<         field_178617_a = new int[EnumFacing.values().length];
---
>         $SwitchMap$net$minecraft$util$EnumFacing = new int[EnumFacing.values().length];
19c19
<             VisGraph.1.field_178617_a[EnumFacing.DOWN.ordinal()] = 1;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.DOWN.ordinal()] = 1;
25c25
<             VisGraph.1.field_178617_a[EnumFacing.UP.ordinal()] = 2;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.UP.ordinal()] = 2;
31c31
<             VisGraph.1.field_178617_a[EnumFacing.NORTH.ordinal()] = 3;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.NORTH.ordinal()] = 3;
37c37
<             VisGraph.1.field_178617_a[EnumFacing.SOUTH.ordinal()] = 4;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.SOUTH.ordinal()] = 4;
43c43
<             VisGraph.1.field_178617_a[EnumFacing.WEST.ordinal()] = 5;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.WEST.ordinal()] = 5;
49c49
<             VisGraph.1.field_178617_a[EnumFacing.EAST.ordinal()] = 6;
---
>             VisGraph.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.EAST.ordinal()] = 6;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/chunk/VisGraph.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/chunk/VisGraph.java
5d4
<  *  com.google.common.collect.Queues
21d19
< import com.google.common.collect.Queues;
40,41c38,39
<     public void setOpaqueCube(BlockPos blockPos) {
<         this.bitSet.set(VisGraph.getIndex(blockPos), true);
---
>     public void setOpaqueCube(BlockPos pos) {
>         this.bitSet.set(VisGraph.getIndex(pos), true);
45,46c43,44
<     private static int getIndex(BlockPos blockPos) {
<         return VisGraph.getIndex(blockPos.p() & 0xF, blockPos.q() & 0xF, blockPos.r() & 0xF);
---
>     private static int getIndex(BlockPos pos) {
>         return VisGraph.getIndex(pos.p() & 0xF, pos.q() & 0xF, pos.r() & 0xF);
49,50c47,48
<     private static int getIndex(int n, int n2, int n3) {
<         return n << 0 | n2 << 8 | n3 << 4;
---
>     private static int getIndex(int x, int y, int z) {
>         return x << 0 | y << 8 | z << 4;
54c52
<         SetVisibility setVisibility = new SetVisibility();
---
>         SetVisibility setvisibility = new SetVisibility();
56c54
<             setVisibility.setAllVisible(true);
---
>             setvisibility.setAllVisible(true);
58c56
<             setVisibility.setAllVisible(false);
---
>             setvisibility.setAllVisible(false);
60,62c58,60
<             for (int n : INDEX_OF_EDGES) {
<                 if (this.bitSet.get(n)) continue;
<                 setVisibility.setManyVisible(this.floodFill(n));
---
>             for (int i : INDEX_OF_EDGES) {
>                 if (this.bitSet.get(i)) continue;
>                 setvisibility.setManyVisible(this.floodFill(i));
65c63
<         return setVisibility;
---
>         return setvisibility;
68,69c66,67
<     public Set<EnumFacing> getVisibleFacings(BlockPos blockPos) {
<         return this.floodFill(VisGraph.getIndex(blockPos));
---
>     public Set<EnumFacing> getVisibleFacings(BlockPos pos) {
>         return this.floodFill(VisGraph.getIndex(pos));
72,84c70,82
<     private Set<EnumFacing> floodFill(int n) {
<         EnumSet enumSet = EnumSet.noneOf(EnumFacing.class);
<         ArrayDeque \u26032 = Queues.newArrayDeque();
<         \u26032.add((Object)IntegerCache.getInteger((int)n));
<         this.bitSet.set(n, true);
<         while (!\u26032.isEmpty()) {
<             int n2 = (Integer)\u26032.poll();
<             this.addEdges(n2, (Set<EnumFacing>)enumSet);
<             for (EnumFacing enumFacing : EnumFacing.values()) {
<                 int n3 = this.getNeighborIndexAtFace(n2, enumFacing);
<                 if (n3 < 0 || this.bitSet.get(n3)) continue;
<                 this.bitSet.set(n3, true);
<                 \u26032.add((Object)IntegerCache.getInteger((int)n3));
---
>     private Set<EnumFacing> floodFill(int pos) {
>         EnumSet set = EnumSet.noneOf(EnumFacing.class);
>         ArrayDeque queue = new ArrayDeque(384);
>         queue.add((Object)IntegerCache.getInteger((int)pos));
>         this.bitSet.set(pos, true);
>         while (!queue.isEmpty()) {
>             int i = (Integer)queue.poll();
>             this.addEdges(i, (Set<EnumFacing>)set);
>             for (EnumFacing enumfacing : EnumFacing.VALUES) {
>                 int j = this.getNeighborIndexAtFace(i, enumfacing);
>                 if (j < 0 || this.bitSet.get(j)) continue;
>                 this.bitSet.set(j, true);
>                 queue.add((Object)IntegerCache.getInteger((int)j));
87c85
<         return enumSet;
---
>         return set;
90,95c88,93
<     private void addEdges(int n, Set<EnumFacing> set) {
<         int n2 = n >> 0 & 0xF;
<         if (n2 == 0) {
<             set.add((Object)EnumFacing.WEST);
<         } else if (n2 == 15) {
<             set.add((Object)EnumFacing.EAST);
---
>     private void addEdges(int pos, Set<EnumFacing> p_178610_2_) {
>         int i = pos >> 0 & 0xF;
>         if (i == 0) {
>             p_178610_2_.add((Object)EnumFacing.WEST);
>         } else if (i == 15) {
>             p_178610_2_.add((Object)EnumFacing.EAST);
97,101c95,99
<         \u2603 = n >> 8 & 0xF;
<         if (\u2603 == 0) {
<             set.add((Object)EnumFacing.DOWN);
<         } else if (\u2603 == 15) {
<             set.add((Object)EnumFacing.UP);
---
>         int j = pos >> 8 & 0xF;
>         if (j == 0) {
>             p_178610_2_.add((Object)EnumFacing.DOWN);
>         } else if (j == 15) {
>             p_178610_2_.add((Object)EnumFacing.UP);
103,107c101,105
<         \u2603 = n >> 4 & 0xF;
<         if (\u2603 == 0) {
<             set.add((Object)EnumFacing.NORTH);
<         } else if (\u2603 == 15) {
<             set.add((Object)EnumFacing.SOUTH);
---
>         int k = pos >> 4 & 0xF;
>         if (k == 0) {
>             p_178610_2_.add((Object)EnumFacing.NORTH);
>         } else if (k == 15) {
>             p_178610_2_.add((Object)EnumFacing.SOUTH);
111,112c109,110
<     private int getNeighborIndexAtFace(int n, EnumFacing enumFacing) {
<         switch (1.field_178617_a[enumFacing.ordinal()]) {
---
>     private int getNeighborIndexAtFace(int pos, EnumFacing facing) {
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing[facing.ordinal()]) {
114c112
<                 if ((n >> 8 & 0xF) == 0) {
---
>                 if ((pos >> 8 & 0xF) == 0) {
117c115
<                 return n - DY;
---
>                 return pos - DY;
120c118
<                 if ((n >> 8 & 0xF) == 15) {
---
>                 if ((pos >> 8 & 0xF) == 15) {
123c121
<                 return n + DY;
---
>                 return pos + DY;
126c124
<                 if ((n >> 4 & 0xF) == 0) {
---
>                 if ((pos >> 4 & 0xF) == 0) {
129c127
<                 return n - DZ;
---
>                 return pos - DZ;
132c130
<                 if ((n >> 4 & 0xF) == 15) {
---
>                 if ((pos >> 4 & 0xF) == 15) {
135c133
<                 return n + DZ;
---
>                 return pos + DZ;
138c136
<                 if ((n >> 0 & 0xF) == 0) {
---
>                 if ((pos >> 0 & 0xF) == 0) {
141c139
<                 return n - DX;
---
>                 return pos - DX;
144c142
<                 if ((n >> 0 & 0xF) == 15) {
---
>                 if ((pos >> 0 & 0xF) == 15) {
147c145
<                 return n + DX;
---
>                 return pos + DX;
154,161c152,159
<         boolean bl = false;
<         int \u26032 = 15;
<         int \u26033 = 0;
<         for (int i = 0; i < 16; ++i) {
<             for (\u2603 = 0; \u2603 < 16; ++\u2603) {
<                 for (\u2603 = 0; \u2603 < 16; ++\u2603) {
<                     if (i != 0 && i != 15 && \u2603 != 0 && \u2603 != 15 && \u2603 != 0 && \u2603 != 15) continue;
<                     VisGraph.INDEX_OF_EDGES[\u26033++] = VisGraph.getIndex(i, \u2603, \u2603);
---
>         boolean i = false;
>         int j = 15;
>         int k = 0;
>         for (int l = 0; l < 16; ++l) {
>             for (int i1 = 0; i1 < 16; ++i1) {
>                 for (int j1 = 0; j1 < 16; ++j1) {
>                     if (l != 0 && l != 15 && i1 != 0 && i1 != 15 && j1 != 0 && j1 != 15) continue;
>                     VisGraph.INDEX_OF_EDGES[k++] = VisGraph.getIndex(l, i1, j1);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/culling/ClippingHelper.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/culling/ClippingHelper.java
13a14
>     public boolean disabled = false;
15,16c16,17
<     private double dot(float[] fArray, double d, double d2, double d3) {
<         return (double)fArray[0] * d + (double)fArray[1] * d2 + (double)fArray[2] * d3 + (double)fArray[3];
---
>     private float dot(float[] p_178624_1_, float p_178624_2_, float p_178624_4_, float p_178624_6_) {
>         return p_178624_1_[0] * p_178624_2_ + p_178624_1_[1] * p_178624_4_ + p_178624_1_[2] * p_178624_6_ + p_178624_1_[3];
19c20,51
<     public boolean isBoxInFrustum(double d, double d2, double d3, double d4, double d5, double d6) {
---
>     public boolean isBoxInFrustum(double p_78553_1_, double p_78553_3_, double p_78553_5_, double p_78553_7_, double p_78553_9_, double p_78553_11_) {
>         if (this.disabled) {
>             return true;
>         }
>         float minXf = (float)p_78553_1_;
>         float minYf = (float)p_78553_3_;
>         float minZf = (float)p_78553_5_;
>         float maxXf = (float)p_78553_7_;
>         float maxYf = (float)p_78553_9_;
>         float maxZf = (float)p_78553_11_;
>         for (int var13 = 0; var13 < 6; ++var13) {
>             float[] frustumi = this.frustum[var13];
>             float frustumi0 = frustumi[0];
>             float frustumi1 = frustumi[1];
>             float frustumi2 = frustumi[2];
>             float frustumi3 = frustumi[3];
>             if (!(frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f) || !(frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f) || !(frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f) || !(frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f) || !(frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f) || !(frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f) || !(frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f) || !(frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f)) continue;
>             return false;
>         }
>         return true;
>     }
> 
>     public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
>         if (this.disabled) {
>             return true;
>         }
>         float minXf = (float)minX;
>         float minYf = (float)minY;
>         float minZf = (float)minZ;
>         float maxXf = (float)maxX;
>         float maxYf = (float)maxY;
>         float maxZf = (float)maxZ;
21,22c53,58
<             float[] fArray = this.frustum[i];
<             if (this.dot(fArray, d, d2, d3) > 0.0 || this.dot(fArray, d4, d2, d3) > 0.0 || this.dot(fArray, d, d5, d3) > 0.0 || this.dot(fArray, d4, d5, d3) > 0.0 || this.dot(fArray, d, d2, d6) > 0.0 || this.dot(fArray, d4, d2, d6) > 0.0 || this.dot(fArray, d, d5, d6) > 0.0 || this.dot(fArray, d4, d5, d6) > 0.0) continue;
---
>             float[] frustumi = this.frustum[i];
>             float frustumi0 = frustumi[0];
>             float frustumi1 = frustumi[1];
>             float frustumi2 = frustumi[2];
>             float frustumi3 = frustumi[3];
>             if (!(i < 4 ? frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f || frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f || frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f || frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f || frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f || frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f || frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f || frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f : frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0f && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0f && frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0f && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0f)) continue;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/culling/Frustum.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/culling/Frustum.java
29,30c29,30
<     public Frustum(ClippingHelper clippingHelper) {
<         this.clippingHelper = clippingHelper;
---
>     public Frustum(ClippingHelper clippingHelperIn) {
>         this.clippingHelper = clippingHelperIn;
33,36c33,36
<     public void setPosition(double d, double d2, double d3) {
<         this.x = d;
<         this.y = d2;
<         this.z = d3;
---
>     public void setPosition(double xIn, double yIn, double zIn) {
>         this.x = xIn;
>         this.y = yIn;
>         this.z = zIn;
39,40c39,40
<     public boolean isBoxInFrustum(double d, double d2, double d3, double d4, double d5, double d6) {
<         return this.clippingHelper.isBoxInFrustum(d - this.x, d2 - this.y, d3 - this.z, d4 - this.x, d5 - this.y, d6 - this.z);
---
>     public boolean isBoxInFrustum(double p_78548_1_, double p_78548_3_, double p_78548_5_, double p_78548_7_, double p_78548_9_, double p_78548_11_) {
>         return this.clippingHelper.isBoxInFrustum(p_78548_1_ - this.x, p_78548_3_ - this.y, p_78548_5_ - this.z, p_78548_7_ - this.x, p_78548_9_ - this.y, p_78548_11_ - this.z);
43,44c43,48
<     public boolean isBoundingBoxInFrustum(AxisAlignedBB axisAlignedBB) {
<         return this.isBoxInFrustum(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ, axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.maxZ);
---
>     public boolean isBoundingBoxInFrustum(AxisAlignedBB p_78546_1_) {
>         return this.isBoxInFrustum(p_78546_1_.minX, p_78546_1_.minY, p_78546_1_.minZ, p_78546_1_.maxX, p_78546_1_.maxY, p_78546_1_.maxZ);
>     }
> 
>     public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
>         return this.clippingHelper.isBoxInFrustumFully(minX - this.x, minY - this.y, minZ - this.z, maxX - this.x, maxY - this.y, maxZ - this.z);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java
4a5
>  *  Config
12a14
>  *  net.optifine.shaders.Shaders
22a25
> import net.optifine.shaders.Shaders;
28,29c31,32
<     public DebugRendererChunkBorder(Minecraft minecraft) {
<         this.minecraft = minecraft;
---
>     public DebugRendererChunkBorder(Minecraft minecraftIn) {
>         this.minecraft = minecraftIn;
32,41c35,49
<     public void render(float f, long l) {
<         int n;
<         EntityPlayerSP entityPlayerSP = this.minecraft.player;
<         Tessellator \u26032 = Tessellator.getInstance();
<         BufferBuilder \u26033 = \u26032.getBuffer();
<         double \u26034 = entityPlayerSP.M + (entityPlayerSP.p - entityPlayerSP.M) * (double)f;
<         double \u26035 = entityPlayerSP.N + (entityPlayerSP.q - entityPlayerSP.N) * (double)f;
<         double \u26036 = entityPlayerSP.O + (entityPlayerSP.r - entityPlayerSP.O) * (double)f;
<         double \u26037 = 0.0 - \u26035;
<         double \u26038 = 256.0 - \u26035;
---
>     public void render(float partialTicks, long finishTimeNano) {
>         if (Shaders.isShadowPass) {
>             return;
>         }
>         if (Config.isShaders()) {
>             Shaders.beginLeash();
>         }
>         EntityPlayerSP entityplayer = this.minecraft.player;
>         Tessellator tessellator = Tessellator.getInstance();
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
>         double d0 = entityplayer.M + (entityplayer.p - entityplayer.M) * (double)partialTicks;
>         double d1 = entityplayer.N + (entityplayer.q - entityplayer.N) * (double)partialTicks;
>         double d2 = entityplayer.O + (entityplayer.r - entityplayer.O) * (double)partialTicks;
>         double d3 = 0.0 - d1;
>         double d4 = 256.0 - d1;
44,45c52,53
<         double \u26039 = (double)(entityPlayerSP.ab << 4) - \u26034;
<         double \u260310 = (double)(entityPlayerSP.ad << 4) - \u26036;
---
>         double d5 = (double)(entityplayer.ab << 4) - d0;
>         double d6 = (double)(entityplayer.ad << 4) - d2;
47,53c55,61
<         \u26033.begin(3, DefaultVertexFormats.POSITION_COLOR);
<         for (n = -16; n <= 32; n += 16) {
<             for (\u2603 = -16; \u2603 <= 32; \u2603 += 16) {
<                 \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + (double)\u2603).color(1.0f, 0.0f, 0.0f, 0.0f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + (double)\u2603).color(1.0f, 0.0f, 0.0f, 0.5f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + (double)\u2603).color(1.0f, 0.0f, 0.0f, 0.5f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + (double)\u2603).color(1.0f, 0.0f, 0.0f, 0.0f).endVertex();
---
>         bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
>         for (int i = -16; i <= 32; i += 16) {
>             for (int j = -16; j <= 32; j += 16) {
>                 bufferbuilder.pos(d5 + (double)i, d3, d6 + (double)j).color(1.0f, 0.0f, 0.0f, 0.0f).endVertex();
>                 bufferbuilder.pos(d5 + (double)i, d3, d6 + (double)j).color(1.0f, 0.0f, 0.0f, 0.5f).endVertex();
>                 bufferbuilder.pos(d5 + (double)i, d4, d6 + (double)j).color(1.0f, 0.0f, 0.0f, 0.5f).endVertex();
>                 bufferbuilder.pos(d5 + (double)i, d4, d6 + (double)j).color(1.0f, 0.0f, 0.0f, 0.0f).endVertex();
56,84c64,92
<         for (n = 2; n < 16; n += 2) {
<             \u26033.pos(\u26039 + (double)n, \u26037, \u260310).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26037, \u260310).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26038, \u260310).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26038, \u260310).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<         }
<         for (n = 2; n < 16; n += 2) {
<             \u26033.pos(\u26039, \u26037, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039, \u26037, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, \u26038, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, \u26038, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, \u26037, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, \u26037, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, \u26038, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, \u26038, \u260310 + (double)n).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<         }
<         for (n = 0; n <= 256; n += 2) {
<             double d = (double)n - \u26035;
<             \u26033.pos(\u26039, d, \u260310).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, d, \u260310 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, d, \u260310).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
---
>         for (int k = 2; k < 16; k += 2) {
>             bufferbuilder.pos(d5 + (double)k, d3, d6).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d3, d6).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d4, d6).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d4, d6).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d3, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d3, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d4, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + (double)k, d4, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>         }
>         for (int l = 2; l < 16; l += 2) {
>             bufferbuilder.pos(d5, d3, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5, d3, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d4, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d4, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d3, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d3, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d4, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d4, d6 + (double)l).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>         }
>         for (int i1 = 0; i1 <= 256; i1 += 2) {
>             double d7 = (double)i1 - d1;
>             bufferbuilder.pos(d5, d7, d6).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5, d7, d6).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d7, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d7, d6 + 16.0).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d7, d6).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d7, d6).color(1.0f, 1.0f, 0.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d7, d6).color(1.0f, 1.0f, 0.0f, 0.0f).endVertex();
86c94
<         \u26032.draw();
---
>         tessellator.draw();
88,94c96,102
<         \u26033.begin(3, DefaultVertexFormats.POSITION_COLOR);
<         for (n = 0; n <= 16; n += 16) {
<             for (\u2603 = 0; \u2603 <= 16; \u2603 += 16) {
<                 \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + (double)\u2603).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26037, \u260310 + (double)\u2603).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + (double)\u2603).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<                 \u26033.pos(\u26039 + (double)n, \u26038, \u260310 + (double)\u2603).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
---
>         bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
>         for (int j1 = 0; j1 <= 16; j1 += 16) {
>             for (int l1 = 0; l1 <= 16; l1 += 16) {
>                 bufferbuilder.pos(d5 + (double)j1, d3, d6 + (double)l1).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
>                 bufferbuilder.pos(d5 + (double)j1, d3, d6 + (double)l1).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>                 bufferbuilder.pos(d5 + (double)j1, d4, d6 + (double)l1).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>                 bufferbuilder.pos(d5 + (double)j1, d4, d6 + (double)l1).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
97,105c105,113
<         for (n = 0; n <= 256; n += 16) {
<             double d = (double)n - \u26035;
<             \u26033.pos(\u26039, d, \u260310).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310 + 16.0).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, d, \u260310 + 16.0).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039 + 16.0, d, \u260310).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
<             \u26033.pos(\u26039, d, \u260310).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
---
>         for (int k1 = 0; k1 <= 256; k1 += 16) {
>             double d8 = (double)k1 - d1;
>             bufferbuilder.pos(d5, d8, d6).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
>             bufferbuilder.pos(d5, d8, d6).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d8, d6 + 16.0).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d8, d6 + 16.0).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5 + 16.0, d8, d6).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d8, d6).color(0.25f, 0.25f, 1.0f, 1.0f).endVertex();
>             bufferbuilder.pos(d5, d8, d6).color(0.25f, 0.25f, 1.0f, 0.0f).endVertex();
107c115
<         \u26032.draw();
---
>         tessellator.draw();
110a119,121
>         if (Config.isShaders()) {
>             Shaders.endLeash();
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/Render.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/Render.java
4a5,6
>  *  Config
>  *  java.lang.Class
25a28
>  *  net.minecraft.util.BlockRenderLayer
32a36,37
>  *  net.optifine.entity.model.IEntityRenderer
>  *  net.optifine.shaders.Shaders
52a58
> import net.minecraft.util.BlockRenderLayer;
59a66,67
> import net.optifine.entity.model.IEntityRenderer;
> import net.optifine.shaders.Shaders;
61c69,70
< public abstract class Render<T extends Entity> {
---
> public abstract class Render<T extends Entity>
> implements IEntityRenderer {
64c73
<     protected float shadowSize;
---
>     public float shadowSize;
66a76,77
>     private Class entityClass = null;
>     private ResourceLocation locationTextureCustom = null;
72,73c83,84
<     public void setRenderOutlines(boolean bl) {
<         this.renderOutlines = bl;
---
>     public void setRenderOutlines(boolean renderOutlinesIn) {
>         this.renderOutlines = renderOutlinesIn;
76,79c87,90
<     public boolean shouldRender(T t, ICamera iCamera, double d, double d2, double d3) {
<         AxisAlignedBB axisAlignedBB = t.getRenderBoundingBox().grow(0.5);
<         if (axisAlignedBB.hasNaN() || axisAlignedBB.getAverageEdgeLength() == 0.0) {
<             axisAlignedBB = new AxisAlignedBB(((Entity)t).posX - 2.0, ((Entity)t).posY - 2.0, ((Entity)t).posZ - 2.0, ((Entity)t).posX + 2.0, ((Entity)t).posY + 2.0, ((Entity)t).posZ + 2.0);
---
>     public boolean shouldRender(T livingEntity, ICamera camera, double camX, double camY, double camZ) {
>         AxisAlignedBB axisalignedbb = livingEntity.getRenderBoundingBox().grow(0.5);
>         if (axisalignedbb.hasNaN() || axisalignedbb.getAverageEdgeLength() == 0.0) {
>             axisalignedbb = new AxisAlignedBB(((Entity)livingEntity).posX - 2.0, ((Entity)livingEntity).posY - 2.0, ((Entity)livingEntity).posZ - 2.0, ((Entity)livingEntity).posX + 2.0, ((Entity)livingEntity).posY + 2.0, ((Entity)livingEntity).posZ + 2.0);
81c92
<         return t.isInRangeToRender3d(d, d2, d3) && (((Entity)t).ignoreFrustumCheck || iCamera.isBoundingBoxInFrustum(axisAlignedBB));
---
>         return livingEntity.isInRangeToRender3d(camX, camY, camZ) && (((Entity)livingEntity).ignoreFrustumCheck || camera.isBoundingBoxInFrustum(axisalignedbb));
84c95
<     public void doRender(T t, double d, double d2, double d3, float f, float f2) {
---
>     public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {
86c97
<             this.renderName(t, d, d2, d3);
---
>             this.renderName(entity, x, y, z);
90,94c101,106
<     protected int getTeamColor(T t) {
<         int n = 0xFFFFFF;
<         ScorePlayerTeam \u26032 = (ScorePlayerTeam)t.getTeam();
<         if (\u26032 != null && (\u2603 = FontRenderer.getFormatFromString((String)\u26032.getPrefix())).length() >= 2) {
<             n = this.getFontRendererFromRenderManager().getColorCode(\u2603.charAt(1));
---
>     protected int getTeamColor(T entityIn) {
>         String s;
>         int i = 0xFFFFFF;
>         ScorePlayerTeam scoreplayerteam = (ScorePlayerTeam)entityIn.getTeam();
>         if (scoreplayerteam != null && (s = FontRenderer.getFormatFromString((String)scoreplayerteam.getPrefix())).length() >= 2) {
>             i = this.getFontRendererFromRenderManager().getColorCode(s.charAt(1));
96c108
<         return n;
---
>         return i;
99,101c111,113
<     protected void renderName(T t, double d, double d2, double d3) {
<         if (!this.canRenderName(t)) {
<             return;
---
>     protected void renderName(T entity, double x, double y, double z) {
>         if (this.canRenderName(entity)) {
>             this.renderLivingLabel(entity, entity.getDisplayName().getFormattedText(), x, y, z, 64);
103d114
<         this.renderLivingLabel(t, t.getDisplayName().getFormattedText(), d, d2, d3, 64);
106,107c117,118
<     protected boolean canRenderName(T t) {
<         return t.getAlwaysRenderNameTagForRender() && t.hasCustomName();
---
>     protected boolean canRenderName(T entity) {
>         return entity.getAlwaysRenderNameTagForRender() && entity.hasCustomName();
110,111c121,122
<     protected void renderEntityName(T t, double d, double d2, double d3, String string, double d4) {
<         this.renderLivingLabel(t, string, d, d2, d3, 64);
---
>     protected void renderEntityName(T entityIn, double x, double y, double z, String name, double distanceSq) {
>         this.renderLivingLabel(entityIn, name, x, y, z, 64);
117,119c128,133
<     protected boolean bindEntityTexture(T t) {
<         ResourceLocation resourceLocation = this.getEntityTexture(t);
<         if (resourceLocation == null) {
---
>     protected boolean bindEntityTexture(T entity) {
>         ResourceLocation resourcelocation = this.getEntityTexture(entity);
>         if (this.locationTextureCustom != null) {
>             resourcelocation = this.locationTextureCustom;
>         }
>         if (resourcelocation == null) {
122c136
<         this.bindTexture(resourceLocation);
---
>         this.bindTexture(resourcelocation);
126,127c140,141
<     public void bindTexture(ResourceLocation resourceLocation) {
<         this.renderManager.renderEngine.bindTexture(resourceLocation);
---
>     public void bindTexture(ResourceLocation location) {
>         this.renderManager.renderEngine.bindTexture(location);
130c144
<     private void renderEntityOnFire(Entity entity, double d, double d2, double d3, float f) {
---
>     private void renderEntityOnFire(Entity entity, double x, double y, double z, float partialTicks) {
132,134c146,148
<         TextureMap textureMap = Minecraft.getMinecraft().getTextureMapBlocks();
<         TextureAtlasSprite \u26032 = textureMap.getAtlasSprite("minecraft:blocks/fire_layer_0");
<         TextureAtlasSprite \u26033 = textureMap.getAtlasSprite("minecraft:blocks/fire_layer_1");
---
>         TextureMap texturemap = Minecraft.getMinecraft().getTextureMapBlocks();
>         TextureAtlasSprite textureatlassprite = texturemap.getAtlasSprite("minecraft:blocks/fire_layer_0");
>         TextureAtlasSprite textureatlassprite1 = texturemap.getAtlasSprite("minecraft:blocks/fire_layer_1");
136,144c150,158
<         GlStateManager.translate((float)((float)d), (float)((float)d2), (float)((float)d3));
<         float \u26034 = entity.width * 1.4f;
<         GlStateManager.scale((float)\u26034, (float)\u26034, (float)\u26034);
<         Tessellator \u26035 = Tessellator.getInstance();
<         BufferBuilder \u26036 = \u26035.getBuffer();
<         float \u26037 = 0.5f;
<         float \u26038 = 0.0f;
<         float \u26039 = entity.height / \u26034;
<         float \u260310 = (float)(entity.posY - entity.getEntityBoundingBox().minY);
---
>         GlStateManager.translate((float)((float)x), (float)((float)y), (float)((float)z));
>         float f = entity.width * 1.4f;
>         GlStateManager.scale((float)f, (float)f, (float)f);
>         Tessellator tessellator = Tessellator.getInstance();
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
>         float f1 = 0.5f;
>         float f2 = 0.0f;
>         float f3 = entity.height / f;
>         float f4 = (float)(entity.posY - entity.getEntityBoundingBox().minY);
146c160
<         GlStateManager.translate((float)0.0f, (float)0.0f, (float)(-0.3f + (float)((int)\u26039) * 0.02f));
---
>         GlStateManager.translate((float)0.0f, (float)0.0f, (float)(-0.3f + (float)((int)f3) * 0.02f));
148,152c162,171
<         float \u260311 = 0.0f;
<         int \u260312 = 0;
<         \u26036.begin(7, DefaultVertexFormats.POSITION_TEX);
<         while (\u26039 > 0.0f) {
<             TextureAtlasSprite textureAtlasSprite = \u260312 % 2 == 0 ? \u26032 : \u26033;
---
>         float f5 = 0.0f;
>         int i = 0;
>         boolean multitexture = Config.isMultiTexture();
>         if (multitexture) {
>             bufferbuilder.setBlockLayer(BlockRenderLayer.SOLID);
>         }
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
>         while (f3 > 0.0f) {
>             TextureAtlasSprite textureatlassprite2 = i % 2 == 0 ? textureatlassprite : textureatlassprite1;
>             bufferbuilder.setSprite(textureatlassprite2);
154,161c173,180
<             float \u260313 = textureAtlasSprite.getMinU();
<             float \u260314 = textureAtlasSprite.getMinV();
<             float \u260315 = textureAtlasSprite.getMaxU();
<             float \u260316 = textureAtlasSprite.getMaxV();
<             if (\u260312 / 2 % 2 == 0) {
<                 float f2 = \u260315;
<                 \u260315 = \u260313;
<                 \u260313 = f2;
---
>             float f6 = textureatlassprite2.getMinU();
>             float f7 = textureatlassprite2.getMinV();
>             float f8 = textureatlassprite2.getMaxU();
>             float f9 = textureatlassprite2.getMaxV();
>             if (i / 2 % 2 == 0) {
>                 float f10 = f8;
>                 f8 = f6;
>                 f6 = f10;
163,171c182,195
<             \u26036.pos((double)(\u26037 - 0.0f), (double)(0.0f - \u260310), (double)\u260311).tex((double)\u260315, (double)\u260316).endVertex();
<             \u26036.pos((double)(-\u26037 - 0.0f), (double)(0.0f - \u260310), (double)\u260311).tex((double)\u260313, (double)\u260316).endVertex();
<             \u26036.pos((double)(-\u26037 - 0.0f), (double)(1.4f - \u260310), (double)\u260311).tex((double)\u260313, (double)\u260314).endVertex();
<             \u26036.pos((double)(\u26037 - 0.0f), (double)(1.4f - \u260310), (double)\u260311).tex((double)\u260315, (double)\u260314).endVertex();
<             \u26039 -= 0.45f;
<             \u260310 -= 0.45f;
<             \u26037 *= 0.9f;
<             \u260311 += 0.03f;
<             ++\u260312;
---
>             bufferbuilder.pos((double)(f1 - 0.0f), (double)(0.0f - f4), (double)f5).tex((double)f8, (double)f9).endVertex();
>             bufferbuilder.pos((double)(-f1 - 0.0f), (double)(0.0f - f4), (double)f5).tex((double)f6, (double)f9).endVertex();
>             bufferbuilder.pos((double)(-f1 - 0.0f), (double)(1.4f - f4), (double)f5).tex((double)f6, (double)f7).endVertex();
>             bufferbuilder.pos((double)(f1 - 0.0f), (double)(1.4f - f4), (double)f5).tex((double)f8, (double)f7).endVertex();
>             f3 -= 0.45f;
>             f4 -= 0.45f;
>             f1 *= 0.9f;
>             f5 += 0.03f;
>             ++i;
>         }
>         tessellator.draw();
>         if (multitexture) {
>             bufferbuilder.setBlockLayer(null);
>             GlStateManager.bindCurrentTexture();
173d196
<         \u26035.draw();
178,179c201,204
<     private void renderShadow(Entity entity2, double d, double d2, double d3, float f, float f2) {
<         Entity entity2;
---
>     private void renderShadow(Entity entityIn, double x, double y, double z, float shadowAlpha, float partialTicks) {
>         if (Config.isShaders() && Shaders.shouldSkipDefaultShadow) {
>             return;
>         }
185,190c210,215
<         float \u26032 = this.shadowSize;
<         if (entity2 instanceof EntityLiving) {
<             EntityLiving entityLiving = (EntityLiving)entity2;
<             \u26032 *= entityLiving.getRenderSizeModifier();
<             if (entityLiving.isChild()) {
<                 \u26032 *= 0.5f;
---
>         float f = this.shadowSize;
>         if (entityIn instanceof EntityLiving) {
>             EntityLiving entityliving = (EntityLiving)entityIn;
>             f *= entityliving.getRenderSizeModifier();
>             if (entityliving.isChild()) {
>                 f *= 0.5f;
193,211c218,236
<         double \u26033 = entity2.lastTickPosX + (entity2.posX - entity2.lastTickPosX) * (double)f2;
<         double \u26034 = entity2.lastTickPosY + (entity2.posY - entity2.lastTickPosY) * (double)f2;
<         double \u26035 = entity2.lastTickPosZ + (entity2.posZ - entity2.lastTickPosZ) * (double)f2;
<         int \u26036 = MathHelper.floor((double)(\u26033 - (double)\u26032));
<         int \u26037 = MathHelper.floor((double)(\u26033 + (double)\u26032));
<         int \u26038 = MathHelper.floor((double)(\u26034 - (double)\u26032));
<         int \u26039 = MathHelper.floor((double)\u26034);
<         int \u260310 = MathHelper.floor((double)(\u26035 - (double)\u26032));
<         int \u260311 = MathHelper.floor((double)(\u26035 + (double)\u26032));
<         double \u260312 = d - \u26033;
<         double \u260313 = d2 - \u26034;
<         double \u260314 = d3 - \u26035;
<         Tessellator \u260315 = Tessellator.getInstance();
<         BufferBuilder \u260316 = \u260315.getBuffer();
<         \u260316.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
<         for (BlockPos blockPos : BlockPos.getAllInBoxMutable((BlockPos)new BlockPos(\u26036, \u26038, \u260310), (BlockPos)new BlockPos(\u26037, \u26039, \u260311))) {
<             IBlockState iBlockState = world.getBlockState(blockPos.down());
<             if (iBlockState.i() == EnumBlockRenderType.INVISIBLE || world.getLightFromNeighbors(blockPos) <= 3) continue;
<             this.renderShadowSingle(iBlockState, d, d2, d3, blockPos, f, \u26032, \u260312, \u260313, \u260314);
---
>         double d5 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * (double)partialTicks;
>         double d0 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * (double)partialTicks;
>         double d1 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * (double)partialTicks;
>         int i = MathHelper.floor((double)(d5 - (double)f));
>         int j = MathHelper.floor((double)(d5 + (double)f));
>         int k = MathHelper.floor((double)(d0 - (double)f));
>         int l = MathHelper.floor((double)d0);
>         int i1 = MathHelper.floor((double)(d1 - (double)f));
>         int j1 = MathHelper.floor((double)(d1 + (double)f));
>         double d2 = x - d5;
>         double d3 = y - d0;
>         double d4 = z - d1;
>         Tessellator tessellator = Tessellator.getInstance();
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
>         for (BlockPos blockpos : BlockPos.getAllInBoxMutable((BlockPos)new BlockPos(i, k, i1), (BlockPos)new BlockPos(j, l, j1))) {
>             IBlockState iblockstate = world.getBlockState(blockpos.down());
>             if (iblockstate.i() == EnumBlockRenderType.INVISIBLE || world.getLightFromNeighbors(blockpos) <= 3) continue;
>             this.renderShadowSingle(iblockstate, x, y, z, blockpos, shadowAlpha, f, d2, d3, d4);
213c238
<         \u260315.draw();
---
>         tessellator.draw();
223,234c248,271
<     private void renderShadowSingle(IBlockState iBlockState, double d, double d2, double d3, BlockPos blockPos, float f, float f2, double d4, double d5, double d6) {
<         if (!iBlockState.g()) {
<             return;
<         }
<         Tessellator tessellator = Tessellator.getInstance();
<         BufferBuilder \u26032 = tessellator.getBuffer();
<         double \u26033 = ((double)f - (d2 - ((double)blockPos.q() + d5)) / 2.0) * 0.5 * (double)this.getWorldFromRenderManager().getLightBrightness(blockPos);
<         if (\u26033 < 0.0) {
<             return;
<         }
<         if (\u26033 > 1.0) {
<             \u26033 = 1.0;
---
>     private void renderShadowSingle(IBlockState state, double p_188299_2_, double p_188299_4_, double p_188299_6_, BlockPos p_188299_8_, float p_188299_9_, float p_188299_10_, double p_188299_11_, double p_188299_13_, double p_188299_15_) {
>         if (state.g()) {
>             Tessellator tessellator = Tessellator.getInstance();
>             BufferBuilder bufferbuilder = tessellator.getBuffer();
>             double d0 = ((double)p_188299_9_ - (p_188299_4_ - ((double)p_188299_8_.q() + p_188299_13_)) / 2.0) * 0.5 * (double)this.getWorldFromRenderManager().getLightBrightness(p_188299_8_);
>             if (d0 >= 0.0) {
>                 if (d0 > 1.0) {
>                     d0 = 1.0;
>                 }
>                 AxisAlignedBB axisalignedbb = state.e((IBlockAccess)this.getWorldFromRenderManager(), p_188299_8_);
>                 double d1 = (double)p_188299_8_.p() + axisalignedbb.minX + p_188299_11_;
>                 double d2 = (double)p_188299_8_.p() + axisalignedbb.maxX + p_188299_11_;
>                 double d3 = (double)p_188299_8_.q() + axisalignedbb.minY + p_188299_13_ + 0.015625;
>                 double d4 = (double)p_188299_8_.r() + axisalignedbb.minZ + p_188299_15_;
>                 double d5 = (double)p_188299_8_.r() + axisalignedbb.maxZ + p_188299_15_;
>                 float f = (float)((p_188299_2_ - d1) / 2.0 / (double)p_188299_10_ + 0.5);
>                 float f1 = (float)((p_188299_2_ - d2) / 2.0 / (double)p_188299_10_ + 0.5);
>                 float f2 = (float)((p_188299_6_ - d4) / 2.0 / (double)p_188299_10_ + 0.5);
>                 float f3 = (float)((p_188299_6_ - d5) / 2.0 / (double)p_188299_10_ + 0.5);
>                 bufferbuilder.pos(d1, d3, d4).tex((double)f, (double)f2).color(1.0f, 1.0f, 1.0f, (float)d0).endVertex();
>                 bufferbuilder.pos(d1, d3, d5).tex((double)f, (double)f3).color(1.0f, 1.0f, 1.0f, (float)d0).endVertex();
>                 bufferbuilder.pos(d2, d3, d5).tex((double)f1, (double)f3).color(1.0f, 1.0f, 1.0f, (float)d0).endVertex();
>                 bufferbuilder.pos(d2, d3, d4).tex((double)f1, (double)f2).color(1.0f, 1.0f, 1.0f, (float)d0).endVertex();
>             }
236,249d272
<         AxisAlignedBB \u26034 = iBlockState.e((IBlockAccess)this.getWorldFromRenderManager(), blockPos);
<         double \u26035 = (double)blockPos.p() + \u26034.minX + d4;
<         double \u26036 = (double)blockPos.p() + \u26034.maxX + d4;
<         double \u26037 = (double)blockPos.q() + \u26034.minY + d5 + 0.015625;
<         double \u26038 = (double)blockPos.r() + \u26034.minZ + d6;
<         double \u26039 = (double)blockPos.r() + \u26034.maxZ + d6;
<         float \u260310 = (float)((d - \u26035) / 2.0 / (double)f2 + 0.5);
<         float \u260311 = (float)((d - \u26036) / 2.0 / (double)f2 + 0.5);
<         float \u260312 = (float)((d3 - \u26038) / 2.0 / (double)f2 + 0.5);
<         float \u260313 = (float)((d3 - \u26039) / 2.0 / (double)f2 + 0.5);
<         \u26032.pos(\u26035, \u26037, \u26038).tex((double)\u260310, (double)\u260312).color(1.0f, 1.0f, 1.0f, (float)\u26033).endVertex();
<         \u26032.pos(\u26035, \u26037, \u26039).tex((double)\u260310, (double)\u260313).color(1.0f, 1.0f, 1.0f, (float)\u26033).endVertex();
<         \u26032.pos(\u26036, \u26037, \u26039).tex((double)\u260311, (double)\u260313).color(1.0f, 1.0f, 1.0f, (float)\u26033).endVertex();
<         \u26032.pos(\u26036, \u26037, \u26038).tex((double)\u260311, (double)\u260312).color(1.0f, 1.0f, 1.0f, (float)\u26033).endVertex();
252c275
<     public static void renderOffsetAABB(AxisAlignedBB axisAlignedBB, double d, double d2, double d3) {
---
>     public static void renderOffsetAABB(AxisAlignedBB boundingBox, double x, double y, double z) {
255c278
<         BufferBuilder \u26032 = tessellator.getBuffer();
---
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
257,282c280,305
<         \u26032.setTranslation(d, d2, d3);
<         \u26032.begin(7, DefaultVertexFormats.POSITION_NORMAL);
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(0.0f, -1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(0.0f, -1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(0.0f, -1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(0.0f, -1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.minZ).normal(1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.minZ).normal(1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.maxY, axisAlignedBB.maxZ).normal(1.0f, 0.0f, 0.0f).endVertex();
<         \u26032.pos(axisAlignedBB.maxX, axisAlignedBB.minY, axisAlignedBB.maxZ).normal(1.0f, 0.0f, 0.0f).endVertex();
---
>         bufferbuilder.setTranslation(x, y, z);
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_NORMAL);
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(0.0f, 0.0f, -1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(0.0f, 0.0f, 1.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(0.0f, -1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(0.0f, -1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(0.0f, -1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(0.0f, -1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(0.0f, 1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(0.0f, 1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(0.0f, 1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(0.0f, 1.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(-1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(1.0f, 0.0f, 0.0f).endVertex();
>         bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(1.0f, 0.0f, 0.0f).endVertex();
284c307
<         \u26032.setTranslation(0.0, 0.0, 0.0);
---
>         bufferbuilder.setTranslation(0.0, 0.0, 0.0);
288,296c311,320
<     public void doRenderShadowAndFire(Entity entity, double d, double d2, double d3, float f, float f2) {
<         if (this.renderManager.options == null) {
<             return;
<         }
<         if (this.renderManager.options.entityShadows && this.shadowSize > 0.0f && !entity.isInvisible() && this.renderManager.isRenderShadow() && (\u2603 = (float)((1.0 - (\u2603 = this.renderManager.getDistanceToCamera(entity.posX, entity.posY, entity.posZ)) / 256.0) * (double)this.shadowOpaque)) > 0.0f) {
<             this.renderShadow(entity, d, d2, d3, \u2603, f2);
<         }
<         if (!(!entity.canRenderOnFire() || entity instanceof EntityPlayer && ((EntityPlayer)entity).isSpectator())) {
<             this.renderEntityOnFire(entity, d, d2, d3, f2);
---
>     public void doRenderShadowAndFire(Entity entityIn, double x, double y, double z, float yaw, float partialTicks) {
>         if (this.renderManager.options != null) {
>             double d0;
>             float f;
>             if (this.renderManager.options.entityShadows && this.shadowSize > 0.0f && !entityIn.isInvisible() && this.renderManager.isRenderShadow() && (f = (float)((1.0 - (d0 = this.renderManager.getDistanceToCamera(entityIn.posX, entityIn.posY, entityIn.posZ)) / 256.0) * (double)this.shadowOpaque)) > 0.0f) {
>                 this.renderShadow(entityIn, x, y, z, f, partialTicks);
>             }
>             if (!(!entityIn.canRenderOnFire() || entityIn instanceof EntityPlayer && ((EntityPlayer)entityIn).isSpectator())) {
>                 this.renderEntityOnFire(entityIn, x, y, z, partialTicks);
>             }
304,307c328,337
<     protected void renderLivingLabel(T t, String string, double d, double d2, double d3, int n) {
<         double d4 = t.getDistanceSq(this.renderManager.renderViewEntity);
<         if (d4 > (double)(n * n)) {
<             return;
---
>     protected void renderLivingLabel(T entityIn, String str, double x, double y, double z, int maxDistance) {
>         double d0 = entityIn.getDistanceSq(this.renderManager.renderViewEntity);
>         if (d0 <= (double)(maxDistance * maxDistance)) {
>             boolean flag = entityIn.isSneaking();
>             float f = this.renderManager.playerViewY;
>             float f1 = this.renderManager.playerViewX;
>             boolean flag1 = this.renderManager.options.thirdPersonView == 2;
>             float f2 = ((Entity)entityIn).height + 0.5f - (flag ? 0.25f : 0.0f);
>             int i = "deadmau5".equals((Object)str) ? -10 : 0;
>             EntityRenderer.drawNameplate((FontRenderer)this.getFontRendererFromRenderManager(), (String)str, (float)((float)x), (float)((float)y + f2), (float)((float)z), (int)i, (float)f, (float)f1, (boolean)flag1, (boolean)flag);
309,315d338
<         boolean \u26032 = t.isSneaking();
<         float \u26033 = this.renderManager.playerViewY;
<         float \u26034 = this.renderManager.playerViewX;
<         boolean \u26035 = this.renderManager.options.thirdPersonView == 2;
<         float \u26036 = ((Entity)t).height + 0.5f - (\u26032 ? 0.25f : 0.0f);
<         int \u26037 = "deadmau5".equals((Object)string) ? -10 : 0;
<         EntityRenderer.drawNameplate((FontRenderer)this.getFontRendererFromRenderManager(), (String)string, (float)((float)d), (float)((float)d2 + \u26036), (float)((float)d3), (int)\u26037, (float)\u26033, (float)\u26034, (boolean)\u26035, (boolean)\u26032);
326c349,365
<     public void renderMultipass(T t, double d, double d2, double d3, float f, float f2) {
---
>     public void renderMultipass(T p_188300_1_, double p_188300_2_, double p_188300_4_, double p_188300_6_, float p_188300_8_, float p_188300_9_) {
>     }
> 
>     public Class getEntityClass() {
>         return this.entityClass;
>     }
> 
>     public void setEntityClass(Class entityClass) {
>         this.entityClass = entityClass;
>     }
> 
>     public ResourceLocation getLocationTextureCustom() {
>         return this.locationTextureCustom;
>     }
> 
>     public void setLocationTextureCustom(ResourceLocation locationTextureCustom) {
>         this.locationTextureCustom = locationTextureCustom;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/RenderItemFrame.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/RenderItemFrame.java
4a5,6
>  *  Config
>  *  java.lang.Math
8a11
>  *  net.minecraft.client.entity.EntityPlayerSP
21a25
>  *  net.minecraft.init.Items
25a30
>  *  net.minecraft.world.World
27,31c32,35
<  *  net.minecraftforge.client.event.RenderItemInFrameEvent
<  *  net.minecraftforge.common.MinecraftForge
<  *  net.minecraftforge.fml.common.eventhandler.Event
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.shaders.Shaders
36a41
> import net.minecraft.client.entity.EntityPlayerSP;
49a55
> import net.minecraft.init.Items;
53a60
> import net.minecraft.world.World;
55,59c62,65
< import net.minecraftforge.client.event.RenderItemInFrameEvent;
< import net.minecraftforge.common.MinecraftForge;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.shaders.Shaders;
61d66
< @SideOnly(value=Side.CLIENT)
68a74
>     private static double itemRenderDistanceSq = 4096.0;
112a119,128
>             if (!this.isRenderItem(itemFrame)) {
>                 return;
>             }
>             if (!Config.zoomMode) {
>                 EntityPlayerSP player = this.mc.player;
>                 double distSq = itemFrame.d(player.posX, player.posY, player.posZ);
>                 if (distSq > 4096.0) {
>                     return;
>                 }
>             }
118,119c134
<             RenderItemInFrameEvent event = new RenderItemInFrameEvent(itemFrame, this);
<             if (!MinecraftForge.EVENT_BUS.post((Event)event)) {
---
>             if (!Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.RenderItemInFrameEvent_Constructor, (Object[])new Object[]{itemFrame, this})) {
126c141
<                     MapData mapdata = ((ItemMap)itemstack.getItem()).getMapData(itemstack, itemFrame.l);
---
>                     MapData mapdata = ReflectorForge.getMapData((ItemMap)Items.FILLED_MAP, (ItemStack)itemstack, (World)itemFrame.l);
154a170,190
>     }
> 
>     private boolean isRenderItem(EntityItemFrame itemFrame) {
>         if (Shaders.isShadowPass) {
>             return false;
>         }
>         if (!Config.zoomMode) {
>             Entity viewEntity = this.mc.getRenderViewEntity();
>             double distSq = itemFrame.d(viewEntity.posX, viewEntity.posY, viewEntity.posZ);
>             if (distSq > itemRenderDistanceSq) {
>                 return false;
>             }
>         }
>         return true;
>     }
> 
>     public static void updateItemRenderDistance() {
>         Minecraft mc = Config.getMinecraft();
>         double fov = Config.limit((float)mc.gameSettings.fovSetting, (float)1.0f, (float)120.0f);
>         double itemRenderDistance = Math.max((double)(6.0 * (double)mc.displayHeight / fov), (double)16.0);
>         itemRenderDistanceSq = itemRenderDistance * itemRenderDistance;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/RenderLiving.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/RenderLiving.java
4a5
>  *  Config
19c20
<  *  net.minecraft.entity.EntityLivingBase
---
>  *  net.optifine.shaders.Shaders
35c36
< import net.minecraft.entity.EntityLivingBase;
---
> import net.optifine.shaders.Shaders;
39,40c40,41
<     public RenderLiving(RenderManager renderManager, ModelBase modelBase, float f) {
<         super(renderManager, modelBase, f);
---
>     public RenderLiving(RenderManager rendermanagerIn, ModelBase modelbaseIn, float shadowsizeIn) {
>         super(rendermanagerIn, modelbaseIn, shadowsizeIn);
43,44c44,45
<     protected boolean canRenderName(T t) {
<         return super.canRenderName(t) && (t.getAlwaysRenderNameTagForRender() || t.n_() && t == this.renderManager.pointedEntity);
---
>     protected boolean canRenderName(T entity) {
>         return super.canRenderName(entity) && (entity.getAlwaysRenderNameTagForRender() || entity.n_() && entity == this.renderManager.pointedEntity);
47,48c48,49
<     public boolean shouldRender(T t, ICamera iCamera, double d, double d2, double d3) {
<         if (super.shouldRender(t, iCamera, d, d2, d3)) {
---
>     public boolean shouldRender(T livingEntity, ICamera camera, double camX, double camY, double camZ) {
>         if (super.shouldRender(livingEntity, camera, camX, camY, camZ)) {
51,53c52,54
<         if (t.getLeashed() && t.getLeashHolder() != null) {
<             Entity entity = t.getLeashHolder();
<             return iCamera.isBoundingBoxInFrustum(entity.getRenderBoundingBox());
---
>         if (livingEntity.getLeashed() && livingEntity.getLeashHolder() != null) {
>             Entity entity = livingEntity.getLeashHolder();
>             return camera.isBoundingBoxInFrustum(entity.getRenderBoundingBox());
58,59c59,60
<     public void doRender(T t, double d, double d2, double d3, float f, float f2) {
<         super.doRender(t, d, d2, d3, f, f2);
---
>     public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {
>         super.doRender(entity, x, y, z, entityYaw, partialTicks);
61c62
<             this.renderLeash(t, d, d2, d3, f, f2);
---
>             this.renderLeash(entity, x, y, z, entityYaw, partialTicks);
65,80c66,78
<     public void setLightmap(T t) {
<         int n = t.av();
<         \u2603 = n % 65536;
<         \u2603 = n / 65536;
<         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)\u2603, (float)\u2603);
<     }
< 
<     private double interpolateValue(double d, double d2, double d3) {
<         return d + (d2 - d) * d3;
<     }
< 
<     protected void renderLeash(T t, double d, double d2, double d3, float f, float f2) {
<         float f3;
<         int n;
<         Entity entity = t.getLeashHolder();
<         if (entity == null) {
---
>     public void setLightmap(T entityLivingIn) {
>         int i = entityLivingIn.av();
>         int j = i % 65536;
>         int k = i / 65536;
>         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
>     }
> 
>     private double interpolateValue(double start, double end, double pct) {
>         return start + (end - start) * pct;
>     }
> 
>     protected void renderLeash(T entityLivingIn, double x, double y, double z, float entityYaw, float partialTicks) {
>         if (Config.isShaders() && Shaders.isShadowPass) {
83,124c81,94
<         d2 -= (1.6 - (double)((EntityLiving)t).H) * 0.5;
<         Tessellator \u26032 = Tessellator.getInstance();
<         BufferBuilder \u26033 = \u26032.getBuffer();
<         double \u26034 = this.interpolateValue(entity.prevRotationYaw, entity.rotationYaw, f2 * 0.5f) * 0.01745329238474369;
<         double \u26035 = this.interpolateValue(entity.prevRotationPitch, entity.rotationPitch, f2 * 0.5f) * 0.01745329238474369;
<         double \u26036 = Math.cos((double)\u26034);
<         double \u26037 = Math.sin((double)\u26034);
<         double \u26038 = Math.sin((double)\u26035);
<         if (entity instanceof EntityHanging) {
<             \u26036 = 0.0;
<             \u26037 = 0.0;
<             \u26038 = -1.0;
<         }
<         double \u26039 = Math.cos((double)\u26035);
<         double \u260310 = this.interpolateValue(entity.prevPosX, entity.posX, f2) - \u26036 * 0.7 - \u26037 * 0.5 * \u26039;
<         double \u260311 = this.interpolateValue(entity.prevPosY + (double)entity.getEyeHeight() * 0.7, entity.posY + (double)entity.getEyeHeight() * 0.7, f2) - \u26038 * 0.5 - 0.25;
<         double \u260312 = this.interpolateValue(entity.prevPosZ, entity.posZ, f2) - \u26037 * 0.7 + \u26036 * 0.5 * \u26039;
<         double \u260313 = this.interpolateValue(((EntityLiving)t).prevRenderYawOffset, ((EntityLiving)t).renderYawOffset, f2) * 0.01745329238474369 + 1.5707963267948966;
<         \u26036 = Math.cos((double)\u260313) * (double)((EntityLiving)t).G * 0.4;
<         \u26037 = Math.sin((double)\u260313) * (double)((EntityLiving)t).G * 0.4;
<         double \u260314 = this.interpolateValue(((EntityLiving)t).m, ((EntityLiving)t).p, f2) + \u26036;
<         double \u260315 = this.interpolateValue(((EntityLiving)t).n, ((EntityLiving)t).q, f2);
<         double \u260316 = this.interpolateValue(((EntityLiving)t).o, ((EntityLiving)t).r, f2) + \u26037;
<         d += \u26036;
<         d3 += \u26037;
<         double \u260317 = (float)(\u260310 - \u260314);
<         double \u260318 = (float)(\u260311 - \u260315);
<         double \u260319 = (float)(\u260312 - \u260316);
<         GlStateManager.disableTexture2D();
<         GlStateManager.disableLighting();
<         GlStateManager.disableCull();
<         int \u260320 = 24;
<         double \u260321 = 0.025;
<         \u26033.begin(5, DefaultVertexFormats.POSITION_COLOR);
<         for (n = 0; n <= 24; ++n) {
<             f3 = 0.5f;
<             \u2603 = 0.4f;
<             \u2603 = 0.3f;
<             if (n % 2 == 0) {
<                 f3 *= 0.7f;
<                 \u2603 *= 0.7f;
<                 \u2603 *= 0.7f;
---
>         Entity entity = entityLivingIn.getLeashHolder();
>         if (entity != null) {
>             y -= (1.6 - (double)((EntityLiving)entityLivingIn).H) * 0.5;
>             Tessellator tessellator = Tessellator.getInstance();
>             BufferBuilder bufferbuilder = tessellator.getBuffer();
>             double d0 = this.interpolateValue(entity.prevRotationYaw, entity.rotationYaw, partialTicks * 0.5f) * 0.01745329238474369;
>             double d1 = this.interpolateValue(entity.prevRotationPitch, entity.rotationPitch, partialTicks * 0.5f) * 0.01745329238474369;
>             double d2 = Math.cos((double)d0);
>             double d3 = Math.sin((double)d0);
>             double d4 = Math.sin((double)d1);
>             if (entity instanceof EntityHanging) {
>                 d2 = 0.0;
>                 d3 = 0.0;
>                 d4 = -1.0;
126,139c96,115
<             \u2603 = (float)n / 24.0f;
<             \u26033.pos(d + \u260317 * (double)\u2603 + 0.0, d2 + \u260318 * (double)(\u2603 * \u2603 + \u2603) * 0.5 + (double)((24.0f - (float)n) / 18.0f + 0.125f), d3 + \u260319 * (double)\u2603).color(f3, \u2603, \u2603, 1.0f).endVertex();
<             \u26033.pos(d + \u260317 * (double)\u2603 + 0.025, d2 + \u260318 * (double)(\u2603 * \u2603 + \u2603) * 0.5 + (double)((24.0f - (float)n) / 18.0f + 0.125f) + 0.025, d3 + \u260319 * (double)\u2603).color(f3, \u2603, \u2603, 1.0f).endVertex();
<         }
<         \u26032.draw();
<         \u26033.begin(5, DefaultVertexFormats.POSITION_COLOR);
<         for (n = 0; n <= 24; ++n) {
<             f3 = 0.5f;
<             \u2603 = 0.4f;
<             \u2603 = 0.3f;
<             if (n % 2 == 0) {
<                 f3 *= 0.7f;
<                 \u2603 *= 0.7f;
<                 \u2603 *= 0.7f;
---
>             double d5 = Math.cos((double)d1);
>             double d6 = this.interpolateValue(entity.prevPosX, entity.posX, partialTicks) - d2 * 0.7 - d3 * 0.5 * d5;
>             double d7 = this.interpolateValue(entity.prevPosY + (double)entity.getEyeHeight() * 0.7, entity.posY + (double)entity.getEyeHeight() * 0.7, partialTicks) - d4 * 0.5 - 0.25;
>             double d8 = this.interpolateValue(entity.prevPosZ, entity.posZ, partialTicks) - d3 * 0.7 + d2 * 0.5 * d5;
>             double d9 = this.interpolateValue(((EntityLiving)entityLivingIn).prevRenderYawOffset, ((EntityLiving)entityLivingIn).renderYawOffset, partialTicks) * 0.01745329238474369 + 1.5707963267948966;
>             d2 = Math.cos((double)d9) * (double)((EntityLiving)entityLivingIn).G * 0.4;
>             d3 = Math.sin((double)d9) * (double)((EntityLiving)entityLivingIn).G * 0.4;
>             double d10 = this.interpolateValue(((EntityLiving)entityLivingIn).m, ((EntityLiving)entityLivingIn).p, partialTicks) + d2;
>             double d11 = this.interpolateValue(((EntityLiving)entityLivingIn).n, ((EntityLiving)entityLivingIn).q, partialTicks);
>             double d12 = this.interpolateValue(((EntityLiving)entityLivingIn).o, ((EntityLiving)entityLivingIn).r, partialTicks) + d3;
>             x += d2;
>             z += d3;
>             double d13 = (float)(d6 - d10);
>             double d14 = (float)(d7 - d11);
>             double d15 = (float)(d8 - d12);
>             GlStateManager.disableTexture2D();
>             GlStateManager.disableLighting();
>             GlStateManager.disableCull();
>             if (Config.isShaders()) {
>                 Shaders.beginLeash();
141,143c117,154
<             \u2603 = (float)n / 24.0f;
<             \u26033.pos(d + \u260317 * (double)\u2603 + 0.0, d2 + \u260318 * (double)(\u2603 * \u2603 + \u2603) * 0.5 + (double)((24.0f - (float)n) / 18.0f + 0.125f) + 0.025, d3 + \u260319 * (double)\u2603).color(f3, \u2603, \u2603, 1.0f).endVertex();
<             \u26033.pos(d + \u260317 * (double)\u2603 + 0.025, d2 + \u260318 * (double)(\u2603 * \u2603 + \u2603) * 0.5 + (double)((24.0f - (float)n) / 18.0f + 0.125f), d3 + \u260319 * (double)\u2603 + 0.025).color(f3, \u2603, \u2603, 1.0f).endVertex();
---
>             int i = 24;
>             double d16 = 0.025;
>             bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
>             for (int j = 0; j <= 24; ++j) {
>                 float f = 0.5f;
>                 float f1 = 0.4f;
>                 float f2 = 0.3f;
>                 if (j % 2 == 0) {
>                     f *= 0.7f;
>                     f1 *= 0.7f;
>                     f2 *= 0.7f;
>                 }
>                 float f3 = (float)j / 24.0f;
>                 bufferbuilder.pos(x + d13 * (double)f3 + 0.0, y + d14 * (double)(f3 * f3 + f3) * 0.5 + (double)((24.0f - (float)j) / 18.0f + 0.125f), z + d15 * (double)f3).color(f, f1, f2, 1.0f).endVertex();
>                 bufferbuilder.pos(x + d13 * (double)f3 + 0.025, y + d14 * (double)(f3 * f3 + f3) * 0.5 + (double)((24.0f - (float)j) / 18.0f + 0.125f) + 0.025, z + d15 * (double)f3).color(f, f1, f2, 1.0f).endVertex();
>             }
>             tessellator.draw();
>             bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
>             for (int k = 0; k <= 24; ++k) {
>                 float f4 = 0.5f;
>                 float f5 = 0.4f;
>                 float f6 = 0.3f;
>                 if (k % 2 == 0) {
>                     f4 *= 0.7f;
>                     f5 *= 0.7f;
>                     f6 *= 0.7f;
>                 }
>                 float f7 = (float)k / 24.0f;
>                 bufferbuilder.pos(x + d13 * (double)f7 + 0.0, y + d14 * (double)(f7 * f7 + f7) * 0.5 + (double)((24.0f - (float)k) / 18.0f + 0.125f) + 0.025, z + d15 * (double)f7).color(f4, f5, f6, 1.0f).endVertex();
>                 bufferbuilder.pos(x + d13 * (double)f7 + 0.025, y + d14 * (double)(f7 * f7 + f7) * 0.5 + (double)((24.0f - (float)k) / 18.0f + 0.125f), z + d15 * (double)f7 + 0.025).color(f4, f5, f6, 1.0f).endVertex();
>             }
>             tessellator.draw();
>             if (Config.isShaders()) {
>                 Shaders.endLeash();
>             }
>             GlStateManager.enableLighting();
>             GlStateManager.enableTexture2D();
>             GlStateManager.enableCull();
145,152d155
<         \u26032.draw();
<         GlStateManager.enableLighting();
<         GlStateManager.enableTexture2D();
<         GlStateManager.enableCull();
<     }
< 
<     protected /* synthetic */ boolean canRenderName(EntityLivingBase entityLivingBase) {
<         return this.canRenderName((EntityLiving)entityLivingBase);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/RenderLivingBase.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/RenderLivingBase.java
4a5
>  *  Config
5a7
>  *  java.lang.Boolean
6a9
>  *  java.lang.Float
14a18
>  *  net.minecraft.client.model.ModelSpider
32,39c36,41
<  *  net.minecraftforge.client.event.RenderLivingEvent$Post
<  *  net.minecraftforge.client.event.RenderLivingEvent$Pre
<  *  net.minecraftforge.client.event.RenderLivingEvent$Specials$Post
<  *  net.minecraftforge.client.event.RenderLivingEvent$Specials$Pre
<  *  net.minecraftforge.common.MinecraftForge
<  *  net.minecraftforge.fml.common.eventhandler.Event
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.EmissiveTextures
>  *  net.optifine.entity.model.CustomEntityModels
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
50a53
> import net.minecraft.client.model.ModelSpider;
66,70c69,74
< import net.minecraftforge.client.event.RenderLivingEvent;
< import net.minecraftforge.common.MinecraftForge;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.EmissiveTextures;
> import net.optifine.entity.model.CustomEntityModels;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
74d77
< @SideOnly(value=Side.CLIENT)
79c82
<     protected ModelBase mainModel;
---
>     public ModelBase mainModel;
84a88,98
>     public EntityLivingBase renderEntity;
>     public float renderLimbSwing;
>     public float renderLimbSwingAmount;
>     public float renderAgeInTicks;
>     public float renderHeadYaw;
>     public float renderHeadPitch;
>     public float renderScaleFactor;
>     public float renderPartialTicks;
>     private boolean renderModelPushMatrix;
>     private boolean renderLayersPushMatrix;
>     public static final boolean animateModelLiving = Boolean.getBoolean((String)"animate.model.living");
89a104
>         this.renderModelPushMatrix = this.mainModel instanceof ModelSpider;
114,115c129
<         boolean shouldSit;
<         if (MinecraftForge.EVENT_BUS.post((Event)new RenderLivingEvent.Pre(entity, this, partialTicks, x, y, z))) {
---
>         if (Reflector.RenderLivingEvent_Pre_Constructor.exists() && Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.RenderLivingEvent_Pre_Constructor, (Object[])new Object[]{entity, this, Float.valueOf((float)partialTicks), x, y, z})) {
117a132,134
>         if (animateModelLiving) {
>             ((EntityLivingBase)entity).limbSwingAmount = 1.0f;
>         }
121c138,141
<         this.mainModel.isRiding = shouldSit = entity.aS() && entity.bJ() != null && entity.bJ().shouldRiderSit();
---
>         this.mainModel.isRiding = entity.aS();
>         if (Reflector.ForgeEntity_shouldRiderSit.exists()) {
>             this.mainModel.isRiding = entity.aS() && entity.bJ() != null && Reflector.callBoolean((Object)entity.bJ(), (ReflectorMethod)Reflector.ForgeEntity_shouldRiderSit, (Object[])new Object[0]);
>         }
127c147
<             if (shouldSit && entity.bJ() instanceof EntityLivingBase) {
---
>             if (this.mainModel.isRiding && entity.bJ() instanceof EntityLivingBase) {
160d179
<                 f2 = f1 - f;
164a184,193
>             if (CustomEntityModels.isActive()) {
>                 this.renderEntity = entity;
>                 this.renderLimbSwing = f6;
>                 this.renderLimbSwingAmount = f5;
>                 this.renderAgeInTicks = f8;
>                 this.renderHeadYaw = f2;
>                 this.renderHeadPitch = f7;
>                 this.renderScaleFactor = f4;
>                 this.renderPartialTicks = partialTicks;
>             }
181a211,216
>                 if (EmissiveTextures.isActive()) {
>                     EmissiveTextures.beginRender();
>                 }
>                 if (this.renderModelPushMatrix) {
>                     GlStateManager.pushMatrix();
>                 }
182a218,231
>                 if (this.renderModelPushMatrix) {
>                     GlStateManager.popMatrix();
>                 }
>                 if (EmissiveTextures.isActive()) {
>                     if (EmissiveTextures.hasEmissive()) {
>                         this.renderModelPushMatrix = true;
>                         EmissiveTextures.beginRenderEmissive();
>                         GlStateManager.pushMatrix();
>                         this.renderModel(entity, f6, f5, f8, f2, f7, f4);
>                         GlStateManager.popMatrix();
>                         EmissiveTextures.endRenderEmissive();
>                     }
>                     EmissiveTextures.endRender();
>                 }
190a240,242
>             if (CustomEntityModels.isActive()) {
>                 this.renderEntity = null;
>             }
202c254,256
<         MinecraftForge.EVENT_BUS.post((Event)new RenderLivingEvent.Post(entity, this, partialTicks, x, y, z));
---
>         if (Reflector.RenderLivingEvent_Post_Constructor.exists()) {
>             Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.RenderLivingEvent_Post_Constructor, (Object[])new Object[]{entity, this, Float.valueOf((float)partialTicks), x, y, z});
>         }
296a351,353
>             if (Config.isShaders()) {
>                 Shaders.setEntityColor((float)1.0f, (float)0.0f, (float)0.0f, (float)0.3f);
>             }
305a363,365
>             if (Config.isShaders()) {
>                 Shaders.setEntityColor((float)f2, (float)f3, (float)f4, (float)(1.0f - f1));
>             }
362a423,425
>         if (Config.isShaders()) {
>             Shaders.setEntityColor((float)0.0f, (float)0.0f, (float)0.0f, (float)0.0f);
>         }
369c432
<     protected void applyRotations(T entityLiving, float ageInTicks, float rotationYaw, float partialTicks) {
---
>     protected void applyRotations(T entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
396a460,465
>             if (EmissiveTextures.isActive()) {
>                 EmissiveTextures.beginRender();
>             }
>             if (this.renderLayersPushMatrix) {
>                 GlStateManager.pushMatrix();
>             }
397a467,480
>             if (this.renderLayersPushMatrix) {
>                 GlStateManager.popMatrix();
>             }
>             if (EmissiveTextures.isActive()) {
>                 if (EmissiveTextures.hasEmissive()) {
>                     this.renderLayersPushMatrix = true;
>                     EmissiveTextures.beginRenderEmissive();
>                     GlStateManager.pushMatrix();
>                     layerrenderer.doRenderLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scaleIn);
>                     GlStateManager.popMatrix();
>                     EmissiveTextures.endRenderEmissive();
>                 }
>                 EmissiveTextures.endRender();
>             }
415c498
<         if (MinecraftForge.EVENT_BUS.post((Event)new RenderLivingEvent.Specials.Pre(entity, this, x, y, z))) {
---
>         if (Reflector.RenderLivingEvent_Specials_Pre_Constructor.exists() && Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.RenderLivingEvent_Specials_Pre_Constructor, (Object[])new Object[]{entity, this, x, y, z})) {
428c511,513
<         MinecraftForge.EVENT_BUS.post((Event)new RenderLivingEvent.Specials.Post(entity, this, x, y, z));
---
>         if (Reflector.RenderLivingEvent_Specials_Post_Constructor.exists()) {
>             Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.RenderLivingEvent_Specials_Post_Constructor, (Object[])new Object[]{entity, this, x, y, z});
>         }
457a543,546
>     }
> 
>     public List<LayerRenderer<T>> getLayerRenderers() {
>         return this.layerRenderers;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/RenderManager.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/RenderManager.java
14a15,16
>  *  net.minecraft.block.BlockBed
>  *  net.minecraft.block.properties.IProperty
188a191
>  *  net.minecraft.init.Blocks
189a193
>  *  net.minecraft.util.EnumFacing
194d197
<  *  net.minecraft.world.IBlockAccess
196,198c199,203
<  *  net.minecraftforge.fml.client.registry.RenderingRegistry
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.entity.model.CustomEntityModels
>  *  net.optifine.player.PlayerItemsLayer
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
206a212,213
> import net.minecraft.block.BlockBed;
> import net.minecraft.block.properties.IProperty;
380a388
> import net.minecraft.init.Blocks;
381a390
> import net.minecraft.util.EnumFacing;
386d394
< import net.minecraft.world.IBlockAccess;
388,390c396,400
< import net.minecraftforge.fml.client.registry.RenderingRegistry;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.entity.model.CustomEntityModels;
> import net.optifine.player.PlayerItemsLayer;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
392d401
< @SideOnly(value=Side.CLIENT)
394c403
<     public final Map<Class<? extends Entity>, Render<? extends Entity>> entityRenderMap = Maps.newHashMap();
---
>     private final Map<Class<? extends Entity>, Render<? extends Entity>> entityRenderMap = Maps.newHashMap();
413a423
>     public Render renderRender = null;
502,506c512,515
<         RenderingRegistry.loadEntityRenderers((RenderManager)this, this.entityRenderMap);
<     }
< 
<     public Map<String, RenderPlayer> getSkinMap() {
<         return Collections.unmodifiableMap(this.skinMap);
---
>         PlayerItemsLayer.register(this.skinMap);
>         if (Reflector.RenderingRegistry_loadEntityRenderers.exists()) {
>             Reflector.call((ReflectorMethod)Reflector.RenderingRegistry_loadEntityRenderers, (Object[])new Object[]{this, this.entityRenderMap});
>         }
543,544c552,558
<             if (block.isBed(iblockstate, (IBlockAccess)worldIn, new BlockPos(livingPlayerIn), (Entity)((EntityLivingBase)livingPlayerIn))) {
<                 int i = block.getBedDirection(iblockstate, (IBlockAccess)worldIn, new BlockPos(livingPlayerIn)).getHorizontalIndex();
---
>             if (Reflector.callBoolean((Object)block, (ReflectorMethod)Reflector.ForgeBlock_isBed, (Object[])new Object[]{iblockstate, worldIn, new BlockPos(livingPlayerIn), (EntityLivingBase)livingPlayerIn})) {
>                 EnumFacing facing = (EnumFacing)Reflector.call((Object)block, (ReflectorMethod)Reflector.ForgeBlock_getBedDirection, (Object[])new Object[]{iblockstate, worldIn, new BlockPos(livingPlayerIn)});
>                 int i = facing.getHorizontalIndex();
>                 this.playerViewY = i * 90 + 180;
>                 this.playerViewX = 0.0f;
>             } else if (block == Blocks.BED) {
>                 int i = ((EnumFacing)iblockstate.getValue((IProperty)BlockBed.D)).getHorizontalIndex();
580,581c594,595
<     public boolean isRenderMultipass(Entity entityIn) {
<         return this.getEntityRenderObject(entityIn).isMultipass();
---
>     public boolean isRenderMultipass(Entity p_188390_1_) {
>         return this.getEntityRenderObject(p_188390_1_).isMultipass();
611c625
<         block9: {
---
>         block10: {
615c629
<                 if (render == null || this.renderEngine == null) break block9;
---
>                 if (render == null || this.renderEngine == null) break block10;
617a632,634
>                     if (CustomEntityModels.isActive()) {
>                         this.renderRender = render;
>                     }
631c648
<                 if (!this.debugBoundingBox || entityIn.isInvisible() || p_188391_10_ || Minecraft.getMinecraft().isReducedDebug()) break block9;
---
>                 if (!this.debugBoundingBox || entityIn.isInvisible() || p_188391_10_ || Minecraft.getMinecraft().isReducedDebug()) break block10;
653,664c670,681
<     public void renderMultipass(Entity entityIn, float partialTicks) {
<         if (entityIn.ticksExisted == 0) {
<             entityIn.lastTickPosX = entityIn.posX;
<             entityIn.lastTickPosY = entityIn.posY;
<             entityIn.lastTickPosZ = entityIn.posZ;
<         }
<         double d0 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * (double)partialTicks;
<         double d1 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * (double)partialTicks;
<         double d2 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * (double)partialTicks;
<         float f = entityIn.prevRotationYaw + (entityIn.rotationYaw - entityIn.prevRotationYaw) * partialTicks;
<         int i = entityIn.getBrightnessForRender();
<         if (entityIn.isBurning()) {
---
>     public void renderMultipass(Entity p_188389_1_, float p_188389_2_) {
>         if (p_188389_1_.ticksExisted == 0) {
>             p_188389_1_.lastTickPosX = p_188389_1_.posX;
>             p_188389_1_.lastTickPosY = p_188389_1_.posY;
>             p_188389_1_.lastTickPosZ = p_188389_1_.posZ;
>         }
>         double d0 = p_188389_1_.lastTickPosX + (p_188389_1_.posX - p_188389_1_.lastTickPosX) * (double)p_188389_2_;
>         double d1 = p_188389_1_.lastTickPosY + (p_188389_1_.posY - p_188389_1_.lastTickPosY) * (double)p_188389_2_;
>         double d2 = p_188389_1_.lastTickPosZ + (p_188389_1_.posZ - p_188389_1_.lastTickPosZ) * (double)p_188389_2_;
>         float f = p_188389_1_.prevRotationYaw + (p_188389_1_.rotationYaw - p_188389_1_.prevRotationYaw) * p_188389_2_;
>         int i = p_188389_1_.getBrightnessForRender();
>         if (p_188389_1_.isBurning()) {
671c688
<         Render render = this.getEntityRenderObject(entityIn);
---
>         Render render = this.getEntityRenderObject(p_188389_1_);
673c690
<             render.renderMultipass(entityIn, d0 - this.renderPosX, d1 - this.renderPosY, d2 - this.renderPosZ, f, partialTicks);
---
>             render.renderMultipass(p_188389_1_, d0 - this.renderPosX, d1 - this.renderPosY, d2 - this.renderPosZ, f, p_188389_2_);
677a695,697
>         if (Shaders.isShadowPass) {
>             return;
>         }
733a754,761
>     }
> 
>     public Map<Class, Render> getEntityRenderMap() {
>         return this.entityRenderMap;
>     }
> 
>     public Map<String, RenderPlayer> getSkinMap() {
>         return Collections.unmodifiableMap(this.skinMap);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/RenderXPOrb.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/RenderXPOrb.java
4a5
>  *  Config
17a19
>  *  net.optifine.CustomColors
32a35
> import net.optifine.CustomColors;
38,39c41,42
<     public RenderXPOrb(RenderManager renderManager) {
<         super(renderManager);
---
>     public RenderXPOrb(RenderManager renderManagerIn) {
>         super(renderManagerIn);
44,46c47,99
<     public void doRender(EntityXPOrb entityXPOrb, double d, double d2, double d3, float f, float f2) {
<         if (this.renderOutlines) {
<             return;
---
>     public void doRender(EntityXPOrb entity, double x, double y, double z, float entityYaw, float partialTicks) {
>         if (!this.renderOutlines) {
>             int col;
>             GlStateManager.pushMatrix();
>             GlStateManager.translate((float)((float)x), (float)((float)y), (float)((float)z));
>             this.bindEntityTexture((Entity)entity);
>             RenderHelper.enableStandardItemLighting();
>             int i = entity.getTextureByXP();
>             float f = (float)(i % 4 * 16 + 0) / 64.0f;
>             float f1 = (float)(i % 4 * 16 + 16) / 64.0f;
>             float f2 = (float)(i / 4 * 16 + 0) / 64.0f;
>             float f3 = (float)(i / 4 * 16 + 16) / 64.0f;
>             float f4 = 1.0f;
>             float f5 = 0.5f;
>             float f6 = 0.25f;
>             int j = entity.getBrightnessForRender();
>             int k = j % 65536;
>             int l = j / 65536;
>             OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)k, (float)l);
>             GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
>             float f8 = 255.0f;
>             float f9 = ((float)entity.xpColor + partialTicks) / 2.0f;
>             if (Config.isCustomColors()) {
>                 f9 = CustomColors.getXpOrbTimer((float)f9);
>             }
>             l = (int)((MathHelper.sin((float)(f9 + 0.0f)) + 1.0f) * 0.5f * 255.0f);
>             int i1 = 255;
>             int j1 = (int)((MathHelper.sin((float)(f9 + 4.1887903f)) + 1.0f) * 0.1f * 255.0f);
>             GlStateManager.translate((float)0.0f, (float)0.1f, (float)0.0f);
>             GlStateManager.rotate((float)(180.0f - this.renderManager.playerViewY), (float)0.0f, (float)1.0f, (float)0.0f);
>             GlStateManager.rotate((float)((float)(this.renderManager.options.thirdPersonView == 2 ? -1 : 1) * -this.renderManager.playerViewX), (float)1.0f, (float)0.0f, (float)0.0f);
>             float f7 = 0.3f;
>             GlStateManager.scale((float)0.3f, (float)0.3f, (float)0.3f);
>             Tessellator tessellator = Tessellator.getInstance();
>             BufferBuilder bufferbuilder = tessellator.getBuffer();
>             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
>             int red = l;
>             int green = 255;
>             int blue = j1;
>             if (Config.isCustomColors() && (col = CustomColors.getXpOrbColor((float)f9)) >= 0) {
>                 red = col >> 16 & 0xFF;
>                 green = col >> 8 & 0xFF;
>                 blue = col >> 0 & 0xFF;
>             }
>             bufferbuilder.pos(-0.5, -0.25, 0.0).tex((double)f, (double)f3).color(red, green, blue, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
>             bufferbuilder.pos(0.5, -0.25, 0.0).tex((double)f1, (double)f3).color(red, green, blue, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
>             bufferbuilder.pos(0.5, 0.75, 0.0).tex((double)f1, (double)f2).color(red, green, blue, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
>             bufferbuilder.pos(-0.5, 0.75, 0.0).tex((double)f, (double)f2).color(red, green, blue, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
>             tessellator.draw();
>             GlStateManager.disableBlend();
>             GlStateManager.disableRescaleNormal();
>             GlStateManager.popMatrix();
>             super.doRender((Entity)entity, x, y, z, entityYaw, partialTicks);
48,86d100
<         GlStateManager.pushMatrix();
<         GlStateManager.translate((float)((float)d), (float)((float)d2), (float)((float)d3));
<         this.bindEntityTexture((Entity)entityXPOrb);
<         RenderHelper.enableStandardItemLighting();
<         int n = entityXPOrb.getTextureByXP();
<         float \u26032 = (float)(n % 4 * 16 + 0) / 64.0f;
<         float \u26033 = (float)(n % 4 * 16 + 16) / 64.0f;
<         float \u26034 = (float)(n / 4 * 16 + 0) / 64.0f;
<         float \u26035 = (float)(n / 4 * 16 + 16) / 64.0f;
<         float \u26036 = 1.0f;
<         float \u26037 = 0.5f;
<         float \u26038 = 0.25f;
<         \u2603 = entityXPOrb.getBrightnessForRender();
<         \u2603 = \u2603 % 65536;
<         \u2603 = \u2603 / 65536;
<         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)\u2603, (float)\u2603);
<         GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
<         float \u26039 = 255.0f;
<         float \u260310 = ((float)entityXPOrb.xpColor + f2) / 2.0f;
<         \u2603 = (int)((MathHelper.sin((float)(\u260310 + 0.0f)) + 1.0f) * 0.5f * 255.0f);
<         \u2603 = 255;
<         \u2603 = (int)((MathHelper.sin((float)(\u260310 + 4.1887903f)) + 1.0f) * 0.1f * 255.0f);
<         GlStateManager.translate((float)0.0f, (float)0.1f, (float)0.0f);
<         GlStateManager.rotate((float)(180.0f - this.renderManager.playerViewY), (float)0.0f, (float)1.0f, (float)0.0f);
<         GlStateManager.rotate((float)((float)(this.renderManager.options.thirdPersonView == 2 ? -1 : 1) * -this.renderManager.playerViewX), (float)1.0f, (float)0.0f, (float)0.0f);
<         float \u260311 = 0.3f;
<         GlStateManager.scale((float)0.3f, (float)0.3f, (float)0.3f);
<         Tessellator \u260312 = Tessellator.getInstance();
<         BufferBuilder \u260313 = \u260312.getBuffer();
<         \u260313.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
<         \u260313.pos(-0.5, -0.25, 0.0).tex((double)\u26032, (double)\u26035).color(\u2603, 255, \u2603, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u260313.pos(0.5, -0.25, 0.0).tex((double)\u26033, (double)\u26035).color(\u2603, 255, \u2603, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u260313.pos(0.5, 0.75, 0.0).tex((double)\u26033, (double)\u26034).color(\u2603, 255, \u2603, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u260313.pos(-0.5, 0.75, 0.0).tex((double)\u26032, (double)\u26034).color(\u2603, 255, \u2603, 128).normal(0.0f, 1.0f, 0.0f).endVertex();
<         \u260312.draw();
<         GlStateManager.disableBlend();
<         GlStateManager.disableRescaleNormal();
<         GlStateManager.popMatrix();
<         super.doRender((Entity)entityXPOrb, d, d2, d3, f, f2);
89c103
<     protected ResourceLocation getEntityTexture(EntityXPOrb entityXPOrb) {
---
>     protected ResourceLocation getEntityTexture(EntityXPOrb entity) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java
4a5
>  *  Config
6d6
<  *  java.lang.Deprecated
15a16
>  *  net.minecraft.client.renderer.entity.layers.LayerArmorBase$1
23,25c24,29
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomItems
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.shaders.ShadersRender
34a39
> import net.minecraft.client.renderer.entity.layers.LayerArmorBase;
42,44c47,52
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomItems;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
> import net.optifine.shaders.ShadersRender;
46d53
< @SideOnly(value=Side.CLIENT)
81c88,90
<             t = this.getArmorModelHook(entityLivingBaseIn, itemstack, slotIn, t);
---
>             if (Reflector.ForgeHooksClient.exists()) {
>                 t = this.getArmorModelHook(entityLivingBaseIn, itemstack, slotIn, t);
>             }
86,92c95,114
<             this.renderer.bindTexture(this.getArmorResource((Entity)entityLivingBaseIn, itemstack, slotIn, null));
<             if (itemarmor.hasOverlay(itemstack)) {
<                 int i = itemarmor.getColor(itemstack);
<                 float f = (float)(i >> 16 & 0xFF) / 255.0f;
<                 float f1 = (float)(i >> 8 & 0xFF) / 255.0f;
<                 float f2 = (float)(i & 0xFF) / 255.0f;
<                 GlStateManager.color((float)(this.colorR * f), (float)(this.colorG * f1), (float)(this.colorB * f2), (float)this.alpha);
---
>             if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture((ItemStack)itemstack, (EntityEquipmentSlot)slotIn, null)) {
>                 if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
>                     this.renderer.bindTexture(this.getArmorResource((Entity)entityLivingBaseIn, itemstack, slotIn, null));
>                 } else {
>                     this.renderer.bindTexture(this.getArmorResource(itemarmor, flag));
>                 }
>             }
>             if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
>                 if (ReflectorForge.armorHasOverlay((ItemArmor)itemarmor, (ItemStack)itemstack)) {
>                     int i = itemarmor.getColor(itemstack);
>                     float f = (float)(i >> 16 & 0xFF) / 255.0f;
>                     float f1 = (float)(i >> 8 & 0xFF) / 255.0f;
>                     float f2 = (float)(i & 0xFF) / 255.0f;
>                     GlStateManager.color((float)(this.colorR * f), (float)(this.colorG * f1), (float)(this.colorB * f2), (float)this.alpha);
>                     t.render((Entity)entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>                     if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture((ItemStack)itemstack, (EntityEquipmentSlot)slotIn, (String)"overlay")) {
>                         this.renderer.bindTexture(this.getArmorResource((Entity)entityLivingBaseIn, itemstack, slotIn, "overlay"));
>                     }
>                 }
>                 GlStateManager.color((float)this.colorR, (float)this.colorG, (float)this.colorB, (float)this.alpha);
94c116,139
<                 this.renderer.bindTexture(this.getArmorResource((Entity)entityLivingBaseIn, itemstack, slotIn, "overlay"));
---
>                 if (!(this.skipRenderGlint || !itemstack.hasEffect() || Config.isCustomItems() && CustomItems.renderCustomArmorEffect((EntityLivingBase)entityLivingBaseIn, (ItemStack)itemstack, t, (float)limbSwing, (float)limbSwingAmount, (float)partialTicks, (float)ageInTicks, (float)netHeadYaw, (float)headPitch, (float)scale))) {
>                     LayerArmorBase.renderEnchantedGlint(this.renderer, entityLivingBaseIn, t, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale);
>                 }
>                 return;
>             }
>             switch (1.$SwitchMap$net$minecraft$item$ItemArmor$ArmorMaterial[itemarmor.getArmorMaterial().ordinal()]) {
>                 case 1: {
>                     int i = itemarmor.getColor(itemstack);
>                     float f = (float)(i >> 16 & 0xFF) / 255.0f;
>                     float f1 = (float)(i >> 8 & 0xFF) / 255.0f;
>                     float f2 = (float)(i & 0xFF) / 255.0f;
>                     GlStateManager.color((float)(this.colorR * f), (float)(this.colorG * f1), (float)(this.colorB * f2), (float)this.alpha);
>                     t.render((Entity)entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>                     if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture((ItemStack)itemstack, (EntityEquipmentSlot)slotIn, (String)"overlay")) {
>                         this.renderer.bindTexture(this.getArmorResource(itemarmor, flag, "overlay"));
>                     }
>                 }
>                 case 2: 
>                 case 3: 
>                 case 4: 
>                 case 5: {
>                     GlStateManager.color((float)this.colorR, (float)this.colorG, (float)this.colorB, (float)this.alpha);
>                     t.render((Entity)entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>                 }
96,98c141
<             GlStateManager.color((float)this.colorR, (float)this.colorG, (float)this.colorB, (float)this.alpha);
<             t.render((Entity)entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
<             if (!this.skipRenderGlint && itemstack.hasEffect()) {
---
>             if (!(this.skipRenderGlint || !itemstack.isItemEnchanted() || Config.isCustomItems() && CustomItems.renderCustomArmorEffect((EntityLivingBase)entityLivingBaseIn, (ItemStack)itemstack, t, (float)limbSwing, (float)limbSwingAmount, (float)partialTicks, (float)ageInTicks, (float)netHeadYaw, (float)headPitch, (float)scale))) {
112a156,158
>         if (Config.isShaders() && Shaders.isShadowPass) {
>             return;
>         }
114a161,163
>         if (Config.isShaders()) {
>             ShadersRender.renderEnchantedGlintBegin();
>         }
143a193,195
>         if (Config.isShaders()) {
>             ShadersRender.renderEnchantedGlintEnd();
>         }
146d197
<     @Deprecated
151d201
<     @Deprecated
180c230
<         ResourceLocation resourcelocation = (ResourceLocation)ARMOR_TEXTURE_RES_MAP.get((Object)(s1 = ForgeHooksClient.getArmorTexture((Entity)entity, (ItemStack)stack, (String)s1, (EntityEquipmentSlot)slot, (String)type)));
---
>         ResourceLocation resourcelocation = (ResourceLocation)ARMOR_TEXTURE_RES_MAP.get((Object)(s1 = Reflector.callString((ReflectorMethod)Reflector.ForgeHooksClient_getArmorTexture, (Object[])new Object[]{entity, stack, s1, slot, type})));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerCape.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerCape.java
16,17d15
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
30,31d27
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
33d28
< @SideOnly(value=Side.CLIENT)
61a57,62
>             if (f2 > 165.0f) {
>                 f2 = 165.0f;
>             }
>             if (f1 < -5.0f) {
>                 f1 = -5.0f;
>             }
65a67
>                 GlStateManager.translate((float)0.0f, (float)0.142f, (float)-0.0178f);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerElytra.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerElytra.java
4a5
>  *  Config
21a23
>  *  net.optifine.CustomItems
38a41
> import net.optifine.CustomItems;
46,47c49,50
<     public LayerElytra(RenderLivingBase<?> renderLivingBase) {
<         this.renderPlayer = renderLivingBase;
---
>     public LayerElytra(RenderLivingBase<?> p_i47185_1_) {
>         this.renderPlayer = p_i47185_1_;
50,64c53,71
<     public void doRenderLayer(EntityLivingBase entityLivingBase, float f8, float f2, float f3, float f4, float f5, float f6, float f7) {
<         float f8;
<         ItemStack itemStack = entityLivingBase.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
<         if (itemStack.getItem() != Items.ELYTRA) {
<             return;
<         }
<         GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
<         GlStateManager.enableBlend();
<         GlStateManager.blendFunc((GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
<         if (entityLivingBase instanceof AbstractClientPlayer) {
<             AbstractClientPlayer abstractClientPlayer = (AbstractClientPlayer)entityLivingBase;
<             if (abstractClientPlayer.isPlayerInfoSet() && abstractClientPlayer.getLocationElytra() != null) {
<                 this.renderPlayer.bindTexture(abstractClientPlayer.getLocationElytra());
<             } else if (abstractClientPlayer.hasPlayerInfo() && abstractClientPlayer.getLocationCape() != null && abstractClientPlayer.isWearing(EnumPlayerModelParts.CAPE)) {
<                 this.renderPlayer.bindTexture(abstractClientPlayer.getLocationCape());
---
>     public void doRenderLayer(EntityLivingBase entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         ItemStack itemstack = entitylivingbaseIn.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
>         if (itemstack.getItem() == Items.ELYTRA) {
>             GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
>             GlStateManager.enableBlend();
>             GlStateManager.blendFunc((GlStateManager.SourceFactor)GlStateManager.SourceFactor.ONE, (GlStateManager.DestFactor)GlStateManager.DestFactor.ZERO);
>             if (entitylivingbaseIn instanceof AbstractClientPlayer) {
>                 AbstractClientPlayer abstractclientplayer = (AbstractClientPlayer)entitylivingbaseIn;
>                 if (abstractclientplayer.isPlayerInfoSet() && abstractclientplayer.getLocationElytra() != null) {
>                     this.renderPlayer.bindTexture(abstractclientplayer.getLocationElytra());
>                 } else if (abstractclientplayer.hasElytraCape() && abstractclientplayer.hasPlayerInfo() && abstractclientplayer.getLocationCape() != null && abstractclientplayer.isWearing(EnumPlayerModelParts.CAPE)) {
>                     this.renderPlayer.bindTexture(abstractclientplayer.getLocationCape());
>                 } else {
>                     ResourceLocation locElytra = TEXTURE_ELYTRA;
>                     if (Config.isCustomItems()) {
>                         locElytra = CustomItems.getCustomElytraTexture((ItemStack)itemstack, (ResourceLocation)locElytra);
>                     }
>                     this.renderPlayer.bindTexture(locElytra);
>                 }
66c73,77
<                 this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
---
>                 ResourceLocation locElytra = TEXTURE_ELYTRA;
>                 if (Config.isCustomItems()) {
>                     locElytra = CustomItems.getCustomElytraTexture((ItemStack)itemstack, (ResourceLocation)locElytra);
>                 }
>                 this.renderPlayer.bindTexture(locElytra);
68,76c79,87
<         } else {
<             this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
<         }
<         GlStateManager.pushMatrix();
<         GlStateManager.translate((float)0.0f, (float)0.0f, (float)0.125f);
<         this.modelElytra.setRotationAngles(f8, f2, f4, f5, f6, f7, (Entity)entityLivingBase);
<         this.modelElytra.render((Entity)entityLivingBase, f8, f2, f4, f5, f6, f7);
<         if (itemStack.isItemEnchanted()) {
<             LayerArmorBase.renderEnchantedGlint(this.renderPlayer, (EntityLivingBase)entityLivingBase, (ModelBase)this.modelElytra, (float)f8, (float)f2, (float)f3, (float)f4, (float)f5, (float)f6, (float)f7);
---
>             GlStateManager.pushMatrix();
>             GlStateManager.translate((float)0.0f, (float)0.0f, (float)0.125f);
>             this.modelElytra.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, (Entity)entitylivingbaseIn);
>             this.modelElytra.render((Entity)entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>             if (itemstack.isItemEnchanted()) {
>                 LayerArmorBase.renderEnchantedGlint(this.renderPlayer, (EntityLivingBase)entitylivingbaseIn, (ModelBase)this.modelElytra, (float)limbSwing, (float)limbSwingAmount, (float)partialTicks, (float)ageInTicks, (float)netHeadYaw, (float)headPitch, (float)scale);
>             }
>             GlStateManager.disableBlend();
>             GlStateManager.popMatrix();
78,79d88
<         GlStateManager.disableBlend();
<         GlStateManager.popMatrix();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java
4a5
>  *  Config
16a18
>  *  net.optifine.shaders.Shaders
28a31
> import net.optifine.shaders.Shaders;
35,36c38,39
<     public LayerEnderDragonEyes(RenderDragon renderDragon) {
<         this.dragonRenderer = renderDragon;
---
>     public LayerEnderDragonEyes(RenderDragon dragonRendererIn) {
>         this.dragonRenderer = dragonRendererIn;
39c42
<     public void doRenderLayer(EntityDragon entityDragon, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
---
>     public void doRenderLayer(EntityDragon entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
46,48c49,51
<         int n = 61680;
<         \u2603 = 61680;
<         boolean \u26032 = false;
---
>         int i = 61680;
>         int j = 61680;
>         boolean k = false;
53c56,64
<         this.dragonRenderer.b().render((Entity)entityDragon, f, f2, f4, f5, f6, f7);
---
>         if (Config.isShaders()) {
>             Shaders.beginSpiderEyes();
>         }
>         Config.getRenderGlobal().renderOverlayEyes = true;
>         this.dragonRenderer.b().render((Entity)entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>         Config.getRenderGlobal().renderOverlayEyes = false;
>         if (Config.isShaders()) {
>             Shaders.endSpiderEyes();
>         }
55c66
<         this.dragonRenderer.c((EntityLiving)entityDragon);
---
>         this.dragonRenderer.c((EntityLiving)entitylivingbaseIn);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java
4a5
>  *  Config
16a18
>  *  net.optifine.shaders.Shaders
28a31
> import net.optifine.shaders.Shaders;
35,36c38,39
<     public LayerEndermanEyes(RenderEnderman renderEnderman) {
<         this.endermanRenderer = renderEnderman;
---
>     public LayerEndermanEyes(RenderEnderman endermanRendererIn) {
>         this.endermanRenderer = endermanRendererIn;
39c42
<     public void doRenderLayer(EntityEnderman entityEnderman, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
---
>     public void doRenderLayer(EntityEnderman entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
45,48c48,51
<         GlStateManager.depthMask((!entityEnderman.aX() ? 1 : 0) != 0);
<         int n = 61680;
<         \u2603 = 61680;
<         boolean \u26032 = false;
---
>         GlStateManager.depthMask((!entitylivingbaseIn.aX() ? 1 : 0) != 0);
>         int i = 61680;
>         int j = 61680;
>         boolean k = false;
53c56,64
<         this.endermanRenderer.getMainModel().a((Entity)entityEnderman, f, f2, f4, f5, f6, f7);
---
>         if (Config.isShaders()) {
>             Shaders.beginSpiderEyes();
>         }
>         Config.getRenderGlobal().renderOverlayEyes = true;
>         this.endermanRenderer.getMainModel().a((Entity)entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>         Config.getRenderGlobal().renderOverlayEyes = false;
>         if (Config.isShaders()) {
>             Shaders.endSpiderEyes();
>         }
55c66
<         this.endermanRenderer.c((EntityLiving)entityEnderman);
---
>         this.endermanRenderer.c((EntityLiving)entitylivingbaseIn);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java
4a5
>  *  Config
9a11
>  *  net.minecraft.client.entity.AbstractClientPlayer
21a24
>  *  net.minecraft.entity.passive.EntityShoulderRiding
24a28
>  *  net.optifine.shaders.Shaders
29a34
> import net.minecraft.client.entity.AbstractClientPlayer;
41a47
> import net.minecraft.entity.passive.EntityShoulderRiding;
44a51
> import net.optifine.shaders.Shaders;
60,61c67,68
<     public LayerEntityOnShoulder(RenderManager renderManager) {
<         this.renderManager = renderManager;
---
>     public LayerEntityOnShoulder(RenderManager p_i47370_1_) {
>         this.renderManager = p_i47370_1_;
64,85c71,93
<     public void doRenderLayer(EntityPlayer entityPlayer, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
<         if (entityPlayer.getLeftShoulderEntity() == null && entityPlayer.getRightShoulderEntity() == null) {
<             return;
<         }
<         GlStateManager.enableRescaleNormal();
<         GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
<         NBTTagCompound nBTTagCompound = entityPlayer.getLeftShoulderEntity();
<         if (!nBTTagCompound.isEmpty()) {
<             \u2603 = this.renderEntityOnShoulder(entityPlayer, this.leftUniqueId, nBTTagCompound, this.leftRenderer, this.leftModel, this.leftResource, this.leftEntityClass, f, f2, f3, f4, f5, f6, f7, true);
<             this.leftUniqueId = \u2603.entityId;
<             this.leftRenderer = \u2603.renderer;
<             this.leftResource = \u2603.textureLocation;
<             this.leftModel = \u2603.model;
<             this.leftEntityClass = \u2603.clazz;
<         }
<         if (!(\u2603 = entityPlayer.getRightShoulderEntity()).isEmpty()) {
<             DataHolder dataHolder = this.renderEntityOnShoulder(entityPlayer, this.rightUniqueId, \u2603, this.rightRenderer, this.rightModel, this.rightResource, this.rightEntityClass, f, f2, f3, f4, f5, f6, f7, false);
<             this.rightUniqueId = dataHolder.entityId;
<             this.rightRenderer = dataHolder.renderer;
<             this.rightResource = dataHolder.textureLocation;
<             this.rightModel = dataHolder.model;
<             this.rightEntityClass = dataHolder.clazz;
---
>     public void doRenderLayer(EntityPlayer entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         if (entitylivingbaseIn.getLeftShoulderEntity() != null || entitylivingbaseIn.getRightShoulderEntity() != null) {
>             NBTTagCompound nbttagcompound1;
>             GlStateManager.enableRescaleNormal();
>             GlStateManager.color((float)1.0f, (float)1.0f, (float)1.0f, (float)1.0f);
>             NBTTagCompound nbttagcompound = entitylivingbaseIn.getLeftShoulderEntity();
>             if (!nbttagcompound.isEmpty()) {
>                 DataHolder layerentityonshoulder$dataholder = this.renderEntityOnShoulder(entitylivingbaseIn, this.leftUniqueId, nbttagcompound, this.leftRenderer, this.leftModel, this.leftResource, this.leftEntityClass, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, true);
>                 this.leftUniqueId = layerentityonshoulder$dataholder.entityId;
>                 this.leftRenderer = layerentityonshoulder$dataholder.renderer;
>                 this.leftResource = layerentityonshoulder$dataholder.textureLocation;
>                 this.leftModel = layerentityonshoulder$dataholder.model;
>                 this.leftEntityClass = layerentityonshoulder$dataholder.clazz;
>             }
>             if (!(nbttagcompound1 = entitylivingbaseIn.getRightShoulderEntity()).isEmpty()) {
>                 DataHolder layerentityonshoulder$dataholder1 = this.renderEntityOnShoulder(entitylivingbaseIn, this.rightUniqueId, nbttagcompound1, this.rightRenderer, this.rightModel, this.rightResource, this.rightEntityClass, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, false);
>                 this.rightUniqueId = layerentityonshoulder$dataholder1.entityId;
>                 this.rightRenderer = layerentityonshoulder$dataholder1.renderer;
>                 this.rightResource = layerentityonshoulder$dataholder1.textureLocation;
>                 this.rightModel = layerentityonshoulder$dataholder1.model;
>                 this.rightEntityClass = layerentityonshoulder$dataholder1.clazz;
>             }
>             GlStateManager.disableRescaleNormal();
87d94
<         GlStateManager.disableRescaleNormal();
90,100c97,104
<     private DataHolder renderEntityOnShoulder(EntityPlayer entityPlayer, @Nullable UUID uUID2, NBTTagCompound nBTTagCompound, RenderLivingBase<? extends EntityLivingBase> renderParrot2, ModelBase \u260332, ResourceLocation \u260342, Class<?> \u260322, float f, float f2, float f3, float f4, float f5, float f6, float f7, boolean bl) {
<         ResourceLocation \u260342;
<         ModelBase \u260332;
<         Class \u260322;
<         if (uUID2 == null || !uUID2.equals((Object)nBTTagCompound.getUniqueId("UUID"))) {
<             UUID uUID2 = nBTTagCompound.getUniqueId("UUID");
<             \u260322 = EntityList.getClassFromName((String)nBTTagCompound.getString("id"));
<             if (\u260322 == EntityParrot.class) {
<                 RenderParrot renderParrot2 = new RenderParrot(this.renderManager);
<                 \u260332 = new ModelParrot();
<                 \u260342 = RenderParrot.PARROT_TEXTURES[nBTTagCompound.getInteger("Variant")];
---
>     private DataHolder renderEntityOnShoulder(EntityPlayer p_192864_1_, @Nullable UUID p_192864_2_, NBTTagCompound p_192864_3_, RenderLivingBase<? extends EntityLivingBase> p_192864_4_, ModelBase p_192864_5_, ResourceLocation p_192864_6_, Class<?> p_192864_7_, float p_192864_8_, float p_192864_9_, float p_192864_10_, float p_192864_11_, float p_192864_12_, float p_192864_13_, float p_192864_14_, boolean p_192864_15_) {
>         if (p_192864_2_ == null || !p_192864_2_.equals((Object)p_192864_3_.getUniqueId("UUID"))) {
>             p_192864_2_ = p_192864_3_.getUniqueId("UUID");
>             p_192864_7_ = EntityList.getClassFromName((String)p_192864_3_.getString("id"));
>             if (p_192864_7_ == EntityParrot.class) {
>                 p_192864_4_ = new RenderParrot(this.renderManager);
>                 p_192864_5_ = new ModelParrot();
>                 p_192864_6_ = RenderParrot.PARROT_TEXTURES[p_192864_3_.getInteger("Variant")];
103c107,119
<         renderParrot2.bindTexture(\u260342);
---
>         Entity renderedEntityOld = Config.getRenderGlobal().renderedEntity;
>         if (p_192864_1_ instanceof AbstractClientPlayer) {
>             EntityShoulderRiding entityShoulder;
>             AbstractClientPlayer acp = (AbstractClientPlayer)p_192864_1_;
>             EntityShoulderRiding entityShoulderRiding = entityShoulder = p_192864_2_ == this.leftUniqueId ? acp.entityShoulderLeft : acp.entityShoulderRight;
>             if (entityShoulder != null) {
>                 Config.getRenderGlobal().renderedEntity = entityShoulder;
>                 if (Config.isShaders()) {
>                     Shaders.nextEntity((Entity)entityShoulder);
>                 }
>             }
>         }
>         p_192864_4_.bindTexture(p_192864_6_);
105,109c121,125
<         float f8 = entityPlayer.aU() ? -1.3f : -1.5f;
<         \u2603 = bl ? 0.4f : -0.4f;
<         GlStateManager.translate((float)\u2603, (float)f8, (float)0.0f);
<         if (\u260322 == EntityParrot.class) {
<             f4 = 0.0f;
---
>         float f = p_192864_1_.aU() ? -1.3f : -1.5f;
>         float f1 = p_192864_15_ ? 0.4f : -0.4f;
>         GlStateManager.translate((float)f1, (float)f, (float)0.0f);
>         if (p_192864_7_ == EntityParrot.class) {
>             p_192864_11_ = 0.0f;
111,113c127,129
<         \u260332.setLivingAnimations((EntityLivingBase)entityPlayer, f, f2, f3);
<         \u260332.setRotationAngles(f, f2, f4, f5, f6, f7, (Entity)entityPlayer);
<         \u260332.render((Entity)entityPlayer, f, f2, f4, f5, f6, f7);
---
>         p_192864_5_.setLivingAnimations((EntityLivingBase)p_192864_1_, p_192864_8_, p_192864_9_, p_192864_10_);
>         p_192864_5_.setRotationAngles(p_192864_8_, p_192864_9_, p_192864_11_, p_192864_12_, p_192864_13_, p_192864_14_, (Entity)p_192864_1_);
>         p_192864_5_.render((Entity)p_192864_1_, p_192864_8_, p_192864_9_, p_192864_11_, p_192864_12_, p_192864_13_, p_192864_14_);
115c131,135
<         return new DataHolder(this, uUID2, (RenderLivingBase)renderParrot2, \u260332, \u260342, \u260322);
---
>         Config.getRenderGlobal().renderedEntity = renderedEntityOld;
>         if (Config.isShaders()) {
>             Shaders.nextEntity((Entity)renderedEntityOld);
>         }
>         return new DataHolder(this, p_192864_2_, (RenderLivingBase)p_192864_4_, p_192864_5_, p_192864_6_, p_192864_7_);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java
4a5
>  *  Config
6a8
>  *  net.minecraft.client.model.ModelRenderer
14a17,18
>  *  net.minecraft.util.ResourceLocation
>  *  net.minecraft.util.math.MathHelper
18a23
> import net.minecraft.client.model.ModelRenderer;
25a31,32
> import net.minecraft.util.ResourceLocation;
> import net.minecraft.util.math.MathHelper;
29a37,39
>     private ModelRenderer modelRendererMushroom;
>     private static final ResourceLocation LOCATION_MUSHROOM_RED = new ResourceLocation("textures/entity/cow/mushroom_red.png");
>     private static boolean hasTextureMushroom = false;
31,32c41,42
<     public LayerMooshroomMushroom(RenderMooshroom renderMooshroom) {
<         this.mooshroomRenderer = renderMooshroom;
---
>     public static void update() {
>         hasTextureMushroom = Config.hasResource((ResourceLocation)LOCATION_MUSHROOM_RED);
35,37c45,108
<     public void doRenderLayer(EntityMooshroom entityMooshroom, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
<         if (entityMooshroom.l_() || entityMooshroom.aX()) {
<             return;
---
>     public LayerMooshroomMushroom(RenderMooshroom mooshroomRendererIn) {
>         this.mooshroomRenderer = mooshroomRendererIn;
>         this.modelRendererMushroom = new ModelRenderer(this.mooshroomRenderer.f);
>         this.modelRendererMushroom.setTextureSize(16, 16);
>         this.modelRendererMushroom.rotationPointX = -6.0f;
>         this.modelRendererMushroom.rotationPointZ = -8.0f;
>         this.modelRendererMushroom.rotateAngleY = MathHelper.PI / 4.0f;
>         int[][] faceUvs = new int[6][];
>         faceUvs[2] = new int[]{16, 16, 0, 0};
>         faceUvs[3] = new int[]{16, 16, 0, 0};
>         this.modelRendererMushroom.addBox((int[][])faceUvs, 0.0f, 0.0f, 10.0f, 20.0f, 16.0f, 0.0f, 0.0f);
>         int[][] faceUvs2 = new int[6][];
>         faceUvs2[4] = new int[]{16, 16, 0, 0};
>         faceUvs2[5] = new int[]{16, 16, 0, 0};
>         this.modelRendererMushroom.addBox((int[][])faceUvs2, 10.0f, 0.0f, 0.0f, 0.0f, 16.0f, 20.0f, 0.0f);
>     }
> 
>     public void doRenderLayer(EntityMooshroom entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         if (!entitylivingbaseIn.l_() && !entitylivingbaseIn.aX()) {
>             BlockRendererDispatcher blockrendererdispatcher = Minecraft.getMinecraft().getBlockRendererDispatcher();
>             if (hasTextureMushroom) {
>                 this.mooshroomRenderer.a(LOCATION_MUSHROOM_RED);
>             } else {
>                 this.mooshroomRenderer.a(TextureMap.LOCATION_BLOCKS_TEXTURE);
>             }
>             GlStateManager.enableCull();
>             GlStateManager.cullFace((GlStateManager.CullFace)GlStateManager.CullFace.FRONT);
>             GlStateManager.pushMatrix();
>             GlStateManager.scale((float)1.0f, (float)-1.0f, (float)1.0f);
>             GlStateManager.translate((float)0.2f, (float)0.35f, (float)0.5f);
>             GlStateManager.rotate((float)42.0f, (float)0.0f, (float)1.0f, (float)0.0f);
>             GlStateManager.pushMatrix();
>             GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
>             if (hasTextureMushroom) {
>                 this.modelRendererMushroom.render(0.0625f);
>             } else {
>                 blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
>             }
>             GlStateManager.popMatrix();
>             GlStateManager.pushMatrix();
>             GlStateManager.translate((float)0.1f, (float)0.0f, (float)-0.6f);
>             GlStateManager.rotate((float)42.0f, (float)0.0f, (float)1.0f, (float)0.0f);
>             GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
>             if (hasTextureMushroom) {
>                 this.modelRendererMushroom.render(0.0625f);
>             } else {
>                 blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
>             }
>             GlStateManager.popMatrix();
>             GlStateManager.popMatrix();
>             GlStateManager.pushMatrix();
>             this.mooshroomRenderer.getMainModel().a.postRender(0.0625f);
>             GlStateManager.scale((float)1.0f, (float)-1.0f, (float)1.0f);
>             GlStateManager.translate((float)0.0f, (float)0.7f, (float)-0.2f);
>             GlStateManager.rotate((float)12.0f, (float)0.0f, (float)1.0f, (float)0.0f);
>             GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
>             if (hasTextureMushroom) {
>                 this.modelRendererMushroom.render(0.0625f);
>             } else {
>                 blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
>             }
>             GlStateManager.popMatrix();
>             GlStateManager.cullFace((GlStateManager.CullFace)GlStateManager.CullFace.BACK);
>             GlStateManager.disableCull();
39,67d109
<         BlockRendererDispatcher blockRendererDispatcher = Minecraft.getMinecraft().getBlockRendererDispatcher();
<         this.mooshroomRenderer.a(TextureMap.LOCATION_BLOCKS_TEXTURE);
<         GlStateManager.enableCull();
<         GlStateManager.cullFace((GlStateManager.CullFace)GlStateManager.CullFace.FRONT);
<         GlStateManager.pushMatrix();
<         GlStateManager.scale((float)1.0f, (float)-1.0f, (float)1.0f);
<         GlStateManager.translate((float)0.2f, (float)0.35f, (float)0.5f);
<         GlStateManager.rotate((float)42.0f, (float)0.0f, (float)1.0f, (float)0.0f);
<         GlStateManager.pushMatrix();
<         GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
<         blockRendererDispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
<         GlStateManager.popMatrix();
<         GlStateManager.pushMatrix();
<         GlStateManager.translate((float)0.1f, (float)0.0f, (float)-0.6f);
<         GlStateManager.rotate((float)42.0f, (float)0.0f, (float)1.0f, (float)0.0f);
<         GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
<         blockRendererDispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
<         GlStateManager.popMatrix();
<         GlStateManager.popMatrix();
<         GlStateManager.pushMatrix();
<         this.mooshroomRenderer.getMainModel().a.postRender(0.0625f);
<         GlStateManager.scale((float)1.0f, (float)-1.0f, (float)1.0f);
<         GlStateManager.translate((float)0.0f, (float)0.7f, (float)-0.2f);
<         GlStateManager.rotate((float)12.0f, (float)0.0f, (float)1.0f, (float)0.0f);
<         GlStateManager.translate((float)-0.5f, (float)-0.5f, (float)0.5f);
<         blockRendererDispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.t(), 1.0f);
<         GlStateManager.popMatrix();
<         GlStateManager.cullFace((GlStateManager.CullFace)GlStateManager.CullFace.BACK);
<         GlStateManager.disableCull();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java
4a5
>  *  Config
14a16
>  *  net.optifine.CustomColors
26a29
> import net.optifine.CustomColors;
32c35
<     private final ModelSheep1 sheepModel = new ModelSheep1();
---
>     public ModelSheep1 sheepModel = new ModelSheep1();
34,35c37,38
<     public LayerSheepWool(RenderSheep renderSheep) {
<         this.sheepRenderer = renderSheep;
---
>     public LayerSheepWool(RenderSheep sheepRendererIn) {
>         this.sheepRenderer = sheepRendererIn;
38,40c41,67
<     public void doRenderLayer(EntitySheep entitySheep, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
<         if (entitySheep.getSheared() || entitySheep.aX()) {
<             return;
---
>     public void doRenderLayer(EntitySheep entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         if (!entitylivingbaseIn.getSheared() && !entitylivingbaseIn.aX()) {
>             this.sheepRenderer.a(TEXTURE);
>             if (entitylivingbaseIn.n_() && "jeb_".equals((Object)entitylivingbaseIn.bq())) {
>                 int i1 = 25;
>                 int i = entitylivingbaseIn.T / 25 + entitylivingbaseIn.S();
>                 int j = EnumDyeColor.values().length;
>                 int k = i % j;
>                 int l = (i + 1) % j;
>                 float f = ((float)(entitylivingbaseIn.T % 25) + partialTicks) / 25.0f;
>                 float[] afloat1 = EntitySheep.getDyeRgb((EnumDyeColor)EnumDyeColor.byMetadata((int)k));
>                 float[] afloat2 = EntitySheep.getDyeRgb((EnumDyeColor)EnumDyeColor.byMetadata((int)l));
>                 if (Config.isCustomColors()) {
>                     afloat1 = CustomColors.getSheepColors((EnumDyeColor)EnumDyeColor.byMetadata((int)k), (float[])afloat1);
>                     afloat2 = CustomColors.getSheepColors((EnumDyeColor)EnumDyeColor.byMetadata((int)l), (float[])afloat2);
>                 }
>                 GlStateManager.color((float)(afloat1[0] * (1.0f - f) + afloat2[0] * f), (float)(afloat1[1] * (1.0f - f) + afloat2[1] * f), (float)(afloat1[2] * (1.0f - f) + afloat2[2] * f));
>             } else {
>                 float[] afloat = EntitySheep.getDyeRgb((EnumDyeColor)entitylivingbaseIn.getFleeceColor());
>                 if (Config.isCustomColors()) {
>                     afloat = CustomColors.getSheepColors((EnumDyeColor)entitylivingbaseIn.getFleeceColor(), (float[])afloat);
>                 }
>                 GlStateManager.color((float)afloat[0], (float)afloat[1], (float)afloat[2]);
>             }
>             this.sheepModel.a(this.sheepRenderer.b());
>             this.sheepModel.setLivingAnimations((EntityLivingBase)entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks);
>             this.sheepModel.a((Entity)entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
42,59d68
<         this.sheepRenderer.a(TEXTURE);
<         if (entitySheep.n_() && "jeb_".equals((Object)entitySheep.bq())) {
<             int n = 25;
<             \u2603 = entitySheep.T / 25 + entitySheep.S();
<             \u2603 = EnumDyeColor.values().length;
<             \u2603 = \u2603 % \u2603;
<             \u2603 = (\u2603 + 1) % \u2603;
<             float \u26032 = ((float)(entitySheep.T % 25) + f3) / 25.0f;
<             float[] \u26033 = EntitySheep.getDyeRgb((EnumDyeColor)EnumDyeColor.byMetadata((int)\u2603));
<             float[] \u26034 = EntitySheep.getDyeRgb((EnumDyeColor)EnumDyeColor.byMetadata((int)\u2603));
<             GlStateManager.color((float)(\u26033[0] * (1.0f - \u26032) + \u26034[0] * \u26032), (float)(\u26033[1] * (1.0f - \u26032) + \u26034[1] * \u26032), (float)(\u26033[2] * (1.0f - \u26032) + \u26034[2] * \u26032));
<         } else {
<             float[] \u26035 = EntitySheep.getDyeRgb((EnumDyeColor)entitySheep.getFleeceColor());
<             GlStateManager.color((float)\u26035[0], (float)\u26035[1], (float)\u26035[2]);
<         }
<         this.sheepModel.a(this.sheepRenderer.b());
<         this.sheepModel.setLivingAnimations((EntityLivingBase)entitySheep, f, f2, f3);
<         this.sheepModel.a((Entity)entitySheep, f, f2, f4, f5, f6, f7);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java
4a5
>  *  Config
14a16
>  *  net.optifine.shaders.Shaders
24a27
> import net.optifine.shaders.Shaders;
31,32c34,35
<     public LayerSpiderEyes(RenderSpider<T> renderSpider) {
<         this.spiderRenderer = renderSpider;
---
>     public LayerSpiderEyes(RenderSpider<T> spiderRendererIn) {
>         this.spiderRenderer = spiderRendererIn;
35c38
<     public void doRenderLayer(T t, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
---
>     public void doRenderLayer(T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
40c43
<         if (t.aX()) {
---
>         if (entitylivingbaseIn.aX()) {
45,48c48,51
<         int n = 61680;
<         \u2603 = n % 65536;
<         \u2603 = n / 65536;
<         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)\u2603, (float)\u2603);
---
>         int i = 61680;
>         int j = i % 65536;
>         int k = i / 65536;
>         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
51c54,62
<         this.spiderRenderer.b().render(t, f, f2, f4, f5, f6, f7);
---
>         if (Config.isShaders()) {
>             Shaders.beginSpiderEyes();
>         }
>         Config.getRenderGlobal().renderOverlayEyes = true;
>         this.spiderRenderer.b().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
>         Config.getRenderGlobal().renderOverlayEyes = false;
>         if (Config.isShaders()) {
>             Shaders.endSpiderEyes();
>         }
53,57c64,68
<         n = t.av();
<         \u2603 = n % 65536;
<         \u2603 = n / 65536;
<         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)\u2603, (float)\u2603);
<         this.spiderRenderer.c(t);
---
>         i = entitylivingbaseIn.av();
>         j = i % 65536;
>         k = i / 65536;
>         OpenGlHelper.setLightmapTextureCoords((int)OpenGlHelper.lightmapTexUnit, (float)j, (float)k);
>         this.spiderRenderer.c(entitylivingbaseIn);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java
4a5
>  *  Config
10a12
>  *  net.minecraft.item.EnumDyeColor
11a14
>  *  net.optifine.CustomColors
19a23
> import net.minecraft.item.EnumDyeColor;
20a25
> import net.optifine.CustomColors;
27,28c32,33
<     public LayerWolfCollar(RenderWolf renderWolf) {
<         this.wolfRenderer = renderWolf;
---
>     public LayerWolfCollar(RenderWolf wolfRendererIn) {
>         this.wolfRenderer = wolfRendererIn;
31,33c36,44
<     public void doRenderLayer(EntityWolf entityWolf, float f, float f2, float f3, float f4, float f5, float f6, float f7) {
<         if (!entityWolf.dl() || entityWolf.aX()) {
<             return;
---
>     public void doRenderLayer(EntityWolf entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
>         if (entitylivingbaseIn.dl() && !entitylivingbaseIn.aX()) {
>             this.wolfRenderer.a(WOLF_COLLAR);
>             float[] afloat = entitylivingbaseIn.getCollarColor().getColorComponentValues();
>             if (Config.isCustomColors()) {
>                 afloat = CustomColors.getWolfCollarColors((EnumDyeColor)entitylivingbaseIn.getCollarColor(), (float[])afloat);
>             }
>             GlStateManager.color((float)afloat[0], (float)afloat[1], (float)afloat[2]);
>             this.wolfRenderer.b().render((Entity)entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
35,38d45
<         this.wolfRenderer.a(WOLF_COLLAR);
<         float[] fArray = entityWolf.getCollarColor().getColorComponentValues();
<         GlStateManager.color((float)fArray[0], (float)fArray[1], (float)fArray[2]);
<         this.wolfRenderer.b().render((Entity)entityWolf, f, f2, f4, f5, f6, f7);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/AbstractTexture.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/AbstractTexture.java
8a9,10
>  *  net.optifine.shaders.MultiTexID
>  *  net.optifine.shaders.ShadersTex
14a17,18
> import net.optifine.shaders.MultiTexID;
> import net.optifine.shaders.ShadersTex;
22a27
>     public MultiTexID multiTex;
24,31c29,36
<     public void setBlurMipmapDirect(boolean bl, boolean bl22) {
<         int \u26033;
<         int \u26032;
<         this.blur = bl;
<         this.mipmap = bl22;
<         if (bl) {
<             \u26032 = bl22 ? 9987 : 9729;
<             \u26033 = 9729;
---
>     public void setBlurMipmapDirect(boolean blurIn, boolean mipmapIn) {
>         int j;
>         int i;
>         this.blur = blurIn;
>         this.mipmap = mipmapIn;
>         if (blurIn) {
>             i = mipmapIn ? 9987 : 9729;
>             j = 9729;
33,35c38,39
<             boolean bl22;
<             \u26032 = bl22 ? 9986 : 9728;
<             \u26033 = 9728;
---
>             i = mipmapIn ? 9986 : 9728;
>             j = 9728;
37,38c41,43
<         GlStateManager.glTexParameteri((int)3553, (int)10241, (int)\u26032);
<         GlStateManager.glTexParameteri((int)3553, (int)10240, (int)\u26033);
---
>         GlStateManager.bindTexture((int)this.getGlTextureId());
>         GlStateManager.glTexParameteri((int)3553, (int)10241, (int)i);
>         GlStateManager.glTexParameteri((int)3553, (int)10240, (int)j);
41c46
<     public void setBlurMipmap(boolean bl, boolean bl2) {
---
>     public void setBlurMipmap(boolean blurIn, boolean mipmapIn) {
44c49
<         this.setBlurMipmapDirect(bl, bl2);
---
>         this.setBlurMipmapDirect(blurIn, mipmapIn);
58a64
>         ShadersTex.deleteTextures((AbstractTexture)this, (int)this.glTextureId);
62a69,72
>     }
> 
>     public MultiTexID getMultiTexID() {
>         return ShadersTex.getMultiTexID((AbstractTexture)this);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/DynamicTexture.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/DynamicTexture.java
4a5
>  *  Config
10a12
>  *  net.optifine.shaders.ShadersTex
18a21
> import net.optifine.shaders.ShadersTex;
24a28
>     private boolean shadersInitialized = false;
32,36c36,45
<     public DynamicTexture(int n, int n2) {
<         this.width = n;
<         this.height = n2;
<         this.dynamicTextureData = new int[n * n2];
<         TextureUtil.allocateTexture((int)this.getGlTextureId(), (int)n, (int)n2);
---
>     public DynamicTexture(int textureWidth, int textureHeight) {
>         this.width = textureWidth;
>         this.height = textureHeight;
>         this.dynamicTextureData = new int[textureWidth * textureHeight * 3];
>         if (Config.isShaders()) {
>             ShadersTex.initDynamicTexture((int)this.getGlTextureId(), (int)textureWidth, (int)textureHeight, (DynamicTexture)this);
>             this.shadersInitialized = true;
>         } else {
>             TextureUtil.allocateTexture((int)this.getGlTextureId(), (int)textureWidth, (int)textureHeight);
>         }
39c48
<     public void loadTexture(IResourceManager iResourceManager) throws IOException {
---
>     public void loadTexture(IResourceManager resourceManager) throws IOException {
43c52,60
<         TextureUtil.uploadTexture((int)this.getGlTextureId(), (int[])this.dynamicTextureData, (int)this.width, (int)this.height);
---
>         if (Config.isShaders()) {
>             if (!this.shadersInitialized) {
>                 ShadersTex.initDynamicTexture((int)this.getGlTextureId(), (int)this.width, (int)this.height, (DynamicTexture)this);
>                 this.shadersInitialized = true;
>             }
>             ShadersTex.updateDynamicTexture((int)this.getGlTextureId(), (int[])this.dynamicTextureData, (int)this.width, (int)this.height, (DynamicTexture)this);
>         } else {
>             TextureUtil.uploadTexture((int)this.getGlTextureId(), (int[])this.dynamicTextureData, (int)this.width, (int)this.height);
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/ITextureObject.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/ITextureObject.java
7a8
>  *  net.optifine.shaders.MultiTexID
12a14
> import net.optifine.shaders.MultiTexID;
21a24,25
> 
>     public MultiTexID getMultiTexID();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java
4a5
>  *  Config
21,23c22,25
<  *  net.minecraftforge.client.MinecraftForgeClient
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.MultiTexID
>  *  net.optifine.shaders.ShadersTex
43,45c45,48
< import net.minecraftforge.client.MinecraftForgeClient;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.MultiTexID;
> import net.optifine.shaders.ShadersTex;
50d52
< @SideOnly(value=Side.CLIENT)
73,85c75,88
<         this.deleteGlTexture();
<         iresource = null;
<         try {
<             iresource = resourceManager.getResource(this.textureLocation);
<             bufferedimage1 = TextureUtil.readBufferedImage((InputStream)iresource.getInputStream());
<             i = bufferedimage1.getType();
<             if (i == 0) {
<                 i = 6;
<             }
<             bufferedimage = new BufferedImage(bufferedimage1.getWidth(), bufferedimage1.getHeight(), i);
<             graphics = bufferedimage.getGraphics();
<             graphics.drawImage((Image)bufferedimage1, 0, 0, (ImageObserver)null);
<             j = 0;
---
>         block16: {
>             this.deleteGlTexture();
>             iresource = null;
>             try {
>                 iresource = resourceManager.getResource(this.textureLocation);
>                 bufferedimage1 = TextureUtil.readBufferedImage((InputStream)iresource.getInputStream());
>                 i = bufferedimage1.getType();
>                 if (i == 0) {
>                     i = 6;
>                 }
>                 bufferedimage = new BufferedImage(bufferedimage1.getWidth(), bufferedimage1.getHeight(), i);
>                 graphics = bufferedimage.getGraphics();
>                 graphics.drawImage((Image)bufferedimage1, 0, 0, (ImageObserver)null);
>                 j = 0;
87c90
<             // 2 sources
---
>                 // 2 sources
89,90c92,96
<             while (true) {
<                 if (j >= 17 || j >= this.listTextures.size() || j >= this.listDyeColors.size()) {
---
>                 while (true) {
>                     if (j >= 17 || j >= this.listTextures.size() || j >= this.listDyeColors.size()) {
>                     }
>                     ** GOTO lbl-1000
>                     break;
92,93d97
<                 ** GOTO lbl-1000
<                 break;
95,97c99,107
<         }
<         catch (IOException ioexception) {
<             LayeredColorMaskTexture.LOGGER.error("Couldn't load layered image", (Throwable)ioexception);
---
>             catch (IOException ioexception) {
>                 LayeredColorMaskTexture.LOGGER.error("Couldn't load layered image", (Throwable)ioexception);
>                 IOUtils.closeQuietly((Closeable)iresource);
>                 return;
>             }
>             catch (Throwable var19_20) {
>                 IOUtils.closeQuietly(iresource);
>                 throw var19_20;
>             }
99,107c109,113
<             return;
<         }
<         catch (Throwable var19_20) {
<             IOUtils.closeQuietly(iresource);
<             throw var19_20;
<         }
<         IOUtils.closeQuietly((Closeable)iresource);
<         TextureUtil.uploadTextureImage((int)this.getGlTextureId(), (BufferedImage)bufferedimage);
<         return;
---
>             if (!Config.isShaders()) {
>                 TextureUtil.uploadTextureImage((int)this.getGlTextureId(), (BufferedImage)bufferedimage);
>                 return;
>             }
>             break block16;
109c115
<         // 1 sources
---
>             // 1 sources
111,124c117,137
<         {
<             iresource1 = null;
<             try {
<                 s = (String)this.listTextures.get(j);
<                 k = ((EnumDyeColor)this.listDyeColors.get(j)).getColorValue();
<                 if (s != null && (bufferedimage2 = MinecraftForgeClient.getImageLayer((ResourceLocation)new ResourceLocation(s), (IResourceManager)resourceManager)).getWidth() == bufferedimage.getWidth() && bufferedimage2.getHeight() == bufferedimage.getHeight() && bufferedimage2.getType() == 6) {
<                     for (l = 0; l < bufferedimage2.getHeight(); ++l) {
<                         for (i1 = 0; i1 < bufferedimage2.getWidth(); ++i1) {
<                             j1 = bufferedimage2.getRGB(i1, l);
<                             if ((j1 & -16777216) == 0) continue;
<                             k1 = (j1 & 0xFF0000) << 8 & -16777216;
<                             l1 = bufferedimage1.getRGB(i1, l);
<                             i2 = MathHelper.multiplyColor((int)l1, (int)k) & 0xFFFFFF;
<                             bufferedimage2.setRGB(i1, l, k1 | i2);
---
>             {
>                 block15: {
>                     iresource1 = null;
>                     try {
>                         s = (String)this.listTextures.get(j);
>                         k = ((EnumDyeColor)this.listDyeColors.get(j)).getColorValue();
>                         if (s == null) break block15;
>                         iresource1 = resourceManager.getResource(new ResourceLocation(s));
>                         v0 = bufferedimage2 = Reflector.MinecraftForgeClient_getImageLayer.exists() != false ? (BufferedImage)Reflector.call((ReflectorMethod)Reflector.MinecraftForgeClient_getImageLayer, (Object[])new Object[]{new ResourceLocation(s), resourceManager}) : TextureUtil.readBufferedImage((InputStream)iresource1.getInputStream());
>                         if (bufferedimage2.getWidth() == bufferedimage.getWidth() && bufferedimage2.getHeight() == bufferedimage.getHeight() && bufferedimage2.getType() == 6) {
>                             for (l = 0; l < bufferedimage2.getHeight(); ++l) {
>                                 for (i1 = 0; i1 < bufferedimage2.getWidth(); ++i1) {
>                                     j1 = bufferedimage2.getRGB(i1, l);
>                                     if ((j1 & -16777216) == 0) continue;
>                                     k1 = (j1 & 0xFF0000) << 8 & -16777216;
>                                     l1 = bufferedimage1.getRGB(i1, l);
>                                     i2 = MathHelper.multiplyColor((int)l1, (int)k) & 0xFFFFFF;
>                                     bufferedimage2.setRGB(i1, l, k1 | i2);
>                                 }
>                             }
>                             bufferedimage.getGraphics().drawImage((Image)bufferedimage2, 0, 0, (ImageObserver)null);
127c140,142
<                     bufferedimage.getGraphics().drawImage((Image)bufferedimage2, 0, 0, (ImageObserver)null);
---
>                     finally {
>                         IOUtils.closeQuietly(iresource1);
>                     }
128a144,145
>                 ++j;
>                 ** continue;
130,134d146
<             finally {
<                 IOUtils.closeQuietly(iresource1);
<             }
<             ++j;
<             ** continue;
135a148
>         ShadersTex.loadSimpleTexture((int)this.getGlTextureId(), (BufferedImage)bufferedimage, (boolean)false, (boolean)false, (IResourceManager)resourceManager, (ResourceLocation)this.textureLocation, (MultiTexID)this.getMultiTexID());
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/SimpleTexture.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/SimpleTexture.java
4a5
>  *  Config
17a19,21
>  *  net.optifine.EmissiveTextures
>  *  net.optifine.shaders.MultiTexID
>  *  net.optifine.shaders.ShadersTex
33a38,40
> import net.optifine.EmissiveTextures;
> import net.optifine.shaders.MultiTexID;
> import net.optifine.shaders.ShadersTex;
41a49,50
>     public ResourceLocation locationEmissive;
>     public boolean isEmissive;
43,44c52,53
<     public SimpleTexture(ResourceLocation resourceLocation) {
<         this.textureLocation = resourceLocation;
---
>     public SimpleTexture(ResourceLocation textureResourceLocation) {
>         this.textureLocation = textureResourceLocation;
50c59
<     public void loadTexture(IResourceManager iResourceManager) throws IOException {
---
>     public void loadTexture(IResourceManager resourceManager) throws IOException {
52c61
<         IResource iResource = null;
---
>         IResource iresource = null;
54,58c63,67
<             iResource = iResourceManager.getResource(this.textureLocation);
<             BufferedImage bufferedImage = TextureUtil.readBufferedImage((InputStream)iResource.getInputStream());
<             boolean \u26032 = false;
<             boolean \u26033 = false;
<             if (iResource.hasMetadata()) {
---
>             iresource = resourceManager.getResource(this.textureLocation);
>             BufferedImage bufferedimage = TextureUtil.readBufferedImage((InputStream)iresource.getInputStream());
>             boolean flag = false;
>             boolean flag1 = false;
>             if (iresource.hasMetadata()) {
60,63c69,72
<                     TextureMetadataSection textureMetadataSection = (TextureMetadataSection)iResource.getMetadata("texture");
<                     if (textureMetadataSection != null) {
<                         \u26032 = textureMetadataSection.getTextureBlur();
<                         \u26033 = textureMetadataSection.getTextureClamp();
---
>                     TextureMetadataSection texturemetadatasection = (TextureMetadataSection)iresource.getMetadata("texture");
>                     if (texturemetadatasection != null) {
>                         flag = texturemetadatasection.getTextureBlur();
>                         flag1 = texturemetadatasection.getTextureClamp();
66,67c75,76
<                 catch (RuntimeException runtimeException) {
<                     LOGGER.warn("Failed reading metadata of: {}", (Object)this.textureLocation, (Object)runtimeException);
---
>                 catch (RuntimeException runtimeexception) {
>                     LOGGER.warn("Failed reading metadata of: {}", (Object)this.textureLocation, (Object)runtimeexception);
70c79,86
<             TextureUtil.uploadTextureImageAllocate((int)this.getGlTextureId(), (BufferedImage)bufferedImage, (boolean)\u26032, (boolean)\u26033);
---
>             if (Config.isShaders()) {
>                 ShadersTex.loadSimpleTexture((int)this.getGlTextureId(), (BufferedImage)bufferedimage, (boolean)flag, (boolean)flag1, (IResourceManager)resourceManager, (ResourceLocation)this.textureLocation, (MultiTexID)this.getMultiTexID());
>             } else {
>                 TextureUtil.uploadTextureImageAllocate((int)this.getGlTextureId(), (BufferedImage)bufferedimage, (boolean)flag, (boolean)flag1);
>             }
>             if (EmissiveTextures.isActive()) {
>                 EmissiveTextures.loadTexture((ResourceLocation)this.textureLocation, (SimpleTexture)this);
>             }
73c89
<             IOUtils.closeQuietly(iResource);
---
>             IOUtils.closeQuietly(iresource);
76c92
<         IOUtils.closeQuietly((Closeable)iResource);
---
>         IOUtils.closeQuietly((Closeable)iresource);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/Stitcher$Holder.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/Stitcher$Holder.java
11,12d10
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
18,19d15
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
24d19
< @SideOnly(value=Side.CLIENT)
39c34
<         this.rotated = Stitcher.getMipmapDimension((int)this.height, (int)mipmapLevelHolderIn) > Stitcher.getMipmapDimension((int)this.width, (int)mipmapLevelHolderIn);
---
>         this.rotated = Stitcher.access$000((int)this.height, (int)mipmapLevelHolderIn) > Stitcher.access$000((int)this.width, (int)mipmapLevelHolderIn);
48c43
<         return Stitcher.getMipmapDimension((int)((int)((float)i * this.scaleFactor)), (int)this.mipmapLevelHolder);
---
>         return Stitcher.access$000((int)((int)((float)i * this.scaleFactor)), (int)this.mipmapLevelHolder);
53c48
<         return Stitcher.getMipmapDimension((int)((int)((float)i * this.scaleFactor)), (int)this.mipmapLevelHolder);
---
>         return Stitcher.access$000((int)((int)((float)i * this.scaleFactor)), (int)this.mipmapLevelHolder);
71c66
<         return "Holder{width=" + this.width + ", height=" + this.height + ", name=" + this.sprite.getIconName() + "}";
---
>         return "Holder{width=" + this.width + ", height=" + this.height + ", name=" + this.sprite.getIconName() + '}';
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/Stitcher$Slot.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/Stitcher$Slot.java
11,12d10
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
19,20d16
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
22d17
< @SideOnly(value=Side.CLIENT)
102c97
<         return "Slot{originX=" + this.originX + ", originY=" + this.originY + ", width=" + this.width + ", height=" + this.height + ", texture=" + String.valueOf((Object)this.holder) + ", subSlots=" + String.valueOf(this.subSlots) + "}";
---
>         return "Slot{originX=" + this.originX + ", originY=" + this.originY + ", width=" + this.width + ", height=" + this.height + ", texture=" + this.holder + ", subSlots=" + this.subSlots + '}';
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/Stitcher.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/Stitcher.java
19,23c19
<  *  net.minecraftforge.fml.common.FMLLog
<  *  net.minecraftforge.fml.common.ProgressManager
<  *  net.minecraftforge.fml.common.ProgressManager$ProgressBar
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.util.MathUtils
37,40c33
< import net.minecraftforge.fml.common.FMLLog;
< import net.minecraftforge.fml.common.ProgressManager;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.util.MathUtils;
42d34
< @SideOnly(value=Side.CLIENT)
79d70
<         ProgressManager.ProgressBar bar = ProgressManager.push((String)"Texture stitching", (int)astitcher$holder.length);
81d71
<             bar.step(stitcher$holder.getAtlasSprite().getIconName());
83,87c73
<             String s = String.format((String)"Unable to fit: %s - size: %dx%d - Maybe try a lowerresolution resourcepack?", (Object[])new Object[]{stitcher$holder.getAtlasSprite().getIconName(), stitcher$holder.getAtlasSprite().getIconWidth(), stitcher$holder.getAtlasSprite().getIconHeight()});
<             FMLLog.log.info(s);
<             for (Holder h : astitcher$holder) {
<                 FMLLog.log.info("  {}", (Object)h);
<             }
---
>             String s = String.format((String)"Unable to fit: %s, size: %dx%d, atlas: %dx%d, atlasMax: %dx%d - Maybe try a lower resolution resourcepack?", (Object[])new Object[]{stitcher$holder.getAtlasSprite().getIconName(), stitcher$holder.getAtlasSprite().getIconWidth(), stitcher$holder.getAtlasSprite().getIconHeight(), this.currentWidth, this.currentHeight, this.maxWidth, this.maxHeight});
92d77
<         ProgressManager.pop((ProgressManager.ProgressBar)bar);
134d118
<         boolean flag4;
147,152c131,134
<         boolean flag3 = flag1 && k != i1;
<         boolean bl2 = flag4 = flag2 && l != j1;
<         if (flag3 ^ flag4) {
<             flag = !flag3 && flag1;
<         } else {
<             boolean bl3 = flag = flag1 && k <= l;
---
>         int po2DownHeight = MathUtils.roundDownToPowerOfTwo((int)this.currentHeight);
>         boolean bl2 = flag = flag1 && i1 <= 2 * po2DownHeight;
>         if (this.currentWidth == 0 && this.currentHeight == 0) {
>             flag = true;
169a152,155
>     }
> 
>     static /* synthetic */ int access$000(int x0, int x1) {
>         return Stitcher.getMipmapDimension(x0, x1);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/TextureAtlasSprite.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/TextureAtlasSprite.java
4a5
>  *  Config
10a12
>  *  java.lang.Math
32,33c34,37
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.SmartAnimations
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.util.CounterInt
>  *  net.optifine.util.TextureUtils
58,59c62,65
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.SmartAnimations;
> import net.optifine.shaders.Shaders;
> import net.optifine.util.CounterInt;
> import net.optifine.util.TextureUtils;
61d66
< @SideOnly(value=Side.CLIENT)
77a83,104
>     private int indexInMap = -1;
>     public float baseU;
>     public float baseV;
>     public int sheetWidth;
>     public int sheetHeight;
>     public int glSpriteTextureId = -1;
>     public TextureAtlasSprite spriteSingle = null;
>     public boolean isSpriteSingle = false;
>     public int mipmapLevels = 0;
>     public TextureAtlasSprite spriteNormal = null;
>     public TextureAtlasSprite spriteSpecular = null;
>     public boolean isShadersSprite = false;
>     public boolean isDependencyParent = false;
>     public boolean isEmissive = false;
>     public TextureAtlasSprite spriteEmissive = null;
>     private int animationIndex = -1;
>     private boolean animationActive = false;
> 
>     private TextureAtlasSprite(String iconName, boolean isSpritesingle) {
>         this.iconName = iconName;
>         this.isSpriteSingle = isSpritesingle;
>     }
79c106
<     protected TextureAtlasSprite(String spriteName) {
---
>     public TextureAtlasSprite(String spriteName) {
80a108,110
>         if (Config.isMultiTexture()) {
>             this.spriteSingle = new TextureAtlasSprite(this.getIconName() + ".spriteSingle", true);
>         }
91,94c121,137
<         this.minU = (float)originInX / (float)inX;
<         this.maxU = (float)(originInX + this.width) / (float)inX;
<         this.minV = (float)originInY / (float)inY;
<         this.maxV = (float)(originInY + this.height) / (float)inY;
---
>         float f = (float)((double)0.01f / (double)inX);
>         float f1 = (float)((double)0.01f / (double)inY);
>         this.minU = (float)originInX / (float)((double)inX) + f;
>         this.maxU = (float)(originInX + this.width) / (float)((double)inX) - f;
>         this.minV = (float)originInY / (float)inY + f1;
>         this.maxV = (float)(originInY + this.height) / (float)inY - f1;
>         this.baseU = Math.min((float)this.minU, (float)this.maxU);
>         this.baseV = Math.min((float)this.minV, (float)this.maxV);
>         if (this.spriteSingle != null) {
>             this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
>         }
>         if (this.spriteNormal != null) {
>             this.spriteNormal.copyFrom(this);
>         }
>         if (this.spriteSpecular != null) {
>             this.spriteSpecular.copyFrom(this);
>         }
106a150,162
>         if (atlasSpirit != Config.getTextureMap().getMissingSprite()) {
>             this.indexInMap = atlasSpirit.indexInMap;
>         }
>         this.baseU = atlasSpirit.baseU;
>         this.baseV = atlasSpirit.baseV;
>         this.sheetWidth = atlasSpirit.sheetWidth;
>         this.sheetHeight = atlasSpirit.sheetHeight;
>         this.glSpriteTextureId = atlasSpirit.glSpriteTextureId;
>         this.mipmapLevels = atlasSpirit.mipmapLevels;
>         if (this.spriteSingle != null) {
>             this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
>         }
>         this.animationIndex = atlasSpirit.animationIndex;
165a222,225
>         if (this.animationMetadata == null) {
>             return;
>         }
>         this.animationActive = SmartAnimations.isActive() ? SmartAnimations.isSpriteRendered((int)this.animationIndex) : true;
172a233,237
>             boolean texBlur = false;
>             boolean texClamp = this.isSpriteSingle;
>             if (!this.animationActive) {
>                 return;
>             }
174c239
<                 TextureUtil.uploadTextureMipmap((int[][])((int[][])this.framesTextureData.get(k)), (int)this.width, (int)this.height, (int)this.originX, (int)this.originY, (boolean)false, (boolean)false);
---
>                 TextureUtil.uploadTextureMipmap((int[][])((int[][])this.framesTextureData.get(k)), (int)this.width, (int)this.height, (int)this.originX, (int)this.originY, (boolean)texBlur, (boolean)texClamp);
176a242,244
>             if (!this.animationActive) {
>                 return;
>             }
223a292,294
>         if (this.spriteSingle != null) {
>             this.spriteSingle.setIconWidth(this.width);
>         }
227a299,301
>         if (this.spriteSingle != null) {
>             this.spriteSingle.setIconHeight(this.height);
>         }
238a313,316
>         if (this.spriteSingle != null) {
>             this.spriteSingle.width = this.width;
>             this.spriteSingle.height = this.height;
>         }
241a320
>         int i;
242a322,324
>         if (this.width != bufferedimage.getWidth()) {
>             bufferedimage = TextureUtils.scaleImage((BufferedImage)bufferedimage, (int)this.width);
>         }
250c332
<             int i = bufferedimage.getHeight() / this.width;
---
>             i = bufferedimage.getHeight() / this.width;
270a353,370
>         if (this.isShadersSprite) {
>             return;
>         }
>         if (Config.isShaders()) {
>             this.loadShadersSprites();
>         }
>         for (i = 0; i < this.framesTextureData.size(); ++i) {
>             int[][] datas = (int[][])this.framesTextureData.get(i);
>             if (datas == null || this.iconName.startsWith("minecraft:blocks/leaves_")) continue;
>             for (int di = 0; di < datas.length; ++di) {
>                 int[] data = datas[di];
>                 this.fixTransparentColor(data);
>             }
>         }
>         if (this.spriteSingle != null) {
>             IResource resourceSingle = Config.getResourceManager().getResource(resource.getResourceLocation());
>             this.spriteSingle.loadSpriteFrames(resourceSingle, mipmaplevels);
>         }
290a391,393
>         if (this.spriteSingle != null) {
>             this.spriteSingle.generateMipmaps(level);
>         }
298a402,404
>         if (this.spriteSingle != null) {
>             this.spriteSingle.allocateFrameTextureData(index);
>         }
313a420,422
>         if (this.spriteSingle != null) {
>             this.spriteSingle.clearFramesTextureData();
>         }
321a431,433
>         if (this.spriteSingle != null) {
>             this.spriteSingle.setFramesTextureData(newFramesTextureData);
>         }
328a441,443
>         if (this.spriteSingle != null) {
>             this.spriteSingle.resetSprite();
>         }
332c447
<         return "TextureAtlasSprite{name='" + this.iconName + "', frameCount=" + this.framesTextureData.size() + ", rotated=" + this.rotated + ", x=" + this.originX + ", y=" + this.originY + ", height=" + this.height + ", width=" + this.width + ", u0=" + this.minU + ", u1=" + this.maxU + ", v0=" + this.minV + ", v1=" + this.maxV + "}";
---
>         return "TextureAtlasSprite{name='" + this.iconName + '\'' + ", frameCount=" + this.framesTextureData.size() + ", rotated=" + this.rotated + ", x=" + this.originX + ", y=" + this.originY + ", height=" + this.height + ", width=" + this.width + ", u0=" + this.minU + ", u1=" + this.maxU + ", v0=" + this.minV + ", v1=" + this.maxV + '}';
344a460,604
>     }
> 
>     public int getIndexInMap() {
>         return this.indexInMap;
>     }
> 
>     public void setIndexInMap(int indexInMap) {
>         this.indexInMap = indexInMap;
>     }
> 
>     public void updateIndexInMap(CounterInt counter) {
>         if (this.indexInMap < 0) {
>             this.indexInMap = counter.nextValue();
>         }
>     }
> 
>     public int getAnimationIndex() {
>         return this.animationIndex;
>     }
> 
>     public void setAnimationIndex(int animationIndex) {
>         this.animationIndex = animationIndex;
>         if (this.spriteNormal != null) {
>             this.spriteNormal.setAnimationIndex(animationIndex);
>         }
>         if (this.spriteSpecular != null) {
>             this.spriteSpecular.setAnimationIndex(animationIndex);
>         }
>     }
> 
>     public boolean isAnimationActive() {
>         return this.animationActive;
>     }
> 
>     private void fixTransparentColor(int[] data) {
>         if (data == null) {
>             return;
>         }
>         long redSum = 0L;
>         long greenSum = 0L;
>         long blueSum = 0L;
>         long count = 0L;
>         for (int i = 0; i < data.length; ++i) {
>             int col = data[i];
>             int alpha = col >> 24 & 0xFF;
>             if (alpha < 16) continue;
>             int red = col >> 16 & 0xFF;
>             int green = col >> 8 & 0xFF;
>             int blue = col & 0xFF;
>             redSum += (long)red;
>             greenSum += (long)green;
>             blueSum += (long)blue;
>             ++count;
>         }
>         if (count <= 0L) {
>             return;
>         }
>         int redAvg = (int)(redSum / count);
>         int greenAvg = (int)(greenSum / count);
>         int blueAvg = (int)(blueSum / count);
>         int colAvg = redAvg << 16 | greenAvg << 8 | blueAvg;
>         for (int i = 0; i < data.length; ++i) {
>             int col = data[i];
>             int alpha = col >> 24 & 0xFF;
>             if (alpha > 16) continue;
>             data[i] = colAvg;
>         }
>     }
> 
>     public double getSpriteU16(float atlasU) {
>         float dU = this.maxU - this.minU;
>         return (atlasU - this.minU) / dU * 16.0f;
>     }
> 
>     public double getSpriteV16(float atlasV) {
>         float dV = this.maxV - this.minV;
>         return (atlasV - this.minV) / dV * 16.0f;
>     }
> 
>     public void bindSpriteTexture() {
>         if (this.glSpriteTextureId < 0) {
>             this.glSpriteTextureId = TextureUtil.glGenTextures();
>             TextureUtil.allocateTextureImpl((int)this.glSpriteTextureId, (int)this.mipmapLevels, (int)this.width, (int)this.height);
>             TextureUtils.applyAnisotropicLevel();
>         }
>         TextureUtils.bindTexture((int)this.glSpriteTextureId);
>     }
> 
>     public void deleteSpriteTexture() {
>         if (this.glSpriteTextureId < 0) {
>             return;
>         }
>         TextureUtil.deleteTexture((int)this.glSpriteTextureId);
>         this.glSpriteTextureId = -1;
>     }
> 
>     public float toSingleU(float u) {
>         u -= this.baseU;
>         float ku = (float)this.sheetWidth / (float)this.width;
>         return u *= ku;
>     }
> 
>     public float toSingleV(float v) {
>         v -= this.baseV;
>         float kv = (float)this.sheetHeight / (float)this.height;
>         return v *= kv;
>     }
> 
>     public List<int[][]> getFramesTextureData() {
>         ArrayList datas = new ArrayList();
>         datas.addAll(this.framesTextureData);
>         return datas;
>     }
> 
>     public AnimationMetadataSection getAnimationMetadata() {
>         return this.animationMetadata;
>     }
> 
>     public void setAnimationMetadata(AnimationMetadataSection animationMetadata) {
>         this.animationMetadata = animationMetadata;
>     }
> 
>     private void loadShadersSprites() {
>         if (Shaders.configNormalMap) {
>             String nameNormal = this.iconName + "_n";
>             ResourceLocation locNormal = new ResourceLocation(nameNormal);
>             locNormal = Config.getTextureMap().completeResourceLocation(locNormal);
>             if (Config.hasResource((ResourceLocation)locNormal)) {
>                 this.spriteNormal = new TextureAtlasSprite(nameNormal);
>                 this.spriteNormal.isShadersSprite = true;
>                 this.spriteNormal.copyFrom(this);
>                 Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteNormal);
>             }
>         }
>         if (Shaders.configSpecularMap) {
>             String nameSpecular = this.iconName + "_s";
>             ResourceLocation locSpecular = new ResourceLocation(nameSpecular);
>             locSpecular = Config.getTextureMap().completeResourceLocation(locSpecular);
>             if (Config.hasResource((ResourceLocation)locSpecular)) {
>                 this.spriteSpecular = new TextureAtlasSprite(nameSpecular);
>                 this.spriteSpecular.isShadersSprite = true;
>                 this.spriteSpecular.copyFrom(this);
>                 Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteSpecular);
>             }
>         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/TextureManager.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/TextureManager.java
4a5
>  *  Config
11a13,14
>  *  java.util.Collection
>  *  java.util.HashSet
15a19
>  *  net.minecraft.client.renderer.texture.AbstractTexture
19a24
>  *  net.minecraft.client.renderer.texture.LayeredColorMaskTexture
29,32c34,37
<  *  net.minecraftforge.fml.common.ProgressManager
<  *  net.minecraftforge.fml.common.ProgressManager$ProgressBar
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CustomGuis
>  *  net.optifine.EmissiveTextures
>  *  net.optifine.RandomEntities
>  *  net.optifine.shaders.ShadersTex
40a46,47
> import java.util.Collection;
> import java.util.HashSet;
43a51
> import net.minecraft.client.renderer.texture.AbstractTexture;
47a56
> import net.minecraft.client.renderer.texture.LayeredColorMaskTexture;
57,59c66,69
< import net.minecraftforge.fml.common.ProgressManager;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CustomGuis;
> import net.optifine.EmissiveTextures;
> import net.optifine.RandomEntities;
> import net.optifine.shaders.ShadersTex;
63d72
< @SideOnly(value=Side.CLIENT)
72a82,83
>     private ITextureObject boundTexture;
>     private ResourceLocation boundTextureLocation;
78a90,95
>         if (Config.isRandomEntities()) {
>             resource = RandomEntities.getTextureLocation((ResourceLocation)resource);
>         }
>         if (Config.isCustomGuis()) {
>             resource = CustomGuis.getTextureLocation((ResourceLocation)resource);
>         }
79a97,99
>         if (EmissiveTextures.isActive()) {
>             itextureobject = EmissiveTextures.getEmissiveTexture((ITextureObject)itextureobject, this.mapTextureObjects);
>         }
84c104,110
<         TextureUtil.bindTexture((int)itextureobject.getGlTextureId());
---
>         if (Config.isShaders()) {
>             ShadersTex.bindTexture((ITextureObject)itextureobject);
>         } else {
>             TextureUtil.bindTexture((int)itextureobject.getGlTextureId());
>         }
>         this.boundTexture = itextureobject;
>         this.boundTextureLocation = resource;
125,126c151,155
<         Integer integer = (Integer)this.mapTextureCounters.get((Object)name);
<         integer = integer == null ? Integer.valueOf((int)1) : Integer.valueOf((int)(integer + 1));
---
>         Integer integer;
>         if (name.equals((Object)"logo")) {
>             texture = Config.getMojangLogoTexture((DynamicTexture)texture);
>         }
>         integer = (integer = (Integer)this.mapTextureCounters.get((Object)name)) == null ? Integer.valueOf((int)1) : Integer.valueOf((int)(integer + 1));
148,149c177,193
<         ProgressManager.ProgressBar bar = ProgressManager.push((String)"Reloading Texture Manager", (int)this.mapTextureObjects.keySet().size(), (boolean)true);
<         Iterator iterator = this.mapTextureObjects.entrySet().iterator();
---
>         Config.dbg((String)"*** Reloading textures ***");
>         Config.log((String)("Resource packs: " + Config.getResourcePackNames()));
>         Iterator it = this.mapTextureObjects.keySet().iterator();
>         while (it.hasNext()) {
>             ResourceLocation loc = (ResourceLocation)it.next();
>             String path = loc.getPath();
>             if (!path.startsWith("mcpatcher/") && !path.startsWith("optifine/") && !EmissiveTextures.isEmissive((ResourceLocation)loc)) continue;
>             ITextureObject tex = (ITextureObject)this.mapTextureObjects.get((Object)loc);
>             if (tex instanceof AbstractTexture) {
>                 AbstractTexture at = (AbstractTexture)tex;
>                 at.deleteGlTexture();
>             }
>             it.remove();
>         }
>         EmissiveTextures.update();
>         HashSet entries = new HashSet((Collection)this.mapTextureObjects.entrySet());
>         Iterator iterator = entries.iterator();
152d195
<             bar.step(((ResourceLocation)entry.getKey()).toString());
160c203,220
<         ProgressManager.pop((ProgressManager.ProgressBar)bar);
---
>     }
> 
>     public void reloadBannerTextures() {
>         HashSet entries = new HashSet((Collection)this.mapTextureObjects.entrySet());
>         for (Map.Entry entry : entries) {
>             ResourceLocation loc = (ResourceLocation)entry.getKey();
>             ITextureObject tex = (ITextureObject)entry.getValue();
>             if (!(tex instanceof LayeredColorMaskTexture)) continue;
>             this.loadTexture(loc, tex);
>         }
>     }
> 
>     public ITextureObject getBoundTexture() {
>         return this.boundTexture;
>     }
> 
>     public ResourceLocation getBoundTextureLocation() {
>         return this.boundTextureLocation;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/TextureMap.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/TextureMap.java
4a5
>  *  Config
6a8,9
>  *  java.awt.Dimension
>  *  java.awt.image.BufferedImage
8a12,13
>  *  java.io.InputStream
>  *  java.lang.Exception
14a20
>  *  java.lang.System
16,17c22,23
<  *  java.util.ArrayDeque
<  *  java.util.Deque
---
>  *  java.util.ArrayList
>  *  java.util.Collection
19c25
<  *  java.util.HashSet
---
>  *  java.util.Iterator
23a30
>  *  java.util.TreeSet
25c32
<  *  net.minecraft.client.Minecraft
---
>  *  net.minecraft.client.renderer.GlStateManager
28a36
>  *  net.minecraft.client.renderer.texture.PngSizeInfo
40,45c48,59
<  *  net.minecraftforge.client.ForgeHooksClient
<  *  net.minecraftforge.fml.common.FMLLog
<  *  net.minecraftforge.fml.common.ProgressManager
<  *  net.minecraftforge.fml.common.ProgressManager$ProgressBar
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.BetterGrass
>  *  net.optifine.ConnectedTextures
>  *  net.optifine.CustomItems
>  *  net.optifine.EmissiveTextures
>  *  net.optifine.SmartAnimations
>  *  net.optifine.SpriteDependencies
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.ShadersTex
>  *  net.optifine.util.CounterInt
>  *  net.optifine.util.TextureUtils
53a68,69
> import java.awt.Dimension;
> import java.awt.image.BufferedImage;
56,57c72,74
< import java.util.ArrayDeque;
< import java.util.Deque;
---
> import java.io.InputStream;
> import java.util.ArrayList;
> import java.util.Collection;
59c76
< import java.util.HashSet;
---
> import java.util.Iterator;
62a80
> import java.util.TreeSet;
64c82
< import net.minecraft.client.Minecraft;
---
> import net.minecraft.client.renderer.GlStateManager;
67a86
> import net.minecraft.client.renderer.texture.PngSizeInfo;
79,83c98,109
< import net.minecraftforge.client.ForgeHooksClient;
< import net.minecraftforge.fml.common.FMLLog;
< import net.minecraftforge.fml.common.ProgressManager;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.BetterGrass;
> import net.optifine.ConnectedTextures;
> import net.optifine.CustomItems;
> import net.optifine.EmissiveTextures;
> import net.optifine.SmartAnimations;
> import net.optifine.SpriteDependencies;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.ShadersTex;
> import net.optifine.util.CounterInt;
> import net.optifine.util.TextureUtils;
88d113
< @SideOnly(value=Side.CLIENT)
102,103c127,137
<     private final Deque<ResourceLocation> loadingSprites = new ArrayDeque();
<     private final Set<ResourceLocation> loadedSprites = new HashSet();
---
>     private TextureAtlasSprite[] iconGrid = null;
>     private int iconGridSize = -1;
>     private int iconGridCountX = -1;
>     private int iconGridCountY = -1;
>     private double iconGridSizeU = -1.0;
>     private double iconGridSizeV = -1.0;
>     private CounterInt counterIndexInMap = new CounterInt(0);
>     public int atlasWidth = 0;
>     public int atlasHeight = 0;
>     private int countAnimationsActive;
>     private int frameCountAnimations;
109,112d142
<     public TextureMap(String basePathIn, @Nullable ITextureMapPopulator iconCreatorIn) {
<         this(basePathIn, iconCreatorIn, false);
<     }
< 
117c147,151
<     public TextureMap(String basePathIn, @Nullable ITextureMapPopulator iconCreatorIn, boolean skipFirst) {
---
>     public TextureMap(String basePathIn, @Nullable ITextureMapPopulator iconCreatorIn) {
>         this(basePathIn, iconCreatorIn, false);
>     }
> 
>     public TextureMap(String basePathIn, ITextureMapPopulator iconCreatorIn, boolean skipFirst) {
127,129c161,164
<         int[] aint = TextureUtil.MISSING_TEXTURE_DATA;
<         this.missingImage.setIconWidth(16);
<         this.missingImage.setIconHeight(16);
---
>         int size = this.getMinSpriteSize();
>         int[] aint = this.getMissingImageData(size);
>         this.missingImage.setIconWidth(size);
>         this.missingImage.setIconHeight(size);
132a168
>         this.missingImage.setIndexInMap(this.counterIndexInMap.nextValue());
143c179,180
<         ForgeHooksClient.onTextureStitchedPre((TextureMap)this);
---
>         this.counterIndexInMap.reset();
>         Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_onTextureStitchedPre, (Object[])new Object[]{this});
144a182,185
>         if (this.mipmapLevels >= 4) {
>             this.mipmapLevels = this.detectMaxMipmapLevel(this.mapRegisteredSprites, resourceManager);
>             Config.log((String)("Mipmap levels: " + this.mipmapLevels));
>         }
149a191,194
>     /*
>      * WARNING - Removed try catching itself - possible behaviour change.
>      * Loose catch block
>      */
151c196,208
<         int i = Minecraft.getGLMaximumTextureSize();
---
>         int l2;
>         int i1;
>         int minSpriteSize;
>         Config.dbg((String)("Multitexture: " + Config.isMultiTexture()));
>         if (Config.isMultiTexture()) {
>             for (TextureAtlasSprite ts : this.mapUploadedSprites.values()) {
>                 ts.deleteSpriteTexture();
>             }
>         }
>         ConnectedTextures.updateIcons((TextureMap)this);
>         CustomItems.updateIcons((TextureMap)this);
>         BetterGrass.updateIcons((TextureMap)this);
>         int i = TextureUtils.getGLMaximumTextureSize();
155a213
>         this.iconGridSize = minSpriteSize = this.getMinSpriteSize();
157,163c215,305
<         FMLLog.log.info("Max texture size: {}", (Object)i);
<         ProgressManager.ProgressBar bar = ProgressManager.push((String)"Texture stitching", (int)this.mapRegisteredSprites.size());
<         this.loadedSprites.clear();
<         for (Map.Entry entry : Maps.newHashMap(this.mapRegisteredSprites).entrySet()) {
<             ResourceLocation location = new ResourceLocation((String)entry.getKey());
<             bar.step(location.toString());
<             j = this.loadTexture(stitcher, resourceManager, location, (TextureAtlasSprite)entry.getValue(), bar, j, k);
---
>         int countCustomLoader = 0;
>         int countCustomLoaderSkipped = 0;
>         SpriteDependencies.reset();
>         ArrayList listRegisteredSprites = new ArrayList(this.mapRegisteredSprites.values());
>         for (int ix = 0; ix < listRegisteredSprites.size(); ++ix) {
>             ResourceLocation resourcelocation;
>             TextureAtlasSprite textureatlassprite;
>             block39: {
>                 textureatlassprite = SpriteDependencies.resolveDependencies((List)listRegisteredSprites, (int)ix, (TextureMap)this);
>                 resourcelocation = this.getResourceLocation(textureatlassprite);
>                 IResource iresource = null;
>                 textureatlassprite.updateIndexInMap(this.counterIndexInMap);
>                 if (textureatlassprite.hasCustomLoader(resourceManager, resourcelocation)) {
>                     if (textureatlassprite.load(resourceManager, resourcelocation, l -> (TextureAtlasSprite)this.mapRegisteredSprites.get((Object)l.toString()))) {
>                         Config.detail((String)("Custom loader (skipped): " + textureatlassprite));
>                         ++countCustomLoaderSkipped;
>                         continue;
>                     }
>                     Config.detail((String)("Custom loader: " + textureatlassprite));
>                     ++countCustomLoader;
>                 } else {
>                     PngSizeInfo pngsizeinfo = PngSizeInfo.makeFromResource((IResource)resourceManager.getResource(resourcelocation));
>                     iresource = resourceManager.getResource(resourcelocation);
>                     boolean flag = iresource.getMetadata("animation") != null;
>                     textureatlassprite.loadSprite(pngsizeinfo, flag);
>                     IOUtils.closeQuietly((Closeable)iresource);
>                 }
>                 break block39;
>                 catch (RuntimeException runtimeexception) {
>                     LOGGER.error("Unable to parse metadata from {}", (Object)resourcelocation, (Object)runtimeexception);
>                     ReflectorForge.FMLClientHandler_trackBrokenTexture((ResourceLocation)resourcelocation, (String)runtimeexception.getMessage());
>                     IOUtils.closeQuietly((Closeable)iresource);
>                     continue;
>                 }
>                 catch (IOException ioexception) {
>                     LOGGER.error("Using missing texture, unable to load " + resourcelocation + ", " + ioexception.getClass().getName());
>                     ReflectorForge.FMLClientHandler_trackMissingTexture((ResourceLocation)resourcelocation);
>                     {
>                         catch (Throwable throwable) {
>                             IOUtils.closeQuietly(iresource);
>                             throw throwable;
>                         }
>                     }
>                     IOUtils.closeQuietly((Closeable)iresource);
>                     continue;
>                 }
>             }
>             int ws = textureatlassprite.getIconWidth();
>             int hs = textureatlassprite.getIconHeight();
>             if (ws < 1 || hs < 1) {
>                 Config.warn((String)("Invalid sprite size: " + textureatlassprite));
>                 continue;
>             }
>             if (ws < minSpriteSize || this.mipmapLevels > 0) {
>                 int ws2;
>                 int n = ws2 = this.mipmapLevels > 0 ? TextureUtils.scaleToGrid((int)ws, (int)minSpriteSize) : TextureUtils.scaleToMin((int)ws, (int)minSpriteSize);
>                 if (ws2 != ws) {
>                     if (!TextureUtils.isPowerOfTwo((int)ws)) {
>                         Config.log((String)("Scaled non power of 2: " + textureatlassprite.getIconName() + ", " + ws + " -> " + ws2));
>                     } else {
>                         Config.log((String)("Scaled too small texture: " + textureatlassprite.getIconName() + ", " + ws + " -> " + ws2));
>                     }
>                     int hs2 = hs * ws2 / ws;
>                     textureatlassprite.setIconWidth(ws2);
>                     textureatlassprite.setIconHeight(hs2);
>                 }
>             }
>             j = Math.min((int)j, (int)Math.min((int)textureatlassprite.getIconWidth(), (int)textureatlassprite.getIconHeight()));
>             int j1 = Math.min((int)Integer.lowestOneBit((int)textureatlassprite.getIconWidth()), (int)Integer.lowestOneBit((int)textureatlassprite.getIconHeight()));
>             if (j1 < k) {
>                 LOGGER.warn("Texture {} with size {}x{} limits mip level from {} to {}", (Object)resourcelocation, (Object)textureatlassprite.getIconWidth(), (Object)textureatlassprite.getIconHeight(), (Object)MathHelper.log2((int)k), (Object)MathHelper.log2((int)j1));
>                 k = j1;
>             }
>             if (!this.generateMipmaps(resourceManager, textureatlassprite)) continue;
>             stitcher.addSprite(textureatlassprite);
>         }
>         if (countCustomLoader > 0) {
>             Config.dbg((String)("Custom loader sprites: " + countCustomLoader));
>         }
>         if (countCustomLoaderSkipped > 0) {
>             Config.dbg((String)("Custom loader sprites (skipped): " + countCustomLoaderSkipped));
>         }
>         if (SpriteDependencies.getCountDependencies() > 0) {
>             Config.dbg((String)("Sprite dependencies: " + SpriteDependencies.getCountDependencies()));
>         }
>         if ((i1 = MathHelper.log2((int)(l2 = Math.min((int)j, (int)k)))) < 0) {
>             i1 = 0;
>         }
>         if (i1 < this.mipmapLevels) {
>             LOGGER.warn("{}: dropping miplevel from {} to {}, because of minimum power of two: {}", (Object)this.basePath, (Object)this.mipmapLevels, (Object)i1, (Object)l2);
>             this.mipmapLevels = i1;
165,203d306
<         this.finishLoading(stitcher, bar, j, k);
<     }
< 
<     /*
<      * Exception decompiling
<      */
<     private int loadTexture(Stitcher stitcher, IResourceManager resourceManager, ResourceLocation location, TextureAtlasSprite textureatlassprite, ProgressManager.ProgressBar bar, int j, int k) {
<         /*
<          * This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
<          * 
<          * java.lang.NullPointerException: Cannot invoke "org.benf.cfr.reader.bytecode.analysis.types.BindingSuperContainer.getBoundSuperForBase(org.benf.cfr.reader.bytecode.analysis.types.JavaTypeInstance)" because "bindingSuperContainer" is null
<          *     at org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.LoopLivenessClash.getIterableIterType(LoopLivenessClash.java:35)
<          *     at org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.LoopLivenessClash.detect(LoopLivenessClash.java:66)
<          *     at org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.LoopLivenessClash.detect(LoopLivenessClash.java:25)
<          *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:827)
<          *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:278)
<          *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:201)
<          *     at org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:94)
<          *     at org.benf.cfr.reader.entities.Method.analyse(Method.java:531)
<          *     at org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:1055)
<          *     at org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:942)
<          *     at org.benf.cfr.reader.Driver.doClass(Driver.java:84)
<          *     at org.benf.cfr.reader.Main.doClass(Main.java:18)
<          *     at org.benf.cfr.reader.PluginRunner.getDecompilationFor(PluginRunner.java:115)
<          *     at cn.enaium.joe.service.decompiler.CFRDecompiler.decompile(CFRDecompiler.java:63)
<          *     at cn.enaium.joe.task.SaveAllSourceTask.get(SaveAllSourceTask.java:60)
<          *     at cn.enaium.joe.task.SaveAllSourceTask.get(SaveAllSourceTask.java:39)
<          *     at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)
<          *     at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
<          *     at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
<          *     at java.base/java.lang.Thread.run(Thread.java:1583)
<          */
<         throw new IllegalStateException("Decompilation failed");
<     }
< 
<     private void finishLoading(Stitcher stitcher, ProgressManager.ProgressBar bar, int j, int k) {
<         ProgressManager.pop((ProgressManager.ProgressBar)bar);
<         int l = Math.min((int)j, (int)k);
<         int i1 = MathHelper.log2((int)l);
206,207d308
<         bar = ProgressManager.push((String)"Texture creation", (int)2);
<         bar.step("Stitching");
210,211c311,315
<         bar.step("Allocating GL texture");
<         TextureUtil.allocateTextureImpl((int)this.getGlTextureId(), (int)this.mipmapLevels, (int)stitcher.getCurrentWidth(), (int)stitcher.getCurrentHeight());
---
>         if (Config.isShaders()) {
>             ShadersTex.allocateTextureMap((int)this.getGlTextureId(), (int)this.mipmapLevels, (int)stitcher.getCurrentWidth(), (int)stitcher.getCurrentHeight(), (Stitcher)stitcher, (TextureMap)this);
>         } else {
>             TextureUtil.allocateTextureImpl((int)this.getGlTextureId(), (int)this.mipmapLevels, (int)stitcher.getCurrentWidth(), (int)stitcher.getCurrentHeight());
>         }
213,214d316
<         ProgressManager.pop((ProgressManager.ProgressBar)bar);
<         bar = ProgressManager.push((String)"Texture mipmap and upload", (int)stitcher.getStichSlots().size());
216d317
<             bar.step(textureatlassprite1.getIconName());
221c322,326
<                 TextureUtil.uploadTextureMipmap((int[][])textureatlassprite1.getFrameTextureData(0), (int)textureatlassprite1.getIconWidth(), (int)textureatlassprite1.getIconHeight(), (int)textureatlassprite1.getOriginX(), (int)textureatlassprite1.getOriginY(), (boolean)false, (boolean)false);
---
>                 if (Config.isShaders()) {
>                     ShadersTex.uploadTexSubForLoadAtlas((TextureMap)this, (String)textureatlassprite1.getIconName(), (int[][])textureatlassprite1.getFrameTextureData(0), (int)textureatlassprite1.getIconWidth(), (int)textureatlassprite1.getIconHeight(), (int)textureatlassprite1.getOriginX(), (int)textureatlassprite1.getOriginY(), (boolean)false, (boolean)false);
>                 } else {
>                     TextureUtil.uploadTextureMipmap((int[][])textureatlassprite1.getFrameTextureData(0), (int)textureatlassprite1.getIconWidth(), (int)textureatlassprite1.getIconHeight(), (int)textureatlassprite1.getOriginX(), (int)textureatlassprite1.getOriginY(), (boolean)false, (boolean)false);
>                 }
230a336
>             textureatlassprite1.setAnimationIndex(this.listAnimatedSprites.size());
236,237c342,384
<         ForgeHooksClient.onTextureStitchedPost((TextureMap)this);
<         ProgressManager.pop((ProgressManager.ProgressBar)bar);
---
>         Config.log((String)("Animated sprites: " + this.listAnimatedSprites.size()));
>         if (Config.isMultiTexture()) {
>             int sheetWidth = stitcher.getCurrentWidth();
>             int sheetHeight = stitcher.getCurrentHeight();
>             List listSprites = stitcher.getStichSlots();
>             for (TextureAtlasSprite tas : listSprites) {
>                 tas.sheetWidth = sheetWidth;
>                 tas.sheetHeight = sheetHeight;
>                 tas.mipmapLevels = this.mipmapLevels;
>                 TextureAtlasSprite ss = tas.spriteSingle;
>                 if (ss == null) continue;
>                 if (ss.getIconWidth() <= 0) {
>                     ss.setIconWidth(tas.getIconWidth());
>                     ss.setIconHeight(tas.getIconHeight());
>                     ss.initSprite(tas.getIconWidth(), tas.getIconHeight(), 0, 0, false);
>                     ss.clearFramesTextureData();
>                     List frameDatas = tas.getFramesTextureData();
>                     ss.setFramesTextureData(frameDatas);
>                     ss.setAnimationMetadata(tas.getAnimationMetadata());
>                 }
>                 ss.sheetWidth = sheetWidth;
>                 ss.sheetHeight = sheetHeight;
>                 ss.mipmapLevels = this.mipmapLevels;
>                 ss.setAnimationIndex(tas.getAnimationIndex());
>                 tas.bindSpriteTexture();
>                 boolean texBlur = false;
>                 boolean texClamp = true;
>                 try {
>                     TextureUtil.uploadTextureMipmap((int[][])ss.getFrameTextureData(0), (int)ss.getIconWidth(), (int)ss.getIconHeight(), (int)ss.getOriginX(), (int)ss.getOriginY(), (boolean)texBlur, (boolean)texClamp);
>                 }
>                 catch (Exception e) {
>                     Config.dbg((String)("Error uploading sprite single: " + ss + ", parent: " + tas));
>                     e.printStackTrace();
>                 }
>             }
>             Config.getMinecraft().getTextureManager().bindTexture(LOCATION_BLOCKS_TEXTURE);
>         }
>         Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooksClient_onTextureStitchedPost, (Object[])new Object[]{this});
>         this.updateIconGrid(stitcher.getCurrentWidth(), stitcher.getCurrentHeight());
>         if (Config.equals((Object)System.getProperty((String)"saveTextureMap"), (Object)"true")) {
>             Config.dbg((String)("Exporting texture map: " + this.basePath));
>             TextureUtils.saveGlTexture((String)("debug/" + this.basePath.replaceAll("/", "_")), (int)this.getGlTextureId(), (int)this.mipmapLevels, (int)stitcher.getCurrentWidth(), (int)stitcher.getCurrentHeight());
>         }
243,244c390,391
<     private boolean generateMipmaps(IResourceManager resourceManager, TextureAtlasSprite texture) {
<         block10: {
---
>     public boolean generateMipmaps(IResourceManager resourceManager, TextureAtlasSprite texture) {
>         block11: {
247c394,396
<             if (!texture.hasCustomLoader(resourceManager, resourcelocation)) {
---
>             if (texture.hasCustomLoader(resourceManager, resourcelocation)) {
>                 TextureUtils.generateCustomMipmaps((TextureAtlasSprite)texture, (int)this.mipmapLevels);
>             } else {
252c401
<                     break block10;
---
>                     break block11;
285c434
<     private ResourceLocation getResourceLocation(TextureAtlasSprite p_184396_1_) {
---
>     public ResourceLocation getResourceLocation(TextureAtlasSprite p_184396_1_) {
286a436,442
>         return this.completeResourceLocation(resourcelocation);
>     }
> 
>     public ResourceLocation completeResourceLocation(ResourceLocation resourcelocation) {
>         if (this.isAbsoluteLocation(resourcelocation)) {
>             return new ResourceLocation(resourcelocation.getNamespace(), resourcelocation.getPath() + ".png");
>         }
298a455,457
>         int frameCount;
>         boolean hasNormal = false;
>         boolean hasSpecular = false;
299a459
>         int countActive = 0;
300a461
>             if (!this.isTerrainAnimationActive(textureatlassprite)) continue;
301a463,520
>             if (textureatlassprite.isAnimationActive()) {
>                 ++countActive;
>             }
>             if (textureatlassprite.spriteNormal != null) {
>                 hasNormal = true;
>             }
>             if (textureatlassprite.spriteSpecular == null) continue;
>             hasSpecular = true;
>         }
>         if (Config.isMultiTexture()) {
>             for (TextureAtlasSprite ts : this.listAnimatedSprites) {
>                 TextureAtlasSprite spriteSingle;
>                 if (!this.isTerrainAnimationActive(ts) || (spriteSingle = ts.spriteSingle) == null) continue;
>                 if (ts == TextureUtils.iconClock || ts == TextureUtils.iconCompass) {
>                     spriteSingle.frameCounter = ts.frameCounter;
>                 }
>                 ts.bindSpriteTexture();
>                 spriteSingle.updateAnimation();
>                 if (!spriteSingle.isAnimationActive()) continue;
>                 ++countActive;
>             }
>             TextureUtil.bindTexture((int)this.getGlTextureId());
>         }
>         if (Config.isShaders()) {
>             if (hasNormal) {
>                 TextureUtil.bindTexture((int)this.getMultiTexID().norm);
>                 for (TextureAtlasSprite textureatlassprite : this.listAnimatedSprites) {
>                     if (textureatlassprite.spriteNormal == null || !this.isTerrainAnimationActive(textureatlassprite)) continue;
>                     if (textureatlassprite == TextureUtils.iconClock || textureatlassprite == TextureUtils.iconCompass) {
>                         textureatlassprite.spriteNormal.frameCounter = textureatlassprite.frameCounter;
>                     }
>                     textureatlassprite.spriteNormal.updateAnimation();
>                     if (!textureatlassprite.spriteNormal.isAnimationActive()) continue;
>                     ++countActive;
>                 }
>             }
>             if (hasSpecular) {
>                 TextureUtil.bindTexture((int)this.getMultiTexID().spec);
>                 for (TextureAtlasSprite textureatlassprite : this.listAnimatedSprites) {
>                     if (textureatlassprite.spriteSpecular == null || !this.isTerrainAnimationActive(textureatlassprite)) continue;
>                     if (textureatlassprite == TextureUtils.iconClock || textureatlassprite == TextureUtils.iconCompass) {
>                         textureatlassprite.spriteNormal.frameCounter = textureatlassprite.frameCounter;
>                     }
>                     textureatlassprite.spriteSpecular.updateAnimation();
>                     if (!textureatlassprite.spriteSpecular.isAnimationActive()) continue;
>                     ++countActive;
>                 }
>             }
>             if (hasNormal || hasSpecular) {
>                 TextureUtil.bindTexture((int)this.getGlTextureId());
>             }
>         }
>         if ((frameCount = Config.getMinecraft().entityRenderer.frameCount) != this.frameCountAnimations) {
>             this.countAnimationsActive = countActive;
>             this.frameCountAnimations = frameCount;
>         }
>         if (SmartAnimations.isActive()) {
>             SmartAnimations.resetSpritesRendered();
312a532,535
>             textureatlassprite.updateIndexInMap(this.counterIndexInMap);
>             if (Config.isEmissiveTextures()) {
>                 this.checkEmissive(location, textureatlassprite);
>             }
337a561
>             entry.updateIndexInMap(this.counterIndexInMap);
351,352c575,783
<     private /* synthetic */ TextureAtlasSprite lambda$loadTexture$0(ResourceLocation l) {
<         return (TextureAtlasSprite)this.mapRegisteredSprites.get((Object)l.toString());
---
>     private boolean isAbsoluteLocation(ResourceLocation loc) {
>         String path = loc.getPath();
>         return this.isAbsoluteLocationPath(path);
>     }
> 
>     private boolean isAbsoluteLocationPath(String resPath) {
>         String path = resPath.toLowerCase();
>         return path.startsWith("mcpatcher/") || path.startsWith("optifine/");
>     }
> 
>     public TextureAtlasSprite getSpriteSafe(String name) {
>         ResourceLocation loc = new ResourceLocation(name);
>         return (TextureAtlasSprite)this.mapRegisteredSprites.get((Object)loc.toString());
>     }
> 
>     public TextureAtlasSprite getRegisteredSprite(ResourceLocation loc) {
>         return (TextureAtlasSprite)this.mapRegisteredSprites.get((Object)loc.toString());
>     }
> 
>     private boolean isTerrainAnimationActive(TextureAtlasSprite ts) {
>         if (ts == TextureUtils.iconWaterStill || ts == TextureUtils.iconWaterFlow) {
>             return Config.isAnimatedWater();
>         }
>         if (ts == TextureUtils.iconLavaStill || ts == TextureUtils.iconLavaFlow) {
>             return Config.isAnimatedLava();
>         }
>         if (ts == TextureUtils.iconFireLayer0 || ts == TextureUtils.iconFireLayer1) {
>             return Config.isAnimatedFire();
>         }
>         if (ts == TextureUtils.iconPortal) {
>             return Config.isAnimatedPortal();
>         }
>         if (ts == TextureUtils.iconClock || ts == TextureUtils.iconCompass) {
>             return true;
>         }
>         return Config.isAnimatedTerrain();
>     }
> 
>     public int getCountRegisteredSprites() {
>         return this.counterIndexInMap.getValue();
>     }
> 
>     private int detectMaxMipmapLevel(Map mapSprites, IResourceManager rm) {
>         int minLevel;
>         int minSize = this.detectMinimumSpriteSize(mapSprites, rm, 20);
>         if (minSize < 16) {
>             minSize = 16;
>         }
>         if ((minSize = MathHelper.smallestEncompassingPowerOfTwo((int)minSize)) > 16) {
>             Config.log((String)("Sprite size: " + minSize));
>         }
>         if ((minLevel = MathHelper.log2((int)minSize)) < 4) {
>             minLevel = 4;
>         }
>         return minLevel;
>     }
> 
>     private int detectMinimumSpriteSize(Map mapSprites, IResourceManager rm, int percentScale) {
>         HashMap mapSizeCounts = new HashMap();
>         Set entrySetSprites = mapSprites.entrySet();
>         for (Map.Entry entry : entrySetSprites) {
>             TextureAtlasSprite sprite = (TextureAtlasSprite)entry.getValue();
>             ResourceLocation loc = new ResourceLocation(sprite.getIconName());
>             ResourceLocation locComplete = this.completeResourceLocation(loc);
>             if (sprite.hasCustomLoader(rm, loc)) continue;
>             try {
>                 InputStream in;
>                 IResource res = rm.getResource(locComplete);
>                 if (res == null || (in = res.getInputStream()) == null) continue;
>                 Dimension dim = TextureUtils.getImageSize((InputStream)in, (String)"png");
>                 in.close();
>                 if (dim == null) continue;
>                 int width = dim.width;
>                 int width2 = MathHelper.smallestEncompassingPowerOfTwo((int)width);
>                 if (!mapSizeCounts.containsKey((Object)width2)) {
>                     mapSizeCounts.put((Object)width2, (Object)1);
>                     continue;
>                 }
>                 int count = (Integer)mapSizeCounts.get((Object)width2);
>                 mapSizeCounts.put((Object)width2, (Object)(count + 1));
>             }
>             catch (Exception e) {}
>         }
>         int countSprites = 0;
>         Set setSizes = mapSizeCounts.keySet();
>         TreeSet setSizesSorted = new TreeSet((Collection)setSizes);
>         Iterator it = setSizesSorted.iterator();
>         while (it.hasNext()) {
>             int size = (Integer)it.next();
>             int count = (Integer)mapSizeCounts.get((Object)size);
>             countSprites += count;
>         }
>         int minSize = 16;
>         int countScale = 0;
>         int countScaleMax = countSprites * percentScale / 100;
>         Iterator it2 = setSizesSorted.iterator();
>         while (it2.hasNext()) {
>             int size = (Integer)it2.next();
>             int count = (Integer)mapSizeCounts.get((Object)size);
>             countScale += count;
>             if (size > minSize) {
>                 minSize = size;
>             }
>             if (countScale <= countScaleMax) continue;
>             return minSize;
>         }
>         return minSize;
>     }
> 
>     private int getMinSpriteSize() {
>         int minSize = 1 << this.mipmapLevels;
>         if (minSize < 8) {
>             minSize = 8;
>         }
>         return minSize;
>     }
> 
>     private int[] getMissingImageData(int size) {
>         BufferedImage bi = new BufferedImage(16, 16, 2);
>         bi.setRGB(0, 0, 16, 16, TextureUtil.MISSING_TEXTURE_DATA, 0, 16);
>         BufferedImage bi2 = TextureUtils.scaleImage((BufferedImage)bi, (int)size);
>         int[] data = new int[size * size];
>         bi2.getRGB(0, 0, size, size, data, 0, size);
>         return data;
>     }
> 
>     public boolean isTextureBound() {
>         int texId;
>         int boundTexId = GlStateManager.getBoundTexture();
>         return boundTexId == (texId = this.getGlTextureId());
>     }
> 
>     private void updateIconGrid(int sheetWidth, int sheetHeight) {
>         this.iconGridCountX = -1;
>         this.iconGridCountY = -1;
>         this.iconGrid = null;
>         if (this.iconGridSize <= 0) {
>             return;
>         }
>         this.iconGridCountX = sheetWidth / this.iconGridSize;
>         this.iconGridCountY = sheetHeight / this.iconGridSize;
>         this.iconGrid = new TextureAtlasSprite[this.iconGridCountX * this.iconGridCountY];
>         this.iconGridSizeU = 1.0 / (double)this.iconGridCountX;
>         this.iconGridSizeV = 1.0 / (double)this.iconGridCountY;
>         for (TextureAtlasSprite ts : this.mapUploadedSprites.values()) {
>             double deltaU = 0.5 / (double)sheetWidth;
>             double deltaV = 0.5 / (double)sheetHeight;
>             double uMin = (double)Math.min((float)ts.getMinU(), (float)ts.getMaxU()) + deltaU;
>             double vMin = (double)Math.min((float)ts.getMinV(), (float)ts.getMaxV()) + deltaV;
>             double uMax = (double)Math.max((float)ts.getMinU(), (float)ts.getMaxU()) - deltaU;
>             double vMax = (double)Math.max((float)ts.getMinV(), (float)ts.getMaxV()) - deltaV;
>             int iuMin = (int)(uMin / this.iconGridSizeU);
>             int ivMin = (int)(vMin / this.iconGridSizeV);
>             int iuMax = (int)(uMax / this.iconGridSizeU);
>             int ivMax = (int)(vMax / this.iconGridSizeV);
>             for (int iu = iuMin; iu <= iuMax; ++iu) {
>                 if (iu < 0 || iu >= this.iconGridCountX) {
>                     Config.warn((String)("Invalid grid U: " + iu + ", icon: " + ts.getIconName()));
>                     continue;
>                 }
>                 for (int iv = ivMin; iv <= ivMax; ++iv) {
>                     if (iv < 0 || iv >= this.iconGridCountX) {
>                         Config.warn((String)("Invalid grid V: " + iv + ", icon: " + ts.getIconName()));
>                         continue;
>                     }
>                     int index = iv * this.iconGridCountX + iu;
>                     this.iconGrid[index] = ts;
>                 }
>             }
>         }
>     }
> 
>     public TextureAtlasSprite getIconByUV(double u, double v) {
>         if (this.iconGrid == null) {
>             return null;
>         }
>         int iv = (int)(v / this.iconGridSizeV);
>         int iu = (int)(u / this.iconGridSizeU);
>         int index = iv * this.iconGridCountX + iu;
>         if (index < 0 || index > this.iconGrid.length) {
>             return null;
>         }
>         return this.iconGrid[index];
>     }
> 
>     private void checkEmissive(ResourceLocation locSprite, TextureAtlasSprite sprite) {
>         String suffixEm = EmissiveTextures.getSuffixEmissive();
>         if (suffixEm == null) {
>             return;
>         }
>         if (locSprite.getPath().endsWith(suffixEm)) {
>             return;
>         }
>         ResourceLocation locSpriteEm = new ResourceLocation(locSprite.getNamespace(), locSprite.getPath() + suffixEm);
>         ResourceLocation locPngEm = this.completeResourceLocation(locSpriteEm);
>         if (!Config.hasResource((ResourceLocation)locPngEm)) {
>             return;
>         }
>         TextureAtlasSprite spriteEmissive = this.registerSprite(locSpriteEm);
>         spriteEmissive.isEmissive = true;
>         sprite.spriteEmissive = spriteEmissive;
>     }
> 
>     public int getCountAnimations() {
>         return this.listAnimatedSprites.size();
>     }
> 
>     public int getCountAnimationsActive() {
>         return this.countAnimationsActive;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/texture/TextureUtil.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/texture/TextureUtil.java
4a5
>  *  Config
22,24c23,24
<  *  net.minecraftforge.fml.client.SplashProgress
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.Mipmaps
>  *  net.optifine.reflect.Reflector
44,46c44,45
< import net.minecraftforge.fml.client.SplashProgress;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.Mipmaps;
> import net.optifine.reflect.Reflector;
51d49
< @SideOnly(value=Side.CLIENT)
58a57
>     private static int[] dataArray;
99,106c98,103
<                 if (j > 0) {
<                     int k = aint2.length / j;
<                     int l = j << 1;
<                     for (int i1 = 0; i1 < j; ++i1) {
<                         for (int j1 = 0; j1 < k; ++j1) {
<                             int k1 = 2 * (i1 + j1 * l);
<                             aint2[i1 + j1 * j] = TextureUtil.blendColors(aint1[k1 + 0], aint1[k1 + 1], aint1[k1 + 0 + l], aint1[k1 + 1 + l], flag);
<                         }
---
>                 int k = aint2.length / j;
>                 int l = j << 1;
>                 for (int i1 = 0; i1 < j; ++i1) {
>                     for (int j1 = 0; j1 < k; ++j1) {
>                         int k1 = 2 * (i1 + j1 * l);
>                         aint2[i1 + j1 * j] = TextureUtil.blendColors(aint1[k1 + 0], aint1[k1 + 1], aint1[k1 + 0 + l], aint1[k1 + 1 + l], flag);
116,145c113
<         if (p_147943_4_) {
<             TextureUtil.MIPMAP_BUFFER[0] = p_147943_0_;
<             TextureUtil.MIPMAP_BUFFER[1] = p_147943_1_;
<             TextureUtil.MIPMAP_BUFFER[2] = p_147943_2_;
<             TextureUtil.MIPMAP_BUFFER[3] = p_147943_3_;
<             float f = 0.0f;
<             float f1 = 0.0f;
<             float f2 = 0.0f;
<             float f3 = 0.0f;
<             for (int i1 = 0; i1 < 4; ++i1) {
<                 if (MIPMAP_BUFFER[i1] >> 24 == 0) continue;
<                 f += TextureUtil.getColorGamma(MIPMAP_BUFFER[i1] >> 24);
<                 f1 += TextureUtil.getColorGamma(MIPMAP_BUFFER[i1] >> 16);
<                 f2 += TextureUtil.getColorGamma(MIPMAP_BUFFER[i1] >> 8);
<                 f3 += TextureUtil.getColorGamma(MIPMAP_BUFFER[i1] >> 0);
<             }
<             int i2 = (int)(Math.pow((double)(f /= 4.0f), (double)0.45454545454545453) * 255.0);
<             int j1 = (int)(Math.pow((double)(f1 /= 4.0f), (double)0.45454545454545453) * 255.0);
<             int k1 = (int)(Math.pow((double)(f2 /= 4.0f), (double)0.45454545454545453) * 255.0);
<             int l1 = (int)(Math.pow((double)(f3 /= 4.0f), (double)0.45454545454545453) * 255.0);
<             if (i2 < 96) {
<                 i2 = 0;
<             }
<             return i2 << 24 | j1 << 16 | k1 << 8 | l1;
<         }
<         int i = TextureUtil.blendColorComponent(p_147943_0_, p_147943_1_, p_147943_2_, p_147943_3_, 24);
<         int j = TextureUtil.blendColorComponent(p_147943_0_, p_147943_1_, p_147943_2_, p_147943_3_, 16);
<         int k = TextureUtil.blendColorComponent(p_147943_0_, p_147943_1_, p_147943_2_, p_147943_3_, 8);
<         int l = TextureUtil.blendColorComponent(p_147943_0_, p_147943_1_, p_147943_2_, p_147943_3_, 0);
<         return i << 24 | j << 16 | k << 8 | l;
---
>         return Mipmaps.alphaBlend((int)p_147943_0_, (int)p_147943_1_, (int)p_147943_2_, (int)p_147943_3_);
160d127
<             if (p_147955_1_ >> i <= 0 || p_147955_2_ >> i <= 0) break;
192,193c159,164
<         Class<SplashProgress> clazz = SplashProgress.class;
<         synchronized (SplashProgress.class) {
---
>         Class monitor = TextureUtil.class;
>         if (Reflector.SplashScreen.exists()) {
>             monitor = Reflector.SplashScreen.getTargetClass();
>         }
>         Class clazz = monitor;
>         synchronized (clazz) {
196,206c167,175
<             // ** MonitorExit[var4_4] (shouldn't be in output)
<             if (mipmapLevels >= 0) {
<                 GlStateManager.glTexParameteri((int)3553, (int)33085, (int)mipmapLevels);
<                 GlStateManager.glTexParameteri((int)3553, (int)33082, (int)0);
<                 GlStateManager.glTexParameteri((int)3553, (int)33083, (int)mipmapLevels);
<                 GlStateManager.glTexParameterf((int)3553, (int)34049, (float)0.0f);
<             }
<             for (int i = 0; i <= mipmapLevels; ++i) {
<                 GlStateManager.glTexImage2D((int)3553, (int)i, (int)6408, (int)(width >> i), (int)(height >> i), (int)0, (int)32993, (int)33639, (IntBuffer)null);
<             }
<             return;
---
>         }
>         if (mipmapLevels >= 0) {
>             GlStateManager.glTexParameteri((int)3553, (int)33085, (int)mipmapLevels);
>             GlStateManager.glTexParameteri((int)3553, (int)33082, (int)0);
>             GlStateManager.glTexParameteri((int)3553, (int)33083, (int)mipmapLevels);
>             GlStateManager.glTexParameterf((int)3553, (int)34049, (float)0.0f);
>         }
>         for (int i = 0; i <= mipmapLevels; ++i) {
>             GlStateManager.glTexImage2D((int)3553, (int)i, (int)6408, (int)(width >> i), (int)(height >> i), (int)0, (int)32993, (int)33639, (IntBuffer)null);
220c189
<         int[] aint = new int[k * i];
---
>         int[] aint = dataArray;
233c202
<     private static void setTextureClamped(boolean p_110997_0_) {
---
>     public static void setTextureClamped(boolean p_110997_0_) {
235,236c204,205
<             GlStateManager.glTexParameteri((int)3553, (int)10242, (int)10496);
<             GlStateManager.glTexParameteri((int)3553, (int)10243, (int)10496);
---
>             GlStateManager.glTexParameteri((int)3553, (int)10242, (int)33071);
>             GlStateManager.glTexParameteri((int)3553, (int)10243, (int)33071);
247c216
<     private static void setTextureBlurMipmap(boolean p_147954_0_, boolean p_147954_1_) {
---
>     public static void setTextureBlurMipmap(boolean p_147954_0_, boolean p_147954_1_) {
252c221,222
<             GlStateManager.glTexParameteri((int)3553, (int)10241, (int)(p_147954_1_ ? 9986 : 9728));
---
>             int mipmapType = Config.getMipmapType();
>             GlStateManager.glTexParameteri((int)3553, (int)10241, (int)(p_147954_1_ ? mipmapType : 9728));
283a254,257
>             if (bufferedimage == null) {
>                 int[] nArray = null;
>                 return nArray;
>             }
297a272,274
>         if (imageStream == null) {
>             return null;
>         }
336a314
>         dataArray = new int[0x400000];
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java
4a5
>  *  Config
18a20
>  *  net.optifine.shaders.Shaders
30a33
> import net.optifine.shaders.Shaders;
36,37c39,40
<     public void render(TileEntityBeacon tileEntityBeacon, double d, double d2, double d3, float f, int n, float f2) {
<         this.renderBeacon(d, d2, d3, f, tileEntityBeacon.shouldBeamRender(), (List<TileEntityBeacon.BeamSegment>)tileEntityBeacon.getBeamSegments(), tileEntityBeacon.D().getTotalWorldTime());
---
>     public void render(TileEntityBeacon te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
>         this.renderBeacon(x, y, z, partialTicks, te.shouldBeamRender(), (List<TileEntityBeacon.BeamSegment>)te.getBeamSegments(), te.D().getTotalWorldTime());
40c43,49
<     public void renderBeacon(double d, double d2, double d3, double d4, double d5, List<TileEntityBeacon.BeamSegment> list, double d6) {
---
>     public void renderBeacon(double x, double y, double z, double partialTicks, double textureScale, List<TileEntityBeacon.BeamSegment> beamSegments, double totalWorldTime) {
>         if (textureScale <= 0.0 || beamSegments.size() <= 0) {
>             return;
>         }
>         if (Config.isShaders()) {
>             Shaders.beginBeacon();
>         }
43c52
<         if (d5 > 0.0) {
---
>         if (textureScale > 0.0) {
45,49c54,58
<             int n = 0;
<             for (\u2603 = 0; \u2603 < list.size(); ++\u2603) {
<                 TileEntityBeacon.BeamSegment beamSegment = (TileEntityBeacon.BeamSegment)list.get(\u2603);
<                 TileEntityBeaconRenderer.renderBeamSegment(d, d2, d3, d4, d5, d6, n, beamSegment.getHeight(), beamSegment.getColors());
<                 n += beamSegment.getHeight();
---
>             int i = 0;
>             for (int j = 0; j < beamSegments.size(); ++j) {
>                 TileEntityBeacon.BeamSegment tileentitybeacon$beamsegment = (TileEntityBeacon.BeamSegment)beamSegments.get(j);
>                 TileEntityBeaconRenderer.renderBeamSegment(x, y, z, partialTicks, textureScale, totalWorldTime, i, tileentitybeacon$beamsegment.getHeight(), tileentitybeacon$beamsegment.getColors());
>                 i += tileentitybeacon$beamsegment.getHeight();
52a62,64
>         if (Config.isShaders()) {
>             Shaders.endBeacon();
>         }
55,56c67,68
<     public static void renderBeamSegment(double d, double d2, double d3, double d4, double d5, double d6, int n, int n2, float[] fArray) {
<         TileEntityBeaconRenderer.renderBeamSegment(d, d2, d3, d4, d5, d6, n, n2, fArray, 0.2, 0.25);
---
>     public static void renderBeamSegment(double x, double y, double z, double partialTicks, double textureScale, double totalWorldTime, int yOffset, int height, float[] colors) {
>         TileEntityBeaconRenderer.renderBeamSegment(x, y, z, partialTicks, textureScale, totalWorldTime, yOffset, height, colors, 0.2, 0.25);
59,60c71,72
<     public static void renderBeamSegment(double d, double d2, double d3, double d4, double d5, double d6, int n, int n2, float[] fArray, double d7, double d8) {
<         int n3 = n + n2;
---
>     public static void renderBeamSegment(double x, double y, double z, double partialTicks, double textureScale, double totalWorldTime, int yOffset, int height, float[] colors, double beamRadius, double glowRadius) {
>         int i = yOffset + height;
68,106c80,118
<         Tessellator \u26032 = Tessellator.getInstance();
<         BufferBuilder \u26033 = \u26032.getBuffer();
<         double \u26034 = d6 + d4;
<         double \u26035 = n2 < 0 ? \u26034 : -\u26034;
<         double \u26036 = MathHelper.frac((double)(\u26035 * 0.2 - (double)MathHelper.floor((double)(\u26035 * 0.1))));
<         float \u26037 = fArray[0];
<         float \u26038 = fArray[1];
<         float \u26039 = fArray[2];
<         double \u260310 = \u26034 * 0.025 * -1.5;
<         double \u260311 = 0.5 + Math.cos((double)(\u260310 + 2.356194490192345)) * d7;
<         double \u260312 = 0.5 + Math.sin((double)(\u260310 + 2.356194490192345)) * d7;
<         double \u260313 = 0.5 + Math.cos((double)(\u260310 + 0.7853981633974483)) * d7;
<         double \u260314 = 0.5 + Math.sin((double)(\u260310 + 0.7853981633974483)) * d7;
<         double \u260315 = 0.5 + Math.cos((double)(\u260310 + 3.9269908169872414)) * d7;
<         double \u260316 = 0.5 + Math.sin((double)(\u260310 + 3.9269908169872414)) * d7;
<         double \u260317 = 0.5 + Math.cos((double)(\u260310 + 5.497787143782138)) * d7;
<         double \u260318 = 0.5 + Math.sin((double)(\u260310 + 5.497787143782138)) * d7;
<         double \u260319 = 0.0;
<         double \u260320 = 1.0;
<         double \u260321 = -1.0 + \u26036;
<         double \u260322 = (double)n2 * d5 * (0.5 / d7) + \u260321;
<         \u26033.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
<         \u26033.pos(d + \u260311, d2 + (double)n3, d3 + \u260312).tex(1.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260311, d2 + (double)n, d3 + \u260312).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260313, d2 + (double)n, d3 + \u260314).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260313, d2 + (double)n3, d3 + \u260314).tex(0.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260317, d2 + (double)n3, d3 + \u260318).tex(1.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260317, d2 + (double)n, d3 + \u260318).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260315, d2 + (double)n, d3 + \u260316).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260315, d2 + (double)n3, d3 + \u260316).tex(0.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260313, d2 + (double)n3, d3 + \u260314).tex(1.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260313, d2 + (double)n, d3 + \u260314).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260317, d2 + (double)n, d3 + \u260318).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260317, d2 + (double)n3, d3 + \u260318).tex(0.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260315, d2 + (double)n3, d3 + \u260316).tex(1.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260315, d2 + (double)n, d3 + \u260316).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260311, d2 + (double)n, d3 + \u260312).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26033.pos(d + \u260311, d2 + (double)n3, d3 + \u260312).tex(0.0, \u260322).color(\u26037, \u26038, \u26039, 1.0f).endVertex();
<         \u26032.draw();
---
>         Tessellator tessellator = Tessellator.getInstance();
>         BufferBuilder bufferbuilder = tessellator.getBuffer();
>         double d0 = totalWorldTime + partialTicks;
>         double d1 = height < 0 ? d0 : -d0;
>         double d2 = MathHelper.frac((double)(d1 * 0.2 - (double)MathHelper.floor((double)(d1 * 0.1))));
>         float f = colors[0];
>         float f1 = colors[1];
>         float f2 = colors[2];
>         double d3 = d0 * 0.025 * -1.5;
>         double d4 = 0.5 + Math.cos((double)(d3 + 2.356194490192345)) * beamRadius;
>         double d5 = 0.5 + Math.sin((double)(d3 + 2.356194490192345)) * beamRadius;
>         double d6 = 0.5 + Math.cos((double)(d3 + 0.7853981633974483)) * beamRadius;
>         double d7 = 0.5 + Math.sin((double)(d3 + 0.7853981633974483)) * beamRadius;
>         double d8 = 0.5 + Math.cos((double)(d3 + 3.9269908169872414)) * beamRadius;
>         double d9 = 0.5 + Math.sin((double)(d3 + 3.9269908169872414)) * beamRadius;
>         double d10 = 0.5 + Math.cos((double)(d3 + 5.497787143782138)) * beamRadius;
>         double d11 = 0.5 + Math.sin((double)(d3 + 5.497787143782138)) * beamRadius;
>         double d12 = 0.0;
>         double d13 = 1.0;
>         double d14 = -1.0 + d2;
>         double d15 = (double)height * textureScale * (0.5 / beamRadius) + d14;
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
>         bufferbuilder.pos(x + d4, y + (double)i, z + d5).tex(1.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d4, y + (double)yOffset, z + d5).tex(1.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d6, y + (double)yOffset, z + d7).tex(0.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d6, y + (double)i, z + d7).tex(0.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d10, y + (double)i, z + d11).tex(1.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d10, y + (double)yOffset, z + d11).tex(1.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d8, y + (double)yOffset, z + d9).tex(0.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d8, y + (double)i, z + d9).tex(0.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d6, y + (double)i, z + d7).tex(1.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d6, y + (double)yOffset, z + d7).tex(1.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d10, y + (double)yOffset, z + d11).tex(0.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d10, y + (double)i, z + d11).tex(0.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d8, y + (double)i, z + d9).tex(1.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d8, y + (double)yOffset, z + d9).tex(1.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d4, y + (double)yOffset, z + d5).tex(0.0, d14).color(f, f1, f2, 1.0f).endVertex();
>         bufferbuilder.pos(x + d4, y + (double)i, z + d5).tex(0.0, d15).color(f, f1, f2, 1.0f).endVertex();
>         tessellator.draw();
110,139c122,154
<         \u260310 = 0.5 - d8;
<         \u260311 = 0.5 - d8;
<         \u260312 = 0.5 + d8;
<         \u260313 = 0.5 - d8;
<         \u260314 = 0.5 - d8;
<         \u260315 = 0.5 + d8;
<         \u260316 = 0.5 + d8;
<         \u260317 = 0.5 + d8;
<         \u260318 = 0.0;
<         \u260319 = 1.0;
<         \u260320 = -1.0 + \u26036;
<         \u260321 = (double)n2 * d5 + \u260320;
<         \u26033.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
<         \u26033.pos(d + \u260310, d2 + (double)n3, d3 + \u260311).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260310, d2 + (double)n, d3 + \u260311).tex(1.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260312, d2 + (double)n, d3 + \u260313).tex(0.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260312, d2 + (double)n3, d3 + \u260313).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260316, d2 + (double)n3, d3 + \u260317).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260316, d2 + (double)n, d3 + \u260317).tex(1.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260314, d2 + (double)n, d3 + \u260315).tex(0.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260314, d2 + (double)n3, d3 + \u260315).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260312, d2 + (double)n3, d3 + \u260313).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260312, d2 + (double)n, d3 + \u260313).tex(1.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260316, d2 + (double)n, d3 + \u260317).tex(0.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260316, d2 + (double)n3, d3 + \u260317).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260314, d2 + (double)n3, d3 + \u260315).tex(1.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260314, d2 + (double)n, d3 + \u260315).tex(1.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260310, d2 + (double)n, d3 + \u260311).tex(0.0, \u260320).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26033.pos(d + \u260310, d2 + (double)n3, d3 + \u260311).tex(0.0, \u260321).color(\u26037, \u26038, \u26039, 0.125f).endVertex();
<         \u26032.draw();
---
>         if (Config.isShaders()) {
>             GlStateManager.depthMask((boolean)Shaders.isBeaconBeamDepth());
>         }
>         d3 = 0.5 - glowRadius;
>         d4 = 0.5 - glowRadius;
>         d5 = 0.5 + glowRadius;
>         d6 = 0.5 - glowRadius;
>         d7 = 0.5 - glowRadius;
>         d8 = 0.5 + glowRadius;
>         d9 = 0.5 + glowRadius;
>         d10 = 0.5 + glowRadius;
>         d11 = 0.0;
>         d12 = 1.0;
>         d13 = -1.0 + d2;
>         d14 = (double)height * textureScale + d13;
>         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
>         bufferbuilder.pos(x + d3, y + (double)i, z + d4).tex(1.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d3, y + (double)yOffset, z + d4).tex(1.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d5, y + (double)yOffset, z + d6).tex(0.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d5, y + (double)i, z + d6).tex(0.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d9, y + (double)i, z + d10).tex(1.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d9, y + (double)yOffset, z + d10).tex(1.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d7, y + (double)yOffset, z + d8).tex(0.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d7, y + (double)i, z + d8).tex(0.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d5, y + (double)i, z + d6).tex(1.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d5, y + (double)yOffset, z + d6).tex(1.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d9, y + (double)yOffset, z + d10).tex(0.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d9, y + (double)i, z + d10).tex(0.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d7, y + (double)i, z + d8).tex(1.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d7, y + (double)yOffset, z + d8).tex(1.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d3, y + (double)yOffset, z + d4).tex(0.0, d13).color(f, f1, f2, 0.125f).endVertex();
>         bufferbuilder.pos(x + d3, y + (double)i, z + d4).tex(0.0, d14).color(f, f1, f2, 0.125f).endVertex();
>         tessellator.draw();
145c160
<     public boolean isGlobalRenderer(TileEntityBeacon tileEntityBeacon) {
---
>     public boolean isGlobalRenderer(TileEntityBeacon te) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java
4a5
>  *  Config
20a22
>  *  net.optifine.shaders.ShadersRender
35a38
> import net.optifine.shaders.ShadersRender;
46c49,52
<     public void render(TileEntityEndPortal tileEntityEndPortal, double d, double d2, double d3, float f, int n, float f2) {
---
>     public void render(TileEntityEndPortal te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
>         if (Config.isShaders() && ShadersRender.renderEndPortal((TileEntityEndPortal)te, (double)x, (double)y, (double)z, (float)partialTicks, (int)destroyStage, (float)this.getOffset())) {
>             return;
>         }
51,55c57,61
<         double d4 = d * d + d2 * d2 + d3 * d3;
<         int \u26032 = this.getPasses(d4);
<         float \u26033 = this.getOffset();
<         boolean \u26034 = false;
<         for (int i = 0; i < \u26032; ++i) {
---
>         double d0 = x * x + y * y + z * z;
>         int i = this.getPasses(d0);
>         float f = this.getOffset();
>         boolean flag = false;
>         for (int j = 0; j < i; ++j) {
57,58c63,64
<             float f3 = 2.0f / (float)(18 - i);
<             if (i == 0) {
---
>             float f1 = 2.0f / (float)(18 - j);
>             if (j == 0) {
60c66
<                 f3 = 0.15f;
---
>                 f1 = 0.15f;
64c70
<             if (i >= 1) {
---
>             if (j >= 1) {
66c72
<                 \u26034 = true;
---
>                 flag = true;
69c75
<             if (i == 1) {
---
>             if (j == 1) {
88,91c94,97
<             \u2603 = i + 1;
<             GlStateManager.translate((float)(17.0f / \u2603), (float)((2.0f + \u2603 / 1.5f) * ((float)Minecraft.getSystemTime() % 800000.0f / 800000.0f)), (float)0.0f);
<             GlStateManager.rotate((float)((\u2603 * \u2603 * 4321.0f + \u2603 * 9.0f) * 2.0f), (float)0.0f, (float)0.0f, (float)1.0f);
<             GlStateManager.scale((float)(4.5f - \u2603 / 4.0f), (float)(4.5f - \u2603 / 4.0f), (float)1.0f);
---
>             float f2 = j + 1;
>             GlStateManager.translate((float)(17.0f / f2), (float)((2.0f + f2 / 1.5f) * ((float)Minecraft.getSystemTime() % 800000.0f / 800000.0f)), (float)0.0f);
>             GlStateManager.rotate((float)((f2 * f2 * 4321.0f + f2 * 9.0f) * 2.0f), (float)0.0f, (float)0.0f, (float)1.0f);
>             GlStateManager.scale((float)(4.5f - f2 / 4.0f), (float)(4.5f - f2 / 4.0f), (float)1.0f);
94,134c100,140
<             Tessellator \u26035 = Tessellator.getInstance();
<             BufferBuilder \u26036 = \u26035.getBuffer();
<             \u26036.begin(7, DefaultVertexFormats.POSITION_COLOR);
<             \u2603 = (RANDOM.nextFloat() * 0.5f + 0.1f) * f3;
<             \u2603 = (RANDOM.nextFloat() * 0.5f + 0.4f) * f3;
<             \u2603 = (RANDOM.nextFloat() * 0.5f + 0.5f) * f3;
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.SOUTH)) {
<                 \u26036.pos(d, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2 + 1.0, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2 + 1.0, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<             }
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.NORTH)) {
<                 \u26036.pos(d, d2 + 1.0, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2 + 1.0, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<             }
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.EAST)) {
<                 \u26036.pos(d + 1.0, d2 + 1.0, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2 + 1.0, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<             }
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.WEST)) {
<                 \u26036.pos(d, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2 + 1.0, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2 + 1.0, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<             }
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.DOWN)) {
<                 \u26036.pos(d, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<             }
<             if (tileEntityEndPortal.shouldRenderFace(EnumFacing.UP)) {
<                 \u26036.pos(d, d2 + (double)\u26033, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2 + (double)\u26033, d3 + 1.0).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d + 1.0, d2 + (double)\u26033, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
<                 \u26036.pos(d, d2 + (double)\u26033, d3).color(\u2603, \u2603, \u2603, 1.0f).endVertex();
---
>             Tessellator tessellator = Tessellator.getInstance();
>             BufferBuilder bufferbuilder = tessellator.getBuffer();
>             bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
>             float f3 = (RANDOM.nextFloat() * 0.5f + 0.1f) * f1;
>             float f4 = (RANDOM.nextFloat() * 0.5f + 0.4f) * f1;
>             float f5 = (RANDOM.nextFloat() * 0.5f + 0.5f) * f1;
>             if (te.shouldRenderFace(EnumFacing.SOUTH)) {
>                 bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>             }
>             if (te.shouldRenderFace(EnumFacing.NORTH)) {
>                 bufferbuilder.pos(x, y + 1.0, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y + 1.0, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0f).endVertex();
>             }
>             if (te.shouldRenderFace(EnumFacing.EAST)) {
>                 bufferbuilder.pos(x + 1.0, y + 1.0, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0f).endVertex();
>             }
>             if (te.shouldRenderFace(EnumFacing.WEST)) {
>                 bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y + 1.0, z).color(f3, f4, f5, 1.0f).endVertex();
>             }
>             if (te.shouldRenderFace(EnumFacing.DOWN)) {
>                 bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>             }
>             if (te.shouldRenderFace(EnumFacing.UP)) {
>                 bufferbuilder.pos(x, y + (double)f, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y + (double)f, z + 1.0).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x + 1.0, y + (double)f, z).color(f3, f4, f5, 1.0f).endVertex();
>                 bufferbuilder.pos(x, y + (double)f, z).color(f3, f4, f5, 1.0f).endVertex();
136c142
<             \u26035.draw();
---
>             tessellator.draw();
146c152
<         if (\u26034) {
---
>         if (flag) {
151,153c157,159
<     protected int getPasses(double d) {
<         int n = d > 36864.0 ? 1 : (d > 25600.0 ? 3 : (d > 16384.0 ? 5 : (d > 9216.0 ? 7 : (d > 4096.0 ? 9 : (d > 1024.0 ? 11 : (d > 576.0 ? 13 : (d > 256.0 ? 14 : 15)))))));
<         return n;
---
>     protected int getPasses(double p_191286_1_) {
>         int i = p_191286_1_ > 36864.0 ? 1 : (p_191286_1_ > 25600.0 ? 3 : (p_191286_1_ > 16384.0 ? 5 : (p_191286_1_ > 9216.0 ? 7 : (p_191286_1_ > 4096.0 ? 9 : (p_191286_1_ > 1024.0 ? 11 : (p_191286_1_ > 576.0 ? 13 : (p_191286_1_ > 256.0 ? 14 : 15)))))));
>         return i;
160c166
<     private FloatBuffer getBuffer(float f, float f2, float f3, float f4) {
---
>     private FloatBuffer getBuffer(float p_147525_1_, float p_147525_2_, float p_147525_3_, float p_147525_4_) {
162c168
<         this.buffer.put(f).put(f2).put(f3).put(f4);
---
>         this.buffer.put(p_147525_1_).put(p_147525_2_).put(p_147525_3_).put(p_147525_4_);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java
15d14
<  *  net.minecraft.client.renderer.ActiveRenderInfo
61,62c60,62
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.EmissiveTextures
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
72d71
< import net.minecraft.client.renderer.ActiveRenderInfo;
118,119c117,119
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.EmissiveTextures;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
121d120
< @SideOnly(value=Side.CLIENT)
137a137
>     public TileEntity tileEntityRendered;
193c193,197
<             if (!this.drawingBatch || !tileentityIn.hasFastRenderer()) {
---
>             boolean setLightmap = true;
>             if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
>                 boolean bl = setLightmap = !this.drawingBatch || !Reflector.callBoolean((Object)tileentityIn, (ReflectorMethod)Reflector.ForgeTileEntity_hasFastRenderer, (Object[])new Object[0]);
>             }
>             if (setLightmap) {
201,202c205,218
<             if (this.world.isBlockLoaded(blockpos = tileentityIn.getPos(), false)) {
<                 this.render(tileentityIn, (double)blockpos.p() - staticPlayerX, (double)blockpos.q() - staticPlayerY, (double)blockpos.r() - staticPlayerZ, partialTicks, destroyStage, 1.0f);
---
>             if (!this.world.isBlockLoaded(blockpos = tileentityIn.getPos(), false)) {
>                 return;
>             }
>             if (EmissiveTextures.isActive()) {
>                 EmissiveTextures.beginRender();
>             }
>             this.render(tileentityIn, (double)blockpos.p() - staticPlayerX, (double)blockpos.q() - staticPlayerY, (double)blockpos.r() - staticPlayerZ, partialTicks, destroyStage, 1.0f);
>             if (EmissiveTextures.isActive()) {
>                 if (EmissiveTextures.hasEmissive()) {
>                     EmissiveTextures.beginRenderEmissive();
>                     this.render(tileentityIn, (double)blockpos.p() - staticPlayerX, (double)blockpos.q() - staticPlayerY, (double)blockpos.r() - staticPlayerZ, partialTicks, destroyStage, 1.0f);
>                     EmissiveTextures.endRenderEmissive();
>                 }
>                 EmissiveTextures.endRender();
219c235,236
<                 if (this.drawingBatch && tileEntityIn.hasFastRenderer()) {
---
>                 this.tileEntityRendered = tileEntityIn;
>                 if (this.drawingBatch && Reflector.callBoolean((Object)tileEntityIn, (ReflectorMethod)Reflector.ForgeTileEntity_hasFastRenderer, (Object[])new Object[0])) {
223a241
>                 this.tileEntityRendered = null;
262,263c280,285
<             Vec3d cameraPos = ActiveRenderInfo.getCameraPosition();
<             this.batchBuffer.getBuffer().sortVertexData((float)cameraPos.x, (float)cameraPos.y, (float)cameraPos.z);
---
>             Vec3d cameraPos = (Vec3d)Reflector.call((ReflectorMethod)Reflector.ActiveRenderInfo_getCameraPosition, (Object[])new Object[0]);
>             if (cameraPos != null) {
>                 this.batchBuffer.getBuffer().sortVertexData((float)cameraPos.x, (float)cameraPos.y, (float)cameraPos.z);
>             } else {
>                 this.batchBuffer.getBuffer().sortVertexData(0.0f, 0.0f, 0.0f);
>             }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java
4a5,6
>  *  Config
>  *  java.lang.Math
8a11
>  *  net.minecraft.client.Minecraft
13a17
>  *  net.minecraft.entity.Entity
17a22,23
>  *  net.optifine.CustomColors
>  *  net.optifine.shaders.Shaders
22a29
> import net.minecraft.client.Minecraft;
27a35
> import net.minecraft.entity.Entity;
31a40,41
> import net.optifine.CustomColors;
> import net.optifine.shaders.Shaders;
36a47
>     private static double textRenderDistanceSq = 4096.0;
38,41c49,50
<     public void render(TileEntitySign tileEntitySign2, double d, double d2, double d3, float f, int n2, float f2) {
<         int n2;
<         float \u26034;
<         Block block = tileEntitySign2.x();
---
>     public void render(TileEntitySign te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
>         Block block = te.x();
43c52
<         float \u26032 = 0.6666667f;
---
>         float f = 0.6666667f;
45,47c54,56
<             GlStateManager.translate((float)((float)d + 0.5f), (float)((float)d2 + 0.5f), (float)((float)d3 + 0.5f));
<             float f3 = (float)(tileEntitySign2.v() * 360) / 16.0f;
<             GlStateManager.rotate((float)(-f3), (float)0.0f, (float)1.0f, (float)0.0f);
---
>             GlStateManager.translate((float)((float)x + 0.5f), (float)((float)y + 0.5f), (float)((float)z + 0.5f));
>             float f1 = (float)(te.v() * 360) / 16.0f;
>             GlStateManager.rotate((float)(-f1), (float)0.0f, (float)1.0f, (float)0.0f);
50,54c59,62
<             TileEntitySign tileEntitySign2;
<             int \u26033 = tileEntitySign2.v();
<             \u26034 = 0.0f;
<             if (\u26033 == 2) {
<                 \u26034 = 180.0f;
---
>             int k = te.v();
>             float f2 = 0.0f;
>             if (k == 2) {
>                 f2 = 180.0f;
56,57c64,65
<             if (\u26033 == 4) {
<                 \u26034 = 90.0f;
---
>             if (k == 4) {
>                 f2 = 90.0f;
59,60c67,68
<             if (\u26033 == 5) {
<                 \u26034 = -90.0f;
---
>             if (k == 5) {
>                 f2 = -90.0f;
62,63c70,71
<             GlStateManager.translate((float)((float)d + 0.5f), (float)((float)d2 + 0.5f), (float)((float)d3 + 0.5f));
<             GlStateManager.rotate((float)(-\u26034), (float)0.0f, (float)1.0f, (float)0.0f);
---
>             GlStateManager.translate((float)((float)x + 0.5f), (float)((float)y + 0.5f), (float)((float)z + 0.5f));
>             GlStateManager.rotate((float)(-f2), (float)0.0f, (float)1.0f, (float)0.0f);
67,68c75,76
<         if (n2 >= 0) {
<             this.bindTexture(DESTROY_STAGES[n2]);
---
>         if (destroyStage >= 0) {
>             this.bindTexture(DESTROY_STAGES[destroyStage]);
82,98c90,113
<         FontRenderer fontRenderer = this.getFontRenderer();
<         \u26034 = 0.010416667f;
<         GlStateManager.translate((float)0.0f, (float)0.33333334f, (float)0.046666667f);
<         GlStateManager.scale((float)0.010416667f, (float)-0.010416667f, (float)0.010416667f);
<         GlStateManager.glNormal3f((float)0.0f, (float)0.0f, (float)-0.010416667f);
<         GlStateManager.depthMask((boolean)false);
<         boolean \u26035 = false;
<         if (n2 < 0) {
<             for (int i = 0; i < tileEntitySign2.signText.length; ++i) {
<                 if (tileEntitySign2.signText[i] == null) continue;
<                 ITextComponent iTextComponent = tileEntitySign2.signText[i];
<                 List \u26036 = GuiUtilRenderComponents.splitText((ITextComponent)iTextComponent, (int)90, (FontRenderer)fontRenderer, (boolean)false, (boolean)true);
<                 String string = string2 = \u26036 != null && !\u26036.isEmpty() ? ((ITextComponent)\u26036.get(0)).getFormattedText() : "";
<                 if (i == tileEntitySign2.lineBeingEdited) {
<                     String string2 = "> " + string2 + " <";
<                     fontRenderer.drawString(string2, -fontRenderer.getStringWidth(string2) / 2, i * 10 - tileEntitySign2.signText.length * 5, 0);
<                     continue;
---
>         if (TileEntitySignRenderer.isRenderText(te)) {
>             FontRenderer fontrenderer = this.getFontRenderer();
>             float f3 = 0.010416667f;
>             GlStateManager.translate((float)0.0f, (float)0.33333334f, (float)0.046666667f);
>             GlStateManager.scale((float)0.010416667f, (float)-0.010416667f, (float)0.010416667f);
>             GlStateManager.glNormal3f((float)0.0f, (float)0.0f, (float)-0.010416667f);
>             GlStateManager.depthMask((boolean)false);
>             int i = 0;
>             if (Config.isCustomColors()) {
>                 i = CustomColors.getSignTextColor((int)i);
>             }
>             if (destroyStage < 0) {
>                 for (int j = 0; j < te.signText.length; ++j) {
>                     String s;
>                     if (te.signText[j] == null) continue;
>                     ITextComponent itextcomponent = te.signText[j];
>                     List list = GuiUtilRenderComponents.splitText((ITextComponent)itextcomponent, (int)90, (FontRenderer)fontrenderer, (boolean)false, (boolean)true);
>                     String string = s = list != null && !list.isEmpty() ? ((ITextComponent)list.get(0)).getFormattedText() : "";
>                     if (j == te.lineBeingEdited) {
>                         s = "> " + s + " <";
>                         fontrenderer.drawString(s, -fontrenderer.getStringWidth(s) / 2, j * 10 - te.signText.length * 5, i);
>                         continue;
>                     }
>                     fontrenderer.drawString(s, -fontrenderer.getStringWidth(s) / 2, j * 10 - te.signText.length * 5, i);
100d114
<                 fontRenderer.drawString(string2, -fontRenderer.getStringWidth(string2) / 2, i * 10 - tileEntitySign2.signText.length * 5, 0);
106c120
<         if (n2 >= 0) {
---
>         if (destroyStage >= 0) {
110a125,145
>     }
> 
>     private static boolean isRenderText(TileEntitySign tileEntity) {
>         if (Shaders.isShadowPass) {
>             return false;
>         }
>         if (!Config.zoomMode && tileEntity.lineBeingEdited < 0) {
>             Entity viewEntity = Config.getMinecraft().getRenderViewEntity();
>             double distSq = tileEntity.a(viewEntity.posX, viewEntity.posY, viewEntity.posZ);
>             if (distSq > textRenderDistanceSq) {
>                 return false;
>             }
>         }
>         return true;
>     }
> 
>     public static void updateTextRenderDistance() {
>         Minecraft mc = Config.getMinecraft();
>         double fov = Config.limit((float)mc.gameSettings.fovSetting, (float)1.0f, (float)120.0f);
>         double textRenderDistance = Math.max((double)(1.5 * (double)mc.displayHeight / fov), (double)16.0);
>         textRenderDistanceSq = textRenderDistance * textRenderDistance;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java
4a5
>  *  java.lang.Class
19,20c20
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.entity.model.IEntityRenderer
36,37c36
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.entity.model.IEntityRenderer;
39,40c38,39
< @SideOnly(value=Side.CLIENT)
< public abstract class TileEntitySpecialRenderer<T extends TileEntity> {
---
> public abstract class TileEntitySpecialRenderer<T extends TileEntity>
> implements IEntityRenderer {
42a42,43
>     private Class tileEntityClass = null;
>     private ResourceLocation locationTextureCustom = null;
86,88d86
<     public void renderTileEntityFast(T te, double x, double y, double z, float partialTicks, int destroyStage, float partial, BufferBuilder buffer) {
<     }
< 
97a96,114
>     }
> 
>     public void renderTileEntityFast(T te, double x, double y, double z, float partialTicks, int destroyStage, float partial, BufferBuilder buffer) {
>     }
> 
>     public Class getEntityClass() {
>         return this.tileEntityClass;
>     }
> 
>     public void setEntityClass(Class tileEntityClass) {
>         this.tileEntityClass = tileEntityClass;
>     }
> 
>     public ResourceLocation getLocationTextureCustom() {
>         return this.locationTextureCustom;
>     }
> 
>     public void setLocationTextureCustom(ResourceLocation locationTextureCustom) {
>         this.locationTextureCustom = locationTextureCustom;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java
4a5
>  *  Config
5a7,8
>  *  java.lang.Throwable
>  *  java.lang.reflect.Field
9a13,15
>  *  net.optifine.reflect.ReflectorClass
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.shaders.SVertexFormat
12a19
> import java.lang.reflect.Field;
14a22,24
> import net.optifine.reflect.ReflectorClass;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.shaders.SVertexFormat;
17,18c27,33
<     public static final VertexFormat BLOCK = new VertexFormat();
<     public static final VertexFormat ITEM = new VertexFormat();
---
>     public static VertexFormat BLOCK = new VertexFormat();
>     public static VertexFormat ITEM = new VertexFormat();
>     private static final VertexFormat BLOCK_VANILLA = BLOCK;
>     private static final VertexFormat ITEM_VANILLA = ITEM;
>     public static ReflectorClass Attributes = new ReflectorClass("net.minecraftforge.client.model.Attributes");
>     public static ReflectorField Attributes_DEFAULT_BAKED_FORMAT = new ReflectorField(Attributes, "DEFAULT_BAKED_FORMAT");
>     private static final VertexFormat FORGE_BAKED = SVertexFormat.duplicate((VertexFormat)((VertexFormat)DefaultVertexFormats.getFieldValue(Attributes_DEFAULT_BAKED_FORMAT)));
34a50,80
> 
>     public static void updateVertexFormats() {
>         if (Config.isShaders()) {
>             BLOCK = SVertexFormat.makeDefVertexFormatBlock();
>             ITEM = SVertexFormat.makeDefVertexFormatItem();
>             if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
>                 SVertexFormat.setDefBakedFormat((VertexFormat)((VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue()));
>             }
>         } else {
>             BLOCK = BLOCK_VANILLA;
>             ITEM = ITEM_VANILLA;
>             if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
>                 SVertexFormat.copy((VertexFormat)FORGE_BAKED, (VertexFormat)((VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue()));
>             }
>         }
>     }
> 
>     public static Object getFieldValue(ReflectorField refField) {
>         try {
>             Field field = refField.getTargetField();
>             if (field == null) {
>                 return null;
>             }
>             Object value = field.get(null);
>             return value;
>         }
>         catch (Throwable e) {
>             e.printStackTrace();
>             return null;
>         }
>     }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/renderer/vertex/VertexBuffer.java ../optifine_patch/src/main/java/net/minecraft/client/renderer/vertex/VertexBuffer.java
9a10,11
>  *  net.optifine.render.VboRange
>  *  net.optifine.render.VboRegion
16a19,20
> import net.optifine.render.VboRange;
> import net.optifine.render.VboRegion;
21a26,28
>     private VboRegion vboRegion;
>     private VboRange vboRange;
>     private int drawMode;
23,24c30,31
<     public VertexBuffer(VertexFormat vertexFormat) {
<         this.vertexFormat = vertexFormat;
---
>     public VertexBuffer(VertexFormat vertexFormatIn) {
>         this.vertexFormat = vertexFormatIn;
32c39,43
<     public void bufferData(ByteBuffer byteBuffer) {
---
>     public void bufferData(ByteBuffer data) {
>         if (this.vboRegion != null) {
>             this.vboRegion.bufferData(data, this.vboRange);
>             return;
>         }
34c45
<         OpenGlHelper.glBufferData((int)OpenGlHelper.GL_ARRAY_BUFFER, (ByteBuffer)byteBuffer, (int)35044);
---
>         OpenGlHelper.glBufferData((int)OpenGlHelper.GL_ARRAY_BUFFER, (ByteBuffer)data, (int)35044);
36c47
<         this.count = byteBuffer.limit() / this.vertexFormat.getSize();
---
>         this.count = data.limit() / this.vertexFormat.getSize();
39,40c50,58
<     public void drawArrays(int n) {
<         GlStateManager.glDrawArrays((int)n, (int)0, (int)this.count);
---
>     public void drawArrays(int mode) {
>         if (this.drawMode > 0) {
>             mode = this.drawMode;
>         }
>         if (this.vboRegion != null) {
>             this.vboRegion.drawArrays(mode, this.vboRange);
>         } else {
>             GlStateManager.glDrawArrays((int)mode, (int)0, (int)this.count);
>         }
51a70,94
>     }
> 
>     public void setVboRegion(VboRegion vboRegion) {
>         if (vboRegion == null) {
>             return;
>         }
>         this.deleteGlBuffers();
>         this.vboRegion = vboRegion;
>         this.vboRange = new VboRange();
>     }
> 
>     public VboRegion getVboRegion() {
>         return this.vboRegion;
>     }
> 
>     public VboRange getVboRange() {
>         return this.vboRange;
>     }
> 
>     public int getDrawMode() {
>         return this.drawMode;
>     }
> 
>     public void setDrawMode(int drawMode) {
>         this.drawMode = drawMode;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/resources/AbstractResourcePack.java ../optifine_patch/src/main/java/net/minecraft/client/resources/AbstractResourcePack.java
54c54
<     protected final File resourcePackFile;
---
>     public final File resourcePackFile;
56,57c56,57
<     public AbstractResourcePack(File file) {
<         this.resourcePackFile = file;
---
>     public AbstractResourcePack(File resourcePackFileIn) {
>         this.resourcePackFile = resourcePackFileIn;
60,61c60,61
<     private static String locationToName(ResourceLocation resourceLocation) {
<         return String.format((String)"%s/%s/%s", (Object[])new Object[]{"assets", resourceLocation.getNamespace(), resourceLocation.getPath()});
---
>     private static String locationToName(ResourceLocation location) {
>         return String.format((String)"%s/%s/%s", (Object[])new Object[]{"assets", location.getNamespace(), location.getPath()});
64,65c64,65
<     protected static String getRelativeName(File file, File file2) {
<         return file.toURI().relativize(file2.toURI()).getPath();
---
>     protected static String getRelativeName(File p_110595_0_, File p_110595_1_) {
>         return p_110595_0_.toURI().relativize(p_110595_1_.toURI()).getPath();
68,69c68,69
<     public InputStream getInputStream(ResourceLocation resourceLocation) throws IOException {
<         return this.getInputStreamByName(AbstractResourcePack.locationToName(resourceLocation));
---
>     public InputStream getInputStream(ResourceLocation location) throws IOException {
>         return this.getInputStreamByName(AbstractResourcePack.locationToName(location));
72,73c72,73
<     public boolean resourceExists(ResourceLocation resourceLocation) {
<         return this.hasResourceName(AbstractResourcePack.locationToName(resourceLocation));
---
>     public boolean resourceExists(ResourceLocation location) {
>         return this.hasResourceName(AbstractResourcePack.locationToName(location));
80,81c80,81
<     protected void logNameNotLowercase(String string) {
<         LOGGER.warn("ResourcePack: ignored non-lowercase namespace: {} in {}", (Object)string, (Object)this.resourcePackFile);
---
>     protected void logNameNotLowercase(String name) {
>         LOGGER.warn("ResourcePack: ignored non-lowercase namespace: {} in {}", (Object)name, (Object)this.resourcePackFile);
84,85c84,85
<     public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String string) throws IOException {
<         return AbstractResourcePack.readMetadata(metadataSerializer, this.getInputStreamByName("pack.mcmeta"), string);
---
>     public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException {
>         return AbstractResourcePack.readMetadata(metadataSerializer, this.getInputStreamByName("pack.mcmeta"), metadataSectionName);
88,90c88,90
<     static <T extends IMetadataSection> T readMetadata(MetadataSerializer metadataSerializer, InputStream inputStream, String string) {
<         JsonObject jsonObject = null;
<         BufferedReader \u26032 = null;
---
>     static <T extends IMetadataSection> T readMetadata(MetadataSerializer metadataSerializer, InputStream p_110596_1_, String sectionName) {
>         JsonObject jsonobject = null;
>         BufferedReader bufferedreader = null;
92,93c92,93
<             \u26032 = new BufferedReader((Reader)new InputStreamReader(inputStream, StandardCharsets.UTF_8));
<             jsonObject = new JsonParser().parse((Reader)\u26032).getAsJsonObject();
---
>             bufferedreader = new BufferedReader((Reader)new InputStreamReader(p_110596_1_, StandardCharsets.UTF_8));
>             jsonobject = new JsonParser().parse((Reader)bufferedreader).getAsJsonObject();
95c95
<         catch (RuntimeException \u26033) {
---
>         catch (RuntimeException runtimeexception) {
97c97
<                 throw new JsonParseException((Throwable)\u26033);
---
>                 throw new JsonParseException((Throwable)runtimeexception);
100c100
<                 IOUtils.closeQuietly(\u26032);
---
>                 IOUtils.closeQuietly(bufferedreader);
104,105c104,105
<         IOUtils.closeQuietly((Reader)\u26032);
<         return (T)metadataSerializer.parseMetadataSection(string, jsonObject);
---
>         IOUtils.closeQuietly((Reader)bufferedreader);
>         return (T)metadataSerializer.parseMetadataSection(sectionName, jsonobject);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/resources/DefaultResourcePack.java ../optifine_patch/src/main/java/net/minecraft/client/resources/DefaultResourcePack.java
11a12
>  *  java.lang.CharSequence
25a27,29
>  *  net.minecraft.util.Util
>  *  net.minecraft.util.Util$EnumOS
>  *  net.optifine.reflect.ReflectorForge
46a51,52
> import net.minecraft.util.Util;
> import net.optifine.reflect.ReflectorForge;
51a58
>     private static final boolean ON_WINDOWS = Util.getOSType() == Util.EnumOS.WINDOWS;
53,54c60,61
<     public DefaultResourcePack(ResourceIndex resourceIndex) {
<         this.resourceIndex = resourceIndex;
---
>     public DefaultResourcePack(ResourceIndex resourceIndexIn) {
>         this.resourceIndex = resourceIndexIn;
57,60c64,67
<     public InputStream getInputStream(ResourceLocation resourceLocation) throws IOException {
<         InputStream inputStream = this.getInputStreamAssets(resourceLocation);
<         if (inputStream != null) {
<             return inputStream;
---
>     public InputStream getInputStream(ResourceLocation location) throws IOException {
>         InputStream inputstream = this.getInputStreamAssets(location);
>         if (inputstream != null) {
>             return inputstream;
62,64c69,71
<         \u2603 = this.getResourceStream(resourceLocation);
<         if (\u2603 != null) {
<             return \u2603;
---
>         InputStream inputstream1 = this.getResourceStream(location);
>         if (inputstream1 != null) {
>             return inputstream1;
66c73
<         throw new FileNotFoundException(resourceLocation.getPath());
---
>         throw new FileNotFoundException(location.getPath());
70,72c77,79
<     public InputStream getInputStreamAssets(ResourceLocation resourceLocation) throws FileNotFoundException {
<         File file = this.resourceIndex.getFile(resourceLocation);
<         return file == null || !file.isFile() ? null : new FileInputStream(file);
---
>     public InputStream getInputStreamAssets(ResourceLocation location) throws IOException, FileNotFoundException {
>         File file1 = this.resourceIndex.getFile(location);
>         return file1 != null && file1.isFile() ? new FileInputStream(file1) : null;
76,77c83,88
<     private InputStream getResourceStream(ResourceLocation resourceLocation) {
<         String string = "/assets/" + resourceLocation.getNamespace() + "/" + resourceLocation.getPath();
---
>     private InputStream getResourceStream(ResourceLocation location) {
>         String s = "/assets/" + location.getNamespace() + "/" + location.getPath();
>         InputStream is = ReflectorForge.getOptiFineResourceStream((String)s);
>         if (is != null) {
>             return is;
>         }
79,82c90,91
<             URL uRL = DefaultResourcePack.class.getResource(string);
<             if (uRL != null && FolderResourcePack.validatePath((File)new File(uRL.getFile()), (String)string)) {
<                 return DefaultResourcePack.class.getResourceAsStream(string);
<             }
---
>             URL url = DefaultResourcePack.class.getResource(s);
>             return url != null && this.validatePath(new File(url.getFile()), s) ? DefaultResourcePack.class.getResourceAsStream(s) : null;
84,85c93,94
<         catch (IOException iOException) {
<             return DefaultResourcePack.class.getResourceAsStream(string);
---
>         catch (IOException var4) {
>             return DefaultResourcePack.class.getResourceAsStream(s);
87d95
<         return null;
90,91c98,99
<     public boolean resourceExists(ResourceLocation resourceLocation) {
<         return this.getResourceStream(resourceLocation) != null || this.resourceIndex.isFileExisting(resourceLocation);
---
>     public boolean resourceExists(ResourceLocation location) {
>         return this.getResourceStream(location) != null || this.resourceIndex.isFileExisting(location);
99c107
<     public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String string) throws IOException {
---
>     public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException {
101,102c109,110
<             FileInputStream fileInputStream = new FileInputStream(this.resourceIndex.getPackMcmeta());
<             return (T)AbstractResourcePack.readMetadata((MetadataSerializer)metadataSerializer, (InputStream)fileInputStream, (String)string);
---
>             FileInputStream inputstream = new FileInputStream(this.resourceIndex.getPackMcmeta());
>             return (T)AbstractResourcePack.readMetadata((MetadataSerializer)metadataSerializer, (InputStream)inputstream, (String)metadataSectionName);
104,105c112,113
<         catch (RuntimeException runtimeException) {
<             return null;
---
>         catch (RuntimeException var4) {
>             return (T)((IMetadataSection)null);
107,108c115,116
<         catch (FileNotFoundException fileNotFoundException) {
<             return null;
---
>         catch (FileNotFoundException var5) {
>             return (T)((IMetadataSection)null);
117a126,136
>     }
> 
>     private boolean validatePath(File file, String path) throws IOException {
>         String s = file.getPath();
>         if (s.startsWith("file:")) {
>             if (ON_WINDOWS) {
>                 s = s.replace((CharSequence)"\\", (CharSequence)"/");
>             }
>             return s.endsWith(path);
>         }
>         return FolderResourcePack.validatePath((File)file, (String)path);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/resources/I18n.java ../optifine_patch/src/main/java/net/minecraft/client/resources/I18n.java
6a7
>  *  java.util.Map
10a12
> import java.util.Map;
16,17c18,19
<     static void setLocale(Locale locale) {
<         i18nLocale = locale;
---
>     static void setLocale(Locale i18nLocaleIn) {
>         i18nLocale = i18nLocaleIn;
20,21c22,23
<     public static String format(String string, Object ... objectArray) {
<         return i18nLocale.formatMessage(string, objectArray);
---
>     public static String format(String translateKey, Object ... parameters) {
>         return i18nLocale.formatMessage(translateKey, parameters);
24,25c26,31
<     public static boolean hasKey(String string) {
<         return i18nLocale.hasKey(string);
---
>     public static boolean hasKey(String key) {
>         return i18nLocale.hasKey(key);
>     }
> 
>     public static Map getLocaleProperties() {
>         return I18n.i18nLocale.properties;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/resources/ResourcePackRepository$1.java ../optifine_patch/src/main/java/net/minecraft/client/resources/ResourcePackRepository$1.java
14c14
< class ResourcePackRepository.1
---
> static final class ResourcePackRepository.1
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/resources/ResourcePackRepository.java ../optifine_patch/src/main/java/net/minecraft/client/resources/ResourcePackRepository.java
54,55d53
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
107,108d104
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
118d113
< @SideOnly(value=Side.CLIENT)
132c127
<     private final List<Entry> repositoryEntries = Lists.newArrayList();
---
>     public final List<Entry> repositoryEntries = Lists.newArrayList();
195c190
<             Entry resourcepackrepository$entry = new Entry(this, file1);
---
>             Entry resourcepackrepository$entry = new Entry(this, file1, null);
199c194
<                 list.add((Object)((Entry)this.repositoryEntriesAll.get(i)));
---
>                 list.add(this.repositoryEntriesAll.get(i));
220c215
<             Entry resourcepackrepository$entry = new Entry(this, this.serverResourcePack);
---
>             Entry resourcepackrepository$entry = new Entry(this, this.serverResourcePack, null);
257a253
>             ListenableFuture<Object> listenablefuture;
275,276c271,272
<             Futures.addCallback(this.downloadingPacks, (FutureCallback)new /* Unavailable Anonymous Inner Class!! */, Runnable::run);
<             ListenableFuture<Object> listenableFuture = this.downloadingPacks;
---
>             Futures.addCallback(this.downloadingPacks, (FutureCallback)new /* Unavailable Anonymous Inner Class!! */);
>             ListenableFuture<Object> listenableFuture = listenablefuture = this.downloadingPacks;
325c321
<         Entry resourcepackrepository$entry = new Entry(this, p_190112_1_);
---
>         Entry resourcepackrepository$entry = new Entry(this, p_190112_1_, null);
379a376,391
>     }
> 
>     static /* synthetic */ boolean access$200(ResourcePackRepository x0, String x1, File x2) {
>         return x0.checkHash(x1, x2);
>     }
> 
>     static /* synthetic */ Logger access$300() {
>         return LOGGER;
>     }
> 
>     static /* synthetic */ IResourcePack access$400(ResourcePackRepository x0, File x1) {
>         return x0.getResourcePack(x1);
>     }
> 
>     static /* synthetic */ ResourceLocation access$500() {
>         return UNKNOWN_PACK_TEXTURE;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/settings/GameSettings$1.java ../optifine_patch/src/main/java/net/minecraft/client/settings/GameSettings$1.java
17c17
< class GameSettings.1
---
> static final class GameSettings.1
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/settings/GameSettings$2.java ../optifine_patch/src/main/java/net/minecraft/client/settings/GameSettings$2.java
17c17
<     static final /* synthetic */ int[] field_151477_a;
---
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$client$settings$GameSettings$Options;
20c20
<         field_151477_a = new int[GameSettings.Options.values().length];
---
>         $SwitchMap$net$minecraft$client$settings$GameSettings$Options = new int[GameSettings.Options.values().length];
22c22
<             GameSettings.2.field_151477_a[GameSettings.Options.INVERT_MOUSE.ordinal()] = 1;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.INVERT_MOUSE.ordinal()] = 1;
28c28
<             GameSettings.2.field_151477_a[GameSettings.Options.VIEW_BOBBING.ordinal()] = 2;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.VIEW_BOBBING.ordinal()] = 2;
34c34
<             GameSettings.2.field_151477_a[GameSettings.Options.ANAGLYPH.ordinal()] = 3;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.ANAGLYPH.ordinal()] = 3;
40c40
<             GameSettings.2.field_151477_a[GameSettings.Options.FBO_ENABLE.ordinal()] = 4;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.FBO_ENABLE.ordinal()] = 4;
46c46
<             GameSettings.2.field_151477_a[GameSettings.Options.CHAT_COLOR.ordinal()] = 5;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.CHAT_COLOR.ordinal()] = 5;
52c52
<             GameSettings.2.field_151477_a[GameSettings.Options.CHAT_LINKS.ordinal()] = 6;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.CHAT_LINKS.ordinal()] = 6;
58c58
<             GameSettings.2.field_151477_a[GameSettings.Options.CHAT_LINKS_PROMPT.ordinal()] = 7;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.CHAT_LINKS_PROMPT.ordinal()] = 7;
64c64
<             GameSettings.2.field_151477_a[GameSettings.Options.SNOOPER_ENABLED.ordinal()] = 8;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.SNOOPER_ENABLED.ordinal()] = 8;
70c70
<             GameSettings.2.field_151477_a[GameSettings.Options.USE_FULLSCREEN.ordinal()] = 9;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.USE_FULLSCREEN.ordinal()] = 9;
76c76
<             GameSettings.2.field_151477_a[GameSettings.Options.ENABLE_VSYNC.ordinal()] = 10;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.ENABLE_VSYNC.ordinal()] = 10;
82c82
<             GameSettings.2.field_151477_a[GameSettings.Options.USE_VBO.ordinal()] = 11;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.USE_VBO.ordinal()] = 11;
88c88
<             GameSettings.2.field_151477_a[GameSettings.Options.TOUCHSCREEN.ordinal()] = 12;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.TOUCHSCREEN.ordinal()] = 12;
94c94
<             GameSettings.2.field_151477_a[GameSettings.Options.FORCE_UNICODE_FONT.ordinal()] = 13;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.FORCE_UNICODE_FONT.ordinal()] = 13;
100c100
<             GameSettings.2.field_151477_a[GameSettings.Options.REDUCED_DEBUG_INFO.ordinal()] = 14;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.REDUCED_DEBUG_INFO.ordinal()] = 14;
106c106
<             GameSettings.2.field_151477_a[GameSettings.Options.ENTITY_SHADOWS.ordinal()] = 15;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.ENTITY_SHADOWS.ordinal()] = 15;
112c112
<             GameSettings.2.field_151477_a[GameSettings.Options.SHOW_SUBTITLES.ordinal()] = 16;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.SHOW_SUBTITLES.ordinal()] = 16;
118c118
<             GameSettings.2.field_151477_a[GameSettings.Options.REALMS_NOTIFICATIONS.ordinal()] = 17;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.REALMS_NOTIFICATIONS.ordinal()] = 17;
124c124
<             GameSettings.2.field_151477_a[GameSettings.Options.ENABLE_WEAK_ATTACKS.ordinal()] = 18;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.ENABLE_WEAK_ATTACKS.ordinal()] = 18;
130c130
<             GameSettings.2.field_151477_a[GameSettings.Options.AUTO_JUMP.ordinal()] = 19;
---
>             GameSettings.2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[GameSettings.Options.AUTO_JUMP.ordinal()] = 19;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/settings/GameSettings$Options.java ../optifine_patch/src/main/java/net/minecraft/client/settings/GameSettings$Options.java
4a5
>  *  Config
9,10d9
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
15,16d13
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
18d14
< @SideOnly(value=Side.CLIENT)
28c24
<     FRAMERATE_LIMIT("options.framerateLimit", true, false, 10.0f, 260.0f, 10.0f),
---
>     FRAMERATE_LIMIT("options.framerateLimit", true, false, 0.0f, 260.0f, 5.0f),
59c55,127
<     NARRATOR("options.narrator", false, false);
---
>     NARRATOR("options.narrator", false, false),
>     FOG_FANCY("of.options.FOG_FANCY", false, false),
>     FOG_START("of.options.FOG_START", false, false),
>     MIPMAP_TYPE("of.options.MIPMAP_TYPE", true, false, 0.0f, 3.0f, 1.0f),
>     SMOOTH_FPS("of.options.SMOOTH_FPS", false, false),
>     CLOUDS("of.options.CLOUDS", false, false),
>     CLOUD_HEIGHT("of.options.CLOUD_HEIGHT", true, false),
>     TREES("of.options.TREES", false, false),
>     RAIN("of.options.RAIN", false, false),
>     ANIMATED_WATER("of.options.ANIMATED_WATER", false, false),
>     ANIMATED_LAVA("of.options.ANIMATED_LAVA", false, false),
>     ANIMATED_FIRE("of.options.ANIMATED_FIRE", false, false),
>     ANIMATED_PORTAL("of.options.ANIMATED_PORTAL", false, false),
>     AO_LEVEL("of.options.AO_LEVEL", true, false),
>     LAGOMETER("of.options.LAGOMETER", false, false),
>     SHOW_FPS("of.options.SHOW_FPS", false, false),
>     AUTOSAVE_TICKS("of.options.AUTOSAVE_TICKS", false, false),
>     BETTER_GRASS("of.options.BETTER_GRASS", false, false),
>     ANIMATED_REDSTONE("of.options.ANIMATED_REDSTONE", false, false),
>     ANIMATED_EXPLOSION("of.options.ANIMATED_EXPLOSION", false, false),
>     ANIMATED_FLAME("of.options.ANIMATED_FLAME", false, false),
>     ANIMATED_SMOKE("of.options.ANIMATED_SMOKE", false, false),
>     WEATHER("of.options.WEATHER", false, false),
>     SKY("of.options.SKY", false, false),
>     STARS("of.options.STARS", false, false),
>     SUN_MOON("of.options.SUN_MOON", false, false),
>     VIGNETTE("of.options.VIGNETTE", false, false),
>     CHUNK_UPDATES("of.options.CHUNK_UPDATES", false, false),
>     CHUNK_UPDATES_DYNAMIC("of.options.CHUNK_UPDATES_DYNAMIC", false, false),
>     TIME("of.options.TIME", false, false),
>     CLEAR_WATER("of.options.CLEAR_WATER", false, false),
>     SMOOTH_WORLD("of.options.SMOOTH_WORLD", false, false),
>     VOID_PARTICLES("of.options.VOID_PARTICLES", false, false),
>     WATER_PARTICLES("of.options.WATER_PARTICLES", false, false),
>     RAIN_SPLASH("of.options.RAIN_SPLASH", false, false),
>     PORTAL_PARTICLES("of.options.PORTAL_PARTICLES", false, false),
>     POTION_PARTICLES("of.options.POTION_PARTICLES", false, false),
>     FIREWORK_PARTICLES("of.options.FIREWORK_PARTICLES", false, false),
>     PROFILER("of.options.PROFILER", false, false),
>     DRIPPING_WATER_LAVA("of.options.DRIPPING_WATER_LAVA", false, false),
>     BETTER_SNOW("of.options.BETTER_SNOW", false, false),
>     FULLSCREEN_MODE("of.options.FULLSCREEN_MODE", true, false, 0.0f, Config.getDisplayModes().length, 1.0f),
>     ANIMATED_TERRAIN("of.options.ANIMATED_TERRAIN", false, false),
>     SWAMP_COLORS("of.options.SWAMP_COLORS", false, false),
>     RANDOM_ENTITIES("of.options.RANDOM_ENTITIES", false, false),
>     SMOOTH_BIOMES("of.options.SMOOTH_BIOMES", false, false),
>     CUSTOM_FONTS("of.options.CUSTOM_FONTS", false, false),
>     CUSTOM_COLORS("of.options.CUSTOM_COLORS", false, false),
>     SHOW_CAPES("of.options.SHOW_CAPES", false, false),
>     CONNECTED_TEXTURES("of.options.CONNECTED_TEXTURES", false, false),
>     CUSTOM_ITEMS("of.options.CUSTOM_ITEMS", false, false),
>     AA_LEVEL("of.options.AA_LEVEL", true, false, 0.0f, 16.0f, 1.0f),
>     AF_LEVEL("of.options.AF_LEVEL", true, false, 1.0f, 16.0f, 1.0f),
>     ANIMATED_TEXTURES("of.options.ANIMATED_TEXTURES", false, false),
>     NATURAL_TEXTURES("of.options.NATURAL_TEXTURES", false, false),
>     EMISSIVE_TEXTURES("of.options.EMISSIVE_TEXTURES", false, false),
>     HELD_ITEM_TOOLTIPS("of.options.HELD_ITEM_TOOLTIPS", false, false),
>     DROPPED_ITEMS("of.options.DROPPED_ITEMS", false, false),
>     LAZY_CHUNK_LOADING("of.options.LAZY_CHUNK_LOADING", false, false),
>     CUSTOM_SKY("of.options.CUSTOM_SKY", false, false),
>     FAST_MATH("of.options.FAST_MATH", false, false),
>     FAST_RENDER("of.options.FAST_RENDER", false, false),
>     TRANSLUCENT_BLOCKS("of.options.TRANSLUCENT_BLOCKS", false, false),
>     DYNAMIC_FOV("of.options.DYNAMIC_FOV", false, false),
>     DYNAMIC_LIGHTS("of.options.DYNAMIC_LIGHTS", false, false),
>     ALTERNATE_BLOCKS("of.options.ALTERNATE_BLOCKS", false, false),
>     CUSTOM_ENTITY_MODELS("of.options.CUSTOM_ENTITY_MODELS", false, false),
>     ADVANCED_TOOLTIPS("of.options.ADVANCED_TOOLTIPS", false, false),
>     SCREENSHOT_SIZE("of.options.SCREENSHOT_SIZE", false, false),
>     CUSTOM_GUIS("of.options.CUSTOM_GUIS", false, false),
>     RENDER_REGIONS("of.options.RENDER_REGIONS", false, false),
>     SHOW_GL_ERRORS("of.options.SHOW_GL_ERRORS", false, false),
>     SMART_ANIMATIONS("of.options.SMART_ANIMATIONS", false, false);
76,77c144,145
<     private GameSettings.Options(String translation, boolean isFloat, boolean isBoolean) {
<         this(translation, isFloat, isBoolean, 0.0f, 1.0f, 0.0f);
---
>     private GameSettings.Options(String str, boolean isFloat, boolean isBoolean) {
>         this(str, isFloat, isBoolean, 0.0f, 1.0f, 0.0f);
80,81c148,149
<     private GameSettings.Options(String translation, boolean isFloat, boolean isBoolean, float valMin, float valMax, float valStep) {
<         this.translation = translation;
---
>     private GameSettings.Options(String str, boolean isFloat, boolean isBoolean, float valMin, float valMax, float valStep) {
>         this.translation = str;
134a203,210
>     }
> 
>     static /* synthetic */ float access$000(GameSettings.Options x0) {
>         return x0.valueMax;
>     }
> 
>     static /* synthetic */ float access$100(GameSettings.Options x0) {
>         return x0.valueMin;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/client/settings/GameSettings.java ../optifine_patch/src/main/java/net/minecraft/client/settings/GameSettings.java
4a5
>  *  Config
10a12
>  *  java.io.BufferedReader
14a17
>  *  java.io.InputStreamReader
17a21
>  *  java.io.Reader
18a23
>  *  java.lang.Boolean
23a29
>  *  java.lang.Math
31a38
>  *  java.util.Arrays
37a45
>  *  net.minecraft.client.gui.GuiScreen
38a47,48
>  *  net.minecraft.client.renderer.OpenGlHelper
>  *  net.minecraft.client.renderer.RenderGlobal
40a51
>  *  net.minecraft.client.settings.GameSettings$2
55a67
>  *  net.minecraft.world.World
57,63c69,81
<  *  net.minecraftforge.client.resource.VanillaResourceType
<  *  net.minecraftforge.client.settings.IKeyConflictContext
<  *  net.minecraftforge.client.settings.KeyConflictContext
<  *  net.minecraftforge.client.settings.KeyModifier
<  *  net.minecraftforge.fml.client.FMLClientHandler
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.ClearWater
>  *  net.optifine.CustomColors
>  *  net.optifine.CustomGuis
>  *  net.optifine.CustomSky
>  *  net.optifine.DynamicLights
>  *  net.optifine.Lang
>  *  net.optifine.NaturalTextures
>  *  net.optifine.RandomEntities
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorMethod
>  *  net.optifine.shaders.Shaders
>  *  net.optifine.util.KeyUtils
70a89
>  *  org.lwjgl.opengl.DisplayMode
79a99
> import java.io.BufferedReader;
83a104
> import java.io.InputStreamReader;
86a108
> import java.io.Reader;
90a113
> import java.util.Arrays;
96a120
> import net.minecraft.client.gui.GuiScreen;
97a122,123
> import net.minecraft.client.renderer.OpenGlHelper;
> import net.minecraft.client.renderer.RenderGlobal;
114a141
> import net.minecraft.world.World;
116,122c143,155
< import net.minecraftforge.client.resource.VanillaResourceType;
< import net.minecraftforge.client.settings.IKeyConflictContext;
< import net.minecraftforge.client.settings.KeyConflictContext;
< import net.minecraftforge.client.settings.KeyModifier;
< import net.minecraftforge.fml.client.FMLClientHandler;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.ClearWater;
> import net.optifine.CustomColors;
> import net.optifine.CustomGuis;
> import net.optifine.CustomSky;
> import net.optifine.DynamicLights;
> import net.optifine.Lang;
> import net.optifine.NaturalTextures;
> import net.optifine.RandomEntities;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorMethod;
> import net.optifine.shaders.Shaders;
> import net.optifine.util.KeyUtils;
129a163
> import org.lwjgl.opengl.DisplayMode;
131c165,167
< @SideOnly(value=Side.CLIENT)
---
> /*
>  * Exception performing whole class analysis ignored.
>  */
233c269,354
<     private boolean needsBlockModelRefresh = false;
---
>     public int ofFogType = 1;
>     public float ofFogStart = 0.8f;
>     public int ofMipmapType = 0;
>     public boolean ofOcclusionFancy = false;
>     public boolean ofSmoothFps = false;
>     public boolean ofSmoothWorld = Config.isSingleProcessor();
>     public boolean ofLazyChunkLoading = Config.isSingleProcessor();
>     public boolean ofRenderRegions = false;
>     public boolean ofSmartAnimations = false;
>     public float ofAoLevel = 1.0f;
>     public int ofAaLevel = 0;
>     public int ofAfLevel = 1;
>     public int ofClouds = 0;
>     public float ofCloudsHeight = 0.0f;
>     public int ofTrees = 0;
>     public int ofRain = 0;
>     public int ofDroppedItems = 0;
>     public int ofBetterGrass = 3;
>     public int ofAutoSaveTicks = 4000;
>     public boolean ofLagometer = false;
>     public boolean ofProfiler = false;
>     public boolean ofShowFps = false;
>     public boolean ofWeather = true;
>     public boolean ofSky = true;
>     public boolean ofStars = true;
>     public boolean ofSunMoon = true;
>     public int ofVignette = 0;
>     public int ofChunkUpdates = 1;
>     public boolean ofChunkUpdatesDynamic = false;
>     public int ofTime = 0;
>     public boolean ofClearWater = false;
>     public boolean ofBetterSnow = false;
>     public String ofFullscreenMode = "Default";
>     public boolean ofSwampColors = true;
>     public boolean ofRandomEntities = true;
>     public boolean ofSmoothBiomes = true;
>     public boolean ofCustomFonts = true;
>     public boolean ofCustomColors = true;
>     public boolean ofCustomSky = true;
>     public boolean ofShowCapes = true;
>     public int ofConnectedTextures = 2;
>     public boolean ofCustomItems = true;
>     public boolean ofNaturalTextures = false;
>     public boolean ofEmissiveTextures = true;
>     public boolean ofFastMath = false;
>     public boolean ofFastRender = false;
>     public int ofTranslucentBlocks = 0;
>     public boolean ofDynamicFov = true;
>     public boolean ofAlternateBlocks = true;
>     public int ofDynamicLights = 3;
>     public boolean ofCustomEntityModels = true;
>     public boolean ofCustomGuis = true;
>     public boolean ofShowGlErrors = true;
>     public int ofScreenshotSize = 1;
>     public int ofAnimatedWater = 0;
>     public int ofAnimatedLava = 0;
>     public boolean ofAnimatedFire = true;
>     public boolean ofAnimatedPortal = true;
>     public boolean ofAnimatedRedstone = true;
>     public boolean ofAnimatedExplosion = true;
>     public boolean ofAnimatedFlame = true;
>     public boolean ofAnimatedSmoke = true;
>     public boolean ofVoidParticles = true;
>     public boolean ofWaterParticles = true;
>     public boolean ofRainSplash = true;
>     public boolean ofPortalParticles = true;
>     public boolean ofPotionParticles = true;
>     public boolean ofFireworkParticles = true;
>     public boolean ofDrippingWaterLava = true;
>     public boolean ofAnimatedTerrain = true;
>     public boolean ofAnimatedTextures = true;
>     public static final int DEFAULT = 0;
>     public static final int FAST = 1;
>     public static final int FANCY = 2;
>     public static final int OFF = 3;
>     public static final int SMART = 4;
>     public static final int ANIM_ON = 0;
>     public static final int ANIM_GENERATED = 1;
>     public static final int ANIM_OFF = 2;
>     public static final String DEFAULT_STR = "Default";
>     private static final int[] OF_TREES_VALUES = new int[]{0, 1, 4, 2};
>     private static final int[] OF_DYNAMIC_LIGHTS = new int[]{3, 1, 2};
>     private static final String[] KEYS_DYNAMIC_LIGHTS = new String[]{"options.off", "options.graphics.fast", "options.graphics.fancy"};
>     public KeyBinding ofKeyBindZoom;
>     private File optionsFileOF;
>     private boolean needsResourceRefresh = false;
235c356
<     public GameSettings(Minecraft mcIn, File mcDataDir) {
---
>     public GameSettings(Minecraft mcIn, File optionsFileIn) {
243c364
<         this.optionsFile = new File(mcDataDir, "options.txt");
---
>         this.optionsFile = new File(optionsFileIn, "options.txt");
245a367,373
>             long MB = 1000000L;
>             if (Runtime.getRuntime().maxMemory() >= 1500L * MB) {
>                 Options.RENDER_DISTANCE.setValueMax(48.0f);
>             }
>             if (Runtime.getRuntime().maxMemory() >= 2500L * MB) {
>                 Options.RENDER_DISTANCE.setValueMax(64.0f);
>             }
249a378,383
>         this.optionsFileOF = new File(optionsFileIn, "optionsof.txt");
>         this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>         this.ofKeyBindZoom = new KeyBinding("of.key.zoom", 46, "key.categories.misc");
>         this.keyBindings = (KeyBinding[])ArrayUtils.add((Object[])this.keyBindings, (Object)this.ofKeyBindZoom);
>         KeyUtils.fixKeyConflicts((KeyBinding[])this.keyBindings, (KeyBinding[])new KeyBinding[]{this.ofKeyBindZoom});
>         this.renderDistanceChunks = 8;
250a385
>         Config.initGameSettings((GameSettings)this);
293a429
>         this.setOptionFloatValueOF(settingsOption, value);
304a441,446
>             this.enableVsync = false;
>             if (this.limitFramerate <= 0) {
>                 this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>                 this.enableVsync = true;
>             }
>             this.updateVSync();
333c475
<                 this.needsBlockModelRefresh = true;
---
>                 this.mc.scheduleResourcesRefresh();
342a485
>         this.setOptionValueOF(settingsOption, value);
353c496,512
<             this.guiScale = this.guiScale + value & 3;
---
>             this.guiScale += value;
>             if (GuiScreen.isShiftKeyDown()) {
>                 this.guiScale = 0;
>             }
>             DisplayMode mode = Config.getLargestDisplayMode();
>             int maxScaleWidth = mode.getWidth() / 320;
>             int maxScaleHeight = mode.getHeight() / 240;
>             int maxGuiScale = Math.min((int)maxScaleWidth, (int)maxScaleHeight);
>             if (this.guiScale < 0) {
>                 this.guiScale = maxGuiScale - 1;
>             }
>             if (this.mc.isUnicode() && this.guiScale % 2 != 0) {
>                 this.guiScale += value;
>             }
>             if (this.guiScale < 0 || this.guiScale >= maxGuiScale) {
>                 this.guiScale = 0;
>             }
371a531,534
>             if (!this.anaglyph && Config.isShaders()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.an.shaders1"), (String)Lang.get((String)"of.message.an.shaders2"));
>                 return;
>             }
373c536,541
<             FMLClientHandler.instance().refreshResources(new IResourceType[]{VanillaResourceType.TEXTURES});
---
>             this.mc.refreshResources();
>             if (Reflector.FMLClientHandler_refreshResources.exists()) {
>                 Object instance = Reflector.call((ReflectorMethod)Reflector.FMLClientHandler_instance, (Object[])new Object[0]);
>                 IResourceType type = (IResourceType)Reflector.VanillaResourceType_TEXTURES.getValue();
>                 Reflector.call((Object)instance, (ReflectorMethod)Reflector.FMLClientHandler_refreshResources, (Object[])new IResourceType[]{type});
>             }
376a545
>             this.updateRenderClouds();
440a610,613
>         float valOF = this.getOptionFloatValueOF(settingOption);
>         if (valOF != Float.MAX_VALUE) {
>             return valOF;
>         }
478,479c651,652
<         switch (settingOption.ordinal()) {
<             case 0: {
---
>         switch (2.$SwitchMap$net$minecraft$client$settings$GameSettings$Options[settingOption.ordinal()]) {
>             case 1: {
482c655
<             case 6: {
---
>             case 2: {
485c658
<             case 7: {
---
>             case 3: {
488c661
<             case 9: {
---
>             case 4: {
491c664
<             case 16: {
---
>             case 5: {
494c667
<             case 17: {
---
>             case 6: {
497c670
<             case 19: {
---
>             case 7: {
500c673
<             case 20: {
---
>             case 8: {
503c676
<             case 21: {
---
>             case 9: {
506c679
<             case 22: {
---
>             case 10: {
509c682
<             case 23: {
---
>             case 11: {
512c685
<             case 24: {
---
>             case 12: {
515c688
<             case 30: {
---
>             case 13: {
518c691
<             case 31: {
---
>             case 14: {
521c694
<             case 32: {
---
>             case 15: {
524c697
<             case 36: {
---
>             case 16: {
527c700
<             case 37: {
---
>             case 17: {
530c703
<             case 35: {
---
>             case 18: {
533c706
<             case 38: {
---
>             case 19: {
547a721,724
>         String strOF = this.getKeyBindingOF(settingOption);
>         if (strOF != null) {
>             return strOF;
>         }
565c742
<                 return f1 == settingOption.valueMax ? s + I18n.format((String)"options.framerateLimit.max", (Object[])new Object[0]) : s + I18n.format((String)"options.framerate", (Object[])new Object[]{(int)f1});
---
>                 return f1 == Options.access$000((Options)settingOption) ? s + I18n.format((String)"options.framerateLimit.max", (Object[])new Object[0]) : s + I18n.format((String)"options.framerate", (Object[])new Object[]{(int)f1});
568c745
<                 return f1 == settingOption.valueMin ? s + I18n.format((String)"options.cloudHeight.min", (Object[])new Object[0]) : s + ((int)f1 + 128);
---
>                 return f1 == Options.access$100((Options)settingOption) ? s + I18n.format((String)"options.cloudHeight.min", (Object[])new Object[0]) : s + ((int)f1 + 128);
594a772,774
>                 if ((double)f1 >= 4.0) {
>                     return s + Lang.get((String)"of.general.max");
>                 }
604c784
<             return s + String.valueOf((Object)this.mainHand);
---
>             return s + this.mainHand;
606a787,789
>             if (this.guiScale >= GUISCALES.length) {
>                 return s + this.guiScale + "x";
>             }
641c824
<         FileInputStream fileInputStream = null;
---
>         FileInputStream is = null;
647,648c830,831
<             fileInputStream = new FileInputStream(this.optionsFile);
<             List list = IOUtils.readLines((InputStream)fileInputStream, (Charset)StandardCharsets.UTF_8);
---
>             is = new FileInputStream(this.optionsFile);
>             List list = IOUtils.readLines((InputStream)is, (Charset)StandardCharsets.UTF_8);
694a878,883
>                         if (this.enableVsync) {
>                             this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>                         }
>                         if (this.limitFramerate <= 0) {
>                             this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>                         }
703a893
>                         this.updateRenderClouds();
769a960,963
>                         if (this.enableVsync) {
>                             this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>                         }
>                         this.updateVSync();
842,844c1036,1044
<                         if (s2.indexOf(58) != -1) {
<                             String[] t = s2.split(":");
<                             keyBinding.setKeyModifierAndCode(KeyModifier.valueFromString((String)t[1]), Integer.parseInt((String)t[0]));
---
>                         if (Reflector.KeyModifier_valueFromString.exists()) {
>                             if (s2.indexOf(58) != -1) {
>                                 String[] t = s2.split(":");
>                                 Object keyModifier = Reflector.call((ReflectorMethod)Reflector.KeyModifier_valueFromString, (Object[])new Object[]{t[1]});
>                                 Reflector.call((Object)keyBinding, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyModifierAndCode, (Object[])new Object[]{keyModifier, Integer.parseInt((String)t[0])});
>                                 continue;
>                             }
>                             Object keyModifierNone = Reflector.getFieldValue((ReflectorField)Reflector.KeyModifier_NONE);
>                             Reflector.call((Object)keyBinding, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyModifierAndCode, (Object[])new Object[]{keyModifierNone, Integer.parseInt((String)s2)});
847c1047
<                         keyBinding.setKeyModifierAndCode(KeyModifier.NONE, Integer.parseInt((String)s2));
---
>                         keyBinding.setKeyCode(Integer.parseInt((String)s2));
859a1060
>                     var11.printStackTrace();
863c1064
<             IOUtils.closeQuietly((InputStream)fileInputStream);
---
>             IOUtils.closeQuietly((InputStream)is);
869c1070
<             IOUtils.closeQuietly(fileInputStream);
---
>             IOUtils.closeQuietly(is);
870a1072
>         this.loadOfOptions();
895c1097,1098
<         if (FMLClientHandler.instance().isLoading()) {
---
>         Object fml;
>         if (Reflector.FMLClientHandler.exists() && (fml = Reflector.call((ReflectorMethod)Reflector.FMLClientHandler_instance, (Object[])new Object[0])) != null && Reflector.callBoolean((Object)fml, (ReflectorMethod)Reflector.FMLClientHandler_isLoading, (Object[])new Object[0])) {
968,969c1171,1178
<                 String keyString = "key_" + keyBinding.getKeyDescription() + ":" + keyBinding.getKeyCode();
<                 printwriter.println(keyBinding.getKeyModifier() != KeyModifier.NONE ? keyString + ":" + String.valueOf((Object)keyBinding.getKeyModifier()) : keyString);
---
>                 if (Reflector.ForgeKeyBinding_getKeyModifier.exists()) {
>                     Object keyModifierNone;
>                     String keyString = "key_" + keyBinding.getKeyDescription() + ":" + keyBinding.getKeyCode();
>                     Object keyModifier = Reflector.call((Object)keyBinding, (ReflectorMethod)Reflector.ForgeKeyBinding_getKeyModifier, (Object[])new Object[0]);
>                     printwriter.println(keyModifier != (keyModifierNone = Reflector.getFieldValue((ReflectorField)Reflector.KeyModifier_NONE)) ? keyString + ":" + keyModifier : keyString);
>                     continue;
>                 }
>                 printwriter.println("key_" + keyBinding.getKeyDescription() + ":" + keyBinding.getKeyCode());
984a1194
>         this.saveOfOptions();
1036a1247,2746
>     private void setOptionFloatValueOF(Options option, float val) {
>         int valInt;
>         if (option == Options.CLOUD_HEIGHT) {
>             this.ofCloudsHeight = val;
>             this.mc.renderGlobal.resetClouds();
>         }
>         if (option == Options.AO_LEVEL) {
>             this.ofAoLevel = val;
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (option == Options.AA_LEVEL) {
>             valInt = (int)val;
>             if (valInt > 0 && Config.isShaders()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.aa.shaders1"), (String)Lang.get((String)"of.message.aa.shaders2"));
>                 return;
>             }
>             int[] aaLevels = new int[]{0, 2, 4, 6, 8, 12, 16};
>             this.ofAaLevel = 0;
>             for (int l = 0; l < aaLevels.length; ++l) {
>                 if (valInt < aaLevels[l]) continue;
>                 this.ofAaLevel = aaLevels[l];
>             }
>             this.ofAaLevel = Config.limit((int)this.ofAaLevel, (int)0, (int)16);
>         }
>         if (option == Options.AF_LEVEL) {
>             valInt = (int)val;
>             if (valInt > 1 && Config.isShaders()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.af.shaders1"), (String)Lang.get((String)"of.message.af.shaders2"));
>                 return;
>             }
>             this.ofAfLevel = 1;
>             while (this.ofAfLevel * 2 <= valInt) {
>                 this.ofAfLevel *= 2;
>             }
>             this.ofAfLevel = Config.limit((int)this.ofAfLevel, (int)1, (int)16);
>             this.mc.refreshResources();
>         }
>         if (option == Options.MIPMAP_TYPE) {
>             valInt = (int)val;
>             this.ofMipmapType = Config.limit((int)valInt, (int)0, (int)3);
>             this.mc.refreshResources();
>         }
>         if (option == Options.FULLSCREEN_MODE) {
>             int index = (int)val - 1;
>             String[] modeNames = Config.getDisplayModeNames();
>             if (index < 0 || index >= modeNames.length) {
>                 this.ofFullscreenMode = "Default";
>                 return;
>             }
>             this.ofFullscreenMode = modeNames[index];
>         }
>     }
> 
>     private float getOptionFloatValueOF(Options settingOption) {
>         if (settingOption == Options.CLOUD_HEIGHT) {
>             return this.ofCloudsHeight;
>         }
>         if (settingOption == Options.AO_LEVEL) {
>             return this.ofAoLevel;
>         }
>         if (settingOption == Options.AA_LEVEL) {
>             return this.ofAaLevel;
>         }
>         if (settingOption == Options.AF_LEVEL) {
>             return this.ofAfLevel;
>         }
>         if (settingOption == Options.MIPMAP_TYPE) {
>             return this.ofMipmapType;
>         }
>         if (settingOption == Options.FRAMERATE_LIMIT) {
>             if ((float)this.limitFramerate == Options.FRAMERATE_LIMIT.getValueMax() && this.enableVsync) {
>                 return 0.0f;
>             }
>             return this.limitFramerate;
>         }
>         if (settingOption == Options.FULLSCREEN_MODE) {
>             if (this.ofFullscreenMode.equals((Object)"Default")) {
>                 return 0.0f;
>             }
>             List modeList = Arrays.asList((Object[])Config.getDisplayModeNames());
>             int index = modeList.indexOf((Object)this.ofFullscreenMode);
>             if (index < 0) {
>                 return 0.0f;
>             }
>             return index + 1;
>         }
>         return Float.MAX_VALUE;
>     }
> 
>     private void setOptionValueOF(Options par1EnumOptions, int par2) {
>         if (par1EnumOptions == Options.FOG_FANCY) {
>             switch (this.ofFogType) {
>                 case 1: {
>                     this.ofFogType = 2;
>                     if (Config.isFancyFogAvailable()) break;
>                     this.ofFogType = 3;
>                     break;
>                 }
>                 case 2: {
>                     this.ofFogType = 3;
>                     break;
>                 }
>                 case 3: {
>                     this.ofFogType = 1;
>                     break;
>                 }
>                 default: {
>                     this.ofFogType = 1;
>                 }
>             }
>         }
>         if (par1EnumOptions == Options.FOG_START) {
>             this.ofFogStart += 0.2f;
>             if (this.ofFogStart > 0.81f) {
>                 this.ofFogStart = 0.2f;
>             }
>         }
>         if (par1EnumOptions == Options.SMOOTH_FPS) {
>             boolean bl = this.ofSmoothFps = !this.ofSmoothFps;
>         }
>         if (par1EnumOptions == Options.SMOOTH_WORLD) {
>             this.ofSmoothWorld = !this.ofSmoothWorld;
>             Config.updateThreadPriorities();
>         }
>         if (par1EnumOptions == Options.CLOUDS) {
>             ++this.ofClouds;
>             if (this.ofClouds > 3) {
>                 this.ofClouds = 0;
>             }
>             this.updateRenderClouds();
>             this.mc.renderGlobal.resetClouds();
>         }
>         if (par1EnumOptions == Options.TREES) {
>             this.ofTrees = GameSettings.nextValue(this.ofTrees, OF_TREES_VALUES);
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.DROPPED_ITEMS) {
>             ++this.ofDroppedItems;
>             if (this.ofDroppedItems > 2) {
>                 this.ofDroppedItems = 0;
>             }
>         }
>         if (par1EnumOptions == Options.RAIN) {
>             ++this.ofRain;
>             if (this.ofRain > 3) {
>                 this.ofRain = 0;
>             }
>         }
>         if (par1EnumOptions == Options.ANIMATED_WATER) {
>             ++this.ofAnimatedWater;
>             if (this.ofAnimatedWater == 1) {
>                 ++this.ofAnimatedWater;
>             }
>             if (this.ofAnimatedWater > 2) {
>                 this.ofAnimatedWater = 0;
>             }
>         }
>         if (par1EnumOptions == Options.ANIMATED_LAVA) {
>             ++this.ofAnimatedLava;
>             if (this.ofAnimatedLava == 1) {
>                 ++this.ofAnimatedLava;
>             }
>             if (this.ofAnimatedLava > 2) {
>                 this.ofAnimatedLava = 0;
>             }
>         }
>         if (par1EnumOptions == Options.ANIMATED_FIRE) {
>             boolean bl = this.ofAnimatedFire = !this.ofAnimatedFire;
>         }
>         if (par1EnumOptions == Options.ANIMATED_PORTAL) {
>             boolean bl = this.ofAnimatedPortal = !this.ofAnimatedPortal;
>         }
>         if (par1EnumOptions == Options.ANIMATED_REDSTONE) {
>             boolean bl = this.ofAnimatedRedstone = !this.ofAnimatedRedstone;
>         }
>         if (par1EnumOptions == Options.ANIMATED_EXPLOSION) {
>             boolean bl = this.ofAnimatedExplosion = !this.ofAnimatedExplosion;
>         }
>         if (par1EnumOptions == Options.ANIMATED_FLAME) {
>             boolean bl = this.ofAnimatedFlame = !this.ofAnimatedFlame;
>         }
>         if (par1EnumOptions == Options.ANIMATED_SMOKE) {
>             boolean bl = this.ofAnimatedSmoke = !this.ofAnimatedSmoke;
>         }
>         if (par1EnumOptions == Options.VOID_PARTICLES) {
>             boolean bl = this.ofVoidParticles = !this.ofVoidParticles;
>         }
>         if (par1EnumOptions == Options.WATER_PARTICLES) {
>             boolean bl = this.ofWaterParticles = !this.ofWaterParticles;
>         }
>         if (par1EnumOptions == Options.PORTAL_PARTICLES) {
>             boolean bl = this.ofPortalParticles = !this.ofPortalParticles;
>         }
>         if (par1EnumOptions == Options.POTION_PARTICLES) {
>             boolean bl = this.ofPotionParticles = !this.ofPotionParticles;
>         }
>         if (par1EnumOptions == Options.FIREWORK_PARTICLES) {
>             boolean bl = this.ofFireworkParticles = !this.ofFireworkParticles;
>         }
>         if (par1EnumOptions == Options.DRIPPING_WATER_LAVA) {
>             boolean bl = this.ofDrippingWaterLava = !this.ofDrippingWaterLava;
>         }
>         if (par1EnumOptions == Options.ANIMATED_TERRAIN) {
>             boolean bl = this.ofAnimatedTerrain = !this.ofAnimatedTerrain;
>         }
>         if (par1EnumOptions == Options.ANIMATED_TEXTURES) {
>             boolean bl = this.ofAnimatedTextures = !this.ofAnimatedTextures;
>         }
>         if (par1EnumOptions == Options.RAIN_SPLASH) {
>             boolean bl = this.ofRainSplash = !this.ofRainSplash;
>         }
>         if (par1EnumOptions == Options.LAGOMETER) {
>             boolean bl = this.ofLagometer = !this.ofLagometer;
>         }
>         if (par1EnumOptions == Options.SHOW_FPS) {
>             boolean bl = this.ofShowFps = !this.ofShowFps;
>         }
>         if (par1EnumOptions == Options.AUTOSAVE_TICKS) {
>             int step = 900;
>             this.ofAutoSaveTicks = Math.max((int)(this.ofAutoSaveTicks / step * step), (int)step);
>             this.ofAutoSaveTicks *= 2;
>             if (this.ofAutoSaveTicks > 32 * step) {
>                 this.ofAutoSaveTicks = step;
>             }
>         }
>         if (par1EnumOptions == Options.BETTER_GRASS) {
>             ++this.ofBetterGrass;
>             if (this.ofBetterGrass > 3) {
>                 this.ofBetterGrass = 1;
>             }
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.CONNECTED_TEXTURES) {
>             ++this.ofConnectedTextures;
>             if (this.ofConnectedTextures > 3) {
>                 this.ofConnectedTextures = 1;
>             }
>             if (this.ofConnectedTextures == 2) {
>                 this.mc.renderGlobal.loadRenderers();
>             } else {
>                 this.mc.refreshResources();
>             }
>         }
>         if (par1EnumOptions == Options.WEATHER) {
>             boolean bl = this.ofWeather = !this.ofWeather;
>         }
>         if (par1EnumOptions == Options.SKY) {
>             boolean bl = this.ofSky = !this.ofSky;
>         }
>         if (par1EnumOptions == Options.STARS) {
>             boolean bl = this.ofStars = !this.ofStars;
>         }
>         if (par1EnumOptions == Options.SUN_MOON) {
>             boolean bl = this.ofSunMoon = !this.ofSunMoon;
>         }
>         if (par1EnumOptions == Options.VIGNETTE) {
>             ++this.ofVignette;
>             if (this.ofVignette > 2) {
>                 this.ofVignette = 0;
>             }
>         }
>         if (par1EnumOptions == Options.CHUNK_UPDATES) {
>             ++this.ofChunkUpdates;
>             if (this.ofChunkUpdates > 5) {
>                 this.ofChunkUpdates = 1;
>             }
>         }
>         if (par1EnumOptions == Options.CHUNK_UPDATES_DYNAMIC) {
>             boolean bl = this.ofChunkUpdatesDynamic = !this.ofChunkUpdatesDynamic;
>         }
>         if (par1EnumOptions == Options.TIME) {
>             ++this.ofTime;
>             if (this.ofTime > 2) {
>                 this.ofTime = 0;
>             }
>         }
>         if (par1EnumOptions == Options.CLEAR_WATER) {
>             this.ofClearWater = !this.ofClearWater;
>             this.updateWaterOpacity();
>         }
>         if (par1EnumOptions == Options.PROFILER) {
>             boolean bl = this.ofProfiler = !this.ofProfiler;
>         }
>         if (par1EnumOptions == Options.BETTER_SNOW) {
>             this.ofBetterSnow = !this.ofBetterSnow;
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.SWAMP_COLORS) {
>             this.ofSwampColors = !this.ofSwampColors;
>             CustomColors.updateUseDefaultGrassFoliageColors();
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.RANDOM_ENTITIES) {
>             this.ofRandomEntities = !this.ofRandomEntities;
>             RandomEntities.update();
>         }
>         if (par1EnumOptions == Options.SMOOTH_BIOMES) {
>             this.ofSmoothBiomes = !this.ofSmoothBiomes;
>             CustomColors.updateUseDefaultGrassFoliageColors();
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.CUSTOM_FONTS) {
>             this.ofCustomFonts = !this.ofCustomFonts;
>             this.mc.fontRenderer.onResourceManagerReload(Config.getResourceManager());
>             this.mc.standardGalacticFontRenderer.onResourceManagerReload(Config.getResourceManager());
>         }
>         if (par1EnumOptions == Options.CUSTOM_COLORS) {
>             this.ofCustomColors = !this.ofCustomColors;
>             CustomColors.update();
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.CUSTOM_ITEMS) {
>             this.ofCustomItems = !this.ofCustomItems;
>             this.mc.refreshResources();
>         }
>         if (par1EnumOptions == Options.CUSTOM_SKY) {
>             this.ofCustomSky = !this.ofCustomSky;
>             CustomSky.update();
>         }
>         if (par1EnumOptions == Options.SHOW_CAPES) {
>             boolean bl = this.ofShowCapes = !this.ofShowCapes;
>         }
>         if (par1EnumOptions == Options.NATURAL_TEXTURES) {
>             this.ofNaturalTextures = !this.ofNaturalTextures;
>             NaturalTextures.update();
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.EMISSIVE_TEXTURES) {
>             this.ofEmissiveTextures = !this.ofEmissiveTextures;
>             this.mc.refreshResources();
>         }
>         if (par1EnumOptions == Options.FAST_MATH) {
>             MathHelper.fastMath = this.ofFastMath = !this.ofFastMath;
>         }
>         if (par1EnumOptions == Options.FAST_RENDER) {
>             if (!this.ofFastRender && Config.isShaders()) {
>                 Config.showGuiMessage((String)Lang.get((String)"of.message.mods.Hileb.optirefine.mixinx.fr.shaders1"), (String)Lang.get((String)"of.message.mods.Hileb.optirefine.mixinx.fr.shaders2"));
>                 return;
>             }
>             boolean bl = this.ofFastRender = !this.ofFastRender;
>             if (this.ofFastRender) {
>                 this.mc.entityRenderer.stopUseShader();
>             }
>             Config.updateFramebufferSize();
>         }
>         if (par1EnumOptions == Options.TRANSLUCENT_BLOCKS) {
>             this.ofTranslucentBlocks = this.ofTranslucentBlocks == 0 ? 1 : (this.ofTranslucentBlocks == 1 ? 2 : (this.ofTranslucentBlocks == 2 ? 0 : 0));
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.LAZY_CHUNK_LOADING) {
>             boolean bl = this.ofLazyChunkLoading = !this.ofLazyChunkLoading;
>         }
>         if (par1EnumOptions == Options.RENDER_REGIONS) {
>             this.ofRenderRegions = !this.ofRenderRegions;
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.SMART_ANIMATIONS) {
>             this.ofSmartAnimations = !this.ofSmartAnimations;
>             this.mc.renderGlobal.loadRenderers();
>         }
>         if (par1EnumOptions == Options.DYNAMIC_FOV) {
>             boolean bl = this.ofDynamicFov = !this.ofDynamicFov;
>         }
>         if (par1EnumOptions == Options.ALTERNATE_BLOCKS) {
>             this.ofAlternateBlocks = !this.ofAlternateBlocks;
>             this.mc.refreshResources();
>         }
>         if (par1EnumOptions == Options.DYNAMIC_LIGHTS) {
>             this.ofDynamicLights = GameSettings.nextValue(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
>             DynamicLights.removeLights((RenderGlobal)this.mc.renderGlobal);
>         }
>         if (par1EnumOptions == Options.SCREENSHOT_SIZE) {
>             ++this.ofScreenshotSize;
>             if (this.ofScreenshotSize > 4) {
>                 this.ofScreenshotSize = 1;
>             }
>             if (!OpenGlHelper.isFramebufferEnabled()) {
>                 this.ofScreenshotSize = 1;
>             }
>         }
>         if (par1EnumOptions == Options.CUSTOM_ENTITY_MODELS) {
>             this.ofCustomEntityModels = !this.ofCustomEntityModels;
>             this.mc.refreshResources();
>         }
>         if (par1EnumOptions == Options.CUSTOM_GUIS) {
>             this.ofCustomGuis = !this.ofCustomGuis;
>             CustomGuis.update();
>         }
>         if (par1EnumOptions == Options.SHOW_GL_ERRORS) {
>             boolean bl = this.ofShowGlErrors = !this.ofShowGlErrors;
>         }
>         if (par1EnumOptions == Options.HELD_ITEM_TOOLTIPS) {
>             boolean bl = this.heldItemTooltips = !this.heldItemTooltips;
>         }
>         if (par1EnumOptions == Options.ADVANCED_TOOLTIPS) {
>             this.advancedItemTooltips = !this.advancedItemTooltips;
>         }
>     }
> 
>     private String getKeyBindingOF(Options par1EnumOptions) {
>         String var2 = I18n.format((String)par1EnumOptions.getTranslation(), (Object[])new Object[0]) + ": ";
>         if (var2 == null) {
>             var2 = par1EnumOptions.getTranslation();
>         }
>         String s = var2;
>         if (par1EnumOptions == Options.RENDER_DISTANCE) {
>             int distChunks = (int)this.getOptionFloatValue(par1EnumOptions);
>             String str = I18n.format((String)"of.options.renderDistance.tiny", (Object[])new Object[0]);
>             int baseDist = 2;
>             if (distChunks >= 4) {
>                 str = I18n.format((String)"of.options.renderDistance.short", (Object[])new Object[0]);
>                 baseDist = 4;
>             }
>             if (distChunks >= 8) {
>                 str = I18n.format((String)"of.options.renderDistance.normal", (Object[])new Object[0]);
>                 baseDist = 8;
>             }
>             if (distChunks >= 16) {
>                 str = I18n.format((String)"of.options.renderDistance.far", (Object[])new Object[0]);
>                 baseDist = 16;
>             }
>             if (distChunks >= 32) {
>                 str = Lang.get((String)"of.options.renderDistance.extreme");
>                 baseDist = 32;
>             }
>             if (distChunks >= 48) {
>                 str = Lang.get((String)"of.options.renderDistance.insane");
>                 baseDist = 48;
>             }
>             if (distChunks >= 64) {
>                 str = Lang.get((String)"of.options.renderDistance.ludicrous");
>                 baseDist = 64;
>             }
>             int diff = this.renderDistanceChunks - baseDist;
>             String descr = str;
>             if (diff > 0) {
>                 descr = descr + "+";
>             }
>             return var2 + distChunks + " " + descr + "";
>         }
>         if (par1EnumOptions == Options.FOG_FANCY) {
>             switch (this.ofFogType) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>                 case 3: {
>                     return s + Lang.getOff();
>                 }
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FOG_START) {
>             return s + this.ofFogStart;
>         }
>         if (par1EnumOptions == Options.MIPMAP_TYPE) {
>             switch (this.ofMipmapType) {
>                 case 0: {
>                     return s + Lang.get((String)"of.options.mipmap.nearest");
>                 }
>                 case 1: {
>                     return s + Lang.get((String)"of.options.mipmap.linear");
>                 }
>                 case 2: {
>                     return s + Lang.get((String)"of.options.mipmap.bilinear");
>                 }
>                 case 3: {
>                     return s + Lang.get((String)"of.options.mipmap.trilinear");
>                 }
>             }
>             return s + "of.options.mipmap.nearest";
>         }
>         if (par1EnumOptions == Options.SMOOTH_FPS) {
>             if (this.ofSmoothFps) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SMOOTH_WORLD) {
>             if (this.ofSmoothWorld) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CLOUDS) {
>             switch (this.ofClouds) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>                 case 3: {
>                     return s + Lang.getOff();
>                 }
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.TREES) {
>             switch (this.ofTrees) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>                 case 4: {
>                     return s + Lang.get((String)"of.general.smart");
>                 }
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.DROPPED_ITEMS) {
>             switch (this.ofDroppedItems) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.RAIN) {
>             switch (this.ofRain) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>                 case 3: {
>                     return s + Lang.getOff();
>                 }
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.ANIMATED_WATER) {
>             switch (this.ofAnimatedWater) {
>                 case 1: {
>                     return s + Lang.get((String)"of.options.animation.dynamic");
>                 }
>                 case 2: {
>                     return s + Lang.getOff();
>                 }
>             }
>             return s + Lang.getOn();
>         }
>         if (par1EnumOptions == Options.ANIMATED_LAVA) {
>             switch (this.ofAnimatedLava) {
>                 case 1: {
>                     return s + Lang.get((String)"of.options.animation.dynamic");
>                 }
>                 case 2: {
>                     return s + Lang.getOff();
>                 }
>             }
>             return s + Lang.getOn();
>         }
>         if (par1EnumOptions == Options.ANIMATED_FIRE) {
>             if (this.ofAnimatedFire) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_PORTAL) {
>             if (this.ofAnimatedPortal) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_REDSTONE) {
>             if (this.ofAnimatedRedstone) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_EXPLOSION) {
>             if (this.ofAnimatedExplosion) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_FLAME) {
>             if (this.ofAnimatedFlame) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_SMOKE) {
>             if (this.ofAnimatedSmoke) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.VOID_PARTICLES) {
>             if (this.ofVoidParticles) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.WATER_PARTICLES) {
>             if (this.ofWaterParticles) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.PORTAL_PARTICLES) {
>             if (this.ofPortalParticles) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.POTION_PARTICLES) {
>             if (this.ofPotionParticles) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FIREWORK_PARTICLES) {
>             if (this.ofFireworkParticles) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.DRIPPING_WATER_LAVA) {
>             if (this.ofDrippingWaterLava) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_TERRAIN) {
>             if (this.ofAnimatedTerrain) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ANIMATED_TEXTURES) {
>             if (this.ofAnimatedTextures) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.RAIN_SPLASH) {
>             if (this.ofRainSplash) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.LAGOMETER) {
>             if (this.ofLagometer) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SHOW_FPS) {
>             if (this.ofShowFps) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.AUTOSAVE_TICKS) {
>             int step = 900;
>             if (this.ofAutoSaveTicks <= step) {
>                 return s + Lang.get((String)"of.options.save.45s");
>             }
>             if (this.ofAutoSaveTicks <= 2 * step) {
>                 return s + Lang.get((String)"of.options.save.90s");
>             }
>             if (this.ofAutoSaveTicks <= 4 * step) {
>                 return s + Lang.get((String)"of.options.save.3min");
>             }
>             if (this.ofAutoSaveTicks <= 8 * step) {
>                 return s + Lang.get((String)"of.options.save.6min");
>             }
>             if (this.ofAutoSaveTicks <= 16 * step) {
>                 return s + Lang.get((String)"of.options.save.12min");
>             }
>             return s + Lang.get((String)"of.options.save.24min");
>         }
>         if (par1EnumOptions == Options.BETTER_GRASS) {
>             switch (this.ofBetterGrass) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CONNECTED_TEXTURES) {
>             switch (this.ofConnectedTextures) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.WEATHER) {
>             if (this.ofWeather) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SKY) {
>             if (this.ofSky) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.STARS) {
>             if (this.ofStars) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SUN_MOON) {
>             if (this.ofSunMoon) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.VIGNETTE) {
>             switch (this.ofVignette) {
>                 case 1: {
>                     return s + Lang.getFast();
>                 }
>                 case 2: {
>                     return s + Lang.getFancy();
>                 }
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.CHUNK_UPDATES) {
>             return s + this.ofChunkUpdates;
>         }
>         if (par1EnumOptions == Options.CHUNK_UPDATES_DYNAMIC) {
>             if (this.ofChunkUpdatesDynamic) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.TIME) {
>             if (this.ofTime == 1) {
>                 return s + Lang.get((String)"of.options.time.dayOnly");
>             }
>             if (this.ofTime == 2) {
>                 return s + Lang.get((String)"of.options.time.nightOnly");
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.CLEAR_WATER) {
>             if (this.ofClearWater) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.AA_LEVEL) {
>             String suffix = "";
>             if (this.ofAaLevel != Config.getAntialiasingLevel()) {
>                 suffix = " (" + Lang.get((String)"of.general.restart") + ")";
>             }
>             if (this.ofAaLevel == 0) {
>                 return s + Lang.getOff() + suffix;
>             }
>             return s + this.ofAaLevel + suffix;
>         }
>         if (par1EnumOptions == Options.AF_LEVEL) {
>             if (this.ofAfLevel == 1) {
>                 return s + Lang.getOff();
>             }
>             return s + this.ofAfLevel;
>         }
>         if (par1EnumOptions == Options.PROFILER) {
>             if (this.ofProfiler) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.BETTER_SNOW) {
>             if (this.ofBetterSnow) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SWAMP_COLORS) {
>             if (this.ofSwampColors) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.RANDOM_ENTITIES) {
>             if (this.ofRandomEntities) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SMOOTH_BIOMES) {
>             if (this.ofSmoothBiomes) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CUSTOM_FONTS) {
>             if (this.ofCustomFonts) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CUSTOM_COLORS) {
>             if (this.ofCustomColors) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CUSTOM_SKY) {
>             if (this.ofCustomSky) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SHOW_CAPES) {
>             if (this.ofShowCapes) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CUSTOM_ITEMS) {
>             if (this.ofCustomItems) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.NATURAL_TEXTURES) {
>             if (this.ofNaturalTextures) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.EMISSIVE_TEXTURES) {
>             if (this.ofEmissiveTextures) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FAST_MATH) {
>             if (this.ofFastMath) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FAST_RENDER) {
>             if (this.ofFastRender) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.TRANSLUCENT_BLOCKS) {
>             if (this.ofTranslucentBlocks == 1) {
>                 return s + Lang.getFast();
>             }
>             if (this.ofTranslucentBlocks == 2) {
>                 return s + Lang.getFancy();
>             }
>             return s + Lang.getDefault();
>         }
>         if (par1EnumOptions == Options.LAZY_CHUNK_LOADING) {
>             if (this.ofLazyChunkLoading) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.RENDER_REGIONS) {
>             if (this.ofRenderRegions) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SMART_ANIMATIONS) {
>             if (this.ofSmartAnimations) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.DYNAMIC_FOV) {
>             if (this.ofDynamicFov) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ALTERNATE_BLOCKS) {
>             if (this.ofAlternateBlocks) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.DYNAMIC_LIGHTS) {
>             int index = GameSettings.indexOf(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
>             return s + GameSettings.getTranslation(KEYS_DYNAMIC_LIGHTS, index);
>         }
>         if (par1EnumOptions == Options.SCREENSHOT_SIZE) {
>             if (this.ofScreenshotSize <= 1) {
>                 return s + Lang.getDefault();
>             }
>             return s + this.ofScreenshotSize + "x";
>         }
>         if (par1EnumOptions == Options.CUSTOM_ENTITY_MODELS) {
>             if (this.ofCustomEntityModels) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.CUSTOM_GUIS) {
>             if (this.ofCustomGuis) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.SHOW_GL_ERRORS) {
>             if (this.ofShowGlErrors) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FULLSCREEN_MODE) {
>             if (this.ofFullscreenMode.equals((Object)"Default")) {
>                 return s + Lang.getDefault();
>             }
>             return s + this.ofFullscreenMode;
>         }
>         if (par1EnumOptions == Options.HELD_ITEM_TOOLTIPS) {
>             if (this.heldItemTooltips) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.ADVANCED_TOOLTIPS) {
>             if (this.advancedItemTooltips) {
>                 return s + Lang.getOn();
>             }
>             return s + Lang.getOff();
>         }
>         if (par1EnumOptions == Options.FRAMERATE_LIMIT) {
>             float var6 = this.getOptionFloatValue(par1EnumOptions);
>             if (var6 == 0.0f) {
>                 return var2 + Lang.get((String)"of.options.framerateLimit.vsync");
>             }
>             if (var6 == Options.access$000((Options)par1EnumOptions)) {
>                 return var2 + I18n.format((String)"options.framerateLimit.max", (Object[])new Object[0]);
>             }
>             return var2 + (int)var6 + " fps";
>         }
>         return null;
>     }
> 
>     public void loadOfOptions() {
>         try {
>             File ofReadFile = this.optionsFileOF;
>             if (!ofReadFile.exists()) {
>                 ofReadFile = this.optionsFile;
>             }
>             if (!ofReadFile.exists()) {
>                 return;
>             }
>             BufferedReader bufferedreader = new BufferedReader((Reader)new InputStreamReader((InputStream)new FileInputStream(ofReadFile), StandardCharsets.UTF_8));
>             String s = "";
>             while ((s = bufferedreader.readLine()) != null) {
>                 try {
>                     String[] as = s.split(":");
>                     if (as[0].equals((Object)"ofRenderDistanceChunks") && as.length >= 2) {
>                         this.renderDistanceChunks = Integer.valueOf((String)as[1]);
>                         this.renderDistanceChunks = Config.limit((int)this.renderDistanceChunks, (int)2, (int)1024);
>                     }
>                     if (as[0].equals((Object)"ofFogType") && as.length >= 2) {
>                         this.ofFogType = Integer.valueOf((String)as[1]);
>                         this.ofFogType = Config.limit((int)this.ofFogType, (int)1, (int)3);
>                     }
>                     if (as[0].equals((Object)"ofFogStart") && as.length >= 2) {
>                         this.ofFogStart = Float.valueOf((String)as[1]).floatValue();
>                         if (this.ofFogStart < 0.2f) {
>                             this.ofFogStart = 0.2f;
>                         }
>                         if (this.ofFogStart > 0.81f) {
>                             this.ofFogStart = 0.8f;
>                         }
>                     }
>                     if (as[0].equals((Object)"ofMipmapType") && as.length >= 2) {
>                         this.ofMipmapType = Integer.valueOf((String)as[1]);
>                         this.ofMipmapType = Config.limit((int)this.ofMipmapType, (int)0, (int)3);
>                     }
>                     if (as[0].equals((Object)"ofOcclusionFancy") && as.length >= 2) {
>                         this.ofOcclusionFancy = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSmoothFps") && as.length >= 2) {
>                         this.ofSmoothFps = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSmoothWorld") && as.length >= 2) {
>                         this.ofSmoothWorld = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAoLevel") && as.length >= 2) {
>                         this.ofAoLevel = Float.valueOf((String)as[1]).floatValue();
>                         this.ofAoLevel = Config.limit((float)this.ofAoLevel, (float)0.0f, (float)1.0f);
>                     }
>                     if (as[0].equals((Object)"ofClouds") && as.length >= 2) {
>                         this.ofClouds = Integer.valueOf((String)as[1]);
>                         this.ofClouds = Config.limit((int)this.ofClouds, (int)0, (int)3);
>                         this.updateRenderClouds();
>                     }
>                     if (as[0].equals((Object)"ofCloudsHeight") && as.length >= 2) {
>                         this.ofCloudsHeight = Float.valueOf((String)as[1]).floatValue();
>                         this.ofCloudsHeight = Config.limit((float)this.ofCloudsHeight, (float)0.0f, (float)1.0f);
>                     }
>                     if (as[0].equals((Object)"ofTrees") && as.length >= 2) {
>                         this.ofTrees = Integer.valueOf((String)as[1]);
>                         this.ofTrees = GameSettings.limit(this.ofTrees, OF_TREES_VALUES);
>                     }
>                     if (as[0].equals((Object)"ofDroppedItems") && as.length >= 2) {
>                         this.ofDroppedItems = Integer.valueOf((String)as[1]);
>                         this.ofDroppedItems = Config.limit((int)this.ofDroppedItems, (int)0, (int)2);
>                     }
>                     if (as[0].equals((Object)"ofRain") && as.length >= 2) {
>                         this.ofRain = Integer.valueOf((String)as[1]);
>                         this.ofRain = Config.limit((int)this.ofRain, (int)0, (int)3);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedWater") && as.length >= 2) {
>                         this.ofAnimatedWater = Integer.valueOf((String)as[1]);
>                         this.ofAnimatedWater = Config.limit((int)this.ofAnimatedWater, (int)0, (int)2);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedLava") && as.length >= 2) {
>                         this.ofAnimatedLava = Integer.valueOf((String)as[1]);
>                         this.ofAnimatedLava = Config.limit((int)this.ofAnimatedLava, (int)0, (int)2);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedFire") && as.length >= 2) {
>                         this.ofAnimatedFire = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedPortal") && as.length >= 2) {
>                         this.ofAnimatedPortal = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedRedstone") && as.length >= 2) {
>                         this.ofAnimatedRedstone = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedExplosion") && as.length >= 2) {
>                         this.ofAnimatedExplosion = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedFlame") && as.length >= 2) {
>                         this.ofAnimatedFlame = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedSmoke") && as.length >= 2) {
>                         this.ofAnimatedSmoke = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofVoidParticles") && as.length >= 2) {
>                         this.ofVoidParticles = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofWaterParticles") && as.length >= 2) {
>                         this.ofWaterParticles = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofPortalParticles") && as.length >= 2) {
>                         this.ofPortalParticles = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofPotionParticles") && as.length >= 2) {
>                         this.ofPotionParticles = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofFireworkParticles") && as.length >= 2) {
>                         this.ofFireworkParticles = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofDrippingWaterLava") && as.length >= 2) {
>                         this.ofDrippingWaterLava = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedTerrain") && as.length >= 2) {
>                         this.ofAnimatedTerrain = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAnimatedTextures") && as.length >= 2) {
>                         this.ofAnimatedTextures = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofRainSplash") && as.length >= 2) {
>                         this.ofRainSplash = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofLagometer") && as.length >= 2) {
>                         this.ofLagometer = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofShowFps") && as.length >= 2) {
>                         this.ofShowFps = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAutoSaveTicks") && as.length >= 2) {
>                         this.ofAutoSaveTicks = Integer.valueOf((String)as[1]);
>                         this.ofAutoSaveTicks = Config.limit((int)this.ofAutoSaveTicks, (int)40, (int)40000);
>                     }
>                     if (as[0].equals((Object)"ofBetterGrass") && as.length >= 2) {
>                         this.ofBetterGrass = Integer.valueOf((String)as[1]);
>                         this.ofBetterGrass = Config.limit((int)this.ofBetterGrass, (int)1, (int)3);
>                     }
>                     if (as[0].equals((Object)"ofConnectedTextures") && as.length >= 2) {
>                         this.ofConnectedTextures = Integer.valueOf((String)as[1]);
>                         this.ofConnectedTextures = Config.limit((int)this.ofConnectedTextures, (int)1, (int)3);
>                     }
>                     if (as[0].equals((Object)"ofWeather") && as.length >= 2) {
>                         this.ofWeather = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSky") && as.length >= 2) {
>                         this.ofSky = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofStars") && as.length >= 2) {
>                         this.ofStars = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSunMoon") && as.length >= 2) {
>                         this.ofSunMoon = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofVignette") && as.length >= 2) {
>                         this.ofVignette = Integer.valueOf((String)as[1]);
>                         this.ofVignette = Config.limit((int)this.ofVignette, (int)0, (int)2);
>                     }
>                     if (as[0].equals((Object)"ofChunkUpdates") && as.length >= 2) {
>                         this.ofChunkUpdates = Integer.valueOf((String)as[1]);
>                         this.ofChunkUpdates = Config.limit((int)this.ofChunkUpdates, (int)1, (int)5);
>                     }
>                     if (as[0].equals((Object)"ofChunkUpdatesDynamic") && as.length >= 2) {
>                         this.ofChunkUpdatesDynamic = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofTime") && as.length >= 2) {
>                         this.ofTime = Integer.valueOf((String)as[1]);
>                         this.ofTime = Config.limit((int)this.ofTime, (int)0, (int)2);
>                     }
>                     if (as[0].equals((Object)"ofClearWater") && as.length >= 2) {
>                         this.ofClearWater = Boolean.valueOf((String)as[1]);
>                         this.updateWaterOpacity();
>                     }
>                     if (as[0].equals((Object)"ofAaLevel") && as.length >= 2) {
>                         this.ofAaLevel = Integer.valueOf((String)as[1]);
>                         this.ofAaLevel = Config.limit((int)this.ofAaLevel, (int)0, (int)16);
>                     }
>                     if (as[0].equals((Object)"ofAfLevel") && as.length >= 2) {
>                         this.ofAfLevel = Integer.valueOf((String)as[1]);
>                         this.ofAfLevel = Config.limit((int)this.ofAfLevel, (int)1, (int)16);
>                     }
>                     if (as[0].equals((Object)"ofProfiler") && as.length >= 2) {
>                         this.ofProfiler = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofBetterSnow") && as.length >= 2) {
>                         this.ofBetterSnow = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSwampColors") && as.length >= 2) {
>                         this.ofSwampColors = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofRandomEntities") && as.length >= 2) {
>                         this.ofRandomEntities = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSmoothBiomes") && as.length >= 2) {
>                         this.ofSmoothBiomes = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofCustomFonts") && as.length >= 2) {
>                         this.ofCustomFonts = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofCustomColors") && as.length >= 2) {
>                         this.ofCustomColors = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofCustomItems") && as.length >= 2) {
>                         this.ofCustomItems = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofCustomSky") && as.length >= 2) {
>                         this.ofCustomSky = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofShowCapes") && as.length >= 2) {
>                         this.ofShowCapes = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofNaturalTextures") && as.length >= 2) {
>                         this.ofNaturalTextures = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofEmissiveTextures") && as.length >= 2) {
>                         this.ofEmissiveTextures = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofLazyChunkLoading") && as.length >= 2) {
>                         this.ofLazyChunkLoading = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofRenderRegions") && as.length >= 2) {
>                         this.ofRenderRegions = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofSmartAnimations") && as.length >= 2) {
>                         this.ofSmartAnimations = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofDynamicFov") && as.length >= 2) {
>                         this.ofDynamicFov = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofAlternateBlocks") && as.length >= 2) {
>                         this.ofAlternateBlocks = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofDynamicLights") && as.length >= 2) {
>                         this.ofDynamicLights = Integer.valueOf((String)as[1]);
>                         this.ofDynamicLights = GameSettings.limit(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
>                     }
>                     if (as[0].equals((Object)"ofScreenshotSize") && as.length >= 2) {
>                         this.ofScreenshotSize = Integer.valueOf((String)as[1]);
>                         this.ofScreenshotSize = Config.limit((int)this.ofScreenshotSize, (int)1, (int)4);
>                     }
>                     if (as[0].equals((Object)"ofCustomEntityModels") && as.length >= 2) {
>                         this.ofCustomEntityModels = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofCustomGuis") && as.length >= 2) {
>                         this.ofCustomGuis = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofShowGlErrors") && as.length >= 2) {
>                         this.ofShowGlErrors = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofFullscreenMode") && as.length >= 2) {
>                         this.ofFullscreenMode = as[1];
>                     }
>                     if (as[0].equals((Object)"ofFastMath") && as.length >= 2) {
>                         MathHelper.fastMath = this.ofFastMath = Boolean.valueOf((String)as[1]).booleanValue();
>                     }
>                     if (as[0].equals((Object)"ofFastRender") && as.length >= 2) {
>                         this.ofFastRender = Boolean.valueOf((String)as[1]);
>                     }
>                     if (as[0].equals((Object)"ofTranslucentBlocks") && as.length >= 2) {
>                         this.ofTranslucentBlocks = Integer.valueOf((String)as[1]);
>                         this.ofTranslucentBlocks = Config.limit((int)this.ofTranslucentBlocks, (int)0, (int)2);
>                     }
>                     if (!as[0].equals((Object)("key_" + this.ofKeyBindZoom.getKeyDescription()))) continue;
>                     this.ofKeyBindZoom.setKeyCode(Integer.parseInt((String)as[1]));
>                 }
>                 catch (Exception exception1) {
>                     Config.dbg((String)("Skipping bad option: " + s));
>                     exception1.printStackTrace();
>                 }
>             }
>             KeyUtils.fixKeyConflicts((KeyBinding[])this.keyBindings, (KeyBinding[])new KeyBinding[]{this.ofKeyBindZoom});
>             KeyBinding.resetKeyBindingArrayAndHash();
>             bufferedreader.close();
>         }
>         catch (Exception exception) {
>             Config.warn((String)"Failed to load options");
>             exception.printStackTrace();
>         }
>     }
> 
>     public void saveOfOptions() {
>         try {
>             PrintWriter printwriter = new PrintWriter((Writer)new OutputStreamWriter((OutputStream)new FileOutputStream(this.optionsFileOF), StandardCharsets.UTF_8));
>             printwriter.println("ofFogType:" + this.ofFogType);
>             printwriter.println("ofFogStart:" + this.ofFogStart);
>             printwriter.println("ofMipmapType:" + this.ofMipmapType);
>             printwriter.println("ofOcclusionFancy:" + this.ofOcclusionFancy);
>             printwriter.println("ofSmoothFps:" + this.ofSmoothFps);
>             printwriter.println("ofSmoothWorld:" + this.ofSmoothWorld);
>             printwriter.println("ofAoLevel:" + this.ofAoLevel);
>             printwriter.println("ofClouds:" + this.ofClouds);
>             printwriter.println("ofCloudsHeight:" + this.ofCloudsHeight);
>             printwriter.println("ofTrees:" + this.ofTrees);
>             printwriter.println("ofDroppedItems:" + this.ofDroppedItems);
>             printwriter.println("ofRain:" + this.ofRain);
>             printwriter.println("ofAnimatedWater:" + this.ofAnimatedWater);
>             printwriter.println("ofAnimatedLava:" + this.ofAnimatedLava);
>             printwriter.println("ofAnimatedFire:" + this.ofAnimatedFire);
>             printwriter.println("ofAnimatedPortal:" + this.ofAnimatedPortal);
>             printwriter.println("ofAnimatedRedstone:" + this.ofAnimatedRedstone);
>             printwriter.println("ofAnimatedExplosion:" + this.ofAnimatedExplosion);
>             printwriter.println("ofAnimatedFlame:" + this.ofAnimatedFlame);
>             printwriter.println("ofAnimatedSmoke:" + this.ofAnimatedSmoke);
>             printwriter.println("ofVoidParticles:" + this.ofVoidParticles);
>             printwriter.println("ofWaterParticles:" + this.ofWaterParticles);
>             printwriter.println("ofPortalParticles:" + this.ofPortalParticles);
>             printwriter.println("ofPotionParticles:" + this.ofPotionParticles);
>             printwriter.println("ofFireworkParticles:" + this.ofFireworkParticles);
>             printwriter.println("ofDrippingWaterLava:" + this.ofDrippingWaterLava);
>             printwriter.println("ofAnimatedTerrain:" + this.ofAnimatedTerrain);
>             printwriter.println("ofAnimatedTextures:" + this.ofAnimatedTextures);
>             printwriter.println("ofRainSplash:" + this.ofRainSplash);
>             printwriter.println("ofLagometer:" + this.ofLagometer);
>             printwriter.println("ofShowFps:" + this.ofShowFps);
>             printwriter.println("ofAutoSaveTicks:" + this.ofAutoSaveTicks);
>             printwriter.println("ofBetterGrass:" + this.ofBetterGrass);
>             printwriter.println("ofConnectedTextures:" + this.ofConnectedTextures);
>             printwriter.println("ofWeather:" + this.ofWeather);
>             printwriter.println("ofSky:" + this.ofSky);
>             printwriter.println("ofStars:" + this.ofStars);
>             printwriter.println("ofSunMoon:" + this.ofSunMoon);
>             printwriter.println("ofVignette:" + this.ofVignette);
>             printwriter.println("ofChunkUpdates:" + this.ofChunkUpdates);
>             printwriter.println("ofChunkUpdatesDynamic:" + this.ofChunkUpdatesDynamic);
>             printwriter.println("ofTime:" + this.ofTime);
>             printwriter.println("ofClearWater:" + this.ofClearWater);
>             printwriter.println("ofAaLevel:" + this.ofAaLevel);
>             printwriter.println("ofAfLevel:" + this.ofAfLevel);
>             printwriter.println("ofProfiler:" + this.ofProfiler);
>             printwriter.println("ofBetterSnow:" + this.ofBetterSnow);
>             printwriter.println("ofSwampColors:" + this.ofSwampColors);
>             printwriter.println("ofRandomEntities:" + this.ofRandomEntities);
>             printwriter.println("ofSmoothBiomes:" + this.ofSmoothBiomes);
>             printwriter.println("ofCustomFonts:" + this.ofCustomFonts);
>             printwriter.println("ofCustomColors:" + this.ofCustomColors);
>             printwriter.println("ofCustomItems:" + this.ofCustomItems);
>             printwriter.println("ofCustomSky:" + this.ofCustomSky);
>             printwriter.println("ofShowCapes:" + this.ofShowCapes);
>             printwriter.println("ofNaturalTextures:" + this.ofNaturalTextures);
>             printwriter.println("ofEmissiveTextures:" + this.ofEmissiveTextures);
>             printwriter.println("ofLazyChunkLoading:" + this.ofLazyChunkLoading);
>             printwriter.println("ofRenderRegions:" + this.ofRenderRegions);
>             printwriter.println("ofSmartAnimations:" + this.ofSmartAnimations);
>             printwriter.println("ofDynamicFov:" + this.ofDynamicFov);
>             printwriter.println("ofAlternateBlocks:" + this.ofAlternateBlocks);
>             printwriter.println("ofDynamicLights:" + this.ofDynamicLights);
>             printwriter.println("ofScreenshotSize:" + this.ofScreenshotSize);
>             printwriter.println("ofCustomEntityModels:" + this.ofCustomEntityModels);
>             printwriter.println("ofCustomGuis:" + this.ofCustomGuis);
>             printwriter.println("ofShowGlErrors:" + this.ofShowGlErrors);
>             printwriter.println("ofFullscreenMode:" + this.ofFullscreenMode);
>             printwriter.println("ofFastMath:" + this.ofFastMath);
>             printwriter.println("ofFastRender:" + this.ofFastRender);
>             printwriter.println("ofTranslucentBlocks:" + this.ofTranslucentBlocks);
>             printwriter.println("key_" + this.ofKeyBindZoom.getKeyDescription() + ":" + this.ofKeyBindZoom.getKeyCode());
>             printwriter.close();
>         }
>         catch (Exception exception) {
>             Config.warn((String)"Failed to save options");
>             exception.printStackTrace();
>         }
>     }
> 
>     private void updateRenderClouds() {
>         switch (this.ofClouds) {
>             case 3: {
>                 this.clouds = 0;
>                 break;
>             }
>             case 1: {
>                 this.clouds = 1;
>                 break;
>             }
>             case 2: {
>                 this.clouds = 2;
>                 break;
>             }
>             default: {
>                 this.clouds = this.fancyGraphics ? 2 : 1;
>             }
>         }
>     }
> 
>     public void resetSettings() {
>         this.renderDistanceChunks = 8;
>         this.viewBobbing = true;
>         this.anaglyph = false;
>         this.limitFramerate = (int)Options.FRAMERATE_LIMIT.getValueMax();
>         this.enableVsync = false;
>         this.updateVSync();
>         this.mipmapLevels = 4;
>         this.fancyGraphics = true;
>         this.ambientOcclusion = 2;
>         this.clouds = 2;
>         this.fovSetting = 70.0f;
>         this.gammaSetting = 0.0f;
>         this.guiScale = 0;
>         this.particleSetting = 0;
>         this.heldItemTooltips = true;
>         this.useVbo = false;
>         this.forceUnicodeFont = false;
>         this.ofFogType = 1;
>         this.ofFogStart = 0.8f;
>         this.ofMipmapType = 0;
>         this.ofOcclusionFancy = false;
>         this.ofSmartAnimations = false;
>         this.ofSmoothFps = false;
>         Config.updateAvailableProcessors();
>         this.ofSmoothWorld = Config.isSingleProcessor();
>         this.ofLazyChunkLoading = false;
>         this.ofRenderRegions = false;
>         this.ofFastMath = false;
>         this.ofFastRender = false;
>         this.ofTranslucentBlocks = 0;
>         this.ofDynamicFov = true;
>         this.ofAlternateBlocks = true;
>         this.ofDynamicLights = 3;
>         this.ofScreenshotSize = 1;
>         this.ofCustomEntityModels = true;
>         this.ofCustomGuis = true;
>         this.ofShowGlErrors = true;
>         this.ofAoLevel = 1.0f;
>         this.ofAaLevel = 0;
>         this.ofAfLevel = 1;
>         this.ofClouds = 0;
>         this.ofCloudsHeight = 0.0f;
>         this.ofTrees = 0;
>         this.ofRain = 0;
>         this.ofBetterGrass = 3;
>         this.ofAutoSaveTicks = 4000;
>         this.ofLagometer = false;
>         this.ofShowFps = false;
>         this.ofProfiler = false;
>         this.ofWeather = true;
>         this.ofSky = true;
>         this.ofStars = true;
>         this.ofSunMoon = true;
>         this.ofVignette = 0;
>         this.ofChunkUpdates = 1;
>         this.ofChunkUpdatesDynamic = false;
>         this.ofTime = 0;
>         this.ofClearWater = false;
>         this.ofBetterSnow = false;
>         this.ofFullscreenMode = "Default";
>         this.ofSwampColors = true;
>         this.ofRandomEntities = true;
>         this.ofSmoothBiomes = true;
>         this.ofCustomFonts = true;
>         this.ofCustomColors = true;
>         this.ofCustomItems = true;
>         this.ofCustomSky = true;
>         this.ofShowCapes = true;
>         this.ofConnectedTextures = 2;
>         this.ofNaturalTextures = false;
>         this.ofEmissiveTextures = true;
>         this.ofAnimatedWater = 0;
>         this.ofAnimatedLava = 0;
>         this.ofAnimatedFire = true;
>         this.ofAnimatedPortal = true;
>         this.ofAnimatedRedstone = true;
>         this.ofAnimatedExplosion = true;
>         this.ofAnimatedFlame = true;
>         this.ofAnimatedSmoke = true;
>         this.ofVoidParticles = true;
>         this.ofWaterParticles = true;
>         this.ofRainSplash = true;
>         this.ofPortalParticles = true;
>         this.ofPotionParticles = true;
>         this.ofFireworkParticles = true;
>         this.ofDrippingWaterLava = true;
>         this.ofAnimatedTerrain = true;
>         this.ofAnimatedTextures = true;
>         Shaders.setShaderPack((String)"OFF");
>         Shaders.configAntialiasingLevel = 0;
>         Shaders.uninit();
>         Shaders.storeConfig();
>         this.updateWaterOpacity();
>         this.mc.refreshResources();
>         this.saveOptions();
>     }
> 
>     public void updateVSync() {
>         Display.setVSyncEnabled((boolean)this.enableVsync);
>     }
> 
>     private void updateWaterOpacity() {
>         if (Config.isIntegratedServerRunning()) {
>             Config.waterOpacityChanged = true;
>         }
>         ClearWater.updateWaterOpacity((GameSettings)this, (World)this.mc.world);
>     }
> 
>     public void setAllAnimations(boolean flag) {
>         int animVal;
>         this.ofAnimatedWater = animVal = flag ? 0 : 2;
>         this.ofAnimatedLava = animVal;
>         this.ofAnimatedFire = flag;
>         this.ofAnimatedPortal = flag;
>         this.ofAnimatedRedstone = flag;
>         this.ofAnimatedExplosion = flag;
>         this.ofAnimatedFlame = flag;
>         this.ofAnimatedSmoke = flag;
>         this.ofVoidParticles = flag;
>         this.ofWaterParticles = flag;
>         this.ofRainSplash = flag;
>         this.ofPortalParticles = flag;
>         this.ofPotionParticles = flag;
>         this.ofFireworkParticles = flag;
>         this.particleSetting = flag ? 0 : 2;
>         this.ofDrippingWaterLava = flag;
>         this.ofAnimatedTerrain = flag;
>         this.ofAnimatedTextures = flag;
>     }
> 
>     private static int nextValue(int val, int[] vals) {
>         int index = GameSettings.indexOf(val, vals);
>         if (index < 0) {
>             return vals[0];
>         }
>         if (++index >= vals.length) {
>             index = 0;
>         }
>         return vals[index];
>     }
> 
>     private static int limit(int val, int[] vals) {
>         int index = GameSettings.indexOf(val, vals);
>         if (index < 0) {
>             return vals[0];
>         }
>         return val;
>     }
> 
>     private static int indexOf(int val, int[] vals) {
>         for (int i = 0; i < vals.length; ++i) {
>             if (vals[i] != val) continue;
>             return i;
>         }
>         return -1;
>     }
> 
1038,1052c2748,2768
<         KeyConflictContext inGame = KeyConflictContext.IN_GAME;
<         this.keyBindForward.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindLeft.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindBack.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindRight.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindJump.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindSneak.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindSprint.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindAttack.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindChat.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindPlayerList.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindCommand.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindTogglePerspective.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindSmoothCamera.setKeyConflictContext((IKeyConflictContext)inGame);
<         this.keyBindSwapHands.setKeyConflictContext((IKeyConflictContext)inGame);
---
>         if (!Reflector.KeyConflictContext_IN_GAME.exists()) {
>             return;
>         }
>         if (!Reflector.ForgeKeyBinding_setKeyConflictContext.exists()) {
>             return;
>         }
>         Object inGame = Reflector.getFieldValue((ReflectorField)Reflector.KeyConflictContext_IN_GAME);
>         Reflector.call((Object)this.keyBindForward, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindLeft, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindBack, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindRight, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindJump, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindSneak, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindSprint, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindAttack, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindChat, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindPlayerList, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindCommand, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindTogglePerspective, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindSmoothCamera, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
>         Reflector.call((Object)this.keyBindSwapHands, (ReflectorMethod)Reflector.ForgeKeyBinding_setKeyConflictContext, (Object[])new Object[]{inGame});
1056,1058c2772,2774
<         if (this.needsBlockModelRefresh) {
<             FMLClientHandler.instance().scheduleResourcesRefresh(new IResourceType[]{VanillaResourceType.MODELS});
<             this.needsBlockModelRefresh = false;
---
>         if (this.needsResourceRefresh) {
>             this.mc.scheduleResourcesRefresh();
>             this.needsResourceRefresh = false;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$1.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$1.java
7d6
<  *  net.minecraft.crash.CrashReport
12d10
< import net.minecraft.crash.CrashReport;
17c15
<     CrashReport.1(CrashReport this$0) {
---
>     CrashReport.1() {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$2.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$2.java
5d4
<  *  java.lang.Exception
8c7
<  *  net.minecraft.crash.CrashReport
---
>  *  java.lang.System
13d11
< import net.minecraft.crash.CrashReport;
18c16
<     CrashReport.2(CrashReport this$0) {
---
>     CrashReport.2() {
21,22c19,20
<     public String call() throws Exception {
<         return "0.2.3-alpha+build.39.run.774";
---
>     public String call() {
>         return System.getProperty((String)"os.name") + " (" + System.getProperty((String)"os.arch") + ") version " + System.getProperty((String)"os.version");
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$3.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$3.java
8d7
<  *  net.minecraft.crash.CrashReport
13d11
< import net.minecraft.crash.CrashReport;
18c16
<     CrashReport.3(CrashReport this$0) {
---
>     CrashReport.3() {
22c20
<         return System.getProperty((String)"os.name") + " (" + System.getProperty((String)"os.arch") + ") version " + System.getProperty((String)"os.version");
---
>         return System.getProperty((String)"java.version") + ", " + System.getProperty((String)"java.vendor");
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$4.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$4.java
8d7
<  *  net.minecraft.crash.CrashReport
13d11
< import net.minecraft.crash.CrashReport;
18c16
<     CrashReport.4(CrashReport this$0) {
---
>     CrashReport.4() {
22c20
<         return System.getProperty((String)"java.version") + ", " + System.getProperty((String)"java.vendor");
---
>         return System.getProperty((String)"java.vm.name") + " (" + System.getProperty((String)"java.vm.info") + "), " + System.getProperty((String)"java.vm.vendor");
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$5.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$5.java
5a6
>  *  java.lang.Runtime
7,8d7
<  *  java.lang.System
<  *  net.minecraft.crash.CrashReport
13d11
< import net.minecraft.crash.CrashReport;
18c16
<     CrashReport.5(CrashReport this$0) {
---
>     CrashReport.5() {
22c20,27
<         return System.getProperty((String)"java.vm.name") + " (" + System.getProperty((String)"java.vm.info") + "), " + System.getProperty((String)"java.vm.vendor");
---
>         Runtime runtime = Runtime.getRuntime();
>         long i = runtime.maxMemory();
>         long j = runtime.totalMemory();
>         long k = runtime.freeMemory();
>         long l = i / 1024L / 1024L;
>         long i1 = j / 1024L / 1024L;
>         long j1 = k / 1024L / 1024L;
>         return k + " bytes (" + j1 + " MB) / " + j + " bytes (" + i1 + " MB) up to " + i + " bytes (" + l + " MB)";
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$6.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$6.java
6d5
<  *  java.lang.Runtime
8c7,10
<  *  net.minecraft.crash.CrashReport
---
>  *  java.lang.StringBuilder
>  *  java.lang.management.ManagementFactory
>  *  java.lang.management.RuntimeMXBean
>  *  java.util.List
13c15,17
< import net.minecraft.crash.CrashReport;
---
> import java.lang.management.ManagementFactory;
> import java.lang.management.RuntimeMXBean;
> import java.util.List;
18c22
<     CrashReport.6(CrashReport this$0) {
---
>     CrashReport.6() {
22,29c26,37
<         Runtime runtime = Runtime.getRuntime();
<         long i = runtime.maxMemory();
<         long j = runtime.totalMemory();
<         long k = runtime.freeMemory();
<         long l = i / 1024L / 1024L;
<         long i1 = j / 1024L / 1024L;
<         long j1 = k / 1024L / 1024L;
<         return k + " bytes (" + j1 + " MB) / " + j + " bytes (" + i1 + " MB) up to " + i + " bytes (" + l + " MB)";
---
>         RuntimeMXBean runtimemxbean = ManagementFactory.getRuntimeMXBean();
>         List list = runtimemxbean.getInputArguments();
>         int i = 0;
>         StringBuilder stringbuilder = new StringBuilder();
>         for (String s : list) {
>             if (!s.startsWith("-X")) continue;
>             if (i++ > 0) {
>                 stringbuilder.append(" ");
>             }
>             stringbuilder.append(s);
>         }
>         return String.format((String)"%d total; %s", (Object[])new Object[]{i, stringbuilder.toString()});
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport$7.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport$7.java
4a5
>  *  java.lang.Exception
7,11d7
<  *  java.lang.StringBuilder
<  *  java.lang.management.ManagementFactory
<  *  java.lang.management.RuntimeMXBean
<  *  java.util.List
<  *  net.minecraft.crash.CrashReport
12a9
>  *  net.minecraft.world.gen.layer.IntCache
16,19d12
< import java.lang.management.ManagementFactory;
< import java.lang.management.RuntimeMXBean;
< import java.util.List;
< import net.minecraft.crash.CrashReport;
20a14
> import net.minecraft.world.gen.layer.IntCache;
24c18
<     CrashReport.7(CrashReport this$0) {
---
>     CrashReport.7() {
27,39c21,22
<     public String call() {
<         RuntimeMXBean runtimemxbean = ManagementFactory.getRuntimeMXBean();
<         List list = runtimemxbean.getInputArguments();
<         int i = 0;
<         StringBuilder stringbuilder = new StringBuilder();
<         for (String s : list) {
<             if (!s.startsWith("-X")) continue;
<             if (i++ > 0) {
<                 stringbuilder.append(" ");
<             }
<             stringbuilder.append(s);
<         }
<         return String.format((String)"%d total; %s", (Object[])new Object[]{i, stringbuilder.toString()});
---
>     public String call() throws Exception {
>         return IntCache.getCacheSizes();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/crash/CrashReport.java ../optifine_patch/src/main/java/net/minecraft/crash/CrashReport.java
6d5
<  *  it.unimi.dsi.fastutil.objects.ObjectOpenHashSet
27d25
<  *  java.util.Iterator
29d26
<  *  java.util.Set
33,36c30,32
<  *  net.minecraftforge.fml.common.FMLCommonHandler
<  *  net.minecraftforge.fml.relauncher.CoreModManager
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.CrashReporter
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
41,42d36
<  *  org.spongepowered.asm.mixin.extensibility.IMixinInfo
<  *  org.spongepowered.asm.mixin.transformer.ClassInfo
47d40
< import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
58d50
< import java.util.Iterator;
60d51
< import java.util.Set;
64,67c55,57
< import net.minecraftforge.fml.common.FMLCommonHandler;
< import net.minecraftforge.fml.relauncher.CoreModManager;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.CrashReporter;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
72,73d61
< import org.spongepowered.asm.mixin.extensibility.IMixinInfo;
< import org.spongepowered.asm.mixin.transformer.ClassInfo;
83a72
>     private boolean reported = false;
93d81
<         this.systemDetailsCategory.addDetail("Cleanroom Version", (ICrashReportDetail)new /* Unavailable Anonymous Inner Class!! */);
100c88,91
<         FMLCommonHandler.instance().enhanceCrashReport(this, this.systemDetailsCategory);
---
>         if (Reflector.FMLCommonHandler_enhanceCrashReport.exists()) {
>             Object instance = Reflector.call((ReflectorMethod)Reflector.FMLCommonHandler_instance, (Object[])new Object[0]);
>             Reflector.callString((Object)instance, (ReflectorMethod)Reflector.FMLCommonHandler_enhanceCrashReport, (Object[])new Object[]{this, this.systemDetailsCategory});
>         }
163,197d153
<         Iterator stacktrace = throwable.getStackTrace();
<         if (((StackTraceElement[])stacktrace).length > 0) {
<             try {
<                 StringBuilder mixinMetadataBuilder = null;
<                 ObjectOpenHashSet classes = new ObjectOpenHashSet();
<                 for (StackTraceElement stackTraceElement : stacktrace) {
<                     classes.add((Object)stackTraceElement.getClassName());
<                 }
<                 for (String className : classes) {
<                     Set mixinInfos;
<                     ClassInfo classInfo = ClassInfo.fromCache((String)className);
<                     if (classInfo == null || (mixinInfos = classInfo.getMixins()).isEmpty()) continue;
<                     if (mixinMetadataBuilder == null) {
<                         mixinMetadataBuilder = new StringBuilder("\n(MixinBooter) Mixins in Stacktrace:");
<                     }
<                     mixinMetadataBuilder.append("\n\t");
<                     mixinMetadataBuilder.append(className);
<                     mixinMetadataBuilder.append(":");
<                     for (IMixinInfo mixinInfo : mixinInfos) {
<                         mixinMetadataBuilder.append("\n\t\t");
<                         mixinMetadataBuilder.append(mixinInfo.getClassName());
<                         mixinMetadataBuilder.append(" (");
<                         mixinMetadataBuilder.append(mixinInfo.getConfig().getName());
<                         mixinMetadataBuilder.append(")");
<                     }
<                 }
<                 if (mixinMetadataBuilder == null) {
<                     return s + "\nNo Mixin Metadata is found in the Stacktrace.\n";
<                 }
<                 return s + String.valueOf(mixinMetadataBuilder);
<             }
<             catch (Throwable t) {
<                 return s + "\nFailed to find Mixin Metadata in Stacktrace:\n" + String.valueOf((Object)((Object)t));
<             }
<         }
201a158,161
>         if (!this.reported) {
>             this.reported = true;
>             CrashReporter.onCrashReport((CrashReport)this, (CrashReportCategory)this.systemDetailsCategory);
>         }
204c164
<         CoreModManager.onCrash((StringBuilder)stringbuilder);
---
>         Reflector.call((ReflectorMethod)Reflector.CoreModManager_onCrash, (Object[])new Object[]{stringbuilder});
224d183
<     @SideOnly(value=Side.CLIENT)
diff -r ../optifine_unpatch/src/main/java/net/minecraft/entity/EntityLiving.java ../optifine_patch/src/main/java/net/minecraft/entity/EntityLiving.java
4a5
>  *  Config
37a39
>  *  net.minecraft.entity.monster.EntityMob
61a64
>  *  net.minecraft.scoreboard.Team
81,85c84,86
<  *  net.minecraftforge.common.ForgeHooks
<  *  net.minecraftforge.event.ForgeEventFactory
<  *  net.minecraftforge.fml.common.eventhandler.Event$Result
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorField
>  *  net.optifine.reflect.ReflectorMethod
114a116
> import net.minecraft.entity.monster.EntityMob;
137a140
> import net.minecraft.scoreboard.Team;
157,161c160,162
< import net.minecraftforge.common.ForgeHooks;
< import net.minecraftforge.event.ForgeEventFactory;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorField;
> import net.optifine.reflect.ReflectorMethod;
173,174c174,175
<     public final EntityAITasks tasks;
<     public final EntityAITasks targetTasks;
---
>     protected final EntityAITasks tasks;
>     protected final EntityAITasks targetTasks;
188a190,191
>     private UUID teamUuid = null;
>     private String teamUuidString = null;
259c262
<         ForgeHooks.onLivingSetAttackTarget((EntityLivingBase)this, (EntityLivingBase)entitylivingbaseIn);
---
>         Reflector.callVoid((ReflectorMethod)Reflector.ForgeHooks_onLivingSetAttackTarget, (Object[])new Object[]{this, entitylivingbaseIn});
334d336
<     @SideOnly(value=Side.CLIENT)
343a346,349
>         if (Config.isSmoothWorld() && this.canSkipUpdate()) {
>             this.onUpdateMinimal();
>             return;
>         }
515,516c521,522
<     public void setMoveForward(float amount) {
<         this.moveForward = amount;
---
>     public void setMoveForward(float p_191989_1_) {
>         this.moveForward = p_191989_1_;
535c541,545
<         if (!this.l.isRemote && this.canPickUpLoot() && !this.dead && ForgeEventFactory.getMobGriefingEvent((World)this.l, (Entity)this)) {
---
>         boolean mobGriefing = this.l.getGameRules().getBoolean("mobGriefing");
>         if (Reflector.ForgeEventFactory_getMobGriefingEvent.exists()) {
>             mobGriefing = Reflector.callBoolean((ReflectorMethod)Reflector.ForgeEventFactory_getMobGriefingEvent, (Object[])new Object[]{this.l, this});
>         }
>         if (!this.l.isRemote && this.canPickUpLoot() && !this.dead && mobGriefing) {
571,575c581,595
<             if (!itemstack1.isEmpty() && (double)(this.S.nextFloat() - 0.1f) < (switch (1.$SwitchMap$net$minecraft$inventory$EntityEquipmentSlot$Type[entityequipmentslot.getSlotType().ordinal()]) {
<                 case 1 -> this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
<                 case 2 -> this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
<                 default -> 0.0;
<             })) {
---
>             double d0;
>             switch (1.$SwitchMap$net$minecraft$inventory$EntityEquipmentSlot$Type[entityequipmentslot.getSlotType().ordinal()]) {
>                 case 1: {
>                     d0 = this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
>                     break;
>                 }
>                 case 2: {
>                     d0 = this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
>                     break;
>                 }
>                 default: {
>                     d0 = 0.0;
>                 }
>             }
>             if (!itemstack1.isEmpty() && (double)(this.S.nextFloat() - 0.1f) < d0) {
603c623,625
<         Event.Result result = null;
---
>         Object result = null;
>         Object Result_DEFAULT = Reflector.getFieldValue((ReflectorField)Reflector.Event_Result_DEFAULT);
>         Object Result_DENY = Reflector.getFieldValue((ReflectorField)Reflector.Event_Result_DENY);
606,607c628,629
<         } else if ((this.idleTime & 0x1F) == 31 && (result = ForgeEventFactory.canEntityDespawn((EntityLiving)this)) != Event.Result.DEFAULT) {
<             if (result == Event.Result.DENY) {
---
>         } else if ((this.idleTime & 0x1F) == 31 && (result = Reflector.call((ReflectorMethod)Reflector.ForgeEventFactory_canEntityDespawn, (Object[])new Object[]{this})) != Result_DEFAULT) {
>             if (result == Result_DENY) {
768a791
>             double d0;
770,774c793,805
<             double d0 = switch (1.$SwitchMap$net$minecraft$inventory$EntityEquipmentSlot$Type[entityequipmentslot.getSlotType().ordinal()]) {
<                 case 1 -> this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
<                 case 2 -> this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
<                 default -> 0.0;
<             };
---
>             switch (1.$SwitchMap$net$minecraft$inventory$EntityEquipmentSlot$Type[entityequipmentslot.getSlotType().ordinal()]) {
>                 case 1: {
>                     d0 = this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
>                     break;
>                 }
>                 case 2: {
>                     d0 = this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
>                     break;
>                 }
>                 default: {
>                     d0 = 0.0;
>                 }
>             }
812,813c843,844
<         EntityEquipmentSlot slot = stack.getItem().getEquipmentSlot(stack);
<         if (slot != null) {
---
>         EntityEquipmentSlot slot;
>         if (Reflector.ForgeItem_getEquipmentSlot.exists() && (slot = (EntityEquipmentSlot)Reflector.call((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_getEquipmentSlot, (Object[])new Object[]{stack})) != null) {
816a848
>             boolean isShield;
823c855,859
<             return stack.getItem().isShield(stack, null) ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
---
>             boolean bl = isShield = stack.getItem() == Items.SHIELD;
>             if (Reflector.ForgeItem_isShield.exists()) {
>                 isShield = Reflector.callBoolean((Object)stack.getItem(), (ReflectorMethod)Reflector.ForgeItem_isShield, (Object[])new Object[]{stack, null});
>             }
>             return isShield ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
1113a1150,1191
>     }
> 
>     private boolean canSkipUpdate() {
>         double dz;
>         if (this.isChild()) {
>             return false;
>         }
>         if (this.hurtTime > 0) {
>             return false;
>         }
>         if (this.T < 20) {
>             return false;
>         }
>         World world = this.e();
>         if (world == null) {
>             return false;
>         }
>         if (world.playerEntities.size() != 1) {
>             return false;
>         }
>         Entity player = (Entity)world.playerEntities.get(0);
>         double dx = Math.max((double)(Math.abs((double)(this.p - player.posX)) - 16.0), (double)0.0);
>         double distSq = dx * dx + (dz = Math.max((double)(Math.abs((double)(this.r - player.posZ)) - 16.0), (double)0.0)) * dz;
>         return !this.a(distSq);
>     }
> 
>     private void onUpdateMinimal() {
>         float brightness;
>         ++this.idleTime;
>         if (this instanceof EntityMob && (brightness = this.aw()) > 0.5f) {
>             this.idleTime += 2;
>         }
>         this.despawnEntity();
>     }
> 
>     public Team aY() {
>         UUID uuid = this.bm();
>         if (this.teamUuid != uuid) {
>             this.teamUuid = uuid;
>             this.teamUuidString = uuid.toString();
>         }
>         return this.l.getScoreboard().getPlayersTeam(this.teamUuidString);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/network/PacketThreadUtil$1.java ../optifine_patch/src/main/java/net/minecraft/network/PacketThreadUtil$1.java
8a9
>  *  net.minecraft.network.PacketThreadUtil
13a15
> import net.minecraft.network.PacketThreadUtil;
14a17,19
> /*
>  * Exception performing whole class analysis ignored.
>  */
17,18c22,23
<     final /* synthetic */ Packet field_180030_a;
<     final /* synthetic */ INetHandler field_180029_b;
---
>     final /* synthetic */ Packet val$packetIn;
>     final /* synthetic */ INetHandler val$processor;
21,22c26,27
<         this.field_180030_a = packet;
<         this.field_180029_b = iNetHandler;
---
>         this.val$packetIn = packet;
>         this.val$processor = iNetHandler;
26c31,32
<         this.field_180030_a.processPacket(this.field_180029_b);
---
>         PacketThreadUtil.clientPreProcessPacket((Packet)this.val$packetIn);
>         this.val$packetIn.processPacket(this.val$processor);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/network/PacketThreadUtil.java ../optifine_patch/src/main/java/net/minecraft/network/PacketThreadUtil.java
4a5,6
>  *  Config
>  *  java.lang.Integer
9a12,14
>  *  net.minecraft.network.play.server.SPacketJoinGame
>  *  net.minecraft.network.play.server.SPacketPlayerPosLook
>  *  net.minecraft.network.play.server.SPacketRespawn
16a22,24
> import net.minecraft.network.play.server.SPacketJoinGame;
> import net.minecraft.network.play.server.SPacketPlayerPosLook;
> import net.minecraft.network.play.server.SPacketRespawn;
20,22c28,32
<     public static <T extends INetHandler> void checkThreadAndEnqueue(Packet<T> packet, T t, IThreadListener iThreadListener) throws ThreadQuickExitException {
<         if (!iThreadListener.isCallingFromMinecraftThread()) {
<             iThreadListener.addScheduledTask((Runnable)new /* Unavailable Anonymous Inner Class!! */);
---
>     public static int lastDimensionId = Integer.MIN_VALUE;
> 
>     public static <T extends INetHandler> void checkThreadAndEnqueue(Packet<T> packetIn, T processor, IThreadListener scheduler) throws ThreadQuickExitException {
>         if (!scheduler.isCallingFromMinecraftThread()) {
>             scheduler.addScheduledTask((Runnable)new /* Unavailable Anonymous Inner Class!! */);
23a34,49
>         }
>         PacketThreadUtil.clientPreProcessPacket(packetIn);
>     }
> 
>     protected static void clientPreProcessPacket(Packet packetIn) {
>         if (packetIn instanceof SPacketPlayerPosLook) {
>             Config.getRenderGlobal().onPlayerPositionSet();
>         }
>         if (packetIn instanceof SPacketRespawn) {
>             SPacketRespawn respawn = (SPacketRespawn)packetIn;
>             lastDimensionId = respawn.getDimensionID();
>         } else if (packetIn instanceof SPacketJoinGame) {
>             SPacketJoinGame joinGame = (SPacketJoinGame)packetIn;
>             lastDimensionId = joinGame.getDimension();
>         } else {
>             lastDimensionId = Integer.MIN_VALUE;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/network/datasync/EntityDataManager$DataEntry.java ../optifine_patch/src/main/java/net/minecraft/network/datasync/EntityDataManager$DataEntry.java
45a46,50
> 
>     static /* synthetic */ boolean access$002(EntityDataManager.DataEntry x0, boolean x1) {
>         x0.dirty = x1;
>         return x0.dirty;
>     }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/network/datasync/EntityDataManager.java ../optifine_patch/src/main/java/net/minecraft/network/datasync/EntityDataManager.java
27a28
>  *  net.minecraft.init.Biomes
34,35c35,36
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.minecraft.util.math.BlockPos
>  *  net.minecraft.world.biome.Biome
55a57
> import net.minecraft.init.Biomes;
62,63c64,65
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.minecraft.util.math.BlockPos;
> import net.minecraft.world.biome.Biome;
67a70,72
> /*
>  * Exception performing whole class analysis ignored.
>  */
75a81,82
>     public Biome spawnBiome = Biomes.PLAINS;
>     public BlockPos spawnPosition = BlockPos.ORIGIN;
83,89c90,94
<         try {
<             Class oclass = Class.forName((String)Thread.currentThread().getStackTrace()[2].getClassName());
<             if (!oclass.equals(clazz)) {
<                 if (LOGGER.isDebugEnabled()) {
<                     LOGGER.warn("defineId called for: {} from {}", (Object)clazz, (Object)oclass, (Object)new RuntimeException());
<                 } else {
<                     LOGGER.warn("defineId called for: {} from {}", (Object)clazz, (Object)oclass);
---
>         if (LOGGER.isDebugEnabled()) {
>             try {
>                 Class oclass = Class.forName((String)Thread.currentThread().getStackTrace()[2].getClassName());
>                 if (!oclass.equals(clazz)) {
>                     LOGGER.debug("defineId called for: {} from {}", (Object)clazz, (Object)oclass, (Object)new RuntimeException());
92,94c97,99
<         }
<         catch (ClassNotFoundException oclass) {
<             // empty catch block
---
>             catch (ClassNotFoundException oclass) {
>                 // empty catch block
>             }
109c114
<             throw new IllegalArgumentException("Data value id is too big with " + j + "! (Max is 254)");
---
>             throw new IllegalArgumentException("Data value id is too big with " + j + "! (Max is " + 254 + ")");
118c123
<             throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is 254)");
---
>             throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 254 + ")");
124c129
<             throw new IllegalArgumentException("Unregistered serializer " + String.valueOf((Object)key.getSerializer()) + " for " + i + "!");
---
>             throw new IllegalArgumentException("Unregistered serializer " + key.getSerializer() + " for " + i + "!");
168c173
<         this.getEntry(key).dirty = true;
---
>         DataEntry.access$002(this.getEntry(key), (boolean)true);
233c238
<             throw new EncoderException("Unknown serializer type " + String.valueOf((Object)dataparameter.getSerializer()));
---
>             throw new EncoderException("Unknown serializer type " + dataparameter.getSerializer());
258d262
<     @SideOnly(value=Side.CLIENT)
271d274
<     @SideOnly(value=Side.CLIENT)
diff -r ../optifine_unpatch/src/main/java/net/minecraft/potion/PotionUtils.java ../optifine_patch/src/main/java/net/minecraft/potion/PotionUtils.java
4a5
>  *  Config
28a30
>  *  net.optifine.CustomColors
52a55
> import net.optifine.CustomColors;
55,56c58,59
<     public static List<PotionEffect> getEffectsFromStack(ItemStack itemStack) {
<         return PotionUtils.getEffectsFromTag(itemStack.getTagCompound());
---
>     public static List<PotionEffect> getEffectsFromStack(ItemStack stack) {
>         return PotionUtils.getEffectsFromTag(stack.getTagCompound());
59,63c62,66
<     public static List<PotionEffect> mergeEffects(PotionType potionType, Collection<PotionEffect> collection) {
<         ArrayList arrayList = Lists.newArrayList();
<         arrayList.addAll((Collection)potionType.getEffects());
<         arrayList.addAll(collection);
<         return arrayList;
---
>     public static List<PotionEffect> mergeEffects(PotionType potionIn, Collection<PotionEffect> effects) {
>         ArrayList list = Lists.newArrayList();
>         list.addAll((Collection)potionIn.getEffects());
>         list.addAll(effects);
>         return list;
66,70c69,73
<     public static List<PotionEffect> getEffectsFromTag(@Nullable NBTTagCompound nBTTagCompound) {
<         ArrayList arrayList = Lists.newArrayList();
<         arrayList.addAll((Collection)PotionUtils.getPotionTypeFromNBT(nBTTagCompound).getEffects());
<         PotionUtils.addCustomPotionEffectToList(nBTTagCompound, (List<PotionEffect>)arrayList);
<         return arrayList;
---
>     public static List<PotionEffect> getEffectsFromTag(@Nullable NBTTagCompound tag) {
>         ArrayList list = Lists.newArrayList();
>         list.addAll((Collection)PotionUtils.getPotionTypeFromNBT(tag).getEffects());
>         PotionUtils.addCustomPotionEffectToList(tag, (List<PotionEffect>)list);
>         return list;
73,74c76,77
<     public static List<PotionEffect> getFullEffectsFromItem(ItemStack itemStack) {
<         return PotionUtils.getFullEffectsFromTag(itemStack.getTagCompound());
---
>     public static List<PotionEffect> getFullEffectsFromItem(ItemStack itemIn) {
>         return PotionUtils.getFullEffectsFromTag(itemIn.getTagCompound());
77,80c80,83
<     public static List<PotionEffect> getFullEffectsFromTag(@Nullable NBTTagCompound nBTTagCompound) {
<         ArrayList arrayList = Lists.newArrayList();
<         PotionUtils.addCustomPotionEffectToList(nBTTagCompound, (List<PotionEffect>)arrayList);
<         return arrayList;
---
>     public static List<PotionEffect> getFullEffectsFromTag(@Nullable NBTTagCompound tag) {
>         ArrayList list = Lists.newArrayList();
>         PotionUtils.addCustomPotionEffectToList(tag, (List<PotionEffect>)list);
>         return list;
83,90c86,93
<     public static void addCustomPotionEffectToList(@Nullable NBTTagCompound nBTTagCompound, List<PotionEffect> list) {
<         if (nBTTagCompound != null && nBTTagCompound.hasKey("CustomPotionEffects", 9)) {
<             NBTTagList nBTTagList = nBTTagCompound.getTagList("CustomPotionEffects", 10);
<             for (int i = 0; i < nBTTagList.tagCount(); ++i) {
<                 NBTTagCompound nBTTagCompound2 = nBTTagList.getCompoundTagAt(i);
<                 PotionEffect \u26032 = PotionEffect.readCustomPotionEffectFromNBT((NBTTagCompound)nBTTagCompound2);
<                 if (\u26032 == null) continue;
<                 list.add((Object)\u26032);
---
>     public static void addCustomPotionEffectToList(@Nullable NBTTagCompound tag, List<PotionEffect> effectList) {
>         if (tag != null && tag.hasKey("CustomPotionEffects", 9)) {
>             NBTTagList nbttaglist = tag.getTagList("CustomPotionEffects", 10);
>             for (int i = 0; i < nbttaglist.tagCount(); ++i) {
>                 NBTTagCompound nbttagcompound = nbttaglist.getCompoundTagAt(i);
>                 PotionEffect potioneffect = PotionEffect.readCustomPotionEffectFromNBT((NBTTagCompound)nbttagcompound);
>                 if (potioneffect == null) continue;
>                 effectList.add((Object)potioneffect);
95,98c98,101
<     public static int getColor(ItemStack itemStack) {
<         NBTTagCompound nBTTagCompound = itemStack.getTagCompound();
<         if (nBTTagCompound != null && nBTTagCompound.hasKey("CustomPotionColor", 99)) {
<             return nBTTagCompound.getInteger("CustomPotionColor");
---
>     public static int getColor(ItemStack p_190932_0_) {
>         NBTTagCompound nbttagcompound = p_190932_0_.getTagCompound();
>         if (nbttagcompound != null && nbttagcompound.hasKey("CustomPotionColor", 99)) {
>             return nbttagcompound.getInteger("CustomPotionColor");
100c103
<         return PotionUtils.getPotionFromItem(itemStack) == PotionTypes.EMPTY ? 0xF800F8 : PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromStack(itemStack));
---
>         return PotionUtils.getPotionFromItem(p_190932_0_) == PotionTypes.EMPTY ? 0xF800F8 : PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromStack(p_190932_0_));
103,104c106,107
<     public static int getPotionColor(PotionType potionType) {
<         return potionType == PotionTypes.EMPTY ? 0xF800F8 : PotionUtils.getPotionColorFromEffectList((Collection<PotionEffect>)potionType.getEffects());
---
>     public static int getPotionColor(PotionType potionIn) {
>         return potionIn == PotionTypes.EMPTY ? 0xF800F8 : PotionUtils.getPotionColorFromEffectList((Collection<PotionEffect>)potionIn.getEffects());
107,110c110,115
<     public static int getPotionColorFromEffectList(Collection<PotionEffect> collection) {
<         int n;
<         int n2 = 3694022;
<         if (collection.isEmpty()) {
---
>     public static int getPotionColorFromEffectList(Collection<PotionEffect> effects) {
>         int i = 3694022;
>         if (effects.isEmpty()) {
>             if (Config.isCustomColors()) {
>                 return CustomColors.getPotionColor(null, (int)i);
>             }
113,124c118,132
<         float \u26032 = 0.0f;
<         float \u26033 = 0.0f;
<         float \u26034 = 0.0f;
<         n = 0;
<         for (PotionEffect potionEffect : collection) {
<             if (!potionEffect.doesShowParticles()) continue;
<             int n3 = potionEffect.getPotion().getLiquidColor();
<             \u2603 = potionEffect.getAmplifier() + 1;
<             \u26032 += (float)(\u2603 * (n3 >> 16 & 0xFF)) / 255.0f;
<             \u26033 += (float)(\u2603 * (n3 >> 8 & 0xFF)) / 255.0f;
<             \u26034 += (float)(\u2603 * (n3 >> 0 & 0xFF)) / 255.0f;
<             n += \u2603;
---
>         float f = 0.0f;
>         float f1 = 0.0f;
>         float f2 = 0.0f;
>         int j = 0;
>         for (PotionEffect potioneffect : effects) {
>             if (!potioneffect.doesShowParticles()) continue;
>             int k = potioneffect.getPotion().getLiquidColor();
>             if (Config.isCustomColors()) {
>                 k = CustomColors.getPotionColor((Potion)potioneffect.getPotion(), (int)k);
>             }
>             int l = potioneffect.getAmplifier() + 1;
>             f += (float)(l * (k >> 16 & 0xFF)) / 255.0f;
>             f1 += (float)(l * (k >> 8 & 0xFF)) / 255.0f;
>             f2 += (float)(l * (k >> 0 & 0xFF)) / 255.0f;
>             j += l;
126c134
<         if (n == 0) {
---
>         if (j == 0) {
129,132c137,140
<         \u26032 = \u26032 / (float)n * 255.0f;
<         \u26033 = \u26033 / (float)n * 255.0f;
<         \u26034 = \u26034 / (float)n * 255.0f;
<         return (int)\u26032 << 16 | (int)\u26033 << 8 | (int)\u26034;
---
>         f = f / (float)j * 255.0f;
>         f1 = f1 / (float)j * 255.0f;
>         f2 = f2 / (float)j * 255.0f;
>         return (int)f << 16 | (int)f1 << 8 | (int)f2;
135,136c143,144
<     public static PotionType getPotionFromItem(ItemStack itemStack) {
<         return PotionUtils.getPotionTypeFromNBT(itemStack.getTagCompound());
---
>     public static PotionType getPotionFromItem(ItemStack itemIn) {
>         return PotionUtils.getPotionTypeFromNBT(itemIn.getTagCompound());
139,143c147,148
<     public static PotionType getPotionTypeFromNBT(@Nullable NBTTagCompound nBTTagCompound) {
<         if (nBTTagCompound == null) {
<             return PotionTypes.EMPTY;
<         }
<         return PotionType.getPotionTypeForName((String)nBTTagCompound.getString("Potion"));
---
>     public static PotionType getPotionTypeFromNBT(@Nullable NBTTagCompound tag) {
>         return tag == null ? PotionTypes.EMPTY : PotionType.getPotionTypeForName((String)tag.getString("Potion"));
146,153c151,158
<     public static ItemStack addPotionToItemStack(ItemStack itemStack2, PotionType potionType) {
<         ResourceLocation resourceLocation = (ResourceLocation)PotionType.REGISTRY.getNameForObject((Object)potionType);
<         if (potionType == PotionTypes.EMPTY) {
<             if (itemStack2.hasTagCompound()) {
<                 NBTTagCompound nBTTagCompound = itemStack2.getTagCompound();
<                 nBTTagCompound.removeTag("Potion");
<                 if (nBTTagCompound.isEmpty()) {
<                     itemStack2.setTagCompound(null);
---
>     public static ItemStack addPotionToItemStack(ItemStack itemIn, PotionType potionIn) {
>         ResourceLocation resourcelocation = (ResourceLocation)PotionType.REGISTRY.getNameForObject((Object)potionIn);
>         if (potionIn == PotionTypes.EMPTY) {
>             if (itemIn.hasTagCompound()) {
>                 NBTTagCompound nbttagcompound = itemIn.getTagCompound();
>                 nbttagcompound.removeTag("Potion");
>                 if (nbttagcompound.isEmpty()) {
>                     itemIn.setTagCompound((NBTTagCompound)null);
157,186c162,188
<             ItemStack itemStack2;
<             NBTTagCompound \u26032 = itemStack2.hasTagCompound() ? itemStack2.getTagCompound() : new NBTTagCompound();
<             \u26032.setString("Potion", resourceLocation.toString());
<             itemStack2.setTagCompound(\u26032);
<         }
<         return itemStack2;
<     }
< 
<     public static ItemStack appendEffects(ItemStack itemStack, Collection<PotionEffect> collection) {
<         if (collection.isEmpty()) {
<             return itemStack;
<         }
<         NBTTagCompound nBTTagCompound = (NBTTagCompound)MoreObjects.firstNonNull((Object)itemStack.getTagCompound(), (Object)new NBTTagCompound());
<         NBTTagList \u26032 = nBTTagCompound.getTagList("CustomPotionEffects", 9);
<         for (PotionEffect potionEffect : collection) {
<             \u26032.appendTag((NBTBase)potionEffect.writeCustomPotionEffectToNBT(new NBTTagCompound()));
<         }
<         nBTTagCompound.setTag("CustomPotionEffects", (NBTBase)\u26032);
<         itemStack.setTagCompound(nBTTagCompound);
<         return itemStack;
<     }
< 
<     public static void addPotionTooltip(ItemStack itemStack, List<String> list2, float f) {
<         List<String> list2;
<         String string;
<         List<PotionEffect> list3 = PotionUtils.getEffectsFromStack(itemStack);
<         ArrayList \u26032 = Lists.newArrayList();
<         if (list3.isEmpty()) {
<             String string2 = I18n.translateToLocal((String)"effect.none").trim();
<             list2.add((Object)(TextFormatting.GRAY + string2));
---
>             NBTTagCompound nbttagcompound1 = itemIn.hasTagCompound() ? itemIn.getTagCompound() : new NBTTagCompound();
>             nbttagcompound1.setString("Potion", resourcelocation.toString());
>             itemIn.setTagCompound(nbttagcompound1);
>         }
>         return itemIn;
>     }
> 
>     public static ItemStack appendEffects(ItemStack itemIn, Collection<PotionEffect> effects) {
>         if (effects.isEmpty()) {
>             return itemIn;
>         }
>         NBTTagCompound nbttagcompound = (NBTTagCompound)MoreObjects.firstNonNull((Object)itemIn.getTagCompound(), (Object)new NBTTagCompound());
>         NBTTagList nbttaglist = nbttagcompound.getTagList("CustomPotionEffects", 9);
>         for (PotionEffect potioneffect : effects) {
>             nbttaglist.appendTag((NBTBase)potioneffect.writeCustomPotionEffectToNBT(new NBTTagCompound()));
>         }
>         nbttagcompound.setTag("CustomPotionEffects", (NBTBase)nbttaglist);
>         itemIn.setTagCompound(nbttagcompound);
>         return itemIn;
>     }
> 
>     public static void addPotionTooltip(ItemStack itemIn, List<String> lores, float durationFactor) {
>         List<PotionEffect> list = PotionUtils.getEffectsFromStack(itemIn);
>         ArrayList list1 = Lists.newArrayList();
>         if (list.isEmpty()) {
>             String s = I18n.translateToLocal((String)"effect.none").trim();
>             lores.add((Object)(TextFormatting.GRAY + s));
188,196c190,198
<             for (PotionEffect \u26033 : list3) {
<                 string = I18n.translateToLocal((String)\u26033.getEffectName()).trim();
<                 Potion \u26034 = \u26033.getPotion();
<                 Map \u26035 = \u26034.getAttributeModifierMap();
<                 if (!\u26035.isEmpty()) {
<                     for (Map.Entry entry : \u26035.entrySet()) {
<                         AttributeModifier attributeModifier = (AttributeModifier)entry.getValue();
<                         \u2603 = new AttributeModifier(attributeModifier.getName(), \u26034.getAttributeModifierAmount(\u26033.getAmplifier(), attributeModifier), attributeModifier.getOperation());
<                         \u26032.add((Object)new Tuple((Object)((IAttribute)entry.getKey()).getName(), (Object)\u2603));
---
>             for (PotionEffect potioneffect : list) {
>                 String s1 = I18n.translateToLocal((String)potioneffect.getEffectName()).trim();
>                 Potion potion = potioneffect.getPotion();
>                 Map map = potion.getAttributeModifierMap();
>                 if (!map.isEmpty()) {
>                     for (Map.Entry entry : map.entrySet()) {
>                         AttributeModifier attributemodifier = (AttributeModifier)entry.getValue();
>                         AttributeModifier attributemodifier1 = new AttributeModifier(attributemodifier.getName(), potion.getAttributeModifierAmount(potioneffect.getAmplifier(), attributemodifier), attributemodifier.getOperation());
>                         list1.add((Object)new Tuple((Object)((IAttribute)entry.getKey()).getName(), (Object)attributemodifier1));
199,200c201,202
<                 if (\u26033.getAmplifier() > 0) {
<                     string = string + " " + I18n.translateToLocal((String)("potion.potency." + \u26033.getAmplifier())).trim();
---
>                 if (potioneffect.getAmplifier() > 0) {
>                     s1 = s1 + " " + I18n.translateToLocal((String)("potion.potency." + potioneffect.getAmplifier())).trim();
202,203c204,205
<                 if (\u26033.getDuration() > 20) {
<                     string = string + " (" + Potion.getPotionDurationString((PotionEffect)\u26033, (float)f) + ")";
---
>                 if (potioneffect.getDuration() > 20) {
>                     s1 = s1 + " (" + Potion.getPotionDurationString((PotionEffect)potioneffect, (float)durationFactor) + ")";
205,206c207,208
<                 if (\u26034.isBadEffect()) {
<                     list2.add((Object)(TextFormatting.RED + string));
---
>                 if (potion.isBadEffect()) {
>                     lores.add((Object)(TextFormatting.RED + s1));
209c211
<                 list2.add((Object)(TextFormatting.BLUE + string));
---
>                 lores.add((Object)(TextFormatting.BLUE + s1));
212,220c214,222
<         if (!\u26032.isEmpty()) {
<             list2.add((Object)"");
<             list2.add((Object)(TextFormatting.DARK_PURPLE + I18n.translateToLocal((String)"potion.whenDrank")));
<             for (PotionEffect \u26033 : \u26032) {
<                 string = (AttributeModifier)\u26033.getSecond();
<                 double \u26036 = string.getAmount();
<                 double \u26037 = string.getOperation() == 1 || string.getOperation() == 2 ? string.getAmount() * 100.0 : string.getAmount();
<                 if (\u26036 > 0.0) {
<                     list2.add((Object)(TextFormatting.BLUE + I18n.translateToLocalFormatted((String)("attribute.modifier.plus." + string.getOperation()), (Object[])new Object[]{ItemStack.DECIMALFORMAT.format(\u26037), I18n.translateToLocal((String)("attribute.name." + (String)\u26033.getFirst()))})));
---
>         if (!list1.isEmpty()) {
>             lores.add((Object)"");
>             lores.add((Object)(TextFormatting.DARK_PURPLE + I18n.translateToLocal((String)"potion.whenDrank")));
>             for (Tuple tuple : list1) {
>                 AttributeModifier attributemodifier2 = (AttributeModifier)tuple.getSecond();
>                 double d0 = attributemodifier2.getAmount();
>                 double d1 = attributemodifier2.getOperation() != 1 && attributemodifier2.getOperation() != 2 ? attributemodifier2.getAmount() : attributemodifier2.getAmount() * 100.0;
>                 if (d0 > 0.0) {
>                     lores.add((Object)(TextFormatting.BLUE + I18n.translateToLocalFormatted((String)("attribute.modifier.plus." + attributemodifier2.getOperation()), (Object[])new Object[]{ItemStack.DECIMALFORMAT.format(d1), I18n.translateToLocal((String)("attribute.name." + (String)tuple.getFirst()))})));
223,224c225,226
<                 if (!(\u26036 < 0.0)) continue;
<                 list2.add((Object)(TextFormatting.RED + I18n.translateToLocalFormatted((String)("attribute.modifier.take." + string.getOperation()), (Object[])new Object[]{ItemStack.DECIMALFORMAT.format(\u26037 *= -1.0), I18n.translateToLocal((String)("attribute.name." + (String)\u26033.getFirst()))})));
---
>                 if (!(d0 < 0.0)) continue;
>                 lores.add((Object)(TextFormatting.RED + I18n.translateToLocalFormatted((String)("attribute.modifier.take." + attributemodifier2.getOperation()), (Object[])new Object[]{ItemStack.DECIMALFORMAT.format(d1 *= -1.0), I18n.translateToLocal((String)("attribute.name." + (String)tuple.getFirst()))})));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/profiler/Profiler.java ../optifine_patch/src/main/java/net/minecraft/profiler/Profiler.java
4a5
>  *  Config
8d8
<  *  java.lang.Deprecated
17a18
>  *  net.minecraft.client.renderer.GlStateManager
19,20c20
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.Lagometer
32a33
> import net.minecraft.client.renderer.GlStateManager;
34,35c35
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.Lagometer;
45a46,57
>     public boolean profilerGlobalEnabled;
>     private boolean profilerLocalEnabled = this.profilerGlobalEnabled = true;
>     private static final String SCHEDULED_EXECUTABLES = "scheduledExecutables";
>     private static final String TICK = "tick";
>     private static final String PRE_RENDER_ERRORS = "preRenderErrors";
>     private static final String RENDER = "render";
>     private static final String DISPLAY = "display";
>     private static final int HASH_SCHEDULED_EXECUTABLES = "scheduledExecutables".hashCode();
>     private static final int HASH_TICK = "tick".hashCode();
>     private static final int HASH_PRE_RENDER_ERRORS = "preRenderErrors".hashCode();
>     private static final int HASH_RENDER = "render".hashCode();
>     private static final int HASH_DISPLAY = "display".hashCode();
50a63
>         this.profilerLocalEnabled = this.profilerGlobalEnabled;
53a67,89
>         int hashName;
>         if (Lagometer.isActive()) {
>             hashName = name.hashCode();
>             if (hashName == HASH_SCHEDULED_EXECUTABLES && name.equals((Object)SCHEDULED_EXECUTABLES)) {
>                 Lagometer.timerScheduledExecutables.start();
>             } else if (hashName == HASH_TICK && name.equals((Object)TICK) && Config.isMinecraftThread()) {
>                 Lagometer.timerScheduledExecutables.end();
>                 Lagometer.timerTick.start();
>             } else if (hashName == HASH_PRE_RENDER_ERRORS && name.equals((Object)PRE_RENDER_ERRORS)) {
>                 Lagometer.timerTick.end();
>             }
>         }
>         if (Config.isFastRender()) {
>             hashName = name.hashCode();
>             if (hashName == HASH_RENDER && name.equals((Object)RENDER)) {
>                 GlStateManager.clearEnabled = false;
>             } else if (hashName == HASH_DISPLAY && name.equals((Object)DISPLAY)) {
>                 GlStateManager.clearEnabled = true;
>             }
>         }
>         if (!this.profilerLocalEnabled) {
>             return;
>         }
64a101,103
>         if (!this.profilerLocalEnabled) {
>             return;
>         }
70a110,112
>         if (!this.profilerLocalEnabled) {
>             return;
>         }
119c161
<             this.profilingMap.put((Object)s3, (Object)((Long)this.profilingMap.get((Object)s3) * 999L / 1000L));
---
>             this.profilingMap.put((Object)s3, (Object)((Long)this.profilingMap.get((Object)s3) * 950L / 1000L));
129a172,174
>         if (!this.profilerLocalEnabled) {
>             return;
>         }
134,138d178
<     public String getNameOfLastSection() {
<         return this.sectionList.isEmpty() ? "[UNKNOWN]" : (String)this.sectionList.get(this.sectionList.size() - 1);
<     }
< 
<     @SideOnly(value=Side.CLIENT)
139a180,182
>         if (!this.profilerLocalEnabled) {
>             return;
>         }
144c187,190
<     @Deprecated
---
>     public String getNameOfLastSection() {
>         return this.sectionList.isEmpty() ? "[UNKNOWN]" : (String)this.sectionList.get(this.sectionList.size() - 1);
>     }
> 
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/integrated/IntegratedServer$3.java ../optifine_patch/src/main/java/net/minecraft/server/integrated/IntegratedServer$3.java
9a10
>  *  net.minecraft.server.integrated.IntegratedServer
14a16
> import net.minecraft.server.integrated.IntegratedServer;
15a18,20
> /*
>  * Exception performing whole class analysis ignored.
>  */
23c28
<             if (entityplayermp.bm().equals((Object)IntegratedServer.this.mc.player.bm())) continue;
---
>             if (entityplayermp.bm().equals((Object)IntegratedServer.access$000((IntegratedServer)IntegratedServer.this).player.bm())) continue;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/integrated/IntegratedServer.java ../optifine_patch/src/main/java/net/minecraft/server/integrated/IntegratedServer.java
4a5
>  *  Config
10a12
>  *  java.lang.Boolean
15a18,19
>  *  java.util.Arrays
>  *  java.util.List
20a25
>  *  net.minecraft.client.settings.GameSettings
23a29,32
>  *  net.minecraft.nbt.NBTTagCompound
>  *  net.minecraft.network.Packet
>  *  net.minecraft.network.PacketThreadUtil
>  *  net.minecraft.network.play.server.SPacketChangeGameState
32a42,43
>  *  net.minecraft.util.math.BlockPos
>  *  net.minecraft.world.DifficultyInstance
45,51c56,59
<  *  net.minecraftforge.common.DimensionManager
<  *  net.minecraftforge.common.MinecraftForge
<  *  net.minecraftforge.event.world.WorldEvent$Load
<  *  net.minecraftforge.fml.common.FMLCommonHandler
<  *  net.minecraftforge.fml.common.eventhandler.Event
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
---
>  *  net.optifine.ClearWater
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorConstructor
>  *  net.optifine.reflect.ReflectorMethod
63a72,73
> import java.util.Arrays;
> import java.util.List;
68a79
> import net.minecraft.client.settings.GameSettings;
71a83,86
> import net.minecraft.nbt.NBTTagCompound;
> import net.minecraft.network.Packet;
> import net.minecraft.network.PacketThreadUtil;
> import net.minecraft.network.play.server.SPacketChangeGameState;
80a96,97
> import net.minecraft.util.math.BlockPos;
> import net.minecraft.world.DifficultyInstance;
93,99c110,113
< import net.minecraftforge.common.DimensionManager;
< import net.minecraftforge.common.MinecraftForge;
< import net.minecraftforge.event.world.WorldEvent;
< import net.minecraftforge.fml.common.FMLCommonHandler;
< import net.minecraftforge.fml.common.eventhandler.Event;
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
---
> import net.optifine.ClearWater;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorConstructor;
> import net.optifine.reflect.ReflectorMethod;
103d116
< @SideOnly(value=Side.CLIENT)
111a125,128
>     private long ticksSaveLast = 0L;
>     public World difficultyUpdateWorld = null;
>     public BlockPos difficultyUpdatePos = null;
>     public DifficultyInstance difficultyLast = null;
114a132
>         NBTTagCompound nbt;
123a142,148
>         ISaveHandler isavehandler = this.getActiveAnvilConverter().getSaveLoader(folderNameIn, false);
>         WorldInfo worldinfo = isavehandler.loadWorldInfo();
>         if (worldinfo != null && (nbt = worldinfo.getPlayerNBTTagCompound()) != null && nbt.hasKey("Dimension")) {
>             int dim;
>             PacketThreadUtil.lastDimensionId = dim = nbt.getInteger("Dimension");
>             this.mc.loadingScreen.setLoadingProgress(-1);
>         }
131a157,161
>         boolean forge = Reflector.DimensionManager.exists();
>         if (!forge) {
>             this.worlds = new WorldServer[3];
>             this.timeOfLastDimensionTick = new long[this.worlds.length][100];
>         }
140,155c170,210
<         WorldServer overWorld = this.isDemo() ? (WorldServer)new WorldServerDemo((MinecraftServer)this, isavehandler, worldinfo, 0, this.profiler).b() : (WorldServer)new WorldServer((MinecraftServer)this, isavehandler, worldinfo, 0, this.profiler).init();
<         overWorld.initialize(this.worldSettings);
<         Integer[] integerArray = DimensionManager.getStaticDimensionIDs();
<         int n = integerArray.length;
<         for (int i = 0; i < n; ++i) {
<             int dim = integerArray[i];
<             WorldServer world = dim == 0 ? overWorld : (WorldServer)new WorldServerMulti((MinecraftServer)this, isavehandler, dim, overWorld, this.profiler).init();
<             world.a((IWorldEventListener)new ServerWorldEventHandler((MinecraftServer)this, world));
<             if (!this.isSinglePlayer()) {
<                 world.V().setGameType(this.getGameType());
<             }
<             MinecraftForge.EVENT_BUS.post((Event)new WorldEvent.Load((World)world));
<         }
<         this.getPlayerList().setPlayerManager(new WorldServer[]{overWorld});
<         if (overWorld.V().getDifficulty() == null) {
<             this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
---
>         if (forge) {
>             Integer[] dimIds;
>             WorldServer overWorld = this.isDemo() ? (WorldServer)new WorldServerDemo((MinecraftServer)this, isavehandler, worldinfo, 0, this.profiler).b() : (WorldServer)new WorldServer((MinecraftServer)this, isavehandler, worldinfo, 0, this.profiler).init();
>             overWorld.initialize(this.worldSettings);
>             Integer[] integerArray = dimIds = (Integer[])Reflector.call((ReflectorMethod)Reflector.DimensionManager_getStaticDimensionIDs, (Object[])new Object[0]);
>             int n = integerArray.length;
>             for (int i = 0; i < n; ++i) {
>                 int dim = integerArray[i];
>                 WorldServer world = dim == 0 ? overWorld : (WorldServer)new WorldServerMulti((MinecraftServer)this, isavehandler, dim, overWorld, this.profiler).init();
>                 world.a((IWorldEventListener)new ServerWorldEventHandler((MinecraftServer)this, world));
>                 if (!this.isSinglePlayer()) {
>                     world.V().setGameType(this.getGameType());
>                 }
>                 if (!Reflector.EventBus.exists()) continue;
>                 Reflector.postForgeBusEvent((ReflectorConstructor)Reflector.WorldEvent_Load_Constructor, (Object[])new Object[]{world});
>             }
>             this.getPlayerList().setPlayerManager(new WorldServer[]{overWorld});
>             if (overWorld.V().getDifficulty() == null) {
>                 this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
>             }
>         } else {
>             for (int i = 0; i < this.worlds.length; ++i) {
>                 int j = 0;
>                 if (i == 1) {
>                     j = -1;
>                 }
>                 if (i == 2) {
>                     j = 1;
>                 }
>                 if (i == 0) {
>                     this.worlds[i] = this.isDemo() ? (WorldServer)new WorldServerDemo((MinecraftServer)this, isavehandler, worldinfo, j, this.profiler).b() : (WorldServer)new WorldServer((MinecraftServer)this, isavehandler, worldinfo, j, this.profiler).init();
>                     this.worlds[i].initialize(this.worldSettings);
>                 } else {
>                     this.worlds[i] = (WorldServer)new WorldServerMulti((MinecraftServer)this, isavehandler, j, this.worlds[0], this.profiler).init();
>                 }
>                 this.worlds[i].a((IWorldEventListener)new ServerWorldEventHandler((MinecraftServer)this, this.worlds[i]));
>             }
>             this.getPlayerList().setPlayerManager(this.worlds);
>             if (this.worlds[0].V().getDifficulty() == null) {
>                 this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
>             }
160a216
>         Object inst;
169,170c225,229
<         if (!FMLCommonHandler.instance().handleServerAboutToStart((MinecraftServer)this)) {
<             return false;
---
>         if (Reflector.FMLCommonHandler_handleServerAboutToStart.exists()) {
>             inst = Reflector.call((ReflectorMethod)Reflector.FMLCommonHandler_instance, (Object[])new Object[0]);
>             if (!Reflector.callBoolean((Object)inst, (ReflectorMethod)Reflector.FMLCommonHandler_handleServerAboutToStart, (Object[])new Object[]{this})) {
>                 return false;
>             }
174c233,240
<         return FMLCommonHandler.instance().handleServerStarting((MinecraftServer)this);
---
>         if (Reflector.FMLCommonHandler_handleServerStarting.exists()) {
>             inst = Reflector.call((ReflectorMethod)Reflector.FMLCommonHandler_instance, (Object[])new Object[0]);
>             if (Reflector.FMLCommonHandler_handleServerStarting.getReturnType() == Boolean.TYPE) {
>                 return Reflector.callBoolean((Object)inst, (ReflectorMethod)Reflector.FMLCommonHandler_handleServerStarting, (Object[])new Object[]{this});
>             }
>             Reflector.callVoid((Object)inst, (ReflectorMethod)Reflector.FMLCommonHandler_handleServerStarting, (Object[])new Object[]{this});
>         }
>         return true;
180a247
>         this.onTick();
245a313,320
>         if (isSilent) {
>             int ticksSaveInterval;
>             int ticks = this.getTickCounter();
>             if ((long)ticks < this.ticksSaveLast + (long)(ticksSaveInterval = this.mc.gameSettings.ofAutoSaveTicks)) {
>                 return;
>             }
>             this.ticksSaveLast = ticks;
>         }
303c378
<             this.lanServerPing = new ThreadLanServerPing(this.getMOTD(), "" + i);
---
>             this.lanServerPing = new ThreadLanServerPing(this.getMOTD(), i + "");
308c383
<             return "" + i;
---
>             return i + "";
324c399
<         if (this.isServerRunning()) {
---
>         if (!Reflector.MinecraftForge.exists() || this.isServerRunning()) {
348a424,498
>     }
> 
>     private void onTick() {
>         List iws = Arrays.asList((Object[])this.worlds);
>         for (WorldServer ws : iws) {
>             this.onTick(ws);
>         }
>     }
> 
>     public DifficultyInstance getDifficultyAsync(World world, BlockPos blockPos) {
>         this.difficultyUpdateWorld = world;
>         this.difficultyUpdatePos = blockPos;
>         return this.difficultyLast;
>     }
> 
>     private void onTick(WorldServer ws) {
>         if (!Config.isTimeDefault()) {
>             this.fixWorldTime(ws);
>         }
>         if (!Config.isWeatherEnabled()) {
>             this.fixWorldWeather(ws);
>         }
>         if (Config.waterOpacityChanged) {
>             Config.waterOpacityChanged = false;
>             ClearWater.updateWaterOpacity((GameSettings)Config.getGameSettings(), (World)ws);
>         }
>         if (this.difficultyUpdateWorld == ws && this.difficultyUpdatePos != null) {
>             this.difficultyLast = ws.D(this.difficultyUpdatePos);
>             this.difficultyUpdateWorld = null;
>             this.difficultyUpdatePos = null;
>         }
>     }
> 
>     private void fixWorldWeather(WorldServer ws) {
>         WorldInfo worldInfo = ws.V();
>         if (worldInfo.isRaining() || worldInfo.isThundering()) {
>             worldInfo.setRainTime(0);
>             worldInfo.setRaining(false);
>             ws.k(0.0f);
>             worldInfo.setThunderTime(0);
>             worldInfo.setThundering(false);
>             ws.i(0.0f);
>             this.getPlayerList().sendPacketToAllPlayers((Packet)new SPacketChangeGameState(2, 0.0f));
>             this.getPlayerList().sendPacketToAllPlayers((Packet)new SPacketChangeGameState(7, 0.0f));
>             this.getPlayerList().sendPacketToAllPlayers((Packet)new SPacketChangeGameState(8, 0.0f));
>         }
>     }
> 
>     private void fixWorldTime(WorldServer ws) {
>         WorldInfo worldInfo = ws.V();
>         if (worldInfo.getGameType().getID() != 1) {
>             return;
>         }
>         long time = ws.S();
>         long timeOfDay = time % 24000L;
>         if (Config.isTimeDayOnly()) {
>             if (timeOfDay <= 1000L) {
>                 ws.b(time - timeOfDay + 1001L);
>             }
>             if (timeOfDay >= 11000L) {
>                 ws.b(time - timeOfDay + 24001L);
>             }
>         }
>         if (Config.isTimeNightOnly()) {
>             if (timeOfDay <= 14000L) {
>                 ws.b(time - timeOfDay + 14001L);
>             }
>             if (timeOfDay >= 22000L) {
>                 ws.b(time - timeOfDay + 24000L + 14001L);
>             }
>         }
>     }
> 
>     static /* synthetic */ Minecraft access$000(IntegratedServer x0) {
>         return x0.mc;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap$1.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap$1.java
21,26c21,22
<     public boolean apply(@Nullable EntityPlayerMP entityPlayerMP) {
<         return entityPlayerMP != null && !entityPlayerMP.isSpectator();
<     }
< 
<     public /* synthetic */ boolean apply(@Nullable Object object) {
<         return this.apply((EntityPlayerMP)object);
---
>     public boolean apply(@Nullable EntityPlayerMP p_apply_1_) {
>         return p_apply_1_ != null && !p_apply_1_.isSpectator();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap$2.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap$2.java
21,26c21,22
<     public boolean apply(@Nullable EntityPlayerMP entityPlayerMP) {
<         return entityPlayerMP != null && (!entityPlayerMP.isSpectator() || entityPlayerMP.getServerWorld().W().getBoolean("spectatorsGenerateChunks"));
<     }
< 
<     public /* synthetic */ boolean apply(@Nullable Object object) {
<         return this.apply((EntityPlayerMP)object);
---
>     public boolean apply(@Nullable EntityPlayerMP p_apply_1_) {
>         return p_apply_1_ != null && (!p_apply_1_.isSpectator() || p_apply_1_.getServerWorld().W().getBoolean("spectatorsGenerateChunks"));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap$3.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap$3.java
25c25
<     final /* synthetic */ Iterator field_187294_a;
---
>     final /* synthetic */ Iterator val$iterator;
28c28
<         this.field_187294_a = iterator;
---
>         this.val$iterator = iterator;
32,37c32,37
<         while (this.field_187294_a.hasNext()) {
<             PlayerChunkMapEntry playerChunkMapEntry = (PlayerChunkMapEntry)this.field_187294_a.next();
<             Chunk \u26032 = playerChunkMapEntry.getChunk();
<             if (\u26032 == null) continue;
<             if (!\u26032.isLightPopulated() && \u26032.isTerrainPopulated()) {
<                 return \u26032;
---
>         while (this.val$iterator.hasNext()) {
>             PlayerChunkMapEntry playerchunkmapentry = (PlayerChunkMapEntry)this.val$iterator.next();
>             Chunk chunk = playerchunkmapentry.getChunk();
>             if (chunk == null) continue;
>             if (!chunk.isLightPopulated() && chunk.isTerrainPopulated()) {
>                 return chunk;
39,40c39,40
<             if (!\u26032.wasTicked()) {
<                 return \u26032;
---
>             if (!chunk.wasTicked()) {
>                 return chunk;
42,43c42,43
<             if (!playerChunkMapEntry.hasPlayerMatchingInRange(128.0, PlayerChunkMap.access$000())) continue;
<             return \u26032;
---
>             if (!playerchunkmapentry.hasPlayerMatchingInRange(128.0, PlayerChunkMap.access$000())) continue;
>             return chunk;
46,49d45
<     }
< 
<     protected /* synthetic */ Object computeNext() {
<         return this.computeNext();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap$4.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap$4.java
21,26c21,22
<     public int compare(PlayerChunkMapEntry playerChunkMapEntry, PlayerChunkMapEntry playerChunkMapEntry2) {
<         return ComparisonChain.start().compare(playerChunkMapEntry.getClosestPlayerDistance(), playerChunkMapEntry2.getClosestPlayerDistance()).result();
<     }
< 
<     public /* synthetic */ int compare(Object object, Object object2) {
<         return this.compare((PlayerChunkMapEntry)object, (PlayerChunkMapEntry)object2);
---
>     public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_) {
>         return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap$5.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap$5.java
21,26c21,22
<     public int compare(PlayerChunkMapEntry playerChunkMapEntry, PlayerChunkMapEntry playerChunkMapEntry2) {
<         return ComparisonChain.start().compare(playerChunkMapEntry.getClosestPlayerDistance(), playerChunkMapEntry2.getClosestPlayerDistance()).result();
<     }
< 
<     public /* synthetic */ int compare(Object object, Object object2) {
<         return this.compare((PlayerChunkMapEntry)object, (PlayerChunkMapEntry)object2);
---
>     public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_) {
>         return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
diff -r ../optifine_unpatch/src/main/java/net/minecraft/server/management/PlayerChunkMap.java ../optifine_patch/src/main/java/net/minecraft/server/management/PlayerChunkMap.java
4a5
>  *  Config
10a12
>  *  java.lang.Math
13d14
<  *  java.util.ArrayList
15a17,18
>  *  java.util.HashMap
>  *  java.util.HashSet
17a21,23
>  *  java.util.Map
>  *  java.util.Map$Entry
>  *  java.util.PriorityQueue
27a34
>  *  net.optifine.ChunkPosComparator
36d42
< import java.util.ArrayList;
38a45,46
> import java.util.HashMap;
> import java.util.HashSet;
40a49,50
> import java.util.Map;
> import java.util.PriorityQueue;
50a61
> import net.optifine.ChunkPosComparator;
65a77
>     private final Map<EntityPlayerMP, Set<ChunkPos>> mapPlayerPendingEntries = new HashMap();
67,69c79,81
<     public PlayerChunkMap(WorldServer worldServer) {
<         this.world = worldServer;
<         this.setPlayerViewRadius(worldServer.getMinecraftServer().getPlayerList().getViewDistance());
---
>     public PlayerChunkMap(WorldServer serverWorld) {
>         this.world = serverWorld;
>         this.setPlayerViewRadius(serverWorld.getMinecraftServer().getPlayerList().getViewDistance());
82,91c94,125
<         WorldProvider worldProvider;
<         PlayerChunkMapEntry \u260332;
<         int n;
<         long l = this.world.R();
<         if (l - this.previousTotalWorldTime > 8000L) {
<             this.previousTotalWorldTime = l;
<             for (n = 0; n < this.entries.size(); ++n) {
<                 \u260332 = (PlayerChunkMapEntry)this.entries.get(n);
<                 \u260332.update();
<                 \u260332.updateChunkInhabitedTime();
---
>         WorldProvider worldprovider;
>         Set pairs = this.mapPlayerPendingEntries.entrySet();
>         Iterator it = pairs.iterator();
>         while (it.hasNext()) {
>             Map.Entry entry = (Map.Entry)it.next();
>             Set setPending = (Set)entry.getValue();
>             if (setPending.isEmpty()) continue;
>             EntityPlayerMP player = (EntityPlayerMP)entry.getKey();
>             if (player.getServerWorld() != this.world) {
>                 it.remove();
>                 continue;
>             }
>             int countUpdates = this.playerViewRadius / 3 + 1;
>             if (!Config.isLazyChunkLoading()) {
>                 countUpdates = this.playerViewRadius * 2 + 1;
>             }
>             PriorityQueue<ChunkPos> queueNearest = this.getNearest((Set<ChunkPos>)setPending, player, countUpdates);
>             for (ChunkPos chunkPos : queueNearest) {
>                 PlayerChunkMapEntry pcmr = this.getOrCreateEntry(chunkPos.x, chunkPos.z);
>                 if (!pcmr.containsPlayer(player)) {
>                     pcmr.addPlayer(player);
>                 }
>                 setPending.remove((Object)chunkPos);
>             }
>         }
>         long i = this.world.R();
>         if (i - this.previousTotalWorldTime > 8000L) {
>             this.previousTotalWorldTime = i;
>             for (int j = 0; j < this.entries.size(); ++j) {
>                 PlayerChunkMapEntry playerchunkmapentry = (PlayerChunkMapEntry)this.entries.get(j);
>                 playerchunkmapentry.update();
>                 playerchunkmapentry.updateChunkInhabitedTime();
95,96c129,130
<             for (PlayerChunkMapEntry \u260332 : this.dirtyEntries) {
<                 \u260332.update();
---
>             for (PlayerChunkMapEntry playerchunkmapentry2 : this.dirtyEntries) {
>                 playerchunkmapentry2.update();
100c134
<         if (this.sortMissingChunks && l % 4L == 0L) {
---
>         if (this.sortMissingChunks && i % 4L == 0L) {
104c138
<         if (this.sortSendToPlayers && l % 4L == 2L) {
---
>         if (this.sortSendToPlayers && i % 4L == 2L) {
109,117c143,152
<             \u2603 = System.nanoTime() + 50000000L;
<             int n2 = 49;
<             Iterator \u26032 = this.entriesWithoutChunks.iterator();
<             while (\u26032.hasNext()) {
<                 PlayerChunkMapEntry playerChunkMapEntry = (PlayerChunkMapEntry)\u26032.next();
<                 if (playerChunkMapEntry.getChunk() != null || !playerChunkMapEntry.providePlayerChunk(\u2603 = playerChunkMapEntry.hasPlayerMatching(CAN_GENERATE_CHUNKS))) continue;
<                 \u26032.remove();
<                 if (playerChunkMapEntry.sendToPlayers()) {
<                     this.pendingSendToPlayers.remove((Object)playerChunkMapEntry);
---
>             long l = System.nanoTime() + 50000000L;
>             int k = 49;
>             Iterator iterator = this.entriesWithoutChunks.iterator();
>             while (iterator.hasNext()) {
>                 boolean flag;
>                 PlayerChunkMapEntry playerchunkmapentry1 = (PlayerChunkMapEntry)iterator.next();
>                 if (playerchunkmapentry1.getChunk() != null || !playerchunkmapentry1.providePlayerChunk(flag = playerchunkmapentry1.hasPlayerMatching(CAN_GENERATE_CHUNKS))) continue;
>                 iterator.remove();
>                 if (playerchunkmapentry1.sendToPlayers()) {
>                     this.pendingSendToPlayers.remove((Object)playerchunkmapentry1);
119c154
<                 if (--n2 >= 0 && System.nanoTime() <= \u2603) continue;
---
>                 if (--k >= 0 && System.nanoTime() <= l) continue;
124,130c159,165
<             n = 81;
<             \u260332 = this.pendingSendToPlayers.iterator();
<             while (\u260332.hasNext()) {
<                 PlayerChunkMapEntry playerChunkMapEntry = (PlayerChunkMapEntry)\u260332.next();
<                 if (!playerChunkMapEntry.sendToPlayers()) continue;
<                 \u260332.remove();
<                 if (--n >= 0) continue;
---
>             int i1 = 81;
>             Iterator iterator1 = this.pendingSendToPlayers.iterator();
>             while (iterator1.hasNext()) {
>                 PlayerChunkMapEntry playerchunkmapentry3 = (PlayerChunkMapEntry)iterator1.next();
>                 if (!playerchunkmapentry3.sendToPlayers()) continue;
>                 iterator1.remove();
>                 if (--i1 >= 0) continue;
134c169
<         if (this.players.isEmpty() && !(worldProvider = this.world.s).canRespawnHere()) {
---
>         if (this.players.isEmpty() && !(worldprovider = this.world.s).canRespawnHere()) {
139,141c174,176
<     public boolean contains(int n, int n2) {
<         long l = PlayerChunkMap.getIndex(n, n2);
<         return this.entryMap.get(l) != null;
---
>     public boolean contains(int chunkX, int chunkZ) {
>         long i = PlayerChunkMap.getIndex(chunkX, chunkZ);
>         return this.entryMap.get(i) != null;
145,146c180,181
<     public PlayerChunkMapEntry getEntry(int n, int n2) {
<         return (PlayerChunkMapEntry)this.entryMap.get(PlayerChunkMap.getIndex(n, n2));
---
>     public PlayerChunkMapEntry getEntry(int x, int z) {
>         return (PlayerChunkMapEntry)this.entryMap.get(PlayerChunkMap.getIndex(x, z));
149,161c184,206
<     private PlayerChunkMapEntry getOrCreateEntry(int n, int n2) {
<         long l = PlayerChunkMap.getIndex(n, n2);
<         PlayerChunkMapEntry \u26032 = (PlayerChunkMapEntry)this.entryMap.get(l);
<         if (\u26032 == null) {
<             \u26032 = new PlayerChunkMapEntry(this, n, n2);
<             this.entryMap.put(l, (Object)\u26032);
<             this.entries.add((Object)\u26032);
<             if (\u26032.getChunk() == null) {
<                 this.entriesWithoutChunks.add((Object)\u26032);
<             }
<             if (!\u26032.sendToPlayers()) {
<                 this.pendingSendToPlayers.add((Object)\u26032);
<             }
---
>     private PlayerChunkMapEntry getOrCreateEntry(int chunkX, int chunkZ) {
>         long i = PlayerChunkMap.getIndex(chunkX, chunkZ);
>         PlayerChunkMapEntry playerchunkmapentry = (PlayerChunkMapEntry)this.entryMap.get(i);
>         if (playerchunkmapentry == null) {
>             playerchunkmapentry = new PlayerChunkMapEntry(this, chunkX, chunkZ);
>             this.entryMap.put(i, (Object)playerchunkmapentry);
>             this.entries.add((Object)playerchunkmapentry);
>             if (playerchunkmapentry.getChunk() == null) {
>                 this.entriesWithoutChunks.add((Object)playerchunkmapentry);
>             }
>             if (!playerchunkmapentry.sendToPlayers()) {
>                 this.pendingSendToPlayers.add((Object)playerchunkmapentry);
>             }
>         }
>         return playerchunkmapentry;
>     }
> 
>     public void markBlockForUpdate(BlockPos pos) {
>         int j;
>         int i = pos.p() >> 4;
>         PlayerChunkMapEntry playerchunkmapentry = this.getEntry(i, j = pos.r() >> 4);
>         if (playerchunkmapentry != null) {
>             playerchunkmapentry.blockChanged(pos.p() & 0xF, pos.q(), pos.r() & 0xF);
163d207
<         return \u26032;
166,181c210,227
<     public void markBlockForUpdate(BlockPos blockPos) {
<         int n = blockPos.p() >> 4;
<         PlayerChunkMapEntry \u26032 = this.getEntry(n, \u2603 = blockPos.r() >> 4);
<         if (\u26032 != null) {
<             \u26032.blockChanged(blockPos.p() & 0xF, blockPos.q(), blockPos.r() & 0xF);
<         }
<     }
< 
<     public void addPlayer(EntityPlayerMP entityPlayerMP) {
<         int n = (int)entityPlayerMP.p >> 4;
<         \u2603 = (int)entityPlayerMP.r >> 4;
<         entityPlayerMP.managedPosX = entityPlayerMP.p;
<         entityPlayerMP.managedPosZ = entityPlayerMP.r;
<         for (\u2603 = n - this.playerViewRadius; \u2603 <= n + this.playerViewRadius; ++\u2603) {
<             for (\u2603 = \u2603 - this.playerViewRadius; \u2603 <= \u2603 + this.playerViewRadius; ++\u2603) {
<                 this.getOrCreateEntry(\u2603, \u2603).addPlayer(entityPlayerMP);
---
>     public void addPlayer(EntityPlayerMP player) {
>         int i = (int)player.p >> 4;
>         int j = (int)player.r >> 4;
>         player.managedPosX = player.p;
>         player.managedPosZ = player.r;
>         int loadRadius = Math.min((int)this.playerViewRadius, (int)8);
>         int kMin = i - loadRadius;
>         int kMax = i + loadRadius;
>         int lMin = j - loadRadius;
>         int lMax = j + loadRadius;
>         Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(player);
>         for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; ++k) {
>             for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; ++l) {
>                 if (k < kMin || k > kMax || l < lMin || l > lMax) {
>                     setPendingEntries.add((Object)new ChunkPos(k, l));
>                     continue;
>                 }
>                 this.getOrCreateEntry(k, l).addPlayer(player);
184c230
<         this.players.add((Object)entityPlayerMP);
---
>         this.players.add((Object)player);
188,196c234,242
<     public void removePlayer(EntityPlayerMP entityPlayerMP2) {
<         EntityPlayerMP entityPlayerMP2;
<         int n = (int)entityPlayerMP2.managedPosX >> 4;
<         \u2603 = (int)entityPlayerMP2.managedPosZ >> 4;
<         for (\u2603 = n - this.playerViewRadius; \u2603 <= n + this.playerViewRadius; ++\u2603) {
<             for (\u2603 = \u2603 - this.playerViewRadius; \u2603 <= \u2603 + this.playerViewRadius; ++\u2603) {
<                 PlayerChunkMapEntry playerChunkMapEntry = this.getEntry(\u2603, \u2603);
<                 if (playerChunkMapEntry == null) continue;
<                 playerChunkMapEntry.removePlayer(entityPlayerMP2);
---
>     public void removePlayer(EntityPlayerMP player) {
>         this.mapPlayerPendingEntries.remove((Object)player);
>         int i = (int)player.managedPosX >> 4;
>         int j = (int)player.managedPosZ >> 4;
>         for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; ++k) {
>             for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; ++l) {
>                 PlayerChunkMapEntry playerchunkmapentry = this.getEntry(k, l);
>                 if (playerchunkmapentry == null) continue;
>                 playerchunkmapentry.removePlayer(player);
199c245
<         this.players.remove((Object)entityPlayerMP2);
---
>         this.players.remove((Object)player);
203,232c249,286
<     private boolean overlaps(int n, int n2, int n3, int n4, int n5) {
<         \u2603 = n - n3;
<         \u2603 = n2 - n4;
<         if (\u2603 < -n5 || \u2603 > n5) {
<             return false;
<         }
<         return \u2603 >= -n5 && \u2603 <= n5;
<     }
< 
<     public void updateMovingPlayer(EntityPlayerMP entityPlayerMP) {
<         int n = (int)entityPlayerMP.p >> 4;
<         \u2603 = (int)entityPlayerMP.r >> 4;
<         double \u26032 = entityPlayerMP.managedPosX - entityPlayerMP.p;
<         double \u26033 = entityPlayerMP.managedPosZ - entityPlayerMP.r;
<         double \u26034 = \u26032 * \u26032 + \u26033 * \u26033;
<         if (\u26034 < 64.0) {
<             return;
<         }
<         \u2603 = (int)entityPlayerMP.managedPosX >> 4;
<         \u2603 = (int)entityPlayerMP.managedPosZ >> 4;
<         \u2603 = this.playerViewRadius;
<         \u2603 = n - \u2603;
<         \u2603 = \u2603 - \u2603;
<         if (\u2603 == 0 && \u2603 == 0) {
<             return;
<         }
<         for (\u2603 = n - \u2603; \u2603 <= n + \u2603; ++\u2603) {
<             for (\u2603 = \u2603 - \u2603; \u2603 <= \u2603 + \u2603; ++\u2603) {
<                 if (!this.overlaps(\u2603, \u2603, \u2603, \u2603, \u2603)) {
<                     this.getOrCreateEntry(\u2603, \u2603).addPlayer(entityPlayerMP);
---
>     private boolean overlaps(int x1, int z1, int x2, int z2, int radius) {
>         int i = x1 - x2;
>         int j = z1 - z2;
>         if (i >= -radius && i <= radius) {
>             return j >= -radius && j <= radius;
>         }
>         return false;
>     }
> 
>     public void updateMovingPlayer(EntityPlayerMP player) {
>         int i = (int)player.p >> 4;
>         int j = (int)player.r >> 4;
>         double d0 = player.managedPosX - player.p;
>         double d1 = player.managedPosZ - player.r;
>         double d2 = d0 * d0 + d1 * d1;
>         if (d2 >= 64.0) {
>             int k = (int)player.managedPosX >> 4;
>             int l = (int)player.managedPosZ >> 4;
>             int i1 = this.playerViewRadius;
>             int j1 = i - k;
>             int k1 = j - l;
>             if (j1 != 0 || k1 != 0) {
>                 Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(player);
>                 for (int l1 = i - i1; l1 <= i + i1; ++l1) {
>                     for (int i2 = j - i1; i2 <= j + i1; ++i2) {
>                         if (!this.overlaps(l1, i2, k, l, i1)) {
>                             if (Config.isLazyChunkLoading()) {
>                                 setPendingEntries.add((Object)new ChunkPos(l1, i2));
>                             } else {
>                                 this.getOrCreateEntry(l1, i2).addPlayer(player);
>                             }
>                         }
>                         if (this.overlaps(l1 - j1, i2 - k1, i, j, i1)) continue;
>                         setPendingEntries.remove((Object)new ChunkPos(l1 - j1, i2 - k1));
>                         PlayerChunkMapEntry playerchunkmapentry = this.getEntry(l1 - j1, i2 - k1);
>                         if (playerchunkmapentry == null) continue;
>                         playerchunkmapentry.removePlayer(player);
>                     }
234,235c288,290
<                 if (this.overlaps(\u2603 - \u2603, \u2603 - \u2603, n, \u2603, \u2603) || (\u2603 = this.getEntry(\u2603 - \u2603, \u2603 - \u2603)) == null) continue;
<                 \u2603.removePlayer(entityPlayerMP);
---
>                 player.managedPosX = player.p;
>                 player.managedPosZ = player.r;
>                 this.markSortPending();
238,240d292
<         entityPlayerMP.managedPosX = entityPlayerMP.p;
<         entityPlayerMP.managedPosZ = entityPlayerMP.r;
<         this.markSortPending();
243,263c295,317
<     public boolean isPlayerWatchingChunk(EntityPlayerMP entityPlayerMP, int n, int n2) {
<         PlayerChunkMapEntry playerChunkMapEntry = this.getEntry(n, n2);
<         return playerChunkMapEntry != null && playerChunkMapEntry.containsPlayer(entityPlayerMP) && playerChunkMapEntry.isSentToPlayers();
<     }
< 
<     public void setPlayerViewRadius(int n2) {
<         int n2;
<         if ((n2 = MathHelper.clamp((int)n2, (int)3, (int)32)) == this.playerViewRadius) {
<             return;
<         }
<         \u2603 = n2 - this.playerViewRadius;
<         ArrayList arrayList = Lists.newArrayList(this.players);
<         for (EntityPlayerMP entityPlayerMP : arrayList) {
<             int n3 = (int)entityPlayerMP.p >> 4;
<             \u2603 = (int)entityPlayerMP.r >> 4;
<             if (\u2603 > 0) {
<                 for (i = n3 - n2; i <= n3 + n2; ++i) {
<                     for (\u2603 = \u2603 - n2; \u2603 <= \u2603 + n2; ++\u2603) {
<                         PlayerChunkMapEntry playerChunkMapEntry = this.getOrCreateEntry(i, \u2603);
<                         if (playerChunkMapEntry.containsPlayer(entityPlayerMP)) continue;
<                         playerChunkMapEntry.addPlayer(entityPlayerMP);
---
>     public boolean isPlayerWatchingChunk(EntityPlayerMP player, int chunkX, int chunkZ) {
>         PlayerChunkMapEntry playerchunkmapentry = this.getEntry(chunkX, chunkZ);
>         return playerchunkmapentry != null && playerchunkmapentry.containsPlayer(player) && playerchunkmapentry.isSentToPlayers();
>     }
> 
>     public void setPlayerViewRadius(int radius) {
>         if ((radius = MathHelper.clamp((int)radius, (int)3, (int)64)) != this.playerViewRadius) {
>             int i = radius - this.playerViewRadius;
>             for (EntityPlayerMP entityplayermp : Lists.newArrayList(this.players)) {
>                 int j = (int)entityplayermp.p >> 4;
>                 int k = (int)entityplayermp.r >> 4;
>                 Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(entityplayermp);
>                 if (i > 0) {
>                     for (int j1 = j - radius; j1 <= j + radius; ++j1) {
>                         for (int k1 = k - radius; k1 <= k + radius; ++k1) {
>                             if (Config.isLazyChunkLoading()) {
>                                 setPendingEntries.add((Object)new ChunkPos(j1, k1));
>                                 continue;
>                             }
>                             PlayerChunkMapEntry playerchunkmapentry = this.getOrCreateEntry(j1, k1);
>                             if (playerchunkmapentry.containsPlayer(entityplayermp)) continue;
>                             playerchunkmapentry.addPlayer(entityplayermp);
>                         }
264a319
>                     continue;
266,271c321,328
<                 continue;
<             }
<             for (int i = n3 - this.playerViewRadius; i <= n3 + this.playerViewRadius; ++i) {
<                 for (\u2603 = \u2603 - this.playerViewRadius; \u2603 <= \u2603 + this.playerViewRadius; ++\u2603) {
<                     if (this.overlaps(i, \u2603, n3, \u2603, n2)) continue;
<                     this.getOrCreateEntry(i, \u2603).removePlayer(entityPlayerMP);
---
>                 for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; ++l) {
>                     for (int i1 = k - this.playerViewRadius; i1 <= k + this.playerViewRadius; ++i1) {
>                         if (this.overlaps(l, i1, j, k, radius)) continue;
>                         setPendingEntries.remove((Object)new ChunkPos(l, i1));
>                         PlayerChunkMapEntry entry = this.getEntry(l, i1);
>                         if (entry == null) continue;
>                         entry.removePlayer(entityplayermp);
>                     }
273a331,332
>             this.playerViewRadius = radius;
>             this.markSortPending();
275,276d333
<         this.playerViewRadius = n2;
<         this.markSortPending();
284,285c341,346
<     public static int getFurthestViewableBlock(int n) {
<         return n * 16 - 16;
---
>     public static int getFurthestViewableBlock(int distance) {
>         return distance * 16 - 16;
>     }
> 
>     private static long getIndex(int p_187307_0_, int p_187307_1_) {
>         return (long)p_187307_0_ + Integer.MAX_VALUE | (long)p_187307_1_ + Integer.MAX_VALUE << 32;
288,289c349,350
<     private static long getIndex(int n, int n2) {
<         return (long)n + Integer.MAX_VALUE | (long)n2 + Integer.MAX_VALUE << 32;
---
>     public void entryChanged(PlayerChunkMapEntry entry) {
>         this.dirtyEntries.add((Object)entry);
292,307c353,364
<     public void entryChanged(PlayerChunkMapEntry playerChunkMapEntry) {
<         this.dirtyEntries.add((Object)playerChunkMapEntry);
<     }
< 
<     public void removeEntry(PlayerChunkMapEntry playerChunkMapEntry) {
<         ChunkPos chunkPos = playerChunkMapEntry.getPos();
<         long \u26032 = PlayerChunkMap.getIndex(chunkPos.x, chunkPos.z);
<         playerChunkMapEntry.updateChunkInhabitedTime();
<         this.entryMap.remove(\u26032);
<         this.entries.remove((Object)playerChunkMapEntry);
<         this.dirtyEntries.remove((Object)playerChunkMapEntry);
<         this.pendingSendToPlayers.remove((Object)playerChunkMapEntry);
<         this.entriesWithoutChunks.remove((Object)playerChunkMapEntry);
<         Chunk \u26033 = playerChunkMapEntry.getChunk();
<         if (\u26033 != null) {
<             this.getWorldServer().getChunkProvider().queueUnload(\u26033);
---
>     public void removeEntry(PlayerChunkMapEntry entry) {
>         ChunkPos chunkpos = entry.getPos();
>         long i = PlayerChunkMap.getIndex(chunkpos.x, chunkpos.z);
>         entry.updateChunkInhabitedTime();
>         this.entryMap.remove(i);
>         this.entries.remove((Object)entry);
>         this.dirtyEntries.remove((Object)entry);
>         this.pendingSendToPlayers.remove((Object)entry);
>         this.entriesWithoutChunks.remove((Object)entry);
>         Chunk chunk = entry.getChunk();
>         if (chunk != null) {
>             this.getWorldServer().getChunkProvider().queueUnload(chunk);
308a366,406
>     }
> 
>     private PriorityQueue<ChunkPos> getNearest(Set<ChunkPos> setPending, EntityPlayerMP player, int count) {
>         float playerYaw;
>         for (playerYaw = player.v + 90.0f; playerYaw <= -180.0f; playerYaw += 360.0f) {
>         }
>         while (playerYaw > 180.0f) {
>             playerYaw -= 360.0f;
>         }
>         double playerYawRad = (double)playerYaw * (Math.PI / 180);
>         double playerPitch = player.w;
>         double playerPitchRad = playerPitch * (Math.PI / 180);
>         ChunkPosComparator comp = new ChunkPosComparator(player.ab, player.ad, playerYawRad, playerPitchRad);
>         Comparator compRev = Collections.reverseOrder((Comparator)comp);
>         PriorityQueue queue = new PriorityQueue(compRev);
>         for (ChunkPos chunkPos : setPending) {
>             if (queue.size() < count) {
>                 queue.add((Object)chunkPos);
>                 continue;
>             }
>             ChunkPos furthest = (ChunkPos)queue.peek();
>             if (comp.compare(chunkPos, furthest) >= 0) continue;
>             queue.remove();
>             queue.add((Object)chunkPos);
>         }
>         return queue;
>     }
> 
>     private Set<ChunkPos> getPendingEntriesSafe(EntityPlayerMP player) {
>         Set setPendingEntries = (Set)this.mapPlayerPendingEntries.get((Object)player);
>         if (setPendingEntries != null) {
>             return setPendingEntries;
>         }
>         int loadRadius = Math.min((int)this.playerViewRadius, (int)8);
>         int playerWidth = this.playerViewRadius * 2 + 1;
>         int loadWidth = loadRadius * 2 + 1;
>         int countLazyChunks = playerWidth * playerWidth - loadWidth * loadWidth;
>         countLazyChunks = Math.max((int)countLazyChunks, (int)16);
>         setPendingEntries = new HashSet(countLazyChunks);
>         this.mapPlayerPendingEntries.put((Object)player, (Object)setPendingEntries);
>         return setPendingEntries;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/ClassInheritanceMultiMap$1.java ../optifine_patch/src/main/java/net/minecraft/util/ClassInheritanceMultiMap$1.java
11a12
>  *  net.minecraft.util.ClassInheritanceMultiMap
18a20
> import net.minecraft.util.ClassInheritanceMultiMap;
19a22,24
> /*
>  * Exception performing whole class analysis ignored.
>  */
24c29
<     ClassInheritanceMultiMap.1() {
---
>     ClassInheritanceMultiMap.1(Class clazz) {
29c34
<         List list = (List)ClassInheritanceMultiMap.this.map.get((Object)ClassInheritanceMultiMap.this.initializeClassLookup(this.val$clazz));
---
>         List list = (List)ClassInheritanceMultiMap.access$000((ClassInheritanceMultiMap)ClassInheritanceMultiMap.this).get((Object)ClassInheritanceMultiMap.this.initializeClassLookup(this.val$clazz));
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java ../optifine_patch/src/main/java/net/minecraft/util/ClassInheritanceMultiMap.java
13d12
<  *  java.lang.String
20a20
>  *  net.optifine.util.IteratorCache
34a35
> import net.optifine.util.IteratorCache;
42a44
>     public boolean empty;
50a53
>         this.empty = this.values.size() == 0;
55c58,60
<         for (Object t : this.values) {
---
>         int count = this.values.size();
>         for (int i = 0; i < count; ++i) {
>             Object t = this.values.get(i);
69c74
<         throw new IllegalArgumentException("Don't know how to search for " + String.valueOf(clazz));
---
>         throw new IllegalArgumentException("Don't know how to search for " + clazz);
76a82
>         this.empty = this.values.size() == 0;
86a93
>         this.empty = this.values.size() == 0;
96a104
>         this.empty = this.values.size() == 0;
109c117
<         return this.values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator((Iterator)this.values.iterator());
---
>         return this.values.isEmpty() ? Collections.emptyIterator() : IteratorCache.getReadOnly(this.values);
113a122,129
>     }
> 
>     public boolean isEmpty() {
>         return this.empty;
>     }
> 
>     static /* synthetic */ Map access$000(ClassInheritanceMultiMap x0) {
>         return x0.map;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/EnumFacing$1.java ../optifine_patch/src/main/java/net/minecraft/util/EnumFacing$1.java
19,21c19,21
<     static final /* synthetic */ int[] field_179515_a;
<     static final /* synthetic */ int[] field_179513_b;
<     static final /* synthetic */ int[] field_179514_c;
---
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$util$EnumFacing$Axis;
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$util$EnumFacing;
>     static final /* synthetic */ int[] $SwitchMap$net$minecraft$util$EnumFacing$Plane;
24c24
<         field_179514_c = new int[EnumFacing.Plane.values().length];
---
>         $SwitchMap$net$minecraft$util$EnumFacing$Plane = new int[EnumFacing.Plane.values().length];
26c26
<             EnumFacing.1.field_179514_c[EnumFacing.Plane.HORIZONTAL.ordinal()] = 1;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Plane[EnumFacing.Plane.HORIZONTAL.ordinal()] = 1;
32c32
<             EnumFacing.1.field_179514_c[EnumFacing.Plane.VERTICAL.ordinal()] = 2;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Plane[EnumFacing.Plane.VERTICAL.ordinal()] = 2;
37c37
<         field_179513_b = new int[EnumFacing.values().length];
---
>         $SwitchMap$net$minecraft$util$EnumFacing = new int[EnumFacing.values().length];
39c39
<             EnumFacing.1.field_179513_b[EnumFacing.NORTH.ordinal()] = 1;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.NORTH.ordinal()] = 1;
45c45
<             EnumFacing.1.field_179513_b[EnumFacing.EAST.ordinal()] = 2;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.EAST.ordinal()] = 2;
51c51
<             EnumFacing.1.field_179513_b[EnumFacing.SOUTH.ordinal()] = 3;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.SOUTH.ordinal()] = 3;
57c57
<             EnumFacing.1.field_179513_b[EnumFacing.WEST.ordinal()] = 4;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.WEST.ordinal()] = 4;
63c63
<             EnumFacing.1.field_179513_b[EnumFacing.UP.ordinal()] = 5;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.UP.ordinal()] = 5;
69c69
<             EnumFacing.1.field_179513_b[EnumFacing.DOWN.ordinal()] = 6;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing[EnumFacing.DOWN.ordinal()] = 6;
74c74
<         field_179515_a = new int[EnumFacing.Axis.values().length];
---
>         $SwitchMap$net$minecraft$util$EnumFacing$Axis = new int[EnumFacing.Axis.values().length];
76c76
<             EnumFacing.1.field_179515_a[EnumFacing.Axis.X.ordinal()] = 1;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Axis[EnumFacing.Axis.X.ordinal()] = 1;
82c82
<             EnumFacing.1.field_179515_a[EnumFacing.Axis.Y.ordinal()] = 2;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Axis[EnumFacing.Axis.Y.ordinal()] = 2;
88c88
<             EnumFacing.1.field_179515_a[EnumFacing.Axis.Z.ordinal()] = 3;
---
>             EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Axis[EnumFacing.Axis.Z.ordinal()] = 3;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/EnumFacing$Plane.java ../optifine_patch/src/main/java/net/minecraft/util/EnumFacing$Plane.java
13a14
>  *  net.minecraft.util.EnumFacing$1
32,33c33,34
<         switch (this.ordinal()) {
<             case 0: {
---
>         switch (EnumFacing.1.$SwitchMap$net$minecraft$util$EnumFacing$Plane[this.ordinal()]) {
>             case 1: {
36c37
<             case 1: {
---
>             case 2: {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/EnumFacing.java ../optifine_patch/src/main/java/net/minecraft/util/EnumFacing.java
16a17
>  *  net.minecraft.util.EnumFacing$1
55c56
<     public static final EnumFacing[] HORIZONTALS;
---
>     private static final EnumFacing[] HORIZONTALS;
81c82
<         return EnumFacing.byIndex(this.opposite);
---
>         return VALUES[this.opposite];
85,86c86,87
<         switch (axis.ordinal()) {
<             case 0: {
---
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing$Axis[axis.ordinal()]) {
>             case 1: {
92c93
<             case 1: {
---
>             case 2: {
98c99
<             case 2: {
---
>             case 3: {
105c106
<         throw new IllegalStateException("Unable to get CW facing for axis " + String.valueOf((Object)axis));
---
>         throw new IllegalStateException("Unable to get CW facing for axis " + axis);
109,110c110,111
<         switch (this.ordinal()) {
<             case 2: {
---
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing[this.ordinal()]) {
>             case 1: {
113c114
<             case 5: {
---
>             case 2: {
123c124
<         throw new IllegalStateException("Unable to get Y-rotated facing of " + String.valueOf((Object)((Object)this)));
---
>         throw new IllegalStateException("Unable to get Y-rotated facing of " + (Object)((Object)this));
127,128c128,129
<         switch (this.ordinal()) {
<             case 2: {
---
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing[this.ordinal()]) {
>             case 1: {
132c133
<                 throw new IllegalStateException("Unable to get X-rotated facing of " + String.valueOf((Object)((Object)this)));
---
>                 throw new IllegalStateException("Unable to get X-rotated facing of " + (Object)((Object)this));
137c138
<             case 1: {
---
>             case 5: {
140c141
<             case 0: 
---
>             case 6: 
146,147c147,148
<         switch (this.ordinal()) {
<             case 5: {
---
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing[this.ordinal()]) {
>             case 2: {
151c152
<                 throw new IllegalStateException("Unable to get Z-rotated facing of " + String.valueOf((Object)((Object)this)));
---
>                 throw new IllegalStateException("Unable to get Z-rotated facing of " + (Object)((Object)this));
156c157
<             case 1: {
---
>             case 5: {
159c160
<             case 0: 
---
>             case 6: 
165,166c166,167
<         switch (this.ordinal()) {
<             case 2: {
---
>         switch (1.$SwitchMap$net$minecraft$util$EnumFacing[this.ordinal()]) {
>             case 1: {
169c170
<             case 5: {
---
>             case 2: {
179c180
<         throw new IllegalStateException("Unable to get CCW facing of " + String.valueOf((Object)((Object)this)));
---
>         throw new IllegalStateException("Unable to get CCW facing of " + (Object)((Object)this));
252c253
<         throw new IllegalArgumentException("No such direction: " + String.valueOf((Object)axisDirectionIn) + " " + String.valueOf((Object)axisIn));
---
>         throw new IllegalArgumentException("No such direction: " + axisDirectionIn + " " + axisIn);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/IntegerCache.java ../optifine_patch/src/main/java/net/minecraft/util/IntegerCache.java
13,15c13,15
<     public static Integer getInteger(int n) {
<         if (n > 0 && n < CACHE.length) {
<             return CACHE[n];
---
>     public static Integer getInteger(int value) {
>         if (value >= 0 && value < CACHE.length) {
>             return CACHE[value];
17c17
<         return n;
---
>         return new Integer(value);
21,23c21,23
<         int n = CACHE.length;
<         for (\u2603 = 0; \u2603 < n; ++\u2603) {
<             IntegerCache.CACHE[\u2603] = \u2603;
---
>         int j = CACHE.length;
>         for (int i = 0; i < j; ++i) {
>             IntegerCache.CACHE[i] = i;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/Util.java ../optifine_patch/src/main/java/net/minecraft/util/Util.java
7a8
>  *  java.lang.OutOfMemoryError
31,32c32,33
<         String string = System.getProperty((String)"os.name").toLowerCase(Locale.ROOT);
<         if (string.contains((CharSequence)"win")) {
---
>         String s = System.getProperty((String)"os.name").toLowerCase(Locale.ROOT);
>         if (s.contains((CharSequence)"win")) {
35c36
<         if (string.contains((CharSequence)"mac")) {
---
>         if (s.contains((CharSequence)"mac")) {
38c39
<         if (string.contains((CharSequence)"solaris")) {
---
>         if (s.contains((CharSequence)"solaris")) {
41c42
<         if (string.contains((CharSequence)"sunos")) {
---
>         if (s.contains((CharSequence)"sunos")) {
44c45
<         if (string.contains((CharSequence)"linux")) {
---
>         if (s.contains((CharSequence)"linux")) {
47,50c48
<         if (string.contains((CharSequence)"unix")) {
<             return EnumOS.LINUX;
<         }
<         return EnumOS.UNKNOWN;
---
>         return s.contains((CharSequence)"unix") ? EnumOS.LINUX : EnumOS.UNKNOWN;
54c52
<     public static <V> V runTask(FutureTask<V> futureTask, Logger logger) {
---
>     public static <V> V runTask(FutureTask<V> task, Logger logger) {
56,57c54,55
<             futureTask.run();
<             return (V)futureTask.get();
---
>             task.run();
>             return (V)task.get();
59,60c57,62
<         catch (ExecutionException executionException) {
<             logger.fatal("Error executing task", (Throwable)executionException);
---
>         catch (ExecutionException executionexception) {
>             logger.fatal("Error executing task", (Throwable)executionexception);
>             if (executionexception.getCause() instanceof OutOfMemoryError) {
>                 OutOfMemoryError oome = (OutOfMemoryError)executionexception.getCause();
>                 throw oome;
>             }
62,63c64,65
<         catch (InterruptedException interruptedException) {
<             logger.fatal("Error executing task", (Throwable)interruptedException);
---
>         catch (InterruptedException interruptedexception) {
>             logger.fatal("Error executing task", (Throwable)interruptedexception);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/math/ChunkPos.java ../optifine_patch/src/main/java/net/minecraft/util/math/ChunkPos.java
17a18
>     private int cachedHashCode = 0;
19,21c20,22
<     public ChunkPos(int n, int n2) {
<         this.x = n;
<         this.z = n2;
---
>     public ChunkPos(int x, int z) {
>         this.x = x;
>         this.z = z;
24,26c25,27
<     public ChunkPos(BlockPos blockPos) {
<         this.x = blockPos.p() >> 4;
<         this.z = blockPos.r() >> 4;
---
>     public ChunkPos(BlockPos pos) {
>         this.x = pos.p() >> 4;
>         this.z = pos.r() >> 4;
29,30c30,31
<     public static long asLong(int n, int n2) {
<         return (long)n & 0xFFFFFFFFL | ((long)n2 & 0xFFFFFFFFL) << 32;
---
>     public static long asLong(int x, int z) {
>         return (long)x & 0xFFFFFFFFL | ((long)z & 0xFFFFFFFFL) << 32;
34,36c35,41
<         int n = 1664525 * this.x + 1013904223;
<         \u2603 = 1664525 * (this.z ^ 0xDEADBEEF) + 1013904223;
<         return n ^ \u2603;
---
>         if (this.cachedHashCode != 0) {
>             return this.cachedHashCode;
>         }
>         int i = 1664525 * this.x + 1013904223;
>         int j = 1664525 * (this.z ^ 0xDEADBEEF) + 1013904223;
>         this.cachedHashCode = i ^ j;
>         return this.cachedHashCode;
39,40c44,45
<     public boolean equals(Object object) {
<         if (this == object) {
---
>     public boolean equals(Object p_equals_1_) {
>         if (this == p_equals_1_) {
43,45c48,49
<         if (object instanceof ChunkPos) {
<             ChunkPos chunkPos = (ChunkPos)object;
<             return this.x == chunkPos.x && this.z == chunkPos.z;
---
>         if (!(p_equals_1_ instanceof ChunkPos)) {
>             return false;
47c51,52
<         return false;
---
>         ChunkPos chunkpos = (ChunkPos)p_equals_1_;
>         return this.x == chunkpos.x && this.z == chunkpos.z;
50,55c55,60
<     public double getDistanceSq(Entity entity) {
<         double d = this.x * 16 + 8;
<         \u2603 = this.z * 16 + 8;
<         \u2603 = d - entity.posX;
<         \u2603 = \u2603 - entity.posZ;
<         return \u2603 * \u2603 + \u2603 * \u2603;
---
>     public double getDistanceSq(Entity entityIn) {
>         double d0 = this.x * 16 + 8;
>         double d1 = this.z * 16 + 8;
>         double d2 = d0 - entityIn.posX;
>         double d3 = d1 - entityIn.posZ;
>         return d2 * d2 + d3 * d3;
74,75c79,80
<     public BlockPos getBlock(int n, int n2, int n3) {
<         return new BlockPos((this.x << 4) + n, n2, (this.z << 4) + n3);
---
>     public BlockPos getBlock(int x, int y, int z) {
>         return new BlockPos((this.x << 4) + x, y, (this.z << 4) + z);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/math/MathHelper.java ../optifine_patch/src/main/java/net/minecraft/util/math/MathHelper.java
15a16
>  *  net.optifine.util.MathUtils
21a23
> import net.optifine.util.MathUtils;
24,26c26,39
<     public static final float SQRT_2;
<     private static final float[] SIN_TABLE;
<     private static final Random RANDOM;
---
>     public static final float SQRT_2 = MathHelper.sqrt(2.0f);
>     private static final int SIN_BITS = 12;
>     private static final int SIN_MASK = 4095;
>     private static final int SIN_COUNT = 4096;
>     private static final int SIN_COUNT_D4 = 1024;
>     public static final float PI = MathUtils.roundToFloat((double)Math.PI);
>     public static final float PI2 = MathUtils.roundToFloat((double)(Math.PI * 2));
>     public static final float PId2 = MathUtils.roundToFloat((double)1.5707963267948966);
>     private static final float radToIndex = MathUtils.roundToFloat((double)651.8986469044033);
>     public static final float deg2Rad = MathUtils.roundToFloat((double)(Math.PI / 180));
>     private static final float[] SIN_TABLE_FAST = new float[4096];
>     public static boolean fastMath = false;
>     private static final float[] SIN_TABLE = new float[65536];
>     private static final Random RANDOM = new Random();
32,33c45,49
<     public static float sin(float f) {
<         return SIN_TABLE[(int)(f * 10430.378f) & 0xFFFF];
---
>     public static float sin(float value) {
>         if (fastMath) {
>             return SIN_TABLE_FAST[(int)(value * radToIndex) & 0xFFF];
>         }
>         return SIN_TABLE[(int)(value * 10430.378f) & 0xFFFF];
36,37c52,56
<     public static float cos(float f) {
<         return SIN_TABLE[(int)(f * 10430.378f + 16384.0f) & 0xFFFF];
---
>     public static float cos(float value) {
>         if (fastMath) {
>             return SIN_TABLE_FAST[(int)(value * radToIndex + 1024.0f) & 0xFFF];
>         }
>         return SIN_TABLE[(int)(value * 10430.378f + 16384.0f) & 0xFFFF];
40,41c59,60
<     public static float sqrt(float f) {
<         return (float)Math.sqrt((double)f);
---
>     public static float sqrt(float value) {
>         return (float)Math.sqrt((double)value);
44,45c63,64
<     public static float sqrt(double d) {
<         return (float)Math.sqrt((double)d);
---
>     public static float sqrt(double value) {
>         return (float)Math.sqrt((double)value);
48,50c67,69
<     public static int floor(float f) {
<         int n = (int)f;
<         return f < (float)n ? n - 1 : n;
---
>     public static int floor(float value) {
>         int i = (int)value;
>         return value < (float)i ? i - 1 : i;
53,54c72,73
<     public static int fastFloor(double d) {
<         return (int)(d + 1024.0) - 1024;
---
>     public static int fastFloor(double value) {
>         return (int)(value + 1024.0) - 1024;
57,59c76,78
<     public static int floor(double d) {
<         int n = (int)d;
<         return d < (double)n ? n - 1 : n;
---
>     public static int floor(double value) {
>         int i = (int)value;
>         return value < (double)i ? i - 1 : i;
62,64c81,83
<     public static long lfloor(double d) {
<         long l = (long)d;
<         return d < (double)l ? l - 1L : l;
---
>     public static long lfloor(double value) {
>         long i = (long)value;
>         return value < (double)i ? i - 1L : i;
67,68c86,87
<     public static int absFloor(double d) {
<         return (int)(d >= 0.0 ? d : -d + 1.0);
---
>     public static int absFloor(double value) {
>         return (int)(value >= 0.0 ? value : -value + 1.0);
71,72c90,91
<     public static float abs(float f) {
<         return f >= 0.0f ? f : -f;
---
>     public static float abs(float value) {
>         return value >= 0.0f ? value : -value;
75,76c94,95
<     public static int abs(int n) {
<         return n >= 0 ? n : -n;
---
>     public static int abs(int value) {
>         return value >= 0 ? value : -value;
79,81c98,100
<     public static int ceil(float f) {
<         int n = (int)f;
<         return f > (float)n ? n + 1 : n;
---
>     public static int ceil(float value) {
>         int i = (int)value;
>         return value > (float)i ? i + 1 : i;
84,86c103,105
<     public static int ceil(double d) {
<         int n = (int)d;
<         return d > (double)n ? n + 1 : n;
---
>     public static int ceil(double value) {
>         int i = (int)value;
>         return value > (double)i ? i + 1 : i;
89,91c108,110
<     public static int clamp(int n, int n2, int n3) {
<         if (n < n2) {
<             return n2;
---
>     public static int clamp(int num, int min, int max) {
>         if (num < min) {
>             return min;
93,96c112
<         if (n > n3) {
<             return n3;
<         }
<         return n;
---
>         return num > max ? max : num;
99,104c115,117
<     public static float clamp(float f, float f2, float f3) {
<         if (f < f2) {
<             return f2;
<         }
<         if (f > f3) {
<             return f3;
---
>     public static float clamp(float num, float min, float max) {
>         if (num < min) {
>             return min;
106c119
<         return f;
---
>         return num > max ? max : num;
109,111c122,124
<     public static double clamp(double d, double d2, double d3) {
<         if (d < d2) {
<             return d2;
---
>     public static double clamp(double num, double min, double max) {
>         if (num < min) {
>             return min;
113,116c126
<         if (d > d3) {
<             return d3;
<         }
<         return d;
---
>         return num > max ? max : num;
119,124c129,131
<     public static double clampedLerp(double d, double d2, double d3) {
<         if (d3 < 0.0) {
<             return d;
<         }
<         if (d3 > 1.0) {
<             return d2;
---
>     public static double clampedLerp(double lowerBnd, double upperBnd, double slide) {
>         if (slide < 0.0) {
>             return lowerBnd;
126c133
<         return d + (d2 - d) * d3;
---
>         return slide > 1.0 ? upperBnd : lowerBnd + (upperBnd - lowerBnd) * slide;
129,131c136,138
<     public static double absMax(double d, double d2) {
<         if (d < 0.0) {
<             d = -d;
---
>     public static double absMax(double p_76132_0_, double p_76132_2_) {
>         if (p_76132_0_ < 0.0) {
>             p_76132_0_ = -p_76132_0_;
133,134c140,141
<         if (d2 < 0.0) {
<             d2 = -d2;
---
>         if (p_76132_2_ < 0.0) {
>             p_76132_2_ = -p_76132_2_;
136c143
<         return d > d2 ? d : d2;
---
>         return p_76132_0_ > p_76132_2_ ? p_76132_0_ : p_76132_2_;
139,143c146,147
<     public static int intFloorDiv(int n, int n2) {
<         if (n < 0) {
<             return -((-n - 1) / n2) - 1;
<         }
<         return n / n2;
---
>     public static int intFloorDiv(int p_76137_0_, int p_76137_1_) {
>         return p_76137_0_ < 0 ? -((-p_76137_0_ - 1) / p_76137_1_) - 1 : p_76137_0_ / p_76137_1_;
146,150c150,151
<     public static int getInt(Random random, int n, int n2) {
<         if (n >= n2) {
<             return n;
<         }
<         return random.nextInt(n2 - n + 1) + n;
---
>     public static int getInt(Random random, int minimum, int maximum) {
>         return minimum >= maximum ? minimum : random.nextInt(maximum - minimum + 1) + minimum;
153,157c154,155
<     public static float nextFloat(Random random, float f, float f2) {
<         if (f >= f2) {
<             return f;
<         }
<         return random.nextFloat() * (f2 - f) + f;
---
>     public static float nextFloat(Random random, float minimum, float maximum) {
>         return minimum >= maximum ? minimum : random.nextFloat() * (maximum - minimum) + minimum;
160,164c158,159
<     public static double nextDouble(Random random, double d, double d2) {
<         if (d >= d2) {
<             return d;
<         }
<         return random.nextDouble() * (d2 - d) + d;
---
>     public static double nextDouble(Random random, double minimum, double maximum) {
>         return minimum >= maximum ? minimum : random.nextDouble() * (maximum - minimum) + minimum;
167,170c162,165
<     public static double average(long[] lArray) {
<         long l = 0L;
<         for (long l2 : lArray) {
<             l += l2;
---
>     public static double average(long[] values) {
>         long i = 0L;
>         for (long j : values) {
>             i += j;
172c167
<         return (double)l / (double)lArray.length;
---
>         return (double)i / (double)values.length;
175,176c170,171
<     public static boolean epsilonEquals(float f, float f2) {
<         return MathHelper.abs(f2 - f) < 1.0E-5f;
---
>     public static boolean epsilonEquals(float p_180185_0_, float p_180185_1_) {
>         return MathHelper.abs(p_180185_1_ - p_180185_0_) < 1.0E-5f;
179,180c174,175
<     public static int normalizeAngle(int n, int n2) {
<         return (n % n2 + n2) % n2;
---
>     public static int normalizeAngle(int p_180184_0_, int p_180184_1_) {
>         return (p_180184_0_ % p_180184_1_ + p_180184_1_) % p_180184_1_;
183,184c178,179
<     public static float positiveModulo(float f, float f2) {
<         return (f % f2 + f2) % f2;
---
>     public static float positiveModulo(float numerator, float denominator) {
>         return (numerator % denominator + denominator) % denominator;
187,188c182,183
<     public static double positiveModulo(double d, double d2) {
<         return (d % d2 + d2) % d2;
---
>     public static double positiveModulo(double numerator, double denominator) {
>         return (numerator % denominator + denominator) % denominator;
191,193c186,188
<     public static float wrapDegrees(float f) {
<         if ((f %= 360.0f) >= 180.0f) {
<             f -= 360.0f;
---
>     public static float wrapDegrees(float value) {
>         if ((value %= 360.0f) >= 180.0f) {
>             value -= 360.0f;
195,196c190,191
<         if (f < -180.0f) {
<             f += 360.0f;
---
>         if (value < -180.0f) {
>             value += 360.0f;
198c193
<         return f;
---
>         return value;
201,203c196,198
<     public static double wrapDegrees(double d) {
<         if ((d %= 360.0) >= 180.0) {
<             d -= 360.0;
---
>     public static double wrapDegrees(double value) {
>         if ((value %= 360.0) >= 180.0) {
>             value -= 360.0;
205,206c200,201
<         if (d < -180.0) {
<             d += 360.0;
---
>         if (value < -180.0) {
>             value += 360.0;
208c203
<         return d;
---
>         return value;
211,213c206,208
<     public static int wrapDegrees(int n) {
<         if ((n %= 360) >= 180) {
<             n -= 360;
---
>     public static int wrapDegrees(int angle) {
>         if ((angle %= 360) >= 180) {
>             angle -= 360;
215,216c210,211
<         if (n < -180) {
<             n += 360;
---
>         if (angle < -180) {
>             angle += 360;
218c213
<         return n;
---
>         return angle;
221c216
<     public static int getInt(String string, int n) {
---
>     public static int getInt(String value, int defaultValue) {
223c218
<             return Integer.parseInt((String)string);
---
>             return Integer.parseInt((String)value);
225,226c220,221
<         catch (Throwable throwable) {
<             return n;
---
>         catch (Throwable var3) {
>             return defaultValue;
230,231c225,226
<     public static int getInt(String string, int n, int n2) {
<         return Math.max((int)n2, (int)MathHelper.getInt(string, n));
---
>     public static int getInt(String value, int defaultValue, int max) {
>         return Math.max((int)max, (int)MathHelper.getInt(value, defaultValue));
234c229
<     public static double getDouble(String string, double d) {
---
>     public static double getDouble(String value, double defaultValue) {
236c231
<             return Double.parseDouble((String)string);
---
>             return Double.parseDouble((String)value);
238,239c233,234
<         catch (Throwable throwable) {
<             return d;
---
>         catch (Throwable var4) {
>             return defaultValue;
243,244c238,239
<     public static double getDouble(String string, double d, double d2) {
<         return Math.max((double)d2, (double)MathHelper.getDouble(string, d));
---
>     public static double getDouble(String value, double defaultValue, double max) {
>         return Math.max((double)max, (double)MathHelper.getDouble(value, defaultValue));
247,254c242,249
<     public static int smallestEncompassingPowerOfTwo(int n) {
<         \u2603 = n - 1;
<         \u2603 |= \u2603 >> 1;
<         \u2603 |= \u2603 >> 2;
<         \u2603 |= \u2603 >> 4;
<         \u2603 |= \u2603 >> 8;
<         \u2603 |= \u2603 >> 16;
<         return \u2603 + 1;
---
>     public static int smallestEncompassingPowerOfTwo(int value) {
>         int i = value - 1;
>         i |= i >> 1;
>         i |= i >> 2;
>         i |= i >> 4;
>         i |= i >> 8;
>         i |= i >> 16;
>         return i + 1;
257,258c252,253
<     private static boolean isPowerOfTwo(int n) {
<         return n != 0 && (n & n - 1) == 0;
---
>     private static boolean isPowerOfTwo(int value) {
>         return value != 0 && (value & value - 1) == 0;
261,263c256,258
<     public static int log2DeBruijn(int n) {
<         n = MathHelper.isPowerOfTwo(n) ? n : MathHelper.smallestEncompassingPowerOfTwo(n);
<         return MULTIPLY_DE_BRUIJN_BIT_POSITION[(int)((long)n * 125613361L >> 27) & 0x1F];
---
>     public static int log2DeBruijn(int value) {
>         value = MathHelper.isPowerOfTwo(value) ? value : MathHelper.smallestEncompassingPowerOfTwo(value);
>         return MULTIPLY_DE_BRUIJN_BIT_POSITION[(int)((long)value * 125613361L >> 27) & 0x1F];
266,267c261,262
<     public static int log2(int n) {
<         return MathHelper.log2DeBruijn(n) - (MathHelper.isPowerOfTwo(n) ? 0 : 1);
---
>     public static int log2(int value) {
>         return MathHelper.log2DeBruijn(value) - (MathHelper.isPowerOfTwo(value) ? 0 : 1);
270,271c265,267
<     public static int roundUp(int n, int n2) {
<         if (n2 == 0) {
---
>     public static int roundUp(int number, int interval) {
>         int i;
>         if (interval == 0) {
274,278c270,271
<         if (n == 0) {
<             return n2;
<         }
<         if (n < 0) {
<             n2 *= -1;
---
>         if (number == 0) {
>             return interval;
280,281c273,274
<         if ((\u2603 = n % n2) == 0) {
<             return n;
---
>         if (number < 0) {
>             interval *= -1;
283c276
<         return n + n2 - \u2603;
---
>         return (i = number % interval) == 0 ? number : number + interval - i;
286,287c279,280
<     public static int rgb(float f, float f2, float f3) {
<         return MathHelper.rgb(MathHelper.floor(f * 255.0f), MathHelper.floor(f2 * 255.0f), MathHelper.floor(f3 * 255.0f));
---
>     public static int rgb(float rIn, float gIn, float bIn) {
>         return MathHelper.rgb(MathHelper.floor(rIn * 255.0f), MathHelper.floor(gIn * 255.0f), MathHelper.floor(bIn * 255.0f));
290,294c283,286
<     public static int rgb(int n, int n2, int n3) {
<         \u2603 = n;
<         \u2603 = (\u2603 << 8) + n2;
<         \u2603 = (\u2603 << 8) + n3;
<         return \u2603;
---
>     public static int rgb(int rIn, int gIn, int bIn) {
>         int lvt_3_1_ = (rIn << 8) + gIn;
>         lvt_3_1_ = (lvt_3_1_ << 8) + bIn;
>         return lvt_3_1_;
297,307c289,299
<     public static int multiplyColor(int n, int n2) {
<         \u2603 = (n & 0xFF0000) >> 16;
<         \u2603 = (n2 & 0xFF0000) >> 16;
<         \u2603 = (n & 0xFF00) >> 8;
<         \u2603 = (n2 & 0xFF00) >> 8;
<         \u2603 = (n & 0xFF) >> 0;
<         \u2603 = (n2 & 0xFF) >> 0;
<         \u2603 = (int)((float)\u2603 * (float)\u2603 / 255.0f);
<         \u2603 = (int)((float)\u2603 * (float)\u2603 / 255.0f);
<         \u2603 = (int)((float)\u2603 * (float)\u2603 / 255.0f);
<         return n & 0xFF000000 | \u2603 << 16 | \u2603 << 8 | \u2603;
---
>     public static int multiplyColor(int p_180188_0_, int p_180188_1_) {
>         int i = (p_180188_0_ & 0xFF0000) >> 16;
>         int j = (p_180188_1_ & 0xFF0000) >> 16;
>         int k = (p_180188_0_ & 0xFF00) >> 8;
>         int l = (p_180188_1_ & 0xFF00) >> 8;
>         int i1 = (p_180188_0_ & 0xFF) >> 0;
>         int j1 = (p_180188_1_ & 0xFF) >> 0;
>         int k1 = (int)((float)i * (float)j / 255.0f);
>         int l1 = (int)((float)k * (float)l / 255.0f);
>         int i2 = (int)((float)i1 * (float)j1 / 255.0f);
>         return p_180188_0_ & 0xFF000000 | k1 << 16 | l1 << 8 | i2;
310,311c302,303
<     public static double frac(double d) {
<         return d - Math.floor((double)d);
---
>     public static double frac(double number) {
>         return number - Math.floor((double)number);
314,315c306,307
<     public static long getPositionRandom(Vec3i vec3i) {
<         return MathHelper.getCoordinateRandom(vec3i.getX(), vec3i.getY(), vec3i.getZ());
---
>     public static long getPositionRandom(Vec3i pos) {
>         return MathHelper.getCoordinateRandom(pos.getX(), pos.getY(), pos.getZ());
318,321c310,313
<     public static long getCoordinateRandom(int n, int n2, int n3) {
<         long l = (long)(n * 3129871) ^ (long)n3 * 116129781L ^ (long)n2;
<         l = l * l * 42317861L + l * 11L;
<         return l;
---
>     public static long getCoordinateRandom(int x, int y, int z) {
>         long i = (long)(x * 3129871) ^ (long)z * 116129781L ^ (long)y;
>         i = i * i * 42317861L + i * 11L;
>         return i;
324,327c316,319
<     public static UUID getRandomUUID(Random random) {
<         long l = random.nextLong() & 0xFFFFFFFFFFFF0FFFL | 0x4000L;
<         \u2603 = random.nextLong() & 0x3FFFFFFFFFFFFFFFL | Long.MIN_VALUE;
<         return new UUID(l, \u2603);
---
>     public static UUID getRandomUUID(Random rand) {
>         long i = rand.nextLong() & 0xFFFFFFFFFFFF0FFFL | 0x4000L;
>         long j = rand.nextLong() & 0x3FFFFFFFFFFFFFFFL | Long.MIN_VALUE;
>         return new UUID(i, j);
334,335c326,327
<     public static double pct(double d, double d2, double d3) {
<         return (d - d2) / (d3 - d2);
---
>     public static double pct(double p_181160_0_, double p_181160_2_, double p_181160_4_) {
>         return (p_181160_0_ - p_181160_2_) / (p_181160_4_ - p_181160_2_);
338,340c330,335
<     public static double atan2(double d, double d2) {
<         \u2603 = d2 * d2 + d * d;
<         if (Double.isNaN((double)\u2603)) {
---
>     public static double atan2(double p_181159_0_, double p_181159_2_) {
>         boolean flag2;
>         boolean flag1;
>         boolean flag;
>         double d0 = p_181159_2_ * p_181159_2_ + p_181159_0_ * p_181159_0_;
>         if (Double.isNaN((double)d0)) {
343,389c338,385
<         boolean bl = \u2603 = d < 0.0;
<         if (\u2603) {
<             d = -d;
<         }
<         boolean bl2 = \u2603 = d2 < 0.0;
<         if (\u2603) {
<             d2 = -d2;
<         }
<         boolean bl3 = \u2603 = d > d2;
<         if (\u2603) {
<             \u2603 = d2;
<             d2 = d;
<             d = \u2603;
<         }
<         \u2603 = MathHelper.fastInvSqrt(\u2603);
<         d2 *= \u2603;
<         \u2603 = FRAC_BIAS + (d *= \u2603);
<         int n = (int)Double.doubleToRawLongBits((double)\u2603);
<         double \u26032 = ASINE_TAB[n];
<         double \u26033 = COS_TAB[n];
<         double \u26034 = \u2603 - FRAC_BIAS;
<         double \u26035 = d * \u26033 - d2 * \u26034;
<         double \u26036 = (6.0 + \u26035 * \u26035) * \u26035 * 0.16666666666666666;
<         double \u26037 = \u26032 + \u26036;
<         if (\u2603) {
<             \u26037 = 1.5707963267948966 - \u26037;
<         }
<         if (\u2603) {
<             \u26037 = Math.PI - \u26037;
<         }
<         if (\u2603) {
<             \u26037 = -\u26037;
<         }
<         return \u26037;
<     }
< 
<     public static double fastInvSqrt(double \u260322) {
<         double d;
<         d = 0.5 * \u260322;
<         long l = Double.doubleToRawLongBits((double)\u260322);
<         l = 6910469410427058090L - (l >> 1);
<         double \u260322 = Double.longBitsToDouble((long)l);
<         \u260322 *= 1.5 - d * \u260322 * \u260322;
<         return \u260322;
<     }
< 
<     public static int hsvToRGB(float f5, float f2, float f32) {
---
>         boolean bl = flag = p_181159_0_ < 0.0;
>         if (flag) {
>             p_181159_0_ = -p_181159_0_;
>         }
>         boolean bl2 = flag1 = p_181159_2_ < 0.0;
>         if (flag1) {
>             p_181159_2_ = -p_181159_2_;
>         }
>         boolean bl3 = flag2 = p_181159_0_ > p_181159_2_;
>         if (flag2) {
>             double d1 = p_181159_2_;
>             p_181159_2_ = p_181159_0_;
>             p_181159_0_ = d1;
>         }
>         double d9 = MathHelper.fastInvSqrt(d0);
>         p_181159_2_ *= d9;
>         double d2 = FRAC_BIAS + (p_181159_0_ *= d9);
>         int i = (int)Double.doubleToRawLongBits((double)d2);
>         double d3 = ASINE_TAB[i];
>         double d4 = COS_TAB[i];
>         double d5 = d2 - FRAC_BIAS;
>         double d6 = p_181159_0_ * d4 - p_181159_2_ * d5;
>         double d7 = (6.0 + d6 * d6) * d6 * 0.16666666666666666;
>         double d8 = d3 + d7;
>         if (flag2) {
>             d8 = 1.5707963267948966 - d8;
>         }
>         if (flag1) {
>             d8 = Math.PI - d8;
>         }
>         if (flag) {
>             d8 = -d8;
>         }
>         return d8;
>     }
> 
>     public static double fastInvSqrt(double p_181161_0_) {
>         double d0 = 0.5 * p_181161_0_;
>         long i = Double.doubleToRawLongBits((double)p_181161_0_);
>         i = 6910469410427058090L - (i >> 1);
>         p_181161_0_ = Double.longBitsToDouble((long)i);
>         p_181161_0_ *= 1.5 - d0 * p_181161_0_ * p_181161_0_;
>         return p_181161_0_;
>     }
> 
>     public static int hsvToRGB(float hue, float saturation, float value) {
>         float f6;
>         float f5;
391,396c387,392
<         int n = (int)(f5 * 6.0f) % 6;
<         float \u26032 = f5 * 6.0f - (float)n;
<         float \u26033 = f32 * (1.0f - f2);
<         float \u26034 = f32 * (1.0f - \u26032 * f2);
<         float \u26035 = f32 * (1.0f - (1.0f - \u26032) * f2);
<         switch (n) {
---
>         int i = (int)(hue * 6.0f) % 6;
>         float f = hue * 6.0f - (float)i;
>         float f1 = value * (1.0f - saturation);
>         float f2 = value * (1.0f - f * saturation);
>         float f3 = value * (1.0f - (1.0f - f) * saturation);
>         switch (i) {
398,400c394,396
<                 f4 = f32;
<                 \u2603 = \u26035;
<                 \u2603 = \u26033;
---
>                 f4 = value;
>                 f5 = f3;
>                 f6 = f1;
404,406c400,402
<                 f4 = \u26034;
<                 \u2603 = f32;
<                 \u2603 = \u26033;
---
>                 f4 = f2;
>                 f5 = value;
>                 f6 = f1;
410,412c406,408
<                 f4 = \u26033;
<                 \u2603 = f32;
<                 \u2603 = \u26035;
---
>                 f4 = f1;
>                 f5 = value;
>                 f6 = f3;
416,418c412,414
<                 f4 = \u26033;
<                 \u2603 = \u26034;
<                 \u2603 = f32;
---
>                 f4 = f1;
>                 f5 = f2;
>                 f6 = value;
422,424c418,420
<                 f4 = \u26035;
<                 \u2603 = \u26033;
<                 \u2603 = f32;
---
>                 f4 = f3;
>                 f5 = f1;
>                 f6 = value;
428,431c424,426
<                 float f32;
<                 f4 = f32;
<                 \u2603 = \u26033;
<                 \u2603 = \u26034;
---
>                 f4 = value;
>                 f5 = f1;
>                 f6 = f2;
435,436c430
<                 float f5;
<                 throw new RuntimeException("Something went wrong when converting from HSV to RGB. Input was " + f5 + ", " + f2 + ", " + f32);
---
>                 throw new RuntimeException("Something went wrong when converting from HSV to RGB. Input was " + hue + ", " + saturation + ", " + value);
439,442c433,436
<         int \u26036 = MathHelper.clamp((int)(f4 * 255.0f), 0, 255);
<         int \u26037 = MathHelper.clamp((int)(\u2603 * 255.0f), 0, 255);
<         int \u26038 = MathHelper.clamp((int)(\u2603 * 255.0f), 0, 255);
<         return \u26036 << 16 | \u26037 << 8 | \u26038;
---
>         int j = MathHelper.clamp((int)(f4 * 255.0f), 0, 255);
>         int k = MathHelper.clamp((int)(f5 * 255.0f), 0, 255);
>         int l = MathHelper.clamp((int)(f6 * 255.0f), 0, 255);
>         return j << 16 | k << 8 | l;
445,451c439,445
<     public static int hash(int n) {
<         n ^= n >>> 16;
<         n *= -2048144789;
<         n ^= n >>> 13;
<         n *= -1028477387;
<         n ^= n >>> 16;
<         return n;
---
>     public static int hash(int p_188208_0_) {
>         p_188208_0_ ^= p_188208_0_ >>> 16;
>         p_188208_0_ *= -2048144789;
>         p_188208_0_ ^= p_188208_0_ >>> 13;
>         p_188208_0_ *= -1028477387;
>         p_188208_0_ ^= p_188208_0_ >>> 16;
>         return p_188208_0_;
455,460c449,453
<         int n;
<         SQRT_2 = MathHelper.sqrt(2.0f);
<         RANDOM = new Random();
<         SIN_TABLE = new float[65536];
<         for (n = 0; n < 65536; ++n) {
<             MathHelper.SIN_TABLE[n] = (float)Math.sin((double)((double)n * Math.PI * 2.0 / 65536.0));
---
>         for (int i = 0; i < 65536; ++i) {
>             MathHelper.SIN_TABLE[i] = (float)Math.sin((double)((double)i * Math.PI * 2.0 / 65536.0));
>         }
>         for (int s = 0; s < SIN_TABLE_FAST.length; ++s) {
>             MathHelper.SIN_TABLE_FAST[s] = MathUtils.roundToFloat((double)Math.sin((double)((double)s * Math.PI * 2.0 / 4096.0)));
466,470c459,463
<         for (n = 0; n < 257; ++n) {
<             double d = (double)n / 256.0;
<             \u2603 = Math.asin((double)d);
<             MathHelper.COS_TAB[n] = Math.cos((double)\u2603);
<             MathHelper.ASINE_TAB[n] = \u2603;
---
>         for (int j = 0; j < 257; ++j) {
>             double d0 = (double)j / 256.0;
>             double d1 = Math.asin((double)d0);
>             MathHelper.COS_TAB[j] = Math.cos((double)d1);
>             MathHelper.ASINE_TAB[j] = d1;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/util/text/translation/I18n.java ../optifine_patch/src/main/java/net/minecraft/util/text/translation/I18n.java
20,21c20,21
<     public static String translateToLocal(String string) {
<         return localizedName.translateKey(string);
---
>     public static String translateToLocal(String key) {
>         return localizedName.translateKey(key);
25,26c25,26
<     public static String translateToLocalFormatted(String string, Object ... objectArray) {
<         return localizedName.translateKeyFormat(string, objectArray);
---
>     public static String translateToLocalFormatted(String key, Object ... format) {
>         return localizedName.translateKeyFormat(key, format);
30,31c30,31
<     public static String translateToFallback(String string) {
<         return fallbackTranslator.translateKey(string);
---
>     public static String translateToFallback(String key) {
>         return fallbackTranslator.translateKey(key);
35,36c35,36
<     public static boolean canTranslate(String string) {
<         return localizedName.isKeyTranslated(string);
---
>     public static boolean canTranslate(String key) {
>         return localizedName.isKeyTranslated(key);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/GameRules$Value.java ../optifine_patch/src/main/java/net/minecraft/world/GameRules$Value.java
24,26c24,26
<     public GameRules.Value(String string, GameRules.ValueType valueType) {
<         this.type = valueType;
<         this.setValue(string);
---
>     public GameRules.Value(String value, GameRules.ValueType type) {
>         this.type = type;
>         this.setValue(value);
29,31c29,41
<     public void setValue(String string) {
<         this.valueString = string;
<         this.valueBoolean = Boolean.parseBoolean((String)string);
---
>     public void setValue(String value) {
>         this.valueString = value;
>         if (value != null) {
>             if (value.equals((Object)"false")) {
>                 this.valueBoolean = false;
>                 return;
>             }
>             if (value.equals((Object)"true")) {
>                 this.valueBoolean = true;
>                 return;
>             }
>         }
>         this.valueBoolean = Boolean.parseBoolean((String)value);
34c44
<             this.valueInteger = Integer.parseInt((String)string);
---
>             this.valueInteger = Integer.parseInt((String)value);
40c50
<             this.valueDouble = Double.parseDouble((String)string);
---
>             this.valueDouble = Double.parseDouble((String)value);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/GameRules.java ../optifine_patch/src/main/java/net/minecraft/world/GameRules.java
50,51c50,51
<     public void addGameRule(String string, String string2, ValueType valueType) {
<         this.rules.put((Object)string, (Object)new Value(string2, valueType));
---
>     public void addGameRule(String key, String value, ValueType type) {
>         this.rules.put((Object)key, (Object)new Value(value, type));
54,57c54,57
<     public void setOrCreateGameRule(String string, String string2) {
<         Value value = (Value)this.rules.get((Object)string);
<         if (value != null) {
<             value.setValue(string2);
---
>     public void setOrCreateGameRule(String key, String ruleValue) {
>         Value gamerules$value = (Value)this.rules.get((Object)key);
>         if (gamerules$value != null) {
>             gamerules$value.setValue(ruleValue);
59c59
<             this.addGameRule(string, string2, ValueType.ANY_VALUE);
---
>             this.addGameRule(key, ruleValue, ValueType.ANY_VALUE);
63,68c63,65
<     public String getString(String string) {
<         Value value = (Value)this.rules.get((Object)string);
<         if (value != null) {
<             return value.getString();
<         }
<         return "";
---
>     public String getString(String name) {
>         Value gamerules$value = (Value)this.rules.get((Object)name);
>         return gamerules$value != null ? gamerules$value.getString() : "";
71,76c68,70
<     public boolean getBoolean(String string) {
<         Value value = (Value)this.rules.get((Object)string);
<         if (value != null) {
<             return value.getBoolean();
<         }
<         return false;
---
>     public boolean getBoolean(String name) {
>         Value gamerules$value = (Value)this.rules.get((Object)name);
>         return gamerules$value != null ? gamerules$value.getBoolean() : false;
79,84c73,75
<     public int getInt(String string) {
<         Value value = (Value)this.rules.get((Object)string);
<         if (value != null) {
<             return value.getInt();
<         }
<         return 0;
---
>     public int getInt(String name) {
>         Value gamerules$value = (Value)this.rules.get((Object)name);
>         return gamerules$value != null ? gamerules$value.getInt() : 0;
88,91c79,82
<         NBTTagCompound nBTTagCompound = new NBTTagCompound();
<         for (String string : this.rules.keySet()) {
<             Value value = (Value)this.rules.get((Object)string);
<             nBTTagCompound.setString(string, value.getString());
---
>         NBTTagCompound nbttagcompound = new NBTTagCompound();
>         for (String s : this.rules.keySet()) {
>             Value gamerules$value = (Value)this.rules.get((Object)s);
>             nbttagcompound.setString(s, gamerules$value.getString());
93c84
<         return nBTTagCompound;
---
>         return nbttagcompound;
96,99c87,89
<     public void readFromNBT(NBTTagCompound nBTTagCompound) {
<         Set set = nBTTagCompound.getKeySet();
<         for (String string : set) {
<             this.setOrCreateGameRule(string, nBTTagCompound.getString(string));
---
>     public void readFromNBT(NBTTagCompound nbt) {
>         for (String s : nbt.getKeySet()) {
>             this.setOrCreateGameRule(s, nbt.getString(s));
108,109c98,99
<     public boolean hasRule(String string) {
<         return this.rules.containsKey((Object)string);
---
>     public boolean hasRule(String name) {
>         return this.rules.containsKey((Object)name);
112,114c102,104
<     public boolean areSameType(String string, ValueType valueType) {
<         Value value = (Value)this.rules.get((Object)string);
<         return value != null && (value.getType() == valueType || valueType == ValueType.ANY_VALUE);
---
>     public boolean areSameType(String key, ValueType otherValue) {
>         Value gamerules$value = (Value)this.rules.get((Object)key);
>         return gamerules$value != null && (gamerules$value.getType() == otherValue || otherValue == ValueType.ANY_VALUE);
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/WorldEntitySpawner.java ../optifine_patch/src/main/java/net/minecraft/world/WorldEntitySpawner.java
8a9,10
>  *  java.lang.Float
>  *  java.lang.Integer
12a15
>  *  java.util.HashMap
13a17
>  *  java.util.Map
34d37
<  *  net.minecraft.world.IBlockAccess
40,41c43,46
<  *  net.minecraftforge.event.ForgeEventFactory
<  *  net.minecraftforge.fml.common.eventhandler.Event$Result
---
>  *  net.optifine.BlockPosM
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorForge
>  *  net.optifine.reflect.ReflectorMethod
48a54
> import java.util.HashMap;
49a56
> import java.util.Map;
68d74
< import net.minecraft.world.IBlockAccess;
73,74c79,82
< import net.minecraftforge.event.ForgeEventFactory;
< import net.minecraftforge.fml.common.eventhandler.Event;
---
> import net.optifine.BlockPosM;
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorForge;
> import net.optifine.reflect.ReflectorMethod;
78a87,90
>     private Map<Class, EntityLiving> mapSampleEntitiesByClass = new HashMap();
>     private int lastPlayerChunkX = Integer.MAX_VALUE;
>     private int lastPlayerChunkZ = Integer.MAX_VALUE;
>     private int countChunkPos;
84,99c96,121
<         this.eligibleChunksForSpawning.clear();
<         int i = 0;
<         for (EntityPlayer entityplayer : worldServerIn.i) {
<             if (entityplayer.isSpectator()) continue;
<             int j = MathHelper.floor((double)(entityplayer.p / 16.0));
<             int k = MathHelper.floor((double)(entityplayer.r / 16.0));
<             int l = 8;
<             for (int i1 = -8; i1 <= 8; ++i1) {
<                 for (int j1 = -8; j1 <= 8; ++j1) {
<                     PlayerChunkMapEntry playerchunkmapentry;
<                     boolean flag = i1 == -8 || i1 == 8 || j1 == -8 || j1 == 8;
<                     ChunkPos chunkpos = new ChunkPos(i1 + j, j1 + k);
<                     if (this.eligibleChunksForSpawning.contains((Object)chunkpos)) continue;
<                     ++i;
<                     if (flag || !worldServerIn.al().contains(chunkpos) || (playerchunkmapentry = worldServerIn.getPlayerChunkMap().getEntry(chunkpos.x, chunkpos.z)) == null || !playerchunkmapentry.isSentToPlayers()) continue;
<                     this.eligibleChunksForSpawning.add((Object)chunkpos);
---
>         boolean updateEligibleChunks = true;
>         EntityPlayer player = null;
>         if (worldServerIn.i.size() == 1) {
>             player = (EntityPlayer)worldServerIn.i.get(0);
>             if (this.eligibleChunksForSpawning.size() > 0 && player != null && player.ab == this.lastPlayerChunkX && player.ad == this.lastPlayerChunkZ) {
>                 updateEligibleChunks = false;
>             }
>         }
>         if (updateEligibleChunks) {
>             this.eligibleChunksForSpawning.clear();
>             int i = 0;
>             for (EntityPlayer entityplayer : worldServerIn.i) {
>                 if (entityplayer.isSpectator()) continue;
>                 int j = MathHelper.floor((double)(entityplayer.p / 16.0));
>                 int k = MathHelper.floor((double)(entityplayer.r / 16.0));
>                 int l = 8;
>                 for (int i1 = -8; i1 <= 8; ++i1) {
>                     for (int j1 = -8; j1 <= 8; ++j1) {
>                         PlayerChunkMapEntry playerchunkmapentry;
>                         boolean flag = i1 == -8 || i1 == 8 || j1 == -8 || j1 == 8;
>                         ChunkPos chunkpos = new ChunkPos(i1 + j, j1 + k);
>                         if (this.eligibleChunksForSpawning.contains((Object)chunkpos)) continue;
>                         ++i;
>                         if (flag || !worldServerIn.al().contains(chunkpos) || (playerchunkmapentry = worldServerIn.getPlayerChunkMap().getEntry(chunkpos.x, chunkpos.z)) == null || !playerchunkmapentry.isSentToPlayers()) continue;
>                         this.eligibleChunksForSpawning.add((Object)chunkpos);
>                     }
101a124,128
>             this.countChunkPos = i;
>             if (player != null) {
>                 this.lastPlayerChunkX = player.ab;
>                 this.lastPlayerChunkZ = player.ad;
>             }
104a132,133
>         BlockPosM blockPosM = new BlockPosM(0, 0, 0);
>         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
108,113c137,145
<             if (enumcreaturetype.getPeacefulCreature() && !spawnPeacefulMobs || !enumcreaturetype.getPeacefulCreature() && !spawnHostileMobs || enumcreaturetype.getAnimal() && !spawnOnSetTickRate || (k4 = worldServerIn.countEntities(enumcreaturetype, true)) > (l4 = enumcreaturetype.getMaxNumberOfCreature() * i / MOB_COUNT_DIV)) continue;
<             ArrayList shuffled = Lists.newArrayList(this.eligibleChunksForSpawning);
<             Collections.shuffle((List)shuffled);
<             BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
<             block6: for (ChunkPos chunkpos1 : shuffled) {
<                 BlockPos blockpos = WorldEntitySpawner.getRandomChunkPosition((World)worldServerIn, chunkpos1.x, chunkpos1.z);
---
>             if (enumcreaturetype.getPeacefulCreature() && !spawnPeacefulMobs || !enumcreaturetype.getPeacefulCreature() && !spawnHostileMobs || enumcreaturetype.getAnimal() && !spawnOnSetTickRate || (k4 = Reflector.ForgeWorld_countEntities.exists() ? Reflector.callInt((Object)worldServerIn, (ReflectorMethod)Reflector.ForgeWorld_countEntities, (Object[])new Object[]{enumcreaturetype, true}) : worldServerIn.a(enumcreaturetype.getCreatureClass())) > (l4 = enumcreaturetype.getMaxNumberOfCreature() * this.countChunkPos / MOB_COUNT_DIV)) continue;
>             ArrayList chunksForSpawning = this.eligibleChunksForSpawning;
>             if (Reflector.ForgeHooksClient.exists()) {
>                 ArrayList shuffled = Lists.newArrayList(chunksForSpawning);
>                 Collections.shuffle((List)shuffled);
>                 chunksForSpawning = shuffled;
>             }
>             block6: for (ChunkPos chunkpos1 : chunksForSpawning) {
>                 BlockPosM blockpos = WorldEntitySpawner.getRandomChunkPosition((World)worldServerIn, chunkpos1.x, chunkpos1.z, blockPosM);
117c149
<                 IBlockState iblockstate = worldServerIn.o(blockpos);
---
>                 IBlockState iblockstate = worldServerIn.o((BlockPos)blockpos);
128a161
>                         boolean canSpawn;
137c170,174
<                             entityliving = biome$spawnlistentry.newInstance((World)worldServerIn);
---
>                             entityliving = (EntityLiving)this.mapSampleEntitiesByClass.get((Object)biome$spawnlistentry.entityClass);
>                             if (entityliving == null) {
>                                 entityliving = Reflector.ForgeBiomeSpawnListEntry_newInstance.exists() ? (EntityLiving)Reflector.call((Object)biome$spawnlistentry, (ReflectorMethod)Reflector.ForgeBiomeSpawnListEntry_newInstance, (Object[])new Object[]{worldServerIn}) : (EntityLiving)biome$spawnlistentry.entityClass.getConstructor(new Class[]{World.class}).newInstance(new Object[]{worldServerIn});
>                                 this.mapSampleEntitiesByClass.put((Object)biome$spawnlistentry.entityClass, (Object)entityliving);
>                             }
144,146c181,185
<                         Event.Result canSpawn = ForgeEventFactory.canEntitySpawn((EntityLiving)entityliving, (World)worldServerIn, (float)f, (float)i3, (float)f1, (boolean)false);
<                         if (canSpawn == Event.Result.ALLOW || canSpawn == Event.Result.DEFAULT && entityliving.getCanSpawnHere() && entityliving.isNotColliding()) {
<                             if (!ForgeEventFactory.doSpecialSpawn((EntityLiving)entityliving, (World)worldServerIn, (float)f, (float)i3, (float)f1)) {
---
>                         boolean bl = Reflector.ForgeEventFactory_canEntitySpawn.exists() ? ReflectorForge.canEntitySpawn((EntityLiving)entityliving, (World)worldServerIn, (float)f, (float)i3, (float)f1) : (canSpawn = entityliving.getCanSpawnHere() && entityliving.isNotColliding());
>                         if (canSpawn) {
>                             int maxSpawnedInChunk;
>                             this.mapSampleEntitiesByClass.remove((Object)biome$spawnlistentry.entityClass);
>                             if (!ReflectorForge.doSpecialSpawn((EntityLiving)entityliving, (World)worldServerIn, (float)f, (int)i3, (float)f1)) {
155c194,195
<                             if (j2 >= ForgeEventFactory.getMaxSpawnPackSize((EntityLiving)entityliving)) continue block6;
---
>                             int n = maxSpawnedInChunk = Reflector.ForgeEventFactory_getMaxSpawnPackSize.exists() ? Reflector.callInt((ReflectorMethod)Reflector.ForgeEventFactory_getMaxSpawnPackSize, (Object[])new Object[]{entityliving}) : entityliving.getMaxSpawnedInChunk();
>                             if (j2 >= maxSpawnedInChunk) continue block6;
173a214,223
>     private static BlockPosM getRandomChunkPosition(World worldIn, int x, int z, BlockPosM blockPosM) {
>         Chunk chunk = worldIn.getChunk(x, z);
>         int px = x * 16 + worldIn.rand.nextInt(16);
>         int pz = z * 16 + worldIn.rand.nextInt(16);
>         int k = MathHelper.roundUp((int)(chunk.getHeightValue(px & 0xF, pz & 0xF) + 1), (int)16);
>         int py = worldIn.rand.nextInt(k > 0 ? k : chunk.getTopFilledSegment() + 16 - 1);
>         blockPosM.setXyz(px, py, pz);
>         return blockPosM;
>     }
> 
190a241,243
>         if (spawnPlacementTypeIn == null) {
>             return false;
>         }
194a248
>         boolean canSpawn;
201c255,256
<         if (!state.getBlock().canCreatureSpawn(state, (IBlockAccess)worldIn, blockpos, spawnPlacementTypeIn)) {
---
>         boolean bl = canSpawn = Reflector.ForgeBlock_canCreatureSpawn.exists() ? Reflector.callBoolean((Object)state.getBlock(), (ReflectorMethod)Reflector.ForgeBlock_canCreatureSpawn, (Object[])new Object[]{state, worldIn, blockpos, spawnPlacementTypeIn}) : state.q();
>         if (!canSpawn) {
209c264
<     public static void performWorldGenSpawning(World worldIn, Biome biomeIn, int centerX, int centerZ, int diameterX, int diameterZ, Random randomIn) {
---
>     public static void performWorldGenSpawning(World worldIn, Biome biomeIn, int p_77191_2_, int p_77191_3_, int p_77191_4_, int p_77191_5_, Random randomIn) {
216,217c271,272
<                 int j = centerX + randomIn.nextInt(diameterX);
<                 int k = centerZ + randomIn.nextInt(diameterZ);
---
>                 int j = p_77191_2_ + randomIn.nextInt(p_77191_4_);
>                 int k = p_77191_3_ + randomIn.nextInt(p_77191_5_);
224a280
>                             Object canSpawn;
227c283
<                                 entityliving = biome$spawnlistentry.newInstance(worldIn);
---
>                                 entityliving = Reflector.ForgeBiomeSpawnListEntry_newInstance.exists() ? (EntityLiving)Reflector.call((Object)biome$spawnlistentry, (ReflectorMethod)Reflector.ForgeBiomeSpawnListEntry_newInstance, (Object[])new Object[]{worldIn}) : (EntityLiving)biome$spawnlistentry.entityClass.getConstructor(new Class[]{World.class}).newInstance(new Object[]{worldIn});
233c289
<                             if (ForgeEventFactory.canEntitySpawn((EntityLiving)entityliving, (World)worldIn, (float)((float)j + 0.5f), (float)blockpos.q(), (float)((float)k + 0.5f), (boolean)false) == Event.Result.DENY) continue;
---
>                             if (Reflector.ForgeEventFactory_canEntitySpawn.exists() && (canSpawn = Reflector.call((ReflectorMethod)Reflector.ForgeEventFactory_canEntitySpawn, (Object[])new Object[]{entityliving, worldIn, Float.valueOf((float)((float)j + 0.5f)), blockpos.q(), Float.valueOf((float)((float)k + 0.5f)), false})) == ReflectorForge.EVENT_RESULT_DENY) continue;
241c297
<                         while (j < centerX || j >= centerX + diameterX || k < centerZ || k >= centerZ + diameterX) {
---
>                         while (j < p_77191_2_ || j >= p_77191_2_ + p_77191_4_ || k < p_77191_3_ || k >= p_77191_3_ + p_77191_4_) {
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java ../optifine_patch/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java
19,20d18
<  *  net.minecraftforge.fml.relauncher.Side
<  *  net.minecraftforge.fml.relauncher.SideOnly
37,38d34
< import net.minecraftforge.fml.relauncher.Side;
< import net.minecraftforge.fml.relauncher.SideOnly;
57,60d52
<         this.setBits(bitsIn, false);
<     }
< 
<     private void setBits(int bitsIn, boolean forceBits) {
71,73d62
<                 if (forceBits) {
<                     this.bits = bitsIn;
<                 }
110d98
<     @SideOnly(value=Side.CLIENT)
114c102
<             this.setBits(i, true);
---
>             this.setBits(i);
118,121d105
<         int regSize = MathHelper.log2DeBruijn((int)Block.BLOCK_STATE_IDS.size());
<         if (this.palette == REGISTRY_BASED_PALETTE && this.bits != regSize) {
<             this.onResize(regSize, AIR_BLOCK_STATE);
<         }
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java ../optifine_patch/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
11c11,12
<  *  net.minecraftforge.common.property.IExtendedBlockState
---
>  *  net.optifine.reflect.Reflector
>  *  net.optifine.reflect.ReflectorMethod
20c21,22
< import net.minecraftforge.common.property.IExtendedBlockState;
---
> import net.optifine.reflect.Reflector;
> import net.optifine.reflect.ReflectorMethod;
44,45c46,47
<         if (state instanceof IExtendedBlockState) {
<             state = ((IExtendedBlockState)state).getClean();
---
>         if (Reflector.IExtendedBlockState.isInstance((Object)state)) {
>             state = (IBlockState)Reflector.call((Object)state, (ReflectorMethod)Reflector.IExtendedBlockState_getClean, (Object[])new Object[0]);
94,101c96,105
<         this.blockRefCount = 0;
<         this.tickRefCount = 0;
<         for (int i = 0; i < 16; ++i) {
<             for (int j = 0; j < 16; ++j) {
<                 for (int k = 0; k < 16; ++k) {
<                     Block block = this.get(i, j, k).getBlock();
<                     if (block == Blocks.AIR) continue;
<                     ++this.blockRefCount;
---
>         IBlockState STATE_AIR = Blocks.AIR.getDefaultState();
>         int localBlockRefCount = 0;
>         int localTickRefCount = 0;
>         for (int y = 0; y < 16; ++y) {
>             for (int z = 0; z < 16; ++z) {
>                 for (int x = 0; x < 16; ++x) {
>                     IBlockState bs = this.data.get(x, y, z);
>                     if (bs == STATE_AIR) continue;
>                     ++localBlockRefCount;
>                     Block block = bs.getBlock();
103c107
<                     ++this.tickRefCount;
---
>                     ++localTickRefCount;
106a111,112
>         this.blockRefCount = localBlockRefCount;
>         this.tickRefCount = localTickRefCount;
126a133,136
>     }
> 
>     public int getBlockRefCount() {
>         return this.blockRefCount;
diff -r ../optifine_unpatch/src/main/java/net/minecraft/world/gen/layer/GenLayerZoom.java ../optifine_patch/src/main/java/net/minecraft/world/gen/layer/GenLayerZoom.java
17,19c17,19
<     public GenLayerZoom(long l, GenLayer genLayer) {
<         super(l);
<         this.parent = genLayer;
---
>     public GenLayerZoom(long p_i2134_1_, GenLayer p_i2134_3_) {
>         super(p_i2134_1_);
>         this.parent = p_i2134_3_;
22,45c22,45
<     public int[] getInts(int n, int n2, int n32, int n4) {
<         int n32;
<         \u2603 = n >> 1;
<         \u2603 = n2 >> 1;
<         \u2603 = (n32 >> 1) + 2;
<         \u2603 = (n4 >> 1) + 2;
<         int[] nArray = this.parent.getInts(\u2603, \u2603, \u2603, \u2603);
<         int \u26032 = \u2603 - 1 << 1;
<         int \u26033 = \u2603 - 1 << 1;
<         \u2603 = IntCache.getIntCache((int)(\u26032 * \u26033));
<         for (int i = 0; i < \u2603 - 1; ++i) {
<             \u2603 = (i << 1) * \u26032;
<             \u2603 = nArray[\u2603 + 0 + (i + 0) * \u2603];
<             \u2603 = nArray[\u2603 + 0 + (i + 1) * \u2603];
<             for (\u2603 = 0; \u2603 < \u2603 - 1; ++\u2603) {
<                 this.initChunkSeed(\u2603 + \u2603 << 1, i + \u2603 << 1);
<                 \u2603 = nArray[\u2603 + 1 + (i + 0) * \u2603];
<                 \u2603 = nArray[\u2603 + 1 + (i + 1) * \u2603];
<                 \u2603[\u2603] = \u2603;
<                 \u2603[\u2603++ + \u26032] = this.selectRandom(new int[]{\u2603, \u2603});
<                 \u2603[\u2603] = this.selectRandom(new int[]{\u2603, \u2603});
<                 \u2603[\u2603++ + \u26032] = this.selectModeOrRandom(\u2603, \u2603, \u2603, \u2603);
<                 \u2603 = \u2603;
<                 \u2603 = \u2603;
---
>     public int[] getInts(int areaX, int areaY, int areaWidth, int areaHeight) {
>         int i = areaX >> 1;
>         int j = areaY >> 1;
>         int k = (areaWidth >> 1) + 2;
>         int l = (areaHeight >> 1) + 2;
>         int[] aint = this.parent.getInts(i, j, k, l);
>         int i1 = k - 1 << 1;
>         int j1 = l - 1 << 1;
>         int[] aint1 = IntCache.getIntCache((int)(i1 * j1));
>         for (int k1 = 0; k1 < l - 1; ++k1) {
>             int i2;
>             int l1 = (k1 << 1) * i1;
>             int j2 = aint[i2 + 0 + (k1 + 0) * k];
>             int k2 = aint[i2 + 0 + (k1 + 1) * k];
>             for (i2 = 0; i2 < k - 1; ++i2) {
>                 this.initChunkSeed(i2 + i << 1, k1 + j << 1);
>                 int l2 = aint[i2 + 1 + (k1 + 0) * k];
>                 int i3 = aint[i2 + 1 + (k1 + 1) * k];
>                 aint1[l1] = j2;
>                 aint1[l1++ + i1] = this.selectRandom2(j2, k2);
>                 aint1[l1] = this.selectRandom2(j2, l2);
>                 aint1[l1++ + i1] = this.selectModeOrRandom(j2, l2, k2, i3);
>                 j2 = l2;
>                 k2 = i3;
48,50c48,50
<         int[] \u26034 = IntCache.getIntCache((int)(n32 * n4));
<         for (\u2603 = 0; \u2603 < n4; ++\u2603) {
<             System.arraycopy((Object)\u2603, (int)((\u2603 + (n2 & 1)) * \u26032 + (n & 1)), (Object)\u26034, (int)(\u2603 * n32), (int)n32);
---
>         int[] aint2 = IntCache.getIntCache((int)(areaWidth * areaHeight));
>         for (int j3 = 0; j3 < areaHeight; ++j3) {
>             System.arraycopy((Object)aint1, (int)((j3 + (areaY & 1)) * i1 + (areaX & 1)), (Object)aint2, (int)(j3 * areaWidth), (int)areaWidth);
52c52
<         return \u26034;
---
>         return aint2;
55,58c55,58
<     public static GenLayer magnify(long l, GenLayer genLayer, int n) {
<         GenLayer genLayer2 = genLayer;
<         for (int i = 0; i < n; ++i) {
<             genLayer2 = new GenLayerZoom(l + (long)i, genLayer2);
---
>     public static GenLayer magnify(long p_75915_0_, GenLayer p_75915_2_, int p_75915_3_) {
>         GenLayer genlayer = p_75915_2_;
>         for (int i = 0; i < p_75915_3_; ++i) {
>             genlayer = new GenLayerZoom(p_75915_0_ + (long)i, genlayer);
60c60,68
<         return genLayer2;
---
>         return genlayer;
>     }
> 
>     protected int selectRandom2(int i0, int i1) {
>         int index = this.nextInt(2);
>         if (index == 0) {
>             return i0;
>         }
>         return i1;
