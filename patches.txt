---
 patches/net/minecraft/block/BlockAir.java     |   43 +-
 .../minecraft/block/material/MapColor.java    |   44 +-
 .../minecraft/block/state/BlockStateBase.java |   87 +-
 .../block/state/BlockStateContainer.java      |  369 +-
 .../client/LoadingScreenRenderer.java         |  159 +-
 .../client/entity/AbstractClientPlayer.java   |  161 +-
 .../minecraft/client/gui/FontRenderer.java    |  832 ++--
 .../client/gui/GuiCustomizeSkin.java          |   88 +-
 .../client/gui/GuiDownloadTerrain.java        |   20 +-
 .../net/minecraft/client/gui/GuiIngame.java   | 1049 ++---
 .../net/minecraft/client/gui/GuiMainMenu.java |  439 +-
 .../minecraft/client/gui/GuiOverlayDebug.java |  371 +-
 .../client/gui/GuiScreenWorking.java          |   45 +-
 patches/net/minecraft/client/gui/GuiSlot.java |  365 +-
 .../client/gui/GuiVideoSettings.java          |  241 +-
 .../net/minecraft/client/model/ModelBox.java  |  225 +-
 .../minecraft/client/model/ModelPlayer.java   |  119 +-
 .../minecraft/client/model/ModelRenderer.java |  422 +-
 .../minecraft/client/model/TexturedQuad.java  |   69 +-
 .../client/multiplayer/WorldClient.java       |  450 ++-
 .../client/particle/ParticleItemPickup.java   |   67 +-
 .../client/particle/ParticleManager.java      |  484 ++-
 .../client/renderer/BlockFluidRenderer.java   |  627 ++-
 .../client/renderer/BlockModelRenderer.java   |  974 +++--
 .../client/renderer/BufferBuilder.java        |  868 ++--
 .../client/renderer/ChunkRenderContainer.java |   42 +-
 .../client/renderer/EntityRenderer.java       | 2378 +++++++----
 .../client/renderer/GlStateManager.java       |  946 +++--
 .../client/renderer/ImageBufferDownload.java  |   94 +-
 .../client/renderer/ItemRenderer.java         |  690 ++--
 .../minecraft/client/renderer/Matrix4f.java   |   34 +-
 .../client/renderer/OpenGlHelper.java         |  455 ++-
 .../client/renderer/RenderGlobal.java         | 3546 ++++++++++-------
 .../minecraft/client/renderer/RenderItem.java |  728 ++--
 .../minecraft/client/renderer/RenderList.java |   76 +-
 .../client/renderer/Tessellator.java          |   10 +-
 .../renderer/ThreadDownloadImageData.java     |  149 +-
 .../client/renderer/VboRenderList.java        |   89 +-
 .../client/renderer/VertexBufferUploader.java |   15 +-
 .../client/renderer/ViewFrustum.java          |  217 +-
 .../renderer/WorldVertexBufferUploader.java   |  132 +-
 .../renderer/block/model/BakedQuad.java       |  199 +-
 .../block/model/BakedQuadRetextured.java      |   36 +-
 .../renderer/block/model/FaceBakery.java      |  460 ++-
 .../block/model/ItemOverrideList.java         |   56 +-
 .../renderer/block/model/ModelBakery.java     |  769 ++--
 .../renderer/block/model/ModelRotation.java   |  102 +-
 .../renderer/chunk/ChunkRenderDispatcher.java |  232 +-
 .../client/renderer/chunk/CompiledChunk.java  |   57 +-
 .../client/renderer/chunk/RenderChunk.java    |  533 ++-
 .../client/renderer/chunk/SetVisibility.java  |   77 +-
 .../client/renderer/chunk/VisGraph.java       |  143 +-
 .../renderer/culling/ClippingHelper.java      |   90 +-
 .../client/renderer/culling/Frustum.java      |   27 +-
 .../debug/DebugRendererChunkBorder.java       |  170 +-
 .../client/renderer/entity/Render.java        |  418 +-
 .../renderer/entity/RenderItemFrame.java      |  150 +-
 .../client/renderer/entity/RenderLiving.java  |  232 +-
 .../renderer/entity/RenderLivingBase.java     |  479 ++-
 .../client/renderer/entity/RenderManager.java |  390 +-
 .../client/renderer/entity/RenderXPOrb.java   |   83 +-
 .../entity/layers/LayerArmorBase.java         |  272 +-
 .../renderer/entity/layers/LayerCape.java     |   88 +-
 .../renderer/entity/layers/LayerElytra.java   |   61 +-
 .../entity/layers/LayerEnderDragonEyes.java   |   39 +-
 .../entity/layers/LayerEndermanEyes.java      |   41 +-
 .../entity/layers/LayerEntityOnShoulder.java  |  180 +-
 .../entity/layers/LayerMooshroomMushroom.java |   69 +-
 .../entity/layers/LayerSheepWool.java         |   64 +-
 .../entity/layers/LayerSpiderEyes.java        |   44 +-
 .../entity/layers/LayerWolfCollar.java        |   31 +-
 .../renderer/texture/AbstractTexture.java     |   38 +-
 .../renderer/texture/DynamicTexture.java      |   36 +-
 .../renderer/texture/ITextureObject.java      |    3 +
 .../texture/LayeredColorMaskTexture.java      |   89 +-
 .../renderer/texture/LayeredTexture.java      |   38 +-
 .../renderer/texture/SimpleTexture.java       |   42 +-
 .../client/renderer/texture/Stitcher.java     |  254 +-
 .../renderer/texture/TextureAtlasSprite.java  |  559 ++-
 .../renderer/texture/TextureManager.java      |  176 +-
 .../client/renderer/texture/TextureMap.java   |  809 +++-
 .../client/renderer/texture/TextureUtil.java  |  394 +-
 .../tileentity/TileEntityBeaconRenderer.java  |  204 +-
 .../TileEntityEndPortalRenderer.java          |  265 +-
 .../TileEntityRendererDispatcher.java         |  183 +-
 .../tileentity/TileEntitySignRenderer.java    |  110 +-
 .../tileentity/TileEntitySpecialRenderer.java |   69 +-
 .../renderer/vertex/DefaultVertexFormats.java |   56 +-
 .../client/renderer/vertex/VertexBuffer.java  |   59 +-
 .../resources/AbstractResourcePack.java       |   49 +-
 .../client/resources/DefaultResourcePack.java |   80 +-
 .../net/minecraft/client/resources/I18n.java  |   18 +-
 .../resources/ResourcePackRepository.java     |  276 +-
 .../client/settings/GameSettings.java         | 2819 ++++++++++---
 patches/net/minecraft/crash/CrashReport.java  |  247 +-
 .../net/minecraft/entity/EntityLiving.java    |  902 +++--
 .../minecraft/network/PacketThreadUtil.java   |   32 +-
 .../network/datasync/EntityDataManager.java   |  231 +-
 patches/net/minecraft/potion/PotionUtils.java |  257 +-
 patches/net/minecraft/profiler/Profiler.java  |  185 +-
 .../server/integrated/IntegratedServer.java   |  403 +-
 .../server/management/PlayerChunkMap.java     |  443 +-
 .../util/ClassInheritanceMultiMap.java        |  108 +-
 patches/net/minecraft/util/EnumFacing.java    |  134 +-
 patches/net/minecraft/util/IntegerCache.java  |   10 +-
 .../net/minecraft/util/ScreenShotHelper.java  |  140 +-
 patches/net/minecraft/util/Util.java          |   36 +-
 patches/net/minecraft/util/math/ChunkPos.java |   54 +-
 .../net/minecraft/util/math/MathHelper.java   |  502 +--
 .../minecraft/util/text/translation/I18n.java |   16 +-
 patches/net/minecraft/world/GameRules.java    |   90 +-
 .../minecraft/world/WorldEntitySpawner.java   |  375 +-
 .../world/chunk/BlockStateContainer.java      |  115 +-
 .../chunk/storage/ExtendedBlockStorage.java   |   88 +-
 .../world/gen/layer/GenLayerZoom.java         |   80 +-
 115 files changed, 21908 insertions(+), 12977 deletions(-)

diff --git a/patches/net/minecraft/block/BlockAir.java b/patches/net/minecraft/block/BlockAir.java
index 9f85a40..9fb2af0 100644
--- a/patches/net/minecraft/block/BlockAir.java
+++ b/patches/net/minecraft/block/BlockAir.java
@@ -1,5 +1,7 @@
 package net.minecraft.block;
 
+import java.util.IdentityHashMap;
+import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.BlockFaceShape;
@@ -12,47 +14,56 @@
 import net.minecraft.world.World;
 
 public class BlockAir extends Block {
+   private static Map mapOriginalOpacity = new IdentityHashMap();
+
    protected BlockAir() {
       super(Material.AIR);
    }
 
-   @Override
-   public EnumBlockRenderType getRenderType(IBlockState var1) {
+   public EnumBlockRenderType getRenderType(IBlockState state) {
       return EnumBlockRenderType.INVISIBLE;
    }
 
    @Nullable
-   @Override
-   public AxisAlignedBB getCollisionBoundingBox(IBlockState var1, IBlockAccess var2, BlockPos var3) {
+   public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos) {
       return NULL_AABB;
    }
 
-   @Override
-   public boolean isOpaqueCube(IBlockState var1) {
+   public boolean isOpaqueCube(IBlockState state) {
       return false;
    }
 
-   @Override
-   public boolean canCollideCheck(IBlockState var1, boolean var2) {
+   public boolean canCollideCheck(IBlockState state, boolean hitIfLiquid) {
       return false;
    }
 
-   @Override
-   public void dropBlockAsItemWithChance(World var1, BlockPos var2, IBlockState var3, float var4, int var5) {
+   public void dropBlockAsItemWithChance(World worldIn, BlockPos pos, IBlockState state, float chance, int fortune) {
    }
 
-   @Override
-   public boolean isReplaceable(IBlockAccess var1, BlockPos var2) {
+   public boolean isReplaceable(IBlockAccess worldIn, BlockPos pos) {
       return true;
    }
 
-   @Override
-   public boolean isFullCube(IBlockState var1) {
+   public boolean isFullCube(IBlockState state) {
       return false;
    }
 
-   @Override
-   public BlockFaceShape getBlockFaceShape(IBlockAccess var1, IBlockState var2, BlockPos var3, EnumFacing var4) {
+   public static void setLightOpacity(Block block, int opacity) {
+      if (!mapOriginalOpacity.containsKey(block)) {
+         mapOriginalOpacity.put(block, block.lightOpacity);
+      }
+
+      block.lightOpacity = opacity;
+   }
+
+   public static void restoreLightOpacity(Block block) {
+      if (mapOriginalOpacity.containsKey(block)) {
+         int opacity = (Integer)mapOriginalOpacity.get(block);
+         setLightOpacity(block, opacity);
+      }
+   }
+
+   public BlockFaceShape getBlockFaceShape(IBlockAccess p_193383_1_, IBlockState p_193383_2_, BlockPos p_193383_3_, EnumFacing p_193383_4_) {
       return BlockFaceShape.UNDEFINED;
    }
 }
diff --git a/patches/net/minecraft/block/material/MapColor.java b/patches/net/minecraft/block/material/MapColor.java
index 6ff5c81..55a0384 100644
--- a/patches/net/minecraft/block/material/MapColor.java
+++ b/patches/net/minecraft/block/material/MapColor.java
@@ -57,45 +57,45 @@ public class MapColor {
    public static final MapColor GREEN_STAINED_HARDENED_CLAY = new MapColor(49, 5001770);
    public static final MapColor RED_STAINED_HARDENED_CLAY = new MapColor(50, 9321518);
    public static final MapColor BLACK_STAINED_HARDENED_CLAY = new MapColor(51, 2430480);
-   public final int colorValue;
+   public int colorValue;
    public final int colorIndex;
 
-   private MapColor(int var1, int var2) {
-      if (☃ >= 0 && ☃ <= 63) {
-         this.colorIndex = ☃;
-         this.colorValue = ☃;
-         COLORS[☃] = this;
+   private MapColor(int index, int color) {
+      if (index >= 0 && index <= 63) {
+         this.colorIndex = index;
+         this.colorValue = color;
+         COLORS[index] = this;
       } else {
          throw new IndexOutOfBoundsException("Map colour ID must be between 0 and 63 (inclusive)");
       }
    }
 
-   public int getMapColor(int var1) {
-      int ☃ = 220;
-      if (☃ == 3) {
-         ☃ = 135;
+   public int getMapColor(int index) {
+      int i = 220;
+      if (index == 3) {
+         i = 135;
       }
 
-      if (☃ == 2) {
-         ☃ = 255;
+      if (index == 2) {
+         i = 255;
       }
 
-      if (☃ == 1) {
-         ☃ = 220;
+      if (index == 1) {
+         i = 220;
       }
 
-      if (☃ == 0) {
-         ☃ = 180;
+      if (index == 0) {
+         i = 180;
       }
 
-      int ☃x = (this.colorValue >> 16 & 0xFF) * ☃ / 255;
-      int ☃xx = (this.colorValue >> 8 & 0xFF) * ☃ / 255;
-      int ☃xxx = (this.colorValue & 0xFF) * ☃ / 255;
-      return 0xFF000000 | ☃x << 16 | ☃xx << 8 | ☃xxx;
+      int j = (this.colorValue >> 16 & 0xFF) * i / 255;
+      int k = (this.colorValue >> 8 & 0xFF) * i / 255;
+      int l = (this.colorValue & 0xFF) * i / 255;
+      return 0xFF000000 | j << 16 | k << 8 | l;
    }
 
-   public static MapColor getBlockColor(EnumDyeColor var0) {
-      return BLOCK_COLORS[☃.getMetadata()];
+   public static MapColor getBlockColor(EnumDyeColor dyeColorIn) {
+      return BLOCK_COLORS[dyeColorIn.getMetadata()];
    }
 
    static {
diff --git a/patches/net/minecraft/block/state/BlockStateBase.java b/patches/net/minecraft/block/state/BlockStateBase.java
index 3d87ef4..e495047 100644
--- a/patches/net/minecraft/block/state/BlockStateBase.java
+++ b/patches/net/minecraft/block/state/BlockStateBase.java
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableTable;
 import com.google.common.collect.Iterables;
 import java.util.Collection;
 import java.util.Iterator;
@@ -9,56 +10,96 @@
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.block.properties.IProperty;
+import net.minecraft.util.ResourceLocation;
 
 public abstract class BlockStateBase implements IBlockState {
    private static final Joiner COMMA_JOINER = Joiner.on(',');
    private static final Function<Entry<IProperty<?>, Comparable<?>>, String> MAP_ENTRY_TO_STRING = new Function<Entry<IProperty<?>, Comparable<?>>, String>() {
       @Nullable
-      public String apply(@Nullable Entry<IProperty<?>, Comparable<?>> var1) {
-         if (☃ == null) {
+      public String apply(@Nullable Entry<IProperty<?>, Comparable<?>> p_apply_1_) {
+         if (p_apply_1_ == null) {
             return "<NULL>";
          } else {
-            IProperty<?> ☃ = ☃.getKey();
-            return ☃.getName() + "=" + this.getPropertyName(☃, ☃.getValue());
+            IProperty<?> iproperty = p_apply_1_.getKey();
+            return iproperty.getName() + "=" + this.getPropertyName(iproperty, p_apply_1_.getValue());
          }
       }
 
-      private <T extends Comparable<T>> String getPropertyName(IProperty<T> var1, Comparable<?> var2) {
-         return ☃.getName((T)☃);
+      private <T extends Comparable<T>> String getPropertyName(IProperty<T> property, Comparable<?> entry) {
+         return property.getName(entry);
       }
    };
+   private int blockId = -1;
+   private int blockStateId = -1;
+   private int metadata = -1;
+   private ResourceLocation blockLocation = null;
 
-   @Override
-   public <T extends Comparable<T>> IBlockState cycleProperty(IProperty<T> var1) {
-      return this.withProperty(☃, cyclePropertyValue(☃.getAllowedValues(), this.getValue(☃)));
+   public int getBlockId() {
+      if (this.blockId < 0) {
+         this.blockId = Block.getIdFromBlock(this.getBlock());
+      }
+
+      return this.blockId;
+   }
+
+   public int getBlockStateId() {
+      if (this.blockStateId < 0) {
+         this.blockStateId = Block.getStateId(this);
+      }
+
+      return this.blockStateId;
+   }
+
+   public int getMetadata() {
+      if (this.metadata < 0) {
+         this.metadata = this.getBlock().getMetaFromState(this);
+      }
+
+      return this.metadata;
+   }
+
+   public ResourceLocation getBlockLocation() {
+      if (this.blockLocation == null) {
+         this.blockLocation = (ResourceLocation)Block.REGISTRY.getNameForObject(this.getBlock());
+      }
+
+      return this.blockLocation;
+   }
+
+   public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
+      return null;
+   }
+
+   public <T extends Comparable<T>> IBlockState cycleProperty(IProperty<T> property) {
+      return this.withProperty(property, cyclePropertyValue(property.getAllowedValues(), this.getValue(property)));
    }
 
-   protected static <T> T cyclePropertyValue(Collection<T> var0, T var1) {
-      Iterator<T> ☃ = ☃.iterator();
+   protected static <T> T cyclePropertyValue(Collection<T> values, T currentValue) {
+      Iterator<T> iterator = values.iterator();
 
-      while (☃.hasNext()) {
-         if (☃.next().equals(☃)) {
-            if (☃.hasNext()) {
-               return ☃.next();
+      while (iterator.hasNext()) {
+         if (iterator.next().equals(currentValue)) {
+            if (iterator.hasNext()) {
+               return iterator.next();
             }
 
-            return ☃.iterator().next();
+            return values.iterator().next();
          }
       }
 
-      return ☃.next();
+      return iterator.next();
    }
 
    @Override
    public String toString() {
-      StringBuilder ☃ = new StringBuilder();
-      ☃.append(Block.REGISTRY.getNameForObject(this.getBlock()));
+      StringBuilder stringbuilder = new StringBuilder();
+      stringbuilder.append(Block.REGISTRY.getNameForObject(this.getBlock()));
       if (!this.getProperties().isEmpty()) {
-         ☃.append("[");
-         COMMA_JOINER.appendTo(☃, Iterables.transform(this.getProperties().entrySet(), MAP_ENTRY_TO_STRING));
-         ☃.append("]");
+         stringbuilder.append("[");
+         COMMA_JOINER.appendTo(stringbuilder, Iterables.transform(this.getProperties().entrySet(), MAP_ENTRY_TO_STRING));
+         stringbuilder.append("]");
       }
 
-      return ☃.toString();
+      return stringbuilder.toString();
    }
 }
diff --git a/patches/net/minecraft/block/state/BlockStateContainer.java b/patches/net/minecraft/block/state/BlockStateContainer.java
index 7bbd97d..b70174a 100644
--- a/patches/net/minecraft/block/state/BlockStateContainer.java
+++ b/patches/net/minecraft/block/state/BlockStateContainer.java
@@ -17,10 +17,13 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Map.Entry;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockFlower;
+import net.minecraft.block.Block.EnumOffsetType;
 import net.minecraft.block.material.EnumPushReaction;
 import net.minecraft.block.material.MapColor;
 import net.minecraft.block.material.Material;
@@ -39,59 +42,74 @@
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
+import net.minecraftforge.common.property.IUnlistedProperty;
+import net.optifine.model.BlockModelUtils;
+import net.optifine.reflect.Reflector;
 
 public class BlockStateContainer {
    private static final Pattern NAME_PATTERN = Pattern.compile("^[a-z0-9_]+$");
    private static final Function<IProperty<?>, String> GET_NAME_FUNC = new Function<IProperty<?>, String>() {
       @Nullable
-      public String apply(@Nullable IProperty<?> var1) {
-         return ☃ == null ? "<NULL>" : ☃.getName();
+      public String apply(@Nullable IProperty<?> p_apply_1_) {
+         return p_apply_1_ == null ? "<NULL>" : p_apply_1_.getName();
       }
    };
    private final Block block;
    private final ImmutableSortedMap<String, IProperty<?>> properties;
    private final ImmutableList<IBlockState> validStates;
 
-   public BlockStateContainer(Block var1, IProperty<?>... var2) {
-      this.block = ☃;
-      Map<String, IProperty<?>> ☃ = Maps.newHashMap();
+   public BlockStateContainer(Block blockIn, IProperty<?>... properties) {
+      this(blockIn, properties, null);
+   }
+
+   protected BlockStateContainer.StateImplementation createState(
+      Block block, ImmutableMap<IProperty<?>, Comparable<?>> properties, @Nullable ImmutableMap<IUnlistedProperty<?>, Optional<?>> unlistedProperties
+   ) {
+      return new BlockStateContainer.StateImplementation(block, properties);
+   }
 
-      for (IProperty<?> ☃x : ☃) {
-         validateProperty(☃, ☃x);
-         ☃.put(☃x.getName(), ☃x);
+   protected BlockStateContainer(Block blockIn, IProperty<?>[] properties, ImmutableMap<IUnlistedProperty<?>, Optional<?>> unlistedProperties) {
+      this.block = blockIn;
+      Map<String, IProperty<?>> map = Maps.newHashMap();
+
+      for (IProperty<?> iproperty : properties) {
+         validateProperty(blockIn, iproperty);
+         map.put(iproperty.getName(), iproperty);
       }
 
-      this.properties = ImmutableSortedMap.copyOf(☃);
-      Map<Map<IProperty<?>, Comparable<?>>, BlockStateContainer.StateImplementation> ☃x = Maps.newLinkedHashMap();
-      List<BlockStateContainer.StateImplementation> ☃xx = Lists.newArrayList();
+      this.properties = ImmutableSortedMap.copyOf(map);
+      Map<Map<IProperty<?>, Comparable<?>>, BlockStateContainer.StateImplementation> map2 = Maps.newLinkedHashMap();
+      List<BlockStateContainer.StateImplementation> list1 = Lists.newArrayList();
 
-      for (List<Comparable<?>> ☃xxx : Cartesian.cartesianProduct(this.getAllowedValues())) {
-         Map<IProperty<?>, Comparable<?>> ☃xxxx = MapPopulator.createMap(this.properties.values(), ☃xxx);
-         BlockStateContainer.StateImplementation ☃xxxxx = new BlockStateContainer.StateImplementation(☃, ImmutableMap.copyOf(☃xxxx));
-         ☃x.put(☃xxxx, ☃xxxxx);
-         ☃xx.add(☃xxxxx);
+      for (List<Comparable<?>> list : Cartesian.cartesianProduct(this.getAllowedValues())) {
+         Map<IProperty<?>, Comparable<?>> map1 = MapPopulator.createMap(this.properties.values(), list);
+         BlockStateContainer.StateImplementation blockstatecontainer$stateimplementation = this.createState(
+            blockIn, ImmutableMap.copyOf(map1), unlistedProperties
+         );
+         map2.put(map1, blockstatecontainer$stateimplementation);
+         list1.add(blockstatecontainer$stateimplementation);
       }
 
-      for (BlockStateContainer.StateImplementation ☃xxx : ☃xx) {
-         ☃xxx.buildPropertyValueTable(☃x);
+      for (BlockStateContainer.StateImplementation blockstatecontainer$stateimplementation1 : list1) {
+         blockstatecontainer$stateimplementation1.buildPropertyValueTable(map2);
       }
 
-      this.validStates = ImmutableList.copyOf(☃xx);
+      this.validStates = ImmutableList.copyOf(list1);
    }
 
-   public static <T extends Comparable<T>> String validateProperty(Block var0, IProperty<T> var1) {
-      String ☃ = ☃.getName();
-      if (!NAME_PATTERN.matcher(☃).matches()) {
-         throw new IllegalArgumentException("Block: " + ☃.getClass() + " has invalidly named property: " + ☃);
+   public static <T extends Comparable<T>> String validateProperty(Block block, IProperty<T> property) {
+      String s = property.getName();
+      if (!NAME_PATTERN.matcher(s).matches()) {
+         throw new IllegalArgumentException("Block: " + block.getClass() + " has invalidly named property: " + s);
       } else {
-         for (T ☃x : ☃.getAllowedValues()) {
-            String ☃xx = ☃.getName(☃x);
-            if (!NAME_PATTERN.matcher(☃xx).matches()) {
-               throw new IllegalArgumentException("Block: " + ☃.getClass() + " has property: " + ☃ + " with invalidly named value: " + ☃xx);
+         for (T t : property.getAllowedValues()) {
+            String s1 = property.getName(t);
+            if (!NAME_PATTERN.matcher(s1).matches()) {
+               throw new IllegalArgumentException("Block: " + block.getClass() + " has property: " + s + " with invalidly named value: " + s1);
             }
          }
 
-         return ☃;
+         return s;
       }
    }
 
@@ -100,16 +118,16 @@ public ImmutableList<IBlockState> getValidStates() {
    }
 
    private List<Iterable<Comparable<?>>> getAllowedValues() {
-      List<Iterable<Comparable<?>>> ☃ = Lists.newArrayList();
-      ImmutableCollection<IProperty<?>> ☃x = this.properties.values();
-      UnmodifiableIterator var3 = ☃x.iterator();
+      List<Iterable<Comparable<?>>> list = Lists.newArrayList();
+      ImmutableCollection<IProperty<?>> immutablecollection = this.properties.values();
+      UnmodifiableIterator unmodifiableiterator = immutablecollection.iterator();
 
-      while (var3.hasNext()) {
-         IProperty<?> ☃xx = (IProperty<?>)var3.next();
-         ☃.add((Iterable<Comparable<?>>)☃xx.getAllowedValues());
+      while (unmodifiableiterator.hasNext()) {
+         IProperty<?> iproperty = (IProperty<?>)unmodifiableiterator.next();
+         list.add(iproperty.getAllowedValues());
       }
 
-      return ☃;
+      return list;
    }
 
    public IBlockState getBaseState() {
@@ -133,8 +151,46 @@ public String toString() {
    }
 
    @Nullable
-   public IProperty<?> getProperty(String var1) {
-      return (IProperty<?>)this.properties.get(☃);
+   public IProperty<?> getProperty(String propertyName) {
+      return (IProperty<?>)this.properties.get(propertyName);
+   }
+
+   public static class Builder {
+      private final Block block;
+      private final List<IProperty<?>> listed = Lists.newArrayList();
+      private final List<IUnlistedProperty<?>> unlisted = Lists.newArrayList();
+
+      public Builder(Block block) {
+         this.block = block;
+      }
+
+      public BlockStateContainer.Builder add(IProperty<?>... props) {
+         for (IProperty<?> prop : props) {
+            this.listed.add(prop);
+         }
+
+         return this;
+      }
+
+      public BlockStateContainer.Builder add(IUnlistedProperty<?>... props) {
+         for (IUnlistedProperty<?> prop : props) {
+            this.unlisted.add(prop);
+         }
+
+         return this;
+      }
+
+      public BlockStateContainer build() {
+         IProperty<?>[] listed = new IProperty[this.listed.size()];
+         listed = this.listed.toArray(listed);
+         if (this.unlisted.size() == 0) {
+            return new BlockStateContainer(this.block, listed);
+         } else {
+            IUnlistedProperty<?>[] unlisted = new IUnlistedProperty[this.unlisted.size()];
+            unlisted = this.unlisted.toArray(unlisted);
+            return (BlockStateContainer)Reflector.newInstance(Reflector.ExtendedBlockState_Constructor, new Object[]{this.block, listed, unlisted});
+         }
+      }
    }
 
    static class StateImplementation extends BlockStateBase {
@@ -142,58 +198,67 @@ static class StateImplementation extends BlockStateBase {
       private final ImmutableMap<IProperty<?>, Comparable<?>> properties;
       private ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> propertyValueTable;
 
-      private StateImplementation(Block var1, ImmutableMap<IProperty<?>, Comparable<?>> var2) {
-         this.block = ☃;
-         this.properties = ☃;
+      private StateImplementation(Block blockIn, ImmutableMap<IProperty<?>, Comparable<?>> propertiesIn) {
+         this.block = blockIn;
+         this.properties = propertiesIn;
+      }
+
+      protected StateImplementation(
+         Block blockIn, ImmutableMap<IProperty<?>, Comparable<?>> propertiesIn, ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> propertyValueTable
+      ) {
+         this.block = blockIn;
+         this.properties = propertiesIn;
+         this.propertyValueTable = propertyValueTable;
       }
 
-      @Override
       public Collection<IProperty<?>> getPropertyKeys() {
          return Collections.unmodifiableCollection(this.properties.keySet());
       }
 
-      @Override
-      public <T extends Comparable<T>> T getValue(IProperty<T> var1) {
-         Comparable<?> ☃ = (Comparable<?>)this.properties.get(☃);
-         if (☃ == null) {
-            throw new IllegalArgumentException("Cannot get property " + ☃ + " as it does not exist in " + this.block.getBlockState());
+      public <T extends Comparable<T>> T getValue(IProperty<T> property) {
+         Comparable<?> comparable = (Comparable<?>)this.properties.get(property);
+         if (comparable == null) {
+            throw new IllegalArgumentException("Cannot get property " + property + " as it does not exist in " + this.block.getBlockState());
          } else {
-            return ☃.getValueClass().cast(☃);
+            return (T)property.getValueClass().cast(comparable);
          }
       }
 
-      @Override
-      public <T extends Comparable<T>, V extends T> IBlockState withProperty(IProperty<T> var1, V var2) {
-         Comparable<?> ☃ = (Comparable<?>)this.properties.get(☃);
-         if (☃ == null) {
-            throw new IllegalArgumentException("Cannot set property " + ☃ + " as it does not exist in " + this.block.getBlockState());
-         } else if (☃ == ☃) {
+      public <T extends Comparable<T>, V extends T> IBlockState withProperty(IProperty<T> property, V value) {
+         Comparable<?> comparable = (Comparable<?>)this.properties.get(property);
+         if (comparable == null) {
+            throw new IllegalArgumentException("Cannot set property " + property + " as it does not exist in " + this.block.getBlockState());
+         } else if (comparable == value) {
             return this;
          } else {
-            IBlockState ☃x = (IBlockState)this.propertyValueTable.get(☃, ☃);
-            if (☃x == null) {
+            IBlockState iblockstate = (IBlockState)this.propertyValueTable.get(property, value);
+            if (iblockstate == null) {
                throw new IllegalArgumentException(
-                  "Cannot set property " + ☃ + " to " + ☃ + " on block " + Block.REGISTRY.getNameForObject(this.block) + ", it is not an allowed value"
+                  "Cannot set property "
+                     + property
+                     + " to "
+                     + value
+                     + " on block "
+                     + Block.REGISTRY.getNameForObject(this.block)
+                     + ", it is not an allowed value"
                );
             } else {
-               return ☃x;
+               return iblockstate;
             }
          }
       }
 
-      @Override
       public ImmutableMap<IProperty<?>, Comparable<?>> getProperties() {
          return this.properties;
       }
 
-      @Override
       public Block getBlock() {
          return this.block;
       }
 
       @Override
-      public boolean equals(Object var1) {
-         return this == ☃;
+      public boolean equals(Object p_equals_1_) {
+         return this == p_equals_1_;
       }
 
       @Override
@@ -201,228 +266,222 @@ public int hashCode() {
          return this.properties.hashCode();
       }
 
-      public void buildPropertyValueTable(Map<Map<IProperty<?>, Comparable<?>>, BlockStateContainer.StateImplementation> var1) {
+      public void buildPropertyValueTable(Map<Map<IProperty<?>, Comparable<?>>, BlockStateContainer.StateImplementation> map) {
          if (this.propertyValueTable != null) {
             throw new IllegalStateException();
          } else {
-            Table<IProperty<?>, Comparable<?>, IBlockState> ☃ = HashBasedTable.create();
-            UnmodifiableIterator var3 = this.properties.entrySet().iterator();
+            Table<IProperty<?>, Comparable<?>, IBlockState> table = HashBasedTable.create();
+            UnmodifiableIterator unmodifiableiterator = this.properties.entrySet().iterator();
 
-            while (var3.hasNext()) {
-               Entry<IProperty<?>, Comparable<?>> ☃x = (Entry<IProperty<?>, Comparable<?>>)var3.next();
-               IProperty<?> ☃xx = ☃x.getKey();
+            while (unmodifiableiterator.hasNext()) {
+               Entry<IProperty<?>, Comparable<?>> entry = (Entry<IProperty<?>, Comparable<?>>)unmodifiableiterator.next();
+               IProperty<?> iproperty = entry.getKey();
 
-               for (Comparable<?> ☃xxx : ☃xx.getAllowedValues()) {
-                  if (☃xxx != ☃x.getValue()) {
-                     ☃.put(☃xx, ☃xxx, ☃.get(this.getPropertiesWithValue(☃xx, ☃xxx)));
+               for (Comparable<?> comparable : iproperty.getAllowedValues()) {
+                  if (comparable != entry.getValue()) {
+                     table.put(iproperty, comparable, map.get(this.getPropertiesWithValue(iproperty, comparable)));
                   }
                }
             }
 
-            this.propertyValueTable = ImmutableTable.copyOf(☃);
+            this.propertyValueTable = ImmutableTable.copyOf(table);
          }
       }
 
-      private Map<IProperty<?>, Comparable<?>> getPropertiesWithValue(IProperty<?> var1, Comparable<?> var2) {
-         Map<IProperty<?>, Comparable<?>> ☃ = Maps.newHashMap(this.properties);
-         ☃.put(☃, ☃);
-         return ☃;
+      private Map<IProperty<?>, Comparable<?>> getPropertiesWithValue(IProperty<?> property, Comparable<?> value) {
+         Map<IProperty<?>, Comparable<?>> map = Maps.newHashMap(this.properties);
+         map.put(property, value);
+         return map;
       }
 
-      @Override
       public Material getMaterial() {
          return this.block.getMaterial(this);
       }
 
-      @Override
       public boolean isFullBlock() {
          return this.block.isFullBlock(this);
       }
 
-      @Override
-      public boolean canEntitySpawn(Entity var1) {
-         return this.block.canEntitySpawn(this, ☃);
+      public boolean canEntitySpawn(Entity entityIn) {
+         return this.block.canEntitySpawn(this, entityIn);
       }
 
-      @Override
       public int getLightOpacity() {
          return this.block.getLightOpacity(this);
       }
 
-      @Override
       public int getLightValue() {
          return this.block.getLightValue(this);
       }
 
-      @Override
       public boolean isTranslucent() {
          return this.block.isTranslucent(this);
       }
 
-      @Override
       public boolean useNeighborBrightness() {
          return this.block.getUseNeighborBrightness(this);
       }
 
-      @Override
-      public MapColor getMapColor(IBlockAccess var1, BlockPos var2) {
-         return this.block.getMapColor(this, ☃, ☃);
+      public MapColor getMapColor(IBlockAccess p_185909_1_, BlockPos p_185909_2_) {
+         return this.block.getMapColor(this, p_185909_1_, p_185909_2_);
       }
 
-      @Override
-      public IBlockState withRotation(Rotation var1) {
-         return this.block.withRotation(this, ☃);
+      public IBlockState withRotation(Rotation rot) {
+         return this.block.withRotation(this, rot);
       }
 
-      @Override
-      public IBlockState withMirror(Mirror var1) {
-         return this.block.withMirror(this, ☃);
+      public IBlockState withMirror(Mirror mirrorIn) {
+         return this.block.withMirror(this, mirrorIn);
       }
 
-      @Override
       public boolean isFullCube() {
          return this.block.isFullCube(this);
       }
 
-      @Override
       public boolean hasCustomBreakingProgress() {
          return this.block.hasCustomBreakingProgress(this);
       }
 
-      @Override
       public EnumBlockRenderType getRenderType() {
          return this.block.getRenderType(this);
       }
 
-      @Override
-      public int getPackedLightmapCoords(IBlockAccess var1, BlockPos var2) {
-         return this.block.getPackedLightmapCoords(this, ☃, ☃);
+      public int getPackedLightmapCoords(IBlockAccess source, BlockPos pos) {
+         return this.block.getPackedLightmapCoords(this, source, pos);
       }
 
-      @Override
       public float getAmbientOcclusionLightValue() {
          return this.block.getAmbientOcclusionLightValue(this);
       }
 
-      @Override
       public boolean isBlockNormalCube() {
          return this.block.isBlockNormalCube(this);
       }
 
-      @Override
       public boolean isNormalCube() {
          return this.block.isNormalCube(this);
       }
 
-      @Override
       public boolean canProvidePower() {
          return this.block.canProvidePower(this);
       }
 
-      @Override
-      public int getWeakPower(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
-         return this.block.getWeakPower(this, ☃, ☃, ☃);
+      public int getWeakPower(IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+         return this.block.getWeakPower(this, blockAccess, pos, side);
       }
 
-      @Override
       public boolean hasComparatorInputOverride() {
          return this.block.hasComparatorInputOverride(this);
       }
 
-      @Override
-      public int getComparatorInputOverride(World var1, BlockPos var2) {
-         return this.block.getComparatorInputOverride(this, ☃, ☃);
+      public int getComparatorInputOverride(World worldIn, BlockPos pos) {
+         return this.block.getComparatorInputOverride(this, worldIn, pos);
       }
 
-      @Override
-      public float getBlockHardness(World var1, BlockPos var2) {
-         return this.block.getBlockHardness(this, ☃, ☃);
+      public float getBlockHardness(World worldIn, BlockPos pos) {
+         return this.block.getBlockHardness(this, worldIn, pos);
       }
 
-      @Override
-      public float getPlayerRelativeBlockHardness(EntityPlayer var1, World var2, BlockPos var3) {
-         return this.block.getPlayerRelativeBlockHardness(this, ☃, ☃, ☃);
+      public float getPlayerRelativeBlockHardness(EntityPlayer player, World worldIn, BlockPos pos) {
+         return this.block.getPlayerRelativeBlockHardness(this, player, worldIn, pos);
       }
 
-      @Override
-      public int getStrongPower(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
-         return this.block.getStrongPower(this, ☃, ☃, ☃);
+      public int getStrongPower(IBlockAccess blockAccess, BlockPos pos, EnumFacing side) {
+         return this.block.getStrongPower(this, blockAccess, pos, side);
       }
 
-      @Override
       public EnumPushReaction getPushReaction() {
          return this.block.getPushReaction(this);
       }
 
-      @Override
-      public IBlockState getActualState(IBlockAccess var1, BlockPos var2) {
-         return this.block.getActualState(this, ☃, ☃);
+      public IBlockState getActualState(IBlockAccess blockAccess, BlockPos pos) {
+         return this.block.getActualState(this, blockAccess, pos);
       }
 
-      @Override
-      public AxisAlignedBB getSelectedBoundingBox(World var1, BlockPos var2) {
-         return this.block.getSelectedBoundingBox(this, ☃, ☃);
+      public AxisAlignedBB getSelectedBoundingBox(World worldIn, BlockPos pos) {
+         return this.block.getSelectedBoundingBox(this, worldIn, pos);
       }
 
-      @Override
-      public boolean shouldSideBeRendered(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
-         return this.block.shouldSideBeRendered(this, ☃, ☃, ☃);
+      public boolean shouldSideBeRendered(IBlockAccess blockAccess, BlockPos pos, EnumFacing facing) {
+         return this.block.shouldSideBeRendered(this, blockAccess, pos, facing);
       }
 
-      @Override
       public boolean isOpaqueCube() {
          return this.block.isOpaqueCube(this);
       }
 
       @Nullable
-      @Override
-      public AxisAlignedBB getCollisionBoundingBox(IBlockAccess var1, BlockPos var2) {
-         return this.block.getCollisionBoundingBox(this, ☃, ☃);
+      public AxisAlignedBB getCollisionBoundingBox(IBlockAccess worldIn, BlockPos pos) {
+         return this.block.getCollisionBoundingBox(this, worldIn, pos);
       }
 
-      @Override
-      public void addCollisionBoxToList(World var1, BlockPos var2, AxisAlignedBB var3, List<AxisAlignedBB> var4, @Nullable Entity var5, boolean var6) {
-         this.block.addCollisionBoxToList(this, ☃, ☃, ☃, ☃, ☃, ☃);
+      public void addCollisionBoxToList(
+         World worldIn, BlockPos pos, AxisAlignedBB entityBox, List<AxisAlignedBB> collidingBoxes, @Nullable Entity entityIn, boolean p_185908_6_
+      ) {
+         this.block.addCollisionBoxToList(this, worldIn, pos, entityBox, collidingBoxes, entityIn, p_185908_6_);
       }
 
-      @Override
-      public AxisAlignedBB getBoundingBox(IBlockAccess var1, BlockPos var2) {
-         return this.block.getBoundingBox(this, ☃, ☃);
+      public AxisAlignedBB getBoundingBox(IBlockAccess blockAccess, BlockPos pos) {
+         EnumOffsetType offsetType = this.block.getOffsetType();
+         if (offsetType != EnumOffsetType.NONE && !(this.block instanceof BlockFlower)) {
+            AxisAlignedBB aabb = this.block.getBoundingBox(this, blockAccess, pos);
+            return BlockModelUtils.getOffsetBoundingBox(aabb, offsetType, pos);
+         } else {
+            return this.block.getBoundingBox(this, blockAccess, pos);
+         }
       }
 
-      @Override
-      public RayTraceResult collisionRayTrace(World var1, BlockPos var2, Vec3d var3, Vec3d var4) {
-         return this.block.collisionRayTrace(this, ☃, ☃, ☃, ☃);
+      public RayTraceResult collisionRayTrace(World worldIn, BlockPos pos, Vec3d start, Vec3d end) {
+         return this.block.collisionRayTrace(this, worldIn, pos, start, end);
       }
 
-      @Override
       public boolean isTopSolid() {
          return this.block.isTopSolid(this);
       }
 
-      @Override
-      public Vec3d getOffset(IBlockAccess var1, BlockPos var2) {
-         return this.block.getOffset(this, ☃, ☃);
+      public Vec3d getOffset(IBlockAccess access, BlockPos pos) {
+         return this.block.getOffset(this, access, pos);
       }
 
-      @Override
-      public boolean onBlockEventReceived(World var1, BlockPos var2, int var3, int var4) {
-         return this.block.eventReceived(this, ☃, ☃, ☃, ☃);
+      public boolean onBlockEventReceived(World worldIn, BlockPos pos, int id, int param) {
+         return this.block.eventReceived(this, worldIn, pos, id, param);
       }
 
-      @Override
-      public void neighborChanged(World var1, BlockPos var2, Block var3, BlockPos var4) {
-         this.block.neighborChanged(this, ☃, ☃, ☃, ☃);
+      public void neighborChanged(World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) {
+         this.block.neighborChanged(this, worldIn, pos, blockIn, fromPos);
       }
 
-      @Override
       public boolean causesSuffocation() {
          return this.block.causesSuffocation(this);
       }
 
       @Override
-      public BlockFaceShape getBlockFaceShape(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
-         return this.block.getBlockFaceShape(☃, this, ☃, ☃);
+      public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
+         return this.propertyValueTable;
+      }
+
+      public int getLightOpacity(IBlockAccess world, BlockPos pos) {
+         return Reflector.callInt(this.block, Reflector.ForgeBlock_getLightOpacity, new Object[]{this, world, pos});
+      }
+
+      public int getLightValue(IBlockAccess world, BlockPos pos) {
+         return Reflector.callInt(this.block, Reflector.ForgeBlock_getLightValue, new Object[]{this, world, pos});
+      }
+
+      public boolean isSideSolid(IBlockAccess world, BlockPos pos, EnumFacing side) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_isSideSolid, new Object[]{this, world, pos, side});
+      }
+
+      public boolean doesSideBlockChestOpening(IBlockAccess world, BlockPos pos, EnumFacing side) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_doesSideBlockChestOpening, new Object[]{this, world, pos, side});
+      }
+
+      public boolean doesSideBlockRendering(IBlockAccess world, BlockPos pos, EnumFacing side) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_doesSideBlockRendering, new Object[]{this, world, pos, side});
+      }
+
+      public BlockFaceShape getBlockFaceShape(IBlockAccess p_193401_1_, BlockPos p_193401_2_, EnumFacing p_193401_3_) {
+         return this.block.getBlockFaceShape(p_193401_1_, this, p_193401_2_, p_193401_3_);
       }
    }
 }
diff --git a/patches/net/minecraft/client/LoadingScreenRenderer.java b/patches/net/minecraft/client/LoadingScreenRenderer.java
index 381e4e7..1fce5e1 100644
--- a/patches/net/minecraft/client/LoadingScreenRenderer.java
+++ b/patches/net/minecraft/client/LoadingScreenRenderer.java
@@ -10,6 +10,9 @@
 import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.MinecraftError;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
+import net.optifine.reflect.Reflector;
 
 public class LoadingScreenRenderer implements IProgressUpdate {
    private String message = "";
@@ -20,27 +23,25 @@ public class LoadingScreenRenderer implements IProgressUpdate {
    private final ScaledResolution scaledResolution;
    private final Framebuffer framebuffer;
 
-   public LoadingScreenRenderer(Minecraft var1) {
-      this.mc = ☃;
-      this.scaledResolution = new ScaledResolution(☃);
-      this.framebuffer = new Framebuffer(☃.displayWidth, ☃.displayHeight, false);
+   public LoadingScreenRenderer(Minecraft mcIn) {
+      this.mc = mcIn;
+      this.scaledResolution = new ScaledResolution(mcIn);
+      this.framebuffer = new Framebuffer(mcIn.displayWidth, mcIn.displayHeight, false);
       this.framebuffer.setFramebufferFilter(9728);
    }
 
-   @Override
-   public void resetProgressAndMessage(String var1) {
+   public void resetProgressAndMessage(String message) {
       this.loadingSuccess = false;
-      this.displayString(☃);
+      this.displayString(message);
    }
 
-   @Override
-   public void displaySavingString(String var1) {
+   public void displaySavingString(String message) {
       this.loadingSuccess = true;
-      this.displayString(☃);
+      this.displayString(message);
    }
 
-   private void displayString(String var1) {
-      this.currentlyDisplayedText = ☃;
+   private void displayString(String message) {
+      this.currentlyDisplayedText = message;
       if (!this.mc.running) {
          if (!this.loadingSuccess) {
             throw new MinecraftError();
@@ -50,11 +51,11 @@ private void displayString(String var1) {
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
          if (OpenGlHelper.isFramebufferEnabled()) {
-            int ☃ = this.scaledResolution.getScaleFactor();
-            GlStateManager.ortho(0.0, this.scaledResolution.getScaledWidth() * ☃, this.scaledResolution.getScaledHeight() * ☃, 0.0, 100.0, 300.0);
+            int i = this.scaledResolution.getScaleFactor();
+            GlStateManager.ortho(0.0, this.scaledResolution.getScaledWidth() * i, this.scaledResolution.getScaledHeight() * i, 0.0, 100.0, 300.0);
          } else {
-            ScaledResolution ☃ = new ScaledResolution(this.mc);
-            GlStateManager.ortho(0.0, ☃.getScaledWidth_double(), ☃.getScaledHeight_double(), 0.0, 100.0, 300.0);
+            ScaledResolution scaledresolution = new ScaledResolution(this.mc);
+            GlStateManager.ortho(0.0, scaledresolution.getScaledWidth_double(), scaledresolution.getScaledHeight_double(), 0.0, 100.0, 300.0);
          }
 
          GlStateManager.matrixMode(5888);
@@ -63,34 +64,32 @@ private void displayString(String var1) {
       }
    }
 
-   @Override
-   public void displayLoadingString(String var1) {
+   public void displayLoadingString(String message) {
       if (!this.mc.running) {
          if (!this.loadingSuccess) {
             throw new MinecraftError();
          }
       } else {
          this.systemTime = 0L;
-         this.message = ☃;
+         this.message = message;
          this.setLoadingProgress(-1);
          this.systemTime = 0L;
       }
    }
 
-   @Override
-   public void setLoadingProgress(int var1) {
+   public void setLoadingProgress(int progress) {
       if (!this.mc.running) {
          if (!this.loadingSuccess) {
             throw new MinecraftError();
          }
       } else {
-         long ☃ = Minecraft.getSystemTime();
-         if (☃ - this.systemTime >= 100L) {
-            this.systemTime = ☃;
-            ScaledResolution ☃x = new ScaledResolution(this.mc);
-            int ☃xx = ☃x.getScaleFactor();
-            int ☃xxx = ☃x.getScaledWidth();
-            int ☃xxxx = ☃x.getScaledHeight();
+         long i = Minecraft.getSystemTime();
+         if (i - this.systemTime >= 100L) {
+            this.systemTime = i;
+            ScaledResolution scaledresolution = new ScaledResolution(this.mc);
+            int j = scaledresolution.getScaleFactor();
+            int k = scaledresolution.getScaledWidth();
+            int l = scaledresolution.getScaledHeight();
             if (OpenGlHelper.isFramebufferEnabled()) {
                this.framebuffer.framebufferClear();
             } else {
@@ -100,7 +99,7 @@ public void setLoadingProgress(int var1) {
             this.framebuffer.bindFramebuffer(false);
             GlStateManager.matrixMode(5889);
             GlStateManager.loadIdentity();
-            GlStateManager.ortho(0.0, ☃x.getScaledWidth_double(), ☃x.getScaledHeight_double(), 0.0, 100.0, 300.0);
+            GlStateManager.ortho(0.0, scaledresolution.getScaledWidth_double(), scaledresolution.getScaledHeight_double(), 0.0, 100.0, 300.0);
             GlStateManager.matrixMode(5888);
             GlStateManager.loadIdentity();
             GlStateManager.translate(0.0F, 0.0F, -200.0F);
@@ -108,66 +107,80 @@ public void setLoadingProgress(int var1) {
                GlStateManager.clear(16640);
             }
 
-            Tessellator ☃xxxxx = Tessellator.getInstance();
-            BufferBuilder ☃xxxxxx = ☃xxxxx.getBuffer();
-            this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
-            float ☃xxxxxxx = 32.0F;
-            ☃xxxxxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            ☃xxxxxx.pos(0.0, ☃xxxx, 0.0).tex(0.0, ☃xxxx / 32.0F).color(64, 64, 64, 255).endVertex();
-            ☃xxxxxx.pos(☃xxx, ☃xxxx, 0.0).tex(☃xxx / 32.0F, ☃xxxx / 32.0F).color(64, 64, 64, 255).endVertex();
-            ☃xxxxxx.pos(☃xxx, 0.0, 0.0).tex(☃xxx / 32.0F, 0.0).color(64, 64, 64, 255).endVertex();
-            ☃xxxxxx.pos(0.0, 0.0, 0.0).tex(0.0, 0.0).color(64, 64, 64, 255).endVertex();
-            ☃xxxxx.draw();
-            if (☃ >= 0) {
-               int ☃xxxxxxxx = 100;
-               int ☃xxxxxxxxx = 2;
-               int ☃xxxxxxxxxx = ☃xxx / 2 - 50;
-               int ☃xxxxxxxxxxx = ☃xxxx / 2 + 16;
-               GlStateManager.disableTexture2D();
-               ☃xxxxxx.begin(7, DefaultVertexFormats.POSITION_COLOR);
-               ☃xxxxxx.pos(☃xxxxxxxxxx, ☃xxxxxxxxxxx, 0.0).color(128, 128, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx, ☃xxxxxxxxxxx + 2, 0.0).color(128, 128, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx + 100, ☃xxxxxxxxxxx + 2, 0.0).color(128, 128, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx + 100, ☃xxxxxxxxxxx, 0.0).color(128, 128, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx, ☃xxxxxxxxxxx, 0.0).color(128, 255, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx, ☃xxxxxxxxxxx + 2, 0.0).color(128, 255, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx + ☃, ☃xxxxxxxxxxx + 2, 0.0).color(128, 255, 128, 255).endVertex();
-               ☃xxxxxx.pos(☃xxxxxxxxxx + ☃, ☃xxxxxxxxxxx, 0.0).color(128, 255, 128, 255).endVertex();
-               ☃xxxxx.draw();
-               GlStateManager.enableTexture2D();
+            boolean render = true;
+            if (Reflector.FMLClientHandler_handleLoadingScreen.exists()) {
+               Object fch = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+               if (fch != null) {
+                  render = !Reflector.callBoolean(fch, Reflector.FMLClientHandler_handleLoadingScreen, new Object[]{scaledresolution});
+               }
             }
 
-            GlStateManager.enableBlend();
-            GlStateManager.tryBlendFuncSeparate(
-               GlStateManager.SourceFactor.SRC_ALPHA,
-               GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
-               GlStateManager.SourceFactor.ONE,
-               GlStateManager.DestFactor.ZERO
-            );
-            this.mc
-               .fontRenderer
-               .drawStringWithShadow(
-                  this.currentlyDisplayedText, (☃xxx - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2, ☃xxxx / 2 - 4 - 16, 16777215
+            if (render) {
+               Tessellator tessellator = Tessellator.getInstance();
+               BufferBuilder bufferbuilder = tessellator.getBuffer();
+               CustomLoadingScreen scr = CustomLoadingScreens.getCustomLoadingScreen();
+               if (scr != null) {
+                  scr.drawBackground(scaledresolution.getScaledWidth(), scaledresolution.getScaledHeight());
+               } else {
+                  this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
+                  float f = 32.0F;
+                  bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+                  bufferbuilder.pos(0.0, l, 0.0).tex(0.0, l / 32.0F).color(64, 64, 64, 255).endVertex();
+                  bufferbuilder.pos(k, l, 0.0).tex(k / 32.0F, l / 32.0F).color(64, 64, 64, 255).endVertex();
+                  bufferbuilder.pos(k, 0.0, 0.0).tex(k / 32.0F, 0.0).color(64, 64, 64, 255).endVertex();
+                  bufferbuilder.pos(0.0, 0.0, 0.0).tex(0.0, 0.0).color(64, 64, 64, 255).endVertex();
+                  tessellator.draw();
+               }
+
+               if (progress >= 0) {
+                  int i1 = 100;
+                  int j1 = 2;
+                  int k1 = k / 2 - 50;
+                  int l1 = l / 2 + 16;
+                  GlStateManager.disableTexture2D();
+                  bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
+                  bufferbuilder.pos(k1, l1, 0.0).color(128, 128, 128, 255).endVertex();
+                  bufferbuilder.pos(k1, l1 + 2, 0.0).color(128, 128, 128, 255).endVertex();
+                  bufferbuilder.pos(k1 + 100, l1 + 2, 0.0).color(128, 128, 128, 255).endVertex();
+                  bufferbuilder.pos(k1 + 100, l1, 0.0).color(128, 128, 128, 255).endVertex();
+                  bufferbuilder.pos(k1, l1, 0.0).color(128, 255, 128, 255).endVertex();
+                  bufferbuilder.pos(k1, l1 + 2, 0.0).color(128, 255, 128, 255).endVertex();
+                  bufferbuilder.pos(k1 + progress, l1 + 2, 0.0).color(128, 255, 128, 255).endVertex();
+                  bufferbuilder.pos(k1 + progress, l1, 0.0).color(128, 255, 128, 255).endVertex();
+                  tessellator.draw();
+                  GlStateManager.enableTexture2D();
+               }
+
+               GlStateManager.enableBlend();
+               GlStateManager.tryBlendFuncSeparate(
+                  GlStateManager.SourceFactor.SRC_ALPHA,
+                  GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+                  GlStateManager.SourceFactor.ONE,
+                  GlStateManager.DestFactor.ZERO
                );
-            this.mc
-               .fontRenderer
-               .drawStringWithShadow(this.message, (☃xxx - this.mc.fontRenderer.getStringWidth(this.message)) / 2, ☃xxxx / 2 - 4 + 8, 16777215);
+               this.mc
+                  .fontRenderer
+                  .drawStringWithShadow(
+                     this.currentlyDisplayedText, (k - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2, l / 2 - 4 - 16, 16777215
+                  );
+               this.mc.fontRenderer.drawStringWithShadow(this.message, (k - this.mc.fontRenderer.getStringWidth(this.message)) / 2, l / 2 - 4 + 8, 16777215);
+            }
+
             this.framebuffer.unbindFramebuffer();
             if (OpenGlHelper.isFramebufferEnabled()) {
-               this.framebuffer.framebufferRender(☃xxx * ☃xx, ☃xxxx * ☃xx);
+               this.framebuffer.framebufferRender(k * j, l * j);
             }
 
             this.mc.updateDisplay();
 
             try {
                Thread.yield();
-            } catch (Exception var15) {
+            } catch (Exception var16) {
             }
          }
       }
    }
 
-   @Override
    public void setDoneWorking() {
    }
 }
diff --git a/patches/net/minecraft/client/entity/AbstractClientPlayer.java b/patches/net/minecraft/client/entity/AbstractClientPlayer.java
index 2aef75c..80edf49 100644
--- a/patches/net/minecraft/client/entity/AbstractClientPlayer.java
+++ b/patches/net/minecraft/client/entity/AbstractClientPlayer.java
@@ -1,6 +1,7 @@
 package net.minecraft.client.entity;
 
 import com.mojang.authlib.GameProfile;
+import java.io.File;
 import javax.annotation.Nullable;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.network.NetworkPlayerInfo;
@@ -11,33 +12,49 @@
 import net.minecraft.client.resources.DefaultPlayerSkin;
 import net.minecraft.entity.SharedMonsterAttributes;
 import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.passive.EntityShoulderRiding;
 import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Items;
+import net.minecraft.item.ItemBow;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.StringUtils;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
+import net.optifine.player.CapeUtils;
+import net.optifine.player.PlayerConfigurations;
+import net.optifine.reflect.Reflector;
 
 public abstract class AbstractClientPlayer extends EntityPlayer {
    private NetworkPlayerInfo playerInfo;
    public float rotateElytraX;
    public float rotateElytraY;
    public float rotateElytraZ;
+   private ResourceLocation locationOfCape = null;
+   private long reloadCapeTimeMs = 0L;
+   private boolean elytraOfCape = false;
+   private String nameClear = null;
+   public EntityShoulderRiding entityShoulderLeft;
+   public EntityShoulderRiding entityShoulderRight;
+   private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");
+
+   public AbstractClientPlayer(World worldIn, GameProfile playerProfile) {
+      super(worldIn, playerProfile);
+      this.nameClear = playerProfile.getName();
+      if (this.nameClear != null && !this.nameClear.isEmpty()) {
+         this.nameClear = StringUtils.stripControlCodes(this.nameClear);
+      }
 
-   public AbstractClientPlayer(World var1, GameProfile var2) {
-      super(☃, ☃);
+      CapeUtils.downloadCape(this);
+      PlayerConfigurations.getPlayerConfiguration(this);
    }
 
-   @Override
    public boolean isSpectator() {
-      NetworkPlayerInfo ☃ = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
-      return ☃ != null && ☃.getGameType() == GameType.SPECTATOR;
+      NetworkPlayerInfo networkplayerinfo = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
+      return networkplayerinfo != null && networkplayerinfo.getGameType() == GameType.SPECTATOR;
    }
 
-   @Override
    public boolean isCreative() {
-      NetworkPlayerInfo ☃ = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
-      return ☃ != null && ☃.getGameType() == GameType.CREATIVE;
+      NetworkPlayerInfo networkplayerinfo = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
+      return networkplayerinfo != null && networkplayerinfo.getGameType() == GameType.CREATIVE;
    }
 
    public boolean hasPlayerInfo() {
@@ -54,19 +71,32 @@ protected NetworkPlayerInfo getPlayerInfo() {
    }
 
    public boolean hasSkin() {
-      NetworkPlayerInfo ☃ = this.getPlayerInfo();
-      return ☃ != null && ☃.hasLocationSkin();
+      NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
+      return networkplayerinfo != null && networkplayerinfo.hasLocationSkin();
    }
 
    public ResourceLocation getLocationSkin() {
-      NetworkPlayerInfo ☃ = this.getPlayerInfo();
-      return ☃ == null ? DefaultPlayerSkin.getDefaultSkin(this.getUniqueID()) : ☃.getLocationSkin();
+      NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
+      return networkplayerinfo == null ? DefaultPlayerSkin.getDefaultSkin(this.getUniqueID()) : networkplayerinfo.getLocationSkin();
    }
 
    @Nullable
    public ResourceLocation getLocationCape() {
-      NetworkPlayerInfo ☃ = this.getPlayerInfo();
-      return ☃ == null ? null : ☃.getLocationCape();
+      if (!Config.isShowCapes()) {
+         return null;
+      } else {
+         if (this.reloadCapeTimeMs != 0L && System.currentTimeMillis() > this.reloadCapeTimeMs) {
+            CapeUtils.reloadCape(this);
+            this.reloadCapeTimeMs = 0L;
+         }
+
+         if (this.locationOfCape != null) {
+            return this.locationOfCape;
+         } else {
+            NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
+            return networkplayerinfo == null ? null : networkplayerinfo.getLocationCape();
+         }
+      }
    }
 
    public boolean isPlayerInfoSet() {
@@ -75,59 +105,96 @@ public boolean isPlayerInfoSet() {
 
    @Nullable
    public ResourceLocation getLocationElytra() {
-      NetworkPlayerInfo ☃ = this.getPlayerInfo();
-      return ☃ == null ? null : ☃.getLocationElytra();
-   }
-
-   public static ThreadDownloadImageData getDownloadImageSkin(ResourceLocation var0, String var1) {
-      TextureManager ☃ = Minecraft.getMinecraft().getTextureManager();
-      ITextureObject ☃x = ☃.getTexture(☃);
-      if (☃x == null) {
-         ☃x = new ThreadDownloadImageData(
-            null,
-            String.format("http://skins.minecraft.net/MinecraftSkins/%s.png", StringUtils.stripControlCodes(☃)),
-            DefaultPlayerSkin.getDefaultSkin(getOfflineUUID(☃)),
+      NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
+      return networkplayerinfo == null ? null : networkplayerinfo.getLocationElytra();
+   }
+
+   public static ThreadDownloadImageData getDownloadImageSkin(ResourceLocation resourceLocationIn, String username) {
+      TextureManager texturemanager = Minecraft.getMinecraft().getTextureManager();
+      ITextureObject itextureobject = texturemanager.getTexture(resourceLocationIn);
+      if (itextureobject == null) {
+         itextureobject = new ThreadDownloadImageData(
+            (File)null,
+            String.format("http://skins.minecraft.net/MinecraftSkins/%s.png", StringUtils.stripControlCodes(username)),
+            DefaultPlayerSkin.getDefaultSkin(getOfflineUUID(username)),
             new ImageBufferDownload()
          );
-         ☃.loadTexture(☃, ☃x);
+         texturemanager.loadTexture(resourceLocationIn, itextureobject);
       }
 
-      return (ThreadDownloadImageData)☃x;
+      return (ThreadDownloadImageData)itextureobject;
    }
 
-   public static ResourceLocation getLocationSkin(String var0) {
-      return new ResourceLocation("skins/" + StringUtils.stripControlCodes(☃));
+   public static ResourceLocation getLocationSkin(String username) {
+      return new ResourceLocation("skins/" + StringUtils.stripControlCodes(username));
    }
 
    public String getSkinType() {
-      NetworkPlayerInfo ☃ = this.getPlayerInfo();
-      return ☃ == null ? DefaultPlayerSkin.getSkinType(this.getUniqueID()) : ☃.getSkinType();
+      NetworkPlayerInfo networkplayerinfo = this.getPlayerInfo();
+      return networkplayerinfo == null ? DefaultPlayerSkin.getSkinType(this.getUniqueID()) : networkplayerinfo.getSkinType();
    }
 
    public float getFovModifier() {
-      float ☃ = 1.0F;
+      float f = 1.0F;
       if (this.capabilities.isFlying) {
-         ☃ *= 1.1F;
+         f *= 1.1F;
       }
 
-      IAttributeInstance ☃x = this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);
-      ☃ = (float)(☃ * ((☃x.getAttributeValue() / this.capabilities.getWalkSpeed() + 1.0) / 2.0));
-      if (this.capabilities.getWalkSpeed() == 0.0F || Float.isNaN(☃) || Float.isInfinite(☃)) {
-         ☃ = 1.0F;
+      IAttributeInstance iattributeinstance = this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);
+      f = (float)(f * ((iattributeinstance.getAttributeValue() / this.capabilities.getWalkSpeed() + 1.0) / 2.0));
+      if (this.capabilities.getWalkSpeed() == 0.0F || Float.isNaN(f) || Float.isInfinite(f)) {
+         f = 1.0F;
       }
 
-      if (this.isHandActive() && this.getActiveItemStack().getItem() == Items.BOW) {
-         int ☃xx = this.getItemInUseMaxCount();
-         float ☃xxx = ☃xx / 20.0F;
-         if (☃xxx > 1.0F) {
-            ☃xxx = 1.0F;
+      if (this.isHandActive() && this.getActiveItemStack().getItem() instanceof ItemBow) {
+         int i = this.getItemInUseMaxCount();
+         float f1 = i / 20.0F;
+         if (f1 > 1.0F) {
+            f1 = 1.0F;
          } else {
-            ☃xxx *= ☃xxx;
+            f1 *= f1;
          }
 
-         ☃ *= 1.0F - ☃xxx * 0.15F;
+         f *= 1.0F - f1 * 0.15F;
       }
 
-      return ☃;
+      return Reflector.ForgeHooksClient_getOffsetFOV.exists() ? Reflector.callFloat(Reflector.ForgeHooksClient_getOffsetFOV, new Object[]{this, f}) : f;
+   }
+
+   public String getNameClear() {
+      return this.nameClear;
+   }
+
+   public ResourceLocation getLocationOfCape() {
+      return this.locationOfCape;
+   }
+
+   public void setLocationOfCape(ResourceLocation locationOfCape) {
+      this.locationOfCape = locationOfCape;
+   }
+
+   public boolean hasElytraCape() {
+      ResourceLocation loc = this.getLocationCape();
+      if (loc == null) {
+         return false;
+      } else {
+         return loc == this.locationOfCape ? this.elytraOfCape : true;
+      }
+   }
+
+   public void setElytraOfCape(boolean elytraOfCape) {
+      this.elytraOfCape = elytraOfCape;
+   }
+
+   public boolean isElytraOfCape() {
+      return this.elytraOfCape;
+   }
+
+   public long getReloadCapeTimeMs() {
+      return this.reloadCapeTimeMs;
+   }
+
+   public void setReloadCapeTimeMs(long reloadCapeTimeMs) {
+      this.reloadCapeTimeMs = reloadCapeTimeMs;
    }
 }
diff --git a/patches/net/minecraft/client/gui/FontRenderer.java b/patches/net/minecraft/client/gui/FontRenderer.java
index 5e7c64f..207383e 100644
--- a/patches/net/minecraft/client/gui/FontRenderer.java
+++ b/patches/net/minecraft/client/gui/FontRenderer.java
@@ -8,6 +8,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.Properties;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.BufferBuilder;
@@ -21,6 +22,9 @@
 import net.minecraft.client.resources.IResourceManagerReloadListener;
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
+import net.optifine.render.GlBlendState;
+import net.optifine.util.FontUtils;
 import org.apache.commons.io.IOUtils;
 
 public class FontRenderer implements IResourceManagerReloadListener {
@@ -30,7 +34,7 @@ public class FontRenderer implements IResourceManagerReloadListener {
    public Random fontRandom = new Random();
    private final byte[] glyphWidth = new byte[65536];
    private final int[] colorCode = new int[32];
-   private final ResourceLocation locationFontTexture;
+   private ResourceLocation locationFontTexture;
    private final TextureManager renderEngine;
    private float posX;
    private float posY;
@@ -46,212 +50,262 @@ public class FontRenderer implements IResourceManagerReloadListener {
    private boolean italicStyle;
    private boolean underlineStyle;
    private boolean strikethroughStyle;
-
-   public FontRenderer(GameSettings var1, ResourceLocation var2, TextureManager var3, boolean var4) {
-      this.locationFontTexture = ☃;
-      this.renderEngine = ☃;
-      this.unicodeFlag = ☃;
-      ☃.bindTexture(this.locationFontTexture);
-
-      for (int ☃ = 0; ☃ < 32; ☃++) {
-         int ☃x = (☃ >> 3 & 1) * 85;
-         int ☃xx = (☃ >> 2 & 1) * 170 + ☃x;
-         int ☃xxx = (☃ >> 1 & 1) * 170 + ☃x;
-         int ☃xxxx = (☃ >> 0 & 1) * 170 + ☃x;
-         if (☃ == 6) {
-            ☃xx += 85;
+   public GameSettings gameSettings;
+   public ResourceLocation locationFontTextureBase;
+   public float offsetBold = 1.0F;
+   private float[] charWidthFloat = new float[256];
+   private boolean blend = false;
+   private GlBlendState oldBlendState = new GlBlendState();
+
+   public FontRenderer(GameSettings gameSettingsIn, ResourceLocation location, TextureManager textureManagerIn, boolean unicode) {
+      this.gameSettings = gameSettingsIn;
+      this.locationFontTextureBase = location;
+      this.locationFontTexture = location;
+      this.renderEngine = textureManagerIn;
+      this.unicodeFlag = unicode;
+      this.locationFontTexture = FontUtils.getHdFontLocation(this.locationFontTextureBase);
+      this.bindTexture(this.locationFontTexture);
+
+      for (int i = 0; i < 32; i++) {
+         int j = (i >> 3 & 1) * 85;
+         int k = (i >> 2 & 1) * 170 + j;
+         int l = (i >> 1 & 1) * 170 + j;
+         int i1 = (i >> 0 & 1) * 170 + j;
+         if (i == 6) {
+            k += 85;
          }
 
-         if (☃.anaglyph) {
-            int ☃xxxxx = (☃xx * 30 + ☃xxx * 59 + ☃xxxx * 11) / 100;
-            int ☃xxxxxx = (☃xx * 30 + ☃xxx * 70) / 100;
-            int ☃xxxxxxx = (☃xx * 30 + ☃xxxx * 70) / 100;
-            ☃xx = ☃xxxxx;
-            ☃xxx = ☃xxxxxx;
-            ☃xxxx = ☃xxxxxxx;
+         if (gameSettingsIn.anaglyph) {
+            int j1 = (k * 30 + l * 59 + i1 * 11) / 100;
+            int k1 = (k * 30 + l * 70) / 100;
+            int l1 = (k * 30 + i1 * 70) / 100;
+            k = j1;
+            l = k1;
+            i1 = l1;
          }
 
-         if (☃ >= 16) {
-            ☃xx /= 4;
-            ☃xxx /= 4;
-            ☃xxxx /= 4;
+         if (i >= 16) {
+            k /= 4;
+            l /= 4;
+            i1 /= 4;
          }
 
-         this.colorCode[☃] = (☃xx & 0xFF) << 16 | (☃xxx & 0xFF) << 8 | ☃xxxx & 0xFF;
+         this.colorCode[i] = (k & 0xFF) << 16 | (l & 0xFF) << 8 | i1 & 0xFF;
       }
 
       this.readGlyphSizes();
    }
 
-   @Override
-   public void onResourceManagerReload(IResourceManager var1) {
+   public void onResourceManagerReload(IResourceManager resourceManager) {
+      this.locationFontTexture = FontUtils.getHdFontLocation(this.locationFontTextureBase);
+
+      for (int i = 0; i < UNICODE_PAGE_LOCATIONS.length; i++) {
+         UNICODE_PAGE_LOCATIONS[i] = null;
+      }
+
       this.readFontTexture();
       this.readGlyphSizes();
    }
 
    private void readFontTexture() {
-      IResource ☃ = null;
+      IResource iresource = null;
 
-      BufferedImage ☃x;
+      BufferedImage bufferedimage;
       try {
-         ☃ = Minecraft.getMinecraft().getResourceManager().getResource(this.locationFontTexture);
-         ☃x = TextureUtil.readBufferedImage(☃.getInputStream());
-      } catch (IOException var20) {
-         throw new RuntimeException(var20);
+         iresource = this.getResource(this.locationFontTexture);
+         bufferedimage = TextureUtil.readBufferedImage(iresource.getInputStream());
+      } catch (IOException var24) {
+         throw new RuntimeException(var24);
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(iresource);
       }
 
-      int var3 = ☃x.getWidth();
-      int var4 = ☃x.getHeight();
-      int[] var5 = new int[var3 * var4];
-      ☃x.getRGB(0, 0, var3, var4, var5, 0, var3);
-      int var6 = var4 / 16;
-      int var7 = var3 / 16;
-      boolean var8 = true;
-      float var9 = 8.0F / var7;
-
-      for (int var10 = 0; var10 < 256; var10++) {
-         int ☃xx = var10 % 16;
-         int ☃xxx = var10 / 16;
-         if (var10 == 32) {
-            this.charWidth[var10] = 4;
-         }
+      Properties props = FontUtils.readFontProperties(this.locationFontTexture);
+      this.blend = FontUtils.readBoolean(props, "blend", false);
+      int imgWidth = bufferedimage.getWidth();
+      int imgHeight = bufferedimage.getHeight();
+      int charW = imgWidth / 16;
+      int charH = imgHeight / 16;
+      float kx = imgWidth / 128.0F;
+      float boldScaleFactor = Config.limit(kx, 1.0F, 2.0F);
+      this.offsetBold = 1.0F / boldScaleFactor;
+      float offsetBoldConfig = FontUtils.readFloat(props, "offsetBold", -1.0F);
+      if (offsetBoldConfig >= 0.0F) {
+         this.offsetBold = offsetBoldConfig;
+      }
+
+      int[] ai = new int[imgWidth * imgHeight];
+      bufferedimage.getRGB(0, 0, imgWidth, imgHeight, ai, 0, imgWidth);
 
-         int ☃xxxx;
-         for (☃xxxx = var7 - 1; ☃xxxx >= 0; ☃xxxx--) {
-            int ☃xxxxx = ☃xx * var7 + ☃xxxx;
-            boolean ☃xxxxxx = true;
+      for (int k = 0; k < 256; k++) {
+         int cx = k % 16;
+         int cy = k / 16;
+         int px = 0;
 
-            for (int ☃xxxxxxx = 0; ☃xxxxxxx < var6 && ☃xxxxxx; ☃xxxxxxx++) {
-               int ☃xxxxxxxx = (☃xxx * var7 + ☃xxxxxxx) * var3;
-               if ((var5[☃xxxxx + ☃xxxxxxxx] >> 24 & 0xFF) != 0) {
-                  ☃xxxxxx = false;
+         for (px = charW - 1; px >= 0; px--) {
+            int x = cx * charW + px;
+            boolean flag = true;
+
+            for (int py = 0; py < charH && flag; py++) {
+               int ypos = (cy * charH + py) * imgWidth;
+               int col = ai[x + ypos];
+               int al = col >> 24 & 0xFF;
+               if (al > 16) {
+                  flag = false;
                }
             }
 
-            if (!☃xxxxxx) {
+            if (!flag) {
                break;
             }
          }
 
-         this.charWidth[var10] = (int)(0.5 + ++☃xxxx * var9) + 1;
+         if (k == 65) {
+            k = k;
+         }
+
+         if (k == 32) {
+            if (charW <= 8) {
+               px = (int)(2.0F * kx);
+            } else {
+               px = (int)(1.5F * kx);
+            }
+         }
+
+         this.charWidthFloat[k] = (px + 1) / kx + 1.0F;
+      }
+
+      FontUtils.readCustomCharWidths(props, this.charWidthFloat);
+
+      for (int i = 0; i < this.charWidth.length; i++) {
+         this.charWidth[i] = Math.round(this.charWidthFloat[i]);
       }
    }
 
    private void readGlyphSizes() {
-      IResource ☃ = null;
+      IResource iresource = null;
 
       try {
-         ☃ = Minecraft.getMinecraft().getResourceManager().getResource(new ResourceLocation("font/glyph_sizes.bin"));
-         ☃.getInputStream().read(this.glyphWidth);
+         iresource = this.getResource(new ResourceLocation("font/glyph_sizes.bin"));
+         iresource.getInputStream().read(this.glyphWidth);
       } catch (IOException var6) {
          throw new RuntimeException(var6);
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(iresource);
       }
    }
 
-   private float renderChar(char var1, boolean var2) {
-      if (☃ == ' ') {
-         return 4.0F;
+   private float renderChar(char ch, boolean italic) {
+      if (ch != ' ' && ch != 160) {
+         int i = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
+            .indexOf(ch);
+         return i != -1 && !this.unicodeFlag ? this.renderDefaultChar(i, italic) : this.renderUnicodeChar(ch, italic);
       } else {
-         int ☃ = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
-            .indexOf(☃);
-         return ☃ != -1 && !this.unicodeFlag ? this.renderDefaultChar(☃, ☃) : this.renderUnicodeChar(☃, ☃);
+         return !this.unicodeFlag ? this.charWidthFloat[ch] : 4.0F;
       }
    }
 
-   private float renderDefaultChar(int var1, boolean var2) {
-      int ☃ = ☃ % 16 * 8;
-      int ☃x = ☃ / 16 * 8;
-      int ☃xx = ☃ ? 1 : 0;
-      this.renderEngine.bindTexture(this.locationFontTexture);
-      int ☃xxx = this.charWidth[☃];
-      float ☃xxxx = ☃xxx - 0.01F;
+   private float renderDefaultChar(int ch, boolean italic) {
+      int i = ch % 16 * 8;
+      int j = ch / 16 * 8;
+      int k = italic ? 1 : 0;
+      this.bindTexture(this.locationFontTexture);
+      float l = this.charWidthFloat[ch];
+      float f = 7.99F;
       GlStateManager.glBegin(5);
-      GlStateManager.glTexCoord2f(☃ / 128.0F, ☃x / 128.0F);
-      GlStateManager.glVertex3f(this.posX + ☃xx, this.posY, 0.0F);
-      GlStateManager.glTexCoord2f(☃ / 128.0F, (☃x + 7.99F) / 128.0F);
-      GlStateManager.glVertex3f(this.posX - ☃xx, this.posY + 7.99F, 0.0F);
-      GlStateManager.glTexCoord2f((☃ + ☃xxxx - 1.0F) / 128.0F, ☃x / 128.0F);
-      GlStateManager.glVertex3f(this.posX + ☃xxxx - 1.0F + ☃xx, this.posY, 0.0F);
-      GlStateManager.glTexCoord2f((☃ + ☃xxxx - 1.0F) / 128.0F, (☃x + 7.99F) / 128.0F);
-      GlStateManager.glVertex3f(this.posX + ☃xxxx - 1.0F - ☃xx, this.posY + 7.99F, 0.0F);
+      GlStateManager.glTexCoord2f(i / 128.0F, j / 128.0F);
+      GlStateManager.glVertex3f(this.posX + k, this.posY, 0.0F);
+      GlStateManager.glTexCoord2f(i / 128.0F, (j + 7.99F) / 128.0F);
+      GlStateManager.glVertex3f(this.posX - k, this.posY + 7.99F, 0.0F);
+      GlStateManager.glTexCoord2f((i + f - 1.0F) / 128.0F, j / 128.0F);
+      GlStateManager.glVertex3f(this.posX + f - 1.0F + k, this.posY, 0.0F);
+      GlStateManager.glTexCoord2f((i + f - 1.0F) / 128.0F, (j + 7.99F) / 128.0F);
+      GlStateManager.glVertex3f(this.posX + f - 1.0F - k, this.posY + 7.99F, 0.0F);
       GlStateManager.glEnd();
-      return ☃xxx;
+      return l;
    }
 
-   private ResourceLocation getUnicodePageLocation(int var1) {
-      if (UNICODE_PAGE_LOCATIONS[☃] == null) {
-         UNICODE_PAGE_LOCATIONS[☃] = new ResourceLocation(String.format("textures/font/unicode_page_%02x.png", ☃));
+   private ResourceLocation getUnicodePageLocation(int page) {
+      if (UNICODE_PAGE_LOCATIONS[page] == null) {
+         UNICODE_PAGE_LOCATIONS[page] = new ResourceLocation(String.format("textures/font/unicode_page_%02x.png", page));
+         UNICODE_PAGE_LOCATIONS[page] = FontUtils.getHdFontLocation(UNICODE_PAGE_LOCATIONS[page]);
       }
 
-      return UNICODE_PAGE_LOCATIONS[☃];
+      return UNICODE_PAGE_LOCATIONS[page];
    }
 
-   private void loadGlyphTexture(int var1) {
-      this.renderEngine.bindTexture(this.getUnicodePageLocation(☃));
+   private void loadGlyphTexture(int page) {
+      this.bindTexture(this.getUnicodePageLocation(page));
    }
 
-   private float renderUnicodeChar(char var1, boolean var2) {
-      int ☃ = this.glyphWidth[☃] & 255;
-      if (☃ == 0) {
+   private float renderUnicodeChar(char ch, boolean italic) {
+      int i = this.glyphWidth[ch] & 255;
+      if (i == 0) {
          return 0.0F;
       } else {
-         int ☃x = ☃ / 256;
-         this.loadGlyphTexture(☃x);
-         int ☃xx = ☃ >>> 4;
-         int ☃xxx = ☃ & 15;
-         float ☃xxxx = ☃xx;
-         float ☃xxxxx = ☃xxx + 1;
-         float ☃xxxxxx = ☃ % 16 * 16 + ☃xxxx;
-         float ☃xxxxxxx = (☃ & 255) / 16 * 16;
-         float ☃xxxxxxxx = ☃xxxxx - ☃xxxx - 0.02F;
-         float ☃xxxxxxxxx = ☃ ? 1.0F : 0.0F;
+         int j = ch / 256;
+         this.loadGlyphTexture(j);
+         int k = i >>> 4;
+         int l = i & 15;
+         float f = k;
+         float f1 = l + 1;
+         float f2 = ch % 16 * 16 + f;
+         float f3 = (ch & 255) / 16 * 16;
+         float f4 = f1 - f - 0.02F;
+         float f5 = italic ? 1.0F : 0.0F;
          GlStateManager.glBegin(5);
-         GlStateManager.glTexCoord2f(☃xxxxxx / 256.0F, ☃xxxxxxx / 256.0F);
-         GlStateManager.glVertex3f(this.posX + ☃xxxxxxxxx, this.posY, 0.0F);
-         GlStateManager.glTexCoord2f(☃xxxxxx / 256.0F, (☃xxxxxxx + 15.98F) / 256.0F);
-         GlStateManager.glVertex3f(this.posX - ☃xxxxxxxxx, this.posY + 7.99F, 0.0F);
-         GlStateManager.glTexCoord2f((☃xxxxxx + ☃xxxxxxxx) / 256.0F, ☃xxxxxxx / 256.0F);
-         GlStateManager.glVertex3f(this.posX + ☃xxxxxxxx / 2.0F + ☃xxxxxxxxx, this.posY, 0.0F);
-         GlStateManager.glTexCoord2f((☃xxxxxx + ☃xxxxxxxx) / 256.0F, (☃xxxxxxx + 15.98F) / 256.0F);
-         GlStateManager.glVertex3f(this.posX + ☃xxxxxxxx / 2.0F - ☃xxxxxxxxx, this.posY + 7.99F, 0.0F);
+         GlStateManager.glTexCoord2f(f2 / 256.0F, f3 / 256.0F);
+         GlStateManager.glVertex3f(this.posX + f5, this.posY, 0.0F);
+         GlStateManager.glTexCoord2f(f2 / 256.0F, (f3 + 15.98F) / 256.0F);
+         GlStateManager.glVertex3f(this.posX - f5, this.posY + 7.99F, 0.0F);
+         GlStateManager.glTexCoord2f((f2 + f4) / 256.0F, f3 / 256.0F);
+         GlStateManager.glVertex3f(this.posX + f4 / 2.0F + f5, this.posY, 0.0F);
+         GlStateManager.glTexCoord2f((f2 + f4) / 256.0F, (f3 + 15.98F) / 256.0F);
+         GlStateManager.glVertex3f(this.posX + f4 / 2.0F - f5, this.posY + 7.99F, 0.0F);
          GlStateManager.glEnd();
-         return (☃xxxxx - ☃xxxx) / 2.0F + 1.0F;
+         return (f1 - f) / 2.0F + 1.0F;
       }
    }
 
-   public int drawStringWithShadow(String var1, float var2, float var3, int var4) {
-      return this.drawString(☃, ☃, ☃, ☃, true);
+   public int drawStringWithShadow(String text, float x, float y, int color) {
+      return this.drawString(text, x, y, color, true);
    }
 
-   public int drawString(String var1, int var2, int var3, int var4) {
-      return this.drawString(☃, ☃, ☃, ☃, false);
+   public int drawString(String text, int x, int y, int color) {
+      return this.drawString(text, x, y, color, false);
    }
 
-   public int drawString(String var1, float var2, float var3, int var4, boolean var5) {
-      GlStateManager.enableAlpha();
+   public int drawString(String text, float x, float y, int color, boolean dropShadow) {
+      this.enableAlpha();
+      if (this.blend) {
+         GlStateManager.getBlendState(this.oldBlendState);
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+      }
+
       this.resetStyles();
-      int ☃;
-      if (☃) {
-         ☃ = this.renderString(☃, ☃ + 1.0F, ☃ + 1.0F, ☃, true);
-         ☃ = Math.max(☃, this.renderString(☃, ☃, ☃, ☃, false));
+      int i;
+      if (dropShadow) {
+         i = this.renderString(text, x + 1.0F, y + 1.0F, color, true);
+         i = Math.max(i, this.renderString(text, x, y, color, false));
       } else {
-         ☃ = this.renderString(☃, ☃, ☃, ☃, false);
+         i = this.renderString(text, x, y, color, false);
       }
 
-      return ☃;
+      if (this.blend) {
+         GlStateManager.setBlendState(this.oldBlendState);
+      }
+
+      return i;
    }
 
-   private String bidiReorder(String var1) {
+   private String bidiReorder(String text) {
       try {
-         Bidi ☃ = new Bidi(new ArabicShaping(8).shape(☃), 127);
-         ☃.setReorderingMode(0);
-         return ☃.writeReordered(2);
-      } catch (ArabicShapingException var3) {
-         return ☃;
+         Bidi bidi = new Bidi(new ArabicShaping(8).shape(text), 127);
+         bidi.setReorderingMode(0);
+         return bidi.writeReordered(2);
+      } catch (ArabicShapingException var31) {
+         return text;
       }
    }
 
@@ -263,397 +317,447 @@ private void resetStyles() {
       this.strikethroughStyle = false;
    }
 
-   private void renderStringAtPos(String var1, boolean var2) {
-      for (int ☃ = 0; ☃ < ☃.length(); ☃++) {
-         char ☃x = ☃.charAt(☃);
-         if (☃x == 167 && ☃ + 1 < ☃.length()) {
-            int ☃xx = "0123456789abcdefklmnor".indexOf(String.valueOf(☃.charAt(☃ + 1)).toLowerCase(Locale.ROOT).charAt(0));
-            if (☃xx < 16) {
+   private void renderStringAtPos(String text, boolean shadow) {
+      for (int i = 0; i < text.length(); i++) {
+         char c0 = text.charAt(i);
+         if (c0 == 167 && i + 1 < text.length()) {
+            int i1 = "0123456789abcdefklmnor".indexOf(String.valueOf(text.charAt(i + 1)).toLowerCase(Locale.ROOT).charAt(0));
+            if (i1 < 16) {
                this.randomStyle = false;
                this.boldStyle = false;
                this.strikethroughStyle = false;
                this.underlineStyle = false;
                this.italicStyle = false;
-               if (☃xx < 0 || ☃xx > 15) {
-                  ☃xx = 15;
+               if (i1 < 0 || i1 > 15) {
+                  i1 = 15;
+               }
+
+               if (shadow) {
+                  i1 += 16;
                }
 
-               if (☃) {
-                  ☃xx += 16;
+               int j1 = this.colorCode[i1];
+               if (Config.isCustomColors()) {
+                  j1 = CustomColors.getTextColor(i1, j1);
                }
 
-               int ☃xxx = this.colorCode[☃xx];
-               this.textColor = ☃xxx;
-               GlStateManager.color((☃xxx >> 16) / 255.0F, (☃xxx >> 8 & 0xFF) / 255.0F, (☃xxx & 0xFF) / 255.0F, this.alpha);
-            } else if (☃xx == 16) {
+               this.textColor = j1;
+               this.setColor((j1 >> 16) / 255.0F, (j1 >> 8 & 0xFF) / 255.0F, (j1 & 0xFF) / 255.0F, this.alpha);
+            } else if (i1 == 16) {
                this.randomStyle = true;
-            } else if (☃xx == 17) {
+            } else if (i1 == 17) {
                this.boldStyle = true;
-            } else if (☃xx == 18) {
+            } else if (i1 == 18) {
                this.strikethroughStyle = true;
-            } else if (☃xx == 19) {
+            } else if (i1 == 19) {
                this.underlineStyle = true;
-            } else if (☃xx == 20) {
+            } else if (i1 == 20) {
                this.italicStyle = true;
-            } else if (☃xx == 21) {
+            } else if (i1 == 21) {
                this.randomStyle = false;
                this.boldStyle = false;
                this.strikethroughStyle = false;
                this.underlineStyle = false;
                this.italicStyle = false;
-               GlStateManager.color(this.red, this.blue, this.green, this.alpha);
+               this.setColor(this.red, this.blue, this.green, this.alpha);
             }
 
-            ☃++;
+            i++;
          } else {
-            int ☃xx = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
-               .indexOf(☃x);
-            if (this.randomStyle && ☃xx != -1) {
-               int ☃xxx = this.getCharWidth(☃x);
+            int j = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
+               .indexOf(c0);
+            if (this.randomStyle && j != -1) {
+               int k = this.getCharWidth(c0);
 
-               char ☃xxxx;
+               char c1;
                do {
-                  ☃xx = this.fontRandom
+                  j = this.fontRandom
                      .nextInt(
                         "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
                            .length()
                      );
-                  ☃xxxx = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
-                     .charAt(☃xx);
-               } while (☃xxx != this.getCharWidth(☃xxxx));
+                  c1 = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
+                     .charAt(j);
+               } while (k != this.getCharWidth(c1));
 
-               ☃x = ☃xxxx;
+               c0 = c1;
             }
 
-            float ☃xxx = this.unicodeFlag ? 0.5F : 1.0F;
-            boolean ☃xxxx = (☃x == 0 || ☃xx == -1 || this.unicodeFlag) && ☃;
-            if (☃xxxx) {
-               this.posX -= ☃xxx;
-               this.posY -= ☃xxx;
+            float f1 = j != -1 && !this.unicodeFlag ? this.offsetBold : 0.5F;
+            boolean flag = (c0 == 0 || j == -1 || this.unicodeFlag) && shadow;
+            if (flag) {
+               this.posX -= f1;
+               this.posY -= f1;
             }
 
-            float ☃xxxxx = this.renderChar(☃x, this.italicStyle);
-            if (☃xxxx) {
-               this.posX += ☃xxx;
-               this.posY += ☃xxx;
+            float f = this.renderChar(c0, this.italicStyle);
+            if (flag) {
+               this.posX += f1;
+               this.posY += f1;
             }
 
             if (this.boldStyle) {
-               this.posX += ☃xxx;
-               if (☃xxxx) {
-                  this.posX -= ☃xxx;
-                  this.posY -= ☃xxx;
+               this.posX += f1;
+               if (flag) {
+                  this.posX -= f1;
+                  this.posY -= f1;
                }
 
-               this.renderChar(☃x, this.italicStyle);
-               this.posX -= ☃xxx;
-               if (☃xxxx) {
-                  this.posX += ☃xxx;
-                  this.posY += ☃xxx;
+               this.renderChar(c0, this.italicStyle);
+               this.posX -= f1;
+               if (flag) {
+                  this.posX += f1;
+                  this.posY += f1;
                }
 
-               ☃xxxxx++;
+               f += f1;
             }
 
-            if (this.strikethroughStyle) {
-               Tessellator ☃xxxxxx = Tessellator.getInstance();
-               BufferBuilder ☃xxxxxxx = ☃xxxxxx.getBuffer();
-               GlStateManager.disableTexture2D();
-               ☃xxxxxxx.begin(7, DefaultVertexFormats.POSITION);
-               ☃xxxxxxx.pos(this.posX, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX + ☃xxxxx, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX + ☃xxxxx, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
-               ☃xxxxxx.draw();
-               GlStateManager.enableTexture2D();
-            }
+            this.doDraw(f);
+         }
+      }
+   }
 
-            if (this.underlineStyle) {
-               Tessellator ☃xxxxxx = Tessellator.getInstance();
-               BufferBuilder ☃xxxxxxx = ☃xxxxxx.getBuffer();
-               GlStateManager.disableTexture2D();
-               ☃xxxxxxx.begin(7, DefaultVertexFormats.POSITION);
-               int ☃xxxxxxxx = this.underlineStyle ? -1 : 0;
-               ☃xxxxxxx.pos(this.posX + ☃xxxxxxxx, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX + ☃xxxxx, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX + ☃xxxxx, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
-               ☃xxxxxxx.pos(this.posX + ☃xxxxxxxx, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
-               ☃xxxxxx.draw();
-               GlStateManager.enableTexture2D();
-            }
+   protected void doDraw(float f) {
+      if (this.strikethroughStyle) {
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         GlStateManager.disableTexture2D();
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION);
+         bufferbuilder.pos(this.posX, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
+         bufferbuilder.pos(this.posX + f, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
+         bufferbuilder.pos(this.posX + f, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
+         bufferbuilder.pos(this.posX, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
+         tessellator.draw();
+         GlStateManager.enableTexture2D();
+      }
 
-            this.posX += (int)☃xxxxx;
-         }
+      if (this.underlineStyle) {
+         Tessellator tessellator1 = Tessellator.getInstance();
+         BufferBuilder bufferbuilder1 = tessellator1.getBuffer();
+         GlStateManager.disableTexture2D();
+         bufferbuilder1.begin(7, DefaultVertexFormats.POSITION);
+         int l = this.underlineStyle ? -1 : 0;
+         bufferbuilder1.pos(this.posX + l, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
+         bufferbuilder1.pos(this.posX + f, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
+         bufferbuilder1.pos(this.posX + f, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
+         bufferbuilder1.pos(this.posX + l, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
+         tessellator1.draw();
+         GlStateManager.enableTexture2D();
       }
+
+      this.posX += f;
    }
 
-   private int renderStringAligned(String var1, int var2, int var3, int var4, int var5, boolean var6) {
+   private int renderStringAligned(String text, int x, int y, int width, int color, boolean dropShadow) {
       if (this.bidiFlag) {
-         int ☃ = this.getStringWidth(this.bidiReorder(☃));
-         ☃ = ☃ + ☃ - ☃;
+         int i = this.getStringWidth(this.bidiReorder(text));
+         x = x + width - i;
       }
 
-      return this.renderString(☃, ☃, ☃, ☃, ☃);
+      return this.renderString(text, x, y, color, dropShadow);
    }
 
-   private int renderString(String var1, float var2, float var3, int var4, boolean var5) {
-      if (☃ == null) {
+   private int renderString(String text, float x, float y, int color, boolean dropShadow) {
+      if (text == null) {
          return 0;
       } else {
          if (this.bidiFlag) {
-            ☃ = this.bidiReorder(☃);
+            text = this.bidiReorder(text);
          }
 
-         if ((☃ & -67108864) == 0) {
-            ☃ |= -16777216;
+         if ((color & -67108864) == 0) {
+            color |= -16777216;
          }
 
-         if (☃) {
-            ☃ = (☃ & 16579836) >> 2 | ☃ & 0xFF000000;
+         if (dropShadow) {
+            color = (color & 16579836) >> 2 | color & 0xFF000000;
          }
 
-         this.red = (☃ >> 16 & 0xFF) / 255.0F;
-         this.blue = (☃ >> 8 & 0xFF) / 255.0F;
-         this.green = (☃ & 0xFF) / 255.0F;
-         this.alpha = (☃ >> 24 & 0xFF) / 255.0F;
-         GlStateManager.color(this.red, this.blue, this.green, this.alpha);
-         this.posX = ☃;
-         this.posY = ☃;
-         this.renderStringAtPos(☃, ☃);
+         this.red = (color >> 16 & 0xFF) / 255.0F;
+         this.blue = (color >> 8 & 0xFF) / 255.0F;
+         this.green = (color & 0xFF) / 255.0F;
+         this.alpha = (color >> 24 & 0xFF) / 255.0F;
+         this.setColor(this.red, this.blue, this.green, this.alpha);
+         this.posX = x;
+         this.posY = y;
+         this.renderStringAtPos(text, dropShadow);
          return (int)this.posX;
       }
    }
 
-   public int getStringWidth(String var1) {
-      if (☃ == null) {
+   public int getStringWidth(String text) {
+      if (text == null) {
          return 0;
       } else {
-         int ☃ = 0;
-         boolean ☃x = false;
-
-         for (int ☃xx = 0; ☃xx < ☃.length(); ☃xx++) {
-            char ☃xxx = ☃.charAt(☃xx);
-            int ☃xxxx = this.getCharWidth(☃xxx);
-            if (☃xxxx < 0 && ☃xx < ☃.length() - 1) {
-               ☃xxx = ☃.charAt(++☃xx);
-               if (☃xxx == 'l' || ☃xxx == 'L') {
-                  ☃x = true;
-               } else if (☃xxx == 'r' || ☃xxx == 'R') {
-                  ☃x = false;
+         float i = 0.0F;
+         boolean flag = false;
+
+         for (int j = 0; j < text.length(); j++) {
+            char c0 = text.charAt(j);
+            float k = this.getCharWidthFloat(c0);
+            if (k < 0.0F && j < text.length() - 1) {
+               c0 = text.charAt(++j);
+               if (c0 == 'l' || c0 == 'L') {
+                  flag = true;
+               } else if (c0 == 'r' || c0 == 'R') {
+                  flag = false;
                }
 
-               ☃xxxx = 0;
+               k = 0.0F;
             }
 
-            ☃ += ☃xxxx;
-            if (☃x && ☃xxxx > 0) {
-               ☃++;
+            i += k;
+            if (flag && k > 0.0F) {
+               i += this.unicodeFlag ? 1.0F : this.offsetBold;
             }
          }
 
-         return ☃;
+         return Math.round(i);
       }
    }
 
-   public int getCharWidth(char var1) {
-      if (☃ == 167) {
-         return -1;
-      } else if (☃ == ' ') {
-         return 4;
-      } else {
-         int ☃ = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
-            .indexOf(☃);
-         if (☃ > 0 && ☃ != -1 && !this.unicodeFlag) {
-            return this.charWidth[☃];
-         } else if (this.glyphWidth[☃] != 0) {
-            int ☃x = this.glyphWidth[☃] & 255;
-            int ☃xx = ☃x >>> 4;
-            int ☃xxx = ☃x & 15;
-            ☃xxx++;
-            return (☃xxx - ☃xx) / 2 + 1;
+   public int getCharWidth(char character) {
+      return Math.round(this.getCharWidthFloat(character));
+   }
+
+   private float getCharWidthFloat(char character) {
+      if (character == 167) {
+         return -1.0F;
+      } else if (character != ' ' && character != 160) {
+         int i = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
+            .indexOf(character);
+         if (character > 0 && i != -1 && !this.unicodeFlag) {
+            return this.charWidthFloat[i];
+         } else if (this.glyphWidth[character] != 0) {
+            int j = this.glyphWidth[character] & 255;
+            int k = j >>> 4;
+            int l = j & 15;
+            l++;
+            return (l - k) / 2 + 1;
          } else {
-            return 0;
+            return 0.0F;
          }
+      } else {
+         return this.charWidthFloat[32];
       }
    }
 
-   public String trimStringToWidth(String var1, int var2) {
-      return this.trimStringToWidth(☃, ☃, false);
+   public String trimStringToWidth(String text, int width) {
+      return this.trimStringToWidth(text, width, false);
    }
 
-   public String trimStringToWidth(String var1, int var2, boolean var3) {
-      StringBuilder ☃ = new StringBuilder();
-      int ☃x = 0;
-      int ☃xx = ☃ ? ☃.length() - 1 : 0;
-      int ☃xxx = ☃ ? -1 : 1;
-      boolean ☃xxxx = false;
-      boolean ☃xxxxx = false;
+   public String trimStringToWidth(String text, int width, boolean reverse) {
+      StringBuilder stringbuilder = new StringBuilder();
+      float i = 0.0F;
+      int j = reverse ? text.length() - 1 : 0;
+      int k = reverse ? -1 : 1;
+      boolean flag = false;
+      boolean flag1 = false;
 
-      for (int ☃xxxxxx = ☃xx; ☃xxxxxx >= 0 && ☃xxxxxx < ☃.length() && ☃x < ☃; ☃xxxxxx += ☃xxx) {
-         char ☃xxxxxxx = ☃.charAt(☃xxxxxx);
-         int ☃xxxxxxxx = this.getCharWidth(☃xxxxxxx);
-         if (☃xxxx) {
-            ☃xxxx = false;
-            if (☃xxxxxxx == 'l' || ☃xxxxxxx == 'L') {
-               ☃xxxxx = true;
-            } else if (☃xxxxxxx == 'r' || ☃xxxxxxx == 'R') {
-               ☃xxxxx = false;
+      for (int l = j; l >= 0 && l < text.length() && i < width; l += k) {
+         char c0 = text.charAt(l);
+         float i1 = this.getCharWidthFloat(c0);
+         if (flag) {
+            flag = false;
+            if (c0 == 'l' || c0 == 'L') {
+               flag1 = true;
+            } else if (c0 == 'r' || c0 == 'R') {
+               flag1 = false;
             }
-         } else if (☃xxxxxxxx < 0) {
-            ☃xxxx = true;
+         } else if (i1 < 0.0F) {
+            flag = true;
          } else {
-            ☃x += ☃xxxxxxxx;
-            if (☃xxxxx) {
-               ☃x++;
+            i += i1;
+            if (flag1) {
+               i++;
             }
          }
 
-         if (☃x > ☃) {
+         if (i > width) {
             break;
          }
 
-         if (☃) {
-            ☃.insert(0, ☃xxxxxxx);
+         if (reverse) {
+            stringbuilder.insert(0, c0);
          } else {
-            ☃.append(☃xxxxxxx);
+            stringbuilder.append(c0);
          }
       }
 
-      return ☃.toString();
+      return stringbuilder.toString();
    }
 
-   private String trimStringNewline(String var1) {
-      while (☃ != null && ☃.endsWith("\n")) {
-         ☃ = ☃.substring(0, ☃.length() - 1);
+   private String trimStringNewline(String text) {
+      while (text != null && text.endsWith("\n")) {
+         text = text.substring(0, text.length() - 1);
       }
 
-      return ☃;
+      return text;
    }
 
-   public void drawSplitString(String var1, int var2, int var3, int var4, int var5) {
+   public void drawSplitString(String str, int x, int y, int wrapWidth, int textColor) {
+      if (this.blend) {
+         GlStateManager.getBlendState(this.oldBlendState);
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+      }
+
       this.resetStyles();
-      this.textColor = ☃;
-      ☃ = this.trimStringNewline(☃);
-      this.renderSplitString(☃, ☃, ☃, ☃, false);
+      this.textColor = textColor;
+      str = this.trimStringNewline(str);
+      this.renderSplitString(str, x, y, wrapWidth, false);
+      if (this.blend) {
+         GlStateManager.setBlendState(this.oldBlendState);
+      }
    }
 
-   private void renderSplitString(String var1, int var2, int var3, int var4, boolean var5) {
-      for (String ☃ : this.listFormattedStringToWidth(☃, ☃)) {
-         this.renderStringAligned(☃, ☃, ☃, ☃, this.textColor, ☃);
-         ☃ += this.FONT_HEIGHT;
+   private void renderSplitString(String str, int x, int y, int wrapWidth, boolean addShadow) {
+      for (String s : this.listFormattedStringToWidth(str, wrapWidth)) {
+         this.renderStringAligned(s, x, y, wrapWidth, this.textColor, addShadow);
+         y += this.FONT_HEIGHT;
       }
    }
 
-   public int getWordWrappedHeight(String var1, int var2) {
-      return this.FONT_HEIGHT * this.listFormattedStringToWidth(☃, ☃).size();
+   public int getWordWrappedHeight(String str, int maxLength) {
+      return this.FONT_HEIGHT * this.listFormattedStringToWidth(str, maxLength).size();
    }
 
-   public void setUnicodeFlag(boolean var1) {
-      this.unicodeFlag = ☃;
+   public void setUnicodeFlag(boolean unicodeFlagIn) {
+      this.unicodeFlag = unicodeFlagIn;
    }
 
    public boolean getUnicodeFlag() {
       return this.unicodeFlag;
    }
 
-   public void setBidiFlag(boolean var1) {
-      this.bidiFlag = ☃;
+   public void setBidiFlag(boolean bidiFlagIn) {
+      this.bidiFlag = bidiFlagIn;
    }
 
-   public List<String> listFormattedStringToWidth(String var1, int var2) {
-      return Arrays.asList(this.wrapFormattedStringToWidth(☃, ☃).split("\n"));
+   public List<String> listFormattedStringToWidth(String str, int wrapWidth) {
+      return Arrays.asList(this.wrapFormattedStringToWidth(str, wrapWidth).split("\n"));
    }
 
-   String wrapFormattedStringToWidth(String var1, int var2) {
-      int ☃ = this.sizeStringToWidth(☃, ☃);
-      if (☃.length() <= ☃) {
-         return ☃;
+   String wrapFormattedStringToWidth(String str, int wrapWidth) {
+      if (str.length() <= 1) {
+         return str;
       } else {
-         String ☃x = ☃.substring(0, ☃);
-         char ☃xx = ☃.charAt(☃);
-         boolean ☃xxx = ☃xx == ' ' || ☃xx == '\n';
-         String ☃xxxx = getFormatFromString(☃x) + ☃.substring(☃ + (☃xxx ? 1 : 0));
-         return ☃x + "\n" + this.wrapFormattedStringToWidth(☃xxxx, ☃);
+         int i = this.sizeStringToWidth(str, wrapWidth);
+         if (str.length() <= i) {
+            return str;
+         } else {
+            String s = str.substring(0, i);
+            char c0 = str.charAt(i);
+            boolean flag = c0 == ' ' || c0 == '\n';
+            String s1 = getFormatFromString(s) + str.substring(i + (flag ? 1 : 0));
+            return s + "\n" + this.wrapFormattedStringToWidth(s1, wrapWidth);
+         }
       }
    }
 
-   private int sizeStringToWidth(String var1, int var2) {
-      int ☃ = ☃.length();
-      int ☃x = 0;
-      int ☃xx = 0;
-      int ☃xxx = -1;
+   private int sizeStringToWidth(String str, int wrapWidth) {
+      int i = str.length();
+      float j = 0.0F;
+      int k = 0;
+      int l = -1;
 
-      for (boolean ☃xxxx = false; ☃xx < ☃; ☃xx++) {
-         char ☃xxxxx = ☃.charAt(☃xx);
-         switch (☃xxxxx) {
+      for (boolean flag = false; k < i; k++) {
+         char c0 = str.charAt(k);
+         switch (c0) {
             case '\n':
-               ☃xx--;
+               k--;
                break;
             case ' ':
-               ☃xxx = ☃xx;
+               l = k;
             default:
-               ☃x += this.getCharWidth(☃xxxxx);
-               if (☃xxxx) {
-                  ☃x++;
+               j += this.getCharWidthFloat(c0);
+               if (flag) {
+                  j++;
                }
                break;
             case '§':
-               if (☃xx < ☃ - 1) {
-                  char ☃xxxxxx = ☃.charAt(++☃xx);
-                  if (☃xxxxxx == 'l' || ☃xxxxxx == 'L') {
-                     ☃xxxx = true;
-                  } else if (☃xxxxxx == 'r' || ☃xxxxxx == 'R' || isFormatColor(☃xxxxxx)) {
-                     ☃xxxx = false;
+               if (k < i - 1) {
+                  char c1 = str.charAt(++k);
+                  if (c1 == 'l' || c1 == 'L') {
+                     flag = true;
+                  } else if (c1 == 'r' || c1 == 'R' || isFormatColor(c1)) {
+                     flag = false;
                   }
                }
          }
 
-         if (☃xxxxx == '\n') {
-            ☃xxx = ++☃xx;
+         if (c0 == '\n') {
+            l = ++k;
             break;
          }
 
-         if (☃x > ☃) {
+         if (Math.round(j) > wrapWidth) {
             break;
          }
       }
 
-      return ☃xx != ☃ && ☃xxx != -1 && ☃xxx < ☃xx ? ☃xxx : ☃xx;
+      return k != i && l != -1 && l < k ? l : k;
    }
 
-   private static boolean isFormatColor(char var0) {
-      return ☃ >= '0' && ☃ <= '9' || ☃ >= 'a' && ☃ <= 'f' || ☃ >= 'A' && ☃ <= 'F';
+   private static boolean isFormatColor(char colorChar) {
+      return colorChar >= '0' && colorChar <= '9' || colorChar >= 'a' && colorChar <= 'f' || colorChar >= 'A' && colorChar <= 'F';
    }
 
-   private static boolean isFormatSpecial(char var0) {
-      return ☃ >= 'k' && ☃ <= 'o' || ☃ >= 'K' && ☃ <= 'O' || ☃ == 'r' || ☃ == 'R';
+   private static boolean isFormatSpecial(char formatChar) {
+      return formatChar >= 'k' && formatChar <= 'o' || formatChar >= 'K' && formatChar <= 'O' || formatChar == 'r' || formatChar == 'R';
    }
 
-   public static String getFormatFromString(String var0) {
-      String ☃ = "";
-      int ☃x = -1;
-      int ☃xx = ☃.length();
+   public static String getFormatFromString(String text) {
+      String s = "";
+      int i = -1;
+      int j = text.length();
 
-      while ((☃x = ☃.indexOf(167, ☃x + 1)) != -1) {
-         if (☃x < ☃xx - 1) {
-            char ☃xxx = ☃.charAt(☃x + 1);
-            if (isFormatColor(☃xxx)) {
-               ☃ = "§" + ☃xxx;
-            } else if (isFormatSpecial(☃xxx)) {
-               ☃ = ☃ + "§" + ☃xxx;
+      while ((i = text.indexOf(167, i + 1)) != -1) {
+         if (i < j - 1) {
+            char c0 = text.charAt(i + 1);
+            if (isFormatColor(c0)) {
+               s = "§" + c0;
+            } else if (isFormatSpecial(c0)) {
+               s = s + "§" + c0;
             }
          }
       }
 
-      return ☃;
+      return s;
    }
 
    public boolean getBidiFlag() {
       return this.bidiFlag;
    }
 
-   public int getColorCode(char var1) {
-      int ☃ = "0123456789abcdef".indexOf(☃);
-      return ☃ >= 0 && ☃ < this.colorCode.length ? this.colorCode[☃] : -1;
+   public int getColorCode(char character) {
+      int i = "0123456789abcdef".indexOf(character);
+      if (i >= 0 && i < this.colorCode.length) {
+         int color = this.colorCode[i];
+         if (Config.isCustomColors()) {
+            color = CustomColors.getTextColor(i, color);
+         }
+
+         return color;
+      } else {
+         return 16777215;
+      }
+   }
+
+   protected void setColor(float r, float g, float b, float a) {
+      GlStateManager.color(r, g, b, a);
+   }
+
+   protected void enableAlpha() {
+      GlStateManager.enableAlpha();
+   }
+
+   protected void bindTexture(ResourceLocation location) {
+      this.renderEngine.bindTexture(location);
+   }
+
+   protected IResource getResource(ResourceLocation location) throws IOException {
+      return Minecraft.getMinecraft().getResourceManager().getResource(location);
    }
 }
diff --git a/patches/net/minecraft/client/gui/GuiCustomizeSkin.java b/patches/net/minecraft/client/gui/GuiCustomizeSkin.java
index 3a62c9f..1ffd5f4 100644
--- a/patches/net/minecraft/client/gui/GuiCustomizeSkin.java
+++ b/patches/net/minecraft/client/gui/GuiCustomizeSkin.java
@@ -1,95 +1,105 @@
 package net.minecraft.client.gui;
 
+import java.io.IOException;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.entity.player.EnumPlayerModelParts;
+import net.optifine.gui.GuiButtonOF;
+import net.optifine.gui.GuiScreenCapeOF;
 
 public class GuiCustomizeSkin extends GuiScreen {
    private final GuiScreen parentScreen;
    private String title;
 
-   public GuiCustomizeSkin(GuiScreen var1) {
-      this.parentScreen = ☃;
+   public GuiCustomizeSkin(GuiScreen parentScreenIn) {
+      this.parentScreen = parentScreenIn;
    }
 
-   @Override
    public void initGui() {
-      int ☃ = 0;
+      int i = 0;
       this.title = I18n.format("options.skinCustomisation.title");
 
-      for (EnumPlayerModelParts ☃x : EnumPlayerModelParts.values()) {
-         this.buttonList.add(new GuiCustomizeSkin.ButtonPart(☃x.getPartId(), this.width / 2 - 155 + ☃ % 2 * 160, this.height / 6 + 24 * (☃ >> 1), 150, 20, ☃x));
-         ☃++;
+      for (EnumPlayerModelParts enumplayermodelparts : EnumPlayerModelParts.values()) {
+         this.buttonList
+            .add(
+               new GuiCustomizeSkin.ButtonPart(
+                  enumplayermodelparts.getPartId(), this.width / 2 - 155 + i % 2 * 160, this.height / 6 + 24 * (i >> 1), 150, 20, enumplayermodelparts
+               )
+            );
+         i++;
       }
 
       this.buttonList
          .add(
             new GuiOptionButton(
                199,
-               this.width / 2 - 155 + ☃ % 2 * 160,
-               this.height / 6 + 24 * (☃ >> 1),
+               this.width / 2 - 155 + i % 2 * 160,
+               this.height / 6 + 24 * (i >> 1),
                GameSettings.Options.MAIN_HAND,
                this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND)
             )
          );
-      if (++☃ % 2 == 1) {
-         ☃++;
+      if (++i % 2 == 1) {
+         i++;
       }
 
-      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 24 * (☃ >> 1), I18n.format("gui.done")));
+      this.buttonList.add(new GuiButtonOF(210, this.width / 2 - 100, this.height / 6 + 24 * (i >> 1), I18n.format("of.options.skinCustomisation.ofCape")));
+      i += 2;
+      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 24 * (i >> 1), I18n.format("gui.done")));
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
-      if (☃ == 1) {
+   protected void keyTyped(char typedChar, int keyCode) throws IOException {
+      if (keyCode == 1) {
          this.mc.gameSettings.saveOptions();
       }
 
-      super.keyTyped(☃, ☃);
+      super.keyTyped(typedChar, keyCode);
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
-      if (☃.enabled) {
-         if (☃.id == 200) {
+   protected void actionPerformed(GuiButton button) throws IOException {
+      if (button.enabled) {
+         if (button.id == 210) {
+            this.mc.displayGuiScreen(new GuiScreenCapeOF(this));
+         }
+
+         if (button.id == 200) {
             this.mc.gameSettings.saveOptions();
             this.mc.displayGuiScreen(this.parentScreen);
-         } else if (☃.id == 199) {
+         } else if (button.id == 199) {
             this.mc.gameSettings.setOptionValue(GameSettings.Options.MAIN_HAND, 1);
-            ☃.displayString = this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND);
+            button.displayString = this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND);
             this.mc.gameSettings.sendSettingsToServer();
-         } else if (☃ instanceof GuiCustomizeSkin.ButtonPart) {
-            EnumPlayerModelParts ☃ = ((GuiCustomizeSkin.ButtonPart)☃).playerModelParts;
-            this.mc.gameSettings.switchModelPartEnabled(☃);
-            ☃.displayString = this.getMessage(☃);
+         } else if (button instanceof GuiCustomizeSkin.ButtonPart) {
+            EnumPlayerModelParts enumplayermodelparts = ((GuiCustomizeSkin.ButtonPart)button).playerModelParts;
+            this.mc.gameSettings.switchModelPartEnabled(enumplayermodelparts);
+            button.displayString = this.getMessage(enumplayermodelparts);
          }
       }
    }
 
-   @Override
-   public void drawScreen(int var1, int var2, float var3) {
+   public void drawScreen(int mouseX, int mouseY, float partialTicks) {
       this.drawDefaultBackground();
-      this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 20, 16777215);
-      super.drawScreen(☃, ☃, ☃);
+      this.a(this.fontRenderer, this.title, this.width / 2, 20, 16777215);
+      super.drawScreen(mouseX, mouseY, partialTicks);
    }
 
-   private String getMessage(EnumPlayerModelParts var1) {
-      String ☃;
-      if (this.mc.gameSettings.getModelParts().contains(☃)) {
-         ☃ = I18n.format("options.on");
+   private String getMessage(EnumPlayerModelParts playerModelParts) {
+      String s;
+      if (this.mc.gameSettings.getModelParts().contains(playerModelParts)) {
+         s = I18n.format("options.on");
       } else {
-         ☃ = I18n.format("options.off");
+         s = I18n.format("options.off");
       }
 
-      return ☃.getName().getFormattedText() + ": " + ☃;
+      return playerModelParts.getName().getFormattedText() + ": " + s;
    }
 
    class ButtonPart extends GuiButton {
       private final EnumPlayerModelParts playerModelParts;
 
-      private ButtonPart(int var2, int var3, int var4, int var5, int var6, EnumPlayerModelParts var7) {
-         super(☃, ☃, ☃, ☃, ☃, GuiCustomizeSkin.this.getMessage(☃));
-         this.playerModelParts = ☃;
+      private ButtonPart(int p_i45514_2_, int p_i45514_3_, int p_i45514_4_, int p_i45514_5_, int p_i45514_6_, EnumPlayerModelParts playerModelParts) {
+         super(p_i45514_2_, p_i45514_3_, p_i45514_4_, p_i45514_5_, p_i45514_6_, GuiCustomizeSkin.this.getMessage(playerModelParts));
+         this.playerModelParts = playerModelParts;
       }
    }
 }
diff --git a/patches/net/minecraft/client/gui/GuiDownloadTerrain.java b/patches/net/minecraft/client/gui/GuiDownloadTerrain.java
index 0b4ee22..5905941 100644
--- a/patches/net/minecraft/client/gui/GuiDownloadTerrain.java
+++ b/patches/net/minecraft/client/gui/GuiDownloadTerrain.java
@@ -1,21 +1,27 @@
 package net.minecraft.client.gui;
 
 import net.minecraft.client.resources.I18n;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
 
 public class GuiDownloadTerrain extends GuiScreen {
-   @Override
+   private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
+
    public void initGui() {
       this.buttonList.clear();
    }
 
-   @Override
-   public void drawScreen(int var1, int var2, float var3) {
-      this.drawBackground(0);
-      this.drawCenteredString(this.fontRenderer, I18n.format("multiplayer.downloadingTerrain"), this.width / 2, this.height / 2 - 50, 16777215);
-      super.drawScreen(☃, ☃, ☃);
+   public void drawScreen(int mouseX, int mouseY, float partialTicks) {
+      if (this.customLoadingScreen != null) {
+         this.customLoadingScreen.drawBackground(this.width, this.height);
+      } else {
+         this.drawBackground(0);
+      }
+
+      this.a(this.fontRenderer, I18n.format("multiplayer.downloadingTerrain"), this.width / 2, this.height / 2 - 50, 16777215);
+      super.drawScreen(mouseX, mouseY, partialTicks);
    }
 
-   @Override
    public boolean doesGuiPauseGame() {
       return false;
    }
diff --git a/patches/net/minecraft/client/gui/GuiIngame.java b/patches/net/minecraft/client/gui/GuiIngame.java
index d2db0a2..38f0a32 100644
--- a/patches/net/minecraft/client/gui/GuiIngame.java
+++ b/patches/net/minecraft/client/gui/GuiIngame.java
@@ -11,6 +11,7 @@
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.chat.IChatListener;
 import net.minecraft.client.gui.chat.NarratorChatListener;
@@ -51,10 +52,16 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.text.ChatType;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.world.border.WorldBorder;
+import net.optifine.CustomColors;
+import net.optifine.CustomItems;
+import net.optifine.TextureAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
 
 public class GuiIngame extends Gui {
    private static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
@@ -88,26 +95,26 @@ public class GuiIngame extends Gui {
    private long healthUpdateCounter;
    private final Map<ChatType, List<IChatListener>> chatListeners = Maps.newHashMap();
 
-   public GuiIngame(Minecraft var1) {
-      this.mc = ☃;
-      this.itemRenderer = ☃.getRenderItem();
-      this.overlayDebug = new GuiOverlayDebug(☃);
-      this.spectatorGui = new GuiSpectator(☃);
-      this.persistantChatGUI = new GuiNewChat(☃);
-      this.overlayPlayerList = new GuiPlayerTabOverlay(☃, this);
-      this.overlayBoss = new GuiBossOverlay(☃);
-      this.overlaySubtitle = new GuiSubtitleOverlay(☃);
-
-      for (ChatType ☃ : ChatType.values()) {
-         this.chatListeners.put(☃, Lists.newArrayList());
+   public GuiIngame(Minecraft mcIn) {
+      this.mc = mcIn;
+      this.itemRenderer = mcIn.getRenderItem();
+      this.overlayDebug = new GuiOverlayDebug(mcIn);
+      this.spectatorGui = new GuiSpectator(mcIn);
+      this.persistantChatGUI = new GuiNewChat(mcIn);
+      this.overlayPlayerList = new GuiPlayerTabOverlay(mcIn, this);
+      this.overlayBoss = new GuiBossOverlay(mcIn);
+      this.overlaySubtitle = new GuiSubtitleOverlay(mcIn);
+
+      for (ChatType chattype : ChatType.values()) {
+         this.chatListeners.put(chattype, Lists.newArrayList());
       }
 
-      IChatListener ☃ = NarratorChatListener.INSTANCE;
-      this.chatListeners.get(ChatType.CHAT).add(new NormalChatListener(☃));
-      this.chatListeners.get(ChatType.CHAT).add(☃);
-      this.chatListeners.get(ChatType.SYSTEM).add(new NormalChatListener(☃));
-      this.chatListeners.get(ChatType.SYSTEM).add(☃);
-      this.chatListeners.get(ChatType.GAME_INFO).add(new OverlayChatListener(☃));
+      IChatListener ichatlistener = NarratorChatListener.INSTANCE;
+      this.chatListeners.get(ChatType.CHAT).add(new NormalChatListener(mcIn));
+      this.chatListeners.get(ChatType.CHAT).add(ichatlistener);
+      this.chatListeners.get(ChatType.SYSTEM).add(new NormalChatListener(mcIn));
+      this.chatListeners.get(ChatType.SYSTEM).add(ichatlistener);
+      this.chatListeners.get(ChatType.GAME_INFO).add(new OverlayChatListener(mcIn));
       this.setDefaultTitlesTimes();
    }
 
@@ -117,14 +124,14 @@ public void setDefaultTitlesTimes() {
       this.titleFadeOut = 20;
    }
 
-   public void renderGameOverlay(float var1) {
-      ScaledResolution ☃ = new ScaledResolution(this.mc);
-      int ☃x = ☃.getScaledWidth();
-      int ☃xx = ☃.getScaledHeight();
-      FontRenderer ☃xxx = this.getFontRenderer();
+   public void renderGameOverlay(float partialTicks) {
+      ScaledResolution scaledresolution = new ScaledResolution(this.mc);
+      int i = scaledresolution.getScaledWidth();
+      int j = scaledresolution.getScaledHeight();
+      FontRenderer fontrenderer = this.getFontRenderer();
       GlStateManager.enableBlend();
-      if (Minecraft.isFancyGraphicsEnabled()) {
-         this.renderVignette(this.mc.player.getBrightness(), ☃);
+      if (Config.isVignetteEnabled()) {
+         this.renderVignette(this.mc.player.getBrightness(), scaledresolution);
       } else {
          GlStateManager.enableDepth();
          GlStateManager.tryBlendFuncSeparate(
@@ -135,28 +142,29 @@ public void renderGameOverlay(float var1) {
          );
       }
 
-      ItemStack ☃xxxx = this.mc.player.inventory.armorItemInSlot(3);
-      if (this.mc.gameSettings.thirdPersonView == 0 && ☃xxxx.getItem() == Item.getItemFromBlock(Blocks.PUMPKIN)) {
-         this.renderPumpkinOverlay(☃);
+      ItemStack itemstack = this.mc.player.inventory.armorItemInSlot(3);
+      if (this.mc.gameSettings.thirdPersonView == 0 && itemstack.getItem() == Item.getItemFromBlock(Blocks.PUMPKIN)) {
+         this.renderPumpkinOverlay(scaledresolution);
       }
 
       if (!this.mc.player.isPotionActive(MobEffects.NAUSEA)) {
-         float ☃xxxxx = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * ☃;
-         if (☃xxxxx > 0.0F) {
-            this.renderPortal(☃xxxxx, ☃);
+         float f = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
+         if (f > 0.0F) {
+            this.renderPortal(f, scaledresolution);
          }
       }
 
       if (this.mc.playerController.isSpectator()) {
-         this.spectatorGui.renderTooltip(☃, ☃);
+         this.spectatorGui.renderTooltip(scaledresolution, partialTicks);
       } else {
-         this.renderHotbar(☃, ☃);
+         this.renderHotbar(scaledresolution, partialTicks);
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       this.mc.getTextureManager().bindTexture(ICONS);
       GlStateManager.enableBlend();
-      this.renderAttackIndicator(☃, ☃);
+      this.renderAttackIndicator(partialTicks, scaledresolution);
+      GlStateManager.enableAlpha();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
@@ -166,62 +174,62 @@ public void renderGameOverlay(float var1) {
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       this.mc.getTextureManager().bindTexture(ICONS);
       if (this.mc.playerController.shouldDrawHUD()) {
-         this.renderPlayerStats(☃);
+         this.renderPlayerStats(scaledresolution);
       }
 
-      this.renderMountHealth(☃);
+      this.renderMountHealth(scaledresolution);
       GlStateManager.disableBlend();
       if (this.mc.player.getSleepTimer() > 0) {
          this.mc.profiler.startSection("sleep");
          GlStateManager.disableDepth();
          GlStateManager.disableAlpha();
-         int ☃xxxxx = this.mc.player.getSleepTimer();
-         float ☃xxxxxx = ☃xxxxx / 100.0F;
-         if (☃xxxxxx > 1.0F) {
-            ☃xxxxxx = 1.0F - (☃xxxxx - 100) / 10.0F;
+         int j1 = this.mc.player.getSleepTimer();
+         float f1 = j1 / 100.0F;
+         if (f1 > 1.0F) {
+            f1 = 1.0F - (j1 - 100) / 10.0F;
          }
 
-         int ☃xxxxxxx = (int)(220.0F * ☃xxxxxx) << 24 | 1052704;
-         drawRect(0, 0, ☃x, ☃xx, ☃xxxxxxx);
+         int k = (int)(220.0F * f1) << 24 | 1052704;
+         drawRect(0, 0, i, j, k);
          GlStateManager.enableAlpha();
          GlStateManager.enableDepth();
          this.mc.profiler.endSection();
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      int ☃xxxxx = ☃x / 2 - 91;
+      int k1 = i / 2 - 91;
       if (this.mc.player.isRidingHorse()) {
-         this.renderHorseJumpBar(☃, ☃xxxxx);
+         this.renderHorseJumpBar(scaledresolution, k1);
       } else if (this.mc.playerController.gameIsSurvivalOrAdventure()) {
-         this.renderExpBar(☃, ☃xxxxx);
+         this.renderExpBar(scaledresolution, k1);
       }
 
       if (this.mc.gameSettings.heldItemTooltips && !this.mc.playerController.isSpectator()) {
-         this.renderSelectedItem(☃);
+         this.renderSelectedItem(scaledresolution);
       } else if (this.mc.player.isSpectator()) {
-         this.spectatorGui.renderSelectedItem(☃);
+         this.spectatorGui.renderSelectedItem(scaledresolution);
       }
 
       if (this.mc.isDemo()) {
-         this.renderDemo(☃);
+         this.renderDemo(scaledresolution);
       }
 
-      this.renderPotionEffects(☃);
+      this.renderPotionEffects(scaledresolution);
       if (this.mc.gameSettings.showDebugInfo) {
-         this.overlayDebug.renderDebugInfo(☃);
+         this.overlayDebug.renderDebugInfo(scaledresolution);
       }
 
       if (this.overlayMessageTime > 0) {
          this.mc.profiler.startSection("overlayMessage");
-         float ☃xxxxxx = this.overlayMessageTime - ☃;
-         int ☃xxxxxxx = (int)(☃xxxxxx * 255.0F / 20.0F);
-         if (☃xxxxxxx > 255) {
-            ☃xxxxxxx = 255;
+         float f2 = this.overlayMessageTime - partialTicks;
+         int l1 = (int)(f2 * 255.0F / 20.0F);
+         if (l1 > 255) {
+            l1 = 255;
          }
 
-         if (☃xxxxxxx > 8) {
+         if (l1 > 8) {
             GlStateManager.pushMatrix();
-            GlStateManager.translate((float)(☃x / 2), (float)(☃xx - 68), 0.0F);
+            GlStateManager.translate((float)(i / 2), (float)(j - 68), 0.0F);
             GlStateManager.enableBlend();
             GlStateManager.tryBlendFuncSeparate(
                GlStateManager.SourceFactor.SRC_ALPHA,
@@ -229,12 +237,12 @@ public void renderGameOverlay(float var1) {
                GlStateManager.SourceFactor.ONE,
                GlStateManager.DestFactor.ZERO
             );
-            int ☃xxxxxxxx = 16777215;
+            int l = 16777215;
             if (this.animateOverlayMessageColor) {
-               ☃xxxxxxxx = MathHelper.hsvToRGB(☃xxxxxx / 50.0F, 0.7F, 0.6F) & 16777215;
+               l = MathHelper.hsvToRGB(f2 / 50.0F, 0.7F, 0.6F) & 16777215;
             }
 
-            ☃xxx.drawString(this.overlayMessage, -☃xxx.getStringWidth(this.overlayMessage) / 2, -4, ☃xxxxxxxx + (☃xxxxxxx << 24 & 0xFF000000));
+            fontrenderer.drawString(this.overlayMessage, -fontrenderer.getStringWidth(this.overlayMessage) / 2, -4, l + (l1 << 24 & 0xFF000000));
             GlStateManager.disableBlend();
             GlStateManager.popMatrix();
          }
@@ -242,24 +250,24 @@ public void renderGameOverlay(float var1) {
          this.mc.profiler.endSection();
       }
 
-      this.overlaySubtitle.renderSubtitles(☃);
+      this.overlaySubtitle.renderSubtitles(scaledresolution);
       if (this.titlesTimer > 0) {
          this.mc.profiler.startSection("titleAndSubtitle");
-         float ☃xxxxxxxx = this.titlesTimer - ☃;
-         int ☃xxxxxxxxx = 255;
+         float f3 = this.titlesTimer - partialTicks;
+         int i2 = 255;
          if (this.titlesTimer > this.titleFadeOut + this.titleDisplayTime) {
-            float ☃xxxxxxxxxx = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut - ☃xxxxxxxx;
-            ☃xxxxxxxxx = (int)(☃xxxxxxxxxx * 255.0F / this.titleFadeIn);
+            float f4 = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut - f3;
+            i2 = (int)(f4 * 255.0F / this.titleFadeIn);
          }
 
          if (this.titlesTimer <= this.titleFadeOut) {
-            ☃xxxxxxxxx = (int)(☃xxxxxxxx * 255.0F / this.titleFadeOut);
+            i2 = (int)(f3 * 255.0F / this.titleFadeOut);
          }
 
-         ☃xxxxxxxxx = MathHelper.clamp(☃xxxxxxxxx, 0, 255);
-         if (☃xxxxxxxxx > 8) {
+         i2 = MathHelper.clamp(i2, 0, 255);
+         if (i2 > 8) {
             GlStateManager.pushMatrix();
-            GlStateManager.translate((float)(☃x / 2), (float)(☃xx / 2), 0.0F);
+            GlStateManager.translate((float)(i / 2), (float)(j / 2), 0.0F);
             GlStateManager.enableBlend();
             GlStateManager.tryBlendFuncSeparate(
                GlStateManager.SourceFactor.SRC_ALPHA,
@@ -269,12 +277,12 @@ public void renderGameOverlay(float var1) {
             );
             GlStateManager.pushMatrix();
             GlStateManager.scale(4.0F, 4.0F, 4.0F);
-            int ☃xxxxxxxxxx = ☃xxxxxxxxx << 24 & 0xFF000000;
-            ☃xxx.drawString(this.displayedTitle, -☃xxx.getStringWidth(this.displayedTitle) / 2, -10.0F, 16777215 | ☃xxxxxxxxxx, true);
+            int j2 = i2 << 24 & 0xFF000000;
+            fontrenderer.drawString(this.displayedTitle, -fontrenderer.getStringWidth(this.displayedTitle) / 2, -10.0F, 16777215 | j2, true);
             GlStateManager.popMatrix();
             GlStateManager.pushMatrix();
             GlStateManager.scale(2.0F, 2.0F, 2.0F);
-            ☃xxx.drawString(this.displayedSubTitle, -☃xxx.getStringWidth(this.displayedSubTitle) / 2, 5.0F, 16777215 | ☃xxxxxxxxxx, true);
+            fontrenderer.drawString(this.displayedSubTitle, -fontrenderer.getStringWidth(this.displayedSubTitle) / 2, 5.0F, 16777215 | j2, true);
             GlStateManager.popMatrix();
             GlStateManager.disableBlend();
             GlStateManager.popMatrix();
@@ -283,19 +291,19 @@ public void renderGameOverlay(float var1) {
          this.mc.profiler.endSection();
       }
 
-      Scoreboard ☃xxxxxxxxxx = this.mc.world.getScoreboard();
-      ScoreObjective ☃xxxxxxxxxxx = null;
-      ScorePlayerTeam ☃xxxxxxxxxxxx = ☃xxxxxxxxxx.getPlayersTeam(this.mc.player.getName());
-      if (☃xxxxxxxxxxxx != null) {
-         int ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxxx.getColor().getColorIndex();
-         if (☃xxxxxxxxxxxxx >= 0) {
-            ☃xxxxxxxxxxx = ☃xxxxxxxxxx.getObjectiveInDisplaySlot(3 + ☃xxxxxxxxxxxxx);
+      Scoreboard scoreboard = this.mc.world.getScoreboard();
+      ScoreObjective scoreobjective = null;
+      ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(this.mc.player.getName());
+      if (scoreplayerteam != null) {
+         int i1 = scoreplayerteam.getColor().getColorIndex();
+         if (i1 >= 0) {
+            scoreobjective = scoreboard.getObjectiveInDisplaySlot(3 + i1);
          }
       }
 
-      ScoreObjective ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxx != null ? ☃xxxxxxxxxxx : ☃xxxxxxxxxx.getObjectiveInDisplaySlot(1);
-      if (☃xxxxxxxxxxxxx != null) {
-         this.renderScoreboard(☃xxxxxxxxxxxxx, ☃);
+      ScoreObjective scoreobjective1 = scoreobjective != null ? scoreobjective : scoreboard.getObjectiveInDisplaySlot(1);
+      if (scoreobjective1 != null) {
+         this.renderScoreboard(scoreobjective1, scaledresolution);
       }
 
       GlStateManager.enableBlend();
@@ -304,18 +312,18 @@ public void renderGameOverlay(float var1) {
       );
       GlStateManager.disableAlpha();
       GlStateManager.pushMatrix();
-      GlStateManager.translate(0.0F, (float)(☃xx - 48), 0.0F);
+      GlStateManager.translate(0.0F, (float)(j - 48), 0.0F);
       this.mc.profiler.startSection("chat");
       this.persistantChatGUI.drawChat(this.updateCounter);
       this.mc.profiler.endSection();
       GlStateManager.popMatrix();
-      ☃xxxxxxxxxxxxx = ☃xxxxxxxxxx.getObjectiveInDisplaySlot(0);
-      if (!this.mc.gameSettings.keyBindPlayerList.isKeyDown()
-         || this.mc.isIntegratedServerRunning() && this.mc.player.connection.getPlayerInfoMap().size() <= 1 && ☃xxxxxxxxxxxxx == null) {
-         this.overlayPlayerList.updatePlayerList(false);
-      } else {
+      scoreobjective1 = scoreboard.getObjectiveInDisplaySlot(0);
+      if (this.mc.gameSettings.keyBindPlayerList.isKeyDown()
+         && (!this.mc.isIntegratedServerRunning() || this.mc.player.connection.getPlayerInfoMap().size() > 1 || scoreobjective1 != null)) {
          this.overlayPlayerList.updatePlayerList(true);
-         this.overlayPlayerList.renderPlayerlist(☃x, ☃xxxxxxxxxx, ☃xxxxxxxxxxxxx);
+         this.overlayPlayerList.renderPlayerlist(i, scoreboard, scoreobjective1);
+      } else {
+         this.overlayPlayerList.updatePlayerList(false);
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
@@ -323,29 +331,30 @@ public void renderGameOverlay(float var1) {
       GlStateManager.enableAlpha();
    }
 
-   private void renderAttackIndicator(float var1, ScaledResolution var2) {
-      GameSettings ☃ = this.mc.gameSettings;
-      if (☃.thirdPersonView == 0) {
+   private void renderAttackIndicator(float p_184045_1_, ScaledResolution p_184045_2_) {
+      GameSettings gamesettings = this.mc.gameSettings;
+      if (gamesettings.thirdPersonView == 0) {
          if (this.mc.playerController.isSpectator() && this.mc.pointedEntity == null) {
-            RayTraceResult ☃x = this.mc.objectMouseOver;
-            if (☃x == null || ☃x.typeOfHit != RayTraceResult.Type.BLOCK) {
+            RayTraceResult raytraceresult = this.mc.objectMouseOver;
+            if (raytraceresult == null || raytraceresult.typeOfHit != Type.BLOCK) {
                return;
             }
 
-            BlockPos ☃xx = ☃x.getBlockPos();
-            if (!this.mc.world.getBlockState(☃xx).getBlock().hasTileEntity() || !(this.mc.world.getTileEntity(☃xx) instanceof IInventory)) {
+            BlockPos blockpos = raytraceresult.getBlockPos();
+            IBlockState state = this.mc.world.getBlockState(blockpos);
+            if (!ReflectorForge.blockHasTileEntity(state) || !(this.mc.world.getTileEntity(blockpos) instanceof IInventory)) {
                return;
             }
          }
 
-         int ☃xx = ☃.getScaledWidth();
-         int ☃xxx = ☃.getScaledHeight();
-         if (☃.showDebugInfo && !☃.hideGUI && !this.mc.player.hasReducedDebug() && !☃.reducedDebugInfo) {
+         int l = p_184045_2_.getScaledWidth();
+         int i1 = p_184045_2_.getScaledHeight();
+         if (gamesettings.showDebugInfo && !gamesettings.hideGUI && !this.mc.player.hasReducedDebug() && !gamesettings.reducedDebugInfo) {
             GlStateManager.pushMatrix();
-            GlStateManager.translate((float)(☃xx / 2), (float)(☃xxx / 2), this.zLevel);
-            Entity ☃xxxx = this.mc.getRenderViewEntity();
-            GlStateManager.rotate(☃xxxx.prevRotationPitch + (☃xxxx.rotationPitch - ☃xxxx.prevRotationPitch) * ☃, -1.0F, 0.0F, 0.0F);
-            GlStateManager.rotate(☃xxxx.prevRotationYaw + (☃xxxx.rotationYaw - ☃xxxx.prevRotationYaw) * ☃, 0.0F, 1.0F, 0.0F);
+            GlStateManager.translate((float)(l / 2), (float)(i1 / 2), this.zLevel);
+            Entity entity = this.mc.getRenderViewEntity();
+            GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * p_184045_1_, -1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * p_184045_1_, 0.0F, 1.0F, 0.0F);
             GlStateManager.scale(-1.0F, -1.0F, -1.0F);
             OpenGlHelper.renderDirections(10);
             GlStateManager.popMatrix();
@@ -357,99 +366,117 @@ private void renderAttackIndicator(float var1, ScaledResolution var2) {
                GlStateManager.DestFactor.ZERO
             );
             GlStateManager.enableAlpha();
-            this.drawTexturedModalRect(☃xx / 2 - 7, ☃xxx / 2 - 7, 0, 0, 16, 16);
+            this.drawTexturedModalRect(l / 2 - 7, i1 / 2 - 7, 0, 0, 16, 16);
             if (this.mc.gameSettings.attackIndicator == 1) {
-               float ☃xxxx = this.mc.player.getCooledAttackStrength(0.0F);
-               boolean ☃xxxxx = false;
-               if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && ☃xxxx >= 1.0F) {
-                  ☃xxxxx = this.mc.player.getCooldownPeriod() > 5.0F;
-                  ☃xxxxx &= ((EntityLivingBase)this.mc.pointedEntity).isEntityAlive();
+               float f = this.mc.player.getCooledAttackStrength(0.0F);
+               boolean flag = false;
+               if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && f >= 1.0F) {
+                  flag = this.mc.player.getCooldownPeriod() > 5.0F;
+                  flag &= ((EntityLivingBase)this.mc.pointedEntity).isEntityAlive();
                }
 
-               int ☃xxxxxx = ☃xxx / 2 - 7 + 16;
-               int ☃xxxxxxx = ☃xx / 2 - 8;
-               if (☃xxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxx, ☃xxxxxx, 68, 94, 16, 16);
-               } else if (☃xxxx < 1.0F) {
-                  int ☃xxxxxxxx = (int)(☃xxxx * 17.0F);
-                  this.drawTexturedModalRect(☃xxxxxxx, ☃xxxxxx, 36, 94, 16, 4);
-                  this.drawTexturedModalRect(☃xxxxxxx, ☃xxxxxx, 52, 94, ☃xxxxxxxx, 4);
+               int i = i1 / 2 - 7 + 16;
+               int j = l / 2 - 8;
+               if (flag) {
+                  this.drawTexturedModalRect(j, i, 68, 94, 16, 16);
+               } else if (f < 1.0F) {
+                  int k = (int)(f * 17.0F);
+                  this.drawTexturedModalRect(j, i, 36, 94, 16, 4);
+                  this.drawTexturedModalRect(j, i, 52, 94, k, 4);
                }
             }
          }
       }
    }
 
-   protected void renderPotionEffects(ScaledResolution var1) {
-      Collection<PotionEffect> ☃ = this.mc.player.getActivePotionEffects();
-      if (!☃.isEmpty()) {
+   protected void renderPotionEffects(ScaledResolution resolution) {
+      Collection<PotionEffect> collection = this.mc.player.getActivePotionEffects();
+      if (!collection.isEmpty()) {
          this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
          GlStateManager.enableBlend();
-         int ☃x = 0;
-         int ☃xx = 0;
-
-         for (PotionEffect ☃xxx : Ordering.natural().reverse().sortedCopy(☃)) {
-            Potion ☃xxxx = ☃xxx.getPotion();
-            if (☃xxxx.hasStatusIcon() && ☃xxx.doesShowParticles()) {
-               int ☃xxxxx = ☃.getScaledWidth();
-               int ☃xxxxxx = 1;
+         int i = 0;
+         int j = 0;
+
+         for (PotionEffect potioneffect : Ordering.natural().reverse().sortedCopy(collection)) {
+            Potion potion = potioneffect.getPotion();
+            boolean potionHasIcon = potion.hasStatusIcon();
+            if (Reflector.ForgePotion_shouldRenderHUD.exists()) {
+               if (!Reflector.callBoolean(potion, Reflector.ForgePotion_shouldRenderHUD, new Object[]{potioneffect})) {
+                  continue;
+               }
+
+               this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
+               potionHasIcon = true;
+            }
+
+            if (potionHasIcon && potioneffect.doesShowParticles()) {
+               int k = resolution.getScaledWidth();
+               int l = 1;
                if (this.mc.isDemo()) {
-                  ☃xxxxxx += 15;
+                  l += 15;
                }
 
-               int ☃xxxxxxx = ☃xxxx.getStatusIconIndex();
-               if (☃xxxx.isBeneficial()) {
-                  ☃x++;
-                  ☃xxxxx -= 25 * ☃x;
+               int i1 = potion.getStatusIconIndex();
+               if (potion.isBeneficial()) {
+                  i++;
+                  k -= 25 * i;
                } else {
-                  ☃xx++;
-                  ☃xxxxx -= 25 * ☃xx;
-                  ☃xxxxxx += 26;
+                  j++;
+                  k -= 25 * j;
+                  l += 26;
                }
 
                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-               float ☃xxxxxxxx = 1.0F;
-               if (☃xxx.getIsAmbient()) {
-                  this.drawTexturedModalRect(☃xxxxx, ☃xxxxxx, 165, 166, 24, 24);
+               float f = 1.0F;
+               if (potioneffect.getIsAmbient()) {
+                  this.drawTexturedModalRect(k, l, 165, 166, 24, 24);
                } else {
-                  this.drawTexturedModalRect(☃xxxxx, ☃xxxxxx, 141, 166, 24, 24);
-                  if (☃xxx.getDuration() <= 200) {
-                     int ☃xxxxxxxxx = 10 - ☃xxx.getDuration() / 20;
-                     ☃xxxxxxxx = MathHelper.clamp(☃xxx.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F)
-                        + MathHelper.cos(☃xxx.getDuration() * (float) Math.PI / 5.0F) * MathHelper.clamp(☃xxxxxxxxx / 10.0F * 0.25F, 0.0F, 0.25F);
+                  this.drawTexturedModalRect(k, l, 141, 166, 24, 24);
+                  if (potioneffect.getDuration() <= 200) {
+                     int j1 = 10 - potioneffect.getDuration() / 20;
+                     f = MathHelper.clamp(potioneffect.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F)
+                        + MathHelper.cos(potioneffect.getDuration() * (float) Math.PI / 5.0F) * MathHelper.clamp(j1 / 10.0F * 0.25F, 0.0F, 0.25F);
                   }
                }
 
-               GlStateManager.color(1.0F, 1.0F, 1.0F, ☃xxxxxxxx);
-               this.drawTexturedModalRect(☃xxxxx + 3, ☃xxxxxx + 3, ☃xxxxxxx % 8 * 18, 198 + ☃xxxxxxx / 8 * 18, 18, 18);
+               GlStateManager.color(1.0F, 1.0F, 1.0F, f);
+               if (Reflector.ForgePotion_renderHUDEffect.exists()) {
+                  if (potion.hasStatusIcon()) {
+                     this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
+                  }
+
+                  Reflector.call(potion, Reflector.ForgePotion_renderHUDEffect, new Object[]{potioneffect, this, k, l, this.zLevel, f});
+               } else {
+                  this.drawTexturedModalRect(k + 3, l + 3, i1 % 8 * 18, 198 + i1 / 8 * 18, 18, 18);
+               }
             }
          }
       }
    }
 
-   protected void renderHotbar(ScaledResolution var1, float var2) {
+   protected void renderHotbar(ScaledResolution sr, float partialTicks) {
       if (this.mc.getRenderViewEntity() instanceof EntityPlayer) {
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
          this.mc.getTextureManager().bindTexture(WIDGETS_TEX_PATH);
-         EntityPlayer ☃ = (EntityPlayer)this.mc.getRenderViewEntity();
-         ItemStack ☃x = ☃.getHeldItemOffhand();
-         EnumHandSide ☃xx = ☃.getPrimaryHand().opposite();
-         int ☃xxx = ☃.getScaledWidth() / 2;
-         float ☃xxxx = this.zLevel;
-         int ☃xxxxx = 182;
-         int ☃xxxxxx = 91;
+         EntityPlayer entityplayer = (EntityPlayer)this.mc.getRenderViewEntity();
+         ItemStack itemstack = entityplayer.getHeldItemOffhand();
+         EnumHandSide enumhandside = entityplayer.getPrimaryHand().opposite();
+         int i = sr.getScaledWidth() / 2;
+         float f = this.zLevel;
+         int j = 182;
+         int k = 91;
          this.zLevel = -90.0F;
-         this.drawTexturedModalRect(☃xxx - 91, ☃.getScaledHeight() - 22, 0, 0, 182, 22);
-         this.drawTexturedModalRect(☃xxx - 91 - 1 + ☃.inventory.currentItem * 20, ☃.getScaledHeight() - 22 - 1, 0, 22, 24, 22);
-         if (!☃x.isEmpty()) {
-            if (☃xx == EnumHandSide.LEFT) {
-               this.drawTexturedModalRect(☃xxx - 91 - 29, ☃.getScaledHeight() - 23, 24, 22, 29, 24);
+         this.drawTexturedModalRect(i - 91, sr.getScaledHeight() - 22, 0, 0, 182, 22);
+         this.drawTexturedModalRect(i - 91 - 1 + entityplayer.inventory.currentItem * 20, sr.getScaledHeight() - 22 - 1, 0, 22, 24, 22);
+         if (!itemstack.isEmpty()) {
+            if (enumhandside == EnumHandSide.LEFT) {
+               this.drawTexturedModalRect(i - 91 - 29, sr.getScaledHeight() - 23, 24, 22, 29, 24);
             } else {
-               this.drawTexturedModalRect(☃xxx + 91, ☃.getScaledHeight() - 23, 53, 22, 29, 24);
+               this.drawTexturedModalRect(i + 91, sr.getScaledHeight() - 23, 53, 22, 29, 24);
             }
          }
 
-         this.zLevel = ☃xxxx;
+         this.zLevel = f;
          GlStateManager.enableRescaleNormal();
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
@@ -459,36 +486,40 @@ protected void renderHotbar(ScaledResolution var1, float var2) {
             GlStateManager.DestFactor.ZERO
          );
          RenderHelper.enableGUIStandardItemLighting();
+         CustomItems.setRenderOffHand(false);
 
-         for (int ☃xxxxxxx = 0; ☃xxxxxxx < 9; ☃xxxxxxx++) {
-            int ☃xxxxxxxx = ☃xxx - 90 + ☃xxxxxxx * 20 + 2;
-            int ☃xxxxxxxxx = ☃.getScaledHeight() - 16 - 3;
-            this.renderHotbarItem(☃xxxxxxxx, ☃xxxxxxxxx, ☃, ☃, ☃.inventory.mainInventory.get(☃xxxxxxx));
+         for (int l = 0; l < 9; l++) {
+            int i1 = i - 90 + l * 20 + 2;
+            int j1 = sr.getScaledHeight() - 16 - 3;
+            this.renderHotbarItem(i1, j1, partialTicks, entityplayer, (ItemStack)entityplayer.inventory.mainInventory.get(l));
          }
 
-         if (!☃x.isEmpty()) {
-            int ☃xxxxxxx = ☃.getScaledHeight() - 16 - 3;
-            if (☃xx == EnumHandSide.LEFT) {
-               this.renderHotbarItem(☃xxx - 91 - 26, ☃xxxxxxx, ☃, ☃, ☃x);
+         if (!itemstack.isEmpty()) {
+            CustomItems.setRenderOffHand(true);
+            int l1 = sr.getScaledHeight() - 16 - 3;
+            if (enumhandside == EnumHandSide.LEFT) {
+               this.renderHotbarItem(i - 91 - 26, l1, partialTicks, entityplayer, itemstack);
             } else {
-               this.renderHotbarItem(☃xxx + 91 + 10, ☃xxxxxxx, ☃, ☃, ☃x);
+               this.renderHotbarItem(i + 91 + 10, l1, partialTicks, entityplayer, itemstack);
             }
+
+            CustomItems.setRenderOffHand(false);
          }
 
          if (this.mc.gameSettings.attackIndicator == 2) {
-            float ☃xxxxxxx = this.mc.player.getCooledAttackStrength(0.0F);
-            if (☃xxxxxxx < 1.0F) {
-               int ☃xxxxxxxx = ☃.getScaledHeight() - 20;
-               int ☃xxxxxxxxx = ☃xxx + 91 + 6;
-               if (☃xx == EnumHandSide.RIGHT) {
-                  ☃xxxxxxxxx = ☃xxx - 91 - 22;
+            float f1 = this.mc.player.getCooledAttackStrength(0.0F);
+            if (f1 < 1.0F) {
+               int i2 = sr.getScaledHeight() - 20;
+               int j2 = i + 91 + 6;
+               if (enumhandside == EnumHandSide.RIGHT) {
+                  j2 = i - 91 - 22;
                }
 
                this.mc.getTextureManager().bindTexture(Gui.ICONS);
-               int ☃xxxxxxxxxx = (int)(☃xxxxxxx * 19.0F);
+               int k1 = (int)(f1 * 19.0F);
                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-               this.drawTexturedModalRect(☃xxxxxxxxx, ☃xxxxxxxx, 0, 94, 18, 18);
-               this.drawTexturedModalRect(☃xxxxxxxxx, ☃xxxxxxxx + 18 - ☃xxxxxxxxxx, 18, 112 - ☃xxxxxxxxxx, 18, ☃xxxxxxxxxx);
+               this.drawTexturedModalRect(j2, i2, 0, 94, 18, 18);
+               this.drawTexturedModalRect(j2, i2 + 18 - k1, 18, 112 - k1, 18, k1);
             }
          }
 
@@ -498,70 +529,75 @@ protected void renderHotbar(ScaledResolution var1, float var2) {
       }
    }
 
-   public void renderHorseJumpBar(ScaledResolution var1, int var2) {
+   public void renderHorseJumpBar(ScaledResolution scaledRes, int x) {
       this.mc.profiler.startSection("jumpBar");
       this.mc.getTextureManager().bindTexture(Gui.ICONS);
-      float ☃ = this.mc.player.getHorseJumpPower();
-      int ☃x = 182;
-      int ☃xx = (int)(☃ * 183.0F);
-      int ☃xxx = ☃.getScaledHeight() - 32 + 3;
-      this.drawTexturedModalRect(☃, ☃xxx, 0, 84, 182, 5);
-      if (☃xx > 0) {
-         this.drawTexturedModalRect(☃, ☃xxx, 0, 89, ☃xx, 5);
+      float f = this.mc.player.getHorseJumpPower();
+      int i = 182;
+      int j = (int)(f * 183.0F);
+      int k = scaledRes.getScaledHeight() - 32 + 3;
+      this.drawTexturedModalRect(x, k, 0, 84, 182, 5);
+      if (j > 0) {
+         this.drawTexturedModalRect(x, k, 0, 89, j, 5);
       }
 
       this.mc.profiler.endSection();
    }
 
-   public void renderExpBar(ScaledResolution var1, int var2) {
+   public void renderExpBar(ScaledResolution scaledRes, int x) {
       this.mc.profiler.startSection("expBar");
       this.mc.getTextureManager().bindTexture(Gui.ICONS);
-      int ☃ = this.mc.player.xpBarCap();
-      if (☃ > 0) {
-         int ☃x = 182;
-         int ☃xx = (int)(this.mc.player.experience * 183.0F);
-         int ☃xxx = ☃.getScaledHeight() - 32 + 3;
-         this.drawTexturedModalRect(☃, ☃xxx, 0, 64, 182, 5);
-         if (☃xx > 0) {
-            this.drawTexturedModalRect(☃, ☃xxx, 0, 69, ☃xx, 5);
+      int i = this.mc.player.xpBarCap();
+      if (i > 0) {
+         int j = 182;
+         int k = (int)(this.mc.player.experience * 183.0F);
+         int l = scaledRes.getScaledHeight() - 32 + 3;
+         this.drawTexturedModalRect(x, l, 0, 64, 182, 5);
+         if (k > 0) {
+            this.drawTexturedModalRect(x, l, 0, 69, k, 5);
          }
       }
 
       this.mc.profiler.endSection();
       if (this.mc.player.experienceLevel > 0) {
          this.mc.profiler.startSection("expLevel");
-         String ☃x = "" + this.mc.player.experienceLevel;
-         int ☃xx = (☃.getScaledWidth() - this.getFontRenderer().getStringWidth(☃x)) / 2;
-         int ☃xxx = ☃.getScaledHeight() - 31 - 4;
-         this.getFontRenderer().drawString(☃x, ☃xx + 1, ☃xxx, 0);
-         this.getFontRenderer().drawString(☃x, ☃xx - 1, ☃xxx, 0);
-         this.getFontRenderer().drawString(☃x, ☃xx, ☃xxx + 1, 0);
-         this.getFontRenderer().drawString(☃x, ☃xx, ☃xxx - 1, 0);
-         this.getFontRenderer().drawString(☃x, ☃xx, ☃xxx, 8453920);
+         int col = 8453920;
+         if (Config.isCustomColors()) {
+            col = CustomColors.getExpBarTextColor(col);
+         }
+
+         String s = "" + this.mc.player.experienceLevel;
+         int i1 = (scaledRes.getScaledWidth() - this.getFontRenderer().getStringWidth(s)) / 2;
+         int j1 = scaledRes.getScaledHeight() - 31 - 4;
+         this.getFontRenderer().drawString(s, i1 + 1, j1, 0);
+         this.getFontRenderer().drawString(s, i1 - 1, j1, 0);
+         this.getFontRenderer().drawString(s, i1, j1 + 1, 0);
+         this.getFontRenderer().drawString(s, i1, j1 - 1, 0);
+         this.getFontRenderer().drawString(s, i1, j1, col);
          this.mc.profiler.endSection();
       }
    }
 
-   public void renderSelectedItem(ScaledResolution var1) {
+   public void renderSelectedItem(ScaledResolution scaledRes) {
       this.mc.profiler.startSection("selectedItemName");
       if (this.remainingHighlightTicks > 0 && !this.highlightingItemStack.isEmpty()) {
-         String ☃ = this.highlightingItemStack.getDisplayName();
+         String s = this.highlightingItemStack.getDisplayName();
          if (this.highlightingItemStack.hasDisplayName()) {
-            ☃ = TextFormatting.ITALIC + ☃;
+            s = TextFormatting.ITALIC + s;
          }
 
-         int ☃x = (☃.getScaledWidth() - this.getFontRenderer().getStringWidth(☃)) / 2;
-         int ☃xx = ☃.getScaledHeight() - 59;
+         int i = (scaledRes.getScaledWidth() - this.getFontRenderer().getStringWidth(s)) / 2;
+         int j = scaledRes.getScaledHeight() - 59;
          if (!this.mc.playerController.shouldDrawHUD()) {
-            ☃xx += 14;
+            j += 14;
          }
 
-         int ☃xxx = (int)(this.remainingHighlightTicks * 256.0F / 10.0F);
-         if (☃xxx > 255) {
-            ☃xxx = 255;
+         int k = (int)(this.remainingHighlightTicks * 256.0F / 10.0F);
+         if (k > 255) {
+            k = 255;
          }
 
-         if (☃xxx > 0) {
+         if (k > 0) {
             GlStateManager.pushMatrix();
             GlStateManager.enableBlend();
             GlStateManager.tryBlendFuncSeparate(
@@ -570,7 +606,7 @@ public void renderSelectedItem(ScaledResolution var1) {
                GlStateManager.SourceFactor.ONE,
                GlStateManager.DestFactor.ZERO
             );
-            this.getFontRenderer().drawStringWithShadow(☃, ☃x, ☃xx, 16777215 + (☃xxx << 24));
+            this.getFontRenderer().drawStringWithShadow(s, i, j, 16777215 + (k << 24));
             GlStateManager.disableBlend();
             GlStateManager.popMatrix();
          }
@@ -579,253 +615,229 @@ public void renderSelectedItem(ScaledResolution var1) {
       this.mc.profiler.endSection();
    }
 
-   public void renderDemo(ScaledResolution var1) {
+   public void renderDemo(ScaledResolution scaledRes) {
       this.mc.profiler.startSection("demo");
-      String ☃;
+      String s;
       if (this.mc.world.getTotalWorldTime() >= 120500L) {
-         ☃ = I18n.format("demo.demoExpired");
+         s = I18n.format("demo.demoExpired");
       } else {
-         ☃ = I18n.format("demo.remainingTime", StringUtils.ticksToElapsedTime((int)(120500L - this.mc.world.getTotalWorldTime())));
+         s = I18n.format("demo.remainingTime", StringUtils.ticksToElapsedTime((int)(120500L - this.mc.world.getTotalWorldTime())));
       }
 
-      int ☃x = this.getFontRenderer().getStringWidth(☃);
-      this.getFontRenderer().drawStringWithShadow(☃, ☃.getScaledWidth() - ☃x - 10, 5.0F, 16777215);
+      int i = this.getFontRenderer().getStringWidth(s);
+      this.getFontRenderer().drawStringWithShadow(s, scaledRes.getScaledWidth() - i - 10, 5.0F, 16777215);
       this.mc.profiler.endSection();
    }
 
-   private void renderScoreboard(ScoreObjective var1, ScaledResolution var2) {
-      Scoreboard ☃ = ☃.getScoreboard();
-      Collection<Score> ☃x = ☃.getSortedScores(☃);
-      List<Score> ☃xx = Lists.newArrayList(Iterables.filter(☃x, new Predicate<Score>() {
-         public boolean apply(@Nullable Score var1) {
-            return ☃.getPlayerName() != null && !☃.getPlayerName().startsWith("#");
+   private void renderScoreboard(ScoreObjective objective, ScaledResolution scaledRes) {
+      Scoreboard scoreboard = objective.getScoreboard();
+      Collection<Score> collection = scoreboard.getSortedScores(objective);
+      List<Score> list = Lists.newArrayList(Iterables.filter(collection, new Predicate<Score>() {
+         public boolean apply(@Nullable Score p_apply_1_) {
+            return p_apply_1_.getPlayerName() != null && !p_apply_1_.getPlayerName().startsWith("#");
          }
       }));
-      if (☃xx.size() > 15) {
-         ☃x = Lists.newArrayList(Iterables.skip(☃xx, ☃x.size() - 15));
+      if (list.size() > 15) {
+         collection = Lists.newArrayList(Iterables.skip(list, collection.size() - 15));
       } else {
-         ☃x = ☃xx;
+         collection = list;
       }
 
-      int ☃xxx = this.getFontRenderer().getStringWidth(☃.getDisplayName());
+      int i = this.getFontRenderer().getStringWidth(objective.getDisplayName());
 
-      for (Score ☃xxxx : ☃x) {
-         ScorePlayerTeam ☃xxxxx = ☃.getPlayersTeam(☃xxxx.getPlayerName());
-         String ☃xxxxxx = ScorePlayerTeam.formatPlayerName(☃xxxxx, ☃xxxx.getPlayerName()) + ": " + TextFormatting.RED + ☃xxxx.getScorePoints();
-         ☃xxx = Math.max(☃xxx, this.getFontRenderer().getStringWidth(☃xxxxxx));
+      for (Score score : collection) {
+         ScorePlayerTeam scoreplayerteam = scoreboard.getPlayersTeam(score.getPlayerName());
+         String s = ScorePlayerTeam.formatPlayerName(scoreplayerteam, score.getPlayerName()) + ": " + TextFormatting.RED + score.getScorePoints();
+         i = Math.max(i, this.getFontRenderer().getStringWidth(s));
       }
 
-      int ☃xxxx = ☃x.size() * this.getFontRenderer().FONT_HEIGHT;
-      int ☃xxxxx = ☃.getScaledHeight() / 2 + ☃xxxx / 3;
-      int ☃xxxxxx = 3;
-      int ☃xxxxxxx = ☃.getScaledWidth() - ☃xxx - 3;
-      int ☃xxxxxxxx = 0;
-
-      for (Score ☃xxxxxxxxx : ☃x) {
-         ☃xxxxxxxx++;
-         ScorePlayerTeam ☃xxxxxxxxxx = ☃.getPlayersTeam(☃xxxxxxxxx.getPlayerName());
-         String ☃xxxxxxxxxxx = ScorePlayerTeam.formatPlayerName(☃xxxxxxxxxx, ☃xxxxxxxxx.getPlayerName());
-         String ☃xxxxxxxxxxxx = TextFormatting.RED + "" + ☃xxxxxxxxx.getScorePoints();
-         int ☃xxxxxxxxxxxxx = ☃xxxxx - ☃xxxxxxxx * this.getFontRenderer().FONT_HEIGHT;
-         int ☃xxxxxxxxxxxxxx = ☃.getScaledWidth() - 3 + 2;
-         drawRect(☃xxxxxxx - 2, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxx + this.getFontRenderer().FONT_HEIGHT, 1342177280);
-         this.getFontRenderer().drawString(☃xxxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxxxxxx, 553648127);
-         this.getFontRenderer().drawString(☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxxx - this.getFontRenderer().getStringWidth(☃xxxxxxxxxxxx), ☃xxxxxxxxxxxxx, 553648127);
-         if (☃xxxxxxxx == ☃x.size()) {
-            String ☃xxxxxxxxxxxxxxx = ☃.getDisplayName();
-            drawRect(☃xxxxxxx - 2, ☃xxxxxxxxxxxxx - this.getFontRenderer().FONT_HEIGHT - 1, ☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxx - 1, 1610612736);
-            drawRect(☃xxxxxxx - 2, ☃xxxxxxxxxxxxx - 1, ☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxx, 1342177280);
+      int i1 = collection.size() * this.getFontRenderer().FONT_HEIGHT;
+      int j1 = scaledRes.getScaledHeight() / 2 + i1 / 3;
+      int k1 = 3;
+      int l1 = scaledRes.getScaledWidth() - i - 3;
+      int j = 0;
+
+      for (Score score1 : collection) {
+         j++;
+         ScorePlayerTeam scoreplayerteam1 = scoreboard.getPlayersTeam(score1.getPlayerName());
+         String s1 = ScorePlayerTeam.formatPlayerName(scoreplayerteam1, score1.getPlayerName());
+         String s2 = TextFormatting.RED + "" + score1.getScorePoints();
+         int k = j1 - j * this.getFontRenderer().FONT_HEIGHT;
+         int l = scaledRes.getScaledWidth() - 3 + 2;
+         drawRect(l1 - 2, k, l, k + this.getFontRenderer().FONT_HEIGHT, 1342177280);
+         this.getFontRenderer().drawString(s1, l1, k, 553648127);
+         this.getFontRenderer().drawString(s2, l - this.getFontRenderer().getStringWidth(s2), k, 553648127);
+         if (j == collection.size()) {
+            String s3 = objective.getDisplayName();
+            drawRect(l1 - 2, k - this.getFontRenderer().FONT_HEIGHT - 1, l, k - 1, 1610612736);
+            drawRect(l1 - 2, k - 1, l, k, 1342177280);
             this.getFontRenderer()
-               .drawString(
-                  ☃xxxxxxxxxxxxxxx,
-                  ☃xxxxxxx + ☃xxx / 2 - this.getFontRenderer().getStringWidth(☃xxxxxxxxxxxxxxx) / 2,
-                  ☃xxxxxxxxxxxxx - this.getFontRenderer().FONT_HEIGHT,
-                  553648127
-               );
+               .drawString(s3, l1 + i / 2 - this.getFontRenderer().getStringWidth(s3) / 2, k - this.getFontRenderer().FONT_HEIGHT, 553648127);
          }
       }
    }
 
-   private void renderPlayerStats(ScaledResolution var1) {
+   private void renderPlayerStats(ScaledResolution scaledRes) {
       if (this.mc.getRenderViewEntity() instanceof EntityPlayer) {
-         EntityPlayer ☃ = (EntityPlayer)this.mc.getRenderViewEntity();
-         int ☃x = MathHelper.ceil(☃.getHealth());
-         boolean ☃xx = this.healthUpdateCounter > this.updateCounter && (this.healthUpdateCounter - this.updateCounter) / 3L % 2L == 1L;
-         if (☃x < this.playerHealth && ☃.hurtResistantTime > 0) {
+         EntityPlayer entityplayer = (EntityPlayer)this.mc.getRenderViewEntity();
+         int i = MathHelper.ceil(entityplayer.getHealth());
+         boolean flag = this.healthUpdateCounter > this.updateCounter && (this.healthUpdateCounter - this.updateCounter) / 3L % 2L == 1L;
+         if (i < this.playerHealth && entityplayer.hurtResistantTime > 0) {
             this.lastSystemTime = Minecraft.getSystemTime();
             this.healthUpdateCounter = this.updateCounter + 20;
-         } else if (☃x > this.playerHealth && ☃.hurtResistantTime > 0) {
+         } else if (i > this.playerHealth && entityplayer.hurtResistantTime > 0) {
             this.lastSystemTime = Minecraft.getSystemTime();
             this.healthUpdateCounter = this.updateCounter + 10;
          }
 
          if (Minecraft.getSystemTime() - this.lastSystemTime > 1000L) {
-            this.playerHealth = ☃x;
-            this.lastPlayerHealth = ☃x;
+            this.playerHealth = i;
+            this.lastPlayerHealth = i;
             this.lastSystemTime = Minecraft.getSystemTime();
          }
 
-         this.playerHealth = ☃x;
-         int ☃xxx = this.lastPlayerHealth;
+         this.playerHealth = i;
+         int j = this.lastPlayerHealth;
          this.rand.setSeed(this.updateCounter * 312871);
-         FoodStats ☃xxxx = ☃.getFoodStats();
-         int ☃xxxxx = ☃xxxx.getFoodLevel();
-         IAttributeInstance ☃xxxxxx = ☃.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH);
-         int ☃xxxxxxx = ☃.getScaledWidth() / 2 - 91;
-         int ☃xxxxxxxx = ☃.getScaledWidth() / 2 + 91;
-         int ☃xxxxxxxxx = ☃.getScaledHeight() - 39;
-         float ☃xxxxxxxxxx = (float)☃xxxxxx.getAttributeValue();
-         int ☃xxxxxxxxxxx = MathHelper.ceil(☃.getAbsorptionAmount());
-         int ☃xxxxxxxxxxxx = MathHelper.ceil((☃xxxxxxxxxx + ☃xxxxxxxxxxx) / 2.0F / 10.0F);
-         int ☃xxxxxxxxxxxxx = Math.max(10 - (☃xxxxxxxxxxxx - 2), 3);
-         int ☃xxxxxxxxxxxxxx = ☃xxxxxxxxx - (☃xxxxxxxxxxxx - 1) * ☃xxxxxxxxxxxxx - 10;
-         int ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxx - 10;
-         int ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx;
-         int ☃xxxxxxxxxxxxxxxxx = ☃.getTotalArmorValue();
-         int ☃xxxxxxxxxxxxxxxxxx = -1;
-         if (☃.isPotionActive(MobEffects.REGENERATION)) {
-            ☃xxxxxxxxxxxxxxxxxx = this.updateCounter % MathHelper.ceil(☃xxxxxxxxxx + 5.0F);
+         FoodStats foodstats = entityplayer.getFoodStats();
+         int k = foodstats.getFoodLevel();
+         IAttributeInstance iattributeinstance = entityplayer.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH);
+         int l = scaledRes.getScaledWidth() / 2 - 91;
+         int i1 = scaledRes.getScaledWidth() / 2 + 91;
+         int j1 = scaledRes.getScaledHeight() - 39;
+         float f = (float)iattributeinstance.getAttributeValue();
+         int k1 = MathHelper.ceil(entityplayer.getAbsorptionAmount());
+         int l1 = MathHelper.ceil((f + k1) / 2.0F / 10.0F);
+         int i2 = Math.max(10 - (l1 - 2), 3);
+         int j2 = j1 - (l1 - 1) * i2 - 10;
+         int k2 = j1 - 10;
+         int l2 = k1;
+         int i3 = entityplayer.getTotalArmorValue();
+         int j3 = -1;
+         if (entityplayer.isPotionActive(MobEffects.REGENERATION)) {
+            j3 = this.updateCounter % MathHelper.ceil(f + 5.0F);
          }
 
          this.mc.profiler.startSection("armor");
 
-         for (int ☃xxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxx < 10; ☃xxxxxxxxxxxxxxxxxxx++) {
-            if (☃xxxxxxxxxxxxxxxxx > 0) {
-               int ☃xxxxxxxxxxxxxxxxxxxx = ☃xxxxxxx + ☃xxxxxxxxxxxxxxxxxxx * 8;
-               if (☃xxxxxxxxxxxxxxxxxxx * 2 + 1 < ☃xxxxxxxxxxxxxxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx, 34, 9, 9, 9);
+         for (int k3 = 0; k3 < 10; k3++) {
+            if (i3 > 0) {
+               int l3 = l + k3 * 8;
+               if (k3 * 2 + 1 < i3) {
+                  this.drawTexturedModalRect(l3, j2, 34, 9, 9, 9);
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxx * 2 + 1 == ☃xxxxxxxxxxxxxxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx, 25, 9, 9, 9);
+               if (k3 * 2 + 1 == i3) {
+                  this.drawTexturedModalRect(l3, j2, 25, 9, 9, 9);
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxx * 2 + 1 > ☃xxxxxxxxxxxxxxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx, 16, 9, 9, 9);
+               if (k3 * 2 + 1 > i3) {
+                  this.drawTexturedModalRect(l3, j2, 16, 9, 9, 9);
                }
             }
          }
 
          this.mc.profiler.endStartSection("health");
 
-         for (int ☃xxxxxxxxxxxxxxxxxxxxx = MathHelper.ceil((☃xxxxxxxxxx + ☃xxxxxxxxxxx) / 2.0F) - 1; ☃xxxxxxxxxxxxxxxxxxxxx >= 0; ☃xxxxxxxxxxxxxxxxxxxxx--) {
-            int ☃xxxxxxxxxxxxxxxxxxxxxx = 16;
-            if (☃.isPotionActive(MobEffects.POISON)) {
-               ☃xxxxxxxxxxxxxxxxxxxxxx += 36;
-            } else if (☃.isPotionActive(MobEffects.WITHER)) {
-               ☃xxxxxxxxxxxxxxxxxxxxxx += 72;
+         for (int j5 = MathHelper.ceil((f + k1) / 2.0F) - 1; j5 >= 0; j5--) {
+            int k5 = 16;
+            if (entityplayer.isPotionActive(MobEffects.POISON)) {
+               k5 += 36;
+            } else if (entityplayer.isPotionActive(MobEffects.WITHER)) {
+               k5 += 72;
             }
 
-            int ☃xxxxxxxxxxxxxxxxxxxxxxx = 0;
-            if (☃xx) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxx = 1;
+            int i4 = 0;
+            if (flag) {
+               i4 = 1;
             }
 
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.ceil((☃xxxxxxxxxxxxxxxxxxxxx + 1) / 10.0F) - 1;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx % 10 * 8;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxx;
-            if (☃x <= 4) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxx += this.rand.nextInt(2);
+            int j4 = MathHelper.ceil((j5 + 1) / 10.0F) - 1;
+            int k4 = l + j5 % 10 * 8;
+            int l4 = j1 - j4 * i2;
+            if (i <= 4) {
+               l4 += this.rand.nextInt(2);
             }
 
-            if (☃xxxxxxxxxxxxxxxx <= 0 && ☃xxxxxxxxxxxxxxxxxxxxx == ☃xxxxxxxxxxxxxxxxxx) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxx -= 2;
+            if (l2 <= 0 && j5 == j3) {
+               l4 -= 2;
             }
 
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = 0;
-            if (☃.world.getWorldInfo().isHardcoreModeEnabled()) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = 5;
+            int i5 = 0;
+            if (entityplayer.world.getWorldInfo().isHardcoreModeEnabled()) {
+               i5 = 5;
             }
 
-            this.drawTexturedModalRect(
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, 16 + ☃xxxxxxxxxxxxxxxxxxxxxxx * 9, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-            );
-            if (☃xx) {
-               if (☃xxxxxxxxxxxxxxxxxxxxx * 2 + 1 < ☃xxx) {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 54, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
+            this.drawTexturedModalRect(k4, l4, 16 + i4 * 9, 9 * i5, 9, 9);
+            if (flag) {
+               if (j5 * 2 + 1 < j) {
+                  this.drawTexturedModalRect(k4, l4, k5 + 54, 9 * i5, 9, 9);
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxx * 2 + 1 == ☃xxx) {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 63, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
+               if (j5 * 2 + 1 == j) {
+                  this.drawTexturedModalRect(k4, l4, k5 + 63, 9 * i5, 9, 9);
                }
             }
 
-            if (☃xxxxxxxxxxxxxxxx > 0) {
-               if (☃xxxxxxxxxxxxxxxx == ☃xxxxxxxxxxx && ☃xxxxxxxxxxx % 2 == 1) {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 153, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
-                  ☃xxxxxxxxxxxxxxxx--;
+            if (l2 > 0) {
+               if (l2 == k1 && k1 % 2 == 1) {
+                  this.drawTexturedModalRect(k4, l4, k5 + 153, 9 * i5, 9, 9);
+                  l2--;
                } else {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 144, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
-                  ☃xxxxxxxxxxxxxxxx -= 2;
+                  this.drawTexturedModalRect(k4, l4, k5 + 144, 9 * i5, 9, 9);
+                  l2 -= 2;
                }
             } else {
-               if (☃xxxxxxxxxxxxxxxxxxxxx * 2 + 1 < ☃x) {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 36, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
+               if (j5 * 2 + 1 < i) {
+                  this.drawTexturedModalRect(k4, l4, k5 + 36, 9 * i5, 9, 9);
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxx * 2 + 1 == ☃x) {
-                  this.drawTexturedModalRect(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 45, 9 * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, 9, 9
-                  );
+               if (j5 * 2 + 1 == i) {
+                  this.drawTexturedModalRect(k4, l4, k5 + 45, 9 * i5, 9, 9);
                }
             }
          }
 
-         Entity ☃xxxxxxxxxxxxxxxxxxxxx = ☃.getRidingEntity();
-         if (☃xxxxxxxxxxxxxxxxxxxxx == null || !(☃xxxxxxxxxxxxxxxxxxxxx instanceof EntityLivingBase)) {
+         Entity entity = entityplayer.getRidingEntity();
+         if (entity == null || !(entity instanceof EntityLivingBase)) {
             this.mc.profiler.endStartSection("food");
 
-            for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx < 10; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxx;
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 16;
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0;
-               if (☃.isPotionActive(MobEffects.HUNGER)) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx += 36;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 13;
+            for (int l5 = 0; l5 < 10; l5++) {
+               int j6 = j1;
+               int l6 = 16;
+               int j7 = 0;
+               if (entityplayer.isPotionActive(MobEffects.HUNGER)) {
+                  l6 += 36;
+                  j7 = 13;
                }
 
-               if (☃.getFoodStats().getSaturationLevel() <= 0.0F && this.updateCounter % (☃xxxxx * 3 + 1) == 0) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxx + (this.rand.nextInt(3) - 1);
+               if (entityplayer.getFoodStats().getSaturationLevel() <= 0.0F && this.updateCounter % (k * 3 + 1) == 0) {
+                  j6 = j1 + (this.rand.nextInt(3) - 1);
                }
 
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx * 8 - 9;
-               this.drawTexturedModalRect(
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 16 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * 9, 27, 9, 9
-               );
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx * 2 + 1 < ☃xxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 36, 27, 9, 9);
+               int l7 = i1 - l5 * 8 - 9;
+               this.drawTexturedModalRect(l7, j6, 16 + j7 * 9, 27, 9, 9);
+               if (l5 * 2 + 1 < k) {
+                  this.drawTexturedModalRect(l7, j6, l6 + 36, 27, 9, 9);
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx * 2 + 1 == ☃xxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 45, 27, 9, 9);
+               if (l5 * 2 + 1 == k) {
+                  this.drawTexturedModalRect(l7, j6, l6 + 45, 27, 9, 9);
                }
             }
          }
 
          this.mc.profiler.endStartSection("air");
-         if (☃.isInsideOfMaterial(Material.WATER)) {
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.mc.player.getAir();
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.ceil((☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx - 2) * 10.0 / 300.0);
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.ceil(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx * 10.0 / 300.0) - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-
-            for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++
-            ) {
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) {
-                  this.drawTexturedModalRect(☃xxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * 8 - 9, ☃xxxxxxxxxxxxxxx, 16, 18, 9, 9);
+         if (entityplayer.isInsideOfMaterial(Material.WATER)) {
+            int i6 = this.mc.player.getAir();
+            int k6 = MathHelper.ceil((i6 - 2) * 10.0 / 300.0);
+            int i7 = MathHelper.ceil(i6 * 10.0 / 300.0) - k6;
+
+            for (int k7 = 0; k7 < k6 + i7; k7++) {
+               if (k7 < k6) {
+                  this.drawTexturedModalRect(i1 - k7 * 8 - 9, k2, 16, 18, 9, 9);
                } else {
-                  this.drawTexturedModalRect(☃xxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * 8 - 9, ☃xxxxxxxxxxxxxxx, 25, 18, 9, 9);
+                  this.drawTexturedModalRect(i1 - k7 * 8 - 9, k2, 25, 18, 9, 9);
                }
             }
          }
@@ -834,50 +846,50 @@ private void renderPlayerStats(ScaledResolution var1) {
       }
    }
 
-   private void renderMountHealth(ScaledResolution var1) {
+   private void renderMountHealth(ScaledResolution p_184047_1_) {
       if (this.mc.getRenderViewEntity() instanceof EntityPlayer) {
-         EntityPlayer ☃ = (EntityPlayer)this.mc.getRenderViewEntity();
-         Entity ☃x = ☃.getRidingEntity();
-         if (☃x instanceof EntityLivingBase) {
+         EntityPlayer entityplayer = (EntityPlayer)this.mc.getRenderViewEntity();
+         Entity entity = entityplayer.getRidingEntity();
+         if (entity instanceof EntityLivingBase) {
             this.mc.profiler.endStartSection("mountHealth");
-            EntityLivingBase ☃xx = (EntityLivingBase)☃x;
-            int ☃xxx = (int)Math.ceil(☃xx.getHealth());
-            float ☃xxxx = ☃xx.getMaxHealth();
-            int ☃xxxxx = (int)(☃xxxx + 0.5F) / 2;
-            if (☃xxxxx > 30) {
-               ☃xxxxx = 30;
+            EntityLivingBase entitylivingbase = (EntityLivingBase)entity;
+            int i = (int)Math.ceil(entitylivingbase.getHealth());
+            float f = entitylivingbase.getMaxHealth();
+            int j = (int)(f + 0.5F) / 2;
+            if (j > 30) {
+               j = 30;
             }
 
-            int ☃xxxxxx = ☃.getScaledHeight() - 39;
-            int ☃xxxxxxx = ☃.getScaledWidth() / 2 + 91;
-            int ☃xxxxxxxx = ☃xxxxxx;
-            int ☃xxxxxxxxx = 0;
-
-            for (boolean ☃xxxxxxxxxx = false; ☃xxxxx > 0; ☃xxxxxxxxx += 20) {
-               int ☃xxxxxxxxxxx = Math.min(☃xxxxx, 10);
-               ☃xxxxx -= ☃xxxxxxxxxxx;
-
-               for (int ☃xxxxxxxxxxxx = 0; ☃xxxxxxxxxxxx < ☃xxxxxxxxxxx; ☃xxxxxxxxxxxx++) {
-                  int ☃xxxxxxxxxxxxx = 52;
-                  int ☃xxxxxxxxxxxxxx = 0;
-                  int ☃xxxxxxxxxxxxxxx = ☃xxxxxxx - ☃xxxxxxxxxxxx * 8 - 9;
-                  this.drawTexturedModalRect(☃xxxxxxxxxxxxxxx, ☃xxxxxxxx, 52 + ☃xxxxxxxxxxxxxx * 9, 9, 9, 9);
-                  if (☃xxxxxxxxxxxx * 2 + 1 + ☃xxxxxxxxx < ☃xxx) {
-                     this.drawTexturedModalRect(☃xxxxxxxxxxxxxxx, ☃xxxxxxxx, 88, 9, 9, 9);
+            int k = p_184047_1_.getScaledHeight() - 39;
+            int l = p_184047_1_.getScaledWidth() / 2 + 91;
+            int i1 = k;
+            int j1 = 0;
+
+            for (boolean flag = false; j > 0; j1 += 20) {
+               int k1 = Math.min(j, 10);
+               j -= k1;
+
+               for (int l1 = 0; l1 < k1; l1++) {
+                  int i2 = 52;
+                  int j2 = 0;
+                  int k2 = l - l1 * 8 - 9;
+                  this.drawTexturedModalRect(k2, i1, 52 + j2 * 9, 9, 9, 9);
+                  if (l1 * 2 + 1 + j1 < i) {
+                     this.drawTexturedModalRect(k2, i1, 88, 9, 9, 9);
                   }
 
-                  if (☃xxxxxxxxxxxx * 2 + 1 + ☃xxxxxxxxx == ☃xxx) {
-                     this.drawTexturedModalRect(☃xxxxxxxxxxxxxxx, ☃xxxxxxxx, 97, 9, 9, 9);
+                  if (l1 * 2 + 1 + j1 == i) {
+                     this.drawTexturedModalRect(k2, i1, 97, 9, 9, 9);
                   }
                }
 
-               ☃xxxxxxxx -= 10;
+               i1 -= 10;
             }
          }
       }
    }
 
-   private void renderPumpkinOverlay(ScaledResolution var1) {
+   private void renderPumpkinOverlay(ScaledResolution scaledRes) {
       GlStateManager.disableDepth();
       GlStateManager.depthMask(false);
       GlStateManager.tryBlendFuncSeparate(
@@ -886,67 +898,82 @@ private void renderPumpkinOverlay(ScaledResolution var1) {
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.disableAlpha();
       this.mc.getTextureManager().bindTexture(PUMPKIN_BLUR_TEX_PATH);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃x.pos(0.0, ☃.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
-      ☃x.pos(☃.getScaledWidth(), ☃.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
-      ☃x.pos(☃.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
-      ☃x.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
-      ☃.draw();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+      bufferbuilder.pos(0.0, scaledRes.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
+      bufferbuilder.pos(scaledRes.getScaledWidth(), scaledRes.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
+      bufferbuilder.pos(scaledRes.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
+      bufferbuilder.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
+      tessellator.draw();
       GlStateManager.depthMask(true);
       GlStateManager.enableDepth();
       GlStateManager.enableAlpha();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
 
-   private void renderVignette(float var1, ScaledResolution var2) {
-      ☃ = 1.0F - ☃;
-      ☃ = MathHelper.clamp(☃, 0.0F, 1.0F);
-      WorldBorder ☃ = this.mc.world.getWorldBorder();
-      float ☃x = (float)☃.getClosestDistance(this.mc.player);
-      double ☃xx = Math.min(☃.getResizeSpeed() * ☃.getWarningTime() * 1000.0, Math.abs(☃.getTargetSize() - ☃.getDiameter()));
-      double ☃xxx = Math.max((double)☃.getWarningDistance(), ☃xx);
-      if (☃x < ☃xxx) {
-         ☃x = 1.0F - (float)(☃x / ☃xxx);
+   private void renderVignette(float lightLevel, ScaledResolution scaledRes) {
+      if (!Config.isVignetteEnabled()) {
+         GlStateManager.enableDepth();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
       } else {
-         ☃x = 0.0F;
-      }
+         lightLevel = 1.0F - lightLevel;
+         lightLevel = MathHelper.clamp(lightLevel, 0.0F, 1.0F);
+         WorldBorder worldborder = this.mc.world.getWorldBorder();
+         float f = (float)worldborder.getClosestDistance(this.mc.player);
+         double d0 = Math.min(
+            worldborder.getResizeSpeed() * worldborder.getWarningTime() * 1000.0, Math.abs(worldborder.getTargetSize() - worldborder.getDiameter())
+         );
+         double d1 = Math.max((double)worldborder.getWarningDistance(), d0);
+         if (f < d1) {
+            f = 1.0F - (float)(f / d1);
+         } else {
+            f = 0.0F;
+         }
 
-      this.prevVignetteBrightness = (float)(this.prevVignetteBrightness + (☃ - this.prevVignetteBrightness) * 0.01);
-      GlStateManager.disableDepth();
-      GlStateManager.depthMask(false);
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      if (☃x > 0.0F) {
-         GlStateManager.color(0.0F, ☃x, ☃x, 1.0F);
-      } else {
-         GlStateManager.color(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
-      }
+         this.prevVignetteBrightness = (float)(this.prevVignetteBrightness + (lightLevel - this.prevVignetteBrightness) * 0.01);
+         GlStateManager.disableDepth();
+         GlStateManager.depthMask(false);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
+         );
+         if (f > 0.0F) {
+            GlStateManager.color(0.0F, f, f, 1.0F);
+         } else {
+            GlStateManager.color(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
+         }
 
-      this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
-      Tessellator ☃xxxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxxx = ☃xxxx.getBuffer();
-      ☃xxxxx.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃xxxxx.pos(0.0, ☃.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
-      ☃xxxxx.pos(☃.getScaledWidth(), ☃.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
-      ☃xxxxx.pos(☃.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
-      ☃xxxxx.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
-      ☃xxxx.draw();
-      GlStateManager.depthMask(true);
-      GlStateManager.enableDepth();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
+         this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+         bufferbuilder.pos(0.0, scaledRes.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
+         bufferbuilder.pos(scaledRes.getScaledWidth(), scaledRes.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
+         bufferbuilder.pos(scaledRes.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
+         bufferbuilder.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
+         tessellator.draw();
+         GlStateManager.depthMask(true);
+         GlStateManager.enableDepth();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+      }
    }
 
-   private void renderPortal(float var1, ScaledResolution var2) {
-      if (☃ < 1.0F) {
-         ☃ *= ☃;
-         ☃ *= ☃;
-         ☃ = ☃ * 0.8F + 0.2F;
+   private void renderPortal(float timeInPortal, ScaledResolution scaledRes) {
+      if (timeInPortal < 1.0F) {
+         timeInPortal *= timeInPortal;
+         timeInPortal *= timeInPortal;
+         timeInPortal = timeInPortal * 0.8F + 0.2F;
       }
 
       GlStateManager.disableAlpha();
@@ -955,48 +982,52 @@ private void renderPortal(float var1, ScaledResolution var2) {
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      GlStateManager.color(1.0F, 1.0F, 1.0F, ☃);
+      GlStateManager.color(1.0F, 1.0F, 1.0F, timeInPortal);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-      TextureAtlasSprite ☃ = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.getDefaultState());
-      float ☃x = ☃.getMinU();
-      float ☃xx = ☃.getMinV();
-      float ☃xxx = ☃.getMaxU();
-      float ☃xxxx = ☃.getMaxV();
-      Tessellator ☃xxxxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxxxx = ☃xxxxx.getBuffer();
-      ☃xxxxxx.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃xxxxxx.pos(0.0, ☃.getScaledHeight(), -90.0).tex(☃x, ☃xxxx).endVertex();
-      ☃xxxxxx.pos(☃.getScaledWidth(), ☃.getScaledHeight(), -90.0).tex(☃xxx, ☃xxxx).endVertex();
-      ☃xxxxxx.pos(☃.getScaledWidth(), 0.0, -90.0).tex(☃xxx, ☃xx).endVertex();
-      ☃xxxxxx.pos(0.0, 0.0, -90.0).tex(☃x, ☃xx).endVertex();
-      ☃xxxxx.draw();
+      TextureAtlasSprite textureatlassprite = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.t());
+      float f = textureatlassprite.getMinU();
+      float f1 = textureatlassprite.getMinV();
+      float f2 = textureatlassprite.getMaxU();
+      float f3 = textureatlassprite.getMaxV();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+      bufferbuilder.pos(0.0, scaledRes.getScaledHeight(), -90.0).tex(f, f3).endVertex();
+      bufferbuilder.pos(scaledRes.getScaledWidth(), scaledRes.getScaledHeight(), -90.0).tex(f2, f3).endVertex();
+      bufferbuilder.pos(scaledRes.getScaledWidth(), 0.0, -90.0).tex(f2, f1).endVertex();
+      bufferbuilder.pos(0.0, 0.0, -90.0).tex(f, f1).endVertex();
+      tessellator.draw();
       GlStateManager.depthMask(true);
       GlStateManager.enableDepth();
       GlStateManager.enableAlpha();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
 
-   private void renderHotbarItem(int var1, int var2, float var3, EntityPlayer var4, ItemStack var5) {
-      if (!☃.isEmpty()) {
-         float ☃ = ☃.getAnimationsToGo() - ☃;
-         if (☃ > 0.0F) {
+   private void renderHotbarItem(int p_184044_1_, int p_184044_2_, float p_184044_3_, EntityPlayer player, ItemStack stack) {
+      if (!stack.isEmpty()) {
+         float f = stack.getAnimationsToGo() - p_184044_3_;
+         if (f > 0.0F) {
             GlStateManager.pushMatrix();
-            float ☃x = 1.0F + ☃ / 5.0F;
-            GlStateManager.translate((float)(☃ + 8), (float)(☃ + 12), 0.0F);
-            GlStateManager.scale(1.0F / ☃x, (☃x + 1.0F) / 2.0F, 1.0F);
-            GlStateManager.translate((float)(-(☃ + 8)), (float)(-(☃ + 12)), 0.0F);
+            float f1 = 1.0F + f / 5.0F;
+            GlStateManager.translate((float)(p_184044_1_ + 8), (float)(p_184044_2_ + 12), 0.0F);
+            GlStateManager.scale(1.0F / f1, (f1 + 1.0F) / 2.0F, 1.0F);
+            GlStateManager.translate((float)(-(p_184044_1_ + 8)), (float)(-(p_184044_2_ + 12)), 0.0F);
          }
 
-         this.itemRenderer.renderItemAndEffectIntoGUI(☃, ☃, ☃, ☃);
-         if (☃ > 0.0F) {
+         this.itemRenderer.renderItemAndEffectIntoGUI(player, stack, p_184044_1_, p_184044_2_);
+         if (f > 0.0F) {
             GlStateManager.popMatrix();
          }
 
-         this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, ☃, ☃, ☃);
+         this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, stack, p_184044_1_, p_184044_2_);
       }
    }
 
    public void updateTick() {
+      if (this.mc.world == null) {
+         TextureAnimations.updateAnimations();
+      }
+
       if (this.overlayMessageTime > 0) {
          this.overlayMessageTime--;
       }
@@ -1011,13 +1042,13 @@ public void updateTick() {
 
       this.updateCounter++;
       if (this.mc.player != null) {
-         ItemStack ☃ = this.mc.player.inventory.getCurrentItem();
-         if (☃.isEmpty()) {
+         ItemStack itemstack = this.mc.player.inventory.getCurrentItem();
+         if (itemstack.isEmpty()) {
             this.remainingHighlightTicks = 0;
          } else if (!this.highlightingItemStack.isEmpty()
-            && ☃.getItem() == this.highlightingItemStack.getItem()
-            && ItemStack.areItemStackTagsEqual(☃, this.highlightingItemStack)
-            && (☃.isItemStackDamageable() || ☃.getMetadata() == this.highlightingItemStack.getMetadata())) {
+            && itemstack.getItem() == this.highlightingItemStack.getItem()
+            && ItemStack.areItemStackTagsEqual(itemstack, this.highlightingItemStack)
+            && (itemstack.isItemStackDamageable() || itemstack.getMetadata() == this.highlightingItemStack.getMetadata())) {
             if (this.remainingHighlightTicks > 0) {
                this.remainingHighlightTicks--;
             }
@@ -1025,41 +1056,41 @@ public void updateTick() {
             this.remainingHighlightTicks = 40;
          }
 
-         this.highlightingItemStack = ☃;
+         this.highlightingItemStack = itemstack;
       }
    }
 
-   public void setRecordPlayingMessage(String var1) {
-      this.setOverlayMessage(I18n.format("record.nowPlaying", ☃), true);
+   public void setRecordPlayingMessage(String recordName) {
+      this.setOverlayMessage(I18n.format("record.nowPlaying", recordName), true);
    }
 
-   public void setOverlayMessage(String var1, boolean var2) {
-      this.overlayMessage = ☃;
+   public void setOverlayMessage(String message, boolean animateColor) {
+      this.overlayMessage = message;
       this.overlayMessageTime = 60;
-      this.animateOverlayMessageColor = ☃;
+      this.animateOverlayMessageColor = animateColor;
    }
 
-   public void displayTitle(String var1, String var2, int var3, int var4, int var5) {
-      if (☃ == null && ☃ == null && ☃ < 0 && ☃ < 0 && ☃ < 0) {
+   public void displayTitle(String title, String subTitle, int timeFadeIn, int displayTime, int timeFadeOut) {
+      if (title == null && subTitle == null && timeFadeIn < 0 && displayTime < 0 && timeFadeOut < 0) {
          this.displayedTitle = "";
          this.displayedSubTitle = "";
          this.titlesTimer = 0;
-      } else if (☃ != null) {
-         this.displayedTitle = ☃;
+      } else if (title != null) {
+         this.displayedTitle = title;
          this.titlesTimer = this.titleFadeIn + this.titleDisplayTime + this.titleFadeOut;
-      } else if (☃ != null) {
-         this.displayedSubTitle = ☃;
+      } else if (subTitle != null) {
+         this.displayedSubTitle = subTitle;
       } else {
-         if (☃ >= 0) {
-            this.titleFadeIn = ☃;
+         if (timeFadeIn >= 0) {
+            this.titleFadeIn = timeFadeIn;
          }
 
-         if (☃ >= 0) {
-            this.titleDisplayTime = ☃;
+         if (displayTime >= 0) {
+            this.titleDisplayTime = displayTime;
          }
 
-         if (☃ >= 0) {
-            this.titleFadeOut = ☃;
+         if (timeFadeOut >= 0) {
+            this.titleFadeOut = timeFadeOut;
          }
 
          if (this.titlesTimer > 0) {
@@ -1068,13 +1099,13 @@ public void displayTitle(String var1, String var2, int var3, int var4, int var5)
       }
    }
 
-   public void setOverlayMessage(ITextComponent var1, boolean var2) {
-      this.setOverlayMessage(☃.getUnformattedText(), ☃);
+   public void setOverlayMessage(ITextComponent component, boolean animateColor) {
+      this.setOverlayMessage(component.getUnformattedText(), animateColor);
    }
 
-   public void addChatMessage(ChatType var1, ITextComponent var2) {
-      for (IChatListener ☃ : this.chatListeners.get(☃)) {
-         ☃.say(☃, ☃);
+   public void addChatMessage(ChatType p_191742_1_, ITextComponent p_191742_2_) {
+      for (IChatListener ichatlistener : this.chatListeners.get(p_191742_1_)) {
+         ichatlistener.say(p_191742_1_, p_191742_2_);
       }
    }
 
diff --git a/patches/net/minecraft/client/gui/GuiMainMenu.java b/patches/net/minecraft/client/gui/GuiMainMenu.java
index af7b4b8..e062cb1 100644
--- a/patches/net/minecraft/client/gui/GuiMainMenu.java
+++ b/patches/net/minecraft/client/gui/GuiMainMenu.java
@@ -1,5 +1,6 @@
 package net.minecraft.client.gui;
 
+import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.Runnables;
 import java.io.BufferedReader;
@@ -29,6 +30,9 @@
 import net.minecraft.world.WorldServerDemo;
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.CustomPanorama;
+import net.optifine.CustomPanoramaProperties;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -72,32 +76,34 @@ public class GuiMainMenu extends GuiScreen {
    private GuiScreen realmsNotification;
    private int widthCopyright;
    private int widthCopyrightRest;
+   private GuiButton modButton;
+   private GuiScreen modUpdateNotification;
 
    public GuiMainMenu() {
       this.splashText = "missingno";
-      IResource ☃ = null;
+      IResource iresource = null;
 
       try {
-         List<String> ☃x = Lists.newArrayList();
-         ☃ = Minecraft.getMinecraft().getResourceManager().getResource(SPLASH_TEXTS);
-         BufferedReader ☃xx = new BufferedReader(new InputStreamReader(☃.getInputStream(), StandardCharsets.UTF_8));
-
-         String ☃xxx;
-         while ((☃xxx = ☃xx.readLine()) != null) {
-            ☃xxx = ☃xxx.trim();
-            if (!☃xxx.isEmpty()) {
-               ☃x.add(☃xxx);
+         List<String> list = Lists.newArrayList();
+         iresource = Minecraft.getMinecraft().getResourceManager().getResource(SPLASH_TEXTS);
+         BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(iresource.getInputStream(), StandardCharsets.UTF_8));
+
+         String s;
+         while ((s = bufferedreader.readLine()) != null) {
+            s = s.trim();
+            if (!s.isEmpty()) {
+               list.add(s);
             }
          }
 
-         if (!☃x.isEmpty()) {
+         if (!list.isEmpty()) {
             do {
-               this.splashText = ☃x.get(RANDOM.nextInt(☃x.size()));
+               this.splashText = list.get(RANDOM.nextInt(list.size()));
             } while (this.splashText.hashCode() == 125780783);
          }
       } catch (IOException var8) {
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(iresource);
       }
 
       this.minceraftRoll = RANDOM.nextFloat();
@@ -113,63 +119,59 @@ private boolean areRealmsNotificationsEnabled() {
       return Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && this.realmsNotification != null;
    }
 
-   @Override
    public void updateScreen() {
       if (this.areRealmsNotificationsEnabled()) {
          this.realmsNotification.updateScreen();
       }
    }
 
-   @Override
    public boolean doesGuiPauseGame() {
       return false;
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
+   protected void keyTyped(char typedChar, int keyCode) throws IOException {
    }
 
-   @Override
    public void initGui() {
       this.viewportTexture = new DynamicTexture(256, 256);
       this.backgroundTexture = this.mc.getTextureManager().getDynamicTextureLocation("background", this.viewportTexture);
       this.widthCopyright = this.fontRenderer.getStringWidth("Copyright Mojang AB. Do not distribute!");
       this.widthCopyrightRest = this.width - this.widthCopyright - 2;
-      Calendar ☃ = Calendar.getInstance();
-      ☃.setTime(new Date());
-      if (☃.get(2) + 1 == 12 && ☃.get(5) == 24) {
+      Calendar calendar = Calendar.getInstance();
+      calendar.setTime(new Date());
+      if (calendar.get(2) + 1 == 12 && calendar.get(5) == 24) {
          this.splashText = "Merry X-mas!";
-      } else if (☃.get(2) + 1 == 1 && ☃.get(5) == 1) {
+      } else if (calendar.get(2) + 1 == 1 && calendar.get(5) == 1) {
          this.splashText = "Happy new year!";
-      } else if (☃.get(2) + 1 == 10 && ☃.get(5) == 31) {
+      } else if (calendar.get(2) + 1 == 10 && calendar.get(5) == 31) {
          this.splashText = "OOoooOOOoooo! Spooky!";
       }
 
-      int ☃x = 24;
-      int ☃xx = this.height / 4 + 48;
+      int i = 24;
+      int j = this.height / 4 + 48;
       if (this.mc.isDemo()) {
-         this.addDemoButtons(☃xx, 24);
+         this.addDemoButtons(j, 24);
       } else {
-         this.addSingleplayerMultiplayerButtons(☃xx, 24);
+         this.addSingleplayerMultiplayerButtons(j, 24);
       }
 
-      this.buttonList.add(new GuiButton(0, this.width / 2 - 100, ☃xx + 72 + 12, 98, 20, I18n.format("menu.options")));
-      this.buttonList.add(new GuiButton(4, this.width / 2 + 2, ☃xx + 72 + 12, 98, 20, I18n.format("menu.quit")));
-      this.buttonList.add(new GuiButtonLanguage(5, this.width / 2 - 124, ☃xx + 72 + 12));
+      this.buttonList.add(new GuiButton(0, this.width / 2 - 100, j + 72 + 12, 98, 20, I18n.format("menu.options")));
+      this.buttonList.add(new GuiButton(4, this.width / 2 + 2, j + 72 + 12, 98, 20, I18n.format("menu.quit")));
+      this.buttonList.add(new GuiButtonLanguage(5, this.width / 2 - 124, j + 72 + 12));
       synchronized (this.threadLock) {
          this.openGLWarning1Width = this.fontRenderer.getStringWidth(this.openGLWarning1);
          this.openGLWarning2Width = this.fontRenderer.getStringWidth(this.openGLWarning2);
-         int ☃xxx = Math.max(this.openGLWarning1Width, this.openGLWarning2Width);
-         this.openGLWarningX1 = (this.width - ☃xxx) / 2;
-         this.openGLWarningY1 = this.buttonList.get(0).y - 24;
-         this.openGLWarningX2 = this.openGLWarningX1 + ☃xxx;
+         int k = Math.max(this.openGLWarning1Width, this.openGLWarning2Width);
+         this.openGLWarningX1 = (this.width - k) / 2;
+         this.openGLWarningY1 = ((GuiButton)this.buttonList.get(0)).y - 24;
+         this.openGLWarningX2 = this.openGLWarningX1 + k;
          this.openGLWarningY2 = this.openGLWarningY1 + 24;
       }
 
       this.mc.setConnectedToRealms(false);
       if (Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && !this.hasCheckedForRealmsNotification) {
-         RealmsBridge ☃xxx = new RealmsBridge();
-         this.realmsNotification = ☃xxx.getNotificationScreen(this);
+         RealmsBridge realmsbridge = new RealmsBridge();
+         this.realmsNotification = realmsbridge.getNotificationScreen(this);
          this.hasCheckedForRealmsNotification = true;
       }
 
@@ -177,64 +179,78 @@ public void initGui() {
          this.realmsNotification.setGuiSize(this.width, this.height);
          this.realmsNotification.initGui();
       }
+
+      if (Reflector.NotificationModUpdateScreen_init.exists()) {
+         this.modUpdateNotification = (GuiScreen)Reflector.call(Reflector.NotificationModUpdateScreen_init, new Object[]{this, this.modButton});
+      }
    }
 
-   private void addSingleplayerMultiplayerButtons(int var1, int var2) {
-      this.buttonList.add(new GuiButton(1, this.width / 2 - 100, ☃, I18n.format("menu.singleplayer")));
-      this.buttonList.add(new GuiButton(2, this.width / 2 - 100, ☃ + ☃ * 1, I18n.format("menu.multiplayer")));
-      this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 - 100, ☃ + ☃ * 2, I18n.format("menu.online")));
+   private void addSingleplayerMultiplayerButtons(int p_73969_1_, int p_73969_2_) {
+      this.buttonList.add(new GuiButton(1, this.width / 2 - 100, p_73969_1_, I18n.format("menu.singleplayer")));
+      this.buttonList.add(new GuiButton(2, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 1, I18n.format("menu.multiplayer")));
+      if (Reflector.GuiModList_Constructor.exists()) {
+         this.realmsButton = this.addButton(
+            new GuiButton(14, this.width / 2 + 2, p_73969_1_ + p_73969_2_ * 2, 98, 20, I18n.format("menu.online").replace("Minecraft", "").trim())
+         );
+         this.buttonList.add(this.modButton = new GuiButton(6, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 2, 98, 20, I18n.format("fml.menu.mods")));
+      } else {
+         this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 - 100, p_73969_1_ + p_73969_2_ * 2, I18n.format("menu.online")));
+      }
    }
 
-   private void addDemoButtons(int var1, int var2) {
-      this.buttonList.add(new GuiButton(11, this.width / 2 - 100, ☃, I18n.format("menu.playdemo")));
-      this.buttonResetDemo = this.addButton(new GuiButton(12, this.width / 2 - 100, ☃ + ☃ * 1, I18n.format("menu.resetdemo")));
-      ISaveFormat ☃ = this.mc.getSaveLoader();
-      WorldInfo ☃x = ☃.getWorldInfo("Demo_World");
-      if (☃x == null) {
+   private void addDemoButtons(int p_73972_1_, int p_73972_2_) {
+      this.buttonList.add(new GuiButton(11, this.width / 2 - 100, p_73972_1_, I18n.format("menu.playdemo")));
+      this.buttonResetDemo = this.addButton(new GuiButton(12, this.width / 2 - 100, p_73972_1_ + p_73972_2_ * 1, I18n.format("menu.resetdemo")));
+      ISaveFormat isaveformat = this.mc.getSaveLoader();
+      WorldInfo worldinfo = isaveformat.getWorldInfo("Demo_World");
+      if (worldinfo == null) {
          this.buttonResetDemo.enabled = false;
       }
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
-      if (☃.id == 0) {
+   protected void actionPerformed(GuiButton button) throws IOException {
+      if (button.id == 0) {
          this.mc.displayGuiScreen(new GuiOptions(this, this.mc.gameSettings));
       }
 
-      if (☃.id == 5) {
+      if (button.id == 5) {
          this.mc.displayGuiScreen(new GuiLanguage(this, this.mc.gameSettings, this.mc.getLanguageManager()));
       }
 
-      if (☃.id == 1) {
+      if (button.id == 1) {
          this.mc.displayGuiScreen(new GuiWorldSelection(this));
       }
 
-      if (☃.id == 2) {
+      if (button.id == 2) {
          this.mc.displayGuiScreen(new GuiMultiplayer(this));
       }
 
-      if (☃.id == 14 && this.realmsButton.visible) {
+      if (button.id == 14 && this.realmsButton.visible) {
          this.switchToRealms();
       }
 
-      if (☃.id == 4) {
+      if (button.id == 4) {
          this.mc.shutdown();
       }
 
-      if (☃.id == 11) {
+      if (button.id == 6 && Reflector.GuiModList_Constructor.exists()) {
+         this.mc.displayGuiScreen((GuiScreen)Reflector.newInstance(Reflector.GuiModList_Constructor, new Object[]{this}));
+      }
+
+      if (button.id == 11) {
          this.mc.launchIntegratedServer("Demo_World", "Demo_World", WorldServerDemo.DEMO_WORLD_SETTINGS);
       }
 
-      if (☃.id == 12) {
-         ISaveFormat ☃ = this.mc.getSaveLoader();
-         WorldInfo ☃x = ☃.getWorldInfo("Demo_World");
-         if (☃x != null) {
+      if (button.id == 12) {
+         ISaveFormat isaveformat = this.mc.getSaveLoader();
+         WorldInfo worldinfo = isaveformat.getWorldInfo("Demo_World");
+         if (worldinfo != null) {
             this.mc
                .displayGuiScreen(
                   new GuiYesNo(
                      this,
                      I18n.format("selectWorld.deleteQuestion"),
-                     "'" + ☃x.getWorldName() + "' " + I18n.format("selectWorld.deleteWarning"),
+                     "'" + worldinfo.getWorldName() + "' " + I18n.format("selectWorld.deleteWarning"),
                      I18n.format("selectWorld.deleteButton"),
                      I18n.format("gui.cancel"),
                      12
@@ -245,25 +261,24 @@ protected void actionPerformed(GuiButton var1) {
    }
 
    private void switchToRealms() {
-      RealmsBridge ☃ = new RealmsBridge();
-      ☃.switchToRealms(this);
+      RealmsBridge realmsbridge = new RealmsBridge();
+      realmsbridge.switchToRealms(this);
    }
 
-   @Override
-   public void confirmClicked(boolean var1, int var2) {
-      if (☃ && ☃ == 12) {
-         ISaveFormat ☃ = this.mc.getSaveLoader();
-         ☃.flushCache();
-         ☃.deleteWorldDirectory("Demo_World");
+   public void confirmClicked(boolean result, int id) {
+      if (result && id == 12) {
+         ISaveFormat isaveformat = this.mc.getSaveLoader();
+         isaveformat.flushCache();
+         isaveformat.deleteWorldDirectory("Demo_World");
          this.mc.displayGuiScreen(this);
-      } else if (☃ == 12) {
+      } else if (id == 12) {
          this.mc.displayGuiScreen(this);
-      } else if (☃ == 13) {
-         if (☃) {
+      } else if (id == 13) {
+         if (result) {
             try {
-               Class<?> ☃ = Class.forName("java.awt.Desktop");
-               Object ☃x = ☃.getMethod("getDesktop").invoke(null);
-               ☃.getMethod("browse", URI.class).invoke(☃x, new URI(this.openGLWarningLink));
+               Class<?> oclass = Class.forName("java.awt.Desktop");
+               Object object = oclass.getMethod("getDesktop").invoke(null);
+               oclass.getMethod("browse", URI.class).invoke(object, new URI(this.openGLWarningLink));
             } catch (Throwable var5) {
                LOGGER.error("Couldn't open link", var5);
             }
@@ -273,9 +288,9 @@ public void confirmClicked(boolean var1, int var2) {
       }
    }
 
-   private void drawPanorama(int var1, int var2, float var3) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+   private void drawPanorama(int mouseX, int mouseY, float partialTicks) {
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       GlStateManager.matrixMode(5889);
       GlStateManager.pushMatrix();
       GlStateManager.loadIdentity();
@@ -293,48 +308,58 @@ private void drawPanorama(int var1, int var2, float var3) {
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      int ☃xx = 8;
+      int i = 8;
+      int blurCount1 = 64;
+      CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
+      if (cpp != null) {
+         blurCount1 = cpp.getBlur1();
+      }
 
-      for (int ☃xxx = 0; ☃xxx < 64; ☃xxx++) {
+      for (int j = 0; j < blurCount1; j++) {
          GlStateManager.pushMatrix();
-         float ☃xxxx = (☃xxx % 8 / 8.0F - 0.5F) / 64.0F;
-         float ☃xxxxx = (☃xxx / 8 / 8.0F - 0.5F) / 64.0F;
-         float ☃xxxxxx = 0.0F;
-         GlStateManager.translate(☃xxxx, ☃xxxxx, 0.0F);
+         float f = (j % 8 / 8.0F - 0.5F) / 64.0F;
+         float f1 = (j / 8 / 8.0F - 0.5F) / 64.0F;
+         float f2 = 0.0F;
+         GlStateManager.translate(f, f1, 0.0F);
          GlStateManager.rotate(MathHelper.sin(this.panoramaTimer / 400.0F) * 25.0F + 20.0F, 1.0F, 0.0F, 0.0F);
          GlStateManager.rotate(-this.panoramaTimer * 0.1F, 0.0F, 1.0F, 0.0F);
 
-         for (int ☃xxxxxxx = 0; ☃xxxxxxx < 6; ☃xxxxxxx++) {
+         for (int k = 0; k < 6; k++) {
             GlStateManager.pushMatrix();
-            if (☃xxxxxxx == 1) {
+            if (k == 1) {
                GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (☃xxxxxxx == 2) {
+            if (k == 2) {
                GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (☃xxxxxxx == 3) {
+            if (k == 3) {
                GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (☃xxxxxxx == 4) {
+            if (k == 4) {
                GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
             }
 
-            if (☃xxxxxxx == 5) {
+            if (k == 5) {
                GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
             }
 
-            this.mc.getTextureManager().bindTexture(TITLE_PANORAMA_PATHS[☃xxxxxxx]);
-            ☃x.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            int ☃xxxxxxxx = 255 / (☃xxx + 1);
-            float ☃xxxxxxxxx = 0.0F;
-            ☃x.pos(-1.0, -1.0, 1.0).tex(0.0, 0.0).color(255, 255, 255, ☃xxxxxxxx).endVertex();
-            ☃x.pos(1.0, -1.0, 1.0).tex(1.0, 0.0).color(255, 255, 255, ☃xxxxxxxx).endVertex();
-            ☃x.pos(1.0, 1.0, 1.0).tex(1.0, 1.0).color(255, 255, 255, ☃xxxxxxxx).endVertex();
-            ☃x.pos(-1.0, 1.0, 1.0).tex(0.0, 1.0).color(255, 255, 255, ☃xxxxxxxx).endVertex();
-            ☃.draw();
+            ResourceLocation[] panoramaLocations = TITLE_PANORAMA_PATHS;
+            if (cpp != null) {
+               panoramaLocations = cpp.getPanoramaLocations();
+            }
+
+            this.mc.getTextureManager().bindTexture(panoramaLocations[k]);
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            int l = 255 / (j + 1);
+            float f3 = 0.0F;
+            bufferbuilder.pos(-1.0, -1.0, 1.0).tex(0.0, 0.0).color(255, 255, 255, l).endVertex();
+            bufferbuilder.pos(1.0, -1.0, 1.0).tex(1.0, 0.0).color(255, 255, 255, l).endVertex();
+            bufferbuilder.pos(1.0, 1.0, 1.0).tex(1.0, 1.0).color(255, 255, 255, l).endVertex();
+            bufferbuilder.pos(-1.0, 1.0, 1.0).tex(0.0, 1.0).color(255, 255, 255, l).endVertex();
+            tessellator.draw();
             GlStateManager.popMatrix();
          }
 
@@ -342,7 +367,7 @@ private void drawPanorama(int var1, int var2, float var3) {
          GlStateManager.colorMask(true, true, true, false);
       }
 
-      ☃x.setTranslation(0.0, 0.0, 0.0);
+      bufferbuilder.setTranslation(0.0, 0.0, 0.0);
       GlStateManager.colorMask(true, true, true, true);
       GlStateManager.matrixMode(5889);
       GlStateManager.popMatrix();
@@ -363,143 +388,193 @@ private void rotateAndBlurSkybox() {
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.colorMask(true, true, true, false);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
       GlStateManager.disableAlpha();
-      int ☃xx = 3;
+      int i = 3;
+      int blurCount2 = 3;
+      CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
+      if (cpp != null) {
+         blurCount2 = cpp.getBlur2();
+      }
 
-      for (int ☃xxx = 0; ☃xxx < 3; ☃xxx++) {
-         float ☃xxxx = 1.0F / (☃xxx + 1);
-         int ☃xxxxx = this.width;
-         int ☃xxxxxx = this.height;
-         float ☃xxxxxxx = (☃xxx - 1) / 256.0F;
-         ☃x.pos(☃xxxxx, ☃xxxxxx, this.zLevel).tex(0.0F + ☃xxxxxxx, 1.0).color(1.0F, 1.0F, 1.0F, ☃xxxx).endVertex();
-         ☃x.pos(☃xxxxx, 0.0, this.zLevel).tex(1.0F + ☃xxxxxxx, 1.0).color(1.0F, 1.0F, 1.0F, ☃xxxx).endVertex();
-         ☃x.pos(0.0, 0.0, this.zLevel).tex(1.0F + ☃xxxxxxx, 0.0).color(1.0F, 1.0F, 1.0F, ☃xxxx).endVertex();
-         ☃x.pos(0.0, ☃xxxxxx, this.zLevel).tex(0.0F + ☃xxxxxxx, 0.0).color(1.0F, 1.0F, 1.0F, ☃xxxx).endVertex();
+      for (int j = 0; j < blurCount2; j++) {
+         float f = 1.0F / (j + 1);
+         int k = this.width;
+         int l = this.height;
+         float f1 = (j - 1) / 256.0F;
+         bufferbuilder.pos(k, l, this.e).tex(0.0F + f1, 1.0).color(1.0F, 1.0F, 1.0F, f).endVertex();
+         bufferbuilder.pos(k, 0.0, this.e).tex(1.0F + f1, 1.0).color(1.0F, 1.0F, 1.0F, f).endVertex();
+         bufferbuilder.pos(0.0, 0.0, this.e).tex(1.0F + f1, 0.0).color(1.0F, 1.0F, 1.0F, f).endVertex();
+         bufferbuilder.pos(0.0, l, this.e).tex(0.0F + f1, 0.0).color(1.0F, 1.0F, 1.0F, f).endVertex();
       }
 
-      ☃.draw();
+      tessellator.draw();
       GlStateManager.enableAlpha();
       GlStateManager.colorMask(true, true, true, true);
    }
 
-   private void renderSkybox(int var1, int var2, float var3) {
+   private void renderSkybox(int mouseX, int mouseY, float partialTicks) {
       this.mc.getFramebuffer().unbindFramebuffer();
       GlStateManager.viewport(0, 0, 256, 256);
-      this.drawPanorama(☃, ☃, ☃);
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
+      this.drawPanorama(mouseX, mouseY, partialTicks);
       this.rotateAndBlurSkybox();
+      int blurCount3 = 3;
+      CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
+      if (cpp != null) {
+         blurCount3 = cpp.getBlur3();
+      }
+
+      for (int i = 0; i < blurCount3; i++) {
+         this.rotateAndBlurSkybox();
+         this.rotateAndBlurSkybox();
+      }
+
       this.mc.getFramebuffer().bindFramebuffer(true);
       GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-      float ☃ = 120.0F / (this.width > this.height ? this.width : this.height);
-      float ☃x = this.height * ☃ / 256.0F;
-      float ☃xx = this.width * ☃ / 256.0F;
-      int ☃xxx = this.width;
-      int ☃xxxx = this.height;
-      Tessellator ☃xxxxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxxxx = ☃xxxxx.getBuffer();
-      ☃xxxxxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-      ☃xxxxxx.pos(0.0, ☃xxxx, this.zLevel).tex(0.5F - ☃x, 0.5F + ☃xx).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      ☃xxxxxx.pos(☃xxx, ☃xxxx, this.zLevel).tex(0.5F - ☃x, 0.5F - ☃xx).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      ☃xxxxxx.pos(☃xxx, 0.0, this.zLevel).tex(0.5F + ☃x, 0.5F - ☃xx).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      ☃xxxxxx.pos(0.0, 0.0, this.zLevel).tex(0.5F + ☃x, 0.5F + ☃xx).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      ☃xxxxx.draw();
+      float f = 120.0F / (this.width > this.height ? this.width : this.height);
+      float f1 = this.height * f / 256.0F;
+      float f2 = this.width * f / 256.0F;
+      int i = this.width;
+      int j = this.height;
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      bufferbuilder.pos(0.0, j, this.e).tex(0.5F - f1, 0.5F + f2).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      bufferbuilder.pos(i, j, this.e).tex(0.5F - f1, 0.5F - f2).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      bufferbuilder.pos(i, 0.0, this.e).tex(0.5F + f1, 0.5F - f2).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      bufferbuilder.pos(0.0, 0.0, this.e).tex(0.5F + f1, 0.5F + f2).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      tessellator.draw();
    }
 
-   @Override
-   public void drawScreen(int var1, int var2, float var3) {
-      this.panoramaTimer += ☃;
+   public void drawScreen(int mouseX, int mouseY, float partialTicks) {
+      this.panoramaTimer += partialTicks;
       GlStateManager.disableAlpha();
-      this.renderSkybox(☃, ☃, ☃);
+      this.renderSkybox(mouseX, mouseY, partialTicks);
       GlStateManager.enableAlpha();
-      int ☃ = 274;
-      int ☃x = this.width / 2 - 137;
-      int ☃xx = 30;
-      this.drawGradientRect(0, 0, this.width, this.height, -2130706433, 16777215);
-      this.drawGradientRect(0, 0, this.width, this.height, 0, Integer.MIN_VALUE);
+      int i = 274;
+      int j = this.width / 2 - 137;
+      int k = 30;
+      int overlay1Top = -2130706433;
+      int overlay1Bottom = 16777215;
+      int overlay2Top = 0;
+      int overlay2Bottom = Integer.MIN_VALUE;
+      CustomPanoramaProperties cpp = CustomPanorama.getCustomPanoramaProperties();
+      if (cpp != null) {
+         overlay1Top = cpp.getOverlay1Top();
+         overlay1Bottom = cpp.getOverlay1Bottom();
+         overlay2Top = cpp.getOverlay2Top();
+         overlay2Bottom = cpp.getOverlay2Bottom();
+      }
+
+      if (overlay1Top != 0 || overlay1Bottom != 0) {
+         this.a(0, 0, this.width, this.height, overlay1Top, overlay1Bottom);
+      }
+
+      if (overlay2Top != 0 || overlay2Bottom != 0) {
+         this.a(0, 0, this.width, this.height, overlay2Top, overlay2Bottom);
+      }
+
       this.mc.getTextureManager().bindTexture(MINECRAFT_TITLE_TEXTURES);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       if (this.minceraftRoll < 1.0E-4) {
-         this.drawTexturedModalRect(☃x + 0, 30, 0, 0, 99, 44);
-         this.drawTexturedModalRect(☃x + 99, 30, 129, 0, 27, 44);
-         this.drawTexturedModalRect(☃x + 99 + 26, 30, 126, 0, 3, 44);
-         this.drawTexturedModalRect(☃x + 99 + 26 + 3, 30, 99, 0, 26, 44);
-         this.drawTexturedModalRect(☃x + 155, 30, 0, 45, 155, 44);
+         this.b(j + 0, 30, 0, 0, 99, 44);
+         this.b(j + 99, 30, 129, 0, 27, 44);
+         this.b(j + 99 + 26, 30, 126, 0, 3, 44);
+         this.b(j + 99 + 26 + 3, 30, 99, 0, 26, 44);
+         this.b(j + 155, 30, 0, 45, 155, 44);
       } else {
-         this.drawTexturedModalRect(☃x + 0, 30, 0, 0, 155, 44);
-         this.drawTexturedModalRect(☃x + 155, 30, 0, 45, 155, 44);
+         this.b(j + 0, 30, 0, 0, 155, 44);
+         this.b(j + 155, 30, 0, 45, 155, 44);
       }
 
       this.mc.getTextureManager().bindTexture(field_194400_H);
-      drawModalRectWithCustomSizedTexture(☃x + 88, 67, 0.0F, 0.0F, 98, 14, 128.0F, 16.0F);
+      a(j + 88, 67, 0.0F, 0.0F, 98, 14, 128.0F, 16.0F);
+      if (Reflector.ForgeHooksClient_renderMainMenu.exists()) {
+         this.splashText = Reflector.callString(
+            Reflector.ForgeHooksClient_renderMainMenu, new Object[]{this, this.fontRenderer, this.width, this.height, this.splashText}
+         );
+      }
+
       GlStateManager.pushMatrix();
       GlStateManager.translate((float)(this.width / 2 + 90), 70.0F, 0.0F);
       GlStateManager.rotate(-20.0F, 0.0F, 0.0F, 1.0F);
-      float ☃xxx = 1.8F - MathHelper.abs(MathHelper.sin((float)(Minecraft.getSystemTime() % 1000L) / 1000.0F * (float) (Math.PI * 2)) * 0.1F);
-      ☃xxx = ☃xxx * 100.0F / (this.fontRenderer.getStringWidth(this.splashText) + 32);
-      GlStateManager.scale(☃xxx, ☃xxx, ☃xxx);
-      this.drawCenteredString(this.fontRenderer, this.splashText, 0, -8, -256);
+      float f = 1.8F - MathHelper.abs(MathHelper.sin((float)(Minecraft.getSystemTime() % 1000L) / 1000.0F * (float) (Math.PI * 2)) * 0.1F);
+      f = f * 100.0F / (this.fontRenderer.getStringWidth(this.splashText) + 32);
+      GlStateManager.scale(f, f, f);
+      this.a(this.fontRenderer, this.splashText, 0, -8, -256);
       GlStateManager.popMatrix();
-      String ☃xxxx = "Minecraft 1.12.2";
+      String s = "Minecraft 1.12.2";
       if (this.mc.isDemo()) {
-         ☃xxxx = ☃xxxx + " Demo";
+         s = s + " Demo";
       } else {
-         ☃xxxx = ☃xxxx + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType());
+         s = s + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType());
       }
 
-      this.drawString(this.fontRenderer, ☃xxxx, 2, this.height - 10, -1);
-      this.drawString(this.fontRenderer, "Copyright Mojang AB. Do not distribute!", this.widthCopyrightRest, this.height - 10, -1);
-      if (☃ > this.widthCopyrightRest && ☃ < this.widthCopyrightRest + this.widthCopyright && ☃ > this.height - 10 && ☃ < this.height && Mouse.isInsideWindow()
-         )
-       {
-         drawRect(this.widthCopyrightRest, this.height - 1, this.widthCopyrightRest + this.widthCopyright, this.height, -1);
+      if (Reflector.FMLCommonHandler_getBrandings.exists()) {
+         Object instance = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         List<String> brandings = Lists.reverse((List)Reflector.call(instance, Reflector.FMLCommonHandler_getBrandings, new Object[]{true}));
+
+         for (int brdline = 0; brdline < brandings.size(); brdline++) {
+            String brd = brandings.get(brdline);
+            if (!Strings.isNullOrEmpty(brd)) {
+               this.c(this.fontRenderer, brd, 2, this.height - (10 + brdline * (this.fontRenderer.FONT_HEIGHT + 1)), 16777215);
+            }
+         }
+      } else {
+         this.c(this.fontRenderer, s, 2, this.height - 10, -1);
+      }
+
+      this.c(this.fontRenderer, "Copyright Mojang AB. Do not distribute!", this.widthCopyrightRest, this.height - 10, -1);
+      if (mouseX > this.widthCopyrightRest
+         && mouseX < this.widthCopyrightRest + this.widthCopyright
+         && mouseY > this.height - 10
+         && mouseY < this.height
+         && Mouse.isInsideWindow()) {
+         a(this.widthCopyrightRest, this.height - 1, this.widthCopyrightRest + this.widthCopyright, this.height, -1);
       }
 
       if (this.openGLWarning1 != null && !this.openGLWarning1.isEmpty()) {
-         drawRect(this.openGLWarningX1 - 2, this.openGLWarningY1 - 2, this.openGLWarningX2 + 2, this.openGLWarningY2 - 1, 1428160512);
-         this.drawString(this.fontRenderer, this.openGLWarning1, this.openGLWarningX1, this.openGLWarningY1, -1);
-         this.drawString(this.fontRenderer, this.openGLWarning2, (this.width - this.openGLWarning2Width) / 2, this.buttonList.get(0).y - 12, -1);
+         a(this.openGLWarningX1 - 2, this.openGLWarningY1 - 2, this.openGLWarningX2 + 2, this.openGLWarningY2 - 1, 1428160512);
+         this.c(this.fontRenderer, this.openGLWarning1, this.openGLWarningX1, this.openGLWarningY1, -1);
+         this.c(this.fontRenderer, this.openGLWarning2, (this.width - this.openGLWarning2Width) / 2, ((GuiButton)this.buttonList.get(0)).y - 12, -1);
       }
 
-      super.drawScreen(☃, ☃, ☃);
+      super.drawScreen(mouseX, mouseY, partialTicks);
       if (this.areRealmsNotificationsEnabled()) {
-         this.realmsNotification.drawScreen(☃, ☃, ☃);
+         this.realmsNotification.drawScreen(mouseX, mouseY, partialTicks);
+      }
+
+      if (this.modUpdateNotification != null) {
+         this.modUpdateNotification.drawScreen(mouseX, mouseY, partialTicks);
       }
    }
 
-   @Override
-   protected void mouseClicked(int var1, int var2, int var3) {
-      super.mouseClicked(☃, ☃, ☃);
+   protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
+      super.mouseClicked(mouseX, mouseY, mouseButton);
       synchronized (this.threadLock) {
          if (!this.openGLWarning1.isEmpty()
             && !StringUtils.isNullOrEmpty(this.openGLWarningLink)
-            && ☃ >= this.openGLWarningX1
-            && ☃ <= this.openGLWarningX2
-            && ☃ >= this.openGLWarningY1
-            && ☃ <= this.openGLWarningY2) {
-            GuiConfirmOpenLink ☃ = new GuiConfirmOpenLink(this, this.openGLWarningLink, 13, true);
-            ☃.disableSecurityWarning();
-            this.mc.displayGuiScreen(☃);
+            && mouseX >= this.openGLWarningX1
+            && mouseX <= this.openGLWarningX2
+            && mouseY >= this.openGLWarningY1
+            && mouseY <= this.openGLWarningY2) {
+            GuiConfirmOpenLink guiconfirmopenlink = new GuiConfirmOpenLink(this, this.openGLWarningLink, 13, true);
+            guiconfirmopenlink.disableSecurityWarning();
+            this.mc.displayGuiScreen(guiconfirmopenlink);
          }
       }
 
       if (this.areRealmsNotificationsEnabled()) {
-         this.realmsNotification.mouseClicked(☃, ☃, ☃);
+         this.realmsNotification.mouseClicked(mouseX, mouseY, mouseButton);
       }
 
-      if (☃ > this.widthCopyrightRest && ☃ < this.widthCopyrightRest + this.widthCopyright && ☃ > this.height - 10 && ☃ < this.height) {
+      if (mouseX > this.widthCopyrightRest && mouseX < this.widthCopyrightRest + this.widthCopyright && mouseY > this.height - 10 && mouseY < this.height) {
          this.mc.displayGuiScreen(new GuiWinGame(false, Runnables.doNothing()));
       }
    }
 
-   @Override
    public void onGuiClosed() {
       if (this.realmsNotification != null) {
          this.realmsNotification.onGuiClosed();
diff --git a/patches/net/minecraft/client/gui/GuiOverlayDebug.java b/patches/net/minecraft/client/gui/GuiOverlayDebug.java
index cc992fd..c13208c 100644
--- a/patches/net/minecraft/client/gui/GuiOverlayDebug.java
+++ b/patches/net/minecraft/client/gui/GuiOverlayDebug.java
@@ -3,6 +3,7 @@
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import com.google.common.collect.UnmodifiableIterator;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
 import net.minecraft.block.Block;
@@ -12,34 +13,44 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.EnumFacing;
-import net.minecraft.util.FrameTimer;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumSkyBlock;
 import net.minecraft.world.WorldType;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.SmartAnimations;
+import net.optifine.TextureAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.util.MemoryMonitor;
+import net.optifine.util.NativeMemory;
 import org.lwjgl.opengl.Display;
 
 public class GuiOverlayDebug extends Gui {
    private final Minecraft mc;
    private final FontRenderer fontRenderer;
+   private String debugOF = null;
+   private List<String> debugInfoLeft = null;
+   private List<String> debugInfoRight = null;
+   private long updateInfoLeftTimeMs = 0L;
+   private long updateInfoRightTimeMs = 0L;
 
-   public GuiOverlayDebug(Minecraft var1) {
-      this.mc = ☃;
-      this.fontRenderer = ☃.fontRenderer;
+   public GuiOverlayDebug(Minecraft mc) {
+      this.mc = mc;
+      this.fontRenderer = mc.fontRenderer;
    }
 
-   public void renderDebugInfo(ScaledResolution var1) {
+   public void renderDebugInfo(ScaledResolution scaledResolutionIn) {
       this.mc.profiler.startSection("debug");
       GlStateManager.pushMatrix();
       this.renderDebugInfoLeft();
-      this.renderDebugInfoRight(☃);
+      this.renderDebugInfoRight(scaledResolutionIn);
       GlStateManager.popMatrix();
       if (this.mc.gameSettings.showLagometer) {
          this.renderLagometer();
@@ -49,49 +60,105 @@ public void renderDebugInfo(ScaledResolution var1) {
    }
 
    protected void renderDebugInfoLeft() {
-      List<String> ☃ = this.call();
-      ☃.add("");
-      ☃.add(
-         "Debug: Pie [shift]: "
-            + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden")
-            + " FPS [alt]: "
-            + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")
-      );
-      ☃.add("For help: press F3 + Q");
-
-      for (int ☃x = 0; ☃x < ☃.size(); ☃x++) {
-         String ☃xx = ☃.get(☃x);
-         if (!Strings.isNullOrEmpty(☃xx)) {
-            int ☃xxx = this.fontRenderer.FONT_HEIGHT;
-            int ☃xxxx = this.fontRenderer.getStringWidth(☃xx);
-            int ☃xxxxx = 2;
-            int ☃xxxxxx = 2 + ☃xxx * ☃x;
-            drawRect(1, ☃xxxxxx - 1, 2 + ☃xxxx + 1, ☃xxxxxx + ☃xxx - 1, -1873784752);
-            this.fontRenderer.drawString(☃xx, 2, ☃xxxxxx, 14737632);
+      List<String> list = this.debugInfoLeft;
+      if (list == null || System.currentTimeMillis() > this.updateInfoLeftTimeMs) {
+         list = this.call();
+         list.add("");
+         list.add(
+            "Debug: Pie [shift]: "
+               + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden")
+               + " FPS [alt]: "
+               + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")
+         );
+         list.add("For help: press F3 + Q");
+         this.debugInfoLeft = list;
+         this.updateInfoLeftTimeMs = System.currentTimeMillis() + 100L;
+      }
+
+      for (int i = 0; i < list.size(); i++) {
+         String s = list.get(i);
+         if (!Strings.isNullOrEmpty(s)) {
+            int j = this.fontRenderer.FONT_HEIGHT;
+            int k = this.fontRenderer.getStringWidth(s);
+            int l = 2;
+            int i1 = 2 + j * i;
+            drawRect(1, i1 - 1, 2 + k + 1, i1 + j - 1, -1873784752);
+            this.fontRenderer.drawString(s, 2, i1, 14737632);
          }
       }
    }
 
-   protected void renderDebugInfoRight(ScaledResolution var1) {
-      List<String> ☃ = this.getDebugInfoRight();
-
-      for (int ☃x = 0; ☃x < ☃.size(); ☃x++) {
-         String ☃xx = ☃.get(☃x);
-         if (!Strings.isNullOrEmpty(☃xx)) {
-            int ☃xxx = this.fontRenderer.FONT_HEIGHT;
-            int ☃xxxx = this.fontRenderer.getStringWidth(☃xx);
-            int ☃xxxxx = ☃.getScaledWidth() - 2 - ☃xxxx;
-            int ☃xxxxxx = 2 + ☃xxx * ☃x;
-            drawRect(☃xxxxx - 1, ☃xxxxxx - 1, ☃xxxxx + ☃xxxx + 1, ☃xxxxxx + ☃xxx - 1, -1873784752);
-            this.fontRenderer.drawString(☃xx, ☃xxxxx, ☃xxxxxx, 14737632);
+   protected void renderDebugInfoRight(ScaledResolution scaledRes) {
+      List<String> list = this.debugInfoRight;
+      if (list == null || System.currentTimeMillis() > this.updateInfoRightTimeMs) {
+         list = this.getDebugInfoRight();
+         this.debugInfoRight = list;
+         this.updateInfoRightTimeMs = System.currentTimeMillis() + 100L;
+      }
+
+      for (int i = 0; i < list.size(); i++) {
+         String s = list.get(i);
+         if (!Strings.isNullOrEmpty(s)) {
+            int j = this.fontRenderer.FONT_HEIGHT;
+            int k = this.fontRenderer.getStringWidth(s);
+            int l = scaledRes.getScaledWidth() - 2 - k;
+            int i1 = 2 + j * i;
+            drawRect(l - 1, i1 - 1, l + k + 1, i1 + j - 1, -1873784752);
+            this.fontRenderer.drawString(s, l, i1, 14737632);
          }
       }
    }
 
    protected List<String> call() {
-      BlockPos ☃ = new BlockPos(
+      BlockPos blockpos = new BlockPos(
          this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().getEntityBoundingBox().minY, this.mc.getRenderViewEntity().posZ
       );
+      if (this.mc.debug != this.debugOF) {
+         StringBuffer sb = new StringBuffer(this.mc.debug);
+         int fpsMin = Config.getFpsMin();
+         int posFps = this.mc.debug.indexOf(" fps ");
+         if (posFps >= 0) {
+            sb.insert(posFps, "/" + fpsMin);
+         }
+
+         if (Config.isSmoothFps()) {
+            sb.append(" sf");
+         }
+
+         if (Config.isFastRender()) {
+            sb.append(" fr");
+         }
+
+         if (Config.isAnisotropicFiltering()) {
+            sb.append(" af");
+         }
+
+         if (Config.isAntialiasing()) {
+            sb.append(" aa");
+         }
+
+         if (Config.isRenderRegions()) {
+            sb.append(" reg");
+         }
+
+         if (Config.isShaders()) {
+            sb.append(" sh");
+         }
+
+         this.mc.debug = sb.toString();
+         this.debugOF = this.mc.debug;
+      }
+
+      StringBuilder sbx = new StringBuilder();
+      TextureMap tm = Config.getTextureMap();
+      sbx.append(", A: ");
+      if (SmartAnimations.isActive()) {
+         sbx.append(tm.getCountAnimationsActive() + TextureAnimations.getCountAnimationsActive());
+         sbx.append("/");
+      }
+
+      sbx.append(tm.getCountAnimations() + TextureAnimations.getCountAnimations());
+      String ofInfo = sbx.toString();
       if (this.mc.isReducedDebug()) {
          return Lists.newArrayList(
             new String[]{
@@ -99,31 +166,31 @@ protected List<String> call() {
                this.mc.debug,
                this.mc.renderGlobal.getDebugInfoRenders(),
                this.mc.renderGlobal.getDebugInfoEntities(),
-               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(),
+               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + ofInfo,
                this.mc.world.getProviderName(),
                "",
-               String.format("Chunk-relative: %d %d %d", ☃.getX() & 15, ☃.getY() & 15, ☃.getZ() & 15)
+               String.format("Chunk-relative: %d %d %d", blockpos.getX() & 15, blockpos.getY() & 15, blockpos.getZ() & 15)
             }
          );
       } else {
-         Entity ☃x = this.mc.getRenderViewEntity();
-         EnumFacing ☃xx = ☃x.getHorizontalFacing();
-         String ☃xxx = "Invalid";
-         switch (☃xx) {
+         Entity entity = this.mc.getRenderViewEntity();
+         EnumFacing enumfacing = entity.getHorizontalFacing();
+         String s = "Invalid";
+         switch (enumfacing) {
             case NORTH:
-               ☃xxx = "Towards negative Z";
+               s = "Towards negative Z";
                break;
             case SOUTH:
-               ☃xxx = "Towards positive Z";
+               s = "Towards positive Z";
                break;
             case WEST:
-               ☃xxx = "Towards negative X";
+               s = "Towards negative X";
                break;
             case EAST:
-               ☃xxx = "Towards positive X";
+               s = "Towards positive X";
          }
 
-         List<String> ☃x = Lists.newArrayList(
+         List<String> list = Lists.newArrayList(
             new String[]{
                "Minecraft 1.12.2 ("
                   + this.mc.getVersion()
@@ -134,7 +201,7 @@ protected List<String> call() {
                this.mc.debug,
                this.mc.renderGlobal.getDebugInfoRenders(),
                this.mc.renderGlobal.getDebugInfoEntities(),
-               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(),
+               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + ofInfo,
                this.mc.world.getProviderName(),
                "",
                String.format(
@@ -143,72 +210,83 @@ protected List<String> call() {
                   this.mc.getRenderViewEntity().getEntityBoundingBox().minY,
                   this.mc.getRenderViewEntity().posZ
                ),
-               String.format("Block: %d %d %d", ☃.getX(), ☃.getY(), ☃.getZ()),
-               String.format("Chunk: %d %d %d in %d %d %d", ☃.getX() & 15, ☃.getY() & 15, ☃.getZ() & 15, ☃.getX() >> 4, ☃.getY() >> 4, ☃.getZ() >> 4),
-               String.format("Facing: %s (%s) (%.1f / %.1f)", ☃xx, ☃xxx, MathHelper.wrapDegrees(☃x.rotationYaw), MathHelper.wrapDegrees(☃x.rotationPitch))
+               String.format("Block: %d %d %d", blockpos.getX(), blockpos.getY(), blockpos.getZ()),
+               String.format(
+                  "Chunk: %d %d %d in %d %d %d",
+                  blockpos.getX() & 15,
+                  blockpos.getY() & 15,
+                  blockpos.getZ() & 15,
+                  blockpos.getX() >> 4,
+                  blockpos.getY() >> 4,
+                  blockpos.getZ() >> 4
+               ),
+               String.format(
+                  "Facing: %s (%s) (%.1f / %.1f)", enumfacing, s, MathHelper.wrapDegrees(entity.rotationYaw), MathHelper.wrapDegrees(entity.rotationPitch)
+               )
             }
          );
          if (this.mc.world != null) {
-            Chunk ☃xx = this.mc.world.getChunk(☃);
-            if (!this.mc.world.isBlockLoaded(☃) || ☃.getY() < 0 || ☃.getY() >= 256) {
-               ☃x.add("Outside of world...");
-            } else if (!☃xx.isEmpty()) {
-               ☃x.add("Biome: " + ☃xx.getBiome(☃, this.mc.world.getBiomeProvider()).getBiomeName());
-               ☃x.add(
+            Chunk chunk = this.mc.world.getChunk(blockpos);
+            if (!this.mc.world.isBlockLoaded(blockpos) || blockpos.getY() < 0 || blockpos.getY() >= 256) {
+               list.add("Outside of world...");
+            } else if (!chunk.isEmpty()) {
+               list.add("Biome: " + chunk.getBiome(blockpos, this.mc.world.getBiomeProvider()).getBiomeName());
+               list.add(
                   "Light: "
-                     + ☃xx.getLightSubtracted(☃, 0)
+                     + chunk.getLightSubtracted(blockpos, 0)
                      + " ("
-                     + ☃xx.getLightFor(EnumSkyBlock.SKY, ☃)
+                     + chunk.getLightFor(EnumSkyBlock.SKY, blockpos)
                      + " sky, "
-                     + ☃xx.getLightFor(EnumSkyBlock.BLOCK, ☃)
+                     + chunk.getLightFor(EnumSkyBlock.BLOCK, blockpos)
                      + " block)"
                );
-               DifficultyInstance ☃xxx = this.mc.world.getDifficultyForLocation(☃);
+               DifficultyInstance difficultyinstance = this.mc.world.getDifficultyForLocation(blockpos);
                if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null) {
-                  EntityPlayerMP ☃xxxx = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.getUniqueID());
-                  if (☃xxxx != null) {
-                     ☃xxx = ☃xxxx.world.getDifficultyForLocation(new BlockPos(☃xxxx));
+                  EntityPlayerMP entityplayermp = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.getUniqueID());
+                  if (entityplayermp != null) {
+                     DifficultyInstance difficultyServer = this.mc.getIntegratedServer().getDifficultyAsync(entityplayermp.world, new BlockPos(entityplayermp));
+                     if (difficultyServer != null) {
+                        difficultyinstance = difficultyServer;
+                     }
                   }
                }
 
-               ☃x.add(
+               list.add(
                   String.format(
                      "Local Difficulty: %.2f // %.2f (Day %d)",
-                     ☃xxx.getAdditionalDifficulty(),
-                     ☃xxx.getClampedAdditionalDifficulty(),
+                     difficultyinstance.getAdditionalDifficulty(),
+                     difficultyinstance.getClampedAdditionalDifficulty(),
                      this.mc.world.getWorldTime() / 24000L
                   )
                );
             } else {
-               ☃x.add("Waiting for chunk...");
+               list.add("Waiting for chunk...");
             }
          }
 
          if (this.mc.entityRenderer != null && this.mc.entityRenderer.isShaderActive()) {
-            ☃x.add("Shader: " + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
+            list.add("Shader: " + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
          }
 
-         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null
-            )
-          {
-            BlockPos ☃xx = this.mc.objectMouseOver.getBlockPos();
-            ☃x.add(String.format("Looking at: %d %d %d", ☃xx.getX(), ☃xx.getY(), ☃xx.getZ()));
+         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
+            BlockPos blockpos1 = this.mc.objectMouseOver.getBlockPos();
+            list.add(String.format("Looking at: %d %d %d", blockpos1.getX(), blockpos1.getY(), blockpos1.getZ()));
          }
 
-         return ☃x;
+         return list;
       }
    }
 
    protected <T extends Comparable<T>> List<String> getDebugInfoRight() {
-      long ☃ = Runtime.getRuntime().maxMemory();
-      long ☃x = Runtime.getRuntime().totalMemory();
-      long ☃xx = Runtime.getRuntime().freeMemory();
-      long ☃xxx = ☃x - ☃xx;
-      List<String> ☃xxxx = Lists.newArrayList(
+      long i = Runtime.getRuntime().maxMemory();
+      long j = Runtime.getRuntime().totalMemory();
+      long k = Runtime.getRuntime().freeMemory();
+      long l = j - k;
+      List<String> list = Lists.newArrayList(
          new String[]{
             String.format("Java: %s %dbit", System.getProperty("java.version"), this.mc.isJava64bit() ? 64 : 32),
-            String.format("Mem: % 2d%% %03d/%03dMB", ☃xxx * 100L / ☃, bytesToMb(☃xxx), bytesToMb(☃)),
-            String.format("Allocated: % 2d%% %03dMB", ☃x * 100L / ☃, bytesToMb(☃x)),
+            String.format("Mem: % 2d%% %03d/%03dMB", l * 100L / i, bytesToMb(l), bytesToMb(i)),
+            String.format("Allocated: % 2d%% %03dMB", j * 100L / i, bytesToMb(j)),
             "",
             String.format("CPU: %s", OpenGlHelper.getCpu()),
             "",
@@ -217,97 +295,76 @@ protected <T extends Comparable<T>> List<String> getDebugInfoRight() {
             GlStateManager.glGetString(7938)
          }
       );
+      long bufferAllocated = NativeMemory.getBufferAllocated();
+      long bufferMaximum = NativeMemory.getBufferMaximum();
+      String strNative = "Native: " + bytesToMb(bufferAllocated) + "/" + bytesToMb(bufferMaximum) + "MB";
+      list.add(4, strNative);
+      list.set(5, "GC: " + MemoryMonitor.getAllocationRateMb() + "MB/s");
+      if (Reflector.FMLCommonHandler_getBrandings.exists()) {
+         Object instance = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         list.add("");
+         list.addAll((Collection<? extends String>)Reflector.call(instance, Reflector.FMLCommonHandler_getBrandings, new Object[]{false}));
+      }
+
       if (this.mc.isReducedDebug()) {
-         return ☃xxxx;
+         return list;
       } else {
-         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null
-            )
-          {
-            BlockPos ☃xxxxx = this.mc.objectMouseOver.getBlockPos();
-            IBlockState ☃xxxxxx = this.mc.world.getBlockState(☃xxxxx);
+         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
+            BlockPos blockpos = this.mc.objectMouseOver.getBlockPos();
+            IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
             if (this.mc.world.getWorldType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
-               ☃xxxxxx = ☃xxxxxx.getActualState(this.mc.world, ☃xxxxx);
+               iblockstate = iblockstate.c(this.mc.world, blockpos);
             }
 
-            ☃xxxx.add("");
-            ☃xxxx.add(String.valueOf(Block.REGISTRY.getNameForObject(☃xxxxxx.getBlock())));
-            UnmodifiableIterator var12 = ☃xxxxxx.getProperties().entrySet().iterator();
-
-            while (var12.hasNext()) {
-               Entry<IProperty<?>, Comparable<?>> ☃xxxxxxx = (Entry<IProperty<?>, Comparable<?>>)var12.next();
-               IProperty<T> ☃xxxxxxxx = (IProperty<T>)☃xxxxxxx.getKey();
-               T ☃xxxxxxxxx = (T)☃xxxxxxx.getValue();
-               String ☃xxxxxxxxxx = ☃xxxxxxxx.getName(☃xxxxxxxxx);
-               if (Boolean.TRUE.equals(☃xxxxxxxxx)) {
-                  ☃xxxxxxxxxx = TextFormatting.GREEN + ☃xxxxxxxxxx;
-               } else if (Boolean.FALSE.equals(☃xxxxxxxxx)) {
-                  ☃xxxxxxxxxx = TextFormatting.RED + ☃xxxxxxxxxx;
+            list.add("");
+            list.add(String.valueOf(Block.REGISTRY.getNameForObject(iblockstate.getBlock())));
+            UnmodifiableIterator unmodifiableiterator = iblockstate.getProperties().entrySet().iterator();
+
+            while (unmodifiableiterator.hasNext()) {
+               Entry<IProperty<?>, Comparable<?>> entry = (Entry<IProperty<?>, Comparable<?>>)unmodifiableiterator.next();
+               IProperty<T> iproperty = (IProperty<T>)entry.getKey();
+               T t = (T)entry.getValue();
+               String s = iproperty.getName(t);
+               if (Boolean.TRUE.equals(t)) {
+                  s = TextFormatting.GREEN + s;
+               } else if (Boolean.FALSE.equals(t)) {
+                  s = TextFormatting.RED + s;
                }
 
-               ☃xxxx.add(☃xxxxxxxx.getName() + ": " + ☃xxxxxxxxxx);
+               list.add(iproperty.getName() + ": " + s);
             }
          }
 
-         return ☃xxxx;
+         return list;
       }
    }
 
    private void renderLagometer() {
-      GlStateManager.disableDepth();
-      FrameTimer ☃ = this.mc.getFrameTimer();
-      int ☃x = ☃.getLastIndex();
-      int ☃xx = ☃.getIndex();
-      long[] ☃xxx = ☃.getFrames();
-      ScaledResolution ☃xxxx = new ScaledResolution(this.mc);
-      int ☃xxxxx = ☃x;
-      int ☃xxxxxx = 0;
-      drawRect(0, ☃xxxx.getScaledHeight() - 60, 240, ☃xxxx.getScaledHeight(), -1873784752);
-
-      while (☃xxxxx != ☃xx) {
-         int ☃xxxxxxx = ☃.getLagometerValue(☃xxx[☃xxxxx], 30);
-         int ☃xxxxxxxx = this.getFrameColor(MathHelper.clamp(☃xxxxxxx, 0, 60), 0, 30, 60);
-         this.drawVerticalLine(☃xxxxxx, ☃xxxx.getScaledHeight(), ☃xxxx.getScaledHeight() - ☃xxxxxxx, ☃xxxxxxxx);
-         ☃xxxxxx++;
-         ☃xxxxx = ☃.parseIndex(☃xxxxx + 1);
-      }
-
-      drawRect(1, ☃xxxx.getScaledHeight() - 30 + 1, 14, ☃xxxx.getScaledHeight() - 30 + 10, -1873784752);
-      this.fontRenderer.drawString("60", 2, ☃xxxx.getScaledHeight() - 30 + 2, 14737632);
-      this.drawHorizontalLine(0, 239, ☃xxxx.getScaledHeight() - 30, -1);
-      drawRect(1, ☃xxxx.getScaledHeight() - 60 + 1, 14, ☃xxxx.getScaledHeight() - 60 + 10, -1873784752);
-      this.fontRenderer.drawString("30", 2, ☃xxxx.getScaledHeight() - 60 + 2, 14737632);
-      this.drawHorizontalLine(0, 239, ☃xxxx.getScaledHeight() - 60, -1);
-      this.drawHorizontalLine(0, 239, ☃xxxx.getScaledHeight() - 1, -1);
-      this.drawVerticalLine(0, ☃xxxx.getScaledHeight() - 60, ☃xxxx.getScaledHeight(), -1);
-      this.drawVerticalLine(239, ☃xxxx.getScaledHeight() - 60, ☃xxxx.getScaledHeight(), -1);
-      if (this.mc.gameSettings.limitFramerate <= 120) {
-         this.drawHorizontalLine(0, 239, ☃xxxx.getScaledHeight() - 60 + this.mc.gameSettings.limitFramerate / 2, -16711681);
-      }
-
-      GlStateManager.enableDepth();
    }
 
-   private int getFrameColor(int var1, int var2, int var3, int var4) {
-      return ☃ < ☃ ? this.blendColors(-16711936, -256, (float)☃ / ☃) : this.blendColors(-256, -65536, (float)(☃ - ☃) / (☃ - ☃));
+   private int getFrameColor(int p_181552_1_, int p_181552_2_, int p_181552_3_, int p_181552_4_) {
+      return p_181552_1_ < p_181552_3_
+         ? this.blendColors(-16711936, -256, (float)p_181552_1_ / p_181552_3_)
+         : this.blendColors(-256, -65536, (float)(p_181552_1_ - p_181552_3_) / (p_181552_4_ - p_181552_3_));
    }
 
-   private int blendColors(int var1, int var2, float var3) {
-      int ☃ = ☃ >> 24 & 0xFF;
-      int ☃x = ☃ >> 16 & 0xFF;
-      int ☃xx = ☃ >> 8 & 0xFF;
-      int ☃xxx = ☃ & 0xFF;
-      int ☃xxxx = ☃ >> 24 & 0xFF;
-      int ☃xxxxx = ☃ >> 16 & 0xFF;
-      int ☃xxxxxx = ☃ >> 8 & 0xFF;
-      int ☃xxxxxxx = ☃ & 0xFF;
-      int ☃xxxxxxxx = MathHelper.clamp((int)(☃ + (☃xxxx - ☃) * ☃), 0, 255);
-      int ☃xxxxxxxxx = MathHelper.clamp((int)(☃x + (☃xxxxx - ☃x) * ☃), 0, 255);
-      int ☃xxxxxxxxxx = MathHelper.clamp((int)(☃xx + (☃xxxxxx - ☃xx) * ☃), 0, 255);
-      int ☃xxxxxxxxxxx = MathHelper.clamp((int)(☃xxx + (☃xxxxxxx - ☃xxx) * ☃), 0, 255);
-      return ☃xxxxxxxx << 24 | ☃xxxxxxxxx << 16 | ☃xxxxxxxxxx << 8 | ☃xxxxxxxxxxx;
+   private int blendColors(int p_181553_1_, int p_181553_2_, float p_181553_3_) {
+      int i = p_181553_1_ >> 24 & 0xFF;
+      int j = p_181553_1_ >> 16 & 0xFF;
+      int k = p_181553_1_ >> 8 & 0xFF;
+      int l = p_181553_1_ & 0xFF;
+      int i1 = p_181553_2_ >> 24 & 0xFF;
+      int j1 = p_181553_2_ >> 16 & 0xFF;
+      int k1 = p_181553_2_ >> 8 & 0xFF;
+      int l1 = p_181553_2_ & 0xFF;
+      int i2 = MathHelper.clamp((int)(i + (i1 - i) * p_181553_3_), 0, 255);
+      int j2 = MathHelper.clamp((int)(j + (j1 - j) * p_181553_3_), 0, 255);
+      int k2 = MathHelper.clamp((int)(k + (k1 - k) * p_181553_3_), 0, 255);
+      int l2 = MathHelper.clamp((int)(l + (l1 - l) * p_181553_3_), 0, 255);
+      return i2 << 24 | j2 << 16 | k2 << 8 | l2;
    }
 
-   private static long bytesToMb(long var0) {
-      return ☃ / 1024L / 1024L;
+   private static long bytesToMb(long bytes) {
+      return bytes / 1024L / 1024L;
    }
 }
diff --git a/patches/net/minecraft/client/gui/GuiScreenWorking.java b/patches/net/minecraft/client/gui/GuiScreenWorking.java
index 254b458..ed088c6 100644
--- a/patches/net/minecraft/client/gui/GuiScreenWorking.java
+++ b/patches/net/minecraft/client/gui/GuiScreenWorking.java
@@ -1,51 +1,56 @@
 package net.minecraft.client.gui;
 
 import net.minecraft.util.IProgressUpdate;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
 
 public class GuiScreenWorking extends GuiScreen implements IProgressUpdate {
    private String title = "";
    private String stage = "";
    private int progress;
    private boolean doneWorking;
+   private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
 
-   @Override
-   public void displaySavingString(String var1) {
-      this.resetProgressAndMessage(☃);
+   public void displaySavingString(String message) {
+      this.resetProgressAndMessage(message);
    }
 
-   @Override
-   public void resetProgressAndMessage(String var1) {
-      this.title = ☃;
+   public void resetProgressAndMessage(String message) {
+      this.title = message;
       this.displayLoadingString("Working...");
    }
 
-   @Override
-   public void displayLoadingString(String var1) {
-      this.stage = ☃;
+   public void displayLoadingString(String message) {
+      this.stage = message;
       this.setLoadingProgress(0);
    }
 
-   @Override
-   public void setLoadingProgress(int var1) {
-      this.progress = ☃;
+   public void setLoadingProgress(int progress) {
+      this.progress = progress;
    }
 
-   @Override
    public void setDoneWorking() {
       this.doneWorking = true;
    }
 
-   @Override
-   public void drawScreen(int var1, int var2, float var3) {
+   public void drawScreen(int mouseX, int mouseY, float partialTicks) {
       if (this.doneWorking) {
          if (!this.mc.isConnectedToRealms()) {
-            this.mc.displayGuiScreen(null);
+            this.mc.displayGuiScreen((GuiScreen)null);
          }
       } else {
-         this.drawDefaultBackground();
-         this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 70, 16777215);
-         this.drawCenteredString(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 16777215);
-         super.drawScreen(☃, ☃, ☃);
+         if (this.customLoadingScreen != null && this.mc.world == null) {
+            this.customLoadingScreen.drawBackground(this.width, this.height);
+         } else {
+            this.drawDefaultBackground();
+         }
+
+         if (this.progress > 0) {
+            this.a(this.fontRenderer, this.title, this.width / 2, 70, 16777215);
+            this.a(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 16777215);
+         }
+
+         super.drawScreen(mouseX, mouseY, partialTicks);
       }
    }
 }
diff --git a/patches/net/minecraft/client/gui/GuiSlot.java b/patches/net/minecraft/client/gui/GuiSlot.java
index fdcfca6..3151f7c 100644
--- a/patches/net/minecraft/client/gui/GuiSlot.java
+++ b/patches/net/minecraft/client/gui/GuiSlot.java
@@ -33,34 +33,34 @@ public abstract class GuiSlot {
    protected int headerPadding;
    private boolean enabled = true;
 
-   public GuiSlot(Minecraft var1, int var2, int var3, int var4, int var5, int var6) {
-      this.mc = ☃;
-      this.width = ☃;
-      this.height = ☃;
-      this.top = ☃;
-      this.bottom = ☃;
-      this.slotHeight = ☃;
+   public GuiSlot(Minecraft mcIn, int width, int height, int topIn, int bottomIn, int slotHeightIn) {
+      this.mc = mcIn;
+      this.width = width;
+      this.height = height;
+      this.top = topIn;
+      this.bottom = bottomIn;
+      this.slotHeight = slotHeightIn;
       this.left = 0;
-      this.right = ☃;
+      this.right = width;
    }
 
-   public void setDimensions(int var1, int var2, int var3, int var4) {
-      this.width = ☃;
-      this.height = ☃;
-      this.top = ☃;
-      this.bottom = ☃;
+   public void setDimensions(int widthIn, int heightIn, int topIn, int bottomIn) {
+      this.width = widthIn;
+      this.height = heightIn;
+      this.top = topIn;
+      this.bottom = bottomIn;
       this.left = 0;
-      this.right = ☃;
+      this.right = widthIn;
    }
 
-   public void setShowSelectionBox(boolean var1) {
-      this.showSelectionBox = ☃;
+   public void setShowSelectionBox(boolean showSelectionBoxIn) {
+      this.showSelectionBox = showSelectionBoxIn;
    }
 
-   protected void setHasListHeader(boolean var1, int var2) {
-      this.hasListHeader = ☃;
-      this.headerPadding = ☃;
-      if (!☃) {
+   protected void setHasListHeader(boolean hasListHeaderIn, int headerPaddingIn) {
+      this.hasListHeader = hasListHeaderIn;
+      this.headerPadding = headerPaddingIn;
+      if (!hasListHeaderIn) {
          this.headerPadding = 0;
       }
    }
@@ -77,31 +77,31 @@ protected int getContentHeight() {
 
    protected abstract void drawBackground();
 
-   protected void updateItemPos(int var1, int var2, int var3, float var4) {
+   protected void updateItemPos(int entryID, int insideLeft, int yPos, float partialTicks) {
    }
 
    protected abstract void drawSlot(int var1, int var2, int var3, int var4, int var5, int var6, float var7);
 
-   protected void drawListHeader(int var1, int var2, Tessellator var3) {
+   protected void drawListHeader(int insideLeft, int insideTop, Tessellator tessellatorIn) {
    }
 
-   protected void clickedHeader(int var1, int var2) {
+   protected void clickedHeader(int p_148132_1_, int p_148132_2_) {
    }
 
-   protected void renderDecorations(int var1, int var2) {
+   protected void renderDecorations(int mouseXIn, int mouseYIn) {
    }
 
-   public int getSlotIndexFromScreenCoords(int var1, int var2) {
-      int ☃ = this.left + this.width / 2 - this.getListWidth() / 2;
-      int ☃x = this.left + this.width / 2 + this.getListWidth() / 2;
-      int ☃xx = ☃ - this.top - this.headerPadding + (int)this.amountScrolled - 4;
-      int ☃xxx = ☃xx / this.slotHeight;
-      return ☃ < this.getScrollBarX() && ☃ >= ☃ && ☃ <= ☃x && ☃xxx >= 0 && ☃xx >= 0 && ☃xxx < this.getSize() ? ☃xxx : -1;
+   public int getSlotIndexFromScreenCoords(int posX, int posY) {
+      int i = this.left + this.width / 2 - this.getListWidth() / 2;
+      int j = this.left + this.width / 2 + this.getListWidth() / 2;
+      int k = posY - this.top - this.headerPadding + (int)this.amountScrolled - 4;
+      int l = k / this.slotHeight;
+      return posX < this.getScrollBarX() && posX >= i && posX <= j && l >= 0 && k >= 0 && l < this.getSize() ? l : -1;
    }
 
-   public void registerScrollButtons(int var1, int var2) {
-      this.scrollUpButtonID = ☃;
-      this.scrollDownButtonID = ☃;
+   public void registerScrollButtons(int scrollUpButtonIDIn, int scrollDownButtonIDIn) {
+      this.scrollUpButtonID = scrollUpButtonIDIn;
+      this.scrollDownButtonID = scrollDownButtonIDIn;
    }
 
    protected void bindAmountScrolled() {
@@ -116,23 +116,23 @@ public int getAmountScrolled() {
       return (int)this.amountScrolled;
    }
 
-   public boolean isMouseYWithinSlotBounds(int var1) {
-      return ☃ >= this.top && ☃ <= this.bottom && this.mouseX >= this.left && this.mouseX <= this.right;
+   public boolean isMouseYWithinSlotBounds(int p_148141_1_) {
+      return p_148141_1_ >= this.top && p_148141_1_ <= this.bottom && this.mouseX >= this.left && this.mouseX <= this.right;
    }
 
-   public void scrollBy(int var1) {
-      this.amountScrolled += ☃;
+   public void scrollBy(int amount) {
+      this.amountScrolled += amount;
       this.bindAmountScrolled();
       this.initialClickY = -2;
    }
 
-   public void actionPerformed(GuiButton var1) {
-      if (☃.enabled) {
-         if (☃.id == this.scrollUpButtonID) {
+   public void actionPerformed(GuiButton button) {
+      if (button.enabled) {
+         if (button.id == this.scrollUpButtonID) {
             this.amountScrolled = this.amountScrolled - this.slotHeight * 2 / 3;
             this.initialClickY = -2;
             this.bindAmountScrolled();
-         } else if (☃.id == this.scrollDownButtonID) {
+         } else if (button.id == this.scrollDownButtonID) {
             this.amountScrolled = this.amountScrolled + this.slotHeight * 2 / 3;
             this.initialClickY = -2;
             this.bindAmountScrolled();
@@ -140,34 +140,26 @@ public void actionPerformed(GuiButton var1) {
       }
    }
 
-   public void drawScreen(int var1, int var2, float var3) {
+   public void drawScreen(int mouseXIn, int mouseYIn, float partialTicks) {
       if (this.visible) {
-         this.mouseX = ☃;
-         this.mouseY = ☃;
+         this.mouseX = mouseXIn;
+         this.mouseY = mouseYIn;
          this.drawBackground();
-         int ☃ = this.getScrollBarX();
-         int ☃x = ☃ + 6;
+         int i = this.getScrollBarX();
+         int j = i + 6;
          this.bindAmountScrolled();
          GlStateManager.disableLighting();
          GlStateManager.disableFog();
-         Tessellator ☃xx = Tessellator.getInstance();
-         BufferBuilder ☃xxx = ☃xx.getBuffer();
-         this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         float ☃xxxx = 32.0F;
-         ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         ☃xxx.pos(this.left, this.bottom, 0.0).tex(this.left / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         ☃xxx.pos(this.right, this.bottom, 0.0).tex(this.right / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         ☃xxx.pos(this.right, this.top, 0.0).tex(this.right / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         ☃xxx.pos(this.left, this.top, 0.0).tex(this.left / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         ☃xx.draw();
-         int ☃xxxxx = this.left + this.width / 2 - this.getListWidth() / 2 + 2;
-         int ☃xxxxxx = this.top + 4 - (int)this.amountScrolled;
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         this.drawContainerBackground(tessellator);
+         int k = this.left + this.width / 2 - this.getListWidth() / 2 + 2;
+         int l = this.top + 4 - (int)this.amountScrolled;
          if (this.hasListHeader) {
-            this.drawListHeader(☃xxxxx, ☃xxxxxx, ☃xx);
+            this.drawListHeader(k, l, tessellator);
          }
 
-         this.drawSelectionBox(☃xxxxx, ☃xxxxxx, ☃, ☃, ☃);
+         this.drawSelectionBox(k, l, mouseXIn, mouseYIn, partialTicks);
          GlStateManager.disableDepth();
          this.overlayBackground(0, this.top, 255, 255);
          this.overlayBackground(this.bottom, this.height, 255, 255);
@@ -181,49 +173,49 @@ public void drawScreen(int var1, int var2, float var3) {
          GlStateManager.disableAlpha();
          GlStateManager.shadeModel(7425);
          GlStateManager.disableTexture2D();
-         int ☃xxxxxxx = 4;
-         ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         ☃xxx.pos(this.left, this.top + 4, 0.0).tex(0.0, 1.0).color(0, 0, 0, 0).endVertex();
-         ☃xxx.pos(this.right, this.top + 4, 0.0).tex(1.0, 1.0).color(0, 0, 0, 0).endVertex();
-         ☃xxx.pos(this.right, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
-         ☃xxx.pos(this.left, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
-         ☃xx.draw();
-         ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         ☃xxx.pos(this.left, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
-         ☃xxx.pos(this.right, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
-         ☃xxx.pos(this.right, this.bottom - 4, 0.0).tex(1.0, 0.0).color(0, 0, 0, 0).endVertex();
-         ☃xxx.pos(this.left, this.bottom - 4, 0.0).tex(0.0, 0.0).color(0, 0, 0, 0).endVertex();
-         ☃xx.draw();
-         int ☃xxxxxxxx = this.getMaxScroll();
-         if (☃xxxxxxxx > 0) {
-            int ☃xxxxxxxxx = (this.bottom - this.top) * (this.bottom - this.top) / this.getContentHeight();
-            ☃xxxxxxxxx = MathHelper.clamp(☃xxxxxxxxx, 32, this.bottom - this.top - 8);
-            int ☃xxxxxxxxxx = (int)this.amountScrolled * (this.bottom - this.top - ☃xxxxxxxxx) / ☃xxxxxxxx + this.top;
-            if (☃xxxxxxxxxx < this.top) {
-               ☃xxxxxxxxxx = this.top;
+         int i1 = 4;
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+         bufferbuilder.pos(this.left, this.top + 4, 0.0).tex(0.0, 1.0).color(0, 0, 0, 0).endVertex();
+         bufferbuilder.pos(this.right, this.top + 4, 0.0).tex(1.0, 1.0).color(0, 0, 0, 0).endVertex();
+         bufferbuilder.pos(this.right, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
+         bufferbuilder.pos(this.left, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
+         tessellator.draw();
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+         bufferbuilder.pos(this.left, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
+         bufferbuilder.pos(this.right, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
+         bufferbuilder.pos(this.right, this.bottom - 4, 0.0).tex(1.0, 0.0).color(0, 0, 0, 0).endVertex();
+         bufferbuilder.pos(this.left, this.bottom - 4, 0.0).tex(0.0, 0.0).color(0, 0, 0, 0).endVertex();
+         tessellator.draw();
+         int j1 = this.getMaxScroll();
+         if (j1 > 0) {
+            int k1 = (this.bottom - this.top) * (this.bottom - this.top) / this.getContentHeight();
+            k1 = MathHelper.clamp(k1, 32, this.bottom - this.top - 8);
+            int l1 = (int)this.amountScrolled * (this.bottom - this.top - k1) / j1 + this.top;
+            if (l1 < this.top) {
+               l1 = this.top;
             }
 
-            ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            ☃xxx.pos(☃, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxx.pos(☃x, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxx.pos(☃x, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
-            ☃xxx.pos(☃, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
-            ☃xx.draw();
-            ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            ☃xxx.pos(☃, ☃xxxxxxxxxx + ☃xxxxxxxxx, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
-            ☃xxx.pos(☃x, ☃xxxxxxxxxx + ☃xxxxxxxxx, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
-            ☃xxx.pos(☃x, ☃xxxxxxxxxx, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
-            ☃xxx.pos(☃, ☃xxxxxxxxxx, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
-            ☃xx.draw();
-            ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            ☃xxx.pos(☃, ☃xxxxxxxxxx + ☃xxxxxxxxx - 1, 0.0).tex(0.0, 1.0).color(192, 192, 192, 255).endVertex();
-            ☃xxx.pos(☃x - 1, ☃xxxxxxxxxx + ☃xxxxxxxxx - 1, 0.0).tex(1.0, 1.0).color(192, 192, 192, 255).endVertex();
-            ☃xxx.pos(☃x - 1, ☃xxxxxxxxxx, 0.0).tex(1.0, 0.0).color(192, 192, 192, 255).endVertex();
-            ☃xxx.pos(☃, ☃xxxxxxxxxx, 0.0).tex(0.0, 0.0).color(192, 192, 192, 255).endVertex();
-            ☃xx.draw();
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            bufferbuilder.pos(i, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(j, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(j, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(i, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
+            tessellator.draw();
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            bufferbuilder.pos(i, l1 + k1, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(j, l1 + k1, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(j, l1, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(i, l1, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
+            tessellator.draw();
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            bufferbuilder.pos(i, l1 + k1 - 1, 0.0).tex(0.0, 1.0).color(192, 192, 192, 255).endVertex();
+            bufferbuilder.pos(j - 1, l1 + k1 - 1, 0.0).tex(1.0, 1.0).color(192, 192, 192, 255).endVertex();
+            bufferbuilder.pos(j - 1, l1, 0.0).tex(1.0, 0.0).color(192, 192, 192, 255).endVertex();
+            bufferbuilder.pos(i, l1, 0.0).tex(0.0, 0.0).color(192, 192, 192, 255).endVertex();
+            tessellator.draw();
          }
 
-         this.renderDecorations(☃, ☃);
+         this.renderDecorations(mouseXIn, mouseYIn);
          GlStateManager.enableTexture2D();
          GlStateManager.shadeModel(7424);
          GlStateManager.enableAlpha();
@@ -234,54 +226,54 @@ public void drawScreen(int var1, int var2, float var3) {
    public void handleMouseInput() {
       if (this.isMouseYWithinSlotBounds(this.mouseY)) {
          if (Mouse.getEventButton() == 0 && Mouse.getEventButtonState() && this.mouseY >= this.top && this.mouseY <= this.bottom) {
-            int ☃ = (this.width - this.getListWidth()) / 2;
-            int ☃x = (this.width + this.getListWidth()) / 2;
-            int ☃xx = this.mouseY - this.top - this.headerPadding + (int)this.amountScrolled - 4;
-            int ☃xxx = ☃xx / this.slotHeight;
-            if (☃xxx < this.getSize() && this.mouseX >= ☃ && this.mouseX <= ☃x && ☃xxx >= 0 && ☃xx >= 0) {
-               this.elementClicked(☃xxx, false, this.mouseX, this.mouseY);
-               this.selectedElement = ☃xxx;
-            } else if (this.mouseX >= ☃ && this.mouseX <= ☃x && ☃xx < 0) {
-               this.clickedHeader(this.mouseX - ☃, this.mouseY - this.top + (int)this.amountScrolled - 4);
+            int i = (this.width - this.getListWidth()) / 2;
+            int j = (this.width + this.getListWidth()) / 2;
+            int k = this.mouseY - this.top - this.headerPadding + (int)this.amountScrolled - 4;
+            int l = k / this.slotHeight;
+            if (l < this.getSize() && this.mouseX >= i && this.mouseX <= j && l >= 0 && k >= 0) {
+               this.elementClicked(l, false, this.mouseX, this.mouseY);
+               this.selectedElement = l;
+            } else if (this.mouseX >= i && this.mouseX <= j && k < 0) {
+               this.clickedHeader(this.mouseX - i, this.mouseY - this.top + (int)this.amountScrolled - 4);
             }
          }
 
          if (!Mouse.isButtonDown(0) || !this.getEnabled()) {
             this.initialClickY = -1;
          } else if (this.initialClickY == -1) {
-            boolean ☃ = true;
+            boolean flag1 = true;
             if (this.mouseY >= this.top && this.mouseY <= this.bottom) {
-               int ☃x = (this.width - this.getListWidth()) / 2;
-               int ☃xx = (this.width + this.getListWidth()) / 2;
-               int ☃xxx = this.mouseY - this.top - this.headerPadding + (int)this.amountScrolled - 4;
-               int ☃xxxx = ☃xxx / this.slotHeight;
-               if (☃xxxx < this.getSize() && this.mouseX >= ☃x && this.mouseX <= ☃xx && ☃xxxx >= 0 && ☃xxx >= 0) {
-                  boolean ☃xxxxx = ☃xxxx == this.selectedElement && Minecraft.getSystemTime() - this.lastClicked < 250L;
-                  this.elementClicked(☃xxxx, ☃xxxxx, this.mouseX, this.mouseY);
-                  this.selectedElement = ☃xxxx;
+               int j2 = (this.width - this.getListWidth()) / 2;
+               int k2 = (this.width + this.getListWidth()) / 2;
+               int l2 = this.mouseY - this.top - this.headerPadding + (int)this.amountScrolled - 4;
+               int i1 = l2 / this.slotHeight;
+               if (i1 < this.getSize() && this.mouseX >= j2 && this.mouseX <= k2 && i1 >= 0 && l2 >= 0) {
+                  boolean flag = i1 == this.selectedElement && Minecraft.getSystemTime() - this.lastClicked < 250L;
+                  this.elementClicked(i1, flag, this.mouseX, this.mouseY);
+                  this.selectedElement = i1;
                   this.lastClicked = Minecraft.getSystemTime();
-               } else if (this.mouseX >= ☃x && this.mouseX <= ☃xx && ☃xxx < 0) {
-                  this.clickedHeader(this.mouseX - ☃x, this.mouseY - this.top + (int)this.amountScrolled - 4);
-                  ☃ = false;
+               } else if (this.mouseX >= j2 && this.mouseX <= k2 && l2 < 0) {
+                  this.clickedHeader(this.mouseX - j2, this.mouseY - this.top + (int)this.amountScrolled - 4);
+                  flag1 = false;
                }
 
-               int ☃xxxxx = this.getScrollBarX();
-               int ☃xxxxxx = ☃xxxxx + 6;
-               if (this.mouseX >= ☃xxxxx && this.mouseX <= ☃xxxxxx) {
+               int i3 = this.getScrollBarX();
+               int j1 = i3 + 6;
+               if (this.mouseX >= i3 && this.mouseX <= j1) {
                   this.scrollMultiplier = -1.0F;
-                  int ☃xxxxxxx = this.getMaxScroll();
-                  if (☃xxxxxxx < 1) {
-                     ☃xxxxxxx = 1;
+                  int k1 = this.getMaxScroll();
+                  if (k1 < 1) {
+                     k1 = 1;
                   }
 
-                  int ☃xxxxxxxx = (int)((float)((this.bottom - this.top) * (this.bottom - this.top)) / this.getContentHeight());
-                  ☃xxxxxxxx = MathHelper.clamp(☃xxxxxxxx, 32, this.bottom - this.top - 8);
-                  this.scrollMultiplier = this.scrollMultiplier / ((float)(this.bottom - this.top - ☃xxxxxxxx) / ☃xxxxxxx);
+                  int l1 = (int)((float)((this.bottom - this.top) * (this.bottom - this.top)) / this.getContentHeight());
+                  l1 = MathHelper.clamp(l1, 32, this.bottom - this.top - 8);
+                  this.scrollMultiplier = this.scrollMultiplier / ((float)(this.bottom - this.top - l1) / k1);
                } else {
                   this.scrollMultiplier = 1.0F;
                }
 
-               if (☃) {
+               if (flag1) {
                   this.initialClickY = this.mouseY;
                } else {
                   this.initialClickY = -2;
@@ -294,21 +286,21 @@ public void handleMouseInput() {
             this.initialClickY = this.mouseY;
          }
 
-         int ☃ = Mouse.getEventDWheel();
-         if (☃ != 0) {
-            if (☃ > 0) {
-               ☃ = -1;
-            } else if (☃ < 0) {
-               ☃ = 1;
+         int i2 = Mouse.getEventDWheel();
+         if (i2 != 0) {
+            if (i2 > 0) {
+               i2 = -1;
+            } else if (i2 < 0) {
+               i2 = 1;
             }
 
-            this.amountScrolled = this.amountScrolled + ☃ * this.slotHeight / 2;
+            this.amountScrolled = this.amountScrolled + i2 * this.slotHeight / 2;
          }
       }
    }
 
-   public void setEnabled(boolean var1) {
-      this.enabled = ☃;
+   public void setEnabled(boolean enabledIn) {
+      this.enabled = enabledIn;
    }
 
    public boolean getEnabled() {
@@ -319,37 +311,39 @@ public int getListWidth() {
       return 220;
    }
 
-   protected void drawSelectionBox(int var1, int var2, int var3, int var4, float var5) {
-      int ☃ = this.getSize();
-      Tessellator ☃x = Tessellator.getInstance();
-      BufferBuilder ☃xx = ☃x.getBuffer();
+   protected void drawSelectionBox(int insideLeft, int insideTop, int mouseXIn, int mouseYIn, float partialTicks) {
+      int i = this.getSize();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
 
-      for (int ☃xxx = 0; ☃xxx < ☃; ☃xxx++) {
-         int ☃xxxx = ☃ + ☃xxx * this.slotHeight + this.headerPadding;
-         int ☃xxxxx = this.slotHeight - 4;
-         if (☃xxxx > this.bottom || ☃xxxx + ☃xxxxx < this.top) {
-            this.updateItemPos(☃xxx, ☃, ☃xxxx, ☃);
+      for (int j = 0; j < i; j++) {
+         int k = insideTop + j * this.slotHeight + this.headerPadding;
+         int l = this.slotHeight - 4;
+         if (k > this.bottom || k + l < this.top) {
+            this.updateItemPos(j, insideLeft, k, partialTicks);
          }
 
-         if (this.showSelectionBox && this.isSelected(☃xxx)) {
-            int ☃xxxxxx = this.left + (this.width / 2 - this.getListWidth() / 2);
-            int ☃xxxxxxx = this.left + this.width / 2 + this.getListWidth() / 2;
+         if (this.showSelectionBox && this.isSelected(j)) {
+            int i1 = this.left + (this.width / 2 - this.getListWidth() / 2);
+            int j1 = this.left + this.width / 2 + this.getListWidth() / 2;
             GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
             GlStateManager.disableTexture2D();
-            ☃xx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            ☃xx.pos(☃xxxxxx, ☃xxxx + ☃xxxxx + 2, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
-            ☃xx.pos(☃xxxxxxx, ☃xxxx + ☃xxxxx + 2, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
-            ☃xx.pos(☃xxxxxxx, ☃xxxx - 2, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
-            ☃xx.pos(☃xxxxxx, ☃xxxx - 2, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
-            ☃xx.pos(☃xxxxxx + 1, ☃xxxx + ☃xxxxx + 1, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xx.pos(☃xxxxxxx - 1, ☃xxxx + ☃xxxxx + 1, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xx.pos(☃xxxxxxx - 1, ☃xxxx - 1, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
-            ☃xx.pos(☃xxxxxx + 1, ☃xxxx - 1, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
-            ☃x.draw();
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            bufferbuilder.pos(i1, k + l + 2, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(j1, k + l + 2, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(j1, k - 2, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(i1, k - 2, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
+            bufferbuilder.pos(i1 + 1, k + l + 1, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(j1 - 1, k + l + 1, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(j1 - 1, k - 1, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(i1 + 1, k - 1, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
+            tessellator.draw();
             GlStateManager.enableTexture2D();
          }
 
-         this.drawSlot(☃xxx, ☃, ☃xxxx, ☃xxxxx, ☃, ☃, ☃);
+         if (!(this instanceof GuiResourcePackList) || k >= this.top - this.slotHeight && k <= this.bottom) {
+            this.drawSlot(j, insideLeft, k, l, mouseXIn, mouseYIn, partialTicks);
+         }
       }
    }
 
@@ -357,26 +351,45 @@ protected int getScrollBarX() {
       return this.width / 2 + 124;
    }
 
-   protected void overlayBackground(int var1, int var2, int var3, int var4) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+   protected void overlayBackground(int startY, int endY, int startAlpha, int endAlpha) {
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      float ☃xx = 32.0F;
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-      ☃x.pos(this.left, ☃, 0.0).tex(0.0, ☃ / 32.0F).color(64, 64, 64, ☃).endVertex();
-      ☃x.pos(this.left + this.width, ☃, 0.0).tex(this.width / 32.0F, ☃ / 32.0F).color(64, 64, 64, ☃).endVertex();
-      ☃x.pos(this.left + this.width, ☃, 0.0).tex(this.width / 32.0F, ☃ / 32.0F).color(64, 64, 64, ☃).endVertex();
-      ☃x.pos(this.left, ☃, 0.0).tex(0.0, ☃ / 32.0F).color(64, 64, 64, ☃).endVertex();
-      ☃.draw();
+      float f = 32.0F;
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      bufferbuilder.pos(this.left, endY, 0.0).tex(0.0, endY / 32.0F).color(64, 64, 64, endAlpha).endVertex();
+      bufferbuilder.pos(this.left + this.width, endY, 0.0).tex(this.width / 32.0F, endY / 32.0F).color(64, 64, 64, endAlpha).endVertex();
+      bufferbuilder.pos(this.left + this.width, startY, 0.0).tex(this.width / 32.0F, startY / 32.0F).color(64, 64, 64, startAlpha).endVertex();
+      bufferbuilder.pos(this.left, startY, 0.0).tex(0.0, startY / 32.0F).color(64, 64, 64, startAlpha).endVertex();
+      tessellator.draw();
    }
 
-   public void setSlotXBoundsFromLeft(int var1) {
-      this.left = ☃;
-      this.right = ☃ + this.width;
+   public void setSlotXBoundsFromLeft(int leftIn) {
+      this.left = leftIn;
+      this.right = leftIn + this.width;
    }
 
    public int getSlotHeight() {
       return this.slotHeight;
    }
+
+   protected void drawContainerBackground(Tessellator tessellator) {
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
+      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+      float f = 32.0F;
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      bufferbuilder.pos(this.left, this.bottom, 0.0)
+         .tex(this.left / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F)
+         .color(32, 32, 32, 255)
+         .endVertex();
+      bufferbuilder.pos(this.right, this.bottom, 0.0)
+         .tex(this.right / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F)
+         .color(32, 32, 32, 255)
+         .endVertex();
+      bufferbuilder.pos(this.right, this.top, 0.0).tex(this.right / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      bufferbuilder.pos(this.left, this.top, 0.0).tex(this.left / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      tessellator.draw();
+   }
 }
diff --git a/patches/net/minecraft/client/gui/GuiVideoSettings.java b/patches/net/minecraft/client/gui/GuiVideoSettings.java
index b53a4b4..7ec4bf2 100644
--- a/patches/net/minecraft/client/gui/GuiVideoSettings.java
+++ b/patches/net/minecraft/client/gui/GuiVideoSettings.java
@@ -1,118 +1,209 @@
 package net.minecraft.client.gui;
 
-import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.settings.GameSettings;
+import net.optifine.Lang;
+import net.optifine.gui.GuiAnimationSettingsOF;
+import net.optifine.gui.GuiDetailSettingsOF;
+import net.optifine.gui.GuiOptionButtonOF;
+import net.optifine.gui.GuiOptionSliderOF;
+import net.optifine.gui.GuiOtherSettingsOF;
+import net.optifine.gui.GuiPerformanceSettingsOF;
+import net.optifine.gui.GuiQualitySettingsOF;
+import net.optifine.gui.GuiScreenOF;
+import net.optifine.gui.TooltipManager;
+import net.optifine.gui.TooltipProviderOptions;
+import net.optifine.shaders.gui.GuiShaders;
 
-public class GuiVideoSettings extends GuiScreen {
-   private final GuiScreen parentGuiScreen;
+public class GuiVideoSettings extends GuiScreenOF {
+   private GuiScreen parentGuiScreen;
    protected String screenTitle = "Video Settings";
-   private final GameSettings guiGameSettings;
-   private GuiListExtended optionsRowList;
-   private static final GameSettings.Options[] VIDEO_OPTIONS = new GameSettings.Options[]{
+   private GameSettings guiGameSettings;
+   private static GameSettings.Options[] videoOptions = new GameSettings.Options[]{
       GameSettings.Options.GRAPHICS,
       GameSettings.Options.RENDER_DISTANCE,
       GameSettings.Options.AMBIENT_OCCLUSION,
       GameSettings.Options.FRAMERATE_LIMIT,
-      GameSettings.Options.ANAGLYPH,
+      GameSettings.Options.AO_LEVEL,
       GameSettings.Options.VIEW_BOBBING,
       GameSettings.Options.GUI_SCALE,
-      GameSettings.Options.ATTACK_INDICATOR,
-      GameSettings.Options.GAMMA,
-      GameSettings.Options.RENDER_CLOUDS,
-      GameSettings.Options.PARTICLES,
-      GameSettings.Options.USE_FULLSCREEN,
-      GameSettings.Options.ENABLE_VSYNC,
-      GameSettings.Options.MIPMAP_LEVELS,
       GameSettings.Options.USE_VBO,
-      GameSettings.Options.ENTITY_SHADOWS
+      GameSettings.Options.GAMMA,
+      GameSettings.Options.ATTACK_INDICATOR,
+      GameSettings.Options.DYNAMIC_LIGHTS,
+      GameSettings.Options.DYNAMIC_FOV
    };
+   private static final String __OBFID = "CL_00000718";
+   private TooltipManager tooltipManager = new TooltipManager(this, new TooltipProviderOptions());
 
-   public GuiVideoSettings(GuiScreen var1, GameSettings var2) {
-      this.parentGuiScreen = ☃;
-      this.guiGameSettings = ☃;
+   public GuiVideoSettings(GuiScreen par1GuiScreen, GameSettings par2GameSettings) {
+      this.parentGuiScreen = par1GuiScreen;
+      this.guiGameSettings = par2GameSettings;
    }
 
-   @Override
    public void initGui() {
       this.screenTitle = I18n.format("options.videoTitle");
       this.buttonList.clear();
-      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height - 27, I18n.format("gui.done")));
-      if (OpenGlHelper.vboSupported) {
-         this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, VIDEO_OPTIONS);
-      } else {
-         GameSettings.Options[] ☃ = new GameSettings.Options[VIDEO_OPTIONS.length - 1];
-         int ☃x = 0;
-
-         for (GameSettings.Options ☃xx : VIDEO_OPTIONS) {
-            if (☃xx == GameSettings.Options.USE_VBO) {
-               break;
-            }
 
-            ☃[☃x] = ☃xx;
-            ☃x++;
+      for (int i = 0; i < videoOptions.length; i++) {
+         GameSettings.Options opt = videoOptions[i];
+         if (opt != null) {
+            int x = this.width / 2 - 155 + i % 2 * 160;
+            int y = this.height / 6 + 21 * (i / 2) - 12;
+            if (opt.isFloat()) {
+               this.buttonList.add(new GuiOptionSliderOF(opt.getOrdinal(), x, y, opt));
+            } else {
+               this.buttonList.add(new GuiOptionButtonOF(opt.getOrdinal(), x, y, opt, this.guiGameSettings.getKeyBinding(opt)));
+            }
          }
-
-         this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, ☃);
       }
+
+      int y = this.height / 6 + 21 * (videoOptions.length / 2) - 12;
+      int x = 0;
+      x = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(231, x, y, Lang.get("of.options.shaders")));
+      x = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(202, x, y, Lang.get("of.options.quality")));
+      y += 21;
+      x = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(201, x, y, Lang.get("of.options.details")));
+      x = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(212, x, y, Lang.get("of.options.performance")));
+      y += 21;
+      x = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(211, x, y, Lang.get("of.options.animations")));
+      x = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(222, x, y, Lang.get("of.options.other")));
+      y += 21;
+      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168 + 11, I18n.format("gui.done")));
    }
 
-   @Override
-   public void handleMouseInput() {
-      super.handleMouseInput();
-      this.optionsRowList.handleMouseInput();
+   protected void actionPerformed(GuiButton button) {
+      this.actionPerformed(button, 1);
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
-      if (☃ == 1) {
-         this.mc.gameSettings.saveOptions();
+   protected void actionPerformedRightClick(GuiButton button) {
+      if (button.id == GameSettings.Options.GUI_SCALE.ordinal()) {
+         this.actionPerformed(button, -1);
       }
-
-      super.keyTyped(☃, ☃);
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
-      if (☃.enabled) {
-         if (☃.id == 200) {
+   private void actionPerformed(GuiButton button, int val) {
+      if (button.enabled) {
+         int guiScale = this.guiGameSettings.guiScale;
+         if (button.id < 200 && button instanceof GuiOptionButton) {
+            this.guiGameSettings.setOptionValue(((GuiOptionButton)button).getOption(), val);
+            button.displayString = this.guiGameSettings.getKeyBinding(GameSettings.Options.byOrdinal(button.id));
+         }
+
+         if (button.id == 200) {
             this.mc.gameSettings.saveOptions();
             this.mc.displayGuiScreen(this.parentGuiScreen);
          }
+
+         if (this.guiGameSettings.guiScale != guiScale) {
+            ScaledResolution var3 = new ScaledResolution(this.mc);
+            int var4 = var3.getScaledWidth();
+            int var5 = var3.getScaledHeight();
+            this.setWorldAndResolution(this.mc, var4, var5);
+         }
+
+         if (button.id == 201) {
+            this.mc.gameSettings.saveOptions();
+            GuiDetailSettingsOF scr = new GuiDetailSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
+
+         if (button.id == 202) {
+            this.mc.gameSettings.saveOptions();
+            GuiQualitySettingsOF scr = new GuiQualitySettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
+
+         if (button.id == 211) {
+            this.mc.gameSettings.saveOptions();
+            GuiAnimationSettingsOF scr = new GuiAnimationSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
+
+         if (button.id == 212) {
+            this.mc.gameSettings.saveOptions();
+            GuiPerformanceSettingsOF scr = new GuiPerformanceSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
+
+         if (button.id == 222) {
+            this.mc.gameSettings.saveOptions();
+            GuiOtherSettingsOF scr = new GuiOtherSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
+
+         if (button.id == 231) {
+            if (Config.isAntialiasing() || Config.isAntialiasingConfigured()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.aa1"), Lang.get("of.message.shaders.aa2"));
+               return;
+            }
+
+            if (Config.isAnisotropicFiltering()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.af1"), Lang.get("of.message.shaders.af2"));
+               return;
+            }
+
+            if (Config.isFastRender()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.fr1"), Lang.get("of.message.shaders.fr2"));
+               return;
+            }
+
+            if (Config.getGameSettings().anaglyph) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.an1"), Lang.get("of.message.shaders.an2"));
+               return;
+            }
+
+            this.mc.gameSettings.saveOptions();
+            GuiShaders scr = new GuiShaders(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(scr);
+         }
       }
    }
 
-   @Override
-   protected void mouseClicked(int var1, int var2, int var3) {
-      int ☃ = this.guiGameSettings.guiScale;
-      super.mouseClicked(☃, ☃, ☃);
-      this.optionsRowList.mouseClicked(☃, ☃, ☃);
-      if (this.guiGameSettings.guiScale != ☃) {
-         ScaledResolution ☃x = new ScaledResolution(this.mc);
-         int ☃xx = ☃x.getScaledWidth();
-         int ☃xxx = ☃x.getScaledHeight();
-         this.setWorldAndResolution(this.mc, ☃xx, ☃xxx);
+   public void drawScreen(int x, int y, float z) {
+      this.drawDefaultBackground();
+      this.a(this.fontRenderer, this.screenTitle, this.width / 2, 15, 16777215);
+      String ver = Config.getVersion();
+      String ed = "HD_U";
+      if (ed.equals("HD")) {
+         ver = "OptiFine HD G5";
+      }
+
+      if (ed.equals("HD_U")) {
+         ver = "OptiFine HD G5 Ultra";
       }
-   }
 
-   @Override
-   protected void mouseReleased(int var1, int var2, int var3) {
-      int ☃ = this.guiGameSettings.guiScale;
-      super.mouseReleased(☃, ☃, ☃);
-      this.optionsRowList.mouseReleased(☃, ☃, ☃);
-      if (this.guiGameSettings.guiScale != ☃) {
-         ScaledResolution ☃x = new ScaledResolution(this.mc);
-         int ☃xx = ☃x.getScaledWidth();
-         int ☃xxx = ☃x.getScaledHeight();
-         this.setWorldAndResolution(this.mc, ☃xx, ☃xxx);
+      if (ed.equals("L")) {
+         ver = "OptiFine G5 Light";
       }
+
+      this.c(this.fontRenderer, ver, 2, this.height - 10, 8421504);
+      String verMc = "Minecraft 1.12.2";
+      int lenMc = this.fontRenderer.getStringWidth(verMc);
+      this.c(this.fontRenderer, verMc, this.width - lenMc - 2, this.height - 10, 8421504);
+      super.drawScreen(x, y, z);
+      this.tooltipManager.drawTooltips(x, y, this.buttonList);
    }
 
-   @Override
-   public void drawScreen(int var1, int var2, float var3) {
-      this.drawDefaultBackground();
-      this.optionsRowList.drawScreen(☃, ☃, ☃);
-      this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 5, 16777215);
-      super.drawScreen(☃, ☃, ☃);
+   public static int getButtonWidth(GuiButton btn) {
+      return btn.width;
+   }
+
+   public static int getButtonHeight(GuiButton btn) {
+      return btn.height;
+   }
+
+   public static void drawGradientRect(GuiScreen guiScreen, int left, int top, int right, int bottom, int startColor, int endColor) {
+      guiScreen.a(left, top, right, bottom, startColor, endColor);
+   }
+
+   public static String getGuiChatText(GuiChat guiChat) {
+      return guiChat.inputField.getText();
    }
 }
diff --git a/patches/net/minecraft/client/model/ModelBox.java b/patches/net/minecraft/client/model/ModelBox.java
index 78e9b6d..4de7f79 100644
--- a/patches/net/minecraft/client/model/ModelBox.java
+++ b/patches/net/minecraft/client/model/ModelBox.java
@@ -13,89 +13,198 @@ public class ModelBox {
    public final float posZ2;
    public String boxName;
 
-   public ModelBox(ModelRenderer var1, int var2, int var3, float var4, float var5, float var6, int var7, int var8, int var9, float var10) {
-      this(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃.mirror);
+   public ModelBox(ModelRenderer renderer, int texU, int texV, float x, float y, float z, int dx, int dy, int dz, float delta) {
+      this(renderer, texU, texV, x, y, z, dx, dy, dz, delta, renderer.mirror);
    }
 
-   public ModelBox(ModelRenderer var1, int var2, int var3, float var4, float var5, float var6, int var7, int var8, int var9, float var10, boolean var11) {
-      this.posX1 = ☃;
-      this.posY1 = ☃;
-      this.posZ1 = ☃;
-      this.posX2 = ☃ + ☃;
-      this.posY2 = ☃ + ☃;
-      this.posZ2 = ☃ + ☃;
+   public ModelBox(ModelRenderer renderer, int[][] faceUvs, float x, float y, float z, float dx, float dy, float dz, float delta, boolean mirror) {
+      this.posX1 = x;
+      this.posY1 = y;
+      this.posZ1 = z;
+      this.posX2 = x + dx;
+      this.posY2 = y + dy;
+      this.posZ2 = z + dz;
       this.vertexPositions = new PositionTextureVertex[8];
       this.quadList = new TexturedQuad[6];
-      float ☃ = ☃ + ☃;
-      float ☃x = ☃ + ☃;
-      float ☃xx = ☃ + ☃;
-      ☃ -= ☃;
-      ☃ -= ☃;
-      ☃ -= ☃;
-      ☃ += ☃;
-      ☃x += ☃;
-      ☃xx += ☃;
-      if (☃) {
-         float ☃xxx = ☃;
-         ☃ = ☃;
-         ☃ = ☃xxx;
+      float f = x + dx;
+      float f1 = y + dy;
+      float f2 = z + dz;
+      x -= delta;
+      y -= delta;
+      z -= delta;
+      f += delta;
+      f1 += delta;
+      f2 += delta;
+      if (mirror) {
+         float f3 = f;
+         f = x;
+         x = f3;
       }
 
-      PositionTextureVertex ☃xxx = new PositionTextureVertex(☃, ☃, ☃, 0.0F, 0.0F);
-      PositionTextureVertex ☃xxxx = new PositionTextureVertex(☃, ☃, ☃, 0.0F, 8.0F);
-      PositionTextureVertex ☃xxxxx = new PositionTextureVertex(☃, ☃x, ☃, 8.0F, 8.0F);
-      PositionTextureVertex ☃xxxxxx = new PositionTextureVertex(☃, ☃x, ☃, 8.0F, 0.0F);
-      PositionTextureVertex ☃xxxxxxx = new PositionTextureVertex(☃, ☃, ☃xx, 0.0F, 0.0F);
-      PositionTextureVertex ☃xxxxxxxx = new PositionTextureVertex(☃, ☃, ☃xx, 0.0F, 8.0F);
-      PositionTextureVertex ☃xxxxxxxxx = new PositionTextureVertex(☃, ☃x, ☃xx, 8.0F, 8.0F);
-      PositionTextureVertex ☃xxxxxxxxxx = new PositionTextureVertex(☃, ☃x, ☃xx, 8.0F, 0.0F);
-      this.vertexPositions[0] = ☃xxx;
-      this.vertexPositions[1] = ☃xxxx;
-      this.vertexPositions[2] = ☃xxxxx;
-      this.vertexPositions[3] = ☃xxxxxx;
-      this.vertexPositions[4] = ☃xxxxxxx;
-      this.vertexPositions[5] = ☃xxxxxxxx;
-      this.vertexPositions[6] = ☃xxxxxxxxx;
-      this.vertexPositions[7] = ☃xxxxxxxxxx;
+      PositionTextureVertex pos0 = new PositionTextureVertex(x, y, z, 0.0F, 0.0F);
+      PositionTextureVertex pos1 = new PositionTextureVertex(f, y, z, 0.0F, 8.0F);
+      PositionTextureVertex pos2 = new PositionTextureVertex(f, f1, z, 8.0F, 8.0F);
+      PositionTextureVertex pos3 = new PositionTextureVertex(x, f1, z, 8.0F, 0.0F);
+      PositionTextureVertex pos4 = new PositionTextureVertex(x, y, f2, 0.0F, 0.0F);
+      PositionTextureVertex pos5 = new PositionTextureVertex(f, y, f2, 0.0F, 8.0F);
+      PositionTextureVertex pos6 = new PositionTextureVertex(f, f1, f2, 8.0F, 8.0F);
+      PositionTextureVertex pos7 = new PositionTextureVertex(x, f1, f2, 8.0F, 0.0F);
+      this.vertexPositions[0] = pos0;
+      this.vertexPositions[1] = pos1;
+      this.vertexPositions[2] = pos2;
+      this.vertexPositions[3] = pos3;
+      this.vertexPositions[4] = pos4;
+      this.vertexPositions[5] = pos5;
+      this.vertexPositions[6] = pos6;
+      this.vertexPositions[7] = pos7;
+      this.quadList[0] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos5, pos1, pos2, pos6}, faceUvs[4], false, renderer.textureWidth, renderer.textureHeight
+      );
+      this.quadList[1] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos0, pos4, pos7, pos3}, faceUvs[5], false, renderer.textureWidth, renderer.textureHeight
+      );
+      this.quadList[2] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos5, pos4, pos0, pos1}, faceUvs[1], true, renderer.textureWidth, renderer.textureHeight
+      );
+      this.quadList[3] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos2, pos3, pos7, pos6}, faceUvs[0], true, renderer.textureWidth, renderer.textureHeight
+      );
+      this.quadList[4] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos1, pos0, pos3, pos2}, faceUvs[2], false, renderer.textureWidth, renderer.textureHeight
+      );
+      this.quadList[5] = this.makeTexturedQuad(
+         new PositionTextureVertex[]{pos4, pos5, pos6, pos7}, faceUvs[3], false, renderer.textureWidth, renderer.textureHeight
+      );
+      if (mirror) {
+         for (TexturedQuad texturedquad : this.quadList) {
+            texturedquad.flipFace();
+         }
+      }
+   }
+
+   private TexturedQuad makeTexturedQuad(
+      PositionTextureVertex[] positionTextureVertexs, int[] faceUvs, boolean reverseUV, float textureWidth, float textureHeight
+   ) {
+      if (faceUvs == null) {
+         return null;
+      } else {
+         return reverseUV
+            ? new TexturedQuad(positionTextureVertexs, faceUvs[2], faceUvs[3], faceUvs[0], faceUvs[1], textureWidth, textureHeight)
+            : new TexturedQuad(positionTextureVertexs, faceUvs[0], faceUvs[1], faceUvs[2], faceUvs[3], textureWidth, textureHeight);
+      }
+   }
+
+   public ModelBox(ModelRenderer renderer, int texU, int texV, float x, float y, float z, int dx, int dy, int dz, float delta, boolean mirror) {
+      this.posX1 = x;
+      this.posY1 = y;
+      this.posZ1 = z;
+      this.posX2 = x + dx;
+      this.posY2 = y + dy;
+      this.posZ2 = z + dz;
+      this.vertexPositions = new PositionTextureVertex[8];
+      this.quadList = new TexturedQuad[6];
+      float f = x + dx;
+      float f1 = y + dy;
+      float f2 = z + dz;
+      x -= delta;
+      y -= delta;
+      z -= delta;
+      f += delta;
+      f1 += delta;
+      f2 += delta;
+      if (mirror) {
+         float f3 = f;
+         f = x;
+         x = f3;
+      }
+
+      PositionTextureVertex positiontexturevertex7 = new PositionTextureVertex(x, y, z, 0.0F, 0.0F);
+      PositionTextureVertex positiontexturevertex = new PositionTextureVertex(f, y, z, 0.0F, 8.0F);
+      PositionTextureVertex positiontexturevertex1 = new PositionTextureVertex(f, f1, z, 8.0F, 8.0F);
+      PositionTextureVertex positiontexturevertex2 = new PositionTextureVertex(x, f1, z, 8.0F, 0.0F);
+      PositionTextureVertex positiontexturevertex3 = new PositionTextureVertex(x, y, f2, 0.0F, 0.0F);
+      PositionTextureVertex positiontexturevertex4 = new PositionTextureVertex(f, y, f2, 0.0F, 8.0F);
+      PositionTextureVertex positiontexturevertex5 = new PositionTextureVertex(f, f1, f2, 8.0F, 8.0F);
+      PositionTextureVertex positiontexturevertex6 = new PositionTextureVertex(x, f1, f2, 8.0F, 0.0F);
+      this.vertexPositions[0] = positiontexturevertex7;
+      this.vertexPositions[1] = positiontexturevertex;
+      this.vertexPositions[2] = positiontexturevertex1;
+      this.vertexPositions[3] = positiontexturevertex2;
+      this.vertexPositions[4] = positiontexturevertex3;
+      this.vertexPositions[5] = positiontexturevertex4;
+      this.vertexPositions[6] = positiontexturevertex5;
+      this.vertexPositions[7] = positiontexturevertex6;
       this.quadList[0] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxxxxxxx, ☃xxxx, ☃xxxxx, ☃xxxxxxxxx}, ☃ + ☃ + ☃, ☃ + ☃, ☃ + ☃ + ☃ + ☃, ☃ + ☃ + ☃, ☃.textureWidth, ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex4, positiontexturevertex, positiontexturevertex1, positiontexturevertex5},
+         texU + dz + dx,
+         texV + dz,
+         texU + dz + dx + dz,
+         texV + dz + dy,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
       this.quadList[1] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxx, ☃xxxxxxx, ☃xxxxxxxxxx, ☃xxxxxx}, ☃, ☃ + ☃, ☃ + ☃, ☃ + ☃ + ☃, ☃.textureWidth, ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex7, positiontexturevertex3, positiontexturevertex6, positiontexturevertex2},
+         texU,
+         texV + dz,
+         texU + dz,
+         texV + dz + dy,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
       this.quadList[2] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxxxxxxx, ☃xxxxxxx, ☃xxx, ☃xxxx}, ☃ + ☃, ☃, ☃ + ☃ + ☃, ☃ + ☃, ☃.textureWidth, ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex4, positiontexturevertex3, positiontexturevertex7, positiontexturevertex},
+         texU + dz,
+         texV,
+         texU + dz + dx,
+         texV + dz,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
       this.quadList[3] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxxxx, ☃xxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxx}, ☃ + ☃ + ☃, ☃ + ☃, ☃ + ☃ + ☃ + ☃, ☃, ☃.textureWidth, ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex1, positiontexturevertex2, positiontexturevertex6, positiontexturevertex5},
+         texU + dz + dx,
+         texV + dz,
+         texU + dz + dx + dx,
+         texV,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
       this.quadList[4] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxxx, ☃xxx, ☃xxxxxx, ☃xxxxx}, ☃ + ☃, ☃ + ☃, ☃ + ☃ + ☃, ☃ + ☃ + ☃, ☃.textureWidth, ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex, positiontexturevertex7, positiontexturevertex2, positiontexturevertex1},
+         texU + dz,
+         texV + dz,
+         texU + dz + dx,
+         texV + dz + dy,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
       this.quadList[5] = new TexturedQuad(
-         new PositionTextureVertex[]{☃xxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx},
-         ☃ + ☃ + ☃ + ☃,
-         ☃ + ☃,
-         ☃ + ☃ + ☃ + ☃ + ☃,
-         ☃ + ☃ + ☃,
-         ☃.textureWidth,
-         ☃.textureHeight
+         new PositionTextureVertex[]{positiontexturevertex3, positiontexturevertex4, positiontexturevertex5, positiontexturevertex6},
+         texU + dz + dx + dz,
+         texV + dz,
+         texU + dz + dx + dz + dx,
+         texV + dz + dy,
+         renderer.textureWidth,
+         renderer.textureHeight
       );
-      if (☃) {
-         for (TexturedQuad ☃xxxxxxxxxxx : this.quadList) {
-            ☃xxxxxxxxxxx.flipFace();
+      if (mirror) {
+         for (TexturedQuad texturedquad : this.quadList) {
+            texturedquad.flipFace();
          }
       }
    }
 
-   public void render(BufferBuilder var1, float var2) {
-      for (TexturedQuad ☃ : this.quadList) {
-         ☃.draw(☃, ☃);
+   public void render(BufferBuilder renderer, float scale) {
+      for (TexturedQuad texturedquad : this.quadList) {
+         if (texturedquad != null) {
+            texturedquad.draw(renderer, scale);
+         }
       }
    }
 
-   public ModelBox setBoxName(String var1) {
-      this.boxName = ☃;
+   public ModelBox setBoxName(String name) {
+      this.boxName = name;
       return this;
    }
 }
diff --git a/patches/net/minecraft/client/model/ModelPlayer.java b/patches/net/minecraft/client/model/ModelPlayer.java
index 4fde081..fd92167 100644
--- a/patches/net/minecraft/client/model/ModelPlayer.java
+++ b/patches/net/minecraft/client/model/ModelPlayer.java
@@ -14,129 +14,122 @@ public class ModelPlayer extends ModelBiped {
    private final ModelRenderer bipedDeadmau5Head;
    private final boolean smallArms;
 
-   public ModelPlayer(float var1, boolean var2) {
-      super(☃, 0.0F, 64, 64);
-      this.smallArms = ☃;
+   public ModelPlayer(float modelSize, boolean smallArmsIn) {
+      super(modelSize, 0.0F, 64, 64);
+      this.smallArms = smallArmsIn;
       this.bipedDeadmau5Head = new ModelRenderer(this, 24, 0);
-      this.bipedDeadmau5Head.addBox(-3.0F, -6.0F, -1.0F, 6, 6, 1, ☃);
+      this.bipedDeadmau5Head.addBox(-3.0F, -6.0F, -1.0F, 6, 6, 1, modelSize);
       this.bipedCape = new ModelRenderer(this, 0, 0);
       this.bipedCape.setTextureSize(64, 32);
-      this.bipedCape.addBox(-5.0F, 0.0F, -1.0F, 10, 16, 1, ☃);
-      if (☃) {
+      this.bipedCape.addBox(-5.0F, 0.0F, -1.0F, 10, 16, 1, modelSize);
+      if (smallArmsIn) {
          this.bipedLeftArm = new ModelRenderer(this, 32, 48);
-         this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, ☃);
+         this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, modelSize);
          this.bipedLeftArm.setRotationPoint(5.0F, 2.5F, 0.0F);
          this.bipedRightArm = new ModelRenderer(this, 40, 16);
-         this.bipedRightArm.addBox(-2.0F, -2.0F, -2.0F, 3, 12, 4, ☃);
+         this.bipedRightArm.addBox(-2.0F, -2.0F, -2.0F, 3, 12, 4, modelSize);
          this.bipedRightArm.setRotationPoint(-5.0F, 2.5F, 0.0F);
          this.bipedLeftArmwear = new ModelRenderer(this, 48, 48);
-         this.bipedLeftArmwear.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, ☃ + 0.25F);
+         this.bipedLeftArmwear.addBox(-1.0F, -2.0F, -2.0F, 3, 12, 4, modelSize + 0.25F);
          this.bipedLeftArmwear.setRotationPoint(5.0F, 2.5F, 0.0F);
          this.bipedRightArmwear = new ModelRenderer(this, 40, 32);
-         this.bipedRightArmwear.addBox(-2.0F, -2.0F, -2.0F, 3, 12, 4, ☃ + 0.25F);
+         this.bipedRightArmwear.addBox(-2.0F, -2.0F, -2.0F, 3, 12, 4, modelSize + 0.25F);
          this.bipedRightArmwear.setRotationPoint(-5.0F, 2.5F, 10.0F);
       } else {
          this.bipedLeftArm = new ModelRenderer(this, 32, 48);
-         this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, ☃);
+         this.bipedLeftArm.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, modelSize);
          this.bipedLeftArm.setRotationPoint(5.0F, 2.0F, 0.0F);
          this.bipedLeftArmwear = new ModelRenderer(this, 48, 48);
-         this.bipedLeftArmwear.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, ☃ + 0.25F);
+         this.bipedLeftArmwear.addBox(-1.0F, -2.0F, -2.0F, 4, 12, 4, modelSize + 0.25F);
          this.bipedLeftArmwear.setRotationPoint(5.0F, 2.0F, 0.0F);
          this.bipedRightArmwear = new ModelRenderer(this, 40, 32);
-         this.bipedRightArmwear.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, ☃ + 0.25F);
+         this.bipedRightArmwear.addBox(-3.0F, -2.0F, -2.0F, 4, 12, 4, modelSize + 0.25F);
          this.bipedRightArmwear.setRotationPoint(-5.0F, 2.0F, 10.0F);
       }
 
       this.bipedLeftLeg = new ModelRenderer(this, 16, 48);
-      this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, ☃);
+      this.bipedLeftLeg.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, modelSize);
       this.bipedLeftLeg.setRotationPoint(1.9F, 12.0F, 0.0F);
       this.bipedLeftLegwear = new ModelRenderer(this, 0, 48);
-      this.bipedLeftLegwear.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, ☃ + 0.25F);
+      this.bipedLeftLegwear.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, modelSize + 0.25F);
       this.bipedLeftLegwear.setRotationPoint(1.9F, 12.0F, 0.0F);
       this.bipedRightLegwear = new ModelRenderer(this, 0, 32);
-      this.bipedRightLegwear.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, ☃ + 0.25F);
+      this.bipedRightLegwear.addBox(-2.0F, 0.0F, -2.0F, 4, 12, 4, modelSize + 0.25F);
       this.bipedRightLegwear.setRotationPoint(-1.9F, 12.0F, 0.0F);
       this.bipedBodyWear = new ModelRenderer(this, 16, 32);
-      this.bipedBodyWear.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, ☃ + 0.25F);
+      this.bipedBodyWear.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, modelSize + 0.25F);
       this.bipedBodyWear.setRotationPoint(0.0F, 0.0F, 0.0F);
    }
 
-   @Override
-   public void render(Entity var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-      super.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale) {
+      super.render(entityIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
       GlStateManager.pushMatrix();
       if (this.isChild) {
-         float ☃ = 2.0F;
+         float f = 2.0F;
          GlStateManager.scale(0.5F, 0.5F, 0.5F);
-         GlStateManager.translate(0.0F, 24.0F * ☃, 0.0F);
-         this.bipedLeftLegwear.render(☃);
-         this.bipedRightLegwear.render(☃);
-         this.bipedLeftArmwear.render(☃);
-         this.bipedRightArmwear.render(☃);
-         this.bipedBodyWear.render(☃);
+         GlStateManager.translate(0.0F, 24.0F * scale, 0.0F);
+         this.bipedLeftLegwear.render(scale);
+         this.bipedRightLegwear.render(scale);
+         this.bipedLeftArmwear.render(scale);
+         this.bipedRightArmwear.render(scale);
+         this.bipedBodyWear.render(scale);
       } else {
-         if (☃.isSneaking()) {
+         if (entityIn.isSneaking()) {
             GlStateManager.translate(0.0F, 0.2F, 0.0F);
          }
 
-         this.bipedLeftLegwear.render(☃);
-         this.bipedRightLegwear.render(☃);
-         this.bipedLeftArmwear.render(☃);
-         this.bipedRightArmwear.render(☃);
-         this.bipedBodyWear.render(☃);
+         this.bipedLeftLegwear.render(scale);
+         this.bipedRightLegwear.render(scale);
+         this.bipedLeftArmwear.render(scale);
+         this.bipedRightArmwear.render(scale);
+         this.bipedBodyWear.render(scale);
       }
 
       GlStateManager.popMatrix();
    }
 
-   public void renderDeadmau5Head(float var1) {
+   public void renderDeadmau5Head(float scale) {
       copyModelAngles(this.bipedHead, this.bipedDeadmau5Head);
       this.bipedDeadmau5Head.rotationPointX = 0.0F;
       this.bipedDeadmau5Head.rotationPointY = 0.0F;
-      this.bipedDeadmau5Head.render(☃);
+      this.bipedDeadmau5Head.render(scale);
    }
 
-   public void renderCape(float var1) {
-      this.bipedCape.render(☃);
+   public void renderCape(float scale) {
+      this.bipedCape.render(scale);
    }
 
-   @Override
-   public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6, Entity var7) {
-      super.setRotationAngles(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public void setRotationAngles(
+      float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn
+   ) {
+      super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);
       copyModelAngles(this.bipedLeftLeg, this.bipedLeftLegwear);
       copyModelAngles(this.bipedRightLeg, this.bipedRightLegwear);
       copyModelAngles(this.bipedLeftArm, this.bipedLeftArmwear);
       copyModelAngles(this.bipedRightArm, this.bipedRightArmwear);
       copyModelAngles(this.bipedBody, this.bipedBodyWear);
-      if (☃.isSneaking()) {
-         this.bipedCape.rotationPointY = 2.0F;
-      } else {
-         this.bipedCape.rotationPointY = 0.0F;
-      }
    }
 
-   @Override
-   public void setVisible(boolean var1) {
-      super.setVisible(☃);
-      this.bipedLeftArmwear.showModel = ☃;
-      this.bipedRightArmwear.showModel = ☃;
-      this.bipedLeftLegwear.showModel = ☃;
-      this.bipedRightLegwear.showModel = ☃;
-      this.bipedBodyWear.showModel = ☃;
-      this.bipedCape.showModel = ☃;
-      this.bipedDeadmau5Head.showModel = ☃;
+   public void setVisible(boolean visible) {
+      super.setVisible(visible);
+      this.bipedLeftArmwear.showModel = visible;
+      this.bipedRightArmwear.showModel = visible;
+      this.bipedLeftLegwear.showModel = visible;
+      this.bipedRightLegwear.showModel = visible;
+      this.bipedBodyWear.showModel = visible;
+      this.bipedCape.showModel = visible;
+      this.bipedDeadmau5Head.showModel = visible;
    }
 
-   @Override
-   public void postRenderArm(float var1, EnumHandSide var2) {
-      ModelRenderer ☃ = this.getArmForSide(☃);
+   public void postRenderArm(float scale, EnumHandSide side) {
+      ModelRenderer modelrenderer = this.getArmForSide(side);
       if (this.smallArms) {
-         float ☃x = 0.5F * (☃ == EnumHandSide.RIGHT ? 1 : -1);
-         ☃.rotationPointX += ☃x;
-         ☃.postRender(☃);
-         ☃.rotationPointX -= ☃x;
+         float f = 0.5F * (side == EnumHandSide.RIGHT ? 1 : -1);
+         modelrenderer.rotationPointX += f;
+         modelrenderer.postRender(scale);
+         modelrenderer.rotationPointX -= f;
       } else {
-         ☃.postRender(☃);
+         modelrenderer.postRender(scale);
       }
    }
 }
diff --git a/patches/net/minecraft/client/model/ModelRenderer.java b/patches/net/minecraft/client/model/ModelRenderer.java
index 4b1f297..2307558 100644
--- a/patches/net/minecraft/client/model/ModelRenderer.java
+++ b/patches/net/minecraft/client/model/ModelRenderer.java
@@ -1,15 +1,21 @@
 package net.minecraft.client.model;
 
 import com.google.common.collect.Lists;
+import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.RenderGlobal;
 import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.util.ResourceLocation;
+import net.optifine.entity.model.anim.ModelUpdater;
+import net.optifine.model.ModelSprite;
+import net.optifine.shaders.Shaders;
 
 public class ModelRenderer {
-   public float textureWidth = 64.0F;
-   public float textureHeight = 32.0F;
+   public float textureWidth;
+   public float textureHeight;
    private int textureOffsetX;
    private int textureOffsetY;
    public float rotationPointX;
@@ -21,138 +27,247 @@ public class ModelRenderer {
    private boolean compiled;
    private int displayList;
    public boolean mirror;
-   public boolean showModel = true;
+   public boolean showModel;
    public boolean isHidden;
-   public List<ModelBox> cubeList = Lists.newArrayList();
+   public List<ModelBox> cubeList;
    public List<ModelRenderer> childModels;
    public final String boxName;
    private final ModelBase baseModel;
    public float offsetX;
    public float offsetY;
    public float offsetZ;
-
-   public ModelRenderer(ModelBase var1, String var2) {
-      this.baseModel = ☃;
-      ☃.boxList.add(this);
-      this.boxName = ☃;
-      this.setTextureSize(☃.textureWidth, ☃.textureHeight);
+   public List spriteList = new ArrayList();
+   public boolean mirrorV = false;
+   public float scaleX = 1.0F;
+   public float scaleY = 1.0F;
+   public float scaleZ = 1.0F;
+   private int countResetDisplayList;
+   private ResourceLocation textureLocation = null;
+   private String id = null;
+   private ModelUpdater modelUpdater;
+   private RenderGlobal renderGlobal = Config.getRenderGlobal();
+
+   public ModelRenderer(ModelBase model, String boxNameIn) {
+      this.textureWidth = 64.0F;
+      this.textureHeight = 32.0F;
+      this.showModel = true;
+      this.cubeList = Lists.newArrayList();
+      this.baseModel = model;
+      model.boxList.add(this);
+      this.boxName = boxNameIn;
+      this.setTextureSize(model.textureWidth, model.textureHeight);
    }
 
-   public ModelRenderer(ModelBase var1) {
-      this(☃, null);
+   public ModelRenderer(ModelBase model) {
+      this(model, (String)null);
    }
 
-   public ModelRenderer(ModelBase var1, int var2, int var3) {
-      this(☃);
-      this.setTextureOffset(☃, ☃);
+   public ModelRenderer(ModelBase model, int texOffX, int texOffY) {
+      this(model);
+      this.setTextureOffset(texOffX, texOffY);
    }
 
-   public void addChild(ModelRenderer var1) {
+   public void addChild(ModelRenderer renderer) {
       if (this.childModels == null) {
          this.childModels = Lists.newArrayList();
       }
 
-      this.childModels.add(☃);
+      this.childModels.add(renderer);
    }
 
-   public ModelRenderer setTextureOffset(int var1, int var2) {
-      this.textureOffsetX = ☃;
-      this.textureOffsetY = ☃;
+   public ModelRenderer setTextureOffset(int x, int y) {
+      this.textureOffsetX = x;
+      this.textureOffsetY = y;
       return this;
    }
 
-   public ModelRenderer addBox(String var1, float var2, float var3, float var4, int var5, int var6, int var7) {
-      ☃ = this.boxName + "." + ☃;
-      TextureOffset ☃ = this.baseModel.getTextureOffset(☃);
-      this.setTextureOffset(☃.textureOffsetX, ☃.textureOffsetY);
-      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, ☃, ☃, ☃, ☃, ☃, ☃, 0.0F).setBoxName(☃));
+   public ModelRenderer addBox(String partName, float offX, float offY, float offZ, int width, int height, int depth) {
+      partName = this.boxName + "." + partName;
+      TextureOffset textureoffset = this.baseModel.getTextureOffset(partName);
+      this.setTextureOffset(textureoffset.textureOffsetX, textureoffset.textureOffsetY);
+      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, offX, offY, offZ, width, height, depth, 0.0F).setBoxName(partName));
       return this;
    }
 
-   public ModelRenderer addBox(float var1, float var2, float var3, int var4, int var5, int var6) {
-      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, ☃, ☃, ☃, ☃, ☃, ☃, 0.0F));
+   public ModelRenderer addBox(float offX, float offY, float offZ, int width, int height, int depth) {
+      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, offX, offY, offZ, width, height, depth, 0.0F));
       return this;
    }
 
-   public ModelRenderer addBox(float var1, float var2, float var3, int var4, int var5, int var6, boolean var7) {
-      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, ☃, ☃, ☃, ☃, ☃, ☃, 0.0F, ☃));
+   public ModelRenderer addBox(float offX, float offY, float offZ, int width, int height, int depth, boolean mirrored) {
+      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, offX, offY, offZ, width, height, depth, 0.0F, mirrored));
       return this;
    }
 
-   public void addBox(float var1, float var2, float var3, int var4, int var5, int var6, float var7) {
-      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, ☃, ☃, ☃, ☃, ☃, ☃, ☃));
+   public void addBox(float offX, float offY, float offZ, int width, int height, int depth, float scaleFactor) {
+      this.cubeList.add(new ModelBox(this, this.textureOffsetX, this.textureOffsetY, offX, offY, offZ, width, height, depth, scaleFactor));
    }
 
-   public void setRotationPoint(float var1, float var2, float var3) {
-      this.rotationPointX = ☃;
-      this.rotationPointY = ☃;
-      this.rotationPointZ = ☃;
+   public void setRotationPoint(float rotationPointXIn, float rotationPointYIn, float rotationPointZIn) {
+      this.rotationPointX = rotationPointXIn;
+      this.rotationPointY = rotationPointYIn;
+      this.rotationPointZ = rotationPointZIn;
    }
 
-   public void render(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(☃);
+   public void render(float scale) {
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(scale);
+         }
+
+         int lastTextureId = 0;
+         if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
+            if (this.renderGlobal.renderOverlayEyes) {
+               return;
             }
 
-            GlStateManager.translate(this.offsetX, this.offsetY, this.offsetZ);
-            if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
-               GlStateManager.pushMatrix();
-               GlStateManager.translate(this.rotationPointX * ☃, this.rotationPointY * ☃, this.rotationPointZ * ☃);
-               if (this.rotateAngleZ != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
-               }
+            lastTextureId = GlStateManager.getBoundTexture();
+            Config.getTextureManager().bindTexture(this.textureLocation);
+         }
 
-               if (this.rotateAngleY != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
-               }
+         if (this.modelUpdater != null) {
+            this.modelUpdater.update();
+         }
 
-               if (this.rotateAngleX != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
-               }
+         boolean scaleXYZ = this.scaleX != 1.0F || this.scaleY != 1.0F || this.scaleZ != 1.0F;
+         GlStateManager.translate(this.offsetX, this.offsetY, this.offsetZ);
+         if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
+            GlStateManager.pushMatrix();
+            GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
+            if (this.rotateAngleZ != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+            }
 
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int ☃ = 0; ☃ < this.childModels.size(); ☃++) {
-                     this.childModels.get(☃).render(☃);
-                  }
+            if (this.rotateAngleY != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+            }
+
+            if (this.rotateAngleX != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+            }
+
+            if (scaleXYZ) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int i = 0; i < this.childModels.size(); i++) {
+                  this.childModels.get(i).render(scale);
                }
+            }
 
-               GlStateManager.popMatrix();
-            } else if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F) {
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int ☃ = 0; ☃ < this.childModels.size(); ☃++) {
-                     this.childModels.get(☃).render(☃);
-                  }
+            GlStateManager.popMatrix();
+         } else if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F) {
+            if (scaleXYZ) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int k = 0; k < this.childModels.size(); k++) {
+                  this.childModels.get(k).render(scale);
                }
-            } else {
-               GlStateManager.translate(this.rotationPointX * ☃, this.rotationPointY * ☃, this.rotationPointZ * ☃);
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int ☃ = 0; ☃ < this.childModels.size(); ☃++) {
-                     this.childModels.get(☃).render(☃);
-                  }
+            }
+
+            if (scaleXYZ) {
+               GlStateManager.scale(1.0F / this.scaleX, 1.0F / this.scaleY, 1.0F / this.scaleZ);
+            }
+         } else {
+            GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
+            if (scaleXYZ) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int j = 0; j < this.childModels.size(); j++) {
+                  this.childModels.get(j).render(scale);
                }
+            }
 
-               GlStateManager.translate(-this.rotationPointX * ☃, -this.rotationPointY * ☃, -this.rotationPointZ * ☃);
+            if (scaleXYZ) {
+               GlStateManager.scale(1.0F / this.scaleX, 1.0F / this.scaleY, 1.0F / this.scaleZ);
             }
 
-            GlStateManager.translate(-this.offsetX, -this.offsetY, -this.offsetZ);
+            GlStateManager.translate(-this.rotationPointX * scale, -this.rotationPointY * scale, -this.rotationPointZ * scale);
+         }
+
+         GlStateManager.translate(-this.offsetX, -this.offsetY, -this.offsetZ);
+         if (lastTextureId != 0) {
+            GlStateManager.bindTexture(lastTextureId);
          }
       }
    }
 
-   public void renderWithRotation(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(☃);
+   public void renderWithRotation(float scale) {
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(scale);
+         }
+
+         int lastTextureId = 0;
+         if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
+            if (this.renderGlobal.renderOverlayEyes) {
+               return;
+            }
+
+            lastTextureId = GlStateManager.getBoundTexture();
+            Config.getTextureManager().bindTexture(this.textureLocation);
+         }
+
+         if (this.modelUpdater != null) {
+            this.modelUpdater.update();
+         }
+
+         boolean scaleXYZ = this.scaleX != 1.0F || this.scaleY != 1.0F || this.scaleZ != 1.0F;
+         GlStateManager.pushMatrix();
+         GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
+         if (this.rotateAngleY != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+         }
+
+         if (this.rotateAngleX != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+         }
+
+         if (this.rotateAngleZ != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+         }
+
+         if (scaleXYZ) {
+            GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+         }
+
+         GlStateManager.callList(this.displayList);
+         if (this.childModels != null) {
+            for (int i = 0; i < this.childModels.size(); i++) {
+               this.childModels.get(i).render(scale);
+            }
+         }
+
+         GlStateManager.popMatrix();
+         if (lastTextureId != 0) {
+            GlStateManager.bindTexture(lastTextureId);
+         }
+      }
+   }
+
+   public void postRender(float scale) {
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(scale);
+         }
+
+         if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
+            GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
+            if (this.rotateAngleZ != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
             }
 
-            GlStateManager.pushMatrix();
-            GlStateManager.translate(this.rotationPointX * ☃, this.rotationPointY * ☃, this.rotationPointZ * ☃);
             if (this.rotateAngleY != 0.0F) {
                GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
             }
@@ -160,60 +275,133 @@ public void renderWithRotation(float var1) {
             if (this.rotateAngleX != 0.0F) {
                GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
             }
+         } else if (this.rotationPointX != 0.0F || this.rotationPointY != 0.0F || this.rotationPointZ != 0.0F) {
+            GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
+         }
+      }
+   }
 
-            if (this.rotateAngleZ != 0.0F) {
-               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
-            }
+   private void compileDisplayList(float scale) {
+      if (this.displayList == 0) {
+         this.displayList = GLAllocation.generateDisplayLists(1);
+      }
 
-            GlStateManager.callList(this.displayList);
-            GlStateManager.popMatrix();
-         }
+      GlStateManager.glNewList(this.displayList, 4864);
+      BufferBuilder bufferbuilder = Tessellator.getInstance().getBuffer();
+
+      for (int i = 0; i < this.cubeList.size(); i++) {
+         this.cubeList.get(i).render(bufferbuilder, scale);
+      }
+
+      for (int i = 0; i < this.spriteList.size(); i++) {
+         ModelSprite sprite = (ModelSprite)this.spriteList.get(i);
+         sprite.render(Tessellator.getInstance(), scale);
       }
+
+      GlStateManager.glEndList();
+      this.compiled = true;
    }
 
-   public void postRender(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(☃);
-            }
+   public ModelRenderer setTextureSize(int textureWidthIn, int textureHeightIn) {
+      this.textureWidth = textureWidthIn;
+      this.textureHeight = textureHeightIn;
+      return this;
+   }
 
-            if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
-               GlStateManager.translate(this.rotationPointX * ☃, this.rotationPointY * ☃, this.rotationPointZ * ☃);
-               if (this.rotateAngleZ != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
-               }
+   public void addSprite(float posX, float posY, float posZ, int sizeX, int sizeY, int sizeZ, float sizeAdd) {
+      this.spriteList.add(new ModelSprite(this, this.textureOffsetX, this.textureOffsetY, posX, posY, posZ, sizeX, sizeY, sizeZ, sizeAdd));
+   }
 
-               if (this.rotateAngleY != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
-               }
+   public boolean getCompiled() {
+      return this.compiled;
+   }
+
+   public int getDisplayList() {
+      return this.displayList;
+   }
+
+   private void checkResetDisplayList() {
+      if (this.countResetDisplayList != Shaders.countResetDisplayLists) {
+         this.compiled = false;
+         this.countResetDisplayList = Shaders.countResetDisplayLists;
+      }
+   }
+
+   public ResourceLocation getTextureLocation() {
+      return this.textureLocation;
+   }
+
+   public void setTextureLocation(ResourceLocation textureLocation) {
+      this.textureLocation = textureLocation;
+   }
+
+   public String getId() {
+      return this.id;
+   }
 
-               if (this.rotateAngleX != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+   public void setId(String id) {
+      this.id = id;
+   }
+
+   public void addBox(int[][] faceUvs, float x, float y, float z, float dx, float dy, float dz, float delta) {
+      this.cubeList.add(new ModelBox(this, faceUvs, x, y, z, dx, dy, dz, delta, this.mirror));
+   }
+
+   public ModelRenderer getChild(String name) {
+      if (name == null) {
+         return null;
+      } else {
+         if (this.childModels != null) {
+            for (int i = 0; i < this.childModels.size(); i++) {
+               ModelRenderer child = this.childModels.get(i);
+               if (name.equals(child.getId())) {
+                  return child;
                }
-            } else if (this.rotationPointX != 0.0F || this.rotationPointY != 0.0F || this.rotationPointZ != 0.0F) {
-               GlStateManager.translate(this.rotationPointX * ☃, this.rotationPointY * ☃, this.rotationPointZ * ☃);
             }
          }
+
+         return null;
       }
    }
 
-   private void compileDisplayList(float var1) {
-      this.displayList = GLAllocation.generateDisplayLists(1);
-      GlStateManager.glNewList(this.displayList, 4864);
-      BufferBuilder ☃ = Tessellator.getInstance().getBuffer();
+   public ModelRenderer getChildDeep(String name) {
+      if (name == null) {
+         return null;
+      } else {
+         ModelRenderer mrChild = this.getChild(name);
+         if (mrChild != null) {
+            return mrChild;
+         } else {
+            if (this.childModels != null) {
+               for (int i = 0; i < this.childModels.size(); i++) {
+                  ModelRenderer child = this.childModels.get(i);
+                  ModelRenderer mr = child.getChildDeep(name);
+                  if (mr != null) {
+                     return mr;
+                  }
+               }
+            }
 
-      for (int ☃x = 0; ☃x < this.cubeList.size(); ☃x++) {
-         this.cubeList.get(☃x).render(☃, ☃);
+            return null;
+         }
       }
+   }
 
-      GlStateManager.glEndList();
-      this.compiled = true;
+   public void setModelUpdater(ModelUpdater modelUpdater) {
+      this.modelUpdater = modelUpdater;
    }
 
-   public ModelRenderer setTextureSize(int var1, int var2) {
-      this.textureWidth = ☃;
-      this.textureHeight = ☃;
-      return this;
+   @Override
+   public String toString() {
+      StringBuffer sb = new StringBuffer();
+      sb.append(
+         "id: "
+            + this.id
+            + ", boxes: "
+            + (this.cubeList != null ? this.cubeList.size() : null)
+            + ", submodels: "
+            + (this.childModels != null ? this.childModels.size() : null)
+      );
+      return sb.toString();
    }
 }
diff --git a/patches/net/minecraft/client/model/TexturedQuad.java b/patches/net/minecraft/client/model/TexturedQuad.java
index 074b7aa..a6788d7 100644
--- a/patches/net/minecraft/client/model/TexturedQuad.java
+++ b/patches/net/minecraft/client/model/TexturedQuad.java
@@ -4,57 +4,64 @@
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.util.math.Vec3d;
+import net.optifine.shaders.SVertexFormat;
 
 public class TexturedQuad {
    public PositionTextureVertex[] vertexPositions;
    public int nVertices;
    private boolean invertNormal;
 
-   public TexturedQuad(PositionTextureVertex[] var1) {
-      this.vertexPositions = ☃;
-      this.nVertices = ☃.length;
+   public TexturedQuad(PositionTextureVertex[] vertices) {
+      this.vertexPositions = vertices;
+      this.nVertices = vertices.length;
    }
 
-   public TexturedQuad(PositionTextureVertex[] var1, int var2, int var3, int var4, int var5, float var6, float var7) {
-      this(☃);
-      float ☃ = 0.0F / ☃;
-      float ☃x = 0.0F / ☃;
-      ☃[0] = ☃[0].setTexturePosition(☃ / ☃ - ☃, ☃ / ☃ + ☃x);
-      ☃[1] = ☃[1].setTexturePosition(☃ / ☃ + ☃, ☃ / ☃ + ☃x);
-      ☃[2] = ☃[2].setTexturePosition(☃ / ☃ + ☃, ☃ / ☃ - ☃x);
-      ☃[3] = ☃[3].setTexturePosition(☃ / ☃ - ☃, ☃ / ☃ - ☃x);
+   public TexturedQuad(
+      PositionTextureVertex[] vertices, int texcoordU1, int texcoordV1, int texcoordU2, int texcoordV2, float textureWidth, float textureHeight
+   ) {
+      this(vertices);
+      float f = 0.0F / textureWidth;
+      float f1 = 0.0F / textureHeight;
+      vertices[0] = vertices[0].setTexturePosition(texcoordU2 / textureWidth - f, texcoordV1 / textureHeight + f1);
+      vertices[1] = vertices[1].setTexturePosition(texcoordU1 / textureWidth + f, texcoordV1 / textureHeight + f1);
+      vertices[2] = vertices[2].setTexturePosition(texcoordU1 / textureWidth + f, texcoordV2 / textureHeight - f1);
+      vertices[3] = vertices[3].setTexturePosition(texcoordU2 / textureWidth - f, texcoordV2 / textureHeight - f1);
    }
 
    public void flipFace() {
-      PositionTextureVertex[] ☃ = new PositionTextureVertex[this.vertexPositions.length];
+      PositionTextureVertex[] apositiontexturevertex = new PositionTextureVertex[this.vertexPositions.length];
 
-      for (int ☃x = 0; ☃x < this.vertexPositions.length; ☃x++) {
-         ☃[☃x] = this.vertexPositions[this.vertexPositions.length - ☃x - 1];
+      for (int i = 0; i < this.vertexPositions.length; i++) {
+         apositiontexturevertex[i] = this.vertexPositions[this.vertexPositions.length - i - 1];
       }
 
-      this.vertexPositions = ☃;
+      this.vertexPositions = apositiontexturevertex;
    }
 
-   public void draw(BufferBuilder var1, float var2) {
-      Vec3d ☃ = this.vertexPositions[1].vector3D.subtractReverse(this.vertexPositions[0].vector3D);
-      Vec3d ☃x = this.vertexPositions[1].vector3D.subtractReverse(this.vertexPositions[2].vector3D);
-      Vec3d ☃xx = ☃x.crossProduct(☃).normalize();
-      float ☃xxx = (float)☃xx.x;
-      float ☃xxxx = (float)☃xx.y;
-      float ☃xxxxx = (float)☃xx.z;
+   public void draw(BufferBuilder renderer, float scale) {
+      Vec3d vec3d = this.vertexPositions[1].vector3D.subtractReverse(this.vertexPositions[0].vector3D);
+      Vec3d vec3d1 = this.vertexPositions[1].vector3D.subtractReverse(this.vertexPositions[2].vector3D);
+      Vec3d vec3d2 = vec3d1.crossProduct(vec3d).normalize();
+      float f = (float)vec3d2.x;
+      float f1 = (float)vec3d2.y;
+      float f2 = (float)vec3d2.z;
       if (this.invertNormal) {
-         ☃xxx = -☃xxx;
-         ☃xxxx = -☃xxxx;
-         ☃xxxxx = -☃xxxxx;
+         f = -f;
+         f1 = -f1;
+         f2 = -f2;
       }
 
-      ☃.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
+      if (Config.isShaders()) {
+         renderer.begin(7, SVertexFormat.defVertexFormatTextured);
+      } else {
+         renderer.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
+      }
 
-      for (int ☃xxxxxx = 0; ☃xxxxxx < 4; ☃xxxxxx++) {
-         PositionTextureVertex ☃xxxxxxx = this.vertexPositions[☃xxxxxx];
-         ☃.pos(☃xxxxxxx.vector3D.x * ☃, ☃xxxxxxx.vector3D.y * ☃, ☃xxxxxxx.vector3D.z * ☃)
-            .tex(☃xxxxxxx.texturePositionX, ☃xxxxxxx.texturePositionY)
-            .normal(☃xxx, ☃xxxx, ☃xxxxx)
+      for (int i = 0; i < 4; i++) {
+         PositionTextureVertex positiontexturevertex = this.vertexPositions[i];
+         renderer.pos(positiontexturevertex.vector3D.x * scale, positiontexturevertex.vector3D.y * scale, positiontexturevertex.vector3D.z * scale)
+            .tex(positiontexturevertex.texturePositionX, positiontexturevertex.texturePositionY)
+            .normal(f, f1, f2)
             .endVertex();
       }
 
diff --git a/patches/net/minecraft/client/multiplayer/WorldClient.java b/patches/net/minecraft/client/multiplayer/WorldClient.java
index 424698a..cac7f9b 100644
--- a/patches/net/minecraft/client/multiplayer/WorldClient.java
+++ b/patches/net/minecraft/client/multiplayer/WorldClient.java
@@ -4,13 +4,15 @@
 import java.util.Random;
 import java.util.Set;
 import javax.annotation.Nullable;
+import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.audio.MovingSoundMinecart;
 import net.minecraft.client.audio.PositionedSoundRecord;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.network.NetHandlerPlayClient;
-import net.minecraft.client.particle.ParticleFirework;
+import net.minecraft.client.particle.ParticleFirework.Starter;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
@@ -31,18 +33,24 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.world.DimensionType;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.EnumSkyBlock;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
 import net.minecraft.world.storage.SaveDataMemoryStorage;
 import net.minecraft.world.storage.SaveHandlerMP;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.CustomGuis;
+import net.optifine.DynamicLights;
+import net.optifine.override.PlayerControllerOF;
+import net.optifine.reflect.Reflector;
 
 public class WorldClient extends World {
    private final NetHandlerPlayClient connection;
@@ -51,22 +59,38 @@ public class WorldClient extends World {
    private final Set<Entity> entitySpawnQueue = Sets.newHashSet();
    private final Minecraft mc = Minecraft.getMinecraft();
    private final Set<ChunkPos> previousActiveChunkSet = Sets.newHashSet();
-   private int ambienceTicks = this.rand.nextInt(12000);
-   protected Set<ChunkPos> visibleChunks = Sets.newHashSet();
-
-   public WorldClient(NetHandlerPlayClient var1, WorldSettings var2, int var3, EnumDifficulty var4, Profiler var5) {
-      super(new SaveHandlerMP(), new WorldInfo(☃, "MpServer"), DimensionType.getById(☃).createDimension(), ☃, true);
-      this.connection = ☃;
-      this.getWorldInfo().setDifficulty(☃);
-      this.setSpawnPoint(new BlockPos(8, 64, 8));
+   private int ambienceTicks;
+   protected Set<ChunkPos> visibleChunks;
+   private int playerChunkX = Integer.MIN_VALUE;
+   private int playerChunkY = Integer.MIN_VALUE;
+   private boolean playerUpdate = false;
+
+   public WorldClient(NetHandlerPlayClient netHandler, WorldSettings settings, int dimension, EnumDifficulty difficulty, Profiler profilerIn) {
+      super(new SaveHandlerMP(), new WorldInfo(settings, "MpServer"), makeWorldProvider(dimension), profilerIn, true);
+      this.ambienceTicks = this.rand.nextInt(12000);
+      this.visibleChunks = Sets.newHashSet();
+      this.connection = netHandler;
+      this.getWorldInfo().setDifficulty(difficulty);
       this.provider.setWorld(this);
+      this.setSpawnPoint(new BlockPos(8, 64, 8));
       this.chunkProvider = this.createChunkProvider();
       this.mapStorage = new SaveDataMemoryStorage();
       this.calculateInitialSkylight();
       this.calculateInitialWeather();
+      Reflector.call(this, Reflector.ForgeWorld_initCapabilities, new Object[0]);
+      Reflector.postForgeBusEvent(Reflector.WorldEvent_Load_Constructor, new Object[]{this});
+      if (this.mc.playerController != null && this.mc.playerController.getClass() == PlayerControllerMP.class) {
+         this.mc.playerController = new PlayerControllerOF(this.mc, netHandler);
+         CustomGuis.setPlayerControllerOF((PlayerControllerOF)this.mc.playerController);
+      }
+   }
+
+   private static WorldProvider makeWorldProvider(int dimension) {
+      return Reflector.DimensionManager_createProviderFor.exists()
+         ? (WorldProvider)Reflector.call(Reflector.DimensionManager_createProviderFor, new Object[]{dimension})
+         : DimensionType.getById(dimension).createDimension();
    }
 
-   @Override
    public void tick() {
       super.tick();
       this.setTotalWorldTime(this.getTotalWorldTime() + 1L);
@@ -76,11 +100,11 @@ public void tick() {
 
       this.profiler.startSection("reEntryProcessing");
 
-      for (int ☃ = 0; ☃ < 10 && !this.entitySpawnQueue.isEmpty(); ☃++) {
-         Entity ☃x = this.entitySpawnQueue.iterator().next();
-         this.entitySpawnQueue.remove(☃x);
-         if (!this.loadedEntityList.contains(☃x)) {
-            this.spawnEntity(☃x);
+      for (int i = 0; i < 10 && !this.entitySpawnQueue.isEmpty(); i++) {
+         Entity entity = this.entitySpawnQueue.iterator().next();
+         this.entitySpawnQueue.remove(entity);
+         if (!this.loadedEntityList.contains(entity)) {
+            this.spawnEntity(entity);
          }
       }
 
@@ -91,37 +115,40 @@ public void tick() {
       this.profiler.endSection();
    }
 
-   public void invalidateBlockReceiveRegion(int var1, int var2, int var3, int var4, int var5, int var6) {
+   public void invalidateBlockReceiveRegion(int x1, int y1, int z1, int x2, int y2, int z2) {
    }
 
-   @Override
    protected IChunkProvider createChunkProvider() {
       this.clientChunkProvider = new ChunkProviderClient(this);
       return this.clientChunkProvider;
    }
 
-   @Override
-   protected boolean isChunkLoaded(int var1, int var2, boolean var3) {
-      return ☃ || !this.getChunkProvider().provideChunk(☃, ☃).isEmpty();
+   protected boolean isChunkLoaded(int x, int z, boolean allowEmpty) {
+      return allowEmpty || !this.getChunkProvider().provideChunk(x, z).isEmpty();
    }
 
    protected void refreshVisibleChunks() {
-      this.visibleChunks.clear();
-      int ☃ = this.mc.gameSettings.renderDistanceChunks;
-      this.profiler.startSection("buildList");
-      int ☃x = MathHelper.floor(this.mc.player.posX / 16.0);
-      int ☃xx = MathHelper.floor(this.mc.player.posZ / 16.0);
-
-      for (int ☃xxx = -☃; ☃xxx <= ☃; ☃xxx++) {
-         for (int ☃xxxx = -☃; ☃xxxx <= ☃; ☃xxxx++) {
-            this.visibleChunks.add(new ChunkPos(☃xxx + ☃x, ☃xxxx + ☃xx));
+      int cx = MathHelper.floor(this.mc.player.posX / 16.0);
+      int cy = MathHelper.floor(this.mc.player.posZ / 16.0);
+      if (cx != this.playerChunkX || cy != this.playerChunkY) {
+         this.playerChunkX = cx;
+         this.playerChunkY = cy;
+         this.visibleChunks.clear();
+         int i = this.mc.gameSettings.renderDistanceChunks;
+         this.profiler.startSection("buildList");
+         int j = MathHelper.floor(this.mc.player.posX / 16.0);
+         int k = MathHelper.floor(this.mc.player.posZ / 16.0);
+
+         for (int l = -i; l <= i; l++) {
+            for (int i1 = -i; i1 <= i; i1++) {
+               this.visibleChunks.add(new ChunkPos(l + j, i1 + k));
+            }
          }
-      }
 
-      this.profiler.endSection();
+         this.profiler.endSection();
+      }
    }
 
-   @Override
    protected void updateBlocks() {
       this.refreshVisibleChunks();
       if (this.ambienceTicks > 0) {
@@ -133,293 +160,332 @@ protected void updateBlocks() {
          this.previousActiveChunkSet.clear();
       }
 
-      int ☃ = 0;
+      int i = 0;
 
-      for (ChunkPos ☃x : this.visibleChunks) {
-         if (!this.previousActiveChunkSet.contains(☃x)) {
-            int ☃xx = ☃x.x * 16;
-            int ☃xxx = ☃x.z * 16;
+      for (ChunkPos chunkpos : this.visibleChunks) {
+         if (!this.previousActiveChunkSet.contains(chunkpos)) {
+            int j = chunkpos.x * 16;
+            int k = chunkpos.z * 16;
             this.profiler.startSection("getChunk");
-            Chunk ☃xxxx = this.getChunk(☃x.x, ☃x.z);
-            this.playMoodSoundAndCheckLight(☃xx, ☃xxx, ☃xxxx);
+            Chunk chunk = this.getChunk(chunkpos.x, chunkpos.z);
+            this.playMoodSoundAndCheckLight(j, k, chunk);
             this.profiler.endSection();
-            this.previousActiveChunkSet.add(☃x);
-            if (++☃ >= 10) {
+            this.previousActiveChunkSet.add(chunkpos);
+            if (++i >= 10) {
                return;
             }
          }
       }
    }
 
-   public void doPreChunk(int var1, int var2, boolean var3) {
-      if (☃) {
-         this.clientChunkProvider.loadChunk(☃, ☃);
+   public void doPreChunk(int chunkX, int chunkZ, boolean loadChunk) {
+      if (loadChunk) {
+         this.clientChunkProvider.loadChunk(chunkX, chunkZ);
       } else {
-         this.clientChunkProvider.unloadChunk(☃, ☃);
-         this.markBlockRangeForRenderUpdate(☃ * 16, 0, ☃ * 16, ☃ * 16 + 15, 256, ☃ * 16 + 15);
+         this.clientChunkProvider.unloadChunk(chunkX, chunkZ);
+         this.markBlockRangeForRenderUpdate(chunkX * 16, 0, chunkZ * 16, chunkX * 16 + 15, 256, chunkZ * 16 + 15);
       }
    }
 
-   @Override
-   public boolean spawnEntity(Entity var1) {
-      boolean ☃ = super.spawnEntity(☃);
-      this.entityList.add(☃);
-      if (☃) {
-         if (☃ instanceof EntityMinecart) {
-            this.mc.getSoundHandler().playSound(new MovingSoundMinecart((EntityMinecart)☃));
+   public boolean spawnEntity(Entity entityIn) {
+      boolean flag = super.spawnEntity(entityIn);
+      this.entityList.add(entityIn);
+      if (flag) {
+         if (entityIn instanceof EntityMinecart) {
+            this.mc.getSoundHandler().playSound(new MovingSoundMinecart((EntityMinecart)entityIn));
          }
       } else {
-         this.entitySpawnQueue.add(☃);
+         this.entitySpawnQueue.add(entityIn);
       }
 
-      return ☃;
+      return flag;
    }
 
-   @Override
-   public void removeEntity(Entity var1) {
-      super.removeEntity(☃);
-      this.entityList.remove(☃);
+   public void removeEntity(Entity entityIn) {
+      super.removeEntity(entityIn);
+      this.entityList.remove(entityIn);
    }
 
-   @Override
-   protected void onEntityAdded(Entity var1) {
-      super.onEntityAdded(☃);
-      if (this.entitySpawnQueue.contains(☃)) {
-         this.entitySpawnQueue.remove(☃);
+   protected void onEntityAdded(Entity entityIn) {
+      super.onEntityAdded(entityIn);
+      if (this.entitySpawnQueue.contains(entityIn)) {
+         this.entitySpawnQueue.remove(entityIn);
       }
    }
 
-   @Override
-   protected void onEntityRemoved(Entity var1) {
-      super.onEntityRemoved(☃);
-      if (this.entityList.contains(☃)) {
-         if (☃.isEntityAlive()) {
-            this.entitySpawnQueue.add(☃);
+   protected void onEntityRemoved(Entity entityIn) {
+      super.onEntityRemoved(entityIn);
+      if (this.entityList.contains(entityIn)) {
+         if (entityIn.isEntityAlive()) {
+            this.entitySpawnQueue.add(entityIn);
          } else {
-            this.entityList.remove(☃);
+            this.entityList.remove(entityIn);
          }
       }
    }
 
-   public void addEntityToWorld(int var1, Entity var2) {
-      Entity ☃ = this.getEntityByID(☃);
-      if (☃ != null) {
-         this.removeEntity(☃);
+   public void addEntityToWorld(int entityID, Entity entityToSpawn) {
+      Entity entity = this.getEntityByID(entityID);
+      if (entity != null) {
+         this.removeEntity(entity);
       }
 
-      this.entityList.add(☃);
-      ☃.setEntityId(☃);
-      if (!this.spawnEntity(☃)) {
-         this.entitySpawnQueue.add(☃);
+      this.entityList.add(entityToSpawn);
+      entityToSpawn.setEntityId(entityID);
+      if (!this.spawnEntity(entityToSpawn)) {
+         this.entitySpawnQueue.add(entityToSpawn);
       }
 
-      this.entitiesById.addKey(☃, ☃);
+      this.entitiesById.addKey(entityID, entityToSpawn);
    }
 
    @Nullable
-   @Override
-   public Entity getEntityByID(int var1) {
-      return (Entity)(☃ == this.mc.player.getEntityId() ? this.mc.player : super.getEntityByID(☃));
+   public Entity getEntityByID(int id) {
+      return (Entity)(id == this.mc.player.getEntityId() ? this.mc.player : super.getEntityByID(id));
    }
 
-   public Entity removeEntityFromWorld(int var1) {
-      Entity ☃ = this.entitiesById.removeObject(☃);
-      if (☃ != null) {
-         this.entityList.remove(☃);
-         this.removeEntity(☃);
+   public Entity removeEntityFromWorld(int entityID) {
+      Entity entity = (Entity)this.entitiesById.removeObject(entityID);
+      if (entity != null) {
+         this.entityList.remove(entity);
+         this.removeEntity(entity);
       }
 
-      return ☃;
+      return entity;
    }
 
    @Deprecated
-   public boolean invalidateRegionAndSetBlock(BlockPos var1, IBlockState var2) {
-      int ☃ = ☃.getX();
-      int ☃x = ☃.getY();
-      int ☃xx = ☃.getZ();
-      this.invalidateBlockReceiveRegion(☃, ☃x, ☃xx, ☃, ☃x, ☃xx);
-      return super.setBlockState(☃, ☃, 3);
+   public boolean invalidateRegionAndSetBlock(BlockPos pos, IBlockState state) {
+      int i = pos.getX();
+      int j = pos.getY();
+      int k = pos.getZ();
+      this.invalidateBlockReceiveRegion(i, j, k, i, j, k);
+      return super.setBlockState(pos, state, 3);
    }
 
-   @Override
    public void sendQuittingDisconnectingPacket() {
       this.connection.getNetworkManager().closeChannel(new TextComponentString("Quitting"));
    }
 
-   @Override
    protected void updateWeather() {
    }
 
-   @Override
-   protected void playMoodSoundAndCheckLight(int var1, int var2, Chunk var3) {
-      super.playMoodSoundAndCheckLight(☃, ☃, ☃);
+   protected void playMoodSoundAndCheckLight(int p_147467_1_, int p_147467_2_, Chunk chunkIn) {
+      super.playMoodSoundAndCheckLight(p_147467_1_, p_147467_2_, chunkIn);
       if (this.ambienceTicks == 0) {
+         EntityPlayerSP player = this.mc.player;
+         if (player == null) {
+            return;
+         }
+
+         if (Math.abs(player.chunkCoordX - chunkIn.x) > 1 || Math.abs(player.chunkCoordZ - chunkIn.z) > 1) {
+            return;
+         }
+
          this.updateLCG = this.updateLCG * 3 + 1013904223;
-         int ☃ = this.updateLCG >> 2;
-         int ☃x = ☃ & 15;
-         int ☃xx = ☃ >> 8 & 15;
-         int ☃xxx = ☃ >> 16 & 0xFF;
-         BlockPos ☃xxxx = new BlockPos(☃x + ☃, ☃xxx, ☃xx + ☃);
-         IBlockState ☃xxxxx = ☃.getBlockState(☃xxxx);
-         ☃x += ☃;
-         ☃xx += ☃;
-         if (☃xxxxx.getMaterial() == Material.AIR && this.getLight(☃xxxx) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, ☃xxxx) <= 0) {
-            double ☃xxxxxx = this.mc.player.getDistanceSq(☃x + 0.5, ☃xxx + 0.5, ☃xx + 0.5);
-            if (this.mc.player != null && ☃xxxxxx > 4.0 && ☃xxxxxx < 256.0) {
-               this.playSound(
-                  ☃x + 0.5, ☃xxx + 0.5, ☃xx + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7F, 0.8F + this.rand.nextFloat() * 0.2F, false
-               );
-               this.ambienceTicks = this.rand.nextInt(12000) + 6000;
-            }
+         int i = this.updateLCG >> 2;
+         int j = i & 15;
+         int k = i >> 8 & 15;
+         int l = i >> 16 & 0xFF;
+         l /= 2;
+         if (player.posY > 160.0) {
+            l += 128;
+         } else if (player.posY > 96.0) {
+            l += 64;
+         }
+
+         BlockPos blockpos = new BlockPos(j + p_147467_1_, l, k + p_147467_2_);
+         IBlockState iblockstate = chunkIn.getBlockState(blockpos);
+         j += p_147467_1_;
+         k += p_147467_2_;
+         double distSq = this.mc.player.getDistanceSq(j + 0.5, l + 0.5, k + 0.5);
+         if (distSq < 4.0) {
+            return;
+         }
+
+         if (distSq > 255.0) {
+            return;
+         }
+
+         if (iblockstate.a() == Material.AIR && this.getLight(blockpos) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, blockpos) <= 0) {
+            this.playSound(j + 0.5, l + 0.5, k + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7F, 0.8F + this.rand.nextFloat() * 0.2F, false);
+            this.ambienceTicks = this.rand.nextInt(12000) + 6000;
          }
       }
    }
 
-   public void doVoidFogParticles(int var1, int var2, int var3) {
-      int ☃ = 32;
-      Random ☃x = new Random();
-      ItemStack ☃xx = this.mc.player.getHeldItemMainhand();
-      boolean ☃xxx = this.mc.playerController.getCurrentGameType() == GameType.CREATIVE
-         && !☃xx.isEmpty()
-         && ☃xx.getItem() == Item.getItemFromBlock(Blocks.BARRIER);
-      BlockPos.MutableBlockPos ☃xxxx = new BlockPos.MutableBlockPos();
+   public void doVoidFogParticles(int posX, int posY, int posZ) {
+      int i = 32;
+      Random random = new Random();
+      ItemStack itemstack = this.mc.player.getHeldItemMainhand();
+      if (itemstack == null || Block.getBlockFromItem(itemstack.getItem()) != Blocks.BARRIER) {
+         itemstack = this.mc.player.getHeldItemOffhand();
+      }
+
+      boolean flag = this.mc.playerController.getCurrentGameType() == GameType.CREATIVE
+         && !itemstack.isEmpty()
+         && itemstack.getItem() == Item.getItemFromBlock(Blocks.BARRIER);
+      MutableBlockPos blockpos$mutableblockpos = new MutableBlockPos();
 
-      for (int ☃xxxxx = 0; ☃xxxxx < 667; ☃xxxxx++) {
-         this.showBarrierParticles(☃, ☃, ☃, 16, ☃x, ☃xxx, ☃xxxx);
-         this.showBarrierParticles(☃, ☃, ☃, 32, ☃x, ☃xxx, ☃xxxx);
+      for (int j = 0; j < 667; j++) {
+         this.showBarrierParticles(posX, posY, posZ, 16, random, flag, blockpos$mutableblockpos);
+         this.showBarrierParticles(posX, posY, posZ, 32, random, flag, blockpos$mutableblockpos);
       }
    }
 
-   public void showBarrierParticles(int var1, int var2, int var3, int var4, Random var5, boolean var6, BlockPos.MutableBlockPos var7) {
-      int ☃ = ☃ + this.rand.nextInt(☃) - this.rand.nextInt(☃);
-      int ☃x = ☃ + this.rand.nextInt(☃) - this.rand.nextInt(☃);
-      int ☃xx = ☃ + this.rand.nextInt(☃) - this.rand.nextInt(☃);
-      ☃.setPos(☃, ☃x, ☃xx);
-      IBlockState ☃xxx = this.getBlockState(☃);
-      ☃xxx.getBlock().randomDisplayTick(☃xxx, this, ☃, ☃);
-      if (☃ && ☃xxx.getBlock() == Blocks.BARRIER) {
-         this.spawnParticle(EnumParticleTypes.BARRIER, ☃ + 0.5F, ☃x + 0.5F, ☃xx + 0.5F, 0.0, 0.0, 0.0, new int[0]);
+   public void showBarrierParticles(int x, int y, int z, int offset, Random random, boolean holdingBarrier, MutableBlockPos pos) {
+      int i = x + this.rand.nextInt(offset) - this.rand.nextInt(offset);
+      int j = y + this.rand.nextInt(offset) - this.rand.nextInt(offset);
+      int k = z + this.rand.nextInt(offset) - this.rand.nextInt(offset);
+      pos.setPos(i, j, k);
+      IBlockState iblockstate = this.getBlockState(pos);
+      iblockstate.getBlock().randomDisplayTick(iblockstate, this, pos, random);
+      if (holdingBarrier && iblockstate.getBlock() == Blocks.BARRIER) {
+         this.spawnParticle(EnumParticleTypes.BARRIER, i + 0.5F, j + 0.5F, k + 0.5F, 0.0, 0.0, 0.0, new int[0]);
       }
    }
 
    public void removeAllEntities() {
       this.loadedEntityList.removeAll(this.unloadedEntityList);
 
-      for (int ☃ = 0; ☃ < this.unloadedEntityList.size(); ☃++) {
-         Entity ☃x = this.unloadedEntityList.get(☃);
-         int ☃xx = ☃x.chunkCoordX;
-         int ☃xxx = ☃x.chunkCoordZ;
-         if (☃x.addedToChunk && this.isChunkLoaded(☃xx, ☃xxx, true)) {
-            this.getChunk(☃xx, ☃xxx).removeEntity(☃x);
+      for (int i = 0; i < this.unloadedEntityList.size(); i++) {
+         Entity entity = (Entity)this.unloadedEntityList.get(i);
+         int j = entity.chunkCoordX;
+         int k = entity.chunkCoordZ;
+         if (entity.addedToChunk && this.isChunkLoaded(j, k, true)) {
+            this.getChunk(j, k).removeEntity(entity);
          }
       }
 
-      for (int ☃x = 0; ☃x < this.unloadedEntityList.size(); ☃x++) {
-         this.onEntityRemoved(this.unloadedEntityList.get(☃x));
+      for (int i1 = 0; i1 < this.unloadedEntityList.size(); i1++) {
+         this.onEntityRemoved((Entity)this.unloadedEntityList.get(i1));
       }
 
       this.unloadedEntityList.clear();
 
-      for (int ☃x = 0; ☃x < this.loadedEntityList.size(); ☃x++) {
-         Entity ☃xx = this.loadedEntityList.get(☃x);
-         Entity ☃xxx = ☃xx.getRidingEntity();
-         if (☃xxx != null) {
-            if (!☃xxx.isDead && ☃xxx.isPassenger(☃xx)) {
+      for (int j1 = 0; j1 < this.loadedEntityList.size(); j1++) {
+         Entity entity1 = (Entity)this.loadedEntityList.get(j1);
+         Entity entity2 = entity1.getRidingEntity();
+         if (entity2 != null) {
+            if (!entity2.isDead && entity2.isPassenger(entity1)) {
                continue;
             }
 
-            ☃xx.dismountRidingEntity();
+            entity1.dismountRidingEntity();
          }
 
-         if (☃xx.isDead) {
-            int ☃xxxx = ☃xx.chunkCoordX;
-            int ☃xxxxx = ☃xx.chunkCoordZ;
-            if (☃xx.addedToChunk && this.isChunkLoaded(☃xxxx, ☃xxxxx, true)) {
-               this.getChunk(☃xxxx, ☃xxxxx).removeEntity(☃xx);
+         if (entity1.isDead) {
+            int k1 = entity1.chunkCoordX;
+            int l = entity1.chunkCoordZ;
+            if (entity1.addedToChunk && this.isChunkLoaded(k1, l, true)) {
+               this.getChunk(k1, l).removeEntity(entity1);
             }
 
-            this.loadedEntityList.remove(☃x--);
-            this.onEntityRemoved(☃xx);
+            this.loadedEntityList.remove(j1--);
+            this.onEntityRemoved(entity1);
          }
       }
    }
 
-   @Override
-   public CrashReportCategory addWorldInfoToCrashReport(CrashReport var1) {
-      CrashReportCategory ☃ = super.addWorldInfoToCrashReport(☃);
-      ☃.addDetail("Forced entities", new ICrashReportDetail<String>() {
+   public CrashReportCategory addWorldInfoToCrashReport(CrashReport report) {
+      CrashReportCategory crashreportcategory = super.addWorldInfoToCrashReport(report);
+      crashreportcategory.addDetail("Forced entities", new ICrashReportDetail<String>() {
          public String call() {
             return WorldClient.this.entityList.size() + " total; " + WorldClient.this.entityList;
          }
       });
-      ☃.addDetail("Retry entities", new ICrashReportDetail<String>() {
+      crashreportcategory.addDetail("Retry entities", new ICrashReportDetail<String>() {
          public String call() {
             return WorldClient.this.entitySpawnQueue.size() + " total; " + WorldClient.this.entitySpawnQueue;
          }
       });
-      ☃.addDetail("Server brand", new ICrashReportDetail<String>() {
+      crashreportcategory.addDetail("Server brand", new ICrashReportDetail<String>() {
          public String call() throws Exception {
             return WorldClient.this.mc.player.getServerBrand();
          }
       });
-      ☃.addDetail("Server type", new ICrashReportDetail<String>() {
+      crashreportcategory.addDetail("Server type", new ICrashReportDetail<String>() {
          public String call() throws Exception {
             return WorldClient.this.mc.getIntegratedServer() == null ? "Non-integrated multiplayer server" : "Integrated singleplayer server";
          }
       });
-      return ☃;
+      return crashreportcategory;
    }
 
-   @Override
-   public void playSound(@Nullable EntityPlayer var1, double var2, double var4, double var6, SoundEvent var8, SoundCategory var9, float var10, float var11) {
-      if (☃ == this.mc.player) {
-         this.playSound(☃, ☃, ☃, ☃, ☃, ☃, ☃, false);
+   public void playSound(@Nullable EntityPlayer player, double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch) {
+      if (player == this.mc.player) {
+         this.playSound(x, y, z, soundIn, category, volume, pitch, false);
       }
    }
 
-   public void playSound(BlockPos var1, SoundEvent var2, SoundCategory var3, float var4, float var5, boolean var6) {
-      this.playSound(☃.getX() + 0.5, ☃.getY() + 0.5, ☃.getZ() + 0.5, ☃, ☃, ☃, ☃, ☃);
+   public void playSound(BlockPos pos, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay) {
+      this.playSound(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5, soundIn, category, volume, pitch, distanceDelay);
    }
 
-   @Override
-   public void playSound(double var1, double var3, double var5, SoundEvent var7, SoundCategory var8, float var9, float var10, boolean var11) {
-      double ☃ = this.mc.getRenderViewEntity().getDistanceSq(☃, ☃, ☃);
-      PositionedSoundRecord ☃x = new PositionedSoundRecord(☃, ☃, ☃, ☃, (float)☃, (float)☃, (float)☃);
-      if (☃ && ☃ > 100.0) {
-         double ☃xx = Math.sqrt(☃) / 40.0;
-         this.mc.getSoundHandler().playDelayedSound(☃x, (int)(☃xx * 20.0));
+   public void playSound(double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay) {
+      double d0 = this.mc.getRenderViewEntity().getDistanceSq(x, y, z);
+      PositionedSoundRecord positionedsoundrecord = new PositionedSoundRecord(soundIn, category, volume, pitch, (float)x, (float)y, (float)z);
+      if (distanceDelay && d0 > 100.0) {
+         double d1 = Math.sqrt(d0) / 40.0;
+         this.mc.getSoundHandler().playDelayedSound(positionedsoundrecord, (int)(d1 * 20.0));
       } else {
-         this.mc.getSoundHandler().playSound(☃x);
+         this.mc.getSoundHandler().playSound(positionedsoundrecord);
       }
    }
 
-   @Override
-   public void makeFireworks(double var1, double var3, double var5, double var7, double var9, double var11, @Nullable NBTTagCompound var13) {
-      this.mc.effectRenderer.addEffect(new ParticleFirework.Starter(this, ☃, ☃, ☃, ☃, ☃, ☃, this.mc.effectRenderer, ☃));
+   public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable NBTTagCompound compund) {
+      this.mc.effectRenderer.addEffect(new Starter(this, x, y, z, motionX, motionY, motionZ, this.mc.effectRenderer, compund));
    }
 
-   @Override
-   public void sendPacketToServer(Packet<?> var1) {
-      this.connection.sendPacket(☃);
+   public void sendPacketToServer(Packet<?> packetIn) {
+      this.connection.sendPacket(packetIn);
    }
 
-   public void setWorldScoreboard(Scoreboard var1) {
-      this.worldScoreboard = ☃;
+   public void setWorldScoreboard(Scoreboard scoreboardIn) {
+      this.worldScoreboard = scoreboardIn;
    }
 
-   @Override
-   public void setWorldTime(long var1) {
-      if (☃ < 0L) {
-         ☃ = -☃;
+   public void setWorldTime(long time) {
+      if (time < 0L) {
+         time = -time;
          this.getGameRules().setOrCreateGameRule("doDaylightCycle", "false");
       } else {
          this.getGameRules().setOrCreateGameRule("doDaylightCycle", "true");
       }
 
-      super.setWorldTime(☃);
+      super.setWorldTime(time);
    }
 
    public ChunkProviderClient getChunkProvider() {
       return (ChunkProviderClient)super.getChunkProvider();
    }
+
+   public int getCombinedLight(BlockPos pos, int lightValue) {
+      int combinedLight = super.getCombinedLight(pos, lightValue);
+      if (Config.isDynamicLights()) {
+         combinedLight = DynamicLights.getCombinedLight(pos, combinedLight);
+      }
+
+      return combinedLight;
+   }
+
+   public boolean setBlockState(BlockPos pos, IBlockState newState, int flags) {
+      this.playerUpdate = this.isPlayerActing();
+      boolean res = super.setBlockState(pos, newState, flags);
+      this.playerUpdate = false;
+      return res;
+   }
+
+   private boolean isPlayerActing() {
+      if (this.mc.playerController instanceof PlayerControllerOF) {
+         PlayerControllerOF pcof = (PlayerControllerOF)this.mc.playerController;
+         return pcof.isActing();
+      } else {
+         return false;
+      }
+   }
+
+   public boolean isPlayerUpdate() {
+      return this.playerUpdate;
+   }
 }
diff --git a/patches/net/minecraft/client/particle/ParticleItemPickup.java b/patches/net/minecraft/client/particle/ParticleItemPickup.java
index 3c0103f..edbebf8 100644
--- a/patches/net/minecraft/client/particle/ParticleItemPickup.java
+++ b/patches/net/minecraft/client/particle/ParticleItemPickup.java
@@ -7,6 +7,8 @@
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.entity.Entity;
 import net.minecraft.world.World;
+import net.optifine.shaders.Program;
+import net.optifine.shaders.Shaders;
 
 public class ParticleItemPickup extends Particle {
    private final Entity item;
@@ -16,40 +18,50 @@ public class ParticleItemPickup extends Particle {
    private final float yOffset;
    private final RenderManager renderManager = Minecraft.getMinecraft().getRenderManager();
 
-   public ParticleItemPickup(World var1, Entity var2, Entity var3, float var4) {
-      super(☃, ☃.posX, ☃.posY, ☃.posZ, ☃.motionX, ☃.motionY, ☃.motionZ);
-      this.item = ☃;
-      this.target = ☃;
+   public ParticleItemPickup(World worldIn, Entity p_i1233_2_, Entity p_i1233_3_, float p_i1233_4_) {
+      super(worldIn, p_i1233_2_.posX, p_i1233_2_.posY, p_i1233_2_.posZ, p_i1233_2_.motionX, p_i1233_2_.motionY, p_i1233_2_.motionZ);
+      this.item = p_i1233_2_;
+      this.target = p_i1233_3_;
       this.maxAge = 3;
-      this.yOffset = ☃;
+      this.yOffset = p_i1233_4_;
    }
 
-   @Override
-   public void renderParticle(BufferBuilder var1, Entity var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      float ☃ = (this.age + ☃) / this.maxAge;
-      ☃ *= ☃;
-      double ☃x = this.item.posX;
-      double ☃xx = this.item.posY;
-      double ☃xxx = this.item.posZ;
-      double ☃xxxx = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * ☃;
-      double ☃xxxxx = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * ☃ + this.yOffset;
-      double ☃xxxxxx = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * ☃;
-      double ☃xxxxxxx = ☃x + (☃xxxx - ☃x) * ☃;
-      double ☃xxxxxxxx = ☃xx + (☃xxxxx - ☃xx) * ☃;
-      double ☃xxxxxxxxx = ☃xxx + (☃xxxxxx - ☃xxx) * ☃;
-      int ☃xxxxxxxxxx = this.getBrightnessForRender(☃);
-      int ☃xxxxxxxxxxx = ☃xxxxxxxxxx % 65536;
-      int ☃xxxxxxxxxxxx = ☃xxxxxxxxxx / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃xxxxxxxxxxx, ☃xxxxxxxxxxxx);
+   public void renderParticle(
+      BufferBuilder buffer, Entity entityIn, float partialTicks, float rotationX, float rotationZ, float rotationYZ, float rotationXY, float rotationXZ
+   ) {
+      Program oldShadersProgram = null;
+      if (Config.isShaders()) {
+         oldShadersProgram = Shaders.activeProgram;
+         Shaders.nextEntity(this.item);
+      }
+
+      float f = (this.age + partialTicks) / this.maxAge;
+      f *= f;
+      double d0 = this.item.posX;
+      double d1 = this.item.posY;
+      double d2 = this.item.posZ;
+      double d3 = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * partialTicks;
+      double d4 = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * partialTicks + this.yOffset;
+      double d5 = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * partialTicks;
+      double d6 = d0 + (d3 - d0) * f;
+      double d7 = d1 + (d4 - d1) * f;
+      double d8 = d2 + (d5 - d2) * f;
+      int i = this.getBrightnessForRender(partialTicks);
+      int j = i % 65536;
+      int k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      ☃xxxxxxx -= interpPosX;
-      ☃xxxxxxxx -= interpPosY;
-      ☃xxxxxxxxx -= interpPosZ;
+      d6 -= interpPosX;
+      d7 -= interpPosY;
+      d8 -= interpPosZ;
       GlStateManager.enableLighting();
-      this.renderManager.renderEntity(this.item, ☃xxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxx, this.item.rotationYaw, ☃, false);
+      this.renderManager.renderEntity(this.item, d6, d7, d8, this.item.rotationYaw, partialTicks, false);
+      if (Config.isShaders()) {
+         Shaders.setEntityId(null);
+         Shaders.useProgram(oldShadersProgram);
+      }
    }
 
-   @Override
    public void onUpdate() {
       this.age++;
       if (this.age == this.maxAge) {
@@ -57,7 +69,6 @@ public void onUpdate() {
       }
    }
 
-   @Override
    public int getFXLayer() {
       return 3;
    }
diff --git a/patches/net/minecraft/client/particle/ParticleManager.java b/patches/net/minecraft/client/particle/ParticleManager.java
index 42bf01b..7875950 100644
--- a/patches/net/minecraft/client/particle/ParticleManager.java
+++ b/patches/net/minecraft/client/particle/ParticleManager.java
@@ -10,8 +10,24 @@
 import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
+import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.particle.ParticleBreaking.SlimeFactory;
+import net.minecraft.client.particle.ParticleBreaking.SnowballFactory;
+import net.minecraft.client.particle.ParticleCrit.DamageIndicatorFactory;
+import net.minecraft.client.particle.ParticleCrit.MagicFactory;
+import net.minecraft.client.particle.ParticleDrip.LavaFactory;
+import net.minecraft.client.particle.ParticleDrip.WaterFactory;
+import net.minecraft.client.particle.ParticleEnchantmentTable.EnchantmentTable;
+import net.minecraft.client.particle.ParticleExplosion.Factory;
+import net.minecraft.client.particle.ParticleFirework.Spark;
+import net.minecraft.client.particle.ParticleHeart.AngryVillagerFactory;
+import net.minecraft.client.particle.ParticleSpell.AmbientMobFactory;
+import net.minecraft.client.particle.ParticleSpell.InstantFactory;
+import net.minecraft.client.particle.ParticleSpell.MobFactory;
+import net.minecraft.client.particle.ParticleSpell.WitchFactory;
+import net.minecraft.client.particle.ParticleSuspendedTown.HappyVillagerFactory;
 import net.minecraft.client.renderer.ActiveRenderInfo;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
@@ -31,7 +47,9 @@
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.world.World;
+import net.optifine.reflect.Reflector;
 
 public class ParticleManager {
    private static final ResourceLocation PARTICLE_TEXTURES = new ResourceLocation("textures/particle/particles.png");
@@ -43,15 +61,15 @@ public class ParticleManager {
    private final Map<Integer, IParticleFactory> particleTypes = Maps.newHashMap();
    private final Queue<Particle> queue = Queues.newArrayDeque();
 
-   public ParticleManager(World var1, TextureManager var2) {
-      this.world = ☃;
-      this.renderer = ☃;
+   public ParticleManager(World worldIn, TextureManager rendererIn) {
+      this.world = worldIn;
+      this.renderer = rendererIn;
 
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         this.fxLayers[☃] = new ArrayDeque[2];
+      for (int i = 0; i < 4; i++) {
+         this.fxLayers[i] = new ArrayDeque[2];
 
-         for (int ☃x = 0; ☃x < 2; ☃x++) {
-            this.fxLayers[☃][☃x] = Queues.newArrayDeque();
+         for (int j = 0; j < 2; j++) {
+            this.fxLayers[i][j] = Queues.newArrayDeque();
          }
       }
 
@@ -59,188 +77,217 @@ public ParticleManager(World var1, TextureManager var2) {
    }
 
    private void registerVanillaParticles() {
-      this.registerParticle(EnumParticleTypes.EXPLOSION_NORMAL.getParticleID(), new ParticleExplosion.Factory());
-      this.registerParticle(EnumParticleTypes.SPIT.getParticleID(), new ParticleSpit.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_BUBBLE.getParticleID(), new ParticleBubble.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_SPLASH.getParticleID(), new ParticleSplash.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_WAKE.getParticleID(), new ParticleWaterWake.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_DROP.getParticleID(), new ParticleRain.Factory());
-      this.registerParticle(EnumParticleTypes.SUSPENDED.getParticleID(), new ParticleSuspend.Factory());
-      this.registerParticle(EnumParticleTypes.SUSPENDED_DEPTH.getParticleID(), new ParticleSuspendedTown.Factory());
-      this.registerParticle(EnumParticleTypes.CRIT.getParticleID(), new ParticleCrit.Factory());
-      this.registerParticle(EnumParticleTypes.CRIT_MAGIC.getParticleID(), new ParticleCrit.MagicFactory());
-      this.registerParticle(EnumParticleTypes.SMOKE_NORMAL.getParticleID(), new ParticleSmokeNormal.Factory());
-      this.registerParticle(EnumParticleTypes.SMOKE_LARGE.getParticleID(), new ParticleSmokeLarge.Factory());
-      this.registerParticle(EnumParticleTypes.SPELL.getParticleID(), new ParticleSpell.Factory());
-      this.registerParticle(EnumParticleTypes.SPELL_INSTANT.getParticleID(), new ParticleSpell.InstantFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_MOB.getParticleID(), new ParticleSpell.MobFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID(), new ParticleSpell.AmbientMobFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_WITCH.getParticleID(), new ParticleSpell.WitchFactory());
-      this.registerParticle(EnumParticleTypes.DRIP_WATER.getParticleID(), new ParticleDrip.WaterFactory());
-      this.registerParticle(EnumParticleTypes.DRIP_LAVA.getParticleID(), new ParticleDrip.LavaFactory());
-      this.registerParticle(EnumParticleTypes.VILLAGER_ANGRY.getParticleID(), new ParticleHeart.AngryVillagerFactory());
-      this.registerParticle(EnumParticleTypes.VILLAGER_HAPPY.getParticleID(), new ParticleSuspendedTown.HappyVillagerFactory());
-      this.registerParticle(EnumParticleTypes.TOWN_AURA.getParticleID(), new ParticleSuspendedTown.Factory());
-      this.registerParticle(EnumParticleTypes.NOTE.getParticleID(), new ParticleNote.Factory());
-      this.registerParticle(EnumParticleTypes.PORTAL.getParticleID(), new ParticlePortal.Factory());
-      this.registerParticle(EnumParticleTypes.ENCHANTMENT_TABLE.getParticleID(), new ParticleEnchantmentTable.EnchantmentTable());
-      this.registerParticle(EnumParticleTypes.FLAME.getParticleID(), new ParticleFlame.Factory());
-      this.registerParticle(EnumParticleTypes.LAVA.getParticleID(), new ParticleLava.Factory());
-      this.registerParticle(EnumParticleTypes.FOOTSTEP.getParticleID(), new ParticleFootStep.Factory());
-      this.registerParticle(EnumParticleTypes.CLOUD.getParticleID(), new ParticleCloud.Factory());
-      this.registerParticle(EnumParticleTypes.REDSTONE.getParticleID(), new ParticleRedstone.Factory());
-      this.registerParticle(EnumParticleTypes.FALLING_DUST.getParticleID(), new ParticleFallingDust.Factory());
-      this.registerParticle(EnumParticleTypes.SNOWBALL.getParticleID(), new ParticleBreaking.SnowballFactory());
-      this.registerParticle(EnumParticleTypes.SNOW_SHOVEL.getParticleID(), new ParticleSnowShovel.Factory());
-      this.registerParticle(EnumParticleTypes.SLIME.getParticleID(), new ParticleBreaking.SlimeFactory());
-      this.registerParticle(EnumParticleTypes.HEART.getParticleID(), new ParticleHeart.Factory());
-      this.registerParticle(EnumParticleTypes.BARRIER.getParticleID(), new Barrier.Factory());
-      this.registerParticle(EnumParticleTypes.ITEM_CRACK.getParticleID(), new ParticleBreaking.Factory());
-      this.registerParticle(EnumParticleTypes.BLOCK_CRACK.getParticleID(), new ParticleDigging.Factory());
-      this.registerParticle(EnumParticleTypes.BLOCK_DUST.getParticleID(), new ParticleBlockDust.Factory());
-      this.registerParticle(EnumParticleTypes.EXPLOSION_HUGE.getParticleID(), new ParticleExplosionHuge.Factory());
-      this.registerParticle(EnumParticleTypes.EXPLOSION_LARGE.getParticleID(), new ParticleExplosionLarge.Factory());
-      this.registerParticle(EnumParticleTypes.FIREWORKS_SPARK.getParticleID(), new ParticleFirework.Factory());
-      this.registerParticle(EnumParticleTypes.MOB_APPEARANCE.getParticleID(), new ParticleMobAppearance.Factory());
-      this.registerParticle(EnumParticleTypes.DRAGON_BREATH.getParticleID(), new ParticleDragonBreath.Factory());
-      this.registerParticle(EnumParticleTypes.END_ROD.getParticleID(), new ParticleEndRod.Factory());
-      this.registerParticle(EnumParticleTypes.DAMAGE_INDICATOR.getParticleID(), new ParticleCrit.DamageIndicatorFactory());
-      this.registerParticle(EnumParticleTypes.SWEEP_ATTACK.getParticleID(), new ParticleSweepAttack.Factory());
-      this.registerParticle(EnumParticleTypes.TOTEM.getParticleID(), new ParticleTotem.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_NORMAL.getParticleID(), new Factory());
+      this.registerParticle(EnumParticleTypes.SPIT.getParticleID(), new net.minecraft.client.particle.ParticleSpit.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_BUBBLE.getParticleID(), new net.minecraft.client.particle.ParticleBubble.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_SPLASH.getParticleID(), new net.minecraft.client.particle.ParticleSplash.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_WAKE.getParticleID(), new net.minecraft.client.particle.ParticleWaterWake.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_DROP.getParticleID(), new net.minecraft.client.particle.ParticleRain.Factory());
+      this.registerParticle(EnumParticleTypes.SUSPENDED.getParticleID(), new net.minecraft.client.particle.ParticleSuspend.Factory());
+      this.registerParticle(EnumParticleTypes.SUSPENDED_DEPTH.getParticleID(), new net.minecraft.client.particle.ParticleSuspendedTown.Factory());
+      this.registerParticle(EnumParticleTypes.CRIT.getParticleID(), new net.minecraft.client.particle.ParticleCrit.Factory());
+      this.registerParticle(EnumParticleTypes.CRIT_MAGIC.getParticleID(), new MagicFactory());
+      this.registerParticle(EnumParticleTypes.SMOKE_NORMAL.getParticleID(), new net.minecraft.client.particle.ParticleSmokeNormal.Factory());
+      this.registerParticle(EnumParticleTypes.SMOKE_LARGE.getParticleID(), new net.minecraft.client.particle.ParticleSmokeLarge.Factory());
+      this.registerParticle(EnumParticleTypes.SPELL.getParticleID(), new net.minecraft.client.particle.ParticleSpell.Factory());
+      this.registerParticle(EnumParticleTypes.SPELL_INSTANT.getParticleID(), new InstantFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_MOB.getParticleID(), new MobFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID(), new AmbientMobFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_WITCH.getParticleID(), new WitchFactory());
+      this.registerParticle(EnumParticleTypes.DRIP_WATER.getParticleID(), new WaterFactory());
+      this.registerParticle(EnumParticleTypes.DRIP_LAVA.getParticleID(), new LavaFactory());
+      this.registerParticle(EnumParticleTypes.VILLAGER_ANGRY.getParticleID(), new AngryVillagerFactory());
+      this.registerParticle(EnumParticleTypes.VILLAGER_HAPPY.getParticleID(), new HappyVillagerFactory());
+      this.registerParticle(EnumParticleTypes.TOWN_AURA.getParticleID(), new net.minecraft.client.particle.ParticleSuspendedTown.Factory());
+      this.registerParticle(EnumParticleTypes.NOTE.getParticleID(), new net.minecraft.client.particle.ParticleNote.Factory());
+      this.registerParticle(EnumParticleTypes.PORTAL.getParticleID(), new net.minecraft.client.particle.ParticlePortal.Factory());
+      this.registerParticle(EnumParticleTypes.ENCHANTMENT_TABLE.getParticleID(), new EnchantmentTable());
+      this.registerParticle(EnumParticleTypes.FLAME.getParticleID(), new net.minecraft.client.particle.ParticleFlame.Factory());
+      this.registerParticle(EnumParticleTypes.LAVA.getParticleID(), new net.minecraft.client.particle.ParticleLava.Factory());
+      this.registerParticle(EnumParticleTypes.FOOTSTEP.getParticleID(), new net.minecraft.client.particle.ParticleFootStep.Factory());
+      this.registerParticle(EnumParticleTypes.CLOUD.getParticleID(), new net.minecraft.client.particle.ParticleCloud.Factory());
+      this.registerParticle(EnumParticleTypes.REDSTONE.getParticleID(), new net.minecraft.client.particle.ParticleRedstone.Factory());
+      this.registerParticle(EnumParticleTypes.FALLING_DUST.getParticleID(), new net.minecraft.client.particle.ParticleFallingDust.Factory());
+      this.registerParticle(EnumParticleTypes.SNOWBALL.getParticleID(), new SnowballFactory());
+      this.registerParticle(EnumParticleTypes.SNOW_SHOVEL.getParticleID(), new net.minecraft.client.particle.ParticleSnowShovel.Factory());
+      this.registerParticle(EnumParticleTypes.SLIME.getParticleID(), new SlimeFactory());
+      this.registerParticle(EnumParticleTypes.HEART.getParticleID(), new net.minecraft.client.particle.ParticleHeart.Factory());
+      this.registerParticle(EnumParticleTypes.BARRIER.getParticleID(), new net.minecraft.client.particle.Barrier.Factory());
+      this.registerParticle(EnumParticleTypes.ITEM_CRACK.getParticleID(), new net.minecraft.client.particle.ParticleBreaking.Factory());
+      this.registerParticle(EnumParticleTypes.BLOCK_CRACK.getParticleID(), new net.minecraft.client.particle.ParticleDigging.Factory());
+      this.registerParticle(EnumParticleTypes.BLOCK_DUST.getParticleID(), new net.minecraft.client.particle.ParticleBlockDust.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_HUGE.getParticleID(), new net.minecraft.client.particle.ParticleExplosionHuge.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_LARGE.getParticleID(), new net.minecraft.client.particle.ParticleExplosionLarge.Factory());
+      this.registerParticle(EnumParticleTypes.FIREWORKS_SPARK.getParticleID(), new net.minecraft.client.particle.ParticleFirework.Factory());
+      this.registerParticle(EnumParticleTypes.MOB_APPEARANCE.getParticleID(), new net.minecraft.client.particle.ParticleMobAppearance.Factory());
+      this.registerParticle(EnumParticleTypes.DRAGON_BREATH.getParticleID(), new net.minecraft.client.particle.ParticleDragonBreath.Factory());
+      this.registerParticle(EnumParticleTypes.END_ROD.getParticleID(), new net.minecraft.client.particle.ParticleEndRod.Factory());
+      this.registerParticle(EnumParticleTypes.DAMAGE_INDICATOR.getParticleID(), new DamageIndicatorFactory());
+      this.registerParticle(EnumParticleTypes.SWEEP_ATTACK.getParticleID(), new net.minecraft.client.particle.ParticleSweepAttack.Factory());
+      this.registerParticle(EnumParticleTypes.TOTEM.getParticleID(), new net.minecraft.client.particle.ParticleTotem.Factory());
    }
 
-   public void registerParticle(int var1, IParticleFactory var2) {
-      this.particleTypes.put(☃, ☃);
+   public void registerParticle(int id, IParticleFactory particleFactory) {
+      this.particleTypes.put(id, particleFactory);
    }
 
-   public void emitParticleAtEntity(Entity var1, EnumParticleTypes var2) {
-      this.particleEmitters.add(new ParticleEmitter(this.world, ☃, ☃));
+   public void emitParticleAtEntity(Entity entityIn, EnumParticleTypes particleTypes) {
+      this.particleEmitters.add(new ParticleEmitter(this.world, entityIn, particleTypes));
    }
 
-   public void emitParticleAtEntity(Entity var1, EnumParticleTypes var2, int var3) {
-      this.particleEmitters.add(new ParticleEmitter(this.world, ☃, ☃, ☃));
+   public void emitParticleAtEntity(Entity p_191271_1_, EnumParticleTypes p_191271_2_, int p_191271_3_) {
+      this.particleEmitters.add(new ParticleEmitter(this.world, p_191271_1_, p_191271_2_, p_191271_3_));
    }
 
    @Nullable
-   public Particle spawnEffectParticle(int var1, double var2, double var4, double var6, double var8, double var10, double var12, int... var14) {
-      IParticleFactory ☃ = this.particleTypes.get(☃);
-      if (☃ != null) {
-         Particle ☃x = ☃.createParticle(☃, this.world, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         if (☃x != null) {
-            this.addEffect(☃x);
-            return ☃x;
+   public Particle spawnEffectParticle(
+      int particleId, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters
+   ) {
+      IParticleFactory iparticlefactory = this.particleTypes.get(particleId);
+      if (iparticlefactory != null) {
+         Particle particle = iparticlefactory.createParticle(particleId, this.world, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
+         if (particle != null) {
+            this.addEffect(particle);
+            return particle;
          }
       }
 
       return null;
    }
 
-   public void addEffect(Particle var1) {
-      this.queue.add(☃);
+   public void addEffect(Particle effect) {
+      if (effect != null) {
+         if (!(effect instanceof Spark) || Config.isFireworkParticles()) {
+            this.queue.add(effect);
+         }
+      }
    }
 
    public void updateEffects() {
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         this.updateEffectLayer(☃);
+      for (int i = 0; i < 4; i++) {
+         this.updateEffectLayer(i);
       }
 
       if (!this.particleEmitters.isEmpty()) {
-         List<ParticleEmitter> ☃ = Lists.newArrayList();
+         List<ParticleEmitter> list = Lists.newArrayList();
 
-         for (ParticleEmitter ☃x : this.particleEmitters) {
-            ☃x.onUpdate();
-            if (!☃x.isAlive()) {
-               ☃.add(☃x);
+         for (ParticleEmitter particleemitter : this.particleEmitters) {
+            particleemitter.onUpdate();
+            if (!particleemitter.k()) {
+               list.add(particleemitter);
             }
          }
 
-         this.particleEmitters.removeAll(☃);
+         this.particleEmitters.removeAll(list);
       }
 
       if (!this.queue.isEmpty()) {
-         for (Particle ☃ = this.queue.poll(); ☃ != null; ☃ = this.queue.poll()) {
-            int ☃xx = ☃.getFXLayer();
-            int ☃xxx = ☃.shouldDisableDepth() ? 0 : 1;
-            if (this.fxLayers[☃xx][☃xxx].size() >= 16384) {
-               this.fxLayers[☃xx][☃xxx].removeFirst();
+         for (Particle particle = this.queue.poll(); particle != null; particle = this.queue.poll()) {
+            int j = particle.getFXLayer();
+            int k = particle.shouldDisableDepth() ? 0 : 1;
+            if (this.fxLayers[j][k].size() >= 16384) {
+               this.fxLayers[j][k].removeFirst();
             }
 
-            this.fxLayers[☃xx][☃xxx].add(☃);
+            if (!(particle instanceof Barrier) || !this.reuseBarrierParticle(particle, this.fxLayers[j][k])) {
+               this.fxLayers[j][k].add(particle);
+            }
          }
       }
    }
 
-   private void updateEffectLayer(int var1) {
-      this.world.profiler.startSection(String.valueOf(☃));
+   private void updateEffectLayer(int layer) {
+      this.world.profiler.startSection(String.valueOf(layer));
 
-      for (int ☃ = 0; ☃ < 2; ☃++) {
-         this.world.profiler.startSection(String.valueOf(☃));
-         this.tickParticleList(this.fxLayers[☃][☃]);
+      for (int i = 0; i < 2; i++) {
+         this.world.profiler.startSection(String.valueOf(i));
+         this.tickParticleList(this.fxLayers[layer][i]);
          this.world.profiler.endSection();
       }
 
       this.world.profiler.endSection();
    }
 
-   private void tickParticleList(Queue<Particle> var1) {
-      if (!☃.isEmpty()) {
-         Iterator<Particle> ☃ = ☃.iterator();
+   private void tickParticleList(Queue<Particle> p_187240_1_) {
+      if (!p_187240_1_.isEmpty()) {
+         long timeStartMs = System.currentTimeMillis();
+         int countLeft = p_187240_1_.size();
+         Iterator<Particle> iterator = p_187240_1_.iterator();
+
+         while (iterator.hasNext()) {
+            Particle particle = iterator.next();
+            this.tickParticle(particle);
+            if (!particle.isAlive()) {
+               iterator.remove();
+            }
 
-         while (☃.hasNext()) {
-            Particle ☃x = ☃.next();
-            this.tickParticle(☃x);
-            if (!☃x.isAlive()) {
-               ☃.remove();
+            countLeft--;
+            if (System.currentTimeMillis() > timeStartMs + 20L) {
+               break;
+            }
+         }
+
+         if (countLeft > 0) {
+            int countToRemove = countLeft;
+
+            for (Iterator it = p_187240_1_.iterator(); it.hasNext() && countToRemove > 0; countToRemove--) {
+               Particle particlex = (Particle)it.next();
+               particlex.setExpired();
+               it.remove();
             }
          }
       }
    }
 
-   private void tickParticle(final Particle var1) {
+   private void tickParticle(final Particle particle) {
       try {
-         ☃.onUpdate();
+         particle.onUpdate();
       } catch (Throwable var6) {
-         CrashReport ☃ = CrashReport.makeCrashReport(var6, "Ticking Particle");
-         CrashReportCategory ☃x = ☃.makeCategory("Particle being ticked");
-         final int ☃xx = ☃.getFXLayer();
-         ☃x.addDetail("Particle", new ICrashReportDetail<String>() {
+         CrashReport crashreport = CrashReport.makeCrashReport(var6, "Ticking Particle");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Particle being ticked");
+         final int i = particle.getFXLayer();
+         crashreportcategory.addDetail("Particle", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return ☃.toString();
+               return particle.toString();
             }
          });
-         ☃x.addDetail("Particle Type", new ICrashReportDetail<String>() {
+         crashreportcategory.addDetail("Particle Type", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               if (☃ == 0) {
+               if (i == 0) {
                   return "MISC_TEXTURE";
-               } else if (☃ == 1) {
+               } else if (i == 1) {
                   return "TERRAIN_TEXTURE";
                } else {
-                  return ☃ == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + ☃;
+                  return i == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + i;
                }
             }
          });
-         throw new ReportedException(☃);
+         throw new ReportedException(crashreport);
       }
    }
 
-   public void renderParticles(Entity var1, float var2) {
-      float ☃ = ActiveRenderInfo.getRotationX();
-      float ☃x = ActiveRenderInfo.getRotationZ();
-      float ☃xx = ActiveRenderInfo.getRotationYZ();
-      float ☃xxx = ActiveRenderInfo.getRotationXY();
-      float ☃xxxx = ActiveRenderInfo.getRotationXZ();
-      Particle.interpPosX = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      Particle.interpPosY = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      Particle.interpPosZ = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      Particle.cameraViewDir = ☃.getLook(☃);
+   public void renderParticles(Entity entityIn, float partialTicks) {
+      float f = ActiveRenderInfo.getRotationX();
+      float f1 = ActiveRenderInfo.getRotationZ();
+      float f2 = ActiveRenderInfo.getRotationYZ();
+      float f3 = ActiveRenderInfo.getRotationXY();
+      float f4 = ActiveRenderInfo.getRotationXZ();
+      Particle.interpPosX = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;
+      Particle.interpPosY = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;
+      Particle.interpPosZ = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;
+      Particle.cameraViewDir = entityIn.getLook(partialTicks);
       GlStateManager.enableBlend();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
       GlStateManager.alphaFunc(516, 0.003921569F);
+      IBlockState cameraBlockState = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.world, entityIn, partialTicks);
+      boolean isEyeInWater = cameraBlockState.a() == Material.WATER;
+
+      for (int i_nf = 0; i_nf < 3; i_nf++) {
+         final int i = i_nf;
 
-      for (final int ☃xxxxx = 0; ☃xxxxx < 3; ☃xxxxx++) {
-         for (int ☃xxxxxx = 0; ☃xxxxxx < 2; ☃xxxxxx++) {
-            if (!this.fxLayers[☃xxxxx][☃xxxxxx].isEmpty()) {
-               switch (☃xxxxxx) {
+         for (int j = 0; j < 2; j++) {
+            if (!this.fxLayers[i][j].isEmpty()) {
+               switch (j) {
                   case 0:
                      GlStateManager.depthMask(false);
                      break;
@@ -248,7 +295,7 @@ public void renderParticles(Entity var1, float var2) {
                      GlStateManager.depthMask(true);
                }
 
-               switch (☃xxxxx) {
+               switch (i) {
                   case 0:
                   default:
                      this.renderer.bindTexture(PARTICLE_TEXTURES);
@@ -258,37 +305,39 @@ public void renderParticles(Entity var1, float var2) {
                }
 
                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-               Tessellator ☃xxxxxxx = Tessellator.getInstance();
-               BufferBuilder ☃xxxxxxxx = ☃xxxxxxx.getBuffer();
-               ☃xxxxxxxx.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
+               Tessellator tessellator = Tessellator.getInstance();
+               BufferBuilder bufferbuilder = tessellator.getBuffer();
+               bufferbuilder.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
 
-               for (final Particle ☃xxxxxxxxx : this.fxLayers[☃xxxxx][☃xxxxxx]) {
+               for (final Particle particle : this.fxLayers[i][j]) {
                   try {
-                     ☃xxxxxxxxx.renderParticle(☃xxxxxxxx, ☃, ☃, ☃, ☃xxxx, ☃x, ☃xx, ☃xxx);
-                  } catch (Throwable var18) {
-                     CrashReport ☃xxxxxxxxxx = CrashReport.makeCrashReport(var18, "Rendering Particle");
-                     CrashReportCategory ☃xxxxxxxxxxx = ☃xxxxxxxxxx.makeCategory("Particle being rendered");
-                     ☃xxxxxxxxxxx.addDetail("Particle", new ICrashReportDetail<String>() {
+                     if (isEyeInWater || !(particle instanceof ParticleSuspend)) {
+                        particle.renderParticle(bufferbuilder, entityIn, partialTicks, f, f4, f1, f2, f3);
+                     }
+                  } catch (Throwable var20) {
+                     CrashReport crashreport = CrashReport.makeCrashReport(var20, "Rendering Particle");
+                     CrashReportCategory crashreportcategory = crashreport.makeCategory("Particle being rendered");
+                     crashreportcategory.addDetail("Particle", new ICrashReportDetail<String>() {
                         public String call() throws Exception {
-                           return ☃.toString();
+                           return particle.toString();
                         }
                      });
-                     ☃xxxxxxxxxxx.addDetail("Particle Type", new ICrashReportDetail<String>() {
+                     crashreportcategory.addDetail("Particle Type", new ICrashReportDetail<String>() {
                         public String call() throws Exception {
-                           if (☃ == 0) {
+                           if (i == 0) {
                               return "MISC_TEXTURE";
-                           } else if (☃ == 1) {
+                           } else if (i == 1) {
                               return "TERRAIN_TEXTURE";
                            } else {
-                              return ☃ == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + ☃;
+                              return i == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + i;
                            }
                         }
                      });
-                     throw new ReportedException(☃xxxxxxxxxx);
+                     throw new ReportedException(crashreport);
                   }
                }
 
-               ☃xxxxxxx.draw();
+               tessellator.draw();
             }
          }
       }
@@ -298,53 +347,61 @@ public String call() throws Exception {
       GlStateManager.alphaFunc(516, 0.1F);
    }
 
-   public void renderLitParticles(Entity var1, float var2) {
-      float ☃ = (float) (Math.PI / 180.0);
-      float ☃x = MathHelper.cos(☃.rotationYaw * (float) (Math.PI / 180.0));
-      float ☃xx = MathHelper.sin(☃.rotationYaw * (float) (Math.PI / 180.0));
-      float ☃xxx = -☃xx * MathHelper.sin(☃.rotationPitch * (float) (Math.PI / 180.0));
-      float ☃xxxx = ☃x * MathHelper.sin(☃.rotationPitch * (float) (Math.PI / 180.0));
-      float ☃xxxxx = MathHelper.cos(☃.rotationPitch * (float) (Math.PI / 180.0));
-
-      for (int ☃xxxxxx = 0; ☃xxxxxx < 2; ☃xxxxxx++) {
-         Queue<Particle> ☃xxxxxxx = this.fxLayers[3][☃xxxxxx];
-         if (!☃xxxxxxx.isEmpty()) {
-            Tessellator ☃xxxxxxxx = Tessellator.getInstance();
-            BufferBuilder ☃xxxxxxxxx = ☃xxxxxxxx.getBuffer();
-
-            for (Particle ☃xxxxxxxxxx : ☃xxxxxxx) {
-               ☃xxxxxxxxxx.renderParticle(☃xxxxxxxxx, ☃, ☃, ☃x, ☃xxxxx, ☃xx, ☃xxx, ☃xxxx);
+   public void renderLitParticles(Entity entityIn, float partialTick) {
+      float f = (float) (Math.PI / 180.0);
+      float f1 = MathHelper.cos(entityIn.rotationYaw * (float) (Math.PI / 180.0));
+      float f2 = MathHelper.sin(entityIn.rotationYaw * (float) (Math.PI / 180.0));
+      float f3 = -f2 * MathHelper.sin(entityIn.rotationPitch * (float) (Math.PI / 180.0));
+      float f4 = f1 * MathHelper.sin(entityIn.rotationPitch * (float) (Math.PI / 180.0));
+      float f5 = MathHelper.cos(entityIn.rotationPitch * (float) (Math.PI / 180.0));
+
+      for (int i = 0; i < 2; i++) {
+         Queue<Particle> queue = this.fxLayers[3][i];
+         if (!queue.isEmpty()) {
+            Tessellator tessellator = Tessellator.getInstance();
+            BufferBuilder bufferbuilder = tessellator.getBuffer();
+
+            for (Particle particle : queue) {
+               particle.renderParticle(bufferbuilder, entityIn, partialTick, f1, f5, f2, f3, f4);
             }
          }
       }
    }
 
-   public void clearEffects(@Nullable World var1) {
-      this.world = ☃;
+   public void clearEffects(@Nullable World worldIn) {
+      this.world = worldIn;
 
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         for (int ☃x = 0; ☃x < 2; ☃x++) {
-            this.fxLayers[☃][☃x].clear();
+      for (int i = 0; i < 4; i++) {
+         for (int j = 0; j < 2; j++) {
+            this.fxLayers[i][j].clear();
          }
       }
 
       this.particleEmitters.clear();
    }
 
-   public void addBlockDestroyEffects(BlockPos var1, IBlockState var2) {
-      if (☃.getMaterial() != Material.AIR) {
-         ☃ = ☃.getActualState(this.world, ☃);
-         int ☃ = 4;
-
-         for (int ☃x = 0; ☃x < 4; ☃x++) {
-            for (int ☃xx = 0; ☃xx < 4; ☃xx++) {
-               for (int ☃xxx = 0; ☃xxx < 4; ☃xxx++) {
-                  double ☃xxxx = (☃x + 0.5) / 4.0;
-                  double ☃xxxxx = (☃xx + 0.5) / 4.0;
-                  double ☃xxxxxx = (☃xxx + 0.5) / 4.0;
+   public void addBlockDestroyEffects(BlockPos pos, IBlockState state) {
+      boolean notAir;
+      if (Reflector.ForgeBlock_addDestroyEffects.exists() && Reflector.ForgeBlock_isAir.exists()) {
+         Block block = state.getBlock();
+         notAir = !Reflector.callBoolean(block, Reflector.ForgeBlock_isAir, new Object[]{state, this.world, pos})
+            && !Reflector.callBoolean(block, Reflector.ForgeBlock_addDestroyEffects, new Object[]{this.world, pos, this});
+      } else {
+         notAir = state.a() != Material.AIR;
+      }
+
+      if (notAir) {
+         state = state.c(this.world, pos);
+         int i = 4;
+
+         for (int j = 0; j < 4; j++) {
+            for (int k = 0; k < 4; k++) {
+               for (int l = 0; l < 4; l++) {
+                  double d0 = (j + 0.5) / 4.0;
+                  double d1 = (k + 0.5) / 4.0;
+                  double d2 = (l + 0.5) / 4.0;
                   this.addEffect(
-                     new ParticleDigging(this.world, ☃.getX() + ☃xxxx, ☃.getY() + ☃xxxxx, ☃.getZ() + ☃xxxxxx, ☃xxxx - 0.5, ☃xxxxx - 0.5, ☃xxxxxx - 0.5, ☃)
-                        .setBlockPos(☃)
+                     new ParticleDigging(this.world, pos.getX() + d0, pos.getY() + d1, pos.getZ() + d2, d0 - 0.5, d1 - 0.5, d2 - 0.5, state).setBlockPos(pos)
                   );
                }
             }
@@ -352,56 +409,77 @@ public void addBlockDestroyEffects(BlockPos var1, IBlockState var2) {
       }
    }
 
-   public void addBlockHitEffects(BlockPos var1, EnumFacing var2) {
-      IBlockState ☃ = this.world.getBlockState(☃);
-      if (☃.getRenderType() != EnumBlockRenderType.INVISIBLE) {
-         int ☃x = ☃.getX();
-         int ☃xx = ☃.getY();
-         int ☃xxx = ☃.getZ();
-         float ☃xxxx = 0.1F;
-         AxisAlignedBB ☃xxxxx = ☃.getBoundingBox(this.world, ☃);
-         double ☃xxxxxx = ☃x + this.rand.nextDouble() * (☃xxxxx.maxX - ☃xxxxx.minX - 0.2F) + 0.1F + ☃xxxxx.minX;
-         double ☃xxxxxxx = ☃xx + this.rand.nextDouble() * (☃xxxxx.maxY - ☃xxxxx.minY - 0.2F) + 0.1F + ☃xxxxx.minY;
-         double ☃xxxxxxxx = ☃xxx + this.rand.nextDouble() * (☃xxxxx.maxZ - ☃xxxxx.minZ - 0.2F) + 0.1F + ☃xxxxx.minZ;
-         if (☃ == EnumFacing.DOWN) {
-            ☃xxxxxxx = ☃xx + ☃xxxxx.minY - 0.1F;
+   public void addBlockHitEffects(BlockPos pos, EnumFacing side) {
+      IBlockState iblockstate = this.world.getBlockState(pos);
+      if (iblockstate.i() != EnumBlockRenderType.INVISIBLE) {
+         int i = pos.getX();
+         int j = pos.getY();
+         int k = pos.getZ();
+         float f = 0.1F;
+         AxisAlignedBB axisalignedbb = iblockstate.e(this.world, pos);
+         double d0 = i + this.rand.nextDouble() * (axisalignedbb.maxX - axisalignedbb.minX - 0.2F) + 0.1F + axisalignedbb.minX;
+         double d1 = j + this.rand.nextDouble() * (axisalignedbb.maxY - axisalignedbb.minY - 0.2F) + 0.1F + axisalignedbb.minY;
+         double d2 = k + this.rand.nextDouble() * (axisalignedbb.maxZ - axisalignedbb.minZ - 0.2F) + 0.1F + axisalignedbb.minZ;
+         if (side == EnumFacing.DOWN) {
+            d1 = j + axisalignedbb.minY - 0.1F;
          }
 
-         if (☃ == EnumFacing.UP) {
-            ☃xxxxxxx = ☃xx + ☃xxxxx.maxY + 0.1F;
+         if (side == EnumFacing.UP) {
+            d1 = j + axisalignedbb.maxY + 0.1F;
          }
 
-         if (☃ == EnumFacing.NORTH) {
-            ☃xxxxxxxx = ☃xxx + ☃xxxxx.minZ - 0.1F;
+         if (side == EnumFacing.NORTH) {
+            d2 = k + axisalignedbb.minZ - 0.1F;
          }
 
-         if (☃ == EnumFacing.SOUTH) {
-            ☃xxxxxxxx = ☃xxx + ☃xxxxx.maxZ + 0.1F;
+         if (side == EnumFacing.SOUTH) {
+            d2 = k + axisalignedbb.maxZ + 0.1F;
          }
 
-         if (☃ == EnumFacing.WEST) {
-            ☃xxxxxx = ☃x + ☃xxxxx.minX - 0.1F;
+         if (side == EnumFacing.WEST) {
+            d0 = i + axisalignedbb.minX - 0.1F;
          }
 
-         if (☃ == EnumFacing.EAST) {
-            ☃xxxxxx = ☃x + ☃xxxxx.maxX + 0.1F;
+         if (side == EnumFacing.EAST) {
+            d0 = i + axisalignedbb.maxX + 0.1F;
          }
 
          this.addEffect(
-            new ParticleDigging(this.world, ☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.0, 0.0, 0.0, ☃).setBlockPos(☃).multiplyVelocity(0.2F).multipleParticleScaleBy(0.6F)
+            new ParticleDigging(this.world, d0, d1, d2, 0.0, 0.0, 0.0, iblockstate).setBlockPos(pos).multiplyVelocity(0.2F).multipleParticleScaleBy(0.6F)
          );
       }
    }
 
    public String getStatistics() {
-      int ☃ = 0;
+      int i = 0;
+
+      for (int j = 0; j < 4; j++) {
+         for (int k = 0; k < 2; k++) {
+            i += this.fxLayers[j][k].size();
+         }
+      }
+
+      return "" + i;
+   }
 
-      for (int ☃x = 0; ☃x < 4; ☃x++) {
-         for (int ☃xx = 0; ☃xx < 2; ☃xx++) {
-            ☃ += this.fxLayers[☃x][☃xx].size();
+   private boolean reuseBarrierParticle(Particle entityfx, ArrayDeque<Particle> deque) {
+      for (Particle efx : deque) {
+         if (efx instanceof Barrier && entityfx.prevPosX == efx.prevPosX && entityfx.prevPosY == efx.prevPosY && entityfx.prevPosZ == efx.prevPosZ) {
+            efx.particleAge = 0;
+            return true;
          }
       }
 
-      return "" + ☃;
+      return false;
+   }
+
+   public void addBlockHitEffects(BlockPos pos, RayTraceResult target) {
+      IBlockState state = this.world.getBlockState(pos);
+      if (state != null) {
+         boolean blockAddHitEffects = Reflector.callBoolean(state.getBlock(), Reflector.ForgeBlock_addHitEffects, new Object[]{state, this.world, target, this});
+         if (state != null && !blockAddHitEffects) {
+            this.addBlockHitEffects(pos, target.sideHit);
+         }
+      }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/BlockFluidRenderer.java b/patches/net/minecraft/client/renderer/BlockFluidRenderer.java
index 1bb9e7d..65c9088 100644
--- a/patches/net/minecraft/client/renderer/BlockFluidRenderer.java
+++ b/patches/net/minecraft/client/renderer/BlockFluidRenderer.java
@@ -2,9 +2,12 @@
 
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockLiquid;
+import net.minecraft.block.BlockSlab;
+import net.minecraft.block.BlockSlab.EnumBlockHalf;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.block.model.FaceBakery;
 import net.minecraft.client.renderer.color.BlockColors;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
@@ -13,6 +16,9 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.IBlockAccess;
+import net.optifine.CustomColors;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
 
 public class BlockFluidRenderer {
    private final BlockColors blockColors;
@@ -20,403 +26,298 @@ public class BlockFluidRenderer {
    private final TextureAtlasSprite[] atlasSpritesWater = new TextureAtlasSprite[2];
    private TextureAtlasSprite atlasSpriteWaterOverlay;
 
-   public BlockFluidRenderer(BlockColors var1) {
-      this.blockColors = ☃;
+   public BlockFluidRenderer(BlockColors blockColorsIn) {
+      this.blockColors = blockColorsIn;
       this.initAtlasSprites();
    }
 
    protected void initAtlasSprites() {
-      TextureMap ☃ = Minecraft.getMinecraft().getTextureMapBlocks();
-      this.atlasSpritesLava[0] = ☃.getAtlasSprite("minecraft:blocks/lava_still");
-      this.atlasSpritesLava[1] = ☃.getAtlasSprite("minecraft:blocks/lava_flow");
-      this.atlasSpritesWater[0] = ☃.getAtlasSprite("minecraft:blocks/water_still");
-      this.atlasSpritesWater[1] = ☃.getAtlasSprite("minecraft:blocks/water_flow");
-      this.atlasSpriteWaterOverlay = ☃.getAtlasSprite("minecraft:blocks/water_overlay");
+      TextureMap texturemap = Minecraft.getMinecraft().getTextureMapBlocks();
+      this.atlasSpritesLava[0] = texturemap.getAtlasSprite("minecraft:blocks/lava_still");
+      this.atlasSpritesLava[1] = texturemap.getAtlasSprite("minecraft:blocks/lava_flow");
+      this.atlasSpritesWater[0] = texturemap.getAtlasSprite("minecraft:blocks/water_still");
+      this.atlasSpritesWater[1] = texturemap.getAtlasSprite("minecraft:blocks/water_flow");
+      this.atlasSpriteWaterOverlay = texturemap.getAtlasSprite("minecraft:blocks/water_overlay");
    }
 
-   public boolean renderFluid(IBlockAccess var1, IBlockState var2, BlockPos var3, BufferBuilder var4) {
-      BlockLiquid ☃ = (BlockLiquid)☃.getBlock();
-      boolean ☃x = ☃.getMaterial() == Material.LAVA;
-      TextureAtlasSprite[] ☃xx = ☃x ? this.atlasSpritesLava : this.atlasSpritesWater;
-      int ☃xxx = this.blockColors.colorMultiplier(☃, ☃, ☃, 0);
-      float ☃xxxx = (☃xxx >> 16 & 0xFF) / 255.0F;
-      float ☃xxxxx = (☃xxx >> 8 & 0xFF) / 255.0F;
-      float ☃xxxxxx = (☃xxx & 0xFF) / 255.0F;
-      boolean ☃xxxxxxx = ☃.shouldSideBeRendered(☃, ☃, EnumFacing.UP);
-      boolean ☃xxxxxxxx = ☃.shouldSideBeRendered(☃, ☃, EnumFacing.DOWN);
-      boolean[] ☃xxxxxxxxx = new boolean[]{
-         ☃.shouldSideBeRendered(☃, ☃, EnumFacing.NORTH),
-         ☃.shouldSideBeRendered(☃, ☃, EnumFacing.SOUTH),
-         ☃.shouldSideBeRendered(☃, ☃, EnumFacing.WEST),
-         ☃.shouldSideBeRendered(☃, ☃, EnumFacing.EAST)
-      };
-      if (!☃xxxxxxx && !☃xxxxxxxx && !☃xxxxxxxxx[0] && !☃xxxxxxxxx[1] && !☃xxxxxxxxx[2] && !☃xxxxxxxxx[3]) {
-         return false;
-      } else {
-         boolean ☃xxxxxxxxxx = false;
-         float ☃xxxxxxxxxxx = 0.5F;
-         float ☃xxxxxxxxxxxx = 1.0F;
-         float ☃xxxxxxxxxxxxx = 0.8F;
-         float ☃xxxxxxxxxxxxxx = 0.6F;
-         Material ☃xxxxxxxxxxxxxxx = ☃.getMaterial();
-         float ☃xxxxxxxxxxxxxxxx = this.getFluidHeight(☃, ☃, ☃xxxxxxxxxxxxxxx);
-         float ☃xxxxxxxxxxxxxxxxx = this.getFluidHeight(☃, ☃.south(), ☃xxxxxxxxxxxxxxx);
-         float ☃xxxxxxxxxxxxxxxxxx = this.getFluidHeight(☃, ☃.east().south(), ☃xxxxxxxxxxxxxxx);
-         float ☃xxxxxxxxxxxxxxxxxxx = this.getFluidHeight(☃, ☃.east(), ☃xxxxxxxxxxxxxxx);
-         double ☃xxxxxxxxxxxxxxxxxxxx = ☃.getX();
-         double ☃xxxxxxxxxxxxxxxxxxxxx = ☃.getY();
-         double ☃xxxxxxxxxxxxxxxxxxxxxx = ☃.getZ();
-         float ☃xxxxxxxxxxxxxxxxxxxxxxx = 0.001F;
-         if (☃xxxxxxx) {
-            ☃xxxxxxxxxx = true;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxx = BlockLiquid.getSlopeAngle(☃, ☃, ☃xxxxxxxxxxxxxxx, ☃);
-            TextureAtlasSprite ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxx > -999.0F ? ☃xx[1] : ☃xx[0];
-            ☃xxxxxxxxxxxxxxxx -= 0.001F;
-            ☃xxxxxxxxxxxxxxxxx -= 0.001F;
-            ☃xxxxxxxxxxxxxxxxxx -= 0.001F;
-            ☃xxxxxxxxxxxxxxxxxxx -= 0.001F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            if (☃xxxxxxxxxxxxxxxxxxxxxxxx < -999.0F) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(0.0);
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(0.0);
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(16.0);
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(16.0);
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            } else {
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.sin(☃xxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.cos(☃xxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 8.0F;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(
-                  8.0F + (-☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  8.0F + (-☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(
-                  8.0F + (-☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  8.0F + (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(
-                  8.0F + (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  8.0F + (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(
-                  8.0F + (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  8.0F + (-☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F
-               );
-            }
-
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃);
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx >> 16 & 65535;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx & 65535;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxxx;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxxxx;
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 0.0)
-               .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-               .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-               .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 0.0)
-               .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            if (☃.shouldRenderSides(☃, ☃.up())) {
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 0.0)
-                  .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 0.0)
-                  .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-                  .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-                  .color(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-            }
+   public boolean renderFluid(IBlockAccess blockAccess, IBlockState blockStateIn, BlockPos blockPosIn, BufferBuilder worldRendererIn) {
+      boolean flag3;
+      try {
+         if (Config.isShaders()) {
+            SVertexBuilder.pushEntity(blockStateIn, blockPosIn, blockAccess, worldRendererIn);
          }
 
-         if (☃xxxxxxxx) {
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx[0].getMinU();
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx[0].getMaxU();
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx[0].getMinV();
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx[0].getMaxV();
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃.down());
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx >> 16 & 65535;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx & 65535;
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-               .color(0.5F, 0.5F, 0.5F, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx)
-               .color(0.5F, 0.5F, 0.5F, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx)
-               .color(0.5F, 0.5F, 0.5F, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃.pos(☃xxxxxxxxxxxxxxxxxxxx + 1.0, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0)
-               .color(0.5F, 0.5F, 0.5F, 1.0F)
-               .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-               .endVertex();
-            ☃xxxxxxxxxx = true;
-         }
+         BlockLiquid blockliquid = (BlockLiquid)blockStateIn.getBlock();
+         boolean flag = blockStateIn.a() == Material.LAVA;
+         TextureAtlasSprite[] atextureatlassprite = flag ? this.atlasSpritesLava : this.atlasSpritesWater;
+         RenderEnv renderEnv = worldRendererIn.getRenderEnv(blockStateIn, blockPosIn);
+         int i = CustomColors.getFluidColor(blockAccess, blockStateIn, blockPosIn, renderEnv);
+         float f = (i >> 16 & 0xFF) / 255.0F;
+         float f1 = (i >> 8 & 0xFF) / 255.0F;
+         float f2 = (i & 0xFF) / 255.0F;
+         boolean flag1 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.UP);
+         boolean flag2 = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.DOWN);
+         boolean[] aboolean = renderEnv.getBorderFlags();
+         aboolean[0] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.NORTH);
+         aboolean[1] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.SOUTH);
+         aboolean[2] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.WEST);
+         aboolean[3] = blockStateIn.c(blockAccess, blockPosIn, EnumFacing.EAST);
+         if (flag1 || flag2 || aboolean[0] || aboolean[1] || aboolean[2] || aboolean[3]) {
+            flag3 = false;
+            float f3 = 0.5F;
+            float f4 = 1.0F;
+            float f5 = 0.8F;
+            float f6 = 0.6F;
+            Material material = blockStateIn.a();
+            float f7 = this.getFluidHeight(blockAccess, blockPosIn, material);
+            float f8 = this.getFluidHeight(blockAccess, blockPosIn.south(), material);
+            float f9 = this.getFluidHeight(blockAccess, blockPosIn.east().south(), material);
+            float f10 = this.getFluidHeight(blockAccess, blockPosIn.east(), material);
+            double d0 = blockPosIn.getX();
+            double d1 = blockPosIn.getY();
+            double d2 = blockPosIn.getZ();
+            float f11 = 0.001F;
+            if (flag1) {
+               flag3 = true;
+               float f12 = BlockLiquid.getSlopeAngle(blockAccess, blockPosIn, material, blockStateIn);
+               TextureAtlasSprite textureatlassprite = f12 > -999.0F ? atextureatlassprite[1] : atextureatlassprite[0];
+               worldRendererIn.setSprite(textureatlassprite);
+               f7 -= 0.001F;
+               f8 -= 0.001F;
+               f9 -= 0.001F;
+               f10 -= 0.001F;
+               float f13;
+               float f14;
+               float f15;
+               float f16;
+               float f17;
+               float f18;
+               float f19;
+               float f20;
+               if (f12 < -999.0F) {
+                  f13 = textureatlassprite.getInterpolatedU(0.0);
+                  f17 = textureatlassprite.getInterpolatedV(0.0);
+                  f14 = f13;
+                  f18 = textureatlassprite.getInterpolatedV(16.0);
+                  f15 = textureatlassprite.getInterpolatedU(16.0);
+                  f19 = f18;
+                  f16 = f15;
+                  f20 = f17;
+               } else {
+                  float f21 = MathHelper.sin(f12) * 0.25F;
+                  float f22 = MathHelper.cos(f12) * 0.25F;
+                  float f23 = 8.0F;
+                  f13 = textureatlassprite.getInterpolatedU(8.0F + (-f22 - f21) * 16.0F);
+                  f17 = textureatlassprite.getInterpolatedV(8.0F + (-f22 + f21) * 16.0F);
+                  f14 = textureatlassprite.getInterpolatedU(8.0F + (-f22 + f21) * 16.0F);
+                  f18 = textureatlassprite.getInterpolatedV(8.0F + (f22 + f21) * 16.0F);
+                  f15 = textureatlassprite.getInterpolatedU(8.0F + (f22 + f21) * 16.0F);
+                  f19 = textureatlassprite.getInterpolatedV(8.0F + (f22 - f21) * 16.0F);
+                  f16 = textureatlassprite.getInterpolatedU(8.0F + (f22 - f21) * 16.0F);
+                  f20 = textureatlassprite.getInterpolatedV(8.0F + (-f22 - f21) * 16.0F);
+               }
 
-         for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 4; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0;
-            if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 0) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx--;
+               int k2 = blockStateIn.b(blockAccess, blockPosIn);
+               int l2 = k2 >> 16 & 65535;
+               int i3 = k2 & 65535;
+               float f24 = 1.0F * f;
+               float f25 = 1.0F * f1;
+               float f26 = 1.0F * f2;
+               worldRendererIn.pos(d0 + 0.0, d1 + f7, d2 + 0.0).color(f24, f25, f26, 1.0F).tex(f13, f17).lightmap(l2, i3).endVertex();
+               worldRendererIn.pos(d0 + 0.0, d1 + f8, d2 + 1.0).color(f24, f25, f26, 1.0F).tex(f14, f18).lightmap(l2, i3).endVertex();
+               worldRendererIn.pos(d0 + 1.0, d1 + f9, d2 + 1.0).color(f24, f25, f26, 1.0F).tex(f15, f19).lightmap(l2, i3).endVertex();
+               worldRendererIn.pos(d0 + 1.0, d1 + f10, d2 + 0.0).color(f24, f25, f26, 1.0F).tex(f16, f20).lightmap(l2, i3).endVertex();
+               if (blockliquid.shouldRenderSides(blockAccess, blockPosIn.up())) {
+                  worldRendererIn.pos(d0 + 0.0, d1 + f7, d2 + 0.0).color(f24, f25, f26, 1.0F).tex(f13, f17).lightmap(l2, i3).endVertex();
+                  worldRendererIn.pos(d0 + 1.0, d1 + f10, d2 + 0.0).color(f24, f25, f26, 1.0F).tex(f16, f20).lightmap(l2, i3).endVertex();
+                  worldRendererIn.pos(d0 + 1.0, d1 + f9, d2 + 1.0).color(f24, f25, f26, 1.0F).tex(f15, f19).lightmap(l2, i3).endVertex();
+                  worldRendererIn.pos(d0 + 0.0, d1 + f8, d2 + 1.0).color(f24, f25, f26, 1.0F).tex(f14, f18).lightmap(l2, i3).endVertex();
+               }
             }
 
-            if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 1) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++;
+            if (flag2) {
+               worldRendererIn.setSprite(atextureatlassprite[0]);
+               float f35 = atextureatlassprite[0].getMinU();
+               float f36 = atextureatlassprite[0].getMaxU();
+               float f37 = atextureatlassprite[0].getMinV();
+               float f38 = atextureatlassprite[0].getMaxV();
+               int l1 = blockStateIn.b(blockAccess, blockPosIn.down());
+               int i2 = l1 >> 16 & 65535;
+               int j2 = l1 & 65535;
+               float fbr = FaceBakery.getFaceBrightness(EnumFacing.DOWN);
+               worldRendererIn.pos(d0, d1, d2 + 1.0).color(f * fbr, f1 * fbr, f2 * fbr, 1.0F).tex(f35, f38).lightmap(i2, j2).endVertex();
+               worldRendererIn.pos(d0, d1, d2).color(f * fbr, f1 * fbr, f2 * fbr, 1.0F).tex(f35, f37).lightmap(i2, j2).endVertex();
+               worldRendererIn.pos(d0 + 1.0, d1, d2).color(f * fbr, f1 * fbr, f2 * fbr, 1.0F).tex(f36, f37).lightmap(i2, j2).endVertex();
+               worldRendererIn.pos(d0 + 1.0, d1, d2 + 1.0).color(f * fbr, f1 * fbr, f2 * fbr, 1.0F).tex(f36, f38).lightmap(i2, j2).endVertex();
+               flag3 = true;
             }
 
-            if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 2) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx--;
-            }
+            for (int i1 = 0; i1 < 4; i1++) {
+               int j1 = 0;
+               int k1 = 0;
+               if (i1 == 0) {
+                  k1--;
+               }
 
-            if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 3) {
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++;
-            }
+               if (i1 == 1) {
+                  k1++;
+               }
 
-            BlockPos ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.add(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, 0, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx);
-            TextureAtlasSprite ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx[1];
-            if (!☃x) {
-               Block ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx).getBlock();
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == Blocks.GLASS || ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == Blocks.STAINED_GLASS) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.atlasSpriteWaterOverlay;
+               if (i1 == 2) {
+                  j1--;
                }
-            }
 
-            if (☃xxxxxxxxx[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx]) {
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 0) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 1.0;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 0.001F;
-               } else if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 1) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 1.0;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0 - 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0 - 0.001F;
-               } else if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 2) {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx;
-               } else {
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 1.0 - 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxx + 1.0 - 0.001F;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx + 1.0;
+               if (i1 == 3) {
+                  j1++;
+               }
+
+               BlockPos blockpos = blockPosIn.add(j1, 0, k1);
+               TextureAtlasSprite textureatlassprite1 = atextureatlassprite[1];
+               worldRendererIn.setSprite(textureatlassprite1);
+               float yMin1 = 0.0F;
+               float yMin2 = 0.0F;
+               if (!flag) {
+                  IBlockState blockState = blockAccess.getBlockState(blockpos);
+                  Block block = blockState.getBlock();
+                  if (block == Blocks.GLASS || block == Blocks.STAINED_GLASS || block == Blocks.BEACON || block == Blocks.SLIME_BLOCK) {
+                     textureatlassprite1 = this.atlasSpriteWaterOverlay;
+                     worldRendererIn.setSprite(textureatlassprite1);
+                  }
+
+                  if (block == Blocks.FARMLAND || block == Blocks.GRASS_PATH) {
+                     yMin1 = 0.9375F;
+                     yMin2 = 0.9375F;
+                  }
+
+                  if (block instanceof BlockSlab) {
+                     BlockSlab blockSlab = (BlockSlab)block;
+                     if (!blockSlab.isDouble() && blockState.getValue(BlockSlab.HALF) == EnumBlockHalf.BOTTOM) {
+                        yMin1 = 0.5F;
+                        yMin2 = 0.5F;
+                     }
+                  }
                }
 
-               ☃xxxxxxxxxx = true;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(0.0);
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedU(8.0);
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  (1.0F - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F * 0.5F
-               );
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(
-                  (1.0F - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 16.0F * 0.5F
-               );
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.getInterpolatedV(8.0);
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx);
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx >> 16 & 65535;
-               int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx & 65535;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 2 ? 0.8F : 0.6F;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxx;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxx;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 1.0F * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxx;
-               ☃.pos(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                  )
-                  .color(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     1.0F
-                  )
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                  )
-                  .color(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     1.0F
-                  )
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .color(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     1.0F
-                  )
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               ☃.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .color(
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                     1.0F
-                  )
-                  .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx != this.atlasSpriteWaterOverlay) {
-                  ☃.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .color(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        1.0F
-                     )
-                     .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .endVertex();
-                  ☃.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx + 0.0, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .color(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        1.0F
-                     )
-                     .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .endVertex();
-                  ☃.pos(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        1.0F
-                     )
-                     .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .endVertex();
-                  ☃.pos(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                        1.0F
-                     )
-                     .tex(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                     .endVertex();
+               if (aboolean[i1]) {
+                  float f39;
+                  float f40;
+                  double d3;
+                  double d4;
+                  double d5;
+                  double d6;
+                  if (i1 == 0) {
+                     f39 = f7;
+                     f40 = f10;
+                     d3 = d0;
+                     d5 = d0 + 1.0;
+                     d4 = d2 + 0.001F;
+                     d6 = d2 + 0.001F;
+                  } else if (i1 == 1) {
+                     f39 = f9;
+                     f40 = f8;
+                     d3 = d0 + 1.0;
+                     d5 = d0;
+                     d4 = d2 + 1.0 - 0.001F;
+                     d6 = d2 + 1.0 - 0.001F;
+                  } else if (i1 == 2) {
+                     f39 = f8;
+                     f40 = f7;
+                     d3 = d0 + 0.001F;
+                     d5 = d0 + 0.001F;
+                     d4 = d2 + 1.0;
+                     d6 = d2;
+                  } else {
+                     f39 = f10;
+                     f40 = f9;
+                     d3 = d0 + 1.0 - 0.001F;
+                     d5 = d0 + 1.0 - 0.001F;
+                     d4 = d2;
+                     d6 = d2 + 1.0;
+                  }
+
+                  if (!(f39 <= yMin1) || !(f40 <= yMin2)) {
+                     yMin1 = Math.min(yMin1, f39);
+                     yMin2 = Math.min(yMin2, f40);
+                     if (yMin1 > f11) {
+                        yMin1 -= f11;
+                     }
+
+                     if (yMin2 > f11) {
+                        yMin2 -= f11;
+                     }
+
+                     flag3 = true;
+                     float f41 = textureatlassprite1.getInterpolatedU(0.0);
+                     float f27 = textureatlassprite1.getInterpolatedU(8.0);
+                     float f28 = textureatlassprite1.getInterpolatedV((1.0F - f39) * 16.0F * 0.5F);
+                     float f29 = textureatlassprite1.getInterpolatedV((1.0F - f40) * 16.0F * 0.5F);
+                     float f30 = textureatlassprite1.getInterpolatedV(8.0);
+                     float vMin1 = textureatlassprite1.getInterpolatedV((1.0F - yMin1) * 16.0F * 0.5F);
+                     float vMin2 = textureatlassprite1.getInterpolatedV((1.0F - yMin2) * 16.0F * 0.5F);
+                     int j = blockStateIn.b(blockAccess, blockpos);
+                     int k = j >> 16 & 65535;
+                     int l = j & 65535;
+                     float f31 = i1 < 2 ? FaceBakery.getFaceBrightness(EnumFacing.NORTH) : FaceBakery.getFaceBrightness(EnumFacing.WEST);
+                     float f32 = 1.0F * f31 * f;
+                     float f33 = 1.0F * f31 * f1;
+                     float f34 = 1.0F * f31 * f2;
+                     worldRendererIn.pos(d3, d1 + f39, d4).color(f32, f33, f34, 1.0F).tex(f41, f28).lightmap(k, l).endVertex();
+                     worldRendererIn.pos(d5, d1 + f40, d6).color(f32, f33, f34, 1.0F).tex(f27, f29).lightmap(k, l).endVertex();
+                     worldRendererIn.pos(d5, d1 + yMin2, d6).color(f32, f33, f34, 1.0F).tex(f27, vMin2).lightmap(k, l).endVertex();
+                     worldRendererIn.pos(d3, d1 + yMin1, d4).color(f32, f33, f34, 1.0F).tex(f41, vMin1).lightmap(k, l).endVertex();
+                     if (textureatlassprite1 != this.atlasSpriteWaterOverlay) {
+                        worldRendererIn.pos(d3, d1 + yMin1, d4).color(f32, f33, f34, 1.0F).tex(f41, vMin1).lightmap(k, l).endVertex();
+                        worldRendererIn.pos(d5, d1 + yMin2, d6).color(f32, f33, f34, 1.0F).tex(f27, vMin2).lightmap(k, l).endVertex();
+                        worldRendererIn.pos(d5, d1 + f40, d6).color(f32, f33, f34, 1.0F).tex(f27, f29).lightmap(k, l).endVertex();
+                        worldRendererIn.pos(d3, d1 + f39, d4).color(f32, f33, f34, 1.0F).tex(f41, f28).lightmap(k, l).endVertex();
+                     }
+                  }
                }
             }
+
+            worldRendererIn.setSprite(null);
+            return flag3;
          }
 
-         return ☃xxxxxxxxxx;
+         flag3 = false;
+      } finally {
+         if (Config.isShaders()) {
+            SVertexBuilder.popEntity(worldRendererIn);
+         }
       }
+
+      return flag3;
    }
 
-   private float getFluidHeight(IBlockAccess var1, BlockPos var2, Material var3) {
-      int ☃ = 0;
-      float ☃x = 0.0F;
+   private float getFluidHeight(IBlockAccess blockAccess, BlockPos blockPosIn, Material blockMaterial) {
+      int i = 0;
+      float f = 0.0F;
 
-      for (int ☃xx = 0; ☃xx < 4; ☃xx++) {
-         BlockPos ☃xxx = ☃.add(-(☃xx & 1), 0, -(☃xx >> 1 & 1));
-         if (☃.getBlockState(☃xxx.up()).getMaterial() == ☃) {
+      for (int j = 0; j < 4; j++) {
+         BlockPos blockpos = blockPosIn.add(-(j & 1), 0, -(j >> 1 & 1));
+         if (blockAccess.getBlockState(blockpos.up()).a() == blockMaterial) {
             return 1.0F;
          }
 
-         IBlockState ☃xxxx = ☃.getBlockState(☃xxx);
-         Material ☃xxxxx = ☃xxxx.getMaterial();
-         if (☃xxxxx == ☃) {
-            int ☃xxxxxx = ☃xxxx.getValue(BlockLiquid.LEVEL);
-            if (☃xxxxxx >= 8 || ☃xxxxxx == 0) {
-               ☃x += BlockLiquid.getLiquidHeightPercent(☃xxxxxx) * 10.0F;
-               ☃ += 10;
+         IBlockState iblockstate = blockAccess.getBlockState(blockpos);
+         Material material = iblockstate.a();
+         if (material != blockMaterial) {
+            if (!material.isSolid()) {
+               f++;
+               i++;
+            }
+         } else {
+            int k = (Integer)iblockstate.getValue(BlockLiquid.LEVEL);
+            if (k >= 8 || k == 0) {
+               f += BlockLiquid.getLiquidHeightPercent(k) * 10.0F;
+               i += 10;
             }
 
-            ☃x += BlockLiquid.getLiquidHeightPercent(☃xxxxxx);
-            ☃++;
-         } else if (!☃xxxxx.isSolid()) {
-            ☃x++;
-            ☃++;
+            f += BlockLiquid.getLiquidHeightPercent(k);
+            i++;
          }
       }
 
-      return 1.0F - ☃x / ☃;
+      return 1.0F - f / i;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/BlockModelRenderer.java b/patches/net/minecraft/client/renderer/BlockModelRenderer.java
index 18336db..a9f76f9 100644
--- a/patches/net/minecraft/client/renderer/BlockModelRenderer.java
+++ b/patches/net/minecraft/client/renderer/BlockModelRenderer.java
@@ -7,509 +7,687 @@
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.block.model.BakedQuad;
+import net.minecraft.client.renderer.block.model.FaceBakery;
 import net.minecraft.client.renderer.block.model.IBakedModel;
 import net.minecraft.client.renderer.color.BlockColors;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.math.Vec3i;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.IBlockAccess;
+import net.optifine.BetterSnow;
+import net.optifine.CustomColors;
+import net.optifine.model.BlockModelCustomizer;
+import net.optifine.model.ListQuadsOverlay;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
+import net.optifine.shaders.Shaders;
 
 public class BlockModelRenderer {
    private final BlockColors blockColors;
+   private static float aoLightValueOpaque = 0.2F;
+   private static boolean separateAoLightValue = false;
+   private static final BlockRenderLayer[] OVERLAY_LAYERS = new BlockRenderLayer[]{
+      BlockRenderLayer.CUTOUT, BlockRenderLayer.CUTOUT_MIPPED, BlockRenderLayer.TRANSLUCENT
+   };
 
-   public BlockModelRenderer(BlockColors var1) {
-      this.blockColors = ☃;
+   public BlockModelRenderer(BlockColors blockColorsIn) {
+      this.blockColors = blockColorsIn;
+      if (Reflector.ForgeModContainer_forgeLightPipelineEnabled.exists()) {
+         Reflector.setFieldValue(Reflector.ForgeModContainer_forgeLightPipelineEnabled, false);
+      }
    }
 
-   public boolean renderModel(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6) {
-      return this.renderModel(☃, ☃, ☃, ☃, ☃, ☃, MathHelper.getPositionRandom(☃));
+   public boolean renderModel(
+      IBlockAccess blockAccessIn, IBakedModel modelIn, IBlockState blockStateIn, BlockPos blockPosIn, BufferBuilder buffer, boolean checkSides
+   ) {
+      return this.renderModel(blockAccessIn, modelIn, blockStateIn, blockPosIn, buffer, checkSides, MathHelper.getPositionRandom(blockPosIn));
    }
 
-   public boolean renderModel(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
-      boolean ☃ = Minecraft.isAmbientOcclusionEnabled() && ☃.getLightValue() == 0 && ☃.isAmbientOcclusion();
+   public boolean renderModel(
+      IBlockAccess worldIn, IBakedModel modelIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, boolean checkSides, long rand
+   ) {
+      boolean flag = Minecraft.isAmbientOcclusionEnabled()
+         && ReflectorForge.getLightValue(stateIn, worldIn, posIn) == 0
+         && ReflectorForge.isAmbientOcclusion(modelIn, stateIn);
 
       try {
-         return ☃ ? this.renderModelSmooth(☃, ☃, ☃, ☃, ☃, ☃, ☃) : this.renderModelFlat(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+         if (Config.isShaders()) {
+            SVertexBuilder.pushEntity(stateIn, posIn, worldIn, buffer);
+         }
+
+         if (!Config.isAlternateBlocks()) {
+            rand = 0L;
+         }
+
+         RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
+         modelIn = BlockModelCustomizer.getRenderModel(modelIn, stateIn, renderEnv);
+         boolean rendered = flag
+            ? this.renderModelSmooth(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand)
+            : this.renderModelFlat(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand);
+         if (rendered) {
+            this.renderOverlayModels(worldIn, modelIn, stateIn, posIn, buffer, checkSides, rand, renderEnv, flag);
+         }
+
+         if (Config.isShaders()) {
+            SVertexBuilder.popEntity(buffer);
+         }
+
+         return rendered;
       } catch (Throwable var13) {
-         CrashReport ☃x = CrashReport.makeCrashReport(var13, "Tesselating block model");
-         CrashReportCategory ☃xx = ☃x.makeCategory("Block model being tesselated");
-         CrashReportCategory.addBlockInfo(☃xx, ☃, ☃);
-         ☃xx.addCrashSection("Using AO", ☃);
-         throw new ReportedException(☃x);
+         CrashReport crashreport = CrashReport.makeCrashReport(var13, "Tesselating block model");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Block model being tesselated");
+         CrashReportCategory.addBlockInfo(crashreportcategory, posIn, stateIn);
+         crashreportcategory.addCrashSection("Using AO", flag);
+         throw new ReportedException(crashreport);
       }
    }
 
-   public boolean renderModelSmooth(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
-      boolean ☃ = false;
-      float[] ☃x = new float[EnumFacing.values().length * 2];
-      BitSet ☃xx = new BitSet(3);
-      BlockModelRenderer.AmbientOcclusionFace ☃xxx = new BlockModelRenderer.AmbientOcclusionFace();
+   public boolean renderModelSmooth(
+      IBlockAccess worldIn, IBakedModel modelIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, boolean checkSides, long rand
+   ) {
+      boolean flag = false;
+      RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
+      BlockRenderLayer layer = buffer.getBlockLayer();
 
-      for (EnumFacing ☃xxxx : EnumFacing.values()) {
-         List<BakedQuad> ☃xxxxx = ☃.getQuads(☃, ☃xxxx, ☃);
-         if (!☃xxxxx.isEmpty() && (!☃ || ☃.shouldSideBeRendered(☃, ☃, ☃xxxx))) {
-            this.renderQuadsSmooth(☃, ☃, ☃, ☃, ☃xxxxx, ☃x, ☃xx, ☃xxx);
-            ☃ = true;
+      for (EnumFacing enumfacing : EnumFacing.VALUES) {
+         List<BakedQuad> list = modelIn.getQuads(stateIn, enumfacing, rand);
+         if (!list.isEmpty() && (!checkSides || stateIn.c(worldIn, posIn, enumfacing))) {
+            list = BlockModelCustomizer.getRenderQuads(list, worldIn, stateIn, posIn, enumfacing, layer, rand, renderEnv);
+            this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, list, renderEnv);
+            flag = true;
          }
       }
 
-      List<BakedQuad> ☃xxxxx = ☃.getQuads(☃, null, ☃);
-      if (!☃xxxxx.isEmpty()) {
-         this.renderQuadsSmooth(☃, ☃, ☃, ☃, ☃xxxxx, ☃x, ☃xx, ☃xxx);
-         ☃ = true;
+      List<BakedQuad> list1 = modelIn.getQuads(stateIn, (EnumFacing)null, rand);
+      if (!list1.isEmpty()) {
+         list1 = BlockModelCustomizer.getRenderQuads(list1, worldIn, stateIn, posIn, null, layer, rand, renderEnv);
+         this.renderQuadsSmooth(worldIn, stateIn, posIn, buffer, list1, renderEnv);
+         flag = true;
       }
 
-      return ☃;
+      return flag;
    }
 
-   public boolean renderModelFlat(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
-      boolean ☃ = false;
-      BitSet ☃x = new BitSet(3);
+   public boolean renderModelFlat(
+      IBlockAccess worldIn, IBakedModel modelIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, boolean checkSides, long rand
+   ) {
+      boolean flag = false;
+      RenderEnv renderEnv = buffer.getRenderEnv(stateIn, posIn);
+      BlockRenderLayer layer = buffer.getBlockLayer();
 
-      for (EnumFacing ☃xx : EnumFacing.values()) {
-         List<BakedQuad> ☃xxx = ☃.getQuads(☃, ☃xx, ☃);
-         if (!☃xxx.isEmpty() && (!☃ || ☃.shouldSideBeRendered(☃, ☃, ☃xx))) {
-            int ☃xxxx = ☃.getPackedLightmapCoords(☃, ☃.offset(☃xx));
-            this.renderQuadsFlat(☃, ☃, ☃, ☃xxxx, false, ☃, ☃xxx, ☃x);
-            ☃ = true;
+      for (EnumFacing enumfacing : EnumFacing.VALUES) {
+         List<BakedQuad> list = modelIn.getQuads(stateIn, enumfacing, rand);
+         if (!list.isEmpty() && (!checkSides || stateIn.c(worldIn, posIn, enumfacing))) {
+            int i = stateIn.b(worldIn, posIn.offset(enumfacing));
+            list = BlockModelCustomizer.getRenderQuads(list, worldIn, stateIn, posIn, enumfacing, layer, rand, renderEnv);
+            this.renderQuadsFlat(worldIn, stateIn, posIn, i, false, buffer, list, renderEnv);
+            flag = true;
          }
       }
 
-      List<BakedQuad> ☃xxx = ☃.getQuads(☃, null, ☃);
-      if (!☃xxx.isEmpty()) {
-         this.renderQuadsFlat(☃, ☃, ☃, -1, true, ☃, ☃xxx, ☃x);
-         ☃ = true;
+      List<BakedQuad> list1 = modelIn.getQuads(stateIn, (EnumFacing)null, rand);
+      if (!list1.isEmpty()) {
+         list1 = BlockModelCustomizer.getRenderQuads(list1, worldIn, stateIn, posIn, null, layer, rand, renderEnv);
+         this.renderQuadsFlat(worldIn, stateIn, posIn, -1, true, buffer, list1, renderEnv);
+         flag = true;
       }
 
-      return ☃;
+      return flag;
    }
 
    private void renderQuadsSmooth(
-      IBlockAccess var1,
-      IBlockState var2,
-      BlockPos var3,
-      BufferBuilder var4,
-      List<BakedQuad> var5,
-      float[] var6,
-      BitSet var7,
-      BlockModelRenderer.AmbientOcclusionFace var8
+      IBlockAccess blockAccessIn, IBlockState stateIn, BlockPos posIn, BufferBuilder buffer, List<BakedQuad> list, RenderEnv renderEnv
    ) {
-      Vec3d ☃ = ☃.getOffset(☃, ☃);
-      double ☃x = ☃.getX() + ☃.x;
-      double ☃xx = ☃.getY() + ☃.y;
-      double ☃xxx = ☃.getZ() + ☃.z;
-      int ☃xxxx = 0;
-
-      for (int ☃xxxxx = ☃.size(); ☃xxxx < ☃xxxxx; ☃xxxx++) {
-         BakedQuad ☃xxxxxx = ☃.get(☃xxxx);
-         this.fillQuadBounds(☃, ☃xxxxxx.getVertexData(), ☃xxxxxx.getFace(), ☃, ☃);
-         ☃.updateVertexBrightness(☃, ☃, ☃, ☃xxxxxx.getFace(), ☃, ☃);
-         ☃.addVertexData(☃xxxxxx.getVertexData());
-         ☃.putBrightness4(☃.vertexBrightness[0], ☃.vertexBrightness[1], ☃.vertexBrightness[2], ☃.vertexBrightness[3]);
-         if (☃xxxxxx.hasTintIndex()) {
-            int ☃xxxxxxx = this.blockColors.colorMultiplier(☃, ☃, ☃, ☃xxxxxx.getTintIndex());
+      float[] quadBounds = renderEnv.getQuadBounds();
+      BitSet bitSet = renderEnv.getBoundsFlags();
+      BlockModelRenderer.AmbientOcclusionFace aoFace = renderEnv.getAoFace();
+      Vec3d vec3d = stateIn.f(blockAccessIn, posIn);
+      double d0 = posIn.getX() + vec3d.x;
+      double d1 = posIn.getY() + vec3d.y;
+      double d2 = posIn.getZ() + vec3d.z;
+      int i = 0;
+
+      for (int j = list.size(); i < j; i++) {
+         BakedQuad bakedquad = list.get(i);
+         this.fillQuadBounds(stateIn, bakedquad.getVertexData(), bakedquad.getFace(), quadBounds, bitSet);
+         aoFace.updateVertexBrightness(blockAccessIn, stateIn, posIn, bakedquad.getFace(), quadBounds, bitSet);
+         if (bakedquad.getSprite().isEmissive) {
+            aoFace.setMaxBlockLight();
+         }
+
+         if (buffer.isMultiTexture()) {
+            buffer.addVertexData(bakedquad.getVertexDataSingle());
+         } else {
+            buffer.addVertexData(bakedquad.getVertexData());
+         }
+
+         buffer.putSprite(bakedquad.getSprite());
+         buffer.putBrightness4(aoFace.vertexBrightness[0], aoFace.vertexBrightness[1], aoFace.vertexBrightness[2], aoFace.vertexBrightness[3]);
+         if (bakedquad.shouldApplyDiffuseLighting()) {
+            float diffuse = FaceBakery.getFaceBrightness(bakedquad.getFace());
+            aoFace.vertexColorMultiplier[0] *= diffuse;
+            aoFace.vertexColorMultiplier[1] *= diffuse;
+            aoFace.vertexColorMultiplier[2] *= diffuse;
+            aoFace.vertexColorMultiplier[3] *= diffuse;
+         }
+
+         int colorMultiplier = CustomColors.getColorMultiplier(bakedquad, stateIn, blockAccessIn, posIn, renderEnv);
+         if (bakedquad.hasTintIndex() || colorMultiplier != -1) {
+            int k = colorMultiplier;
+            if (colorMultiplier == -1) {
+               k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
+            }
+
             if (EntityRenderer.anaglyphEnable) {
-               ☃xxxxxxx = TextureUtil.anaglyphColor(☃xxxxxxx);
+               k = TextureUtil.anaglyphColor(k);
             }
 
-            float ☃xxxxxxxx = (☃xxxxxxx >> 16 & 0xFF) / 255.0F;
-            float ☃xxxxxxxxx = (☃xxxxxxx >> 8 & 0xFF) / 255.0F;
-            float ☃xxxxxxxxxx = (☃xxxxxxx & 0xFF) / 255.0F;
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[0] * ☃xxxxxxxx, ☃.vertexColorMultiplier[0] * ☃xxxxxxxxx, ☃.vertexColorMultiplier[0] * ☃xxxxxxxxxx, 4);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[1] * ☃xxxxxxxx, ☃.vertexColorMultiplier[1] * ☃xxxxxxxxx, ☃.vertexColorMultiplier[1] * ☃xxxxxxxxxx, 3);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[2] * ☃xxxxxxxx, ☃.vertexColorMultiplier[2] * ☃xxxxxxxxx, ☃.vertexColorMultiplier[2] * ☃xxxxxxxxxx, 2);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[3] * ☃xxxxxxxx, ☃.vertexColorMultiplier[3] * ☃xxxxxxxxx, ☃.vertexColorMultiplier[3] * ☃xxxxxxxxxx, 1);
+            float f = (k >> 16 & 0xFF) / 255.0F;
+            float f1 = (k >> 8 & 0xFF) / 255.0F;
+            float f2 = (k & 0xFF) / 255.0F;
+            if (separateAoLightValue) {
+               buffer.putColorMultiplierRgba(f, f1, f2, aoFace.vertexColorMultiplier[0], 4);
+               buffer.putColorMultiplierRgba(f, f1, f2, aoFace.vertexColorMultiplier[1], 3);
+               buffer.putColorMultiplierRgba(f, f1, f2, aoFace.vertexColorMultiplier[2], 2);
+               buffer.putColorMultiplierRgba(f, f1, f2, aoFace.vertexColorMultiplier[3], 1);
+            } else {
+               buffer.putColorMultiplier(aoFace.vertexColorMultiplier[0] * f, aoFace.vertexColorMultiplier[0] * f1, aoFace.vertexColorMultiplier[0] * f2, 4);
+               buffer.putColorMultiplier(aoFace.vertexColorMultiplier[1] * f, aoFace.vertexColorMultiplier[1] * f1, aoFace.vertexColorMultiplier[1] * f2, 3);
+               buffer.putColorMultiplier(aoFace.vertexColorMultiplier[2] * f, aoFace.vertexColorMultiplier[2] * f1, aoFace.vertexColorMultiplier[2] * f2, 2);
+               buffer.putColorMultiplier(aoFace.vertexColorMultiplier[3] * f, aoFace.vertexColorMultiplier[3] * f1, aoFace.vertexColorMultiplier[3] * f2, 1);
+            }
+         } else if (separateAoLightValue) {
+            buffer.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, aoFace.vertexColorMultiplier[0], 4);
+            buffer.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, aoFace.vertexColorMultiplier[1], 3);
+            buffer.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, aoFace.vertexColorMultiplier[2], 2);
+            buffer.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, aoFace.vertexColorMultiplier[3], 1);
          } else {
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[0], ☃.vertexColorMultiplier[0], ☃.vertexColorMultiplier[0], 4);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[1], ☃.vertexColorMultiplier[1], ☃.vertexColorMultiplier[1], 3);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[2], ☃.vertexColorMultiplier[2], ☃.vertexColorMultiplier[2], 2);
-            ☃.putColorMultiplier(☃.vertexColorMultiplier[3], ☃.vertexColorMultiplier[3], ☃.vertexColorMultiplier[3], 1);
+            buffer.putColorMultiplier(aoFace.vertexColorMultiplier[0], aoFace.vertexColorMultiplier[0], aoFace.vertexColorMultiplier[0], 4);
+            buffer.putColorMultiplier(aoFace.vertexColorMultiplier[1], aoFace.vertexColorMultiplier[1], aoFace.vertexColorMultiplier[1], 3);
+            buffer.putColorMultiplier(aoFace.vertexColorMultiplier[2], aoFace.vertexColorMultiplier[2], aoFace.vertexColorMultiplier[2], 2);
+            buffer.putColorMultiplier(aoFace.vertexColorMultiplier[3], aoFace.vertexColorMultiplier[3], aoFace.vertexColorMultiplier[3], 1);
          }
 
-         ☃.putPosition(☃x, ☃xx, ☃xxx);
+         buffer.putPosition(d0, d1, d2);
       }
    }
 
-   private void fillQuadBounds(IBlockState var1, int[] var2, EnumFacing var3, @Nullable float[] var4, BitSet var5) {
-      float ☃ = 32.0F;
-      float ☃x = 32.0F;
-      float ☃xx = 32.0F;
-      float ☃xxx = -32.0F;
-      float ☃xxxx = -32.0F;
-      float ☃xxxxx = -32.0F;
-
-      for (int ☃xxxxxx = 0; ☃xxxxxx < 4; ☃xxxxxx++) {
-         float ☃xxxxxxx = Float.intBitsToFloat(☃[☃xxxxxx * 7]);
-         float ☃xxxxxxxx = Float.intBitsToFloat(☃[☃xxxxxx * 7 + 1]);
-         float ☃xxxxxxxxx = Float.intBitsToFloat(☃[☃xxxxxx * 7 + 2]);
-         ☃ = Math.min(☃, ☃xxxxxxx);
-         ☃x = Math.min(☃x, ☃xxxxxxxx);
-         ☃xx = Math.min(☃xx, ☃xxxxxxxxx);
-         ☃xxx = Math.max(☃xxx, ☃xxxxxxx);
-         ☃xxxx = Math.max(☃xxxx, ☃xxxxxxxx);
-         ☃xxxxx = Math.max(☃xxxxx, ☃xxxxxxxxx);
+   private void fillQuadBounds(IBlockState stateIn, int[] vertexData, EnumFacing face, @Nullable float[] quadBounds, BitSet boundsFlags) {
+      float f = 32.0F;
+      float f1 = 32.0F;
+      float f2 = 32.0F;
+      float f3 = -32.0F;
+      float f4 = -32.0F;
+      float f5 = -32.0F;
+      int step = vertexData.length / 4;
+
+      for (int i = 0; i < 4; i++) {
+         float f6 = Float.intBitsToFloat(vertexData[i * step]);
+         float f7 = Float.intBitsToFloat(vertexData[i * step + 1]);
+         float f8 = Float.intBitsToFloat(vertexData[i * step + 2]);
+         f = Math.min(f, f6);
+         f1 = Math.min(f1, f7);
+         f2 = Math.min(f2, f8);
+         f3 = Math.max(f3, f6);
+         f4 = Math.max(f4, f7);
+         f5 = Math.max(f5, f8);
       }
 
-      if (☃ != null) {
-         ☃[EnumFacing.WEST.getIndex()] = ☃;
-         ☃[EnumFacing.EAST.getIndex()] = ☃xxx;
-         ☃[EnumFacing.DOWN.getIndex()] = ☃x;
-         ☃[EnumFacing.UP.getIndex()] = ☃xxxx;
-         ☃[EnumFacing.NORTH.getIndex()] = ☃xx;
-         ☃[EnumFacing.SOUTH.getIndex()] = ☃xxxxx;
-         int ☃xxxxxx = EnumFacing.values().length;
-         ☃[EnumFacing.WEST.getIndex() + ☃xxxxxx] = 1.0F - ☃;
-         ☃[EnumFacing.EAST.getIndex() + ☃xxxxxx] = 1.0F - ☃xxx;
-         ☃[EnumFacing.DOWN.getIndex() + ☃xxxxxx] = 1.0F - ☃x;
-         ☃[EnumFacing.UP.getIndex() + ☃xxxxxx] = 1.0F - ☃xxxx;
-         ☃[EnumFacing.NORTH.getIndex() + ☃xxxxxx] = 1.0F - ☃xx;
-         ☃[EnumFacing.SOUTH.getIndex() + ☃xxxxxx] = 1.0F - ☃xxxxx;
+      if (quadBounds != null) {
+         quadBounds[EnumFacing.WEST.getIndex()] = f;
+         quadBounds[EnumFacing.EAST.getIndex()] = f3;
+         quadBounds[EnumFacing.DOWN.getIndex()] = f1;
+         quadBounds[EnumFacing.UP.getIndex()] = f4;
+         quadBounds[EnumFacing.NORTH.getIndex()] = f2;
+         quadBounds[EnumFacing.SOUTH.getIndex()] = f5;
+         int j = EnumFacing.VALUES.length;
+         quadBounds[EnumFacing.WEST.getIndex() + j] = 1.0F - f;
+         quadBounds[EnumFacing.EAST.getIndex() + j] = 1.0F - f3;
+         quadBounds[EnumFacing.DOWN.getIndex() + j] = 1.0F - f1;
+         quadBounds[EnumFacing.UP.getIndex() + j] = 1.0F - f4;
+         quadBounds[EnumFacing.NORTH.getIndex() + j] = 1.0F - f2;
+         quadBounds[EnumFacing.SOUTH.getIndex() + j] = 1.0F - f5;
       }
 
-      float ☃xxxxxx = 1.0E-4F;
-      float ☃xxxxxxx = 0.9999F;
-      switch (☃) {
+      float f9 = 1.0E-4F;
+      float f10 = 0.9999F;
+      switch (face) {
          case DOWN:
-            ☃.set(1, ☃ >= 1.0E-4F || ☃xx >= 1.0E-4F || ☃xxx <= 0.9999F || ☃xxxxx <= 0.9999F);
-            ☃.set(0, (☃x < 1.0E-4F || ☃.isFullCube()) && ☃x == ☃xxxx);
+            boundsFlags.set(1, f >= 1.0E-4F || f2 >= 1.0E-4F || f3 <= 0.9999F || f5 <= 0.9999F);
+            boundsFlags.set(0, (f1 < 1.0E-4F || stateIn.g()) && f1 == f4);
             break;
          case UP:
-            ☃.set(1, ☃ >= 1.0E-4F || ☃xx >= 1.0E-4F || ☃xxx <= 0.9999F || ☃xxxxx <= 0.9999F);
-            ☃.set(0, (☃xxxx > 0.9999F || ☃.isFullCube()) && ☃x == ☃xxxx);
+            boundsFlags.set(1, f >= 1.0E-4F || f2 >= 1.0E-4F || f3 <= 0.9999F || f5 <= 0.9999F);
+            boundsFlags.set(0, (f4 > 0.9999F || stateIn.g()) && f1 == f4);
             break;
          case NORTH:
-            ☃.set(1, ☃ >= 1.0E-4F || ☃x >= 1.0E-4F || ☃xxx <= 0.9999F || ☃xxxx <= 0.9999F);
-            ☃.set(0, (☃xx < 1.0E-4F || ☃.isFullCube()) && ☃xx == ☃xxxxx);
+            boundsFlags.set(1, f >= 1.0E-4F || f1 >= 1.0E-4F || f3 <= 0.9999F || f4 <= 0.9999F);
+            boundsFlags.set(0, (f2 < 1.0E-4F || stateIn.g()) && f2 == f5);
             break;
          case SOUTH:
-            ☃.set(1, ☃ >= 1.0E-4F || ☃x >= 1.0E-4F || ☃xxx <= 0.9999F || ☃xxxx <= 0.9999F);
-            ☃.set(0, (☃xxxxx > 0.9999F || ☃.isFullCube()) && ☃xx == ☃xxxxx);
+            boundsFlags.set(1, f >= 1.0E-4F || f1 >= 1.0E-4F || f3 <= 0.9999F || f4 <= 0.9999F);
+            boundsFlags.set(0, (f5 > 0.9999F || stateIn.g()) && f2 == f5);
             break;
          case WEST:
-            ☃.set(1, ☃x >= 1.0E-4F || ☃xx >= 1.0E-4F || ☃xxxx <= 0.9999F || ☃xxxxx <= 0.9999F);
-            ☃.set(0, (☃ < 1.0E-4F || ☃.isFullCube()) && ☃ == ☃xxx);
+            boundsFlags.set(1, f1 >= 1.0E-4F || f2 >= 1.0E-4F || f4 <= 0.9999F || f5 <= 0.9999F);
+            boundsFlags.set(0, (f < 1.0E-4F || stateIn.g()) && f == f3);
             break;
          case EAST:
-            ☃.set(1, ☃x >= 1.0E-4F || ☃xx >= 1.0E-4F || ☃xxxx <= 0.9999F || ☃xxxxx <= 0.9999F);
-            ☃.set(0, (☃xxx > 0.9999F || ☃.isFullCube()) && ☃ == ☃xxx);
+            boundsFlags.set(1, f1 >= 1.0E-4F || f2 >= 1.0E-4F || f4 <= 0.9999F || f5 <= 0.9999F);
+            boundsFlags.set(0, (f3 > 0.9999F || stateIn.g()) && f == f3);
       }
    }
 
    private void renderQuadsFlat(
-      IBlockAccess var1, IBlockState var2, BlockPos var3, int var4, boolean var5, BufferBuilder var6, List<BakedQuad> var7, BitSet var8
+      IBlockAccess blockAccessIn,
+      IBlockState stateIn,
+      BlockPos posIn,
+      int brightnessIn,
+      boolean ownBrightness,
+      BufferBuilder buffer,
+      List<BakedQuad> list,
+      RenderEnv renderEnv
    ) {
-      Vec3d ☃ = ☃.getOffset(☃, ☃);
-      double ☃x = ☃.getX() + ☃.x;
-      double ☃xx = ☃.getY() + ☃.y;
-      double ☃xxx = ☃.getZ() + ☃.z;
-      int ☃xxxx = 0;
-
-      for (int ☃xxxxx = ☃.size(); ☃xxxx < ☃xxxxx; ☃xxxx++) {
-         BakedQuad ☃xxxxxx = ☃.get(☃xxxx);
-         if (☃) {
-            this.fillQuadBounds(☃, ☃xxxxxx.getVertexData(), ☃xxxxxx.getFace(), null, ☃);
-            BlockPos ☃xxxxxxx = ☃.get(0) ? ☃.offset(☃xxxxxx.getFace()) : ☃;
-            ☃ = ☃.getPackedLightmapCoords(☃, ☃xxxxxxx);
-         }
-
-         ☃.addVertexData(☃xxxxxx.getVertexData());
-         ☃.putBrightness4(☃, ☃, ☃, ☃);
-         if (☃xxxxxx.hasTintIndex()) {
-            int ☃xxxxxxx = this.blockColors.colorMultiplier(☃, ☃, ☃, ☃xxxxxx.getTintIndex());
+      BitSet bitSet = renderEnv.getBoundsFlags();
+      Vec3d vec3d = stateIn.f(blockAccessIn, posIn);
+      double d0 = posIn.getX() + vec3d.x;
+      double d1 = posIn.getY() + vec3d.y;
+      double d2 = posIn.getZ() + vec3d.z;
+      int i = 0;
+
+      for (int j = list.size(); i < j; i++) {
+         BakedQuad bakedquad = list.get(i);
+         if (ownBrightness) {
+            this.fillQuadBounds(stateIn, bakedquad.getVertexData(), bakedquad.getFace(), (float[])null, bitSet);
+            BlockPos blockpos = bitSet.get(0) ? posIn.offset(bakedquad.getFace()) : posIn;
+            brightnessIn = stateIn.b(blockAccessIn, blockpos);
+         }
+
+         if (bakedquad.getSprite().isEmissive) {
+            brightnessIn |= 240;
+         }
+
+         if (buffer.isMultiTexture()) {
+            buffer.addVertexData(bakedquad.getVertexDataSingle());
+         } else {
+            buffer.addVertexData(bakedquad.getVertexData());
+         }
+
+         buffer.putSprite(bakedquad.getSprite());
+         buffer.putBrightness4(brightnessIn, brightnessIn, brightnessIn, brightnessIn);
+         int colorMultiplier = CustomColors.getColorMultiplier(bakedquad, stateIn, blockAccessIn, posIn, renderEnv);
+         if (bakedquad.hasTintIndex() || colorMultiplier != -1) {
+            int k = colorMultiplier;
+            if (colorMultiplier == -1) {
+               k = this.blockColors.colorMultiplier(stateIn, blockAccessIn, posIn, bakedquad.getTintIndex());
+            }
+
             if (EntityRenderer.anaglyphEnable) {
-               ☃xxxxxxx = TextureUtil.anaglyphColor(☃xxxxxxx);
+               k = TextureUtil.anaglyphColor(k);
+            }
+
+            float f = (k >> 16 & 0xFF) / 255.0F;
+            float f1 = (k >> 8 & 0xFF) / 255.0F;
+            float f2 = (k & 0xFF) / 255.0F;
+            if (bakedquad.shouldApplyDiffuseLighting()) {
+               float diffuse = FaceBakery.getFaceBrightness(bakedquad.getFace());
+               f *= diffuse;
+               f1 *= diffuse;
+               f2 *= diffuse;
             }
 
-            float ☃xxxxxxxx = (☃xxxxxxx >> 16 & 0xFF) / 255.0F;
-            float ☃xxxxxxxxx = (☃xxxxxxx >> 8 & 0xFF) / 255.0F;
-            float ☃xxxxxxxxxx = (☃xxxxxxx & 0xFF) / 255.0F;
-            ☃.putColorMultiplier(☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx, 4);
-            ☃.putColorMultiplier(☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx, 3);
-            ☃.putColorMultiplier(☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx, 2);
-            ☃.putColorMultiplier(☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx, 1);
+            buffer.putColorMultiplier(f, f1, f2, 4);
+            buffer.putColorMultiplier(f, f1, f2, 3);
+            buffer.putColorMultiplier(f, f1, f2, 2);
+            buffer.putColorMultiplier(f, f1, f2, 1);
+         } else if (bakedquad.shouldApplyDiffuseLighting()) {
+            float diffuse = FaceBakery.getFaceBrightness(bakedquad.getFace());
+            buffer.putColorMultiplier(diffuse, diffuse, diffuse, 4);
+            buffer.putColorMultiplier(diffuse, diffuse, diffuse, 3);
+            buffer.putColorMultiplier(diffuse, diffuse, diffuse, 2);
+            buffer.putColorMultiplier(diffuse, diffuse, diffuse, 1);
          }
 
-         ☃.putPosition(☃x, ☃xx, ☃xxx);
+         buffer.putPosition(d0, d1, d2);
       }
    }
 
-   public void renderModelBrightnessColor(IBakedModel var1, float var2, float var3, float var4, float var5) {
-      this.renderModelBrightnessColor(null, ☃, ☃, ☃, ☃, ☃);
+   public void renderModelBrightnessColor(IBakedModel bakedModel, float p_178262_2_, float red, float green, float blue) {
+      this.renderModelBrightnessColor((IBlockState)null, bakedModel, p_178262_2_, red, green, blue);
    }
 
-   public void renderModelBrightnessColor(IBlockState var1, IBakedModel var2, float var3, float var4, float var5, float var6) {
-      for (EnumFacing ☃ : EnumFacing.values()) {
-         this.renderModelBrightnessColorQuads(☃, ☃, ☃, ☃, ☃.getQuads(☃, ☃, 0L));
+   public void renderModelBrightnessColor(
+      IBlockState state, IBakedModel p_187495_2_, float p_187495_3_, float p_187495_4_, float p_187495_5_, float p_187495_6_
+   ) {
+      for (EnumFacing enumfacing : EnumFacing.VALUES) {
+         this.renderModelBrightnessColorQuads(p_187495_3_, p_187495_4_, p_187495_5_, p_187495_6_, p_187495_2_.getQuads(state, enumfacing, 0L));
       }
 
-      this.renderModelBrightnessColorQuads(☃, ☃, ☃, ☃, ☃.getQuads(☃, null, 0L));
+      this.renderModelBrightnessColorQuads(p_187495_3_, p_187495_4_, p_187495_5_, p_187495_6_, p_187495_2_.getQuads(state, (EnumFacing)null, 0L));
    }
 
-   public void renderModelBrightness(IBakedModel var1, IBlockState var2, float var3, boolean var4) {
-      Block ☃ = ☃.getBlock();
+   public void renderModelBrightness(IBakedModel model, IBlockState state, float brightness, boolean p_178266_4_) {
+      Block block = state.getBlock();
       GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
-      int ☃x = this.blockColors.colorMultiplier(☃, null, null, 0);
+      int i = this.blockColors.colorMultiplier(state, (IBlockAccess)null, (BlockPos)null, 0);
       if (EntityRenderer.anaglyphEnable) {
-         ☃x = TextureUtil.anaglyphColor(☃x);
+         i = TextureUtil.anaglyphColor(i);
       }
 
-      float ☃xx = (☃x >> 16 & 0xFF) / 255.0F;
-      float ☃xxx = (☃x >> 8 & 0xFF) / 255.0F;
-      float ☃xxxx = (☃x & 0xFF) / 255.0F;
-      if (!☃) {
-         GlStateManager.color(☃, ☃, ☃, 1.0F);
+      float f = (i >> 16 & 0xFF) / 255.0F;
+      float f1 = (i >> 8 & 0xFF) / 255.0F;
+      float f2 = (i & 0xFF) / 255.0F;
+      if (!p_178266_4_) {
+         GlStateManager.color(brightness, brightness, brightness, 1.0F);
       }
 
-      this.renderModelBrightnessColor(☃, ☃, ☃, ☃xx, ☃xxx, ☃xxxx);
+      this.renderModelBrightnessColor(state, model, brightness, f, f1, f2);
    }
 
-   private void renderModelBrightnessColorQuads(float var1, float var2, float var3, float var4, List<BakedQuad> var5) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      int ☃xx = 0;
-
-      for (int ☃xxx = ☃.size(); ☃xx < ☃xxx; ☃xx++) {
-         BakedQuad ☃xxxx = ☃.get(☃xx);
-         ☃x.begin(7, DefaultVertexFormats.ITEM);
-         ☃x.addVertexData(☃xxxx.getVertexData());
-         if (☃xxxx.hasTintIndex()) {
-            ☃x.putColorRGB_F4(☃ * ☃, ☃ * ☃, ☃ * ☃);
+   private void renderModelBrightnessColorQuads(float brightness, float red, float green, float blue, List<BakedQuad> listQuads) {
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      int i = 0;
+
+      for (int j = listQuads.size(); i < j; i++) {
+         BakedQuad bakedquad = listQuads.get(i);
+         bufferbuilder.begin(7, DefaultVertexFormats.ITEM);
+         bufferbuilder.addVertexData(bakedquad.getVertexData());
+         bufferbuilder.putSprite(bakedquad.getSprite());
+         if (bakedquad.hasTintIndex()) {
+            bufferbuilder.putColorRGB_F4(red * brightness, green * brightness, blue * brightness);
          } else {
-            ☃x.putColorRGB_F4(☃, ☃, ☃);
+            bufferbuilder.putColorRGB_F4(brightness, brightness, brightness);
+         }
+
+         Vec3i vec3i = bakedquad.getFace().getDirectionVec();
+         bufferbuilder.putNormal(vec3i.getX(), vec3i.getY(), vec3i.getZ());
+         tessellator.draw();
+      }
+   }
+
+   public static float fixAoLightValue(float val) {
+      return val == 0.2F ? aoLightValueOpaque : val;
+   }
+
+   public static void updateAoLightValue() {
+      aoLightValueOpaque = 1.0F - Config.getAmbientOcclusionLevel() * 0.8F;
+      separateAoLightValue = Config.isShaders() && Shaders.isSeparateAo();
+   }
+
+   private void renderOverlayModels(
+      IBlockAccess worldIn,
+      IBakedModel modelIn,
+      IBlockState stateIn,
+      BlockPos posIn,
+      BufferBuilder buffer,
+      boolean checkSides,
+      long rand,
+      RenderEnv renderEnv,
+      boolean smooth
+   ) {
+      if (renderEnv.isOverlaysRendered()) {
+         for (int l = 0; l < OVERLAY_LAYERS.length; l++) {
+            BlockRenderLayer layer = OVERLAY_LAYERS[l];
+            ListQuadsOverlay listQuadsOverlay = renderEnv.getListQuadsOverlay(layer);
+            if (listQuadsOverlay.size() > 0) {
+               RegionRenderCacheBuilder rrcb = renderEnv.getRegionRenderCacheBuilder();
+               if (rrcb != null) {
+                  BufferBuilder overlayBuffer = rrcb.getWorldRendererByLayer(layer);
+                  if (!overlayBuffer.isDrawing()) {
+                     overlayBuffer.begin(7, DefaultVertexFormats.BLOCK);
+                     overlayBuffer.setTranslation(buffer.getXOffset(), buffer.getYOffset(), buffer.getZOffset());
+                  }
+
+                  for (int q = 0; q < listQuadsOverlay.size(); q++) {
+                     BakedQuad quad = listQuadsOverlay.getQuad(q);
+                     List<BakedQuad> listQuadSingle = listQuadsOverlay.getListQuadsSingle(quad);
+                     IBlockState quadBlockState = listQuadsOverlay.getBlockState(q);
+                     if (quad.getQuadEmissive() != null) {
+                        listQuadsOverlay.addQuad(quad.getQuadEmissive(), quadBlockState);
+                     }
+
+                     renderEnv.reset(quadBlockState, posIn);
+                     if (smooth) {
+                        this.renderQuadsSmooth(worldIn, quadBlockState, posIn, overlayBuffer, listQuadSingle, renderEnv);
+                     } else {
+                        int col = quadBlockState.b(worldIn, posIn.offset(quad.getFace()));
+                        this.renderQuadsFlat(worldIn, quadBlockState, posIn, col, false, overlayBuffer, listQuadSingle, renderEnv);
+                     }
+                  }
+               }
+
+               listQuadsOverlay.clear();
+            }
          }
+      }
 
-         Vec3i ☃xxxxx = ☃xxxx.getFace().getDirectionVec();
-         ☃x.putNormal(☃xxxxx.getX(), ☃xxxxx.getY(), ☃xxxxx.getZ());
-         ☃.draw();
+      if (Config.isBetterSnow() && !renderEnv.isBreakingAnimation() && BetterSnow.shouldRender(worldIn, stateIn, posIn)) {
+         IBakedModel modelSnow = BetterSnow.getModelSnowLayer();
+         IBlockState stateSnow = BetterSnow.getStateSnowLayer();
+         this.renderModel(worldIn, modelSnow, stateSnow, posIn, buffer, checkSides, rand);
       }
    }
 
-   class AmbientOcclusionFace {
+   public static class AmbientOcclusionFace {
       private final float[] vertexColorMultiplier = new float[4];
       private final int[] vertexBrightness = new int[4];
+      private MutableBlockPos[] blockPosArr = new MutableBlockPos[5];
 
       public AmbientOcclusionFace() {
+         this(null);
+      }
+
+      public AmbientOcclusionFace(BlockModelRenderer bmr) {
+         for (int i = 0; i < this.blockPosArr.length; i++) {
+            this.blockPosArr[i] = new MutableBlockPos();
+         }
       }
 
-      public void updateVertexBrightness(IBlockAccess var1, IBlockState var2, BlockPos var3, EnumFacing var4, float[] var5, BitSet var6) {
-         BlockPos ☃ = ☃.get(0) ? ☃.offset(☃) : ☃;
-         BlockPos.PooledMutableBlockPos ☃x = BlockPos.PooledMutableBlockPos.retain();
-         BlockModelRenderer.EnumNeighborInfo ☃xx = BlockModelRenderer.EnumNeighborInfo.getNeighbourInfo(☃);
-         BlockPos.PooledMutableBlockPos ☃xxx = BlockPos.PooledMutableBlockPos.retain(☃).move(☃xx.corners[0]);
-         BlockPos.PooledMutableBlockPos ☃xxxx = BlockPos.PooledMutableBlockPos.retain(☃).move(☃xx.corners[1]);
-         BlockPos.PooledMutableBlockPos ☃xxxxx = BlockPos.PooledMutableBlockPos.retain(☃).move(☃xx.corners[2]);
-         BlockPos.PooledMutableBlockPos ☃xxxxxx = BlockPos.PooledMutableBlockPos.retain(☃).move(☃xx.corners[3]);
-         int ☃xxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxx);
-         int ☃xxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxx);
-         int ☃xxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxx);
-         int ☃xxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxx);
-         float ☃xxxxxxxxxxx = ☃.getBlockState(☃xxx).getAmbientOcclusionLightValue();
-         float ☃xxxxxxxxxxxx = ☃.getBlockState(☃xxxx).getAmbientOcclusionLightValue();
-         float ☃xxxxxxxxxxxxx = ☃.getBlockState(☃xxxxx).getAmbientOcclusionLightValue();
-         float ☃xxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxx).getAmbientOcclusionLightValue();
-         boolean ☃xxxxxxxxxxxxxxx = ☃.getBlockState(☃x.setPos(☃xxx).move(☃)).isTranslucent();
-         boolean ☃xxxxxxxxxxxxxxxx = ☃.getBlockState(☃x.setPos(☃xxxx).move(☃)).isTranslucent();
-         boolean ☃xxxxxxxxxxxxxxxxx = ☃.getBlockState(☃x.setPos(☃xxxxx).move(☃)).isTranslucent();
-         boolean ☃xxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃x.setPos(☃xxxxxx).move(☃)).isTranslucent();
-         float ☃xxxxxxxxxxxxxxxxxxx;
-         int ☃xxxxxxxxxxxxxxxxxxxx;
-         if (!☃xxxxxxxxxxxxxxxxx && !☃xxxxxxxxxxxxxxx) {
-            ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx;
-            ☃xxxxxxxxxxxxxxxxxxxx = ☃xxxxxxx;
+      public void setMaxBlockLight() {
+         int maxBlockLight = 240;
+         this.vertexBrightness[0] = this.vertexBrightness[0] | maxBlockLight;
+         this.vertexBrightness[1] = this.vertexBrightness[1] | maxBlockLight;
+         this.vertexBrightness[2] = this.vertexBrightness[2] | maxBlockLight;
+         this.vertexBrightness[3] = this.vertexBrightness[3] | maxBlockLight;
+         this.vertexColorMultiplier[0] = 1.0F;
+         this.vertexColorMultiplier[1] = 1.0F;
+         this.vertexColorMultiplier[2] = 1.0F;
+         this.vertexColorMultiplier[3] = 1.0F;
+      }
+
+      public void updateVertexBrightness(
+         IBlockAccess worldIn, IBlockState state, BlockPos centerPos, EnumFacing direction, float[] faceShape, BitSet shapeState
+      ) {
+         BlockPos blockpos = shapeState.get(0) ? centerPos.offset(direction) : centerPos;
+         MutableBlockPos blockpos$pooledmutableblockpos = this.blockPosArr[0].setPos(0, 0, 0);
+         BlockModelRenderer.EnumNeighborInfo blockmodelrenderer$enumneighborinfo = BlockModelRenderer.EnumNeighborInfo.getNeighbourInfo(direction);
+         MutableBlockPos blockpos$pooledmutableblockpos1 = this.blockPosArr[1].setPos(blockpos).move(blockmodelrenderer$enumneighborinfo.corners[0]);
+         MutableBlockPos blockpos$pooledmutableblockpos2 = this.blockPosArr[2].setPos(blockpos).move(blockmodelrenderer$enumneighborinfo.corners[1]);
+         MutableBlockPos blockpos$pooledmutableblockpos3 = this.blockPosArr[3].setPos(blockpos).move(blockmodelrenderer$enumneighborinfo.corners[2]);
+         MutableBlockPos blockpos$pooledmutableblockpos4 = this.blockPosArr[4].setPos(blockpos).move(blockmodelrenderer$enumneighborinfo.corners[3]);
+         int i = state.b(worldIn, blockpos$pooledmutableblockpos1);
+         int j = state.b(worldIn, blockpos$pooledmutableblockpos2);
+         int k = state.b(worldIn, blockpos$pooledmutableblockpos3);
+         int l = state.b(worldIn, blockpos$pooledmutableblockpos4);
+         float f = worldIn.getBlockState(blockpos$pooledmutableblockpos1).j();
+         float f1 = worldIn.getBlockState(blockpos$pooledmutableblockpos2).j();
+         float f2 = worldIn.getBlockState(blockpos$pooledmutableblockpos3).j();
+         float f3 = worldIn.getBlockState(blockpos$pooledmutableblockpos4).j();
+         f = BlockModelRenderer.fixAoLightValue(f);
+         f1 = BlockModelRenderer.fixAoLightValue(f1);
+         f2 = BlockModelRenderer.fixAoLightValue(f2);
+         f3 = BlockModelRenderer.fixAoLightValue(f3);
+         boolean flag = worldIn.getBlockState(blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos1).move(direction)).e();
+         boolean flag1 = worldIn.getBlockState(blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos2).move(direction)).e();
+         boolean flag2 = worldIn.getBlockState(blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos3).move(direction)).e();
+         boolean flag3 = worldIn.getBlockState(blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos4).move(direction)).e();
+         int i1;
+         float f4;
+         if (!flag2 && !flag) {
+            f4 = f;
+            i1 = i;
          } else {
-            BlockPos ☃xxxxxxxxxxxxxxxxxxxxx = ☃x.setPos(☃xxx).move(☃xx.corners[2]);
-            ☃xxxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxxxxxxx).getAmbientOcclusionLightValue();
-            ☃xxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxxxxxxxxxxxxxxxxx);
+            BlockPos blockpos1 = blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos1).move(blockmodelrenderer$enumneighborinfo.corners[2]);
+            f4 = worldIn.getBlockState(blockpos1).j();
+            f4 = BlockModelRenderer.fixAoLightValue(f4);
+            i1 = state.b(worldIn, blockpos1);
          }
 
-         float ☃xxxxxxxxxxxxxxxxxxxxx;
-         int ☃xxxxxxxxxxxxxxxxxxxxxx;
-         if (!☃xxxxxxxxxxxxxxxxxx && !☃xxxxxxxxxxxxxxx) {
-            ☃xxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx;
-            ☃xxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxx;
+         int j1;
+         float f5;
+         if (!flag3 && !flag) {
+            f5 = f;
+            j1 = i;
          } else {
-            BlockPos ☃xxxxxxxxxxxxxxxxxxxxxxx = ☃x.setPos(☃xxx).move(☃xx.corners[3]);
-            ☃xxxxxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxxxxxxxxx).getAmbientOcclusionLightValue();
-            ☃xxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxxxxxxxxxxxxxxxxxxx);
+            BlockPos blockpos2 = blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos1).move(blockmodelrenderer$enumneighborinfo.corners[3]);
+            f5 = worldIn.getBlockState(blockpos2).j();
+            f5 = BlockModelRenderer.fixAoLightValue(f5);
+            j1 = state.b(worldIn, blockpos2);
          }
 
-         float ☃xxxxxxxxxxxxxxxxxxxxxxx;
-         int ☃xxxxxxxxxxxxxxxxxxxxxxxx;
-         if (!☃xxxxxxxxxxxxxxxxx && !☃xxxxxxxxxxxxxxxx) {
-            ☃xxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx;
-            ☃xxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxx;
+         int k1;
+         float f6;
+         if (!flag2 && !flag1) {
+            f6 = f1;
+            k1 = j;
          } else {
-            BlockPos ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃x.setPos(☃xxxx).move(☃xx.corners[2]);
-            ☃xxxxxxxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxxxxxxxxxxx).getAmbientOcclusionLightValue();
-            ☃xxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxxxxxxxxxxxxxxxxxxxxx);
+            BlockPos blockpos3 = blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos2).move(blockmodelrenderer$enumneighborinfo.corners[2]);
+            f6 = worldIn.getBlockState(blockpos3).j();
+            f6 = BlockModelRenderer.fixAoLightValue(f6);
+            k1 = state.b(worldIn, blockpos3);
          }
 
-         float ☃xxxxxxxxxxxxxxxxxxxxxxxxx;
-         int ☃xxxxxxxxxxxxxxxxxxxxxxxxxx;
-         if (!☃xxxxxxxxxxxxxxxxxx && !☃xxxxxxxxxxxxxxxx) {
-            ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx;
-            ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxx;
+         int l1;
+         float f7;
+         if (!flag3 && !flag1) {
+            f7 = f1;
+            l1 = j;
          } else {
-            BlockPos ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃x.setPos(☃xxxx).move(☃xx.corners[3]);
-            ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxxxxxxxxxxxxx).getAmbientOcclusionLightValue();
-            ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx);
-         }
-
-         int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃);
-         if (☃.get(0) || !☃.getBlockState(☃.offset(☃)).isOpaqueCube()) {
-            ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.getPackedLightmapCoords(☃, ☃.offset(☃));
-         }
-
-         float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃.get(0)
-            ? ☃.getBlockState(☃).getAmbientOcclusionLightValue()
-            : ☃.getBlockState(☃).getAmbientOcclusionLightValue();
-         BlockModelRenderer.VertexTranslations ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = BlockModelRenderer.VertexTranslations.getVertexTranslations(☃);
-         ☃x.release();
-         ☃xxx.release();
-         ☃xxxx.release();
-         ☃xxxxx.release();
-         ☃xxxxxx.release();
-         if (☃.get(1) && ☃xx.doNonCubicWeight) {
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxxx + ☃xxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxx + ☃xxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxx + ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxxx + ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert0Weights[0].shape] * ☃[☃xx.vert0Weights[1].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert0Weights[2].shape] * ☃[☃xx.vert0Weights[3].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert0Weights[4].shape] * ☃[☃xx.vert0Weights[5].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert0Weights[6].shape] * ☃[☃xx.vert0Weights[7].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert1Weights[0].shape] * ☃[☃xx.vert1Weights[1].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert1Weights[2].shape] * ☃[☃xx.vert1Weights[3].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert1Weights[4].shape] * ☃[☃xx.vert1Weights[5].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert1Weights[6].shape] * ☃[☃xx.vert1Weights[7].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert2Weights[0].shape] * ☃[☃xx.vert2Weights[1].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert2Weights[2].shape] * ☃[☃xx.vert2Weights[3].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert2Weights[4].shape] * ☃[☃xx.vert2Weights[5].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert2Weights[6].shape] * ☃[☃xx.vert2Weights[7].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert3Weights[0].shape] * ☃[☃xx.vert3Weights[1].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert3Weights[2].shape] * ☃[☃xx.vert3Weights[3].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert3Weights[4].shape] * ☃[☃xx.vert3Weights[5].shape];
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃[☃xx.vert3Weights[6].shape] * ☃[☃xx.vert3Weights[7].shape];
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert0] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert1] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert2] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert3] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                  * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-               + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.getAoBrightness(
-               ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.getAoBrightness(
-               ☃xxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.getAoBrightness(
-               ☃xxxxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.getAoBrightness(
-               ☃xxxxxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert0] = this.getVertexBrightness(
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert1] = this.getVertexBrightness(
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert2] = this.getVertexBrightness(
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert3] = this.getVertexBrightness(
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-               ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
+            BlockPos blockpos4 = blockpos$pooledmutableblockpos.setPos(blockpos$pooledmutableblockpos2).move(blockmodelrenderer$enumneighborinfo.corners[3]);
+            f7 = worldIn.getBlockState(blockpos4).j();
+            f7 = BlockModelRenderer.fixAoLightValue(f7);
+            l1 = state.b(worldIn, blockpos4);
+         }
+
+         int i3 = state.b(worldIn, centerPos);
+         if (shapeState.get(0) || !worldIn.getBlockState(centerPos.offset(direction)).p()) {
+            i3 = state.b(worldIn, centerPos.offset(direction));
+         }
+
+         float f8 = shapeState.get(0) ? worldIn.getBlockState(blockpos).j() : worldIn.getBlockState(centerPos).j();
+         f8 = BlockModelRenderer.fixAoLightValue(f8);
+         BlockModelRenderer.VertexTranslations blockmodelrenderer$vertextranslations = BlockModelRenderer.VertexTranslations.getVertexTranslations(direction);
+         if (shapeState.get(1) && blockmodelrenderer$enumneighborinfo.doNonCubicWeight) {
+            float f29 = (f3 + f + f5 + f8) * 0.25F;
+            float f30 = (f2 + f + f4 + f8) * 0.25F;
+            float f31 = (f2 + f1 + f6 + f8) * 0.25F;
+            float f32 = (f3 + f1 + f7 + f8) * 0.25F;
+            float f13 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[0].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[1].shape];
+            float f14 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[2].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[3].shape];
+            float f15 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[4].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[5].shape];
+            float f16 = faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[6].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert0Weights[7].shape];
+            float f17 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[0].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[1].shape];
+            float f18 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[2].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[3].shape];
+            float f19 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[4].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[5].shape];
+            float f20 = faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[6].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert1Weights[7].shape];
+            float f21 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[0].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[1].shape];
+            float f22 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[2].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[3].shape];
+            float f23 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[4].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[5].shape];
+            float f24 = faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[6].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert2Weights[7].shape];
+            float f25 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[0].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[1].shape];
+            float f26 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[2].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[3].shape];
+            float f27 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[4].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[5].shape];
+            float f28 = faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[6].shape]
+               * faceShape[blockmodelrenderer$enumneighborinfo.vert3Weights[7].shape];
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert0] = f29 * f13 + f30 * f14 + f31 * f15 + f32 * f16;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert1] = f29 * f17 + f30 * f18 + f31 * f19 + f32 * f20;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert2] = f29 * f21 + f30 * f22 + f31 * f23 + f32 * f24;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert3] = f29 * f25 + f30 * f26 + f31 * f27 + f32 * f28;
+            int i2 = this.getAoBrightness(l, i, j1, i3);
+            int j2 = this.getAoBrightness(k, i, i1, i3);
+            int k2 = this.getAoBrightness(k, j, k1, i3);
+            int l2 = this.getAoBrightness(l, j, l1, i3);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert0] = this.getVertexBrightness(i2, j2, k2, l2, f13, f14, f15, f16);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert1] = this.getVertexBrightness(i2, j2, k2, l2, f17, f18, f19, f20);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert2] = this.getVertexBrightness(i2, j2, k2, l2, f21, f22, f23, f24);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert3] = this.getVertexBrightness(i2, j2, k2, l2, f25, f26, f27, f28);
          } else {
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxxx + ☃xxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxx + ☃xxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxx + ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxxx + ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.25F;
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert0] = this.getAoBrightness(
-               ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert1] = this.getAoBrightness(
-               ☃xxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert2] = this.getAoBrightness(
-               ☃xxxxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexBrightness[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert3] = this.getAoBrightness(
-               ☃xxxxxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx
-            );
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert0] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert1] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert2] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
-            this.vertexColorMultiplier[☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx.vert3] = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
+            float f9 = (f3 + f + f5 + f8) * 0.25F;
+            float f10 = (f2 + f + f4 + f8) * 0.25F;
+            float f11 = (f2 + f1 + f6 + f8) * 0.25F;
+            float f12 = (f3 + f1 + f7 + f8) * 0.25F;
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert0] = this.getAoBrightness(l, i, j1, i3);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert1] = this.getAoBrightness(k, i, i1, i3);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert2] = this.getAoBrightness(k, j, k1, i3);
+            this.vertexBrightness[blockmodelrenderer$vertextranslations.vert3] = this.getAoBrightness(l, j, l1, i3);
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert0] = f9;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert1] = f10;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert2] = f11;
+            this.vertexColorMultiplier[blockmodelrenderer$vertextranslations.vert3] = f12;
          }
       }
 
-      private int getAoBrightness(int var1, int var2, int var3, int var4) {
-         if (☃ == 0) {
-            ☃ = ☃;
+      private int getAoBrightness(int br1, int br2, int br3, int br4) {
+         if (br1 == 0) {
+            br1 = br4;
          }
 
-         if (☃ == 0) {
-            ☃ = ☃;
+         if (br2 == 0) {
+            br2 = br4;
          }
 
-         if (☃ == 0) {
-            ☃ = ☃;
+         if (br3 == 0) {
+            br3 = br4;
          }
 
-         return ☃ + ☃ + ☃ + ☃ >> 2 & 16711935;
+         return br1 + br2 + br3 + br4 >> 2 & 16711935;
       }
 
-      private int getVertexBrightness(int var1, int var2, int var3, int var4, float var5, float var6, float var7, float var8) {
-         int ☃ = (int)((☃ >> 16 & 0xFF) * ☃ + (☃ >> 16 & 0xFF) * ☃ + (☃ >> 16 & 0xFF) * ☃ + (☃ >> 16 & 0xFF) * ☃) & 0xFF;
-         int ☃x = (int)((☃ & 0xFF) * ☃ + (☃ & 0xFF) * ☃ + (☃ & 0xFF) * ☃ + (☃ & 0xFF) * ☃) & 0xFF;
-         return ☃ << 16 | ☃x;
+      private int getVertexBrightness(
+         int p_178203_1_, int p_178203_2_, int p_178203_3_, int p_178203_4_, float p_178203_5_, float p_178203_6_, float p_178203_7_, float p_178203_8_
+      ) {
+         int i = (int)(
+               (p_178203_1_ >> 16 & 0xFF) * p_178203_5_
+                  + (p_178203_2_ >> 16 & 0xFF) * p_178203_6_
+                  + (p_178203_3_ >> 16 & 0xFF) * p_178203_7_
+                  + (p_178203_4_ >> 16 & 0xFF) * p_178203_8_
+            )
+            & 0xFF;
+         int j = (int)(
+               (p_178203_1_ & 0xFF) * p_178203_5_
+                  + (p_178203_2_ & 0xFF) * p_178203_6_
+                  + (p_178203_3_ & 0xFF) * p_178203_7_
+                  + (p_178203_4_ & 0xFF) * p_178203_8_
+            )
+            & 0xFF;
+         return i << 16 | j;
       }
    }
 
@@ -795,25 +973,25 @@ public static enum EnumNeighborInfo {
       private static final BlockModelRenderer.EnumNeighborInfo[] VALUES = new BlockModelRenderer.EnumNeighborInfo[6];
 
       private EnumNeighborInfo(
-         EnumFacing[] var3,
-         float var4,
-         boolean var5,
-         BlockModelRenderer.Orientation[] var6,
-         BlockModelRenderer.Orientation[] var7,
-         BlockModelRenderer.Orientation[] var8,
-         BlockModelRenderer.Orientation[] var9
+         EnumFacing[] p_i46236_3_,
+         float p_i46236_4_,
+         boolean p_i46236_5_,
+         BlockModelRenderer.Orientation[] p_i46236_6_,
+         BlockModelRenderer.Orientation[] p_i46236_7_,
+         BlockModelRenderer.Orientation[] p_i46236_8_,
+         BlockModelRenderer.Orientation[] p_i46236_9_
       ) {
-         this.corners = ☃;
-         this.shadeWeight = ☃;
-         this.doNonCubicWeight = ☃;
-         this.vert0Weights = ☃;
-         this.vert1Weights = ☃;
-         this.vert2Weights = ☃;
-         this.vert3Weights = ☃;
+         this.corners = p_i46236_3_;
+         this.shadeWeight = p_i46236_4_;
+         this.doNonCubicWeight = p_i46236_5_;
+         this.vert0Weights = p_i46236_6_;
+         this.vert1Weights = p_i46236_7_;
+         this.vert2Weights = p_i46236_8_;
+         this.vert3Weights = p_i46236_9_;
       }
 
-      public static BlockModelRenderer.EnumNeighborInfo getNeighbourInfo(EnumFacing var0) {
-         return VALUES[☃.getIndex()];
+      public static BlockModelRenderer.EnumNeighborInfo getNeighbourInfo(EnumFacing p_178273_0_) {
+         return VALUES[p_178273_0_.getIndex()];
       }
 
       static {
@@ -842,8 +1020,8 @@ public static enum Orientation {
 
       private final int shape;
 
-      private Orientation(EnumFacing var3, boolean var4) {
-         this.shape = ☃.getIndex() + (☃ ? EnumFacing.values().length : 0);
+      private Orientation(EnumFacing p_i46233_3_, boolean p_i46233_4_) {
+         this.shape = p_i46233_3_.getIndex() + (p_i46233_4_ ? EnumFacing.values().length : 0);
       }
    }
 
@@ -861,15 +1039,15 @@ static enum VertexTranslations {
       private final int vert3;
       private static final BlockModelRenderer.VertexTranslations[] VALUES = new BlockModelRenderer.VertexTranslations[6];
 
-      private VertexTranslations(int var3, int var4, int var5, int var6) {
-         this.vert0 = ☃;
-         this.vert1 = ☃;
-         this.vert2 = ☃;
-         this.vert3 = ☃;
+      private VertexTranslations(int p_i46234_3_, int p_i46234_4_, int p_i46234_5_, int p_i46234_6_) {
+         this.vert0 = p_i46234_3_;
+         this.vert1 = p_i46234_4_;
+         this.vert2 = p_i46234_5_;
+         this.vert3 = p_i46234_6_;
       }
 
-      public static BlockModelRenderer.VertexTranslations getVertexTranslations(EnumFacing var0) {
-         return VALUES[☃.getIndex()];
+      public static BlockModelRenderer.VertexTranslations getVertexTranslations(EnumFacing p_178184_0_) {
+         return VALUES[p_178184_0_.getIndex()];
       }
 
       static {
diff --git a/patches/net/minecraft/client/renderer/BufferBuilder.java b/patches/net/minecraft/client/renderer/BufferBuilder.java
index 1bbae03..83f95f3 100644
--- a/patches/net/minecraft/client/renderer/BufferBuilder.java
+++ b/patches/net/minecraft/client/renderer/BufferBuilder.java
@@ -10,300 +10,408 @@
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Comparator;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.SmartAnimations;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
+import net.optifine.util.TextureUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.GL11;
 
 public class BufferBuilder {
    private static final Logger LOGGER = LogManager.getLogger();
    private ByteBuffer byteBuffer;
-   private IntBuffer rawIntBuffer;
+   public IntBuffer rawIntBuffer;
    private ShortBuffer rawShortBuffer;
-   private FloatBuffer rawFloatBuffer;
-   private int vertexCount;
+   public FloatBuffer rawFloatBuffer;
+   public int vertexCount;
    private VertexFormatElement vertexFormatElement;
    private int vertexFormatIndex;
    private boolean noColor;
-   private int drawMode;
+   public int drawMode;
    private double xOffset;
    private double yOffset;
    private double zOffset;
    private VertexFormat vertexFormat;
    private boolean isDrawing;
-
-   public BufferBuilder(int var1) {
-      this.byteBuffer = GLAllocation.createDirectByteBuffer(☃ * 4);
+   private BlockRenderLayer blockLayer = null;
+   private boolean[] drawnIcons = new boolean[256];
+   private TextureAtlasSprite[] quadSprites = null;
+   private TextureAtlasSprite[] quadSpritesPrev = null;
+   private TextureAtlasSprite quadSprite = null;
+   public SVertexBuilder sVertexBuilder;
+   public RenderEnv renderEnv = null;
+   public BitSet animatedSprites = null;
+   public BitSet animatedSpritesCached = new BitSet();
+   private boolean modeTriangles = false;
+   private ByteBuffer byteBufferTriangles;
+
+   public BufferBuilder(int bufferSizeIn) {
+      this.byteBuffer = GLAllocation.createDirectByteBuffer(bufferSizeIn * 4);
       this.rawIntBuffer = this.byteBuffer.asIntBuffer();
       this.rawShortBuffer = this.byteBuffer.asShortBuffer();
       this.rawFloatBuffer = this.byteBuffer.asFloatBuffer();
+      SVertexBuilder.initVertexBuilder(this);
    }
 
-   private void growBuffer(int var1) {
-      if (MathHelper.roundUp(☃, 4) / 4 > this.rawIntBuffer.remaining() || this.vertexCount * this.vertexFormat.getSize() + ☃ > this.byteBuffer.capacity()) {
-         int ☃ = this.byteBuffer.capacity();
-         int ☃x = ☃ + MathHelper.roundUp(☃, 2097152);
-         LOGGER.debug("Needed to grow BufferBuilder buffer: Old size {} bytes, new size {} bytes.", ☃, ☃x);
-         int ☃xx = this.rawIntBuffer.position();
-         ByteBuffer ☃xxx = GLAllocation.createDirectByteBuffer(☃x);
+   private void growBuffer(int p_181670_1_) {
+      if (MathHelper.roundUp(p_181670_1_, 4) / 4 > this.rawIntBuffer.remaining()
+         || this.vertexCount * this.vertexFormat.getSize() + p_181670_1_ > this.byteBuffer.capacity()) {
+         int i = this.byteBuffer.capacity();
+         int j = i + MathHelper.roundUp(p_181670_1_, 2097152);
+         LOGGER.debug("Needed to grow BufferBuilder buffer: Old size {} bytes, new size {} bytes.", i, j);
+         int k = this.rawIntBuffer.position();
+         ByteBuffer bytebuffer = GLAllocation.createDirectByteBuffer(j);
          ((Buffer)this.byteBuffer).position(0);
-         ☃xxx.put(this.byteBuffer);
-         ((Buffer)☃xxx).rewind();
-         this.byteBuffer = ☃xxx;
-         this.rawFloatBuffer = this.byteBuffer.asFloatBuffer().asReadOnlyBuffer();
+         bytebuffer.put(this.byteBuffer);
+         ((Buffer)bytebuffer).rewind();
+         this.byteBuffer = bytebuffer;
+         this.rawFloatBuffer = this.byteBuffer.asFloatBuffer();
          this.rawIntBuffer = this.byteBuffer.asIntBuffer();
-         ((Buffer)this.rawIntBuffer).position(☃xx);
+         ((Buffer)this.rawIntBuffer).position(k);
          this.rawShortBuffer = this.byteBuffer.asShortBuffer();
-         ((Buffer)this.rawShortBuffer).position(☃xx << 1);
+         ((Buffer)this.rawShortBuffer).position(k << 1);
+         if (this.quadSprites != null) {
+            TextureAtlasSprite[] sprites = this.quadSprites;
+            int quadSize = this.getBufferQuadSize();
+            this.quadSprites = new TextureAtlasSprite[quadSize];
+            System.arraycopy(sprites, 0, this.quadSprites, 0, Math.min(sprites.length, this.quadSprites.length));
+            this.quadSpritesPrev = null;
+         }
       }
    }
 
-   public void sortVertexData(float var1, float var2, float var3) {
-      int ☃ = this.vertexCount / 4;
-      final float[] ☃x = new float[☃];
+   public void sortVertexData(float p_181674_1_, float p_181674_2_, float p_181674_3_) {
+      int i = this.vertexCount / 4;
+      final float[] afloat = new float[i];
 
-      for (int ☃xx = 0; ☃xx < ☃; ☃xx++) {
-         ☃x[☃xx] = getDistanceSq(
+      for (int j = 0; j < i; j++) {
+         afloat[j] = getDistanceSq(
             this.rawFloatBuffer,
-            (float)(☃ + this.xOffset),
-            (float)(☃ + this.yOffset),
-            (float)(☃ + this.zOffset),
+            (float)(p_181674_1_ + this.xOffset),
+            (float)(p_181674_2_ + this.yOffset),
+            (float)(p_181674_3_ + this.zOffset),
             this.vertexFormat.getIntegerSize(),
-            ☃xx * this.vertexFormat.getSize()
+            j * this.vertexFormat.getSize()
          );
       }
 
-      Integer[] ☃xx = new Integer[☃];
+      Integer[] ainteger = new Integer[i];
 
-      for (int ☃xxx = 0; ☃xxx < ☃xx.length; ☃xxx++) {
-         ☃xx[☃xxx] = ☃xxx;
+      for (int k = 0; k < ainteger.length; k++) {
+         ainteger[k] = k;
       }
 
-      Arrays.sort(☃xx, new Comparator<Integer>() {
-         public int compare(Integer var1, Integer var2x) {
-            return Floats.compare(☃[var2x], ☃[☃]);
+      Arrays.sort(ainteger, new Comparator<Integer>() {
+         public int compare(Integer p_compare_1_, Integer p_compare_2_) {
+            return Floats.compare(afloat[p_compare_2_], afloat[p_compare_1_]);
          }
       });
-      BitSet ☃xxx = new BitSet();
-      int ☃xxxx = this.vertexFormat.getSize();
-      int[] ☃xxxxx = new int[☃xxxx];
-
-      for (int ☃xxxxxx = ☃xxx.nextClearBit(0); ☃xxxxxx < ☃xx.length; ☃xxxxxx = ☃xxx.nextClearBit(☃xxxxxx + 1)) {
-         int ☃xxxxxxx = ☃xx[☃xxxxxx];
-         if (☃xxxxxxx != ☃xxxxxx) {
-            ((Buffer)this.rawIntBuffer).limit(☃xxxxxxx * ☃xxxx + ☃xxxx);
-            ((Buffer)this.rawIntBuffer).position(☃xxxxxxx * ☃xxxx);
-            this.rawIntBuffer.get(☃xxxxx);
-            int ☃xxxxxxxx = ☃xxxxxxx;
-
-            for (int ☃xxxxxxxxx = ☃xx[☃xxxxxxx]; ☃xxxxxxxx != ☃xxxxxx; ☃xxxxxxxxx = ☃xx[☃xxxxxxxxx]) {
-               ((Buffer)this.rawIntBuffer).limit(☃xxxxxxxxx * ☃xxxx + ☃xxxx);
-               ((Buffer)this.rawIntBuffer).position(☃xxxxxxxxx * ☃xxxx);
-               IntBuffer ☃xxxxxxxxxx = this.rawIntBuffer.slice();
-               ((Buffer)this.rawIntBuffer).limit(☃xxxxxxxx * ☃xxxx + ☃xxxx);
-               ((Buffer)this.rawIntBuffer).position(☃xxxxxxxx * ☃xxxx);
-               this.rawIntBuffer.put(☃xxxxxxxxxx);
-               ☃xxx.set(☃xxxxxxxx);
-               ☃xxxxxxxx = ☃xxxxxxxxx;
+      BitSet bitset = new BitSet();
+      int l = this.vertexFormat.getSize();
+      int[] aint = new int[l];
+
+      for (int i1 = bitset.nextClearBit(0); i1 < ainteger.length; i1 = bitset.nextClearBit(i1 + 1)) {
+         int j1 = ainteger[i1];
+         if (j1 != i1) {
+            ((Buffer)this.rawIntBuffer).limit(j1 * l + l);
+            ((Buffer)this.rawIntBuffer).position(j1 * l);
+            this.rawIntBuffer.get(aint);
+            int k1 = j1;
+
+            for (int l1 = ainteger[j1]; k1 != i1; l1 = ainteger[l1]) {
+               ((Buffer)this.rawIntBuffer).limit(l1 * l + l);
+               ((Buffer)this.rawIntBuffer).position(l1 * l);
+               IntBuffer intbuffer = this.rawIntBuffer.slice();
+               ((Buffer)this.rawIntBuffer).limit(k1 * l + l);
+               ((Buffer)this.rawIntBuffer).position(k1 * l);
+               this.rawIntBuffer.put(intbuffer);
+               bitset.set(k1);
+               k1 = l1;
             }
 
-            ((Buffer)this.rawIntBuffer).limit(☃xxxxxx * ☃xxxx + ☃xxxx);
-            ((Buffer)this.rawIntBuffer).position(☃xxxxxx * ☃xxxx);
-            this.rawIntBuffer.put(☃xxxxx);
+            ((Buffer)this.rawIntBuffer).limit(i1 * l + l);
+            ((Buffer)this.rawIntBuffer).position(i1 * l);
+            this.rawIntBuffer.put(aint);
+         }
+
+         bitset.set(i1);
+      }
+
+      ((Buffer)this.rawIntBuffer).limit(this.rawIntBuffer.capacity());
+      ((Buffer)this.rawIntBuffer).position(this.getBufferSize());
+      if (this.quadSprites != null) {
+         TextureAtlasSprite[] quadSpritesSorted = new TextureAtlasSprite[this.vertexCount / 4];
+         int quadStep = this.vertexFormat.getSize() / 4 * 4;
+
+         for (int ix = 0; ix < ainteger.length; ix++) {
+            int indexQuad = ainteger[ix];
+            quadSpritesSorted[ix] = this.quadSprites[indexQuad];
          }
 
-         ☃xxx.set(☃xxxxxx);
+         System.arraycopy(quadSpritesSorted, 0, this.quadSprites, 0, quadSpritesSorted.length);
       }
    }
 
    public BufferBuilder.State getVertexState() {
       ((Buffer)this.rawIntBuffer).rewind();
-      int ☃ = this.getBufferSize();
-      ((Buffer)this.rawIntBuffer).limit(☃);
-      int[] ☃x = new int[☃];
-      this.rawIntBuffer.get(☃x);
+      int i = this.getBufferSize();
+      ((Buffer)this.rawIntBuffer).limit(i);
+      int[] aint = new int[i];
+      this.rawIntBuffer.get(aint);
       ((Buffer)this.rawIntBuffer).limit(this.rawIntBuffer.capacity());
-      ((Buffer)this.rawIntBuffer).position(☃);
-      return new BufferBuilder.State(☃x, new VertexFormat(this.vertexFormat));
+      ((Buffer)this.rawIntBuffer).position(i);
+      TextureAtlasSprite[] quadSpritesCopy = null;
+      if (this.quadSprites != null) {
+         int countQuads = this.vertexCount / 4;
+         quadSpritesCopy = new TextureAtlasSprite[countQuads];
+         System.arraycopy(this.quadSprites, 0, quadSpritesCopy, 0, countQuads);
+      }
+
+      return new BufferBuilder.State(aint, new VertexFormat(this.vertexFormat), quadSpritesCopy);
    }
 
-   private int getBufferSize() {
+   public int getBufferSize() {
       return this.vertexCount * this.vertexFormat.getIntegerSize();
    }
 
-   private static float getDistanceSq(FloatBuffer var0, float var1, float var2, float var3, int var4, int var5) {
-      float ☃ = ☃.get(☃ + ☃ * 0 + 0);
-      float ☃x = ☃.get(☃ + ☃ * 0 + 1);
-      float ☃xx = ☃.get(☃ + ☃ * 0 + 2);
-      float ☃xxx = ☃.get(☃ + ☃ * 1 + 0);
-      float ☃xxxx = ☃.get(☃ + ☃ * 1 + 1);
-      float ☃xxxxx = ☃.get(☃ + ☃ * 1 + 2);
-      float ☃xxxxxx = ☃.get(☃ + ☃ * 2 + 0);
-      float ☃xxxxxxx = ☃.get(☃ + ☃ * 2 + 1);
-      float ☃xxxxxxxx = ☃.get(☃ + ☃ * 2 + 2);
-      float ☃xxxxxxxxx = ☃.get(☃ + ☃ * 3 + 0);
-      float ☃xxxxxxxxxx = ☃.get(☃ + ☃ * 3 + 1);
-      float ☃xxxxxxxxxxx = ☃.get(☃ + ☃ * 3 + 2);
-      float ☃xxxxxxxxxxxx = (☃ + ☃xxx + ☃xxxxxx + ☃xxxxxxxxx) * 0.25F - ☃;
-      float ☃xxxxxxxxxxxxx = (☃x + ☃xxxx + ☃xxxxxxx + ☃xxxxxxxxxx) * 0.25F - ☃;
-      float ☃xxxxxxxxxxxxxx = (☃xx + ☃xxxxx + ☃xxxxxxxx + ☃xxxxxxxxxxx) * 0.25F - ☃;
-      return ☃xxxxxxxxxxxx * ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxx * ☃xxxxxxxxxxxxx + ☃xxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxx;
-   }
-
-   public void setVertexState(BufferBuilder.State var1) {
+   private static float getDistanceSq(FloatBuffer p_181665_0_, float p_181665_1_, float p_181665_2_, float p_181665_3_, int p_181665_4_, int p_181665_5_) {
+      float f = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 0);
+      float f1 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 1);
+      float f2 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 0 + 2);
+      float f3 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 0);
+      float f4 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 1);
+      float f5 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 1 + 2);
+      float f6 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 0);
+      float f7 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 1);
+      float f8 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 2 + 2);
+      float f9 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 0);
+      float f10 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 1);
+      float f11 = p_181665_0_.get(p_181665_5_ + p_181665_4_ * 3 + 2);
+      float f12 = (f + f3 + f6 + f9) * 0.25F - p_181665_1_;
+      float f13 = (f1 + f4 + f7 + f10) * 0.25F - p_181665_2_;
+      float f14 = (f2 + f5 + f8 + f11) * 0.25F - p_181665_3_;
+      return f12 * f12 + f13 * f13 + f14 * f14;
+   }
+
+   public void setVertexState(BufferBuilder.State state) {
       ((Buffer)this.rawIntBuffer).clear();
-      this.growBuffer(☃.getRawBuffer().length * 4);
-      this.rawIntBuffer.put(☃.getRawBuffer());
-      this.vertexCount = ☃.getVertexCount();
-      this.vertexFormat = new VertexFormat(☃.getVertexFormat());
+      this.growBuffer(state.getRawBuffer().length * 4);
+      this.rawIntBuffer.put(state.getRawBuffer());
+      this.vertexCount = state.getVertexCount();
+      this.vertexFormat = new VertexFormat(state.getVertexFormat());
+      if (state.stateQuadSprites != null) {
+         if (this.quadSprites == null) {
+            this.quadSprites = this.quadSpritesPrev;
+         }
+
+         if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
+            this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
+         }
+
+         TextureAtlasSprite[] src = state.stateQuadSprites;
+         System.arraycopy(src, 0, this.quadSprites, 0, src.length);
+      } else {
+         if (this.quadSprites != null) {
+            this.quadSpritesPrev = this.quadSprites;
+         }
+
+         this.quadSprites = null;
+      }
    }
 
    public void reset() {
       this.vertexCount = 0;
       this.vertexFormatElement = null;
       this.vertexFormatIndex = 0;
+      this.quadSprite = null;
+      if (SmartAnimations.isActive()) {
+         if (this.animatedSprites == null) {
+            this.animatedSprites = this.animatedSpritesCached;
+         }
+
+         this.animatedSprites.clear();
+      } else if (this.animatedSprites != null) {
+         this.animatedSprites = null;
+      }
+
+      this.modeTriangles = false;
    }
 
-   public void begin(int var1, VertexFormat var2) {
+   public void begin(int glMode, VertexFormat format) {
       if (this.isDrawing) {
          throw new IllegalStateException("Already building!");
       } else {
          this.isDrawing = true;
          this.reset();
-         this.drawMode = ☃;
-         this.vertexFormat = ☃;
-         this.vertexFormatElement = ☃.getElement(this.vertexFormatIndex);
+         this.drawMode = glMode;
+         this.vertexFormat = format;
+         this.vertexFormatElement = format.getElement(this.vertexFormatIndex);
          this.noColor = false;
          ((Buffer)this.byteBuffer).limit(this.byteBuffer.capacity());
+         if (Config.isShaders()) {
+            SVertexBuilder.endSetVertexFormat(this);
+         }
+
+         if (Config.isMultiTexture()) {
+            if (this.blockLayer != null) {
+               if (this.quadSprites == null) {
+                  this.quadSprites = this.quadSpritesPrev;
+               }
+
+               if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
+                  this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
+               }
+            }
+         } else {
+            if (this.quadSprites != null) {
+               this.quadSpritesPrev = this.quadSprites;
+            }
+
+            this.quadSprites = null;
+         }
       }
    }
 
-   public BufferBuilder tex(double var1, double var3) {
-      int ☃ = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
+   public BufferBuilder tex(double u, double v) {
+      if (this.quadSprite != null && this.quadSprites != null) {
+         u = this.quadSprite.toSingleU((float)u);
+         v = this.quadSprite.toSingleV((float)v);
+         this.quadSprites[this.vertexCount / 4] = this.quadSprite;
+      }
+
+      int i = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
-            this.byteBuffer.putFloat(☃, (float)☃);
-            this.byteBuffer.putFloat(☃ + 4, (float)☃);
+            this.byteBuffer.putFloat(i, (float)u);
+            this.byteBuffer.putFloat(i + 4, (float)v);
             break;
          case UINT:
          case INT:
-            this.byteBuffer.putInt(☃, (int)☃);
-            this.byteBuffer.putInt(☃ + 4, (int)☃);
+            this.byteBuffer.putInt(i, (int)u);
+            this.byteBuffer.putInt(i + 4, (int)v);
             break;
          case USHORT:
          case SHORT:
-            this.byteBuffer.putShort(☃, (short)☃);
-            this.byteBuffer.putShort(☃ + 2, (short)☃);
+            this.byteBuffer.putShort(i, (short)v);
+            this.byteBuffer.putShort(i + 2, (short)u);
             break;
          case UBYTE:
          case BYTE:
-            this.byteBuffer.put(☃, (byte)☃);
-            this.byteBuffer.put(☃ + 1, (byte)☃);
+            this.byteBuffer.put(i, (byte)v);
+            this.byteBuffer.put(i + 1, (byte)u);
       }
 
       this.nextVertexFormatIndex();
       return this;
    }
 
-   public BufferBuilder lightmap(int var1, int var2) {
-      int ☃ = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
+   public BufferBuilder lightmap(int p_187314_1_, int p_187314_2_) {
+      int i = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
-            this.byteBuffer.putFloat(☃, ☃);
-            this.byteBuffer.putFloat(☃ + 4, ☃);
+            this.byteBuffer.putFloat(i, p_187314_1_);
+            this.byteBuffer.putFloat(i + 4, p_187314_2_);
             break;
          case UINT:
          case INT:
-            this.byteBuffer.putInt(☃, ☃);
-            this.byteBuffer.putInt(☃ + 4, ☃);
+            this.byteBuffer.putInt(i, p_187314_1_);
+            this.byteBuffer.putInt(i + 4, p_187314_2_);
             break;
          case USHORT:
          case SHORT:
-            this.byteBuffer.putShort(☃, (short)☃);
-            this.byteBuffer.putShort(☃ + 2, (short)☃);
+            this.byteBuffer.putShort(i, (short)p_187314_2_);
+            this.byteBuffer.putShort(i + 2, (short)p_187314_1_);
             break;
          case UBYTE:
          case BYTE:
-            this.byteBuffer.put(☃, (byte)☃);
-            this.byteBuffer.put(☃ + 1, (byte)☃);
+            this.byteBuffer.put(i, (byte)p_187314_2_);
+            this.byteBuffer.put(i + 1, (byte)p_187314_1_);
       }
 
       this.nextVertexFormatIndex();
       return this;
    }
 
-   public void putBrightness4(int var1, int var2, int var3, int var4) {
-      int ☃ = (this.vertexCount - 4) * this.vertexFormat.getIntegerSize() + this.vertexFormat.getUvOffsetById(1) / 4;
-      int ☃x = this.vertexFormat.getSize() >> 2;
-      this.rawIntBuffer.put(☃, ☃);
-      this.rawIntBuffer.put(☃ + ☃x, ☃);
-      this.rawIntBuffer.put(☃ + ☃x * 2, ☃);
-      this.rawIntBuffer.put(☃ + ☃x * 3, ☃);
+   public void putBrightness4(int p_178962_1_, int p_178962_2_, int p_178962_3_, int p_178962_4_) {
+      int i = (this.vertexCount - 4) * this.vertexFormat.getIntegerSize() + this.vertexFormat.getUvOffsetById(1) / 4;
+      int j = this.vertexFormat.getSize() >> 2;
+      this.rawIntBuffer.put(i, p_178962_1_);
+      this.rawIntBuffer.put(i + j, p_178962_2_);
+      this.rawIntBuffer.put(i + j * 2, p_178962_3_);
+      this.rawIntBuffer.put(i + j * 3, p_178962_4_);
    }
 
-   public void putPosition(double var1, double var3, double var5) {
-      int ☃ = this.vertexFormat.getIntegerSize();
-      int ☃x = (this.vertexCount - 4) * ☃;
+   public void putPosition(double x, double y, double z) {
+      int i = this.vertexFormat.getIntegerSize();
+      int j = (this.vertexCount - 4) * i;
 
-      for (int ☃xx = 0; ☃xx < 4; ☃xx++) {
-         int ☃xxx = ☃x + ☃xx * ☃;
-         int ☃xxxx = ☃xxx + 1;
-         int ☃xxxxx = ☃xxxx + 1;
-         this.rawIntBuffer.put(☃xxx, Float.floatToRawIntBits((float)(☃ + this.xOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(☃xxx))));
-         this.rawIntBuffer.put(☃xxxx, Float.floatToRawIntBits((float)(☃ + this.yOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(☃xxxx))));
-         this.rawIntBuffer.put(☃xxxxx, Float.floatToRawIntBits((float)(☃ + this.zOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(☃xxxxx))));
+      for (int k = 0; k < 4; k++) {
+         int l = j + k * i;
+         int i1 = l + 1;
+         int j1 = i1 + 1;
+         this.rawIntBuffer.put(l, Float.floatToRawIntBits((float)(x + this.xOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(l))));
+         this.rawIntBuffer.put(i1, Float.floatToRawIntBits((float)(y + this.yOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(i1))));
+         this.rawIntBuffer.put(j1, Float.floatToRawIntBits((float)(z + this.zOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(j1))));
       }
    }
 
-   private int getColorIndex(int var1) {
-      return ((this.vertexCount - ☃) * this.vertexFormat.getSize() + this.vertexFormat.getColorOffset()) / 4;
+   public int getColorIndex(int vertexIndex) {
+      return ((this.vertexCount - vertexIndex) * this.vertexFormat.getSize() + this.vertexFormat.getColorOffset()) / 4;
    }
 
-   public void putColorMultiplier(float var1, float var2, float var3, int var4) {
-      int ☃ = this.getColorIndex(☃);
-      int ☃x = -1;
+   public void putColorMultiplier(float red, float green, float blue, int vertexIndex) {
+      int i = this.getColorIndex(vertexIndex);
+      int j = -1;
       if (!this.noColor) {
-         ☃x = this.rawIntBuffer.get(☃);
+         j = this.rawIntBuffer.get(i);
          if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
-            int ☃xx = (int)((☃x & 0xFF) * ☃);
-            int ☃xxx = (int)((☃x >> 8 & 0xFF) * ☃);
-            int ☃xxxx = (int)((☃x >> 16 & 0xFF) * ☃);
-            ☃x &= -16777216;
-            ☃x |= ☃xxxx << 16 | ☃xxx << 8 | ☃xx;
+            int k = (int)((j & 0xFF) * red);
+            int l = (int)((j >> 8 & 0xFF) * green);
+            int i1 = (int)((j >> 16 & 0xFF) * blue);
+            j &= -16777216;
+            j = j | i1 << 16 | l << 8 | k;
          } else {
-            int ☃xx = (int)((☃x >> 24 & 0xFF) * ☃);
-            int ☃xxx = (int)((☃x >> 16 & 0xFF) * ☃);
-            int ☃xxxx = (int)((☃x >> 8 & 0xFF) * ☃);
-            ☃x &= 255;
-            ☃x |= ☃xx << 24 | ☃xxx << 16 | ☃xxxx << 8;
+            int j1 = (int)((j >> 24 & 0xFF) * red);
+            int k1 = (int)((j >> 16 & 0xFF) * green);
+            int l1 = (int)((j >> 8 & 0xFF) * blue);
+            j &= 255;
+            j = j | j1 << 24 | k1 << 16 | l1 << 8;
          }
       }
 
-      this.rawIntBuffer.put(☃, ☃x);
+      this.rawIntBuffer.put(i, j);
    }
 
-   private void putColor(int var1, int var2) {
-      int ☃ = this.getColorIndex(☃);
-      int ☃x = ☃ >> 16 & 0xFF;
-      int ☃xx = ☃ >> 8 & 0xFF;
-      int ☃xxx = ☃ & 0xFF;
-      this.putColorRGBA(☃, ☃x, ☃xx, ☃xxx);
+   private void putColor(int argb, int vertexIndex) {
+      int i = this.getColorIndex(vertexIndex);
+      int j = argb >> 16 & 0xFF;
+      int k = argb >> 8 & 0xFF;
+      int l = argb & 0xFF;
+      this.putColorRGBA(i, j, k, l);
    }
 
-   public void putColorRGB_F(float var1, float var2, float var3, int var4) {
-      int ☃ = this.getColorIndex(☃);
-      int ☃x = MathHelper.clamp((int)(☃ * 255.0F), 0, 255);
-      int ☃xx = MathHelper.clamp((int)(☃ * 255.0F), 0, 255);
-      int ☃xxx = MathHelper.clamp((int)(☃ * 255.0F), 0, 255);
-      this.putColorRGBA(☃, ☃x, ☃xx, ☃xxx);
+   public void putColorRGB_F(float red, float green, float blue, int vertexIndex) {
+      int i = this.getColorIndex(vertexIndex);
+      int j = MathHelper.clamp((int)(red * 255.0F), 0, 255);
+      int k = MathHelper.clamp((int)(green * 255.0F), 0, 255);
+      int l = MathHelper.clamp((int)(blue * 255.0F), 0, 255);
+      this.putColorRGBA(i, j, k, l);
    }
 
-   private void putColorRGBA(int var1, int var2, int var3, int var4) {
+   public void putColorRGBA(int index, int red, int green, int blue) {
       if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
-         this.rawIntBuffer.put(☃, 0xFF000000 | ☃ << 16 | ☃ << 8 | ☃);
+         this.rawIntBuffer.put(index, 0xFF000000 | blue << 16 | green << 8 | red);
       } else {
-         this.rawIntBuffer.put(☃, ☃ << 24 | ☃ << 16 | ☃ << 8 | 0xFF);
+         this.rawIntBuffer.put(index, red << 24 | green << 16 | blue << 8 | 0xFF);
       }
    }
 
@@ -311,48 +419,48 @@ public void noColor() {
       this.noColor = true;
    }
 
-   public BufferBuilder color(float var1, float var2, float var3, float var4) {
-      return this.color((int)(☃ * 255.0F), (int)(☃ * 255.0F), (int)(☃ * 255.0F), (int)(☃ * 255.0F));
+   public BufferBuilder color(float red, float green, float blue, float alpha) {
+      return this.color((int)(red * 255.0F), (int)(green * 255.0F), (int)(blue * 255.0F), (int)(alpha * 255.0F));
    }
 
-   public BufferBuilder color(int var1, int var2, int var3, int var4) {
+   public BufferBuilder color(int red, int green, int blue, int alpha) {
       if (this.noColor) {
          return this;
       } else {
-         int ☃ = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
+         int i = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
          switch (this.vertexFormatElement.getType()) {
             case FLOAT:
-               this.byteBuffer.putFloat(☃, ☃ / 255.0F);
-               this.byteBuffer.putFloat(☃ + 4, ☃ / 255.0F);
-               this.byteBuffer.putFloat(☃ + 8, ☃ / 255.0F);
-               this.byteBuffer.putFloat(☃ + 12, ☃ / 255.0F);
+               this.byteBuffer.putFloat(i, red / 255.0F);
+               this.byteBuffer.putFloat(i + 4, green / 255.0F);
+               this.byteBuffer.putFloat(i + 8, blue / 255.0F);
+               this.byteBuffer.putFloat(i + 12, alpha / 255.0F);
                break;
             case UINT:
             case INT:
-               this.byteBuffer.putFloat(☃, ☃);
-               this.byteBuffer.putFloat(☃ + 4, ☃);
-               this.byteBuffer.putFloat(☃ + 8, ☃);
-               this.byteBuffer.putFloat(☃ + 12, ☃);
+               this.byteBuffer.putFloat(i, red);
+               this.byteBuffer.putFloat(i + 4, green);
+               this.byteBuffer.putFloat(i + 8, blue);
+               this.byteBuffer.putFloat(i + 12, alpha);
                break;
             case USHORT:
             case SHORT:
-               this.byteBuffer.putShort(☃, (short)☃);
-               this.byteBuffer.putShort(☃ + 2, (short)☃);
-               this.byteBuffer.putShort(☃ + 4, (short)☃);
-               this.byteBuffer.putShort(☃ + 6, (short)☃);
+               this.byteBuffer.putShort(i, (short)red);
+               this.byteBuffer.putShort(i + 2, (short)green);
+               this.byteBuffer.putShort(i + 4, (short)blue);
+               this.byteBuffer.putShort(i + 6, (short)alpha);
                break;
             case UBYTE:
             case BYTE:
                if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
-                  this.byteBuffer.put(☃, (byte)☃);
-                  this.byteBuffer.put(☃ + 1, (byte)☃);
-                  this.byteBuffer.put(☃ + 2, (byte)☃);
-                  this.byteBuffer.put(☃ + 3, (byte)☃);
+                  this.byteBuffer.put(i, (byte)red);
+                  this.byteBuffer.put(i + 1, (byte)green);
+                  this.byteBuffer.put(i + 2, (byte)blue);
+                  this.byteBuffer.put(i + 3, (byte)alpha);
                } else {
-                  this.byteBuffer.put(☃, (byte)☃);
-                  this.byteBuffer.put(☃ + 1, (byte)☃);
-                  this.byteBuffer.put(☃ + 2, (byte)☃);
-                  this.byteBuffer.put(☃ + 3, (byte)☃);
+                  this.byteBuffer.put(i, (byte)alpha);
+                  this.byteBuffer.put(i + 1, (byte)blue);
+                  this.byteBuffer.put(i + 2, (byte)green);
+                  this.byteBuffer.put(i + 3, (byte)red);
                }
          }
 
@@ -361,106 +469,122 @@ public BufferBuilder color(int var1, int var2, int var3, int var4) {
       }
    }
 
-   public void addVertexData(int[] var1) {
-      this.growBuffer(☃.length * 4);
+   public void addVertexData(int[] vertexData) {
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertexData(this, vertexData);
+      }
+
+      this.growBuffer(vertexData.length * 4 + this.vertexFormat.getSize());
       ((Buffer)this.rawIntBuffer).position(this.getBufferSize());
-      this.rawIntBuffer.put(☃);
-      this.vertexCount = this.vertexCount + ☃.length / this.vertexFormat.getIntegerSize();
+      this.rawIntBuffer.put(vertexData);
+      this.vertexCount = this.vertexCount + vertexData.length / this.vertexFormat.getIntegerSize();
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertexData(this);
+      }
    }
 
    public void endVertex() {
       this.vertexCount++;
       this.growBuffer(this.vertexFormat.getSize());
+      this.vertexFormatIndex = 0;
+      this.vertexFormatElement = this.vertexFormat.getElement(this.vertexFormatIndex);
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertex(this);
+      }
    }
 
-   public BufferBuilder pos(double var1, double var3, double var5) {
-      int ☃ = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
+   public BufferBuilder pos(double x, double y, double z) {
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertex(this);
+      }
+
+      int i = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
-            this.byteBuffer.putFloat(☃, (float)(☃ + this.xOffset));
-            this.byteBuffer.putFloat(☃ + 4, (float)(☃ + this.yOffset));
-            this.byteBuffer.putFloat(☃ + 8, (float)(☃ + this.zOffset));
+            this.byteBuffer.putFloat(i, (float)(x + this.xOffset));
+            this.byteBuffer.putFloat(i + 4, (float)(y + this.yOffset));
+            this.byteBuffer.putFloat(i + 8, (float)(z + this.zOffset));
             break;
          case UINT:
          case INT:
-            this.byteBuffer.putInt(☃, Float.floatToRawIntBits((float)(☃ + this.xOffset)));
-            this.byteBuffer.putInt(☃ + 4, Float.floatToRawIntBits((float)(☃ + this.yOffset)));
-            this.byteBuffer.putInt(☃ + 8, Float.floatToRawIntBits((float)(☃ + this.zOffset)));
+            this.byteBuffer.putInt(i, Float.floatToRawIntBits((float)(x + this.xOffset)));
+            this.byteBuffer.putInt(i + 4, Float.floatToRawIntBits((float)(y + this.yOffset)));
+            this.byteBuffer.putInt(i + 8, Float.floatToRawIntBits((float)(z + this.zOffset)));
             break;
          case USHORT:
          case SHORT:
-            this.byteBuffer.putShort(☃, (short)(☃ + this.xOffset));
-            this.byteBuffer.putShort(☃ + 2, (short)(☃ + this.yOffset));
-            this.byteBuffer.putShort(☃ + 4, (short)(☃ + this.zOffset));
+            this.byteBuffer.putShort(i, (short)(x + this.xOffset));
+            this.byteBuffer.putShort(i + 2, (short)(y + this.yOffset));
+            this.byteBuffer.putShort(i + 4, (short)(z + this.zOffset));
             break;
          case UBYTE:
          case BYTE:
-            this.byteBuffer.put(☃, (byte)(☃ + this.xOffset));
-            this.byteBuffer.put(☃ + 1, (byte)(☃ + this.yOffset));
-            this.byteBuffer.put(☃ + 2, (byte)(☃ + this.zOffset));
+            this.byteBuffer.put(i, (byte)(x + this.xOffset));
+            this.byteBuffer.put(i + 1, (byte)(y + this.yOffset));
+            this.byteBuffer.put(i + 2, (byte)(z + this.zOffset));
       }
 
       this.nextVertexFormatIndex();
       return this;
    }
 
-   public void putNormal(float var1, float var2, float var3) {
-      int ☃ = (byte)(☃ * 127.0F) & 255;
-      int ☃x = (byte)(☃ * 127.0F) & 255;
-      int ☃xx = (byte)(☃ * 127.0F) & 255;
-      int ☃xxx = ☃ | ☃x << 8 | ☃xx << 16;
-      int ☃xxxx = this.vertexFormat.getSize() >> 2;
-      int ☃xxxxx = (this.vertexCount - 4) * ☃xxxx + this.vertexFormat.getNormalOffset() / 4;
-      this.rawIntBuffer.put(☃xxxxx, ☃xxx);
-      this.rawIntBuffer.put(☃xxxxx + ☃xxxx, ☃xxx);
-      this.rawIntBuffer.put(☃xxxxx + ☃xxxx * 2, ☃xxx);
-      this.rawIntBuffer.put(☃xxxxx + ☃xxxx * 3, ☃xxx);
+   public void putNormal(float x, float y, float z) {
+      int i = (byte)(x * 127.0F) & 255;
+      int j = (byte)(y * 127.0F) & 255;
+      int k = (byte)(z * 127.0F) & 255;
+      int l = i | j << 8 | k << 16;
+      int i1 = this.vertexFormat.getSize() >> 2;
+      int j1 = (this.vertexCount - 4) * i1 + this.vertexFormat.getNormalOffset() / 4;
+      this.rawIntBuffer.put(j1, l);
+      this.rawIntBuffer.put(j1 + i1, l);
+      this.rawIntBuffer.put(j1 + i1 * 2, l);
+      this.rawIntBuffer.put(j1 + i1 * 3, l);
    }
 
    private void nextVertexFormatIndex() {
       this.vertexFormatIndex++;
       this.vertexFormatIndex = this.vertexFormatIndex % this.vertexFormat.getElementCount();
       this.vertexFormatElement = this.vertexFormat.getElement(this.vertexFormatIndex);
-      if (this.vertexFormatElement.getUsage() == VertexFormatElement.EnumUsage.PADDING) {
+      if (this.vertexFormatElement.getUsage() == EnumUsage.PADDING) {
          this.nextVertexFormatIndex();
       }
    }
 
-   public BufferBuilder normal(float var1, float var2, float var3) {
-      int ☃ = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
+   public BufferBuilder normal(float x, float y, float z) {
+      int i = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
-            this.byteBuffer.putFloat(☃, ☃);
-            this.byteBuffer.putFloat(☃ + 4, ☃);
-            this.byteBuffer.putFloat(☃ + 8, ☃);
+            this.byteBuffer.putFloat(i, x);
+            this.byteBuffer.putFloat(i + 4, y);
+            this.byteBuffer.putFloat(i + 8, z);
             break;
          case UINT:
          case INT:
-            this.byteBuffer.putInt(☃, (int)☃);
-            this.byteBuffer.putInt(☃ + 4, (int)☃);
-            this.byteBuffer.putInt(☃ + 8, (int)☃);
+            this.byteBuffer.putInt(i, (int)x);
+            this.byteBuffer.putInt(i + 4, (int)y);
+            this.byteBuffer.putInt(i + 8, (int)z);
             break;
          case USHORT:
          case SHORT:
-            this.byteBuffer.putShort(☃, (short)((int)☃ * 32767 & 65535));
-            this.byteBuffer.putShort(☃ + 2, (short)((int)☃ * 32767 & 65535));
-            this.byteBuffer.putShort(☃ + 4, (short)((int)☃ * 32767 & 65535));
+            this.byteBuffer.putShort(i, (short)((int)(x * 32767.0F) & 65535));
+            this.byteBuffer.putShort(i + 2, (short)((int)(y * 32767.0F) & 65535));
+            this.byteBuffer.putShort(i + 4, (short)((int)(z * 32767.0F) & 65535));
             break;
          case UBYTE:
          case BYTE:
-            this.byteBuffer.put(☃, (byte)((int)☃ * 127 & 0xFF));
-            this.byteBuffer.put(☃ + 1, (byte)((int)☃ * 127 & 0xFF));
-            this.byteBuffer.put(☃ + 2, (byte)((int)☃ * 127 & 0xFF));
+            this.byteBuffer.put(i, (byte)((int)(x * 127.0F) & 0xFF));
+            this.byteBuffer.put(i + 1, (byte)((int)(y * 127.0F) & 0xFF));
+            this.byteBuffer.put(i + 2, (byte)((int)(z * 127.0F) & 0xFF));
       }
 
       this.nextVertexFormatIndex();
       return this;
    }
 
-   public void setTranslation(double var1, double var3, double var5) {
-      this.xOffset = ☃;
-      this.yOffset = ☃;
-      this.zOffset = ☃;
+   public void setTranslation(double x, double y, double z) {
+      this.xOffset = x;
+      this.yOffset = y;
+      this.zOffset = z;
    }
 
    public void finishDrawing() {
@@ -474,7 +598,7 @@ public void finishDrawing() {
    }
 
    public ByteBuffer getByteBuffer() {
-      return this.byteBuffer;
+      return this.modeTriangles ? this.byteBufferTriangles : this.byteBuffer;
    }
 
    public VertexFormat getVertexFormat() {
@@ -482,32 +606,280 @@ public VertexFormat getVertexFormat() {
    }
 
    public int getVertexCount() {
-      return this.vertexCount;
+      return this.modeTriangles ? this.vertexCount / 4 * 6 : this.vertexCount;
    }
 
    public int getDrawMode() {
-      return this.drawMode;
+      return this.modeTriangles ? 4 : this.drawMode;
+   }
+
+   public void putColor4(int argb) {
+      for (int i = 0; i < 4; i++) {
+         this.putColor(argb, i + 1);
+      }
+   }
+
+   public void putColorRGB_F4(float red, float green, float blue) {
+      for (int i = 0; i < 4; i++) {
+         this.putColorRGB_F(red, green, blue, i + 1);
+      }
+   }
+
+   public void putSprite(TextureAtlasSprite sprite) {
+      if (this.animatedSprites != null && sprite != null && sprite.getAnimationIndex() >= 0) {
+         this.animatedSprites.set(sprite.getAnimationIndex());
+      }
+
+      if (this.quadSprites != null) {
+         int countQuads = this.vertexCount / 4;
+         this.quadSprites[countQuads - 1] = sprite;
+      }
+   }
+
+   public void setSprite(TextureAtlasSprite sprite) {
+      if (this.animatedSprites != null && sprite != null && sprite.getAnimationIndex() >= 0) {
+         this.animatedSprites.set(sprite.getAnimationIndex());
+      }
+
+      if (this.quadSprites != null) {
+         this.quadSprite = sprite;
+      }
+   }
+
+   public boolean isMultiTexture() {
+      return this.quadSprites != null;
+   }
+
+   public void drawMultiTexture() {
+      if (this.quadSprites != null) {
+         int maxTextureIndex = Config.getMinecraft().getTextureMapBlocks().getCountRegisteredSprites();
+         if (this.drawnIcons.length <= maxTextureIndex) {
+            this.drawnIcons = new boolean[maxTextureIndex + 1];
+         }
+
+         Arrays.fill(this.drawnIcons, false);
+         int texSwitch = 0;
+         int grassOverlayIndex = -1;
+         int countQuads = this.vertexCount / 4;
+
+         for (int i = 0; i < countQuads; i++) {
+            TextureAtlasSprite icon = this.quadSprites[i];
+            if (icon != null) {
+               int iconIndex = icon.getIndexInMap();
+               if (!this.drawnIcons[iconIndex]) {
+                  if (icon == TextureUtils.iconGrassSideOverlay) {
+                     if (grassOverlayIndex < 0) {
+                        grassOverlayIndex = i;
+                     }
+                  } else {
+                     i = this.drawForIcon(icon, i) - 1;
+                     texSwitch++;
+                     if (this.blockLayer != BlockRenderLayer.TRANSLUCENT) {
+                        this.drawnIcons[iconIndex] = true;
+                     }
+                  }
+               }
+            }
+         }
+
+         if (grassOverlayIndex >= 0) {
+            this.drawForIcon(TextureUtils.iconGrassSideOverlay, grassOverlayIndex);
+            texSwitch++;
+         }
+
+         if (texSwitch > 0) {
+         }
+      }
+   }
+
+   private int drawForIcon(TextureAtlasSprite sprite, int startQuadPos) {
+      GL11.glBindTexture(3553, sprite.glSpriteTextureId);
+      int firstRegionEnd = -1;
+      int lastPos = -1;
+      int countQuads = this.vertexCount / 4;
+
+      for (int i = startQuadPos; i < countQuads; i++) {
+         TextureAtlasSprite ts = this.quadSprites[i];
+         if (ts == sprite) {
+            if (lastPos < 0) {
+               lastPos = i;
+            }
+         } else if (lastPos >= 0) {
+            this.draw(lastPos, i);
+            if (this.blockLayer == BlockRenderLayer.TRANSLUCENT) {
+               return i;
+            }
+
+            lastPos = -1;
+            if (firstRegionEnd < 0) {
+               firstRegionEnd = i;
+            }
+         }
+      }
+
+      if (lastPos >= 0) {
+         this.draw(lastPos, countQuads);
+      }
+
+      if (firstRegionEnd < 0) {
+         firstRegionEnd = countQuads;
+      }
+
+      return firstRegionEnd;
+   }
+
+   private void draw(int startQuadVertex, int endQuadVertex) {
+      int vxQuadCount = endQuadVertex - startQuadVertex;
+      if (vxQuadCount > 0) {
+         int startVertex = startQuadVertex * 4;
+         int vxCount = vxQuadCount * 4;
+         GL11.glDrawArrays(this.drawMode, startVertex, vxCount);
+      }
+   }
+
+   public void setBlockLayer(BlockRenderLayer blockLayer) {
+      this.blockLayer = blockLayer;
+      if (blockLayer == null) {
+         if (this.quadSprites != null) {
+            this.quadSpritesPrev = this.quadSprites;
+         }
+
+         this.quadSprites = null;
+         this.quadSprite = null;
+      }
+   }
+
+   private int getBufferQuadSize() {
+      return this.rawIntBuffer.capacity() * 4 / (this.vertexFormat.getIntegerSize() * 4);
+   }
+
+   public RenderEnv getRenderEnv(IBlockState blockStateIn, BlockPos blockPosIn) {
+      if (this.renderEnv == null) {
+         this.renderEnv = new RenderEnv(blockStateIn, blockPosIn);
+         return this.renderEnv;
+      } else {
+         this.renderEnv.reset(blockStateIn, blockPosIn);
+         return this.renderEnv;
+      }
+   }
+
+   public boolean isDrawing() {
+      return this.isDrawing;
+   }
+
+   public double getXOffset() {
+      return this.xOffset;
+   }
+
+   public double getYOffset() {
+      return this.yOffset;
+   }
+
+   public double getZOffset() {
+      return this.zOffset;
+   }
+
+   public BlockRenderLayer getBlockLayer() {
+      return this.blockLayer;
+   }
+
+   public void putColorMultiplierRgba(float red, float green, float blue, float alpha, int vertexIndex) {
+      int index = this.getColorIndex(vertexIndex);
+      int col = -1;
+      if (!this.noColor) {
+         col = this.rawIntBuffer.get(index);
+         if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+            int r = (int)((col & 0xFF) * red);
+            int g = (int)((col >> 8 & 0xFF) * green);
+            int b = (int)((col >> 16 & 0xFF) * blue);
+            int a = (int)((col >> 24 & 0xFF) * alpha);
+            col = a << 24 | b << 16 | g << 8 | r;
+         } else {
+            int r = (int)((col >> 24 & 0xFF) * red);
+            int g = (int)((col >> 16 & 0xFF) * green);
+            int b = (int)((col >> 8 & 0xFF) * blue);
+            int a = (int)((col & 0xFF) * alpha);
+            col = r << 24 | g << 16 | b << 8 | a;
+         }
+      }
+
+      this.rawIntBuffer.put(index, col);
    }
 
-   public void putColor4(int var1) {
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         this.putColor(☃, ☃ + 1);
+   public void quadsToTriangles() {
+      if (this.drawMode == 7) {
+         if (this.byteBufferTriangles == null) {
+            this.byteBufferTriangles = GLAllocation.createDirectByteBuffer(this.byteBuffer.capacity() * 2);
+         }
+
+         if (this.byteBufferTriangles.capacity() < this.byteBuffer.capacity() * 2) {
+            this.byteBufferTriangles = GLAllocation.createDirectByteBuffer(this.byteBuffer.capacity() * 2);
+         }
+
+         int vertexSize = this.vertexFormat.getSize();
+         int limit = this.byteBuffer.limit();
+         ((Buffer)this.byteBuffer).rewind();
+         ((Buffer)this.byteBufferTriangles).clear();
+
+         for (int v = 0; v < this.vertexCount; v += 4) {
+            ((Buffer)this.byteBuffer).limit((v + 3) * vertexSize);
+            ((Buffer)this.byteBuffer).position(v * vertexSize);
+            this.byteBufferTriangles.put(this.byteBuffer);
+            ((Buffer)this.byteBuffer).limit((v + 1) * vertexSize);
+            ((Buffer)this.byteBuffer).position(v * vertexSize);
+            this.byteBufferTriangles.put(this.byteBuffer);
+            ((Buffer)this.byteBuffer).limit((v + 2 + 2) * vertexSize);
+            ((Buffer)this.byteBuffer).position((v + 2) * vertexSize);
+            this.byteBufferTriangles.put(this.byteBuffer);
+         }
+
+         ((Buffer)this.byteBuffer).limit(limit);
+         ((Buffer)this.byteBuffer).rewind();
+         ((Buffer)this.byteBufferTriangles).flip();
+         this.modeTriangles = true;
       }
    }
 
-   public void putColorRGB_F4(float var1, float var2, float var3) {
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         this.putColorRGB_F(☃, ☃, ☃, ☃ + 1);
+   public void putColorRGBA(int index, int red, int green, int blue, int alpha) {
+      if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+         this.rawIntBuffer.put(index, alpha << 24 | blue << 16 | green << 8 | red);
+      } else {
+         this.rawIntBuffer.put(index, red << 24 | green << 16 | blue << 8 | alpha);
+      }
+   }
+
+   public boolean isColorDisabled() {
+      return this.noColor;
+   }
+
+   public void putBulkData(ByteBuffer buffer) {
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertexData(this, buffer);
+      }
+
+      this.growBuffer(buffer.limit() + this.vertexFormat.getSize());
+      ((Buffer)this.byteBuffer).position(this.vertexCount * this.vertexFormat.getSize());
+      this.byteBuffer.put(buffer);
+      this.vertexCount = this.vertexCount + buffer.limit() / this.vertexFormat.getSize();
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertexData(this);
       }
    }
 
    public class State {
       private final int[] stateRawBuffer;
       private final VertexFormat stateVertexFormat;
+      private TextureAtlasSprite[] stateQuadSprites;
+
+      public State(int[] buffer, VertexFormat format, TextureAtlasSprite[] quadSprites) {
+         this.stateRawBuffer = buffer;
+         this.stateVertexFormat = format;
+         this.stateQuadSprites = quadSprites;
+      }
 
-      public State(int[] var2, VertexFormat var3) {
-         this.stateRawBuffer = ☃;
-         this.stateVertexFormat = ☃;
+      public State(int[] buffer, VertexFormat format) {
+         this.stateRawBuffer = buffer;
+         this.stateVertexFormat = format;
       }
 
       public int[] getRawBuffer() {
diff --git a/patches/net/minecraft/client/renderer/ChunkRenderContainer.java b/patches/net/minecraft/client/renderer/ChunkRenderContainer.java
index f2ae45e..b840965 100644
--- a/patches/net/minecraft/client/renderer/ChunkRenderContainer.java
+++ b/patches/net/minecraft/client/renderer/ChunkRenderContainer.java
@@ -1,10 +1,12 @@
 package net.minecraft.client.renderer;
 
 import com.google.common.collect.Lists;
+import java.util.BitSet;
 import java.util.List;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.math.BlockPos;
+import net.optifine.SmartAnimations;
 
 public abstract class ChunkRenderContainer {
    private double viewEntityX;
@@ -12,22 +14,44 @@ public abstract class ChunkRenderContainer {
    private double viewEntityZ;
    protected List<RenderChunk> renderChunks = Lists.newArrayListWithCapacity(17424);
    protected boolean initialized;
+   private BitSet animatedSpritesRendered;
+   private final BitSet animatedSpritesCached = new BitSet();
 
-   public void initialize(double var1, double var3, double var5) {
+   public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
       this.initialized = true;
       this.renderChunks.clear();
-      this.viewEntityX = ☃;
-      this.viewEntityY = ☃;
-      this.viewEntityZ = ☃;
+      this.viewEntityX = viewEntityXIn;
+      this.viewEntityY = viewEntityYIn;
+      this.viewEntityZ = viewEntityZIn;
+      if (SmartAnimations.isActive()) {
+         if (this.animatedSpritesRendered != null) {
+            SmartAnimations.spritesRendered(this.animatedSpritesRendered);
+         } else {
+            this.animatedSpritesRendered = this.animatedSpritesCached;
+         }
+
+         this.animatedSpritesRendered.clear();
+      } else if (this.animatedSpritesRendered != null) {
+         SmartAnimations.spritesRendered(this.animatedSpritesRendered);
+         this.animatedSpritesRendered = null;
+      }
    }
 
-   public void preRenderChunk(RenderChunk var1) {
-      BlockPos ☃ = ☃.getPosition();
-      GlStateManager.translate((float)(☃.getX() - this.viewEntityX), (float)(☃.getY() - this.viewEntityY), (float)(☃.getZ() - this.viewEntityZ));
+   public void preRenderChunk(RenderChunk renderChunkIn) {
+      BlockPos blockpos = renderChunkIn.getPosition();
+      GlStateManager.translate(
+         (float)(blockpos.getX() - this.viewEntityX), (float)(blockpos.getY() - this.viewEntityY), (float)(blockpos.getZ() - this.viewEntityZ)
+      );
    }
 
-   public void addRenderChunk(RenderChunk var1, BlockRenderLayer var2) {
-      this.renderChunks.add(☃);
+   public void addRenderChunk(RenderChunk renderChunkIn, BlockRenderLayer layer) {
+      this.renderChunks.add(renderChunkIn);
+      if (this.animatedSpritesRendered != null) {
+         BitSet animatedSprites = renderChunkIn.compiledChunk.getAnimatedSprites(layer);
+         if (animatedSprites != null) {
+            this.animatedSpritesRendered.or(animatedSprites);
+         }
+      }
    }
 
    public abstract void renderChunkLayer(BlockRenderLayer var1);
diff --git a/patches/net/minecraft/client/renderer/EntityRenderer.java b/patches/net/minecraft/client/renderer/EntityRenderer.java
index 3624094..453da2b 100644
--- a/patches/net/minecraft/client/renderer/EntityRenderer.java
+++ b/patches/net/minecraft/client/renderer/EntityRenderer.java
@@ -5,9 +5,12 @@
 import com.google.gson.JsonSyntaxException;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.nio.Buffer;
 import java.nio.FloatBuffer;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
@@ -19,18 +22,27 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.gui.GuiChat;
+import net.minecraft.client.gui.GuiDownloadTerrain;
+import net.minecraft.client.gui.GuiMainMenu;
 import net.minecraft.client.gui.MapItemRenderer;
 import net.minecraft.client.gui.ScaledResolution;
+import net.minecraft.client.gui.advancements.GuiScreenAdvancements;
 import net.minecraft.client.particle.ParticleManager;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
+import net.minecraft.client.renderer.chunk.RenderChunk;
+import net.minecraft.client.renderer.culling.ClippingHelper;
 import net.minecraft.client.renderer.culling.ClippingHelperImpl;
 import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.client.renderer.culling.ICamera;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.client.resources.I18n;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
+import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
@@ -50,8 +62,10 @@
 import net.minecraft.init.SoundEvents;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.item.ItemStack;
+import net.minecraft.server.integrated.IntegratedServer;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EntitySelectors;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.MouseFilter;
 import net.minecraft.util.ReportedException;
@@ -63,13 +77,35 @@
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
+import net.minecraft.util.math.RayTraceResult.Type;
+import net.minecraft.util.text.Style;
+import net.minecraft.util.text.TextComponentString;
+import net.minecraft.util.text.event.ClickEvent;
+import net.minecraft.util.text.event.ClickEvent.Action;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.biome.Biome;
+import net.optifine.CustomColors;
+import net.optifine.GlErrors;
+import net.optifine.Lagometer;
+import net.optifine.RandomEntities;
+import net.optifine.gui.GuiChatOF;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.reflect.ReflectorResolver;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
+import net.optifine.util.MemoryMonitor;
+import net.optifine.util.TextureUtils;
+import net.optifine.util.TimedEvent;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.Project;
 
@@ -83,12 +119,12 @@ public class EntityRenderer implements IResourceManagerReloadListener {
    private final IResourceManager resourceManager;
    private final Random random = new Random();
    private float farPlaneDistance;
-   public final ItemRenderer itemRenderer;
+   public ItemRenderer itemRenderer;
    private final MapItemRenderer mapItemRenderer;
    private int rendererUpdateCount;
    private Entity pointedEntity;
-   private final MouseFilter mouseFilterXAxis = new MouseFilter();
-   private final MouseFilter mouseFilterYAxis = new MouseFilter();
+   private MouseFilter mouseFilterXAxis = new MouseFilter();
+   private MouseFilter mouseFilterYAxis = new MouseFilter();
    private final float thirdPersonDistance = 4.0F;
    private float thirdPersonDistancePrev = 4.0F;
    private float smoothCamYaw;
@@ -116,9 +152,9 @@ public class EntityRenderer implements IResourceManagerReloadListener {
    private final float[] rainXCoords = new float[1024];
    private final float[] rainYCoords = new float[1024];
    private final FloatBuffer fogColorBuffer = GLAllocation.createDirectFloatBuffer(16);
-   private float fogColorRed;
-   private float fogColorGreen;
-   private float fogColorBlue;
+   public float fogColorRed;
+   public float fogColorGreen;
+   public float fogColorBlue;
    private float fogColor2;
    private float fogColor1;
    private int debugViewDirection;
@@ -158,27 +194,40 @@ public class EntityRenderer implements IResourceManagerReloadListener {
       new ResourceLocation("shaders/post/spider.json")
    };
    public static final int SHADER_COUNT = SHADERS_TEXTURES.length;
-   private int shaderIndex = SHADER_COUNT;
+   private int shaderIndex;
    private boolean useShader;
-   private int frameCount;
-
-   public EntityRenderer(Minecraft var1, IResourceManager var2) {
-      this.mc = ☃;
-      this.resourceManager = ☃;
-      this.itemRenderer = ☃.getItemRenderer();
-      this.mapItemRenderer = new MapItemRenderer(☃.getTextureManager());
+   public int frameCount;
+   private boolean initialized = false;
+   private World updatedWorld = null;
+   public boolean fogStandard = false;
+   private float clipDistance = 128.0F;
+   private long lastServerTime = 0L;
+   private int lastServerTicks = 0;
+   private int serverWaitTime = 0;
+   private int serverWaitTimeCurrent = 0;
+   private float avgServerTimeDiff = 0.0F;
+   private float avgServerTickDiff = 0.0F;
+   private ShaderGroup[] fxaaShaders = new ShaderGroup[10];
+   private boolean loadVisibleChunks = false;
+
+   public EntityRenderer(Minecraft mcIn, IResourceManager resourceManagerIn) {
+      this.shaderIndex = SHADER_COUNT;
+      this.mc = mcIn;
+      this.resourceManager = resourceManagerIn;
+      this.itemRenderer = mcIn.getItemRenderer();
+      this.mapItemRenderer = new MapItemRenderer(mcIn.getTextureManager());
       this.lightmapTexture = new DynamicTexture(16, 16);
-      this.locationLightMap = ☃.getTextureManager().getDynamicTextureLocation("lightMap", this.lightmapTexture);
+      this.locationLightMap = mcIn.getTextureManager().getDynamicTextureLocation("lightMap", this.lightmapTexture);
       this.lightmapColors = this.lightmapTexture.getTextureData();
       this.shaderGroup = null;
 
-      for (int ☃ = 0; ☃ < 32; ☃++) {
-         for (int ☃x = 0; ☃x < 32; ☃x++) {
-            float ☃xx = ☃x - 16;
-            float ☃xxx = ☃ - 16;
-            float ☃xxxx = MathHelper.sqrt(☃xx * ☃xx + ☃xxx * ☃xxx);
-            this.rainXCoords[☃ << 5 | ☃x] = -☃xxx / ☃xxxx;
-            this.rainYCoords[☃ << 5 | ☃x] = ☃xx / ☃xxxx;
+      for (int i = 0; i < 32; i++) {
+         for (int j = 0; j < 32; j++) {
+            float f = j - 16;
+            float f1 = i - 16;
+            float f2 = MathHelper.sqrt(f * f + f1 * f1);
+            this.rainXCoords[i << 5 | j] = -f1 / f2;
+            this.rainYCoords[i << 5 | j] = f / f2;
          }
       }
    }
@@ -200,41 +249,44 @@ public void switchUseShader() {
       this.useShader = !this.useShader;
    }
 
-   public void loadEntityShader(@Nullable Entity var1) {
+   public void loadEntityShader(@Nullable Entity entityIn) {
       if (OpenGlHelper.shadersSupported) {
          if (this.shaderGroup != null) {
             this.shaderGroup.deleteShaderGroup();
          }
 
          this.shaderGroup = null;
-         if (☃ instanceof EntityCreeper) {
+         if (entityIn instanceof EntityCreeper) {
             this.loadShader(new ResourceLocation("shaders/post/creeper.json"));
-         } else if (☃ instanceof EntitySpider) {
+         } else if (entityIn instanceof EntitySpider) {
             this.loadShader(new ResourceLocation("shaders/post/spider.json"));
-         } else if (☃ instanceof EntityEnderman) {
+         } else if (entityIn instanceof EntityEnderman) {
             this.loadShader(new ResourceLocation("shaders/post/invert.json"));
+         } else if (Reflector.ForgeHooksClient_loadEntityShader.exists()) {
+            Reflector.call(Reflector.ForgeHooksClient_loadEntityShader, new Object[]{entityIn, this});
          }
       }
    }
 
-   private void loadShader(ResourceLocation var1) {
-      try {
-         this.shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), ☃);
-         this.shaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
-         this.useShader = true;
-      } catch (IOException var3) {
-         LOGGER.warn("Failed to load shader: {}", ☃, var3);
-         this.shaderIndex = SHADER_COUNT;
-         this.useShader = false;
-      } catch (JsonSyntaxException var4) {
-         LOGGER.warn("Failed to load shader: {}", ☃, var4);
-         this.shaderIndex = SHADER_COUNT;
-         this.useShader = false;
+   private void loadShader(ResourceLocation resourceLocationIn) {
+      if (OpenGlHelper.isFramebufferEnabled()) {
+         try {
+            this.shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), resourceLocationIn);
+            this.shaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
+            this.useShader = true;
+         } catch (IOException var3) {
+            LOGGER.warn("Failed to load shader: {}", resourceLocationIn, var3);
+            this.shaderIndex = SHADER_COUNT;
+            this.useShader = false;
+         } catch (JsonSyntaxException var4) {
+            LOGGER.warn("Failed to load shader: {}", resourceLocationIn, var4);
+            this.shaderIndex = SHADER_COUNT;
+            this.useShader = false;
+         }
       }
    }
 
-   @Override
-   public void onResourceManagerReload(IResourceManager var1) {
+   public void onResourceManagerReload(IResourceManager resourceManager) {
       if (this.shaderGroup != null) {
          this.shaderGroup.deleteShaderGroup();
       }
@@ -257,10 +309,10 @@ public void updateRenderer() {
       this.fogColor2 = this.fogColor1;
       this.thirdPersonDistancePrev = 4.0F;
       if (this.mc.gameSettings.smoothCamera) {
-         float ☃ = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-         float ☃x = ☃ * ☃ * ☃ * 8.0F;
-         this.smoothCamFilterX = this.mouseFilterXAxis.smooth(this.smoothCamYaw, 0.05F * ☃x);
-         this.smoothCamFilterY = this.mouseFilterYAxis.smooth(this.smoothCamPitch, 0.05F * ☃x);
+         float f = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+         float f1 = f * f * f * 8.0F;
+         this.smoothCamFilterX = this.mouseFilterXAxis.smooth(this.smoothCamYaw, 0.05F * f1);
+         this.smoothCamFilterY = this.mouseFilterYAxis.smooth(this.smoothCamPitch, 0.05F * f1);
          this.smoothCamPartialTicks = 0.0F;
          this.smoothCamYaw = 0.0F;
          this.smoothCamPitch = 0.0F;
@@ -275,10 +327,15 @@ public void updateRenderer() {
          this.mc.setRenderViewEntity(this.mc.player);
       }
 
-      float ☃ = this.mc.world.getLightBrightness(new BlockPos(this.mc.getRenderViewEntity()));
-      float ☃x = this.mc.gameSettings.renderDistanceChunks / 32.0F;
-      float ☃xx = ☃ * (1.0F - ☃x) + ☃x;
-      this.fogColor1 = this.fogColor1 + (☃xx - this.fogColor1) * 0.1F;
+      Entity viewEntity = this.mc.getRenderViewEntity();
+      double vx = viewEntity.posX;
+      double vy = viewEntity.posY + viewEntity.getEyeHeight();
+      double vz = viewEntity.posZ;
+      float f3 = this.mc.world.getLightBrightness(new BlockPos(vx, vy, vz));
+      float f4 = this.mc.gameSettings.renderDistanceChunks / 16.0F;
+      f4 = MathHelper.clamp(f4, 0.0F, 1.0F);
+      float f2 = f3 * (1.0F - f4) + f4;
+      this.fogColor1 = this.fogColor1 + (f2 - this.fogColor1) * 0.1F;
       this.rendererUpdateCount++;
       this.itemRenderer.updateEquippedItem();
       this.addRainParticles();
@@ -304,114 +361,111 @@ public ShaderGroup getShaderGroup() {
       return this.shaderGroup;
    }
 
-   public void updateShaderGroupSize(int var1, int var2) {
+   public void updateShaderGroupSize(int width, int height) {
       if (OpenGlHelper.shadersSupported) {
          if (this.shaderGroup != null) {
-            this.shaderGroup.createBindFramebuffers(☃, ☃);
+            this.shaderGroup.createBindFramebuffers(width, height);
          }
 
-         this.mc.renderGlobal.createBindEntityOutlineFbs(☃, ☃);
+         this.mc.renderGlobal.createBindEntityOutlineFbs(width, height);
       }
    }
 
-   public void getMouseOver(float var1) {
-      Entity ☃ = this.mc.getRenderViewEntity();
-      if (☃ != null) {
-         if (this.mc.world != null) {
-            this.mc.profiler.startSection("pick");
-            this.mc.pointedEntity = null;
-            double ☃x = this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = ☃.rayTrace(☃x, ☃);
-            Vec3d ☃xx = ☃.getPositionEyes(☃);
-            boolean ☃xxx = false;
-            int ☃xxxx = 3;
-            double ☃xxxxx = ☃x;
-            if (this.mc.playerController.extendedReach()) {
-               ☃xxxxx = 6.0;
-               ☃x = ☃xxxxx;
-            } else {
-               if (☃x > 3.0) {
-                  ☃xxx = true;
-               }
-
-               ☃x = ☃x;
-            }
+   public void getMouseOver(float partialTicks) {
+      Entity entity = this.mc.getRenderViewEntity();
+      if (entity != null && this.mc.world != null) {
+         this.mc.profiler.startSection("pick");
+         this.mc.pointedEntity = null;
+         double d0 = this.mc.playerController.getBlockReachDistance();
+         this.mc.objectMouseOver = entity.rayTrace(d0, partialTicks);
+         Vec3d vec3d = entity.getPositionEyes(partialTicks);
+         boolean flag = false;
+         int i = 3;
+         double d1 = d0;
+         if (this.mc.playerController.extendedReach()) {
+            d1 = 6.0;
+            d0 = d1;
+         } else if (d0 > 3.0) {
+            flag = true;
+         }
 
-            if (this.mc.objectMouseOver != null) {
-               ☃xxxxx = this.mc.objectMouseOver.hitVec.distanceTo(☃xx);
-            }
+         if (this.mc.objectMouseOver != null) {
+            d1 = this.mc.objectMouseOver.hitVec.distanceTo(vec3d);
+         }
 
-            Vec3d ☃xxxxxx = ☃.getLook(1.0F);
-            Vec3d ☃xxxxxxx = ☃xx.add(☃xxxxxx.x * ☃x, ☃xxxxxx.y * ☃x, ☃xxxxxx.z * ☃x);
-            this.pointedEntity = null;
-            Vec3d ☃xxxxxxxx = null;
-            float ☃xxxxxxxxx = 1.0F;
-            List<Entity> ☃xxxxxxxxxx = this.mc
-               .world
-               .getEntitiesInAABBexcluding(
-                  ☃,
-                  ☃.getEntityBoundingBox().expand(☃xxxxxx.x * ☃x, ☃xxxxxx.y * ☃x, ☃xxxxxx.z * ☃x).grow(1.0, 1.0, 1.0),
-                  Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>() {
-                     public boolean apply(@Nullable Entity var1) {
-                        return ☃ != null && ☃.canBeCollidedWith();
-                     }
-                  })
-               );
-            double ☃xxxxxxxxxxx = ☃xxxxx;
-
-            for (int ☃xxxxxxxxxxxx = 0; ☃xxxxxxxxxxxx < ☃xxxxxxxxxx.size(); ☃xxxxxxxxxxxx++) {
-               Entity ☃xxxxxxxxxxxxx = ☃xxxxxxxxxx.get(☃xxxxxxxxxxxx);
-               AxisAlignedBB ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx.getEntityBoundingBox().grow(☃xxxxxxxxxxxxx.getCollisionBorderSize());
-               RayTraceResult ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxx.calculateIntercept(☃xx, ☃xxxxxxx);
-               if (☃xxxxxxxxxxxxxx.contains(☃xx)) {
-                  if (☃xxxxxxxxxxx >= 0.0) {
-                     this.pointedEntity = ☃xxxxxxxxxxxxx;
-                     ☃xxxxxxxx = ☃xxxxxxxxxxxxxxx == null ? ☃xx : ☃xxxxxxxxxxxxxxx.hitVec;
-                     ☃xxxxxxxxxxx = 0.0;
+         Vec3d vec3d1 = entity.getLook(1.0F);
+         Vec3d vec3d2 = vec3d.add(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0);
+         this.pointedEntity = null;
+         Vec3d vec3d3 = null;
+         float f = 1.0F;
+         List<Entity> list = this.mc
+            .world
+            .getEntitiesInAABBexcluding(
+               entity,
+               entity.getEntityBoundingBox().expand(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0).grow(1.0, 1.0, 1.0),
+               Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>() {
+                  public boolean apply(@Nullable Entity p_apply_1_) {
+                     return p_apply_1_ != null && p_apply_1_.canBeCollidedWith();
                   }
-               } else if (☃xxxxxxxxxxxxxxx != null) {
-                  double ☃xxxxxxxxxxxxxxxx = ☃xx.distanceTo(☃xxxxxxxxxxxxxxx.hitVec);
-                  if (☃xxxxxxxxxxxxxxxx < ☃xxxxxxxxxxx || ☃xxxxxxxxxxx == 0.0) {
-                     if (☃xxxxxxxxxxxxx.getLowestRidingEntity() == ☃.getLowestRidingEntity()) {
-                        if (☃xxxxxxxxxxx == 0.0) {
-                           this.pointedEntity = ☃xxxxxxxxxxxxx;
-                           ☃xxxxxxxx = ☃xxxxxxxxxxxxxxx.hitVec;
-                        }
-                     } else {
-                        this.pointedEntity = ☃xxxxxxxxxxxxx;
-                        ☃xxxxxxxx = ☃xxxxxxxxxxxxxxx.hitVec;
-                        ☃xxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx;
-                     }
+               })
+            );
+         double d2 = d1;
+
+         for (int j = 0; j < list.size(); j++) {
+            Entity entity1 = list.get(j);
+            AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().grow(entity1.getCollisionBorderSize());
+            RayTraceResult raytraceresult = axisalignedbb.calculateIntercept(vec3d, vec3d2);
+            if (axisalignedbb.contains(vec3d)) {
+               if (d2 >= 0.0) {
+                  this.pointedEntity = entity1;
+                  vec3d3 = raytraceresult == null ? vec3d : raytraceresult.hitVec;
+                  d2 = 0.0;
+               }
+            } else if (raytraceresult != null) {
+               double d3 = vec3d.distanceTo(raytraceresult.hitVec);
+               if (d3 < d2 || d2 == 0.0) {
+                  boolean canRiderInteract = false;
+                  if (Reflector.ForgeEntity_canRiderInteract.exists()) {
+                     canRiderInteract = Reflector.callBoolean(entity1, Reflector.ForgeEntity_canRiderInteract, new Object[0]);
+                  }
+
+                  if (canRiderInteract || entity1.getLowestRidingEntity() != entity.getLowestRidingEntity()) {
+                     this.pointedEntity = entity1;
+                     vec3d3 = raytraceresult.hitVec;
+                     d2 = d3;
+                  } else if (d2 == 0.0) {
+                     this.pointedEntity = entity1;
+                     vec3d3 = raytraceresult.hitVec;
                   }
                }
             }
+         }
 
-            if (this.pointedEntity != null && ☃xxx && ☃xx.distanceTo(☃xxxxxxxx) > 3.0) {
-               this.pointedEntity = null;
-               this.mc.objectMouseOver = new RayTraceResult(RayTraceResult.Type.MISS, ☃xxxxxxxx, null, new BlockPos(☃xxxxxxxx));
-            }
+         if (this.pointedEntity != null && flag && vec3d.distanceTo(vec3d3) > 3.0) {
+            this.pointedEntity = null;
+            this.mc.objectMouseOver = new RayTraceResult(Type.MISS, vec3d3, (EnumFacing)null, new BlockPos(vec3d3));
+         }
 
-            if (this.pointedEntity != null && (☃xxxxxxxxxxx < ☃xxxxx || this.mc.objectMouseOver == null)) {
-               this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, ☃xxxxxxxx);
-               if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
-                  this.mc.pointedEntity = this.pointedEntity;
-               }
+         if (this.pointedEntity != null && (d2 < d1 || this.mc.objectMouseOver == null)) {
+            this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, vec3d3);
+            if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
+               this.mc.pointedEntity = this.pointedEntity;
             }
-
-            this.mc.profiler.endSection();
          }
+
+         this.mc.profiler.endSection();
       }
    }
 
    private void updateFovModifierHand() {
-      float ☃ = 1.0F;
+      float f = 1.0F;
       if (this.mc.getRenderViewEntity() instanceof AbstractClientPlayer) {
-         AbstractClientPlayer ☃x = (AbstractClientPlayer)this.mc.getRenderViewEntity();
-         ☃ = ☃x.getFovModifier();
+         AbstractClientPlayer abstractclientplayer = (AbstractClientPlayer)this.mc.getRenderViewEntity();
+         f = abstractclientplayer.getFovModifier();
       }
 
       this.fovModifierHandPrev = this.fovModifierHand;
-      this.fovModifierHand = this.fovModifierHand + (☃ - this.fovModifierHand) * 0.5F;
+      this.fovModifierHand = this.fovModifierHand + (f - this.fovModifierHand) * 0.5F;
       if (this.fovModifierHand > 1.5F) {
          this.fovModifierHand = 1.5F;
       }
@@ -421,120 +475,147 @@ private void updateFovModifierHand() {
       }
    }
 
-   private float getFOVModifier(float var1, boolean var2) {
+   private float getFOVModifier(float partialTicks, boolean useFOVSetting) {
       if (this.debugView) {
          return 90.0F;
       } else {
-         Entity ☃ = this.mc.getRenderViewEntity();
-         float ☃x = 70.0F;
-         if (☃) {
-            ☃x = this.mc.gameSettings.fovSetting;
-            ☃x *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * ☃;
+         Entity entity = this.mc.getRenderViewEntity();
+         float f = 70.0F;
+         if (useFOVSetting) {
+            f = this.mc.gameSettings.fovSetting;
+            if (Config.isDynamicFov()) {
+               f *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * partialTicks;
+            }
          }
 
-         if (☃ instanceof EntityLivingBase && ((EntityLivingBase)☃).getHealth() <= 0.0F) {
-            float ☃xx = ((EntityLivingBase)☃).deathTime + ☃;
-            ☃x /= (1.0F - 500.0F / (☃xx + 500.0F)) * 2.0F + 1.0F;
+         boolean zoomActive = false;
+         if (this.mc.currentScreen == null) {
+            zoomActive = GameSettings.isKeyDown(this.mc.gameSettings.ofKeyBindZoom);
          }
 
-         IBlockState ☃xx = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, ☃, ☃);
-         if (☃xx.getMaterial() == Material.WATER) {
-            ☃x = ☃x * 60.0F / 70.0F;
+         if (zoomActive) {
+            if (!Config.zoomMode) {
+               Config.zoomMode = true;
+               Config.zoomSmoothCamera = this.mc.gameSettings.smoothCamera;
+               this.mc.gameSettings.smoothCamera = true;
+               this.mc.renderGlobal.displayListEntitiesDirty = true;
+            }
+
+            if (Config.zoomMode) {
+               f /= 4.0F;
+            }
+         } else if (Config.zoomMode) {
+            Config.zoomMode = false;
+            this.mc.gameSettings.smoothCamera = Config.zoomSmoothCamera;
+            this.mouseFilterXAxis = new MouseFilter();
+            this.mouseFilterYAxis = new MouseFilter();
+            this.mc.renderGlobal.displayListEntitiesDirty = true;
+         }
+
+         if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).getHealth() <= 0.0F) {
+            float f1 = ((EntityLivingBase)entity).deathTime + partialTicks;
+            f /= (1.0F - 500.0F / (f1 + 500.0F)) * 2.0F + 1.0F;
          }
 
-         return ☃x;
+         IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, entity, partialTicks);
+         if (iblockstate.a() == Material.WATER) {
+            f = f * 60.0F / 70.0F;
+         }
+
+         return Reflector.ForgeHooksClient_getFOVModifier.exists()
+            ? Reflector.callFloat(Reflector.ForgeHooksClient_getFOVModifier, new Object[]{this, entity, iblockstate, partialTicks, f})
+            : f;
       }
    }
 
-   private void hurtCameraEffect(float var1) {
+   private void hurtCameraEffect(float partialTicks) {
       if (this.mc.getRenderViewEntity() instanceof EntityLivingBase) {
-         EntityLivingBase ☃ = (EntityLivingBase)this.mc.getRenderViewEntity();
-         float ☃x = ☃.hurtTime - ☃;
-         if (☃.getHealth() <= 0.0F) {
-            float ☃xx = ☃.deathTime + ☃;
-            GlStateManager.rotate(40.0F - 8000.0F / (☃xx + 200.0F), 0.0F, 0.0F, 1.0F);
+         EntityLivingBase entitylivingbase = (EntityLivingBase)this.mc.getRenderViewEntity();
+         float f = entitylivingbase.hurtTime - partialTicks;
+         if (entitylivingbase.getHealth() <= 0.0F) {
+            float f1 = entitylivingbase.deathTime + partialTicks;
+            GlStateManager.rotate(40.0F - 8000.0F / (f1 + 200.0F), 0.0F, 0.0F, 1.0F);
          }
 
-         if (☃x < 0.0F) {
+         if (f < 0.0F) {
             return;
          }
 
-         ☃x /= ☃.maxHurtTime;
-         ☃x = MathHelper.sin(☃x * ☃x * ☃x * ☃x * (float) Math.PI);
-         float ☃xx = ☃.attackedAtYaw;
-         GlStateManager.rotate(-☃xx, 0.0F, 1.0F, 0.0F);
-         GlStateManager.rotate(-☃x * 14.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.rotate(☃xx, 0.0F, 1.0F, 0.0F);
+         f /= entitylivingbase.maxHurtTime;
+         f = MathHelper.sin(f * f * f * f * (float) Math.PI);
+         float f2 = entitylivingbase.attackedAtYaw;
+         GlStateManager.rotate(-f2, 0.0F, 1.0F, 0.0F);
+         GlStateManager.rotate(-f * 14.0F, 0.0F, 0.0F, 1.0F);
+         GlStateManager.rotate(f2, 0.0F, 1.0F, 0.0F);
       }
    }
 
-   private void applyBobbing(float var1) {
+   private void applyBobbing(float partialTicks) {
       if (this.mc.getRenderViewEntity() instanceof EntityPlayer) {
-         EntityPlayer ☃ = (EntityPlayer)this.mc.getRenderViewEntity();
-         float ☃x = ☃.distanceWalkedModified - ☃.prevDistanceWalkedModified;
-         float ☃xx = -(☃.distanceWalkedModified + ☃x * ☃);
-         float ☃xxx = ☃.prevCameraYaw + (☃.cameraYaw - ☃.prevCameraYaw) * ☃;
-         float ☃xxxx = ☃.prevCameraPitch + (☃.cameraPitch - ☃.prevCameraPitch) * ☃;
-         GlStateManager.translate(MathHelper.sin(☃xx * (float) Math.PI) * ☃xxx * 0.5F, -Math.abs(MathHelper.cos(☃xx * (float) Math.PI) * ☃xxx), 0.0F);
-         GlStateManager.rotate(MathHelper.sin(☃xx * (float) Math.PI) * ☃xxx * 3.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.rotate(Math.abs(MathHelper.cos(☃xx * (float) Math.PI - 0.2F) * ☃xxx) * 5.0F, 1.0F, 0.0F, 0.0F);
-         GlStateManager.rotate(☃xxxx, 1.0F, 0.0F, 0.0F);
+         EntityPlayer entityplayer = (EntityPlayer)this.mc.getRenderViewEntity();
+         float f = entityplayer.distanceWalkedModified - entityplayer.prevDistanceWalkedModified;
+         float f1 = -(entityplayer.distanceWalkedModified + f * partialTicks);
+         float f2 = entityplayer.prevCameraYaw + (entityplayer.cameraYaw - entityplayer.prevCameraYaw) * partialTicks;
+         float f3 = entityplayer.prevCameraPitch + (entityplayer.cameraPitch - entityplayer.prevCameraPitch) * partialTicks;
+         GlStateManager.translate(MathHelper.sin(f1 * (float) Math.PI) * f2 * 0.5F, -Math.abs(MathHelper.cos(f1 * (float) Math.PI) * f2), 0.0F);
+         GlStateManager.rotate(MathHelper.sin(f1 * (float) Math.PI) * f2 * 3.0F, 0.0F, 0.0F, 1.0F);
+         GlStateManager.rotate(Math.abs(MathHelper.cos(f1 * (float) Math.PI - 0.2F) * f2) * 5.0F, 1.0F, 0.0F, 0.0F);
+         GlStateManager.rotate(f3, 1.0F, 0.0F, 0.0F);
       }
    }
 
-   private void orientCamera(float var1) {
-      Entity ☃ = this.mc.getRenderViewEntity();
-      float ☃x = ☃.getEyeHeight();
-      double ☃xx = ☃.prevPosX + (☃.posX - ☃.prevPosX) * ☃;
-      double ☃xxx = ☃.prevPosY + (☃.posY - ☃.prevPosY) * ☃ + ☃x;
-      double ☃xxxx = ☃.prevPosZ + (☃.posZ - ☃.prevPosZ) * ☃;
-      if (☃ instanceof EntityLivingBase && ((EntityLivingBase)☃).isPlayerSleeping()) {
-         ☃x = (float)(☃x + 1.0);
+   private void orientCamera(float partialTicks) {
+      Entity entity = this.mc.getRenderViewEntity();
+      float f = entity.getEyeHeight();
+      double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * partialTicks;
+      double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * partialTicks + f;
+      double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * partialTicks;
+      if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPlayerSleeping()) {
+         f = (float)(f + 1.0);
          GlStateManager.translate(0.0F, 0.3F, 0.0F);
          if (!this.mc.gameSettings.debugCamEnable) {
-            BlockPos ☃xxxxx = new BlockPos(☃);
-            IBlockState ☃xxxxxx = this.mc.world.getBlockState(☃xxxxx);
-            Block ☃xxxxxxx = ☃xxxxxx.getBlock();
-            if (☃xxxxxxx == Blocks.BED) {
-               int ☃xxxxxxxx = ☃xxxxxx.getValue(BlockBed.FACING).getHorizontalIndex();
-               GlStateManager.rotate(☃xxxxxxxx * 90, 0.0F, 1.0F, 0.0F);
+            BlockPos blockpos = new BlockPos(entity);
+            IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
+            Block block = iblockstate.getBlock();
+            if (Reflector.ForgeHooksClient_orientBedCamera.exists()) {
+               Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[]{this.mc.world, blockpos, iblockstate, entity});
+            } else if (block == Blocks.BED) {
+               int j = ((EnumFacing)iblockstate.getValue(BlockBed.D)).getHorizontalIndex();
+               GlStateManager.rotate(j * 90, 0.0F, 1.0F, 0.0F);
             }
 
-            GlStateManager.rotate(☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃ + 180.0F, 0.0F, -1.0F, 0.0F);
-            GlStateManager.rotate(☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃, -1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, -1.0F, 0.0F);
+            GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
          }
       } else if (this.mc.gameSettings.thirdPersonView > 0) {
-         double ☃xxxxx = this.thirdPersonDistancePrev + (4.0F - this.thirdPersonDistancePrev) * ☃;
+         double d3 = this.thirdPersonDistancePrev + (4.0F - this.thirdPersonDistancePrev) * partialTicks;
          if (this.mc.gameSettings.debugCamEnable) {
-            GlStateManager.translate(0.0F, 0.0F, (float)(-☃xxxxx));
+            GlStateManager.translate(0.0F, 0.0F, (float)(-d3));
          } else {
-            float ☃xxxxxx = ☃.rotationYaw;
-            float ☃xxxxxxx = ☃.rotationPitch;
+            float f1 = entity.rotationYaw;
+            float f2 = entity.rotationPitch;
             if (this.mc.gameSettings.thirdPersonView == 2) {
-               ☃xxxxxxx += 180.0F;
+               f2 += 180.0F;
             }
 
-            double ☃xxxxxxxx = -MathHelper.sin(☃xxxxxx * (float) (Math.PI / 180.0)) * MathHelper.cos(☃xxxxxxx * (float) (Math.PI / 180.0)) * ☃xxxxx;
-            double ☃xxxxxxxxx = MathHelper.cos(☃xxxxxx * (float) (Math.PI / 180.0)) * MathHelper.cos(☃xxxxxxx * (float) (Math.PI / 180.0)) * ☃xxxxx;
-            double ☃xxxxxxxxxx = -MathHelper.sin(☃xxxxxxx * (float) (Math.PI / 180.0)) * ☃xxxxx;
-
-            for (int ☃xxxxxxxxxxx = 0; ☃xxxxxxxxxxx < 8; ☃xxxxxxxxxxx++) {
-               float ☃xxxxxxxxxxxx = (☃xxxxxxxxxxx & 1) * 2 - 1;
-               float ☃xxxxxxxxxxxxx = (☃xxxxxxxxxxx >> 1 & 1) * 2 - 1;
-               float ☃xxxxxxxxxxxxxx = (☃xxxxxxxxxxx >> 2 & 1) * 2 - 1;
-               ☃xxxxxxxxxxxx *= 0.1F;
-               ☃xxxxxxxxxxxxx *= 0.1F;
-               ☃xxxxxxxxxxxxxx *= 0.1F;
-               RayTraceResult ☃xxxxxxxxxxxxxxx = this.mc
+            double d4 = -MathHelper.sin(f1 * (float) (Math.PI / 180.0)) * MathHelper.cos(f2 * (float) (Math.PI / 180.0)) * d3;
+            double d5 = MathHelper.cos(f1 * (float) (Math.PI / 180.0)) * MathHelper.cos(f2 * (float) (Math.PI / 180.0)) * d3;
+            double d6 = -MathHelper.sin(f2 * (float) (Math.PI / 180.0)) * d3;
+
+            for (int i = 0; i < 8; i++) {
+               float f3 = (i & 1) * 2 - 1;
+               float f4 = (i >> 1 & 1) * 2 - 1;
+               float f5 = (i >> 2 & 1) * 2 - 1;
+               f3 *= 0.1F;
+               f4 *= 0.1F;
+               f5 *= 0.1F;
+               RayTraceResult raytraceresult = this.mc
                   .world
-                  .rayTraceBlocks(
-                     new Vec3d(☃xx + ☃xxxxxxxxxxxx, ☃xxx + ☃xxxxxxxxxxxxx, ☃xxxx + ☃xxxxxxxxxxxxxx),
-                     new Vec3d(☃xx - ☃xxxxxxxx + ☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxx, ☃xxx - ☃xxxxxxxxxx + ☃xxxxxxxxxxxxx, ☃xxxx - ☃xxxxxxxxx + ☃xxxxxxxxxxxxxx)
-                  );
-               if (☃xxxxxxxxxxxxxxx != null) {
-                  double ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx.hitVec.distanceTo(new Vec3d(☃xx, ☃xxx, ☃xxxx));
-                  if (☃xxxxxxxxxxxxxxxx < ☃xxxxx) {
-                     ☃xxxxx = ☃xxxxxxxxxxxxxxxx;
+                  .rayTraceBlocks(new Vec3d(d0 + f3, d1 + f4, d2 + f5), new Vec3d(d0 - d4 + f3 + f5, d1 - d6 + f4, d2 - d5 + f5));
+               if (raytraceresult != null) {
+                  double d7 = raytraceresult.hitVec.distanceTo(new Vec3d(d0, d1, d2));
+                  if (d7 < d3) {
+                     d3 = d7;
                   }
                }
             }
@@ -543,40 +624,75 @@ private void orientCamera(float var1) {
                GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            GlStateManager.rotate(☃.rotationPitch - ☃xxxxxxx, 1.0F, 0.0F, 0.0F);
-            GlStateManager.rotate(☃.rotationYaw - ☃xxxxxx, 0.0F, 1.0F, 0.0F);
-            GlStateManager.translate(0.0F, 0.0F, (float)(-☃xxxxx));
-            GlStateManager.rotate(☃xxxxxx - ☃.rotationYaw, 0.0F, 1.0F, 0.0F);
-            GlStateManager.rotate(☃xxxxxxx - ☃.rotationPitch, 1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(entity.rotationPitch - f2, 1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(entity.rotationYaw - f1, 0.0F, 1.0F, 0.0F);
+            GlStateManager.translate(0.0F, 0.0F, (float)(-d3));
+            GlStateManager.rotate(f1 - entity.rotationYaw, 0.0F, 1.0F, 0.0F);
+            GlStateManager.rotate(f2 - entity.rotationPitch, 1.0F, 0.0F, 0.0F);
          }
       } else {
          GlStateManager.translate(0.0F, 0.0F, 0.05F);
       }
 
-      if (!this.mc.gameSettings.debugCamEnable) {
-         GlStateManager.rotate(☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃, 1.0F, 0.0F, 0.0F);
-         if (☃ instanceof EntityAnimal) {
-            EntityAnimal ☃xxxxx = (EntityAnimal)☃;
-            GlStateManager.rotate(☃xxxxx.prevRotationYawHead + (☃xxxxx.rotationYawHead - ☃xxxxx.prevRotationYawHead) * ☃ + 180.0F, 0.0F, 1.0F, 0.0F);
+      if (Reflector.EntityViewRenderEvent_CameraSetup_Constructor.exists()) {
+         if (!this.mc.gameSettings.debugCamEnable) {
+            float yaw = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F;
+            float pitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
+            float roll = 0.0F;
+            if (entity instanceof EntityAnimal) {
+               EntityAnimal entityanimal = (EntityAnimal)entity;
+               yaw = entityanimal.aQ + (entityanimal.aP - entityanimal.aQ) * partialTicks + 180.0F;
+            }
+
+            IBlockState state = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, entity, partialTicks);
+            Object event = Reflector.newInstance(
+               Reflector.EntityViewRenderEvent_CameraSetup_Constructor, new Object[]{this, entity, state, partialTicks, yaw, pitch, roll}
+            );
+            Reflector.postForgeBusEvent(event);
+            roll = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_CameraSetup_getRoll, new Object[0]);
+            pitch = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_CameraSetup_getPitch, new Object[0]);
+            yaw = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_CameraSetup_getYaw, new Object[0]);
+            GlStateManager.rotate(roll, 0.0F, 0.0F, 1.0F);
+            GlStateManager.rotate(pitch, 1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(yaw, 0.0F, 1.0F, 0.0F);
+         }
+      } else if (!this.mc.gameSettings.debugCamEnable) {
+         GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, 1.0F, 0.0F, 0.0F);
+         if (entity instanceof EntityAnimal) {
+            EntityAnimal entityanimal = (EntityAnimal)entity;
+            GlStateManager.rotate(entityanimal.aQ + (entityanimal.aP - entityanimal.aQ) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
          } else {
-            GlStateManager.rotate(☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃ + 180.0F, 0.0F, 1.0F, 0.0F);
+            GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, 1.0F, 0.0F);
          }
       }
 
-      GlStateManager.translate(0.0F, -☃x, 0.0F);
-      ☃xx = ☃.prevPosX + (☃.posX - ☃.prevPosX) * ☃;
-      ☃xxx = ☃.prevPosY + (☃.posY - ☃.prevPosY) * ☃ + ☃x;
-      ☃xxxx = ☃.prevPosZ + (☃.posZ - ☃.prevPosZ) * ☃;
-      this.cloudFog = this.mc.renderGlobal.hasCloudFog(☃xx, ☃xxx, ☃xxxx, ☃);
+      GlStateManager.translate(0.0F, -f, 0.0F);
+      d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * partialTicks;
+      d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * partialTicks + f;
+      d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * partialTicks;
+      this.cloudFog = this.mc.renderGlobal.hasCloudFog(d0, d1, d2, partialTicks);
    }
 
-   private void setupCameraTransform(float var1, int var2) {
+   public void setupCameraTransform(float partialTicks, int pass) {
       this.farPlaneDistance = this.mc.gameSettings.renderDistanceChunks * 16;
+      if (Config.isFogFancy()) {
+         this.farPlaneDistance *= 0.95F;
+      }
+
+      if (Config.isFogFast()) {
+         this.farPlaneDistance *= 0.83F;
+      }
+
       GlStateManager.matrixMode(5889);
       GlStateManager.loadIdentity();
-      float ☃ = 0.07F;
+      float f = 0.07F;
       if (this.mc.gameSettings.anaglyph) {
-         GlStateManager.translate(-(☃ * 2 - 1) * 0.07F, 0.0F, 0.0F);
+         GlStateManager.translate(-(pass * 2 - 1) * 0.07F, 0.0F, 0.0F);
+      }
+
+      this.clipDistance = this.farPlaneDistance * 2.0F;
+      if (this.clipDistance < 173.0F) {
+         this.clipDistance = 173.0F;
       }
 
       if (this.cameraZoom != 1.0) {
@@ -584,35 +700,33 @@ private void setupCameraTransform(float var1, int var2) {
          GlStateManager.scale(this.cameraZoom, this.cameraZoom, 1.0);
       }
 
-      Project.gluPerspective(
-         this.getFOVModifier(☃, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-      );
+      Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
       GlStateManager.matrixMode(5888);
       GlStateManager.loadIdentity();
       if (this.mc.gameSettings.anaglyph) {
-         GlStateManager.translate((☃ * 2 - 1) * 0.1F, 0.0F, 0.0F);
+         GlStateManager.translate((pass * 2 - 1) * 0.1F, 0.0F, 0.0F);
       }
 
-      this.hurtCameraEffect(☃);
+      this.hurtCameraEffect(partialTicks);
       if (this.mc.gameSettings.viewBobbing) {
-         this.applyBobbing(☃);
+         this.applyBobbing(partialTicks);
       }
 
-      float ☃x = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * ☃;
-      if (☃x > 0.0F) {
-         int ☃xx = 20;
+      float f1 = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
+      if (f1 > 0.0F) {
+         int i = 20;
          if (this.mc.player.isPotionActive(MobEffects.NAUSEA)) {
-            ☃xx = 7;
+            i = 7;
          }
 
-         float ☃xxx = 5.0F / (☃x * ☃x + 5.0F) - ☃x * 0.04F;
-         ☃xxx *= ☃xxx;
-         GlStateManager.rotate((this.rendererUpdateCount + ☃) * ☃xx, 0.0F, 1.0F, 1.0F);
-         GlStateManager.scale(1.0F / ☃xxx, 1.0F, 1.0F);
-         GlStateManager.rotate(-(this.rendererUpdateCount + ☃) * ☃xx, 0.0F, 1.0F, 1.0F);
+         float f2 = 5.0F / (f1 * f1 + 5.0F) - f1 * 0.04F;
+         f2 *= f2;
+         GlStateManager.rotate((this.rendererUpdateCount + partialTicks) * i, 0.0F, 1.0F, 1.0F);
+         GlStateManager.scale(1.0F / f2, 1.0F, 1.0F);
+         GlStateManager.rotate(-(this.rendererUpdateCount + partialTicks) * i, 0.0F, 1.0F, 1.0F);
       }
 
-      this.orientCamera(☃);
+      this.orientCamera(partialTicks);
       if (this.debugView) {
          switch (this.debugViewDirection) {
             case 0:
@@ -633,43 +747,72 @@ private void setupCameraTransform(float var1, int var2) {
       }
    }
 
-   private void renderHand(float var1, int var2) {
+   private void renderHand(float partialTicks, int pass) {
+      this.renderHand(partialTicks, pass, true, true, false);
+   }
+
+   public void renderHand(float partialTicks, int pass, boolean renderItem, boolean renderOverlay, boolean renderTranslucent) {
       if (!this.debugView) {
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         float ☃ = 0.07F;
+         float f = 0.07F;
          if (this.mc.gameSettings.anaglyph) {
-            GlStateManager.translate(-(☃ * 2 - 1) * 0.07F, 0.0F, 0.0F);
+            GlStateManager.translate(-(pass * 2 - 1) * 0.07F, 0.0F, 0.0F);
+         }
+
+         if (Config.isShaders()) {
+            Shaders.applyHandDepth();
          }
 
-         Project.gluPerspective(this.getFOVModifier(☃, false), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+         Project.gluPerspective(
+            this.getFOVModifier(partialTicks, false), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F
+         );
          GlStateManager.matrixMode(5888);
          GlStateManager.loadIdentity();
          if (this.mc.gameSettings.anaglyph) {
-            GlStateManager.translate((☃ * 2 - 1) * 0.1F, 0.0F, 0.0F);
+            GlStateManager.translate((pass * 2 - 1) * 0.1F, 0.0F, 0.0F);
          }
 
-         GlStateManager.pushMatrix();
-         this.hurtCameraEffect(☃);
-         if (this.mc.gameSettings.viewBobbing) {
-            this.applyBobbing(☃);
+         boolean flag = false;
+         if (renderItem) {
+            GlStateManager.pushMatrix();
+            this.hurtCameraEffect(partialTicks);
+            if (this.mc.gameSettings.viewBobbing) {
+               this.applyBobbing(partialTicks);
+            }
+
+            flag = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
+            boolean shouldRenderHand = !ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, partialTicks, pass);
+            if (shouldRenderHand
+               && this.mc.gameSettings.thirdPersonView == 0
+               && !flag
+               && !this.mc.gameSettings.hideGUI
+               && !this.mc.playerController.isSpectator()) {
+               this.enableLightmap();
+               if (Config.isShaders()) {
+                  ShadersRender.renderItemFP(this.itemRenderer, partialTicks, renderTranslucent);
+               } else {
+                  this.itemRenderer.renderItemInFirstPerson(partialTicks);
+               }
+
+               this.disableLightmap();
+            }
+
+            GlStateManager.popMatrix();
          }
 
-         boolean ☃x = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
-         if (this.mc.gameSettings.thirdPersonView == 0 && !☃x && !this.mc.gameSettings.hideGUI && !this.mc.playerController.isSpectator()) {
-            this.enableLightmap();
-            this.itemRenderer.renderItemInFirstPerson(☃);
-            this.disableLightmap();
+         if (!renderOverlay) {
+            return;
          }
 
-         GlStateManager.popMatrix();
-         if (this.mc.gameSettings.thirdPersonView == 0 && !☃x) {
-            this.itemRenderer.renderOverlays(☃);
-            this.hurtCameraEffect(☃);
+         this.disableLightmap();
+         if (this.mc.gameSettings.thirdPersonView == 0 && !flag) {
+            this.itemRenderer.renderOverlays(partialTicks);
+            this.hurtCameraEffect(partialTicks);
          }
 
          if (this.mc.gameSettings.viewBobbing) {
-            this.applyBobbing(☃);
+            this.applyBobbing(partialTicks);
          }
       }
    }
@@ -678,24 +821,30 @@ public void disableLightmap() {
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
       GlStateManager.disableTexture2D();
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.disableLightmap();
+      }
    }
 
    public void enableLightmap() {
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
       GlStateManager.matrixMode(5890);
       GlStateManager.loadIdentity();
-      float ☃ = 0.00390625F;
+      float f = 0.00390625F;
       GlStateManager.scale(0.00390625F, 0.00390625F, 0.00390625F);
       GlStateManager.translate(8.0F, 8.0F, 8.0F);
       GlStateManager.matrixMode(5888);
       this.mc.getTextureManager().bindTexture(this.locationLightMap);
       GlStateManager.glTexParameteri(3553, 10241, 9729);
       GlStateManager.glTexParameteri(3553, 10240, 9729);
-      GlStateManager.glTexParameteri(3553, 10242, 10496);
-      GlStateManager.glTexParameteri(3553, 10243, 10496);
+      GlStateManager.glTexParameteri(3553, 10242, 33071);
+      GlStateManager.glTexParameteri(3553, 10243, 33071);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.enableTexture2D();
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.enableLightmap();
+      }
    }
 
    private void updateTorchFlicker() {
@@ -705,114 +854,135 @@ private void updateTorchFlicker() {
       this.lightmapUpdateNeeded = true;
    }
 
-   private void updateLightmap(float var1) {
+   private void updateLightmap(float partialTicks) {
       if (this.lightmapUpdateNeeded) {
          this.mc.profiler.startSection("lightTex");
-         World ☃ = this.mc.world;
-         if (☃ != null) {
-            float ☃x = ☃.getSunBrightness(1.0F);
-            float ☃xx = ☃x * 0.95F + 0.05F;
-
-            for (int ☃xxx = 0; ☃xxx < 256; ☃xxx++) {
-               float ☃xxxx = ☃.provider.getLightBrightnessTable()[☃xxx / 16] * ☃xx;
-               float ☃xxxxx = ☃.provider.getLightBrightnessTable()[☃xxx % 16] * (this.torchFlickerX * 0.1F + 1.5F);
-               if (☃.getLastLightningBolt() > 0) {
-                  ☃xxxx = ☃.provider.getLightBrightnessTable()[☃xxx / 16];
+         World world = this.mc.world;
+         if (world != null) {
+            if (Config.isCustomColors()
+               && CustomColors.updateLightmap(
+                  world, this.torchFlickerX, this.lightmapColors, this.mc.player.isPotionActive(MobEffects.NIGHT_VISION), partialTicks
+               )) {
+               this.lightmapTexture.updateDynamicTexture();
+               this.lightmapUpdateNeeded = false;
+               this.mc.profiler.endSection();
+               return;
+            }
+
+            float f = world.getSunBrightness(1.0F);
+            float f1 = f * 0.95F + 0.05F;
+
+            for (int i = 0; i < 256; i++) {
+               float f2 = world.provider.getLightBrightnessTable()[i / 16] * f1;
+               float f3 = world.provider.getLightBrightnessTable()[i % 16] * (this.torchFlickerX * 0.1F + 1.5F);
+               if (world.getLastLightningBolt() > 0) {
+                  f2 = world.provider.getLightBrightnessTable()[i / 16];
                }
 
-               float ☃xxxxxx = ☃xxxx * (☃x * 0.65F + 0.35F);
-               float ☃xxxxxxx = ☃xxxx * (☃x * 0.65F + 0.35F);
-               float ☃xxxxxxxx = ☃xxxxx * ((☃xxxxx * 0.6F + 0.4F) * 0.6F + 0.4F);
-               float ☃xxxxxxxxx = ☃xxxxx * (☃xxxxx * ☃xxxxx * 0.6F + 0.4F);
-               float ☃xxxxxxxxxx = ☃xxxxxx + ☃xxxxx;
-               float ☃xxxxxxxxxxx = ☃xxxxxxx + ☃xxxxxxxx;
-               float ☃xxxxxxxxxxxx = ☃xxxx + ☃xxxxxxxxx;
-               ☃xxxxxxxxxx = ☃xxxxxxxxxx * 0.96F + 0.03F;
-               ☃xxxxxxxxxxx = ☃xxxxxxxxxxx * 0.96F + 0.03F;
-               ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxx * 0.96F + 0.03F;
+               float f4 = f2 * (f * 0.65F + 0.35F);
+               float f5 = f2 * (f * 0.65F + 0.35F);
+               float f6 = f3 * ((f3 * 0.6F + 0.4F) * 0.6F + 0.4F);
+               float f7 = f3 * (f3 * f3 * 0.6F + 0.4F);
+               float f8 = f4 + f3;
+               float f9 = f5 + f6;
+               float f10 = f2 + f7;
+               f8 = f8 * 0.96F + 0.03F;
+               f9 = f9 * 0.96F + 0.03F;
+               f10 = f10 * 0.96F + 0.03F;
                if (this.bossColorModifier > 0.0F) {
-                  float ☃xxxxxxxxxxxxx = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * ☃;
-                  ☃xxxxxxxxxx = ☃xxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxx * 0.7F * ☃xxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxx = ☃xxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxxx * 0.6F * ☃xxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxxxx * 0.6F * ☃xxxxxxxxxxxxx;
+                  float f11 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * partialTicks;
+                  f8 = f8 * (1.0F - f11) + f8 * 0.7F * f11;
+                  f9 = f9 * (1.0F - f11) + f9 * 0.6F * f11;
+                  f10 = f10 * (1.0F - f11) + f10 * 0.6F * f11;
                }
 
-               if (☃.provider.getDimensionType().getId() == 1) {
-                  ☃xxxxxxxxxx = 0.22F + ☃xxxxx * 0.75F;
-                  ☃xxxxxxxxxxx = 0.28F + ☃xxxxxxxx * 0.75F;
-                  ☃xxxxxxxxxxxx = 0.25F + ☃xxxxxxxxx * 0.75F;
+               if (world.provider.getDimensionType().getId() == 1) {
+                  f8 = 0.22F + f3 * 0.75F;
+                  f9 = 0.28F + f6 * 0.75F;
+                  f10 = 0.25F + f7 * 0.75F;
                }
 
+               if (Reflector.ForgeWorldProvider_getLightmapColors.exists()) {
+                  float[] colors = new float[]{f8, f9, f10};
+                  Reflector.call(world.provider, Reflector.ForgeWorldProvider_getLightmapColors, new Object[]{partialTicks, f, f2, f3, colors});
+                  f8 = colors[0];
+                  f9 = colors[1];
+                  f10 = colors[2];
+               }
+
+               f8 = MathHelper.clamp(f8, 0.0F, 1.0F);
+               f9 = MathHelper.clamp(f9, 0.0F, 1.0F);
+               f10 = MathHelper.clamp(f10, 0.0F, 1.0F);
                if (this.mc.player.isPotionActive(MobEffects.NIGHT_VISION)) {
-                  float ☃xxxxxxxxxxxxx = this.getNightVisionBrightness(this.mc.player, ☃);
-                  float ☃xxxxxxxxxxxxxx = 1.0F / ☃xxxxxxxxxx;
-                  if (☃xxxxxxxxxxxxxx > 1.0F / ☃xxxxxxxxxxx) {
-                     ☃xxxxxxxxxxxxxx = 1.0F / ☃xxxxxxxxxxx;
+                  float f15 = this.getNightVisionBrightness(this.mc.player, partialTicks);
+                  float f12 = 1.0F / f8;
+                  if (f12 > 1.0F / f9) {
+                     f12 = 1.0F / f9;
                   }
 
-                  if (☃xxxxxxxxxxxxxx > 1.0F / ☃xxxxxxxxxxxx) {
-                     ☃xxxxxxxxxxxxxx = 1.0F / ☃xxxxxxxxxxxx;
+                  if (f12 > 1.0F / f10) {
+                     f12 = 1.0F / f10;
                   }
 
-                  ☃xxxxxxxxxx = ☃xxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxx * ☃xxxxxxxxxxxxxx * ☃xxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxx = ☃xxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxxx * ☃xxxxxxxxxxxxxx * ☃xxxxxxxxxxxxx;
-                  ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxx) + ☃xxxxxxxxxxxx * ☃xxxxxxxxxxxxxx * ☃xxxxxxxxxxxxx;
+                  f8 = f8 * (1.0F - f15) + f8 * f12 * f15;
+                  f9 = f9 * (1.0F - f15) + f9 * f12 * f15;
+                  f10 = f10 * (1.0F - f15) + f10 * f12 * f15;
                }
 
-               if (☃xxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxx = 1.0F;
+               if (f8 > 1.0F) {
+                  f8 = 1.0F;
                }
 
-               if (☃xxxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxxx = 1.0F;
+               if (f9 > 1.0F) {
+                  f9 = 1.0F;
                }
 
-               if (☃xxxxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxxxx = 1.0F;
+               if (f10 > 1.0F) {
+                  f10 = 1.0F;
                }
 
-               float ☃xxxxxxxxxxxxxxx = this.mc.gameSettings.gammaSetting;
-               float ☃xxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxx;
-               float ☃xxxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxx;
-               float ☃xxxxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxx = ☃xxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxxxx) + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxx = ☃xxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxxxx) + ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxx * (1.0F - ☃xxxxxxxxxxxxxxx) + ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxx;
-               ☃xxxxxxxxxx = ☃xxxxxxxxxx * 0.96F + 0.03F;
-               ☃xxxxxxxxxxx = ☃xxxxxxxxxxx * 0.96F + 0.03F;
-               ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxx * 0.96F + 0.03F;
-               if (☃xxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxx = 1.0F;
+               float f16 = this.mc.gameSettings.gammaSetting;
+               float f17 = 1.0F - f8;
+               float f13 = 1.0F - f9;
+               float f14 = 1.0F - f10;
+               f17 = 1.0F - f17 * f17 * f17 * f17;
+               f13 = 1.0F - f13 * f13 * f13 * f13;
+               f14 = 1.0F - f14 * f14 * f14 * f14;
+               f8 = f8 * (1.0F - f16) + f17 * f16;
+               f9 = f9 * (1.0F - f16) + f13 * f16;
+               f10 = f10 * (1.0F - f16) + f14 * f16;
+               f8 = f8 * 0.96F + 0.03F;
+               f9 = f9 * 0.96F + 0.03F;
+               f10 = f10 * 0.96F + 0.03F;
+               if (f8 > 1.0F) {
+                  f8 = 1.0F;
                }
 
-               if (☃xxxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxxx = 1.0F;
+               if (f9 > 1.0F) {
+                  f9 = 1.0F;
                }
 
-               if (☃xxxxxxxxxxxx > 1.0F) {
-                  ☃xxxxxxxxxxxx = 1.0F;
+               if (f10 > 1.0F) {
+                  f10 = 1.0F;
                }
 
-               if (☃xxxxxxxxxx < 0.0F) {
-                  ☃xxxxxxxxxx = 0.0F;
+               if (f8 < 0.0F) {
+                  f8 = 0.0F;
                }
 
-               if (☃xxxxxxxxxxx < 0.0F) {
-                  ☃xxxxxxxxxxx = 0.0F;
+               if (f9 < 0.0F) {
+                  f9 = 0.0F;
                }
 
-               if (☃xxxxxxxxxxxx < 0.0F) {
-                  ☃xxxxxxxxxxxx = 0.0F;
+               if (f10 < 0.0F) {
+                  f10 = 0.0F;
                }
 
-               int ☃xxxxxxxxxxxxxxxxxxx = 255;
-               int ☃xxxxxxxxxxxxxxxxxxxx = (int)(☃xxxxxxxxxx * 255.0F);
-               int ☃xxxxxxxxxxxxxxxxxxxxx = (int)(☃xxxxxxxxxxx * 255.0F);
-               int ☃xxxxxxxxxxxxxxxxxxxxxx = (int)(☃xxxxxxxxxxxx * 255.0F);
-               this.lightmapColors[☃xxx] = 0xFF000000 | ☃xxxxxxxxxxxxxxxxxxxx << 16 | ☃xxxxxxxxxxxxxxxxxxxxx << 8 | ☃xxxxxxxxxxxxxxxxxxxxxx;
+               int j = 255;
+               int k = (int)(f8 * 255.0F);
+               int l = (int)(f9 * 255.0F);
+               int i1 = (int)(f10 * 255.0F);
+               this.lightmapColors[i] = 0xFF000000 | k << 16 | l << 8 | i1;
             }
 
             this.lightmapTexture.updateDynamicTexture();
@@ -822,14 +992,15 @@ private void updateLightmap(float var1) {
       }
    }
 
-   private float getNightVisionBrightness(EntityLivingBase var1, float var2) {
-      int ☃ = ☃.getActivePotionEffect(MobEffects.NIGHT_VISION).getDuration();
-      return ☃ > 200 ? 1.0F : 0.7F + MathHelper.sin((☃ - ☃) * (float) Math.PI * 0.2F) * 0.3F;
+   public float getNightVisionBrightness(EntityLivingBase entitylivingbaseIn, float partialTicks) {
+      int i = entitylivingbaseIn.getActivePotionEffect(MobEffects.NIGHT_VISION).getDuration();
+      return i > 200 ? 1.0F : 0.7F + MathHelper.sin((i - partialTicks) * (float) Math.PI * 0.2F) * 0.3F;
    }
 
-   public void updateCameraAndRender(float var1, long var2) {
-      boolean ☃ = Display.isActive();
-      if (!☃ && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1))) {
+   public void updateCameraAndRender(float partialTicks, long nanoTime) {
+      this.frameInit();
+      boolean flag = Display.isActive();
+      if (!flag && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1))) {
          if (Minecraft.getSystemTime() - this.prevFrameTime > 500L) {
             this.mc.displayInGameMenu();
          }
@@ -838,55 +1009,65 @@ public void updateCameraAndRender(float var1, long var2) {
       }
 
       this.mc.profiler.startSection("mouse");
-      if (☃ && Minecraft.IS_RUNNING_ON_MAC && this.mc.inGameHasFocus && !Mouse.isInsideWindow()) {
+      if (flag && Minecraft.IS_RUNNING_ON_MAC && this.mc.inGameHasFocus && !Mouse.isInsideWindow()) {
          Mouse.setGrabbed(false);
          Mouse.setCursorPosition(Display.getWidth() / 2, Display.getHeight() / 2 - 20);
          Mouse.setGrabbed(true);
       }
 
-      if (this.mc.inGameHasFocus && ☃) {
+      if (this.mc.inGameHasFocus && flag) {
          this.mc.mouseHelper.mouseXYChange();
          this.mc.getTutorial().handleMouse(this.mc.mouseHelper);
-         float ☃x = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
-         float ☃xx = ☃x * ☃x * ☃x * 8.0F;
-         float ☃xxx = this.mc.mouseHelper.deltaX * ☃xx;
-         float ☃xxxx = this.mc.mouseHelper.deltaY * ☃xx;
-         int ☃xxxxx = 1;
+         float f = this.mc.gameSettings.mouseSensitivity * 0.6F + 0.2F;
+         float f1 = f * f * f * 8.0F;
+         float f2 = this.mc.mouseHelper.deltaX * f1;
+         float f3 = this.mc.mouseHelper.deltaY * f1;
+         int i = 1;
          if (this.mc.gameSettings.invertMouse) {
-            ☃xxxxx = -1;
+            i = -1;
          }
 
          if (this.mc.gameSettings.smoothCamera) {
-            this.smoothCamYaw += ☃xxx;
-            this.smoothCamPitch += ☃xxxx;
-            float ☃xxxxxx = ☃ - this.smoothCamPartialTicks;
-            this.smoothCamPartialTicks = ☃;
-            ☃xxx = this.smoothCamFilterX * ☃xxxxxx;
-            ☃xxxx = this.smoothCamFilterY * ☃xxxxxx;
-            this.mc.player.turn(☃xxx, ☃xxxx * ☃xxxxx);
+            this.smoothCamYaw += f2;
+            this.smoothCamPitch += f3;
+            float f4 = partialTicks - this.smoothCamPartialTicks;
+            this.smoothCamPartialTicks = partialTicks;
+            f2 = this.smoothCamFilterX * f4;
+            f3 = this.smoothCamFilterY * f4;
+            this.mc.player.turn(f2, f3 * i);
          } else {
             this.smoothCamYaw = 0.0F;
             this.smoothCamPitch = 0.0F;
-            this.mc.player.turn(☃xxx, ☃xxxx * ☃xxxxx);
+            this.mc.player.turn(f2, f3 * i);
          }
       }
 
       this.mc.profiler.endSection();
       if (!this.mc.skipRenderWorld) {
          anaglyphEnable = this.mc.gameSettings.anaglyph;
-         final ScaledResolution ☃xxxxxx = new ScaledResolution(this.mc);
-         int ☃xxxxxxx = ☃xxxxxx.getScaledWidth();
-         int ☃xxxxxxxx = ☃xxxxxx.getScaledHeight();
-         final int ☃xxxxxxxxx = Mouse.getX() * ☃xxxxxxx / this.mc.displayWidth;
-         final int ☃xxxxxxxxxx = ☃xxxxxxxx - Mouse.getY() * ☃xxxxxxxx / this.mc.displayHeight - 1;
-         int ☃xxxxxxxxxxx = this.mc.gameSettings.limitFramerate;
-         if (this.mc.world != null) {
+         final ScaledResolution scaledresolution = new ScaledResolution(this.mc);
+         int i1 = scaledresolution.getScaledWidth();
+         int j1 = scaledresolution.getScaledHeight();
+         final int k1 = Mouse.getX() * i1 / this.mc.displayWidth;
+         final int l1 = j1 - Mouse.getY() * j1 / this.mc.displayHeight - 1;
+         int i2 = this.mc.gameSettings.limitFramerate;
+         if (this.mc.world == null) {
+            GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+            GlStateManager.matrixMode(5889);
+            GlStateManager.loadIdentity();
+            GlStateManager.matrixMode(5888);
+            GlStateManager.loadIdentity();
+            this.setupOverlayRendering();
+            this.renderEndNanoTime = System.nanoTime();
+            TileEntityRendererDispatcher.instance.renderEngine = this.mc.getTextureManager();
+            TileEntityRendererDispatcher.instance.fontRenderer = this.mc.fontRenderer;
+         } else {
             this.mc.profiler.startSection("level");
-            int ☃xxxxxxxxxxxx = Math.min(Minecraft.getDebugFPS(), ☃xxxxxxxxxxx);
-            ☃xxxxxxxxxxxx = Math.max(☃xxxxxxxxxxxx, 60);
-            long ☃xxxxxxxxxxxxx = System.nanoTime() - ☃;
-            long ☃xxxxxxxxxxxxxx = Math.max(1000000000 / ☃xxxxxxxxxxxx / 4 - ☃xxxxxxxxxxxxx, 0L);
-            this.renderWorld(☃, System.nanoTime() + ☃xxxxxxxxxxxxxx);
+            int j = Math.min(Minecraft.getDebugFPS(), i2);
+            j = Math.max(j, 60);
+            long k = System.nanoTime() - nanoTime;
+            long l = Math.max(1000000000 / j / 4 - k, 0L);
+            this.renderWorld(partialTicks, System.nanoTime() + l);
             if (this.mc.isSingleplayer() && this.timeWorldIcon < Minecraft.getSystemTime() - 1000L) {
                this.timeWorldIcon = Minecraft.getSystemTime();
                if (!this.mc.getIntegratedServer().isWorldIconSet()) {
@@ -900,7 +1081,7 @@ public void updateCameraAndRender(float var1, long var2) {
                   GlStateManager.matrixMode(5890);
                   GlStateManager.pushMatrix();
                   GlStateManager.loadIdentity();
-                  this.shaderGroup.render(☃);
+                  this.shaderGroup.render(partialTicks);
                   GlStateManager.popMatrix();
                }
 
@@ -912,87 +1093,98 @@ public void updateCameraAndRender(float var1, long var2) {
             if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null) {
                GlStateManager.alphaFunc(516, 0.1F);
                this.setupOverlayRendering();
-               this.renderItemActivation(☃xxxxxxx, ☃xxxxxxxx, ☃);
-               this.mc.ingameGUI.renderGameOverlay(☃);
+               this.renderItemActivation(i1, j1, partialTicks);
+               this.mc.ingameGUI.renderGameOverlay(partialTicks);
+               if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo) {
+                  Config.drawFps();
+               }
+
+               if (this.mc.gameSettings.showDebugInfo) {
+                  Lagometer.showLagometer(scaledresolution);
+               }
             }
 
             this.mc.profiler.endSection();
-         } else {
-            GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            GlStateManager.matrixMode(5888);
-            GlStateManager.loadIdentity();
-            this.setupOverlayRendering();
-            this.renderEndNanoTime = System.nanoTime();
          }
 
          if (this.mc.currentScreen != null) {
             GlStateManager.clear(256);
 
             try {
-               this.mc.currentScreen.drawScreen(☃xxxxxxxxx, ☃xxxxxxxxxx, this.mc.getTickLength());
+               if (Reflector.ForgeHooksClient_drawScreen.exists()) {
+                  Reflector.callVoid(Reflector.ForgeHooksClient_drawScreen, new Object[]{this.mc.currentScreen, k1, l1, this.mc.getTickLength()});
+               } else {
+                  this.mc.currentScreen.drawScreen(k1, l1, this.mc.getTickLength());
+               }
             } catch (Throwable var16) {
-               CrashReport ☃xxxxxxxxxxxxxxx = CrashReport.makeCrashReport(var16, "Rendering screen");
-               CrashReportCategory ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx.makeCategory("Screen render details");
-               ☃xxxxxxxxxxxxxxxx.addDetail("Screen name", new ICrashReportDetail<String>() {
+               CrashReport crashreport = CrashReport.makeCrashReport(var16, "Rendering screen");
+               CrashReportCategory crashreportcategory = crashreport.makeCategory("Screen render details");
+               crashreportcategory.addDetail("Screen name", new ICrashReportDetail<String>() {
                   public String call() throws Exception {
                      return EntityRenderer.this.mc.currentScreen.getClass().getCanonicalName();
                   }
                });
-               ☃xxxxxxxxxxxxxxxx.addDetail("Mouse location", new ICrashReportDetail<String>() {
+               crashreportcategory.addDetail("Mouse location", new ICrashReportDetail<String>() {
                   public String call() throws Exception {
-                     return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", ☃, ☃, Mouse.getX(), Mouse.getY());
+                     return String.format("Scaled: (%d, %d). Absolute: (%d, %d)", k1, l1, Mouse.getX(), Mouse.getY());
                   }
                });
-               ☃xxxxxxxxxxxxxxxx.addDetail(
+               crashreportcategory.addDetail(
                   "Screen size",
                   new ICrashReportDetail<String>() {
                      public String call() throws Exception {
                         return String.format(
                            "Scaled: (%d, %d). Absolute: (%d, %d). Scale factor of %d",
-                           ☃.getScaledWidth(),
-                           ☃.getScaledHeight(),
+                           scaledresolution.getScaledWidth(),
+                           scaledresolution.getScaledHeight(),
                            EntityRenderer.this.mc.displayWidth,
                            EntityRenderer.this.mc.displayHeight,
-                           ☃.getScaleFactor()
+                           scaledresolution.getScaleFactor()
                         );
                      }
                   }
                );
-               throw new ReportedException(☃xxxxxxxxxxxxxxx);
+               throw new ReportedException(crashreport);
             }
          }
       }
+
+      this.frameFinish();
+      this.waitForServerThread();
+      MemoryMonitor.update();
+      Lagometer.updateLagometer();
+      if (this.mc.gameSettings.ofProfiler) {
+         this.mc.gameSettings.showDebugProfilerChart = true;
+      }
    }
 
    private void createWorldIcon() {
       if (this.mc.renderGlobal.getRenderedChunks() > 10 && this.mc.renderGlobal.hasNoChunkUpdates() && !this.mc.getIntegratedServer().isWorldIconSet()) {
-         BufferedImage ☃ = ScreenShotHelper.createScreenshot(this.mc.displayWidth, this.mc.displayHeight, this.mc.getFramebuffer());
-         int ☃x = ☃.getWidth();
-         int ☃xx = ☃.getHeight();
-         int ☃xxx = 0;
-         int ☃xxxx = 0;
-         if (☃x > ☃xx) {
-            ☃xxx = (☃x - ☃xx) / 2;
-            ☃x = ☃xx;
+         BufferedImage bufferedimage = ScreenShotHelper.createScreenshot(this.mc.displayWidth, this.mc.displayHeight, this.mc.getFramebuffer());
+         int i = bufferedimage.getWidth();
+         int j = bufferedimage.getHeight();
+         int k = 0;
+         int l = 0;
+         if (i > j) {
+            k = (i - j) / 2;
+            i = j;
          } else {
-            ☃xxxx = (☃xx - ☃x) / 2;
+            l = (j - i) / 2;
          }
 
          try {
-            BufferedImage ☃xxxxx = new BufferedImage(64, 64, 1);
-            Graphics ☃xxxxxx = ☃xxxxx.createGraphics();
-            ☃xxxxxx.drawImage(☃, 0, 0, 64, 64, ☃xxx, ☃xxxx, ☃xxx + ☃x, ☃xxxx + ☃x, null);
-            ☃xxxxxx.dispose();
-            ImageIO.write(☃xxxxx, "png", this.mc.getIntegratedServer().getWorldIconFile());
+            BufferedImage bufferedimage1 = new BufferedImage(64, 64, 1);
+            Graphics graphics = bufferedimage1.createGraphics();
+            graphics.drawImage(bufferedimage, 0, 0, 64, 64, k, l, k + i, l + i, (ImageObserver)null);
+            graphics.dispose();
+            ImageIO.write(bufferedimage1, "png", this.mc.getIntegratedServer().getWorldIconFile());
          } catch (IOException var8) {
             LOGGER.warn("Couldn't save auto screenshot", var8);
          }
       }
    }
 
-   public void renderStreamIndicator(float var1) {
+   public void renderStreamIndicator(float partialTicks) {
       this.setupOverlayRendering();
    }
 
@@ -1000,115 +1192,191 @@ private boolean isDrawBlockOutline() {
       if (!this.drawBlockOutline) {
          return false;
       } else {
-         Entity ☃ = this.mc.getRenderViewEntity();
-         boolean ☃x = ☃ instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
-         if (☃x && !((EntityPlayer)☃).capabilities.allowEdit) {
-            ItemStack ☃xx = ((EntityPlayer)☃).getHeldItemMainhand();
-            if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK) {
-               BlockPos ☃xxx = this.mc.objectMouseOver.getBlockPos();
-               Block ☃xxxx = this.mc.world.getBlockState(☃xxx).getBlock();
+         Entity entity = this.mc.getRenderViewEntity();
+         boolean flag = entity instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
+         if (flag && !((EntityPlayer)entity).capabilities.allowEdit) {
+            ItemStack itemstack = ((EntityPlayer)entity).getHeldItemMainhand();
+            if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK) {
+               BlockPos blockpos = this.mc.objectMouseOver.getBlockPos();
+               IBlockState state = this.mc.world.getBlockState(blockpos);
+               Block block = state.getBlock();
                if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR) {
-                  ☃x = ☃xxxx.hasTileEntity() && this.mc.world.getTileEntity(☃xxx) instanceof IInventory;
+                  flag = ReflectorForge.blockHasTileEntity(state) && this.mc.world.getTileEntity(blockpos) instanceof IInventory;
                } else {
-                  ☃x = !☃xx.isEmpty() && (☃xx.canDestroy(☃xxxx) || ☃xx.canPlaceOn(☃xxxx));
+                  flag = !itemstack.isEmpty() && (itemstack.canDestroy(block) || itemstack.canPlaceOn(block));
                }
             }
          }
 
-         return ☃x;
+         return flag;
       }
    }
 
-   public void renderWorld(float var1, long var2) {
-      this.updateLightmap(☃);
+   public void renderWorld(float partialTicks, long finishTimeNano) {
+      this.updateLightmap(partialTicks);
       if (this.mc.getRenderViewEntity() == null) {
          this.mc.setRenderViewEntity(this.mc.player);
       }
 
-      this.getMouseOver(☃);
+      this.getMouseOver(partialTicks);
+      if (Config.isShaders()) {
+         Shaders.beginRender(this.mc, partialTicks, finishTimeNano);
+      }
+
       GlStateManager.enableDepth();
       GlStateManager.enableAlpha();
-      GlStateManager.alphaFunc(516, 0.5F);
+      GlStateManager.alphaFunc(516, 0.1F);
       this.mc.profiler.startSection("center");
       if (this.mc.gameSettings.anaglyph) {
          anaglyphField = 0;
          GlStateManager.colorMask(false, true, true, false);
-         this.renderWorldPass(0, ☃, ☃);
+         this.renderWorldPass(0, partialTicks, finishTimeNano);
          anaglyphField = 1;
          GlStateManager.colorMask(true, false, false, false);
-         this.renderWorldPass(1, ☃, ☃);
+         this.renderWorldPass(1, partialTicks, finishTimeNano);
          GlStateManager.colorMask(true, true, true, false);
       } else {
-         this.renderWorldPass(2, ☃, ☃);
+         this.renderWorldPass(2, partialTicks, finishTimeNano);
       }
 
       this.mc.profiler.endSection();
    }
 
-   private void renderWorldPass(int var1, float var2, long var3) {
-      RenderGlobal ☃ = this.mc.renderGlobal;
-      ParticleManager ☃x = this.mc.effectRenderer;
-      boolean ☃xx = this.isDrawBlockOutline();
+   private void renderWorldPass(int pass, float partialTicks, long finishTimeNano) {
+      boolean isShaders = Config.isShaders();
+      if (isShaders) {
+         Shaders.beginRenderPass(pass, partialTicks, finishTimeNano);
+      }
+
+      RenderGlobal renderglobal = this.mc.renderGlobal;
+      ParticleManager particlemanager = this.mc.effectRenderer;
+      boolean flag = this.isDrawBlockOutline();
       GlStateManager.enableCull();
       this.mc.profiler.endStartSection("clear");
-      GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-      this.updateFogColor(☃);
+      if (isShaders) {
+         Shaders.setViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+      } else {
+         GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+      }
+
+      this.updateFogColor(partialTicks);
       GlStateManager.clear(16640);
+      if (isShaders) {
+         Shaders.clearRenderBuffer();
+      }
+
       this.mc.profiler.endStartSection("camera");
-      this.setupCameraTransform(☃, ☃);
-      ActiveRenderInfo.updateRenderInfo(this.mc.player, this.mc.gameSettings.thirdPersonView == 2);
+      this.setupCameraTransform(partialTicks, pass);
+      if (isShaders) {
+         Shaders.setCamera(partialTicks);
+      }
+
+      if (Reflector.ActiveRenderInfo_updateRenderInfo2.exists()) {
+         Reflector.call(Reflector.ActiveRenderInfo_updateRenderInfo2, new Object[]{this.mc.getRenderViewEntity(), this.mc.gameSettings.thirdPersonView == 2});
+      } else {
+         ActiveRenderInfo.updateRenderInfo(this.mc.player, this.mc.gameSettings.thirdPersonView == 2);
+      }
+
       this.mc.profiler.endStartSection("frustum");
-      ClippingHelperImpl.getInstance();
+      ClippingHelper clippingHelper = ClippingHelperImpl.getInstance();
       this.mc.profiler.endStartSection("culling");
-      ICamera ☃xxx = new Frustum();
-      Entity ☃xxxx = this.mc.getRenderViewEntity();
-      double ☃xxxxx = ☃xxxx.lastTickPosX + (☃xxxx.posX - ☃xxxx.lastTickPosX) * ☃;
-      double ☃xxxxxx = ☃xxxx.lastTickPosY + (☃xxxx.posY - ☃xxxx.lastTickPosY) * ☃;
-      double ☃xxxxxxx = ☃xxxx.lastTickPosZ + (☃xxxx.posZ - ☃xxxx.lastTickPosZ) * ☃;
-      ☃xxx.setPosition(☃xxxxx, ☃xxxxxx, ☃xxxxxxx);
-      if (this.mc.gameSettings.renderDistanceChunks >= 4) {
-         this.setupFog(-1, ☃);
+      clippingHelper.disabled = Config.isShaders() && !Shaders.isFrustumCulling();
+      ICamera icamera = new Frustum(clippingHelper);
+      Entity entity = this.mc.getRenderViewEntity();
+      double d0 = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * partialTicks;
+      double d1 = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * partialTicks;
+      double d2 = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * partialTicks;
+      if (isShaders) {
+         ShadersRender.setFrustrumPosition(icamera, d0, d1, d2);
+      } else {
+         icamera.setPosition(d0, d1, d2);
+      }
+
+      if ((Config.isSkyEnabled() || Config.isSunMoonEnabled() || Config.isStarsEnabled()) && !Shaders.isShadowPass) {
+         this.setupFog(-1, partialTicks);
          this.mc.profiler.endStartSection("sky");
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(this.getFOVModifier(☃, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+         Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
-         ☃.renderSky(☃, ☃);
+         if (isShaders) {
+            Shaders.beginSky();
+         }
+
+         renderglobal.renderSky(partialTicks, pass);
+         if (isShaders) {
+            Shaders.endSky();
+         }
+
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(
-            this.getFOVModifier(☃, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-         );
+         Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
+      } else {
+         GlStateManager.disableBlend();
       }
 
-      this.setupFog(0, ☃);
+      this.setupFog(0, partialTicks);
       GlStateManager.shadeModel(7425);
-      if (☃xxxx.posY + ☃xxxx.getEyeHeight() < 128.0) {
-         this.renderCloudsCheck(☃, ☃, ☃, ☃xxxxx, ☃xxxxxx, ☃xxxxxxx);
+      if (entity.posY + entity.getEyeHeight() < 128.0 + this.mc.gameSettings.ofCloudsHeight * 128.0F) {
+         this.renderCloudsCheck(renderglobal, partialTicks, pass, d0, d1, d2);
       }
 
       this.mc.profiler.endStartSection("prepareterrain");
-      this.setupFog(0, ☃);
+      this.setupFog(0, partialTicks);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       RenderHelper.disableStandardItemLighting();
       this.mc.profiler.endStartSection("terrain_setup");
-      ☃.setupTerrain(☃xxxx, ☃, ☃xxx, this.frameCount++, this.mc.player.isSpectator());
-      if (☃ == 0 || ☃ == 2) {
+      this.checkLoadVisibleChunks(entity, partialTicks, icamera, this.mc.player.isSpectator());
+      if (isShaders) {
+         ShadersRender.setupTerrain(renderglobal, entity, partialTicks, icamera, this.frameCount++, this.mc.player.isSpectator());
+      } else {
+         renderglobal.setupTerrain(entity, partialTicks, icamera, this.frameCount++, this.mc.player.isSpectator());
+      }
+
+      if (pass == 0 || pass == 2) {
          this.mc.profiler.endStartSection("updatechunks");
-         this.mc.renderGlobal.updateChunks(☃);
+         Lagometer.timerChunkUpload.start();
+         this.mc.renderGlobal.updateChunks(finishTimeNano);
+         Lagometer.timerChunkUpload.end();
       }
 
       this.mc.profiler.endStartSection("terrain");
+      Lagometer.timerTerrain.start();
+      if (this.mc.gameSettings.ofSmoothFps && pass > 0) {
+         this.mc.profiler.endStartSection("finish");
+         GL11.glFinish();
+         this.mc.profiler.endStartSection("terrain");
+      }
+
       GlStateManager.matrixMode(5888);
       GlStateManager.pushMatrix();
       GlStateManager.disableAlpha();
-      ☃.renderBlockLayer(BlockRenderLayer.SOLID, ☃, ☃, ☃xxxx);
+      if (isShaders) {
+         ShadersRender.beginTerrainSolid();
+      }
+
+      renderglobal.renderBlockLayer(BlockRenderLayer.SOLID, partialTicks, pass, entity);
       GlStateManager.enableAlpha();
-      ☃.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, ☃, ☃, ☃xxxx);
+      if (isShaders) {
+         ShadersRender.beginTerrainCutoutMipped();
+      }
+
+      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, this.mc.gameSettings.mipmapLevels > 0);
+      renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, partialTicks, pass, entity);
+      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
       this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-      ☃.renderBlockLayer(BlockRenderLayer.CUTOUT, ☃, ☃, ☃xxxx);
+      if (isShaders) {
+         ShadersRender.beginTerrainCutout();
+      }
+
+      renderglobal.renderBlockLayer(BlockRenderLayer.CUTOUT, partialTicks, pass, entity);
       this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      if (isShaders) {
+         ShadersRender.endTerrain();
+      }
+
+      Lagometer.timerTerrain.end();
       GlStateManager.shadeModel(7424);
       GlStateManager.alphaFunc(516, 0.1F);
       if (!this.debugView) {
@@ -1117,166 +1385,256 @@ private void renderWorldPass(int var1, float var2, long var3) {
          GlStateManager.pushMatrix();
          RenderHelper.enableStandardItemLighting();
          this.mc.profiler.endStartSection("entities");
-         ☃.renderEntities(☃xxxx, ☃xxx, ☃);
+         if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{0});
+         }
+
+         renderglobal.renderEntities(entity, icamera, partialTicks);
+         if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{-1});
+         }
+
          RenderHelper.disableStandardItemLighting();
          this.disableLightmap();
       }
 
       GlStateManager.matrixMode(5888);
       GlStateManager.popMatrix();
-      if (☃xx && this.mc.objectMouseOver != null && !☃xxxx.isInsideOfMaterial(Material.WATER)) {
-         EntityPlayer ☃xxxxxxxx = (EntityPlayer)☃xxxx;
+      if (flag && this.mc.objectMouseOver != null && !entity.isInsideOfMaterial(Material.WATER)) {
+         EntityPlayer entityplayer = (EntityPlayer)entity;
          GlStateManager.disableAlpha();
          this.mc.profiler.endStartSection("outline");
-         ☃.drawSelectionBox(☃xxxxxxxx, this.mc.objectMouseOver, 0, ☃);
+         if (!Reflector.ForgeHooksClient_onDrawBlockHighlight.exists()
+            || !Reflector.callBoolean(
+               Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[]{renderglobal, entityplayer, this.mc.objectMouseOver, 0, partialTicks}
+            )) {
+            renderglobal.drawSelectionBox(entityplayer, this.mc.objectMouseOver, 0, partialTicks);
+         }
+
          GlStateManager.enableAlpha();
       }
 
       if (this.mc.debugRenderer.shouldRender()) {
-         this.mc.debugRenderer.renderDebug(☃, ☃);
+         boolean preDebugFog = GlStateManager.isFogEnabled();
+         GlStateManager.disableFog();
+         this.mc.debugRenderer.renderDebug(partialTicks, finishTimeNano);
+         GlStateManager.setFogEnabled(preDebugFog);
       }
 
-      this.mc.profiler.endStartSection("destroyProgress");
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-      ☃.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), ☃xxxx, ☃);
-      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      if (!renderglobal.damagedBlocks.isEmpty()) {
+         this.mc.profiler.endStartSection("destroyProgress");
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
+         );
+         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
+         renderglobal.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), entity, partialTicks);
+         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+         GlStateManager.disableBlend();
+      }
+
+      GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
       GlStateManager.disableBlend();
       if (!this.debugView) {
          this.enableLightmap();
          this.mc.profiler.endStartSection("litParticles");
-         ☃x.renderLitParticles(☃xxxx, ☃);
+         if (isShaders) {
+            Shaders.beginLitParticles();
+         }
+
+         particlemanager.renderLitParticles(entity, partialTicks);
          RenderHelper.disableStandardItemLighting();
-         this.setupFog(0, ☃);
+         this.setupFog(0, partialTicks);
          this.mc.profiler.endStartSection("particles");
-         ☃x.renderParticles(☃xxxx, ☃);
+         if (isShaders) {
+            Shaders.beginParticles();
+         }
+
+         particlemanager.renderParticles(entity, partialTicks);
+         if (isShaders) {
+            Shaders.endParticles();
+         }
+
          this.disableLightmap();
       }
 
       GlStateManager.depthMask(false);
+      if (Config.isShaders()) {
+         GlStateManager.depthMask(Shaders.isRainDepth());
+      }
+
       GlStateManager.enableCull();
       this.mc.profiler.endStartSection("weather");
-      this.renderRainSnow(☃);
+      if (isShaders) {
+         Shaders.beginWeather();
+      }
+
+      this.renderRainSnow(partialTicks);
+      if (isShaders) {
+         Shaders.endWeather();
+      }
+
       GlStateManager.depthMask(true);
-      ☃.renderWorldBorder(☃xxxx, ☃);
+      renderglobal.renderWorldBorder(entity, partialTicks);
+      if (isShaders) {
+         ShadersRender.renderHand0(this, partialTicks, pass);
+         Shaders.preWater();
+      }
+
       GlStateManager.disableBlend();
       GlStateManager.enableCull();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.alphaFunc(516, 0.1F);
-      this.setupFog(0, ☃);
+      this.setupFog(0, partialTicks);
       GlStateManager.enableBlend();
       GlStateManager.depthMask(false);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       GlStateManager.shadeModel(7425);
       this.mc.profiler.endStartSection("translucent");
-      ☃.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, ☃, ☃, ☃xxxx);
+      if (isShaders) {
+         Shaders.beginWater();
+      }
+
+      renderglobal.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, partialTicks, pass, entity);
+      if (isShaders) {
+         Shaders.endWater();
+      }
+
+      if (Reflector.ForgeHooksClient_setRenderPass.exists() && !this.debugView) {
+         RenderHelper.enableStandardItemLighting();
+         this.mc.profiler.endStartSection("entities");
+         Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{1});
+         this.mc.renderGlobal.renderEntities(entity, icamera, partialTicks);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{-1});
+         RenderHelper.disableStandardItemLighting();
+      }
+
       GlStateManager.shadeModel(7424);
       GlStateManager.depthMask(true);
       GlStateManager.enableCull();
       GlStateManager.disableBlend();
       GlStateManager.disableFog();
-      if (☃xxxx.posY + ☃xxxx.getEyeHeight() >= 128.0) {
+      if (entity.posY + entity.getEyeHeight() >= 128.0 + this.mc.gameSettings.ofCloudsHeight * 128.0F) {
          this.mc.profiler.endStartSection("aboveClouds");
-         this.renderCloudsCheck(☃, ☃, ☃, ☃xxxxx, ☃xxxxxx, ☃xxxxxxx);
+         this.renderCloudsCheck(renderglobal, partialTicks, pass, d0, d1, d2);
+      }
+
+      if (Reflector.ForgeHooksClient_dispatchRenderLast.exists()) {
+         this.mc.profiler.endStartSection("forge_render_last");
+         Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[]{renderglobal, partialTicks});
       }
 
       this.mc.profiler.endStartSection("hand");
-      if (this.renderHand) {
+      if (this.renderHand && !Shaders.isShadowPass) {
+         if (isShaders) {
+            ShadersRender.renderHand1(this, partialTicks, pass);
+            Shaders.renderCompositeFinal();
+         }
+
          GlStateManager.clear(256);
-         this.renderHand(☃, ☃);
+         if (isShaders) {
+            ShadersRender.renderFPOverlay(this, partialTicks, pass);
+         } else {
+            this.renderHand(partialTicks, pass);
+         }
+      }
+
+      if (isShaders) {
+         Shaders.endRender();
       }
    }
 
-   private void renderCloudsCheck(RenderGlobal var1, float var2, int var3, double var4, double var6, double var8) {
-      if (this.mc.gameSettings.shouldRenderClouds() != 0) {
+   private void renderCloudsCheck(RenderGlobal renderGlobalIn, float partialTicks, int pass, double x, double y, double z) {
+      if (this.mc.gameSettings.renderDistanceChunks >= 4 && !Config.isCloudsOff() && Shaders.shouldRenderClouds(this.mc.gameSettings)) {
          this.mc.profiler.endStartSection("clouds");
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(this.getFOVModifier(☃, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 4.0F);
+         Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance * 4.0F);
          GlStateManager.matrixMode(5888);
          GlStateManager.pushMatrix();
-         this.setupFog(0, ☃);
-         ☃.renderClouds(☃, ☃, ☃, ☃, ☃);
+         this.setupFog(0, partialTicks);
+         renderGlobalIn.renderClouds(partialTicks, pass, x, y, z);
          GlStateManager.disableFog();
          GlStateManager.popMatrix();
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(
-            this.getFOVModifier(☃, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-         );
+         Project.gluPerspective(this.getFOVModifier(partialTicks, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
       }
    }
 
    private void addRainParticles() {
-      float ☃ = this.mc.world.getRainStrength(1.0F);
-      if (!this.mc.gameSettings.fancyGraphics) {
-         ☃ /= 2.0F;
+      float f = this.mc.world.getRainStrength(1.0F);
+      if (!Config.isRainFancy()) {
+         f /= 2.0F;
       }
 
-      if (☃ != 0.0F) {
+      if (f != 0.0F && Config.isRainSplash()) {
          this.random.setSeed(this.rendererUpdateCount * 312987231L);
-         Entity ☃x = this.mc.getRenderViewEntity();
-         World ☃xx = this.mc.world;
-         BlockPos ☃xxx = new BlockPos(☃x);
-         int ☃xxxx = 10;
-         double ☃xxxxx = 0.0;
-         double ☃xxxxxx = 0.0;
-         double ☃xxxxxxx = 0.0;
-         int ☃xxxxxxxx = 0;
-         int ☃xxxxxxxxx = (int)(100.0F * ☃ * ☃);
+         Entity entity = this.mc.getRenderViewEntity();
+         World world = this.mc.world;
+         BlockPos blockpos = new BlockPos(entity);
+         int i = 10;
+         double d0 = 0.0;
+         double d1 = 0.0;
+         double d2 = 0.0;
+         int j = 0;
+         int k = (int)(100.0F * f * f);
          if (this.mc.gameSettings.particleSetting == 1) {
-            ☃xxxxxxxxx >>= 1;
+            k >>= 1;
          } else if (this.mc.gameSettings.particleSetting == 2) {
-            ☃xxxxxxxxx = 0;
+            k = 0;
          }
 
-         for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx < ☃xxxxxxxxx; ☃xxxxxxxxxx++) {
-            BlockPos ☃xxxxxxxxxxx = ☃xx.getPrecipitationHeight(
-               ☃xxx.add(this.random.nextInt(10) - this.random.nextInt(10), 0, this.random.nextInt(10) - this.random.nextInt(10))
+         for (int l = 0; l < k; l++) {
+            BlockPos blockpos1 = world.getPrecipitationHeight(
+               blockpos.add(this.random.nextInt(10) - this.random.nextInt(10), 0, this.random.nextInt(10) - this.random.nextInt(10))
             );
-            Biome ☃xxxxxxxxxxxx = ☃xx.getBiome(☃xxxxxxxxxxx);
-            BlockPos ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxx.down();
-            IBlockState ☃xxxxxxxxxxxxxx = ☃xx.getBlockState(☃xxxxxxxxxxxxx);
-            if (☃xxxxxxxxxxx.getY() <= ☃xxx.getY() + 10
-               && ☃xxxxxxxxxxx.getY() >= ☃xxx.getY() - 10
-               && ☃xxxxxxxxxxxx.canRain()
-               && ☃xxxxxxxxxxxx.getTemperature(☃xxxxxxxxxxx) >= 0.15F) {
-               double ☃xxxxxxxxxxxxxxx = this.random.nextDouble();
-               double ☃xxxxxxxxxxxxxxxx = this.random.nextDouble();
-               AxisAlignedBB ☃xxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxx.getBoundingBox(☃xx, ☃xxxxxxxxxxxxx);
-               if (☃xxxxxxxxxxxxxx.getMaterial() == Material.LAVA || ☃xxxxxxxxxxxxxx.getBlock() == Blocks.MAGMA) {
+            Biome biome = world.getBiome(blockpos1);
+            BlockPos blockpos2 = blockpos1.down();
+            IBlockState iblockstate = world.getBlockState(blockpos2);
+            if (blockpos1.getY() <= blockpos.getY() + 10
+               && blockpos1.getY() >= blockpos.getY() - 10
+               && biome.canRain()
+               && biome.getTemperature(blockpos1) >= 0.15F) {
+               double d3 = this.random.nextDouble();
+               double d4 = this.random.nextDouble();
+               AxisAlignedBB axisalignedbb = iblockstate.e(world, blockpos2);
+               if (iblockstate.a() == Material.LAVA || iblockstate.getBlock() == Blocks.MAGMA) {
                   this.mc
                      .world
                      .spawnParticle(
                         EnumParticleTypes.SMOKE_NORMAL,
-                        ☃xxxxxxxxxxx.getX() + ☃xxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxx.getY() + 0.1F - ☃xxxxxxxxxxxxxxxxx.minY,
-                        ☃xxxxxxxxxxx.getZ() + ☃xxxxxxxxxxxxxxxx,
+                        blockpos1.getX() + d3,
+                        blockpos1.getY() + 0.1F - axisalignedbb.minY,
+                        blockpos1.getZ() + d4,
                         0.0,
                         0.0,
                         0.0,
                         new int[0]
                      );
-               } else if (☃xxxxxxxxxxxxxx.getMaterial() != Material.AIR) {
-                  if (this.random.nextInt(++☃xxxxxxxx) == 0) {
-                     ☃xxxxx = ☃xxxxxxxxxxxxx.getX() + ☃xxxxxxxxxxxxxxx;
-                     ☃xxxxxx = ☃xxxxxxxxxxxxx.getY() + 0.1F + ☃xxxxxxxxxxxxxxxxx.maxY - 1.0;
-                     ☃xxxxxxx = ☃xxxxxxxxxxxxx.getZ() + ☃xxxxxxxxxxxxxxxx;
+               } else if (iblockstate.a() != Material.AIR) {
+                  if (this.random.nextInt(++j) == 0) {
+                     d0 = blockpos2.getX() + d3;
+                     d1 = blockpos2.getY() + 0.1F + axisalignedbb.maxY - 1.0;
+                     d2 = blockpos2.getZ() + d4;
                   }
 
                   this.mc
                      .world
                      .spawnParticle(
                         EnumParticleTypes.WATER_DROP,
-                        ☃xxxxxxxxxxxxx.getX() + ☃xxxxxxxxxxxxxxx,
-                        ☃xxxxxxxxxxxxx.getY() + 0.1F + ☃xxxxxxxxxxxxxxxxx.maxY,
-                        ☃xxxxxxxxxxxxx.getZ() + ☃xxxxxxxxxxxxxxxx,
+                        blockpos2.getX() + d3,
+                        blockpos2.getY() + 0.1F + axisalignedbb.maxY,
+                        blockpos2.getZ() + d4,
                         0.0,
                         0.0,
                         0.0,
@@ -1286,28 +1644,41 @@ private void addRainParticles() {
             }
          }
 
-         if (☃xxxxxxxx > 0 && this.random.nextInt(3) < this.rainSoundCounter++) {
+         if (j > 0 && this.random.nextInt(3) < this.rainSoundCounter++) {
             this.rainSoundCounter = 0;
-            if (☃xxxxxx > ☃xxx.getY() + 1 && ☃xx.getPrecipitationHeight(☃xxx).getY() > MathHelper.floor((float)☃xxx.getY())) {
-               this.mc.world.playSound(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, SoundEvents.WEATHER_RAIN_ABOVE, SoundCategory.WEATHER, 0.1F, 0.5F, false);
+            if (d1 > blockpos.getY() + 1 && world.getPrecipitationHeight(blockpos).getY() > MathHelper.floor((float)blockpos.getY())) {
+               this.mc.world.playSound(d0, d1, d2, SoundEvents.WEATHER_RAIN_ABOVE, SoundCategory.WEATHER, 0.1F, 0.5F, false);
             } else {
-               this.mc.world.playSound(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, SoundEvents.WEATHER_RAIN, SoundCategory.WEATHER, 0.2F, 1.0F, false);
+               this.mc.world.playSound(d0, d1, d2, SoundEvents.WEATHER_RAIN, SoundCategory.WEATHER, 0.2F, 1.0F, false);
             }
          }
       }
    }
 
-   protected void renderRainSnow(float var1) {
-      float ☃ = this.mc.world.getRainStrength(☃);
-      if (!(☃ <= 0.0F)) {
+   protected void renderRainSnow(float partialTicks) {
+      if (Reflector.ForgeWorldProvider_getWeatherRenderer.exists()) {
+         WorldProvider worldProvider = this.mc.world.provider;
+         Object weatherRenderer = Reflector.call(worldProvider, Reflector.ForgeWorldProvider_getWeatherRenderer, new Object[0]);
+         if (weatherRenderer != null) {
+            Reflector.callVoid(weatherRenderer, Reflector.IRenderHandler_render, new Object[]{partialTicks, this.mc.world, this.mc});
+            return;
+         }
+      }
+
+      float f = this.mc.world.getRainStrength(partialTicks);
+      if (f > 0.0F) {
+         if (Config.isRainOff()) {
+            return;
+         }
+
          this.enableLightmap();
-         Entity ☃x = this.mc.getRenderViewEntity();
-         World ☃xx = this.mc.world;
-         int ☃xxx = MathHelper.floor(☃x.posX);
-         int ☃xxxx = MathHelper.floor(☃x.posY);
-         int ☃xxxxx = MathHelper.floor(☃x.posZ);
-         Tessellator ☃xxxxxx = Tessellator.getInstance();
-         BufferBuilder ☃xxxxxxx = ☃xxxxxx.getBuffer();
+         Entity entity = this.mc.getRenderViewEntity();
+         World world = this.mc.world;
+         int i = MathHelper.floor(entity.posX);
+         int j = MathHelper.floor(entity.posY);
+         int k = MathHelper.floor(entity.posZ);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
          GlStateManager.disableCull();
          GlStateManager.glNormal3f(0.0F, 1.0F, 0.0F);
          GlStateManager.enableBlend();
@@ -1318,176 +1689,116 @@ protected void renderRainSnow(float var1) {
             GlStateManager.DestFactor.ZERO
          );
          GlStateManager.alphaFunc(516, 0.1F);
-         double ☃xxxxxxxx = ☃x.lastTickPosX + (☃x.posX - ☃x.lastTickPosX) * ☃;
-         double ☃xxxxxxxxx = ☃x.lastTickPosY + (☃x.posY - ☃x.lastTickPosY) * ☃;
-         double ☃xxxxxxxxxx = ☃x.lastTickPosZ + (☃x.posZ - ☃x.lastTickPosZ) * ☃;
-         int ☃xxxxxxxxxxx = MathHelper.floor(☃xxxxxxxxx);
-         int ☃xxxxxxxxxxxx = 5;
-         if (this.mc.gameSettings.fancyGraphics) {
-            ☃xxxxxxxxxxxx = 10;
-         }
-
-         int ☃xxxxxxxxxxxxx = -1;
-         float ☃xxxxxxxxxxxxxx = this.rendererUpdateCount + ☃;
-         ☃xxxxxxx.setTranslation(-☃xxxxxxxx, -☃xxxxxxxxx, -☃xxxxxxxxxx);
+         double d0 = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * partialTicks;
+         double d1 = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * partialTicks;
+         double d2 = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * partialTicks;
+         int l = MathHelper.floor(d1);
+         int i1 = 5;
+         if (Config.isRainFancy()) {
+            i1 = 10;
+         }
+
+         int j1 = -1;
+         float f1 = this.rendererUpdateCount + partialTicks;
+         bufferbuilder.setTranslation(-d0, -d1, -d2);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         BlockPos.MutableBlockPos ☃xxxxxxxxxxxxxxx = new BlockPos.MutableBlockPos();
-
-         for (int ☃xxxxxxxxxxxxxxxx = ☃xxxxx - ☃xxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxx <= ☃xxxxx + ☃xxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxx++) {
-            for (int ☃xxxxxxxxxxxxxxxxx = ☃xxx - ☃xxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxx <= ☃xxx + ☃xxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxx++) {
-               int ☃xxxxxxxxxxxxxxxxxx = (☃xxxxxxxxxxxxxxxx - ☃xxxxx + 16) * 32 + ☃xxxxxxxxxxxxxxxxx - ☃xxx + 16;
-               double ☃xxxxxxxxxxxxxxxxxxx = this.rainXCoords[☃xxxxxxxxxxxxxxxxxx] * 0.5;
-               double ☃xxxxxxxxxxxxxxxxxxxx = this.rainYCoords[☃xxxxxxxxxxxxxxxxxx] * 0.5;
-               ☃xxxxxxxxxxxxxxx.setPos(☃xxxxxxxxxxxxxxxxx, 0, ☃xxxxxxxxxxxxxxxx);
-               Biome ☃xxxxxxxxxxxxxxxxxxxxx = ☃xx.getBiome(☃xxxxxxxxxxxxxxx);
-               if (☃xxxxxxxxxxxxxxxxxxxxx.canRain() || ☃xxxxxxxxxxxxxxxxxxxxx.getEnableSnow()) {
-                  int ☃xxxxxxxxxxxxxxxxxxxxxx = ☃xx.getPrecipitationHeight(☃xxxxxxxxxxxxxxx).getY();
-                  int ☃xxxxxxxxxxxxxxxxxxxxxxx = ☃xxxx - ☃xxxxxxxxxxxx;
-                  int ☃xxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxx + ☃xxxxxxxxxxxx;
-                  if (☃xxxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxxxxxxx) {
-                     ☃xxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx;
+         MutableBlockPos blockpos$mutableblockpos = new MutableBlockPos();
+
+         for (int k1 = k - i1; k1 <= k + i1; k1++) {
+            for (int l1 = i - i1; l1 <= i + i1; l1++) {
+               int i2 = (k1 - k + 16) * 32 + l1 - i + 16;
+               double d3 = this.rainXCoords[i2] * 0.5;
+               double d4 = this.rainYCoords[i2] * 0.5;
+               blockpos$mutableblockpos.setPos(l1, 0, k1);
+               Biome biome = world.getBiome(blockpos$mutableblockpos);
+               if (biome.canRain() || biome.getEnableSnow()) {
+                  int j2 = world.getPrecipitationHeight(blockpos$mutableblockpos).getY();
+                  int k2 = j - i1;
+                  int l2 = j + i1;
+                  if (k2 < j2) {
+                     k2 = j2;
                   }
 
-                  if (☃xxxxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxxxxxxx) {
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx;
+                  if (l2 < j2) {
+                     l2 = j2;
                   }
 
-                  int ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx;
-                  if (☃xxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxx) {
-                     ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx;
+                  int i3 = j2;
+                  if (j2 < l) {
+                     i3 = l;
                   }
 
-                  if (☃xxxxxxxxxxxxxxxxxxxxxxx != ☃xxxxxxxxxxxxxxxxxxxxxxxx) {
-                     this.random
-                        .setSeed(
-                           ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx * 3121 + ☃xxxxxxxxxxxxxxxxx * 45238971
-                              ^ ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx * 418711 + ☃xxxxxxxxxxxxxxxx * 13761
-                        );
-                     ☃xxxxxxxxxxxxxxx.setPos(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx);
-                     float ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxx.getTemperature(☃xxxxxxxxxxxxxxx);
-                     if (☃xx.getBiomeProvider().getTemperatureAtHeight(☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx) >= 0.15F) {
-                        if (☃xxxxxxxxxxxxx != 0) {
-                           if (☃xxxxxxxxxxxxx >= 0) {
-                              ☃xxxxxx.draw();
+                  if (k2 != l2) {
+                     this.random.setSeed(l1 * l1 * 3121 + l1 * 45238971 ^ k1 * k1 * 418711 + k1 * 13761);
+                     blockpos$mutableblockpos.setPos(l1, k2, k1);
+                     float f2 = biome.getTemperature(blockpos$mutableblockpos);
+                     if (world.getBiomeProvider().getTemperatureAtHeight(f2, j2) >= 0.15F) {
+                        if (j1 != 0) {
+                           if (j1 >= 0) {
+                              tessellator.draw();
                            }
 
-                           ☃xxxxxxxxxxxxx = 0;
+                           j1 = 0;
                            this.mc.getTextureManager().bindTexture(RAIN_TEXTURES);
-                           ☃xxxxxxx.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
+                           bufferbuilder.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
                         }
 
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = -(
-                              (double)(
-                                    this.rendererUpdateCount
-                                          + ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx * 3121
-                                          + ☃xxxxxxxxxxxxxxxxx * 45238971
-                                          + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx * 418711
-                                          + ☃xxxxxxxxxxxxxxxx * 13761
-                                       & 31
-                                 )
-                                 + ☃
-                           )
+                        double d5 = -((double)(this.rendererUpdateCount + l1 * l1 * 3121 + l1 * 45238971 + k1 * k1 * 418711 + k1 * 13761 & 31) + partialTicks)
                            / 32.0
                            * (3.0 + this.random.nextDouble());
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx + 0.5F - ☃x.posX;
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx + 0.5F - ☃x.posZ;
-                        float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.sqrt(
-                              ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           / ☃xxxxxxxxxxxx;
-                        float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ((1.0F - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.5F + 0.5F) * ☃;
-                        ☃xxxxxxxxxxxxxxx.setPos(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx);
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xx.getCombinedLight(☃xxxxxxxxxxxxxxx, 0);
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx >> 16 & 65535;
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx & 65535;
-                        ☃xxxxxxx.pos(
-                              ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxx + 0.5
-                           )
-                           .tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .endVertex();
-                        ☃xxxxxxx.pos(
-                              ☃xxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx + 0.5
-                           )
-                           .tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .endVertex();
-                        ☃xxxxxxx.pos(☃xxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx + 0.5)
-                           .tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .endVertex();
-                        ☃xxxxxxx.pos(☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxx + 0.5)
-                           .tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .endVertex();
+                        double d6 = l1 + 0.5F - entity.posX;
+                        double d7 = k1 + 0.5F - entity.posZ;
+                        float f3 = MathHelper.sqrt(d6 * d6 + d7 * d7) / i1;
+                        float f4 = ((1.0F - f3 * f3) * 0.5F + 0.5F) * f;
+                        blockpos$mutableblockpos.setPos(l1, i3, k1);
+                        int j3 = world.getCombinedLight(blockpos$mutableblockpos, 0);
+                        int k3 = j3 >> 16 & 65535;
+                        int l3 = j3 & 65535;
+                        bufferbuilder.pos(l1 - d3 + 0.5, l2, k1 - d4 + 0.5).tex(0.0, k2 * 0.25 + d5).color(1.0F, 1.0F, 1.0F, f4).lightmap(k3, l3).endVertex();
+                        bufferbuilder.pos(l1 + d3 + 0.5, l2, k1 + d4 + 0.5).tex(1.0, k2 * 0.25 + d5).color(1.0F, 1.0F, 1.0F, f4).lightmap(k3, l3).endVertex();
+                        bufferbuilder.pos(l1 + d3 + 0.5, k2, k1 + d4 + 0.5).tex(1.0, l2 * 0.25 + d5).color(1.0F, 1.0F, 1.0F, f4).lightmap(k3, l3).endVertex();
+                        bufferbuilder.pos(l1 - d3 + 0.5, k2, k1 - d4 + 0.5).tex(0.0, l2 * 0.25 + d5).color(1.0F, 1.0F, 1.0F, f4).lightmap(k3, l3).endVertex();
                      } else {
-                        if (☃xxxxxxxxxxxxx != 1) {
-                           if (☃xxxxxxxxxxxxx >= 0) {
-                              ☃xxxxxx.draw();
+                        if (j1 != 1) {
+                           if (j1 >= 0) {
+                              tessellator.draw();
                            }
 
-                           ☃xxxxxxxxxxxxx = 1;
+                           j1 = 1;
                            this.mc.getTextureManager().bindTexture(SNOW_TEXTURES);
-                           ☃xxxxxxx.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
+                           bufferbuilder.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
                         }
 
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = -((this.rendererUpdateCount & 511) + ☃) / 512.0F;
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.random.nextDouble() + ☃xxxxxxxxxxxxxx * 0.01 * (float)this.random.nextGaussian();
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = this.random.nextDouble() + ☃xxxxxxxxxxxxxx * (float)this.random.nextGaussian() * 0.001;
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx + 0.5F - ☃x.posX;
-                        double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx + 0.5F - ☃x.posZ;
-                        float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.sqrt(
-                              ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                                 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           / ☃xxxxxxxxxxxx;
-                        float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (
-                              (1.0F - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx) * 0.3F + 0.5F
-                           )
-                           * ☃;
-                        ☃xxxxxxxxxxxxxxx.setPos(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx);
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = (☃xx.getCombinedLight(☃xxxxxxxxxxxxxxx, 0) * 3 + 15728880) / 4;
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx >> 16 & 65535;
-                        int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx & 65535;
-                        ☃xxxxxxx.pos(
-                              ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxx + 0.5
-                           )
-                           .tex(
-                              0.0 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                              ☃xxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
+                        double d8 = -((this.rendererUpdateCount & 511) + partialTicks) / 512.0F;
+                        double d9 = this.random.nextDouble() + f1 * 0.01 * (float)this.random.nextGaussian();
+                        double d10 = this.random.nextDouble() + f1 * (float)this.random.nextGaussian() * 0.001;
+                        double d11 = l1 + 0.5F - entity.posX;
+                        double d12 = k1 + 0.5F - entity.posZ;
+                        float f6 = MathHelper.sqrt(d11 * d11 + d12 * d12) / i1;
+                        float f5 = ((1.0F - f6 * f6) * 0.3F + 0.5F) * f;
+                        blockpos$mutableblockpos.setPos(l1, i3, k1);
+                        int i4 = (world.getCombinedLight(blockpos$mutableblockpos, 0) * 3 + 15728880) / 4;
+                        int j4 = i4 >> 16 & 65535;
+                        int k4 = i4 & 65535;
+                        bufferbuilder.pos(l1 - d3 + 0.5, l2, k1 - d4 + 0.5)
+                           .tex(0.0 + d9, k2 * 0.25 + d8 + d10)
+                           .color(1.0F, 1.0F, 1.0F, f5)
+                           .lightmap(j4, k4)
                            .endVertex();
-                        ☃xxxxxxx.pos(
-                              ☃xxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx + 0.5
-                           )
-                           .tex(
-                              1.0 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                              ☃xxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
+                        bufferbuilder.pos(l1 + d3 + 0.5, l2, k1 + d4 + 0.5)
+                           .tex(1.0 + d9, k2 * 0.25 + d8 + d10)
+                           .color(1.0F, 1.0F, 1.0F, f5)
+                           .lightmap(j4, k4)
                            .endVertex();
-                        ☃xxxxxxx.pos(☃xxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx + 0.5)
-                           .tex(
-                              1.0 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                              ☃xxxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
+                        bufferbuilder.pos(l1 + d3 + 0.5, k2, k1 + d4 + 0.5)
+                           .tex(1.0 + d9, l2 * 0.25 + d8 + d10)
+                           .color(1.0F, 1.0F, 1.0F, f5)
+                           .lightmap(j4, k4)
                            .endVertex();
-                        ☃xxxxxxx.pos(☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx + 0.5, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxx + 0.5)
-                           .tex(
-                              0.0 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx,
-                              ☃xxxxxxxxxxxxxxxxxxxxxxxx * 0.25 + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
-                           )
-                           .color(1.0F, 1.0F, 1.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                           .lightmap(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
+                        bufferbuilder.pos(l1 - d3 + 0.5, k2, k1 - d4 + 0.5)
+                           .tex(0.0 + d9, l2 * 0.25 + d8 + d10)
+                           .color(1.0F, 1.0F, 1.0F, f5)
+                           .lightmap(j4, k4)
                            .endVertex();
                      }
                   }
@@ -1495,11 +1806,11 @@ protected void renderRainSnow(float var1) {
             }
          }
 
-         if (☃xxxxxxxxxxxxx >= 0) {
-            ☃xxxxxx.draw();
+         if (j1 >= 0) {
+            tessellator.draw();
          }
 
-         ☃xxxxxxx.setTranslation(0.0, 0.0, 0.0);
+         bufferbuilder.setTranslation(0.0, 0.0, 0.0);
          GlStateManager.enableCull();
          GlStateManager.disableBlend();
          GlStateManager.alphaFunc(516, 0.1F);
@@ -1508,212 +1819,283 @@ protected void renderRainSnow(float var1) {
    }
 
    public void setupOverlayRendering() {
-      ScaledResolution ☃ = new ScaledResolution(this.mc);
+      ScaledResolution scaledresolution = new ScaledResolution(this.mc);
       GlStateManager.clear(256);
       GlStateManager.matrixMode(5889);
       GlStateManager.loadIdentity();
-      GlStateManager.ortho(0.0, ☃.getScaledWidth_double(), ☃.getScaledHeight_double(), 0.0, 1000.0, 3000.0);
+      GlStateManager.ortho(0.0, scaledresolution.getScaledWidth_double(), scaledresolution.getScaledHeight_double(), 0.0, 1000.0, 3000.0);
       GlStateManager.matrixMode(5888);
       GlStateManager.loadIdentity();
       GlStateManager.translate(0.0F, 0.0F, -2000.0F);
    }
 
-   private void updateFogColor(float var1) {
-      World ☃ = this.mc.world;
-      Entity ☃x = this.mc.getRenderViewEntity();
-      float ☃xx = 0.25F + 0.75F * this.mc.gameSettings.renderDistanceChunks / 32.0F;
-      ☃xx = 1.0F - (float)Math.pow(☃xx, 0.25);
-      Vec3d ☃xxx = ☃.getSkyColor(this.mc.getRenderViewEntity(), ☃);
-      float ☃xxxx = (float)☃xxx.x;
-      float ☃xxxxx = (float)☃xxx.y;
-      float ☃xxxxxx = (float)☃xxx.z;
-      Vec3d ☃xxxxxxx = ☃.getFogColor(☃);
-      this.fogColorRed = (float)☃xxxxxxx.x;
-      this.fogColorGreen = (float)☃xxxxxxx.y;
-      this.fogColorBlue = (float)☃xxxxxxx.z;
+   private void updateFogColor(float partialTicks) {
+      World world = this.mc.world;
+      Entity entity = this.mc.getRenderViewEntity();
+      float f = 0.25F + 0.75F * this.mc.gameSettings.renderDistanceChunks / 32.0F;
+      f = 1.0F - (float)Math.pow(f, 0.25);
+      Vec3d vec3d = world.getSkyColor(this.mc.getRenderViewEntity(), partialTicks);
+      vec3d = CustomColors.getWorldSkyColor(vec3d, world, this.mc.getRenderViewEntity(), partialTicks);
+      float f1 = (float)vec3d.x;
+      float f2 = (float)vec3d.y;
+      float f3 = (float)vec3d.z;
+      Vec3d vec3d1 = world.getFogColor(partialTicks);
+      vec3d1 = CustomColors.getWorldFogColor(vec3d1, world, this.mc.getRenderViewEntity(), partialTicks);
+      this.fogColorRed = (float)vec3d1.x;
+      this.fogColorGreen = (float)vec3d1.y;
+      this.fogColorBlue = (float)vec3d1.z;
       if (this.mc.gameSettings.renderDistanceChunks >= 4) {
-         double ☃xxxxxxxx = MathHelper.sin(☃.getCelestialAngleRadians(☃)) > 0.0F ? -1.0 : 1.0;
-         Vec3d ☃xxxxxxxxx = new Vec3d(☃xxxxxxxx, 0.0, 0.0);
-         float ☃xxxxxxxxxx = (float)☃x.getLook(☃).dotProduct(☃xxxxxxxxx);
-         if (☃xxxxxxxxxx < 0.0F) {
-            ☃xxxxxxxxxx = 0.0F;
-         }
-
-         if (☃xxxxxxxxxx > 0.0F) {
-            float[] ☃xxxxxxxxxxx = ☃.provider.calcSunriseSunsetColors(☃.getCelestialAngle(☃), ☃);
-            if (☃xxxxxxxxxxx != null) {
-               ☃xxxxxxxxxx *= ☃xxxxxxxxxxx[3];
-               this.fogColorRed = this.fogColorRed * (1.0F - ☃xxxxxxxxxx) + ☃xxxxxxxxxxx[0] * ☃xxxxxxxxxx;
-               this.fogColorGreen = this.fogColorGreen * (1.0F - ☃xxxxxxxxxx) + ☃xxxxxxxxxxx[1] * ☃xxxxxxxxxx;
-               this.fogColorBlue = this.fogColorBlue * (1.0F - ☃xxxxxxxxxx) + ☃xxxxxxxxxxx[2] * ☃xxxxxxxxxx;
+         double d0 = MathHelper.sin(world.getCelestialAngleRadians(partialTicks)) > 0.0F ? -1.0 : 1.0;
+         Vec3d vec3d2 = new Vec3d(d0, 0.0, 0.0);
+         float f5 = (float)entity.getLook(partialTicks).dotProduct(vec3d2);
+         if (f5 < 0.0F) {
+            f5 = 0.0F;
+         }
+
+         if (f5 > 0.0F) {
+            float[] afloat = world.provider.calcSunriseSunsetColors(world.getCelestialAngle(partialTicks), partialTicks);
+            if (afloat != null) {
+               f5 *= afloat[3];
+               this.fogColorRed = this.fogColorRed * (1.0F - f5) + afloat[0] * f5;
+               this.fogColorGreen = this.fogColorGreen * (1.0F - f5) + afloat[1] * f5;
+               this.fogColorBlue = this.fogColorBlue * (1.0F - f5) + afloat[2] * f5;
             }
          }
       }
 
-      this.fogColorRed = this.fogColorRed + (☃xxxx - this.fogColorRed) * ☃xx;
-      this.fogColorGreen = this.fogColorGreen + (☃xxxxx - this.fogColorGreen) * ☃xx;
-      this.fogColorBlue = this.fogColorBlue + (☃xxxxxx - this.fogColorBlue) * ☃xx;
-      float ☃xxxxxxxxxxx = ☃.getRainStrength(☃);
-      if (☃xxxxxxxxxxx > 0.0F) {
-         float ☃xxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxx * 0.5F;
-         float ☃xxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxx * 0.4F;
-         this.fogColorRed *= ☃xxxxxxxxxxxx;
-         this.fogColorGreen *= ☃xxxxxxxxxxxx;
-         this.fogColorBlue *= ☃xxxxxxxxxxxxx;
+      this.fogColorRed = this.fogColorRed + (f1 - this.fogColorRed) * f;
+      this.fogColorGreen = this.fogColorGreen + (f2 - this.fogColorGreen) * f;
+      this.fogColorBlue = this.fogColorBlue + (f3 - this.fogColorBlue) * f;
+      float f8 = world.getRainStrength(partialTicks);
+      if (f8 > 0.0F) {
+         float f4 = 1.0F - f8 * 0.5F;
+         float f10 = 1.0F - f8 * 0.4F;
+         this.fogColorRed *= f4;
+         this.fogColorGreen *= f4;
+         this.fogColorBlue *= f10;
       }
 
-      float ☃xxxxxxxxxxxx = ☃.getThunderStrength(☃);
-      if (☃xxxxxxxxxxxx > 0.0F) {
-         float ☃xxxxxxxxxxxxx = 1.0F - ☃xxxxxxxxxxxx * 0.5F;
-         this.fogColorRed *= ☃xxxxxxxxxxxxx;
-         this.fogColorGreen *= ☃xxxxxxxxxxxxx;
-         this.fogColorBlue *= ☃xxxxxxxxxxxxx;
+      float f9 = world.getThunderStrength(partialTicks);
+      if (f9 > 0.0F) {
+         float f11 = 1.0F - f9 * 0.5F;
+         this.fogColorRed *= f11;
+         this.fogColorGreen *= f11;
+         this.fogColorBlue *= f11;
       }
 
-      IBlockState ☃xxxxxxxxxxxxx = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, ☃x, ☃);
+      IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, entity, partialTicks);
       if (this.cloudFog) {
-         Vec3d ☃xxxxxxxxxxxxxx = ☃.getCloudColour(☃);
-         this.fogColorRed = (float)☃xxxxxxxxxxxxxx.x;
-         this.fogColorGreen = (float)☃xxxxxxxxxxxxxx.y;
-         this.fogColorBlue = (float)☃xxxxxxxxxxxxxx.z;
-      } else if (☃xxxxxxxxxxxxx.getMaterial() == Material.WATER) {
-         float ☃xxxxxxxxxxxxxx = 0.0F;
-         if (☃x instanceof EntityLivingBase) {
-            ☃xxxxxxxxxxxxxx = EnchantmentHelper.getRespirationModifier((EntityLivingBase)☃x) * 0.2F;
-            if (((EntityLivingBase)☃x).isPotionActive(MobEffects.WATER_BREATHING)) {
-               ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxx * 0.3F + 0.6F;
+         Vec3d vec3d3 = world.getCloudColour(partialTicks);
+         this.fogColorRed = (float)vec3d3.x;
+         this.fogColorGreen = (float)vec3d3.y;
+         this.fogColorBlue = (float)vec3d3.z;
+      } else if (Reflector.ForgeBlock_getFogColor.exists()) {
+         Vec3d viewport = ActiveRenderInfo.projectViewFromEntity(entity, partialTicks);
+         BlockPos viewportPos = new BlockPos(viewport);
+         IBlockState viewportState = this.mc.world.getBlockState(viewportPos);
+         Vec3d inMaterialColor = (Vec3d)Reflector.call(
+            viewportState.getBlock(),
+            Reflector.ForgeBlock_getFogColor,
+            new Object[]{this.mc.world, viewportPos, viewportState, entity, new Vec3d(this.fogColorRed, this.fogColorGreen, this.fogColorBlue), partialTicks}
+         );
+         this.fogColorRed = (float)inMaterialColor.x;
+         this.fogColorGreen = (float)inMaterialColor.y;
+         this.fogColorBlue = (float)inMaterialColor.z;
+      } else if (iblockstate.a() == Material.WATER) {
+         float f12 = 0.0F;
+         if (entity instanceof EntityLivingBase) {
+            f12 = EnchantmentHelper.getRespirationModifier((EntityLivingBase)entity) * 0.2F;
+            f12 = Config.limit(f12, 0.0F, 0.6F);
+            if (((EntityLivingBase)entity).isPotionActive(MobEffects.WATER_BREATHING)) {
+               f12 = f12 * 0.3F + 0.6F;
             }
          }
 
-         this.fogColorRed = 0.02F + ☃xxxxxxxxxxxxxx;
-         this.fogColorGreen = 0.02F + ☃xxxxxxxxxxxxxx;
-         this.fogColorBlue = 0.2F + ☃xxxxxxxxxxxxxx;
-      } else if (☃xxxxxxxxxxxxx.getMaterial() == Material.LAVA) {
+         this.fogColorRed = 0.02F + f12;
+         this.fogColorGreen = 0.02F + f12;
+         this.fogColorBlue = 0.2F + f12;
+      } else if (iblockstate.a() == Material.LAVA) {
          this.fogColorRed = 0.6F;
          this.fogColorGreen = 0.1F;
          this.fogColorBlue = 0.0F;
       }
 
-      float ☃xxxxxxxxxxxxxx = this.fogColor2 + (this.fogColor1 - this.fogColor2) * ☃;
-      this.fogColorRed *= ☃xxxxxxxxxxxxxx;
-      this.fogColorGreen *= ☃xxxxxxxxxxxxxx;
-      this.fogColorBlue *= ☃xxxxxxxxxxxxxx;
-      double ☃xxxxxxxxxxxxxxx = (☃x.lastTickPosY + (☃x.posY - ☃x.lastTickPosY) * ☃) * ☃.provider.getVoidFogYFactor();
-      if (☃x instanceof EntityLivingBase && ((EntityLivingBase)☃x).isPotionActive(MobEffects.BLINDNESS)) {
-         int ☃xxxxxxxxxxxxxxxx = ((EntityLivingBase)☃x).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
-         if (☃xxxxxxxxxxxxxxxx < 20) {
-            ☃xxxxxxxxxxxxxxx *= 1.0F - ☃xxxxxxxxxxxxxxxx / 20.0F;
+      if (iblockstate.a() == Material.WATER) {
+         Vec3d colUnderwater = CustomColors.getUnderwaterColor(
+            this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (colUnderwater != null) {
+            this.fogColorRed = (float)colUnderwater.x;
+            this.fogColorGreen = (float)colUnderwater.y;
+            this.fogColorBlue = (float)colUnderwater.z;
+         }
+      } else if (iblockstate.a() == Material.LAVA) {
+         Vec3d colUnderlava = CustomColors.getUnderlavaColor(
+            this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (colUnderlava != null) {
+            this.fogColorRed = (float)colUnderlava.x;
+            this.fogColorGreen = (float)colUnderlava.y;
+            this.fogColorBlue = (float)colUnderlava.z;
+         }
+      }
+
+      float f13 = this.fogColor2 + (this.fogColor1 - this.fogColor2) * partialTicks;
+      this.fogColorRed *= f13;
+      this.fogColorGreen *= f13;
+      this.fogColorBlue *= f13;
+      double d1 = (entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * partialTicks) * world.provider.getVoidFogYFactor();
+      if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPotionActive(MobEffects.BLINDNESS)) {
+         int i = ((EntityLivingBase)entity).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
+         if (i < 20) {
+            d1 *= 1.0F - i / 20.0F;
          } else {
-            ☃xxxxxxxxxxxxxxx = 0.0;
+            d1 = 0.0;
          }
       }
 
-      if (☃xxxxxxxxxxxxxxx < 1.0) {
-         if (☃xxxxxxxxxxxxxxx < 0.0) {
-            ☃xxxxxxxxxxxxxxx = 0.0;
+      if (d1 < 1.0) {
+         if (d1 < 0.0) {
+            d1 = 0.0;
          }
 
-         ☃xxxxxxxxxxxxxxx *= ☃xxxxxxxxxxxxxxx;
-         this.fogColorRed = (float)(this.fogColorRed * ☃xxxxxxxxxxxxxxx);
-         this.fogColorGreen = (float)(this.fogColorGreen * ☃xxxxxxxxxxxxxxx);
-         this.fogColorBlue = (float)(this.fogColorBlue * ☃xxxxxxxxxxxxxxx);
+         d1 *= d1;
+         this.fogColorRed = (float)(this.fogColorRed * d1);
+         this.fogColorGreen = (float)(this.fogColorGreen * d1);
+         this.fogColorBlue = (float)(this.fogColorBlue * d1);
       }
 
       if (this.bossColorModifier > 0.0F) {
-         float ☃xxxxxxxxxxxxxxxx = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * ☃;
-         this.fogColorRed = this.fogColorRed * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorRed * 0.7F * ☃xxxxxxxxxxxxxxxx;
-         this.fogColorGreen = this.fogColorGreen * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorGreen * 0.6F * ☃xxxxxxxxxxxxxxxx;
-         this.fogColorBlue = this.fogColorBlue * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorBlue * 0.6F * ☃xxxxxxxxxxxxxxxx;
+         float f14 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * partialTicks;
+         this.fogColorRed = this.fogColorRed * (1.0F - f14) + this.fogColorRed * 0.7F * f14;
+         this.fogColorGreen = this.fogColorGreen * (1.0F - f14) + this.fogColorGreen * 0.6F * f14;
+         this.fogColorBlue = this.fogColorBlue * (1.0F - f14) + this.fogColorBlue * 0.6F * f14;
       }
 
-      if (☃x instanceof EntityLivingBase && ((EntityLivingBase)☃x).isPotionActive(MobEffects.NIGHT_VISION)) {
-         float ☃xxxxxxxxxxxxxxxx = this.getNightVisionBrightness((EntityLivingBase)☃x, ☃);
-         float ☃xxxxxxxxxxxxxxxxx = 1.0F / this.fogColorRed;
-         if (☃xxxxxxxxxxxxxxxxx > 1.0F / this.fogColorGreen) {
-            ☃xxxxxxxxxxxxxxxxx = 1.0F / this.fogColorGreen;
+      if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPotionActive(MobEffects.NIGHT_VISION)) {
+         float f15 = this.getNightVisionBrightness((EntityLivingBase)entity, partialTicks);
+         float f6 = 1.0F / this.fogColorRed;
+         if (f6 > 1.0F / this.fogColorGreen) {
+            f6 = 1.0F / this.fogColorGreen;
+         }
+
+         if (f6 > 1.0F / this.fogColorBlue) {
+            f6 = 1.0F / this.fogColorBlue;
          }
 
-         if (☃xxxxxxxxxxxxxxxxx > 1.0F / this.fogColorBlue) {
-            ☃xxxxxxxxxxxxxxxxx = 1.0F / this.fogColorBlue;
+         if (Float.isInfinite(f6)) {
+            f6 = Math.nextAfter(f6, 0.0);
          }
 
-         this.fogColorRed = this.fogColorRed * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorRed * ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx;
-         this.fogColorGreen = this.fogColorGreen * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorGreen * ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx;
-         this.fogColorBlue = this.fogColorBlue * (1.0F - ☃xxxxxxxxxxxxxxxx) + this.fogColorBlue * ☃xxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxx;
+         this.fogColorRed = this.fogColorRed * (1.0F - f15) + this.fogColorRed * f6 * f15;
+         this.fogColorGreen = this.fogColorGreen * (1.0F - f15) + this.fogColorGreen * f6 * f15;
+         this.fogColorBlue = this.fogColorBlue * (1.0F - f15) + this.fogColorBlue * f6 * f15;
       }
 
       if (this.mc.gameSettings.anaglyph) {
-         float ☃xxxxxxxxxxxxxxxxxx = (this.fogColorRed * 30.0F + this.fogColorGreen * 59.0F + this.fogColorBlue * 11.0F) / 100.0F;
-         float ☃xxxxxxxxxxxxxxxxxxx = (this.fogColorRed * 30.0F + this.fogColorGreen * 70.0F) / 100.0F;
-         float ☃xxxxxxxxxxxxxxxxxxxx = (this.fogColorRed * 30.0F + this.fogColorBlue * 70.0F) / 100.0F;
-         this.fogColorRed = ☃xxxxxxxxxxxxxxxxxx;
-         this.fogColorGreen = ☃xxxxxxxxxxxxxxxxxxx;
-         this.fogColorBlue = ☃xxxxxxxxxxxxxxxxxxxx;
+         float f16 = (this.fogColorRed * 30.0F + this.fogColorGreen * 59.0F + this.fogColorBlue * 11.0F) / 100.0F;
+         float f17 = (this.fogColorRed * 30.0F + this.fogColorGreen * 70.0F) / 100.0F;
+         float f7 = (this.fogColorRed * 30.0F + this.fogColorBlue * 70.0F) / 100.0F;
+         this.fogColorRed = f16;
+         this.fogColorGreen = f17;
+         this.fogColorBlue = f7;
+      }
+
+      if (Reflector.EntityViewRenderEvent_FogColors_Constructor.exists()) {
+         Object event = Reflector.newInstance(
+            Reflector.EntityViewRenderEvent_FogColors_Constructor,
+            new Object[]{this, entity, iblockstate, partialTicks, this.fogColorRed, this.fogColorGreen, this.fogColorBlue}
+         );
+         Reflector.postForgeBusEvent(event);
+         this.fogColorRed = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_FogColors_getRed, new Object[0]);
+         this.fogColorGreen = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_FogColors_getGreen, new Object[0]);
+         this.fogColorBlue = Reflector.callFloat(event, Reflector.EntityViewRenderEvent_FogColors_getBlue, new Object[0]);
       }
 
-      GlStateManager.clearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
+      Shaders.setClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
    }
 
-   private void setupFog(int var1, float var2) {
-      Entity ☃ = this.mc.getRenderViewEntity();
+   private void setupFog(int startCoords, float partialTicks) {
+      this.fogStandard = false;
+      Entity entity = this.mc.getRenderViewEntity();
       this.setupFogColor(false);
       GlStateManager.glNormal3f(0.0F, -1.0F, 0.0F);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      IBlockState ☃x = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, ☃, ☃);
-      if (☃ instanceof EntityLivingBase && ((EntityLivingBase)☃).isPotionActive(MobEffects.BLINDNESS)) {
-         float ☃xx = 5.0F;
-         int ☃xxx = ((EntityLivingBase)☃).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
-         if (☃xxx < 20) {
-            ☃xx = 5.0F + (this.farPlaneDistance - 5.0F) * (1.0F - ☃xxx / 20.0F);
+      IBlockState iblockstate = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, entity, partialTicks);
+      float forgeFogDensity = -1.0F;
+      if (Reflector.ForgeHooksClient_getFogDensity.exists()) {
+         forgeFogDensity = Reflector.callFloat(Reflector.ForgeHooksClient_getFogDensity, new Object[]{this, entity, iblockstate, partialTicks, 0.1F});
+      }
+
+      if (forgeFogDensity >= 0.0F) {
+         GlStateManager.setFogDensity(forgeFogDensity);
+      } else if (entity instanceof EntityLivingBase && ((EntityLivingBase)entity).isPotionActive(MobEffects.BLINDNESS)) {
+         float f1 = 5.0F;
+         int i = ((EntityLivingBase)entity).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
+         if (i < 20) {
+            f1 = 5.0F + (this.farPlaneDistance - 5.0F) * (1.0F - i / 20.0F);
          }
 
          GlStateManager.setFog(GlStateManager.FogMode.LINEAR);
-         if (☃ == -1) {
+         if (startCoords == -1) {
             GlStateManager.setFogStart(0.0F);
-            GlStateManager.setFogEnd(☃xx * 0.8F);
+            GlStateManager.setFogEnd(f1 * 0.8F);
          } else {
-            GlStateManager.setFogStart(☃xx * 0.25F);
-            GlStateManager.setFogEnd(☃xx);
+            GlStateManager.setFogStart(f1 * 0.25F);
+            GlStateManager.setFogEnd(f1);
          }
 
-         if (GLContext.getCapabilities().GL_NV_fog_distance) {
+         if (GLContext.getCapabilities().GL_NV_fog_distance && Config.isFogFancy()) {
             GlStateManager.glFogi(34138, 34139);
          }
       } else if (this.cloudFog) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
          GlStateManager.setFogDensity(0.1F);
-      } else if (☃x.getMaterial() == Material.WATER) {
+      } else if (iblockstate.a() == Material.WATER) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
-         if (☃ instanceof EntityLivingBase) {
-            if (((EntityLivingBase)☃).isPotionActive(MobEffects.WATER_BREATHING)) {
+         float waterFogDensityMax = Config.isClearWater() ? 0.02F : 0.1F;
+         if (entity instanceof EntityLivingBase) {
+            if (((EntityLivingBase)entity).isPotionActive(MobEffects.WATER_BREATHING)) {
                GlStateManager.setFogDensity(0.01F);
             } else {
-               GlStateManager.setFogDensity(0.1F - EnchantmentHelper.getRespirationModifier((EntityLivingBase)☃) * 0.03F);
+               float waterFogDensity = 0.1F - EnchantmentHelper.getRespirationModifier((EntityLivingBase)entity) * 0.03F;
+               GlStateManager.setFogDensity(Config.limit(waterFogDensity, 0.0F, waterFogDensityMax));
             }
          } else {
-            GlStateManager.setFogDensity(0.1F);
+            GlStateManager.setFogDensity(waterFogDensityMax);
          }
-      } else if (☃x.getMaterial() == Material.LAVA) {
+      } else if (iblockstate.a() == Material.LAVA) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
          GlStateManager.setFogDensity(2.0F);
       } else {
-         float ☃xxxx = this.farPlaneDistance;
+         float f = this.farPlaneDistance;
+         this.fogStandard = true;
          GlStateManager.setFog(GlStateManager.FogMode.LINEAR);
-         if (☃ == -1) {
+         if (startCoords == -1) {
             GlStateManager.setFogStart(0.0F);
-            GlStateManager.setFogEnd(☃xxxx);
+            GlStateManager.setFogEnd(f);
          } else {
-            GlStateManager.setFogStart(☃xxxx * 0.75F);
-            GlStateManager.setFogEnd(☃xxxx);
+            GlStateManager.setFogStart(f * Config.getFogStart());
+            GlStateManager.setFogEnd(f);
          }
 
          if (GLContext.getCapabilities().GL_NV_fog_distance) {
-            GlStateManager.glFogi(34138, 34139);
+            if (Config.isFogFancy()) {
+               GlStateManager.glFogi(34138, 34139);
+            }
+
+            if (Config.isFogFast()) {
+               GlStateManager.glFogi(34138, 34140);
+            }
+         }
+
+         if (this.mc.world.provider.doesXZShowFog((int)entity.posX, (int)entity.posZ) || this.mc.ingameGUI.getBossOverlay().shouldCreateFog()) {
+            GlStateManager.setFogStart(f * 0.05F);
+            GlStateManager.setFogEnd(f);
          }
 
-         if (this.mc.world.provider.doesXZShowFog((int)☃.posX, (int)☃.posZ) || this.mc.ingameGUI.getBossOverlay().shouldCreateFog()) {
-            GlStateManager.setFogStart(☃xxxx * 0.05F);
-            GlStateManager.setFogEnd(Math.min(☃xxxx, 192.0F) * 0.5F);
+         if (Reflector.ForgeHooksClient_onFogRender.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_onFogRender, new Object[]{this, entity, iblockstate, partialTicks, startCoords, f});
          }
       }
 
@@ -1722,17 +2104,21 @@ private void setupFog(int var1, float var2) {
       GlStateManager.colorMaterial(1028, 4608);
    }
 
-   public void setupFogColor(boolean var1) {
-      if (☃) {
+   public void setupFogColor(boolean black) {
+      if (black) {
          GlStateManager.glFog(2918, this.setFogColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
       } else {
          GlStateManager.glFog(2918, this.setFogColorBuffer(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 1.0F));
       }
    }
 
-   private FloatBuffer setFogColorBuffer(float var1, float var2, float var3, float var4) {
+   private FloatBuffer setFogColorBuffer(float red, float green, float blue, float alpha) {
+      if (Config.isShaders()) {
+         Shaders.setFogColor(red, green, blue);
+      }
+
       ((Buffer)this.fogColorBuffer).clear();
-      this.fogColorBuffer.put(☃).put(☃).put(☃).put(☃);
+      this.fogColorBuffer.put(red).put(green).put(blue).put(alpha);
       ((Buffer)this.fogColorBuffer).flip();
       return this.fogColorBuffer;
    }
@@ -1746,18 +2132,286 @@ public MapItemRenderer getMapItemRenderer() {
       return this.mapItemRenderer;
    }
 
+   private void waitForServerThread() {
+      this.serverWaitTimeCurrent = 0;
+      if (!Config.isSmoothWorld() || !Config.isSingleProcessor()) {
+         this.lastServerTime = 0L;
+         this.lastServerTicks = 0;
+      } else if (this.mc.isIntegratedServerRunning()) {
+         IntegratedServer srv = this.mc.getIntegratedServer();
+         if (srv != null) {
+            boolean paused = this.mc.isGamePaused();
+            if (!paused && !(this.mc.currentScreen instanceof GuiDownloadTerrain)) {
+               if (this.serverWaitTime > 0) {
+                  Lagometer.timerServer.start();
+                  Config.sleep(this.serverWaitTime);
+                  Lagometer.timerServer.end();
+                  this.serverWaitTimeCurrent = this.serverWaitTime;
+               }
+
+               long timeNow = System.nanoTime() / 1000000L;
+               if (this.lastServerTime != 0L && this.lastServerTicks != 0) {
+                  long timeDiff = timeNow - this.lastServerTime;
+                  if (timeDiff < 0L) {
+                     this.lastServerTime = timeNow;
+                     timeDiff = 0L;
+                  }
+
+                  if (timeDiff >= 50L) {
+                     this.lastServerTime = timeNow;
+                     int ticks = srv.getTickCounter();
+                     int tickDiff = ticks - this.lastServerTicks;
+                     if (tickDiff < 0) {
+                        this.lastServerTicks = ticks;
+                        tickDiff = 0;
+                     }
+
+                     if (tickDiff < 1 && this.serverWaitTime < 100) {
+                        this.serverWaitTime += 2;
+                     }
+
+                     if (tickDiff > 1 && this.serverWaitTime > 0) {
+                        this.serverWaitTime--;
+                     }
+
+                     this.lastServerTicks = ticks;
+                  }
+               } else {
+                  this.lastServerTime = timeNow;
+                  this.lastServerTicks = srv.getTickCounter();
+                  this.avgServerTickDiff = 1.0F;
+                  this.avgServerTimeDiff = 50.0F;
+               }
+            } else {
+               if (this.mc.currentScreen instanceof GuiDownloadTerrain) {
+                  Config.sleep(20L);
+               }
+
+               this.lastServerTime = 0L;
+               this.lastServerTicks = 0;
+            }
+         }
+      }
+   }
+
+   private void frameInit() {
+      GlErrors.frameStart();
+      if (!this.initialized) {
+         ReflectorResolver.resolve();
+         TextureUtils.registerResourceListener();
+         if (Config.getBitsOs() == 64 && Config.getBitsJre() == 32) {
+            Config.setNotify64BitJava(true);
+         }
+
+         this.initialized = true;
+      }
+
+      Config.checkDisplayMode();
+      World world = this.mc.world;
+      if (world != null) {
+         if (Config.getNewRelease() != null) {
+            String userEdition = "HD_U".replace("HD_U", "HD Ultra").replace("L", "Light");
+            String fullNewVer = userEdition + " " + Config.getNewRelease();
+            TextComponentString msg = new TextComponentString(I18n.format("of.message.newVersion", "§n" + fullNewVer + "§r"));
+            msg.setStyle(new Style().setClickEvent(new ClickEvent(Action.OPEN_URL, "https://optifine.net/downloads")));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(msg);
+            Config.setNewRelease(null);
+         }
+
+         if (Config.isNotify64BitJava()) {
+            Config.setNotify64BitJava(false);
+            TextComponentString msg = new TextComponentString(I18n.format("of.message.java64Bit"));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(msg);
+         }
+      }
+
+      if (this.mc.currentScreen instanceof GuiMainMenu) {
+         this.updateMainMenu((GuiMainMenu)this.mc.currentScreen);
+      }
+
+      if (this.updatedWorld != world) {
+         RandomEntities.worldChanged(this.updatedWorld, world);
+         Config.updateThreadPriorities();
+         this.lastServerTime = 0L;
+         this.lastServerTicks = 0;
+         this.updatedWorld = world;
+      }
+
+      if (!this.setFxaaShader(Shaders.configAntialiasingLevel)) {
+         Shaders.configAntialiasingLevel = 0;
+      }
+
+      if (this.mc.currentScreen != null && this.mc.currentScreen.getClass() == GuiChat.class) {
+         this.mc.displayGuiScreen(new GuiChatOF((GuiChat)this.mc.currentScreen));
+      }
+   }
+
+   private void frameFinish() {
+      if (this.mc.world != null && Config.isShowGlErrors() && TimedEvent.isActive("CheckGlErrorFrameFinish", 10000L)) {
+         int err = GlStateManager.glGetError();
+         if (err != 0 && GlErrors.isEnabled(err)) {
+            String text = Config.getGlErrorString(err);
+            TextComponentString msg = new TextComponentString(I18n.format("of.message.openglError", err, text));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(msg);
+         }
+      }
+   }
+
+   private void updateMainMenu(GuiMainMenu mainGui) {
+      try {
+         String str = null;
+         Calendar calendar = Calendar.getInstance();
+         calendar.setTime(new Date());
+         int day = calendar.get(5);
+         int month = calendar.get(2) + 1;
+         if (day == 8 && month == 4) {
+            str = "Happy birthday, OptiFine!";
+         }
+
+         if (day == 14 && month == 8) {
+            str = "Happy birthday, sp614x!";
+         }
+
+         if (str == null) {
+            return;
+         }
+
+         Reflector.setFieldValue(mainGui, Reflector.GuiMainMenu_splashText, str);
+      } catch (Throwable var6) {
+      }
+   }
+
+   public boolean setFxaaShader(int fxaaLevel) {
+      if (!OpenGlHelper.isFramebufferEnabled()) {
+         return false;
+      } else if (this.shaderGroup != null && this.shaderGroup != this.fxaaShaders[2] && this.shaderGroup != this.fxaaShaders[4]) {
+         return true;
+      } else if (fxaaLevel != 2 && fxaaLevel != 4) {
+         if (this.shaderGroup == null) {
+            return true;
+         } else {
+            this.shaderGroup.deleteShaderGroup();
+            this.shaderGroup = null;
+            return true;
+         }
+      } else if (this.shaderGroup != null && this.shaderGroup == this.fxaaShaders[fxaaLevel]) {
+         return true;
+      } else if (this.mc.world == null) {
+         return true;
+      } else {
+         this.loadShader(new ResourceLocation("shaders/post/fxaa_of_" + fxaaLevel + "x.json"));
+         this.fxaaShaders[fxaaLevel] = this.shaderGroup;
+         return this.useShader;
+      }
+   }
+
+   private void checkLoadVisibleChunks(Entity entity, float partialTicks, ICamera icamera, boolean spectator) {
+      int messageId = 201435902;
+      if (this.loadVisibleChunks) {
+         this.loadVisibleChunks = false;
+         this.loadAllVisibleChunks(entity, partialTicks, icamera, spectator);
+         this.mc.ingameGUI.getChatGUI().deleteChatLine(messageId);
+      }
+
+      if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(38)) {
+         if (this.mc.gameSettings.keyBindAdvancements.getKeyCode() == 38) {
+            if (this.mc.currentScreen instanceof GuiScreenAdvancements) {
+               this.mc.displayGuiScreen(null);
+            }
+
+            while (Keyboard.next()) {
+            }
+         }
+
+         if (this.mc.currentScreen != null) {
+            return;
+         }
+
+         this.loadVisibleChunks = true;
+         TextComponentString msg = new TextComponentString(I18n.format("of.message.loadingVisibleChunks"));
+         this.mc.ingameGUI.getChatGUI().printChatMessageWithOptionalDeletion(msg, messageId);
+         Reflector.Minecraft_actionKeyF3.setValue(this.mc, Boolean.TRUE);
+      }
+   }
+
+   private void loadAllVisibleChunks(Entity entity, double partialTicks, ICamera icamera, boolean spectator) {
+      int chunkUpdatesConfig = this.mc.gameSettings.ofChunkUpdates;
+      boolean lazyChunkLoadingConfig = this.mc.gameSettings.ofLazyChunkLoading;
+
+      try {
+         this.mc.gameSettings.ofChunkUpdates = 1000;
+         this.mc.gameSettings.ofLazyChunkLoading = false;
+         RenderGlobal renderGlobal = Config.getRenderGlobal();
+         int countLoadedChunks = renderGlobal.getCountLoadedChunks();
+         long timeStart = System.currentTimeMillis();
+         Config.dbg("Loading visible chunks");
+         long timeLog = System.currentTimeMillis() + 5000L;
+         int chunksUpdated = 0;
+         boolean hasUpdates = false;
+
+         do {
+            hasUpdates = false;
+
+            for (int i = 0; i < 100; i++) {
+               renderGlobal.displayListEntitiesDirty = true;
+               renderGlobal.setupTerrain(entity, partialTicks, icamera, this.frameCount++, spectator);
+               if (!renderGlobal.hasNoChunkUpdates()) {
+                  hasUpdates = true;
+               }
+
+               chunksUpdated += renderGlobal.getCountChunksToUpdate();
+
+               while (!renderGlobal.hasNoChunkUpdates()) {
+                  renderGlobal.updateChunks(System.nanoTime() + 1000000000L);
+               }
+
+               chunksUpdated -= renderGlobal.getCountChunksToUpdate();
+               if (!hasUpdates) {
+                  break;
+               }
+            }
+
+            if (renderGlobal.getCountLoadedChunks() != countLoadedChunks) {
+               hasUpdates = true;
+               countLoadedChunks = renderGlobal.getCountLoadedChunks();
+            }
+
+            if (System.currentTimeMillis() > timeLog) {
+               Config.log("Chunks loaded: " + chunksUpdated);
+               timeLog = System.currentTimeMillis() + 5000L;
+            }
+         } while (hasUpdates);
+
+         Config.log("Chunks loaded: " + chunksUpdated);
+         Config.log("Finished loading visible chunks");
+         RenderChunk.renderChunksUpdated = 0;
+      } finally {
+         this.mc.gameSettings.ofChunkUpdates = chunkUpdatesConfig;
+         this.mc.gameSettings.ofLazyChunkLoading = lazyChunkLoadingConfig;
+      }
+   }
+
    public static void drawNameplate(
-      FontRenderer var0, String var1, float var2, float var3, float var4, int var5, float var6, float var7, boolean var8, boolean var9
+      FontRenderer fontRendererIn,
+      String str,
+      float x,
+      float y,
+      float z,
+      int verticalShift,
+      float viewerYaw,
+      float viewerPitch,
+      boolean isThirdPersonFrontal,
+      boolean isSneaking
    ) {
       GlStateManager.pushMatrix();
-      GlStateManager.translate(☃, ☃, ☃);
+      GlStateManager.translate(x, y, z);
       GlStateManager.glNormal3f(0.0F, 1.0F, 0.0F);
-      GlStateManager.rotate(-☃, 0.0F, 1.0F, 0.0F);
-      GlStateManager.rotate((☃ ? -1 : 1) * ☃, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate(-viewerYaw, 0.0F, 1.0F, 0.0F);
+      GlStateManager.rotate((isThirdPersonFrontal ? -1 : 1) * viewerPitch, 1.0F, 0.0F, 0.0F);
       GlStateManager.scale(-0.025F, -0.025F, 0.025F);
       GlStateManager.disableLighting();
       GlStateManager.depthMask(false);
-      if (!☃) {
+      if (!isSneaking) {
          GlStateManager.disableDepth();
       }
 
@@ -1765,47 +2419,47 @@ public static void drawNameplate(
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      int ☃ = ☃.getStringWidth(☃) / 2;
+      int i = fontRendererIn.getStringWidth(str) / 2;
       GlStateManager.disableTexture2D();
-      Tessellator ☃x = Tessellator.getInstance();
-      BufferBuilder ☃xx = ☃x.getBuffer();
-      ☃xx.begin(7, DefaultVertexFormats.POSITION_COLOR);
-      ☃xx.pos(-☃ - 1, -1 + ☃, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
-      ☃xx.pos(-☃ - 1, 8 + ☃, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
-      ☃xx.pos(☃ + 1, 8 + ☃, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
-      ☃xx.pos(☃ + 1, -1 + ☃, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
-      ☃x.draw();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
+      bufferbuilder.pos(-i - 1, -1 + verticalShift, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+      bufferbuilder.pos(-i - 1, 8 + verticalShift, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+      bufferbuilder.pos(i + 1, 8 + verticalShift, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+      bufferbuilder.pos(i + 1, -1 + verticalShift, 0.0).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
+      tessellator.draw();
       GlStateManager.enableTexture2D();
-      if (!☃) {
-         ☃.drawString(☃, -☃.getStringWidth(☃) / 2, ☃, 553648127);
+      if (!isSneaking) {
+         fontRendererIn.drawString(str, -fontRendererIn.getStringWidth(str) / 2, verticalShift, 553648127);
          GlStateManager.enableDepth();
       }
 
       GlStateManager.depthMask(true);
-      ☃.drawString(☃, -☃.getStringWidth(☃) / 2, ☃, ☃ ? 553648127 : -1);
+      fontRendererIn.drawString(str, -fontRendererIn.getStringWidth(str) / 2, verticalShift, isSneaking ? 553648127 : -1);
       GlStateManager.enableLighting();
       GlStateManager.disableBlend();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.popMatrix();
    }
 
-   public void displayItemActivation(ItemStack var1) {
-      this.itemActivationItem = ☃;
+   public void displayItemActivation(ItemStack p_190565_1_) {
+      this.itemActivationItem = p_190565_1_;
       this.itemActivationTicks = 40;
       this.itemActivationOffX = this.random.nextFloat() * 2.0F - 1.0F;
       this.itemActivationOffY = this.random.nextFloat() * 2.0F - 1.0F;
    }
 
-   private void renderItemActivation(int var1, int var2, float var3) {
+   private void renderItemActivation(int p_190563_1_, int p_190563_2_, float p_190563_3_) {
       if (this.itemActivationItem != null && this.itemActivationTicks > 0) {
-         int ☃ = 40 - this.itemActivationTicks;
-         float ☃x = (☃ + ☃) / 40.0F;
-         float ☃xx = ☃x * ☃x;
-         float ☃xxx = ☃x * ☃xx;
-         float ☃xxxx = 10.25F * ☃xxx * ☃xx + -24.95F * ☃xx * ☃xx + 25.5F * ☃xxx + -13.8F * ☃xx + 4.0F * ☃x;
-         float ☃xxxxx = ☃xxxx * (float) Math.PI;
-         float ☃xxxxxx = this.itemActivationOffX * (☃ / 4);
-         float ☃xxxxxxx = this.itemActivationOffY * (☃ / 4);
+         int i = 40 - this.itemActivationTicks;
+         float f = (i + p_190563_3_) / 40.0F;
+         float f1 = f * f;
+         float f2 = f * f1;
+         float f3 = 10.25F * f2 * f1 + -24.95F * f1 * f1 + 25.5F * f2 + -13.8F * f1 + 4.0F * f;
+         float f4 = f3 * (float) Math.PI;
+         float f5 = this.itemActivationOffX * (p_190563_1_ / 4);
+         float f6 = this.itemActivationOffY * (p_190563_2_ / 4);
          GlStateManager.enableAlpha();
          GlStateManager.pushMatrix();
          GlStateManager.pushAttrib();
@@ -1813,14 +2467,14 @@ private void renderItemActivation(int var1, int var2, float var3) {
          GlStateManager.disableCull();
          RenderHelper.enableStandardItemLighting();
          GlStateManager.translate(
-            ☃ / 2 + ☃xxxxxx * MathHelper.abs(MathHelper.sin(☃xxxxx * 2.0F)), ☃ / 2 + ☃xxxxxxx * MathHelper.abs(MathHelper.sin(☃xxxxx * 2.0F)), -50.0F
+            p_190563_1_ / 2 + f5 * MathHelper.abs(MathHelper.sin(f4 * 2.0F)), p_190563_2_ / 2 + f6 * MathHelper.abs(MathHelper.sin(f4 * 2.0F)), -50.0F
          );
-         float ☃xxxxxxxx = 50.0F + 175.0F * MathHelper.sin(☃xxxxx);
-         GlStateManager.scale(☃xxxxxxxx, -☃xxxxxxxx, ☃xxxxxxxx);
-         GlStateManager.rotate(900.0F * MathHelper.abs(MathHelper.sin(☃xxxxx)), 0.0F, 1.0F, 0.0F);
-         GlStateManager.rotate(6.0F * MathHelper.cos(☃x * 8.0F), 1.0F, 0.0F, 0.0F);
-         GlStateManager.rotate(6.0F * MathHelper.cos(☃x * 8.0F), 0.0F, 0.0F, 1.0F);
-         this.mc.getRenderItem().renderItem(this.itemActivationItem, ItemCameraTransforms.TransformType.FIXED);
+         float f7 = 50.0F + 175.0F * MathHelper.sin(f4);
+         GlStateManager.scale(f7, -f7, f7);
+         GlStateManager.rotate(900.0F * MathHelper.abs(MathHelper.sin(f4)), 0.0F, 1.0F, 0.0F);
+         GlStateManager.rotate(6.0F * MathHelper.cos(f * 8.0F), 1.0F, 0.0F, 0.0F);
+         GlStateManager.rotate(6.0F * MathHelper.cos(f * 8.0F), 0.0F, 0.0F, 1.0F);
+         this.mc.getRenderItem().renderItem(this.itemActivationItem, TransformType.FIXED);
          GlStateManager.popAttrib();
          GlStateManager.popMatrix();
          RenderHelper.disableStandardItemLighting();
diff --git a/patches/net/minecraft/client/renderer/GlStateManager.java b/patches/net/minecraft/client/renderer/GlStateManager.java
index 70c8203..3faab9c 100644
--- a/patches/net/minecraft/client/renderer/GlStateManager.java
+++ b/patches/net/minecraft/client/renderer/GlStateManager.java
@@ -5,6 +5,11 @@
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import javax.annotation.Nullable;
+import net.optifine.SmartAnimations;
+import net.optifine.render.GlAlphaState;
+import net.optifine.render.GlBlendState;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.LockCounter;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL14;
@@ -34,6 +39,12 @@ public class GlStateManager {
    private static final GlStateManager.BooleanState rescaleNormalState;
    private static final GlStateManager.ColorMask colorMaskState;
    private static final GlStateManager.Color colorState;
+   public static boolean clearEnabled = true;
+   private static LockCounter alphaLock = new LockCounter();
+   private static GlAlphaState alphaLockState = new GlAlphaState();
+   private static LockCounter blendLock = new LockCounter();
+   private static GlBlendState blendLockState = new GlBlendState();
+   private static boolean creatingDisplayList = false;
 
    public static void pushAttrib() {
       GL11.glPushAttrib(8256);
@@ -44,18 +55,30 @@ public static void popAttrib() {
    }
 
    public static void disableAlpha() {
-      alphaState.alphaTest.setDisabled();
+      if (alphaLock.isLocked()) {
+         alphaLockState.setDisabled();
+      } else {
+         alphaState.alphaTest.setDisabled();
+      }
    }
 
    public static void enableAlpha() {
-      alphaState.alphaTest.setEnabled();
+      if (alphaLock.isLocked()) {
+         alphaLockState.setEnabled();
+      } else {
+         alphaState.alphaTest.setEnabled();
+      }
    }
 
-   public static void alphaFunc(int var0, float var1) {
-      if (☃ != alphaState.func || ☃ != alphaState.ref) {
-         alphaState.func = ☃;
-         alphaState.ref = ☃;
-         GL11.glAlphaFunc(☃, ☃);
+   public static void alphaFunc(int func, float ref) {
+      if (alphaLock.isLocked()) {
+         alphaLockState.setFuncRef(func, ref);
+      } else {
+         if (func != alphaState.func || ref != alphaState.ref) {
+            alphaState.func = func;
+            alphaState.ref = ref;
+            GL11.glAlphaFunc(func, ref);
+         }
       }
    }
 
@@ -67,12 +90,12 @@ public static void disableLighting() {
       lightingState.setDisabled();
    }
 
-   public static void enableLight(int var0) {
-      lightState[☃].setEnabled();
+   public static void enableLight(int light) {
+      lightState[light].setEnabled();
    }
 
-   public static void disableLight(int var0) {
-      lightState[☃].setDisabled();
+   public static void disableLight(int light) {
+      lightState[light].setDisabled();
    }
 
    public static void enableColorMaterial() {
@@ -83,24 +106,24 @@ public static void disableColorMaterial() {
       colorMaterialState.colorMaterial.setDisabled();
    }
 
-   public static void colorMaterial(int var0, int var1) {
-      if (☃ != colorMaterialState.face || ☃ != colorMaterialState.mode) {
-         colorMaterialState.face = ☃;
-         colorMaterialState.mode = ☃;
-         GL11.glColorMaterial(☃, ☃);
+   public static void colorMaterial(int face, int mode) {
+      if (face != colorMaterialState.face || mode != colorMaterialState.mode) {
+         colorMaterialState.face = face;
+         colorMaterialState.mode = mode;
+         GL11.glColorMaterial(face, mode);
       }
    }
 
-   public static void glLight(int var0, int var1, FloatBuffer var2) {
-      GL11.glLight(☃, ☃, ☃);
+   public static void glLight(int light, int pname, FloatBuffer params) {
+      GL11.glLight(light, pname, params);
    }
 
-   public static void glLightModel(int var0, FloatBuffer var1) {
-      GL11.glLightModel(☃, ☃);
+   public static void glLightModel(int pname, FloatBuffer params) {
+      GL11.glLightModel(pname, params);
    }
 
-   public static void glNormal3f(float var0, float var1, float var2) {
-      GL11.glNormal3f(☃, ☃, ☃);
+   public static void glNormal3f(float nx, float ny, float nz) {
+      GL11.glNormal3f(nx, ny, nz);
    }
 
    public static void disableDepth() {
@@ -111,65 +134,100 @@ public static void enableDepth() {
       depthState.depthTest.setEnabled();
    }
 
-   public static void depthFunc(int var0) {
-      if (☃ != depthState.depthFunc) {
-         depthState.depthFunc = ☃;
-         GL11.glDepthFunc(☃);
+   public static void depthFunc(int depthFunc) {
+      if (depthFunc != depthState.depthFunc) {
+         depthState.depthFunc = depthFunc;
+         GL11.glDepthFunc(depthFunc);
       }
    }
 
-   public static void depthMask(boolean var0) {
-      if (☃ != depthState.maskEnabled) {
-         depthState.maskEnabled = ☃;
-         GL11.glDepthMask(☃);
+   public static void depthMask(boolean flagIn) {
+      if (flagIn != depthState.maskEnabled) {
+         depthState.maskEnabled = flagIn;
+         GL11.glDepthMask(flagIn);
       }
    }
 
    public static void disableBlend() {
-      blendState.blend.setDisabled();
+      if (blendLock.isLocked()) {
+         blendLockState.setDisabled();
+      } else {
+         blendState.blend.setDisabled();
+      }
    }
 
    public static void enableBlend() {
-      blendState.blend.setEnabled();
+      if (blendLock.isLocked()) {
+         blendLockState.setEnabled();
+      } else {
+         blendState.blend.setEnabled();
+      }
    }
 
-   public static void blendFunc(GlStateManager.SourceFactor var0, GlStateManager.DestFactor var1) {
-      blendFunc(☃.factor, ☃.factor);
-   }
+   public static void blendFunc(GlStateManager.SourceFactor srcFactor, GlStateManager.DestFactor dstFactor) {
+      blendFunc(srcFactor.factor, dstFactor.factor);
+   }
+
+   public static void blendFunc(int srcFactor, int dstFactor) {
+      if (blendLock.isLocked()) {
+         blendLockState.setFactors(srcFactor, dstFactor);
+      } else {
+         if (srcFactor != blendState.srcFactor
+            || dstFactor != blendState.dstFactor
+            || srcFactor != blendState.srcFactorAlpha
+            || dstFactor != blendState.dstFactorAlpha) {
+            blendState.srcFactor = srcFactor;
+            blendState.dstFactor = dstFactor;
+            blendState.srcFactorAlpha = srcFactor;
+            blendState.dstFactorAlpha = dstFactor;
+            if (Config.isShaders()) {
+               Shaders.uniform_blendFunc.setValue(srcFactor, dstFactor, srcFactor, dstFactor);
+            }
 
-   public static void blendFunc(int var0, int var1) {
-      if (☃ != blendState.srcFactor || ☃ != blendState.dstFactor) {
-         blendState.srcFactor = ☃;
-         blendState.dstFactor = ☃;
-         GL11.glBlendFunc(☃, ☃);
+            GL11.glBlendFunc(srcFactor, dstFactor);
+         }
       }
    }
 
    public static void tryBlendFuncSeparate(
-      GlStateManager.SourceFactor var0, GlStateManager.DestFactor var1, GlStateManager.SourceFactor var2, GlStateManager.DestFactor var3
+      GlStateManager.SourceFactor srcFactor,
+      GlStateManager.DestFactor dstFactor,
+      GlStateManager.SourceFactor srcFactorAlpha,
+      GlStateManager.DestFactor dstFactorAlpha
    ) {
-      tryBlendFuncSeparate(☃.factor, ☃.factor, ☃.factor, ☃.factor);
-   }
+      tryBlendFuncSeparate(srcFactor.factor, dstFactor.factor, srcFactorAlpha.factor, dstFactorAlpha.factor);
+   }
+
+   public static void tryBlendFuncSeparate(int srcFactor, int dstFactor, int srcFactorAlpha, int dstFactorAlpha) {
+      if (blendLock.isLocked()) {
+         blendLockState.setFactors(srcFactor, dstFactor, srcFactorAlpha, dstFactorAlpha);
+      } else {
+         if (srcFactor != blendState.srcFactor
+            || dstFactor != blendState.dstFactor
+            || srcFactorAlpha != blendState.srcFactorAlpha
+            || dstFactorAlpha != blendState.dstFactorAlpha) {
+            blendState.srcFactor = srcFactor;
+            blendState.dstFactor = dstFactor;
+            blendState.srcFactorAlpha = srcFactorAlpha;
+            blendState.dstFactorAlpha = dstFactorAlpha;
+            if (Config.isShaders()) {
+               Shaders.uniform_blendFunc.setValue(srcFactor, dstFactor, srcFactorAlpha, dstFactorAlpha);
+            }
 
-   public static void tryBlendFuncSeparate(int var0, int var1, int var2, int var3) {
-      if (☃ != blendState.srcFactor || ☃ != blendState.dstFactor || ☃ != blendState.srcFactorAlpha || ☃ != blendState.dstFactorAlpha) {
-         blendState.srcFactor = ☃;
-         blendState.dstFactor = ☃;
-         blendState.srcFactorAlpha = ☃;
-         blendState.dstFactorAlpha = ☃;
-         OpenGlHelper.glBlendFunc(☃, ☃, ☃, ☃);
+            OpenGlHelper.glBlendFunc(srcFactor, dstFactor, srcFactorAlpha, dstFactorAlpha);
+         }
       }
    }
 
-   public static void glBlendEquation(int var0) {
-      GL14.glBlendEquation(☃);
+   public static void glBlendEquation(int blendEquation) {
+      GL14.glBlendEquation(blendEquation);
    }
 
-   public static void enableOutlineMode(int var0) {
-      BUF_FLOAT_4.put(0, (☃ >> 16 & 0xFF) / 255.0F);
-      BUF_FLOAT_4.put(1, (☃ >> 8 & 0xFF) / 255.0F);
-      BUF_FLOAT_4.put(2, (☃ >> 0 & 0xFF) / 255.0F);
-      BUF_FLOAT_4.put(3, (☃ >> 24 & 0xFF) / 255.0F);
+   public static void enableOutlineMode(int p_187431_0_) {
+      BUF_FLOAT_4.put(0, (p_187431_0_ >> 16 & 0xFF) / 255.0F);
+      BUF_FLOAT_4.put(1, (p_187431_0_ >> 8 & 0xFF) / 255.0F);
+      BUF_FLOAT_4.put(2, (p_187431_0_ >> 0 & 0xFF) / 255.0F);
+      BUF_FLOAT_4.put(3, (p_187431_0_ >> 24 & 0xFF) / 255.0F);
       glTexEnv(8960, 8705, BUF_FLOAT_4);
       glTexEnvi(8960, 8704, 34160);
       glTexEnvi(8960, 34161, 7681);
@@ -198,44 +256,54 @@ public static void disableFog() {
       fogState.fog.setDisabled();
    }
 
-   public static void setFog(GlStateManager.FogMode var0) {
-      setFog(☃.capabilityId);
+   public static void setFog(GlStateManager.FogMode fogMode) {
+      setFog(fogMode.capabilityId);
    }
 
-   private static void setFog(int var0) {
-      if (☃ != fogState.mode) {
-         fogState.mode = ☃;
-         GL11.glFogi(2917, ☃);
+   private static void setFog(int param) {
+      if (param != fogState.mode) {
+         fogState.mode = param;
+         GL11.glFogi(2917, param);
+         if (Config.isShaders()) {
+            Shaders.setFogMode(param);
+         }
       }
    }
 
-   public static void setFogDensity(float var0) {
-      if (☃ != fogState.density) {
-         fogState.density = ☃;
-         GL11.glFogf(2914, ☃);
+   public static void setFogDensity(float param) {
+      if (param < 0.0F) {
+         param = 0.0F;
+      }
+
+      if (param != fogState.density) {
+         fogState.density = param;
+         GL11.glFogf(2914, param);
+         if (Config.isShaders()) {
+            Shaders.setFogDensity(param);
+         }
       }
    }
 
-   public static void setFogStart(float var0) {
-      if (☃ != fogState.start) {
-         fogState.start = ☃;
-         GL11.glFogf(2915, ☃);
+   public static void setFogStart(float param) {
+      if (param != fogState.start) {
+         fogState.start = param;
+         GL11.glFogf(2915, param);
       }
    }
 
-   public static void setFogEnd(float var0) {
-      if (☃ != fogState.end) {
-         fogState.end = ☃;
-         GL11.glFogf(2916, ☃);
+   public static void setFogEnd(float param) {
+      if (param != fogState.end) {
+         fogState.end = param;
+         GL11.glFogf(2916, param);
       }
    }
 
-   public static void glFog(int var0, FloatBuffer var1) {
-      GL11.glFog(☃, ☃);
+   public static void glFog(int pname, FloatBuffer param) {
+      GL11.glFog(pname, param);
    }
 
-   public static void glFogi(int var0, int var1) {
-      GL11.glFogi(☃, ☃);
+   public static void glFogi(int pname, int param) {
+      GL11.glFogi(pname, param);
    }
 
    public static void enableCull() {
@@ -246,19 +314,19 @@ public static void disableCull() {
       cullState.cullFace.setDisabled();
    }
 
-   public static void cullFace(GlStateManager.CullFace var0) {
-      cullFace(☃.mode);
+   public static void cullFace(GlStateManager.CullFace cullFace) {
+      cullFace(cullFace.mode);
    }
 
-   private static void cullFace(int var0) {
-      if (☃ != cullState.mode) {
-         cullState.mode = ☃;
-         GL11.glCullFace(☃);
+   private static void cullFace(int mode) {
+      if (mode != cullState.mode) {
+         cullState.mode = mode;
+         GL11.glCullFace(mode);
       }
    }
 
-   public static void glPolygonMode(int var0, int var1) {
-      GL11.glPolygonMode(☃, ☃);
+   public static void glPolygonMode(int face, int mode) {
+      GL11.glPolygonMode(face, mode);
    }
 
    public static void enablePolygonOffset() {
@@ -269,11 +337,11 @@ public static void disablePolygonOffset() {
       polygonOffsetState.polygonOffsetFill.setDisabled();
    }
 
-   public static void doPolygonOffset(float var0, float var1) {
-      if (☃ != polygonOffsetState.factor || ☃ != polygonOffsetState.units) {
-         polygonOffsetState.factor = ☃;
-         polygonOffsetState.units = ☃;
-         GL11.glPolygonOffset(☃, ☃);
+   public static void doPolygonOffset(float factor, float units) {
+      if (factor != polygonOffsetState.factor || units != polygonOffsetState.units) {
+         polygonOffsetState.factor = factor;
+         polygonOffsetState.units = units;
+         GL11.glPolygonOffset(factor, units);
       }
    }
 
@@ -285,39 +353,39 @@ public static void disableColorLogic() {
       colorLogicState.colorLogicOp.setDisabled();
    }
 
-   public static void colorLogicOp(GlStateManager.LogicOp var0) {
-      colorLogicOp(☃.opcode);
+   public static void colorLogicOp(GlStateManager.LogicOp logicOperation) {
+      colorLogicOp(logicOperation.opcode);
    }
 
-   public static void colorLogicOp(int var0) {
-      if (☃ != colorLogicState.opcode) {
-         colorLogicState.opcode = ☃;
-         GL11.glLogicOp(☃);
+   public static void colorLogicOp(int opcode) {
+      if (opcode != colorLogicState.opcode) {
+         colorLogicState.opcode = opcode;
+         GL11.glLogicOp(opcode);
       }
    }
 
-   public static void enableTexGenCoord(GlStateManager.TexGen var0) {
-      texGenCoord(☃).textureGen.setEnabled();
+   public static void enableTexGenCoord(GlStateManager.TexGen texGen) {
+      texGenCoord(texGen).textureGen.setEnabled();
    }
 
-   public static void disableTexGenCoord(GlStateManager.TexGen var0) {
-      texGenCoord(☃).textureGen.setDisabled();
+   public static void disableTexGenCoord(GlStateManager.TexGen texGen) {
+      texGenCoord(texGen).textureGen.setDisabled();
    }
 
-   public static void texGen(GlStateManager.TexGen var0, int var1) {
-      GlStateManager.TexGenCoord ☃ = texGenCoord(☃);
-      if (☃ != ☃.param) {
-         ☃.param = ☃;
-         GL11.glTexGeni(☃.coord, 9472, ☃);
+   public static void texGen(GlStateManager.TexGen texGen, int param) {
+      GlStateManager.TexGenCoord glstatemanager$texgencoord = texGenCoord(texGen);
+      if (param != glstatemanager$texgencoord.param) {
+         glstatemanager$texgencoord.param = param;
+         GL11.glTexGeni(glstatemanager$texgencoord.coord, 9472, param);
       }
    }
 
-   public static void texGen(GlStateManager.TexGen var0, int var1, FloatBuffer var2) {
-      GL11.glTexGen(texGenCoord(☃).coord, ☃, ☃);
+   public static void texGen(GlStateManager.TexGen texGen, int pname, FloatBuffer params) {
+      GL11.glTexGen(texGenCoord(texGen).coord, pname, params);
    }
 
-   private static GlStateManager.TexGenCoord texGenCoord(GlStateManager.TexGen var0) {
-      switch (☃) {
+   private static GlStateManager.TexGenCoord texGenCoord(GlStateManager.TexGen texGen) {
+      switch (texGen) {
          case S:
             return texGenState.s;
          case T:
@@ -331,10 +399,10 @@ private static GlStateManager.TexGenCoord texGenCoord(GlStateManager.TexGen var0
       }
    }
 
-   public static void setActiveTexture(int var0) {
-      if (activeTextureUnit != ☃ - OpenGlHelper.defaultTexUnit) {
-         activeTextureUnit = ☃ - OpenGlHelper.defaultTexUnit;
-         OpenGlHelper.setActiveTexture(☃);
+   public static void setActiveTexture(int texture) {
+      if (activeTextureUnit != texture - OpenGlHelper.defaultTexUnit) {
+         activeTextureUnit = texture - OpenGlHelper.defaultTexUnit;
+         OpenGlHelper.setActiveTexture(texture);
       }
    }
 
@@ -346,65 +414,72 @@ public static void disableTexture2D() {
       textureState[activeTextureUnit].texture2DState.setDisabled();
    }
 
-   public static void glTexEnv(int var0, int var1, FloatBuffer var2) {
-      GL11.glTexEnv(☃, ☃, ☃);
+   public static void glTexEnv(int target, int parameterName, FloatBuffer parameters) {
+      GL11.glTexEnv(target, parameterName, parameters);
    }
 
-   public static void glTexEnvi(int var0, int var1, int var2) {
-      GL11.glTexEnvi(☃, ☃, ☃);
+   public static void glTexEnvi(int target, int parameterName, int parameter) {
+      GL11.glTexEnvi(target, parameterName, parameter);
    }
 
-   public static void glTexEnvf(int var0, int var1, float var2) {
-      GL11.glTexEnvf(☃, ☃, ☃);
+   public static void glTexEnvf(int target, int parameterName, float parameter) {
+      GL11.glTexEnvf(target, parameterName, parameter);
    }
 
-   public static void glTexParameterf(int var0, int var1, float var2) {
-      GL11.glTexParameterf(☃, ☃, ☃);
+   public static void glTexParameterf(int target, int parameterName, float parameter) {
+      GL11.glTexParameterf(target, parameterName, parameter);
    }
 
-   public static void glTexParameteri(int var0, int var1, int var2) {
-      GL11.glTexParameteri(☃, ☃, ☃);
+   public static void glTexParameteri(int target, int parameterName, int parameter) {
+      GL11.glTexParameteri(target, parameterName, parameter);
    }
 
-   public static int glGetTexLevelParameteri(int var0, int var1, int var2) {
-      return GL11.glGetTexLevelParameteri(☃, ☃, ☃);
+   public static int glGetTexLevelParameteri(int target, int level, int parameterName) {
+      return GL11.glGetTexLevelParameteri(target, level, parameterName);
    }
 
    public static int generateTexture() {
       return GL11.glGenTextures();
    }
 
-   public static void deleteTexture(int var0) {
-      GL11.glDeleteTextures(☃);
+   public static void deleteTexture(int texture) {
+      if (texture != 0) {
+         GL11.glDeleteTextures(texture);
 
-      for (GlStateManager.TextureState ☃ : textureState) {
-         if (☃.textureName == ☃) {
-            ☃.textureName = -1;
+         for (GlStateManager.TextureState glstatemanager$texturestate : textureState) {
+            if (glstatemanager$texturestate.textureName == texture) {
+               glstatemanager$texturestate.textureName = 0;
+            }
          }
       }
    }
 
-   public static void bindTexture(int var0) {
-      if (☃ != textureState[activeTextureUnit].textureName) {
-         textureState[activeTextureUnit].textureName = ☃;
-         GL11.glBindTexture(3553, ☃);
+   public static void bindTexture(int texture) {
+      if (texture != textureState[activeTextureUnit].textureName) {
+         textureState[activeTextureUnit].textureName = texture;
+         GL11.glBindTexture(3553, texture);
+         if (SmartAnimations.isActive()) {
+            SmartAnimations.textureRendered(texture);
+         }
       }
    }
 
-   public static void glTexImage2D(int var0, int var1, int var2, int var3, int var4, int var5, int var6, int var7, @Nullable IntBuffer var8) {
-      GL11.glTexImage2D(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public static void glTexImage2D(
+      int target, int level, int internalFormat, int width, int height, int border, int format, int type, @Nullable IntBuffer pixels
+   ) {
+      GL11.glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
    }
 
-   public static void glTexSubImage2D(int var0, int var1, int var2, int var3, int var4, int var5, int var6, int var7, IntBuffer var8) {
-      GL11.glTexSubImage2D(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public static void glTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, IntBuffer pixels) {
+      GL11.glTexSubImage2D(target, level, xOffset, yOffset, width, height, format, type, pixels);
    }
 
-   public static void glCopyTexSubImage2D(int var0, int var1, int var2, int var3, int var4, int var5, int var6, int var7) {
-      GL11.glCopyTexSubImage2D(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public static void glCopyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height) {
+      GL11.glCopyTexSubImage2D(target, level, xOffset, yOffset, x, y, width, height);
    }
 
-   public static void glGetTexImage(int var0, int var1, int var2, int var3, IntBuffer var4) {
-      GL11.glGetTexImage(☃, ☃, ☃, ☃, ☃);
+   public static void glGetTexImage(int target, int level, int format, int type, IntBuffer pixels) {
+      GL11.glGetTexImage(target, level, format, type, pixels);
    }
 
    public static void enableNormalize() {
@@ -415,10 +490,10 @@ public static void disableNormalize() {
       normalizeState.setDisabled();
    }
 
-   public static void shadeModel(int var0) {
-      if (☃ != activeShadeModel) {
-         activeShadeModel = ☃;
-         GL11.glShadeModel(☃);
+   public static void shadeModel(int mode) {
+      if (mode != activeShadeModel) {
+         activeShadeModel = mode;
+         GL11.glShadeModel(mode);
       }
    }
 
@@ -430,43 +505,45 @@ public static void disableRescaleNormal() {
       rescaleNormalState.setDisabled();
    }
 
-   public static void viewport(int var0, int var1, int var2, int var3) {
-      GL11.glViewport(☃, ☃, ☃, ☃);
+   public static void viewport(int x, int y, int width, int height) {
+      GL11.glViewport(x, y, width, height);
    }
 
-   public static void colorMask(boolean var0, boolean var1, boolean var2, boolean var3) {
-      if (☃ != colorMaskState.red || ☃ != colorMaskState.green || ☃ != colorMaskState.blue || ☃ != colorMaskState.alpha) {
-         colorMaskState.red = ☃;
-         colorMaskState.green = ☃;
-         colorMaskState.blue = ☃;
-         colorMaskState.alpha = ☃;
-         GL11.glColorMask(☃, ☃, ☃, ☃);
+   public static void colorMask(boolean red, boolean green, boolean blue, boolean alpha) {
+      if (red != colorMaskState.red || green != colorMaskState.green || blue != colorMaskState.blue || alpha != colorMaskState.alpha) {
+         colorMaskState.red = red;
+         colorMaskState.green = green;
+         colorMaskState.blue = blue;
+         colorMaskState.alpha = alpha;
+         GL11.glColorMask(red, green, blue, alpha);
       }
    }
 
-   public static void clearDepth(double var0) {
-      if (☃ != clearState.depth) {
-         clearState.depth = ☃;
-         GL11.glClearDepth(☃);
+   public static void clearDepth(double depth) {
+      if (depth != clearState.depth) {
+         clearState.depth = depth;
+         GL11.glClearDepth(depth);
       }
    }
 
-   public static void clearColor(float var0, float var1, float var2, float var3) {
-      if (☃ != clearState.color.red || ☃ != clearState.color.green || ☃ != clearState.color.blue || ☃ != clearState.color.alpha) {
-         clearState.color.red = ☃;
-         clearState.color.green = ☃;
-         clearState.color.blue = ☃;
-         clearState.color.alpha = ☃;
-         GL11.glClearColor(☃, ☃, ☃, ☃);
+   public static void clearColor(float red, float green, float blue, float alpha) {
+      if (red != clearState.color.red || green != clearState.color.green || blue != clearState.color.blue || alpha != clearState.color.alpha) {
+         clearState.color.red = red;
+         clearState.color.green = green;
+         clearState.color.blue = blue;
+         clearState.color.alpha = alpha;
+         GL11.glClearColor(red, green, blue, alpha);
       }
    }
 
-   public static void clear(int var0) {
-      GL11.glClear(☃);
+   public static void clear(int mask) {
+      if (clearEnabled) {
+         GL11.glClear(mask);
+      }
    }
 
-   public static void matrixMode(int var0) {
-      GL11.glMatrixMode(☃);
+   public static void matrixMode(int mode) {
+      GL11.glMatrixMode(mode);
    }
 
    public static void loadIdentity() {
@@ -481,93 +558,93 @@ public static void popMatrix() {
       GL11.glPopMatrix();
    }
 
-   public static void getFloat(int var0, FloatBuffer var1) {
-      GL11.glGetFloat(☃, ☃);
+   public static void getFloat(int pname, FloatBuffer params) {
+      GL11.glGetFloat(pname, params);
    }
 
-   public static void ortho(double var0, double var2, double var4, double var6, double var8, double var10) {
-      GL11.glOrtho(☃, ☃, ☃, ☃, ☃, ☃);
+   public static void ortho(double left, double right, double bottom, double top, double zNear, double zFar) {
+      GL11.glOrtho(left, right, bottom, top, zNear, zFar);
    }
 
-   public static void rotate(float var0, float var1, float var2, float var3) {
-      GL11.glRotatef(☃, ☃, ☃, ☃);
+   public static void rotate(float angle, float x, float y, float z) {
+      GL11.glRotatef(angle, x, y, z);
    }
 
-   public static void scale(float var0, float var1, float var2) {
-      GL11.glScalef(☃, ☃, ☃);
+   public static void scale(float x, float y, float z) {
+      GL11.glScalef(x, y, z);
    }
 
-   public static void scale(double var0, double var2, double var4) {
-      GL11.glScaled(☃, ☃, ☃);
+   public static void scale(double x, double y, double z) {
+      GL11.glScaled(x, y, z);
    }
 
-   public static void translate(float var0, float var1, float var2) {
-      GL11.glTranslatef(☃, ☃, ☃);
+   public static void translate(float x, float y, float z) {
+      GL11.glTranslatef(x, y, z);
    }
 
-   public static void translate(double var0, double var2, double var4) {
-      GL11.glTranslated(☃, ☃, ☃);
+   public static void translate(double x, double y, double z) {
+      GL11.glTranslated(x, y, z);
    }
 
-   public static void multMatrix(FloatBuffer var0) {
-      GL11.glMultMatrix(☃);
+   public static void multMatrix(FloatBuffer matrix) {
+      GL11.glMultMatrix(matrix);
    }
 
-   public static void rotate(Quaternion var0) {
-      multMatrix(quatToGlMatrix(BUF_FLOAT_16, ☃));
+   public static void rotate(Quaternion quaternionIn) {
+      multMatrix(quatToGlMatrix(BUF_FLOAT_16, quaternionIn));
    }
 
-   public static FloatBuffer quatToGlMatrix(FloatBuffer var0, Quaternion var1) {
-      ((Buffer)☃).clear();
-      float ☃ = ☃.x * ☃.x;
-      float ☃x = ☃.x * ☃.y;
-      float ☃xx = ☃.x * ☃.z;
-      float ☃xxx = ☃.x * ☃.w;
-      float ☃xxxx = ☃.y * ☃.y;
-      float ☃xxxxx = ☃.y * ☃.z;
-      float ☃xxxxxx = ☃.y * ☃.w;
-      float ☃xxxxxxx = ☃.z * ☃.z;
-      float ☃xxxxxxxx = ☃.z * ☃.w;
-      ☃.put(1.0F - 2.0F * (☃xxxx + ☃xxxxxxx));
-      ☃.put(2.0F * (☃x + ☃xxxxxxxx));
-      ☃.put(2.0F * (☃xx - ☃xxxxxx));
-      ☃.put(0.0F);
-      ☃.put(2.0F * (☃x - ☃xxxxxxxx));
-      ☃.put(1.0F - 2.0F * (☃ + ☃xxxxxxx));
-      ☃.put(2.0F * (☃xxxxx + ☃xxx));
-      ☃.put(0.0F);
-      ☃.put(2.0F * (☃xx + ☃xxxxxx));
-      ☃.put(2.0F * (☃xxxxx - ☃xxx));
-      ☃.put(1.0F - 2.0F * (☃ + ☃xxxx));
-      ☃.put(0.0F);
-      ☃.put(0.0F);
-      ☃.put(0.0F);
-      ☃.put(0.0F);
-      ☃.put(1.0F);
-      ((Buffer)☃).rewind();
-      return ☃;
+   public static FloatBuffer quatToGlMatrix(FloatBuffer buffer, Quaternion quaternionIn) {
+      ((Buffer)buffer).clear();
+      float f = quaternionIn.x * quaternionIn.x;
+      float f1 = quaternionIn.x * quaternionIn.y;
+      float f2 = quaternionIn.x * quaternionIn.z;
+      float f3 = quaternionIn.x * quaternionIn.w;
+      float f4 = quaternionIn.y * quaternionIn.y;
+      float f5 = quaternionIn.y * quaternionIn.z;
+      float f6 = quaternionIn.y * quaternionIn.w;
+      float f7 = quaternionIn.z * quaternionIn.z;
+      float f8 = quaternionIn.z * quaternionIn.w;
+      buffer.put(1.0F - 2.0F * (f4 + f7));
+      buffer.put(2.0F * (f1 + f8));
+      buffer.put(2.0F * (f2 - f6));
+      buffer.put(0.0F);
+      buffer.put(2.0F * (f1 - f8));
+      buffer.put(1.0F - 2.0F * (f + f7));
+      buffer.put(2.0F * (f5 + f3));
+      buffer.put(0.0F);
+      buffer.put(2.0F * (f2 + f6));
+      buffer.put(2.0F * (f5 - f3));
+      buffer.put(1.0F - 2.0F * (f + f4));
+      buffer.put(0.0F);
+      buffer.put(0.0F);
+      buffer.put(0.0F);
+      buffer.put(0.0F);
+      buffer.put(1.0F);
+      ((Buffer)buffer).rewind();
+      return buffer;
    }
 
-   public static void color(float var0, float var1, float var2, float var3) {
-      if (☃ != colorState.red || ☃ != colorState.green || ☃ != colorState.blue || ☃ != colorState.alpha) {
-         colorState.red = ☃;
-         colorState.green = ☃;
-         colorState.blue = ☃;
-         colorState.alpha = ☃;
-         GL11.glColor4f(☃, ☃, ☃, ☃);
+   public static void color(float colorRed, float colorGreen, float colorBlue, float colorAlpha) {
+      if (colorRed != colorState.red || colorGreen != colorState.green || colorBlue != colorState.blue || colorAlpha != colorState.alpha) {
+         colorState.red = colorRed;
+         colorState.green = colorGreen;
+         colorState.blue = colorBlue;
+         colorState.alpha = colorAlpha;
+         GL11.glColor4f(colorRed, colorGreen, colorBlue, colorAlpha);
       }
    }
 
-   public static void color(float var0, float var1, float var2) {
-      color(☃, ☃, ☃, 1.0F);
+   public static void color(float colorRed, float colorGreen, float colorBlue) {
+      color(colorRed, colorGreen, colorBlue, 1.0F);
    }
 
-   public static void glTexCoord2f(float var0, float var1) {
-      GL11.glTexCoord2f(☃, ☃);
+   public static void glTexCoord2f(float sCoord, float tCoord) {
+      GL11.glTexCoord2f(sCoord, tCoord);
    }
 
-   public static void glVertex3f(float var0, float var1, float var2) {
-      GL11.glVertex3f(☃, ☃, ☃);
+   public static void glVertex3f(float x, float y, float z) {
+      GL11.glVertex3f(x, y, z);
    }
 
    public static void resetColor() {
@@ -577,113 +654,278 @@ public static void resetColor() {
       colorState.alpha = -1.0F;
    }
 
-   public static void glNormalPointer(int var0, int var1, ByteBuffer var2) {
-      GL11.glNormalPointer(☃, ☃, ☃);
+   public static void glNormalPointer(int type, int stride, ByteBuffer buffer) {
+      GL11.glNormalPointer(type, stride, buffer);
    }
 
-   public static void glTexCoordPointer(int var0, int var1, int var2, int var3) {
-      GL11.glTexCoordPointer(☃, ☃, ☃, ☃);
+   public static void glTexCoordPointer(int size, int type, int stride, int buffer_offset) {
+      GL11.glTexCoordPointer(size, type, stride, buffer_offset);
    }
 
-   public static void glTexCoordPointer(int var0, int var1, int var2, ByteBuffer var3) {
-      GL11.glTexCoordPointer(☃, ☃, ☃, ☃);
+   public static void glTexCoordPointer(int size, int type, int stride, ByteBuffer buffer) {
+      GL11.glTexCoordPointer(size, type, stride, buffer);
    }
 
-   public static void glVertexPointer(int var0, int var1, int var2, int var3) {
-      GL11.glVertexPointer(☃, ☃, ☃, ☃);
+   public static void glVertexPointer(int size, int type, int stride, int buffer_offset) {
+      GL11.glVertexPointer(size, type, stride, buffer_offset);
    }
 
-   public static void glVertexPointer(int var0, int var1, int var2, ByteBuffer var3) {
-      GL11.glVertexPointer(☃, ☃, ☃, ☃);
+   public static void glVertexPointer(int size, int type, int stride, ByteBuffer buffer) {
+      GL11.glVertexPointer(size, type, stride, buffer);
    }
 
-   public static void glColorPointer(int var0, int var1, int var2, int var3) {
-      GL11.glColorPointer(☃, ☃, ☃, ☃);
+   public static void glColorPointer(int size, int type, int stride, int buffer_offset) {
+      GL11.glColorPointer(size, type, stride, buffer_offset);
    }
 
-   public static void glColorPointer(int var0, int var1, int var2, ByteBuffer var3) {
-      GL11.glColorPointer(☃, ☃, ☃, ☃);
+   public static void glColorPointer(int size, int type, int stride, ByteBuffer buffer) {
+      GL11.glColorPointer(size, type, stride, buffer);
    }
 
-   public static void glDisableClientState(int var0) {
-      GL11.glDisableClientState(☃);
+   public static void glDisableClientState(int cap) {
+      GL11.glDisableClientState(cap);
    }
 
-   public static void glEnableClientState(int var0) {
-      GL11.glEnableClientState(☃);
+   public static void glEnableClientState(int cap) {
+      GL11.glEnableClientState(cap);
    }
 
-   public static void glBegin(int var0) {
-      GL11.glBegin(☃);
+   public static void glBegin(int mode) {
+      GL11.glBegin(mode);
    }
 
    public static void glEnd() {
       GL11.glEnd();
    }
 
-   public static void glDrawArrays(int var0, int var1, int var2) {
-      GL11.glDrawArrays(☃, ☃, ☃);
+   public static void glDrawArrays(int mode, int first, int count) {
+      GL11.glDrawArrays(mode, first, count);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int countInstances = Shaders.activeProgram.getCountInstances();
+         if (countInstances > 1) {
+            for (int i = 1; i < countInstances; i++) {
+               Shaders.uniform_instanceId.setValue(i);
+               GL11.glDrawArrays(mode, first, count);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
+   }
+
+   public static void glLineWidth(float width) {
+      GL11.glLineWidth(width);
    }
 
-   public static void glLineWidth(float var0) {
-      GL11.glLineWidth(☃);
+   public static void callList(int list) {
+      GL11.glCallList(list);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int countInstances = Shaders.activeProgram.getCountInstances();
+         if (countInstances > 1) {
+            for (int i = 1; i < countInstances; i++) {
+               Shaders.uniform_instanceId.setValue(i);
+               GL11.glCallList(list);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
    }
 
-   public static void callList(int var0) {
-      GL11.glCallList(☃);
+   public static void callLists(IntBuffer lists) {
+      GL11.glCallLists(lists);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int countInstances = Shaders.activeProgram.getCountInstances();
+         if (countInstances > 1) {
+            for (int i = 1; i < countInstances; i++) {
+               Shaders.uniform_instanceId.setValue(i);
+               GL11.glCallLists(lists);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
    }
 
-   public static void glDeleteLists(int var0, int var1) {
-      GL11.glDeleteLists(☃, ☃);
+   public static void glDeleteLists(int list, int range) {
+      GL11.glDeleteLists(list, range);
    }
 
-   public static void glNewList(int var0, int var1) {
-      GL11.glNewList(☃, ☃);
+   public static void glNewList(int list, int mode) {
+      GL11.glNewList(list, mode);
+      creatingDisplayList = true;
    }
 
    public static void glEndList() {
       GL11.glEndList();
+      creatingDisplayList = false;
    }
 
-   public static int glGenLists(int var0) {
-      return GL11.glGenLists(☃);
+   public static int glGenLists(int range) {
+      return GL11.glGenLists(range);
    }
 
-   public static void glPixelStorei(int var0, int var1) {
-      GL11.glPixelStorei(☃, ☃);
+   public static void glPixelStorei(int parameterName, int param) {
+      GL11.glPixelStorei(parameterName, param);
    }
 
-   public static void glReadPixels(int var0, int var1, int var2, int var3, int var4, int var5, IntBuffer var6) {
-      GL11.glReadPixels(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public static void glReadPixels(int x, int y, int width, int height, int format, int type, IntBuffer pixels) {
+      GL11.glReadPixels(x, y, width, height, format, type, pixels);
    }
 
    public static int glGetError() {
       return GL11.glGetError();
    }
 
-   public static String glGetString(int var0) {
-      return GL11.glGetString(☃);
+   public static String glGetString(int name) {
+      return GL11.glGetString(name);
+   }
+
+   public static void glGetInteger(int parameterName, IntBuffer parameters) {
+      GL11.glGetInteger(parameterName, parameters);
+   }
+
+   public static int glGetInteger(int parameterName) {
+      return GL11.glGetInteger(parameterName);
+   }
+
+   public static void enableBlendProfile(GlStateManager.Profile p_187408_0_) {
+      p_187408_0_.apply();
+   }
+
+   public static void disableBlendProfile(GlStateManager.Profile p_187440_0_) {
+      p_187440_0_.clean();
+   }
+
+   public static int getActiveTextureUnit() {
+      return OpenGlHelper.defaultTexUnit + activeTextureUnit;
+   }
+
+   public static void bindCurrentTexture() {
+      GL11.glBindTexture(3553, textureState[activeTextureUnit].textureName);
+   }
+
+   public static int getBoundTexture() {
+      return textureState[activeTextureUnit].textureName;
+   }
+
+   public static void checkBoundTexture() {
+      if (Config.isMinecraftThread()) {
+         int glAct = GL11.glGetInteger(34016);
+         int glTex = GL11.glGetInteger(32873);
+         int act = getActiveTextureUnit();
+         int tex = getBoundTexture();
+         if (tex > 0) {
+            if (glAct != act || glTex != tex) {
+               Config.dbg("checkTexture: act: " + act + ", glAct: " + glAct + ", tex: " + tex + ", glTex: " + glTex);
+            }
+         }
+      }
+   }
+
+   public static void deleteTextures(IntBuffer buf) {
+      ((Buffer)buf).rewind();
+
+      while (buf.position() < buf.limit()) {
+         int texId = buf.get();
+         deleteTexture(texId);
+      }
+
+      ((Buffer)buf).rewind();
+   }
+
+   public static boolean isFogEnabled() {
+      return fogState.fog.currentState;
+   }
+
+   public static void setFogEnabled(boolean state) {
+      fogState.fog.setState(state);
+   }
+
+   public static void lockAlpha(GlAlphaState stateNew) {
+      if (!alphaLock.isLocked()) {
+         getAlphaState(alphaLockState);
+         setAlphaState(stateNew);
+         alphaLock.lock();
+      }
    }
 
-   public static void glGetInteger(int var0, IntBuffer var1) {
-      GL11.glGetInteger(☃, ☃);
+   public static void unlockAlpha() {
+      if (alphaLock.unlock()) {
+         setAlphaState(alphaLockState);
+      }
    }
 
-   public static int glGetInteger(int var0) {
-      return GL11.glGetInteger(☃);
+   public static void getAlphaState(GlAlphaState state) {
+      if (alphaLock.isLocked()) {
+         state.setState(alphaLockState);
+      } else {
+         state.setState(alphaState.alphaTest.currentState, alphaState.func, alphaState.ref);
+      }
    }
 
-   public static void enableBlendProfile(GlStateManager.Profile var0) {
-      ☃.apply();
+   public static void setAlphaState(GlAlphaState state) {
+      if (alphaLock.isLocked()) {
+         alphaLockState.setState(state);
+      } else {
+         alphaState.alphaTest.setState(state.isEnabled());
+         alphaFunc(state.getFunc(), state.getRef());
+      }
    }
 
-   public static void disableBlendProfile(GlStateManager.Profile var0) {
-      ☃.clean();
+   public static void lockBlend(GlBlendState stateNew) {
+      if (!blendLock.isLocked()) {
+         getBlendState(blendLockState);
+         setBlendState(stateNew);
+         blendLock.lock();
+      }
+   }
+
+   public static void unlockBlend() {
+      if (blendLock.unlock()) {
+         setBlendState(blendLockState);
+      }
+   }
+
+   public static void getBlendState(GlBlendState gbs) {
+      if (blendLock.isLocked()) {
+         gbs.setState(blendLockState);
+      } else {
+         gbs.setState(blendState.blend.currentState, blendState.srcFactor, blendState.dstFactor, blendState.srcFactorAlpha, blendState.dstFactorAlpha);
+      }
+   }
+
+   public static void setBlendState(GlBlendState gbs) {
+      if (blendLock.isLocked()) {
+         blendLockState.setState(gbs);
+      } else {
+         blendState.blend.setState(gbs.isEnabled());
+         if (!gbs.isSeparate()) {
+            blendFunc(gbs.getSrcFactor(), gbs.getDstFactor());
+         } else {
+            tryBlendFuncSeparate(gbs.getSrcFactor(), gbs.getDstFactor(), gbs.getSrcFactorAlpha(), gbs.getDstFactorAlpha());
+         }
+      }
+   }
+
+   public static void glMultiDrawArrays(int mode, IntBuffer bFirst, IntBuffer bCount) {
+      GL14.glMultiDrawArrays(mode, bFirst, bCount);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int countInstances = Shaders.activeProgram.getCountInstances();
+         if (countInstances > 1) {
+            for (int i = 1; i < countInstances; i++) {
+               Shaders.uniform_instanceId.setValue(i);
+               GL14.glMultiDrawArrays(mode, bFirst, bCount);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
    }
 
    static {
-      for (int ☃ = 0; ☃ < 8; ☃++) {
-         lightState[☃] = new GlStateManager.BooleanState(16384 + ☃);
+      for (int i = 0; i < 8; i++) {
+         lightState[i] = new GlStateManager.BooleanState(16384 + i);
       }
 
       colorMaterialState = new GlStateManager.ColorMaterialState();
@@ -697,10 +939,10 @@ public static void disableBlendProfile(GlStateManager.Profile var0) {
       clearState = new GlStateManager.ClearState();
       stencilState = new GlStateManager.StencilState();
       normalizeState = new GlStateManager.BooleanState(2977);
-      textureState = new GlStateManager.TextureState[8];
+      textureState = new GlStateManager.TextureState[32];
 
-      for (int ☃ = 0; ☃ < 8; ☃++) {
-         textureState[☃] = new GlStateManager.TextureState();
+      for (int j = 0; j < textureState.length; j++) {
+         textureState[j] = new GlStateManager.TextureState();
       }
 
       activeShadeModel = 7425;
@@ -733,8 +975,8 @@ static class BooleanState {
       private final int capability;
       private boolean currentState;
 
-      public BooleanState(int var1) {
-         this.capability = ☃;
+      public BooleanState(int capabilityIn) {
+         this.capability = capabilityIn;
       }
 
       public void setDisabled() {
@@ -745,10 +987,10 @@ public void setEnabled() {
          this.setState(true);
       }
 
-      public void setState(boolean var1) {
-         if (☃ != this.currentState) {
-            this.currentState = ☃;
-            if (☃) {
+      public void setState(boolean state) {
+         if (state != this.currentState) {
+            this.currentState = state;
+            if (state) {
                GL11.glEnable(this.capability);
             } else {
                GL11.glDisable(this.capability);
@@ -775,11 +1017,11 @@ public Color() {
          this(1.0F, 1.0F, 1.0F, 1.0F);
       }
 
-      public Color(float var1, float var2, float var3, float var4) {
-         this.red = ☃;
-         this.green = ☃;
-         this.blue = ☃;
-         this.alpha = ☃;
+      public Color(float redIn, float greenIn, float blueIn, float alphaIn) {
+         this.red = redIn;
+         this.green = greenIn;
+         this.blue = blueIn;
+         this.alpha = alphaIn;
       }
    }
 
@@ -817,8 +1059,8 @@ public static enum CullFace {
 
       public final int mode;
 
-      private CullFace(int var3) {
-         this.mode = ☃;
+      private CullFace(int modeIn) {
+         this.mode = modeIn;
       }
    }
 
@@ -857,8 +1099,8 @@ public static enum DestFactor {
 
       public final int factor;
 
-      private DestFactor(int var3) {
-         this.factor = ☃;
+      private DestFactor(int factorIn) {
+         this.factor = factorIn;
       }
    }
 
@@ -869,8 +1111,8 @@ public static enum FogMode {
 
       public final int capabilityId;
 
-      private FogMode(int var3) {
-         this.capabilityId = ☃;
+      private FogMode(int capabilityIn) {
+         this.capabilityId = capabilityIn;
       }
    }
 
@@ -905,8 +1147,8 @@ public static enum LogicOp {
 
       public final int opcode;
 
-      private LogicOp(int var3) {
-         this.opcode = ☃;
+      private LogicOp(int opcodeIn) {
+         this.opcode = opcodeIn;
       }
    }
 
@@ -927,18 +1169,18 @@ public void apply() {
             GlStateManager.disableAlpha();
             GlStateManager.alphaFunc(519, 0.0F);
             GlStateManager.disableLighting();
-            GlStateManager.glLightModel(2899, RenderHelper.setColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
-
-            for (int ☃ = 0; ☃ < 8; ☃++) {
-               GlStateManager.disableLight(☃);
-               GlStateManager.glLight(16384 + ☃, 4608, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
-               GlStateManager.glLight(16384 + ☃, 4611, RenderHelper.setColorBuffer(0.0F, 0.0F, 1.0F, 0.0F));
-               if (☃ == 0) {
-                  GlStateManager.glLight(16384 + ☃, 4609, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
-                  GlStateManager.glLight(16384 + ☃, 4610, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+            GL11.glLightModel(2899, RenderHelper.setColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
+
+            for (int i = 0; i < 8; i++) {
+               GlStateManager.disableLight(i);
+               GL11.glLight(16384 + i, 4608, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+               GL11.glLight(16384 + i, 4611, RenderHelper.setColorBuffer(0.0F, 0.0F, 1.0F, 0.0F));
+               if (i == 0) {
+                  GL11.glLight(16384 + i, 4609, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+                  GL11.glLight(16384 + i, 4610, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
                } else {
-                  GlStateManager.glLight(16384 + ☃, 4609, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
-                  GlStateManager.glLight(16384 + ☃, 4610, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+                  GL11.glLight(16384 + i, 4609, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+                  GL11.glLight(16384 + i, 4610, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
                }
             }
 
@@ -952,15 +1194,15 @@ public void apply() {
             GlStateManager.tryBlendFuncSeparate(
                GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
             );
-            GlStateManager.glBlendEquation(32774);
+            GL14.glBlendEquation(32774);
             GlStateManager.disableFog();
-            GlStateManager.glFogi(2917, 2048);
+            GL11.glFogi(2917, 2048);
             GlStateManager.setFogDensity(1.0F);
             GlStateManager.setFogStart(0.0F);
             GlStateManager.setFogEnd(1.0F);
-            GlStateManager.glFog(2918, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
+            GL11.glFog(2918, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             if (GLContext.getCapabilities().GL_NV_fog_distance) {
-               GlStateManager.glFogi(2917, 34140);
+               GL11.glFogi(2917, 34140);
             }
 
             GlStateManager.doPolygonOffset(0.0F, 0.0F);
@@ -983,41 +1225,41 @@ public void apply() {
             GlStateManager.texGen(GlStateManager.TexGen.Q, 9474, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             GlStateManager.texGen(GlStateManager.TexGen.Q, 9217, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             GlStateManager.setActiveTexture(0);
-            GlStateManager.glTexParameteri(3553, 10240, 9729);
-            GlStateManager.glTexParameteri(3553, 10241, 9986);
-            GlStateManager.glTexParameteri(3553, 10242, 10497);
-            GlStateManager.glTexParameteri(3553, 10243, 10497);
-            GlStateManager.glTexParameteri(3553, 33085, 1000);
-            GlStateManager.glTexParameteri(3553, 33083, 1000);
-            GlStateManager.glTexParameteri(3553, 33082, -1000);
-            GlStateManager.glTexParameterf(3553, 34049, 0.0F);
-            GlStateManager.glTexEnvi(8960, 8704, 8448);
-            GlStateManager.glTexEnv(8960, 8705, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
-            GlStateManager.glTexEnvi(8960, 34161, 8448);
-            GlStateManager.glTexEnvi(8960, 34162, 8448);
-            GlStateManager.glTexEnvi(8960, 34176, 5890);
-            GlStateManager.glTexEnvi(8960, 34177, 34168);
-            GlStateManager.glTexEnvi(8960, 34178, 34166);
-            GlStateManager.glTexEnvi(8960, 34184, 5890);
-            GlStateManager.glTexEnvi(8960, 34185, 34168);
-            GlStateManager.glTexEnvi(8960, 34186, 34166);
-            GlStateManager.glTexEnvi(8960, 34192, 768);
-            GlStateManager.glTexEnvi(8960, 34193, 768);
-            GlStateManager.glTexEnvi(8960, 34194, 770);
-            GlStateManager.glTexEnvi(8960, 34200, 770);
-            GlStateManager.glTexEnvi(8960, 34201, 770);
-            GlStateManager.glTexEnvi(8960, 34202, 770);
-            GlStateManager.glTexEnvf(8960, 34163, 1.0F);
-            GlStateManager.glTexEnvf(8960, 3356, 1.0F);
+            GL11.glTexParameteri(3553, 10240, 9729);
+            GL11.glTexParameteri(3553, 10241, 9986);
+            GL11.glTexParameteri(3553, 10242, 10497);
+            GL11.glTexParameteri(3553, 10243, 10497);
+            GL11.glTexParameteri(3553, 33085, 1000);
+            GL11.glTexParameteri(3553, 33083, 1000);
+            GL11.glTexParameteri(3553, 33082, -1000);
+            GL11.glTexParameterf(3553, 34049, 0.0F);
+            GL11.glTexEnvi(8960, 8704, 8448);
+            GL11.glTexEnv(8960, 8705, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
+            GL11.glTexEnvi(8960, 34161, 8448);
+            GL11.glTexEnvi(8960, 34162, 8448);
+            GL11.glTexEnvi(8960, 34176, 5890);
+            GL11.glTexEnvi(8960, 34177, 34168);
+            GL11.glTexEnvi(8960, 34178, 34166);
+            GL11.glTexEnvi(8960, 34184, 5890);
+            GL11.glTexEnvi(8960, 34185, 34168);
+            GL11.glTexEnvi(8960, 34186, 34166);
+            GL11.glTexEnvi(8960, 34192, 768);
+            GL11.glTexEnvi(8960, 34193, 768);
+            GL11.glTexEnvi(8960, 34194, 770);
+            GL11.glTexEnvi(8960, 34200, 770);
+            GL11.glTexEnvi(8960, 34201, 770);
+            GL11.glTexEnvi(8960, 34202, 770);
+            GL11.glTexEnvf(8960, 34163, 1.0F);
+            GL11.glTexEnvf(8960, 3356, 1.0F);
             GlStateManager.disableNormalize();
             GlStateManager.shadeModel(7425);
             GlStateManager.disableRescaleNormal();
             GlStateManager.colorMask(true, true, true, true);
             GlStateManager.clearDepth(1.0);
-            GlStateManager.glLineWidth(1.0F);
-            GlStateManager.glNormal3f(0.0F, 0.0F, 1.0F);
-            GlStateManager.glPolygonMode(1028, 6914);
-            GlStateManager.glPolygonMode(1029, 6914);
+            GL11.glLineWidth(1.0F);
+            GL11.glNormal3f(0.0F, 0.0F, 1.0F);
+            GL11.glPolygonMode(1028, 6914);
+            GL11.glPolygonMode(1029, 6914);
          }
 
          @Override
@@ -1081,8 +1323,8 @@ public static enum SourceFactor {
 
       public final int factor;
 
-      private SourceFactor(int var3) {
-         this.factor = ☃;
+      private SourceFactor(int factorIn) {
+         this.factor = factorIn;
       }
    }
 
@@ -1117,9 +1359,9 @@ static class TexGenCoord {
       public int coord;
       public int param = -1;
 
-      public TexGenCoord(int var1, int var2) {
-         this.coord = ☃;
-         this.textureGen = new GlStateManager.BooleanState(☃);
+      public TexGenCoord(int coordIn, int capabilityIn) {
+         this.coord = coordIn;
+         this.textureGen = new GlStateManager.BooleanState(capabilityIn);
       }
    }
 
diff --git a/patches/net/minecraft/client/renderer/ImageBufferDownload.java b/patches/net/minecraft/client/renderer/ImageBufferDownload.java
index 8a41ac9..b33cfe1 100644
--- a/patches/net/minecraft/client/renderer/ImageBufferDownload.java
+++ b/patches/net/minecraft/client/renderer/ImageBufferDownload.java
@@ -4,6 +4,7 @@
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
 import java.awt.image.DataBufferInt;
+import java.awt.image.ImageObserver;
 import javax.annotation.Nullable;
 
 public class ImageBufferDownload implements IImageBuffer {
@@ -12,72 +13,79 @@ public class ImageBufferDownload implements IImageBuffer {
    private int imageHeight;
 
    @Nullable
-   @Override
-   public BufferedImage parseUserSkin(BufferedImage var1) {
-      if (☃ == null) {
+   public BufferedImage parseUserSkin(BufferedImage image) {
+      if (image == null) {
          return null;
       } else {
          this.imageWidth = 64;
          this.imageHeight = 64;
-         BufferedImage ☃ = new BufferedImage(this.imageWidth, this.imageHeight, 2);
-         Graphics ☃x = ☃.getGraphics();
-         ☃x.drawImage(☃, 0, 0, null);
-         boolean ☃xx = ☃.getHeight() == 32;
-         if (☃xx) {
-            ☃x.setColor(new Color(0, 0, 0, 0));
-            ☃x.fillRect(0, 32, 64, 32);
-            ☃x.drawImage(☃, 24, 48, 20, 52, 4, 16, 8, 20, null);
-            ☃x.drawImage(☃, 28, 48, 24, 52, 8, 16, 12, 20, null);
-            ☃x.drawImage(☃, 20, 52, 16, 64, 8, 20, 12, 32, null);
-            ☃x.drawImage(☃, 24, 52, 20, 64, 4, 20, 8, 32, null);
-            ☃x.drawImage(☃, 28, 52, 24, 64, 0, 20, 4, 32, null);
-            ☃x.drawImage(☃, 32, 52, 28, 64, 12, 20, 16, 32, null);
-            ☃x.drawImage(☃, 40, 48, 36, 52, 44, 16, 48, 20, null);
-            ☃x.drawImage(☃, 44, 48, 40, 52, 48, 16, 52, 20, null);
-            ☃x.drawImage(☃, 36, 52, 32, 64, 48, 20, 52, 32, null);
-            ☃x.drawImage(☃, 40, 52, 36, 64, 44, 20, 48, 32, null);
-            ☃x.drawImage(☃, 44, 52, 40, 64, 40, 20, 44, 32, null);
-            ☃x.drawImage(☃, 48, 52, 44, 64, 52, 20, 56, 32, null);
+         int srcWidth = image.getWidth();
+         int srcHeight = image.getHeight();
+
+         int k;
+         for (k = 1; this.imageWidth < srcWidth || this.imageHeight < srcHeight; k *= 2) {
+            this.imageWidth *= 2;
+            this.imageHeight *= 2;
+         }
+
+         BufferedImage bufferedimage = new BufferedImage(this.imageWidth, this.imageHeight, 2);
+         Graphics graphics = bufferedimage.getGraphics();
+         graphics.drawImage(image, 0, 0, (ImageObserver)null);
+         boolean flag = image.getHeight() == 32 * k;
+         if (flag) {
+            graphics.setColor(new Color(0, 0, 0, 0));
+            graphics.fillRect(0 * k, 32 * k, 64 * k, 32 * k);
+            graphics.drawImage(bufferedimage, 24 * k, 48 * k, 20 * k, 52 * k, 4 * k, 16 * k, 8 * k, 20 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 28 * k, 48 * k, 24 * k, 52 * k, 8 * k, 16 * k, 12 * k, 20 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 20 * k, 52 * k, 16 * k, 64 * k, 8 * k, 20 * k, 12 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 24 * k, 52 * k, 20 * k, 64 * k, 4 * k, 20 * k, 8 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 28 * k, 52 * k, 24 * k, 64 * k, 0 * k, 20 * k, 4 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 32 * k, 52 * k, 28 * k, 64 * k, 12 * k, 20 * k, 16 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 40 * k, 48 * k, 36 * k, 52 * k, 44 * k, 16 * k, 48 * k, 20 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 44 * k, 48 * k, 40 * k, 52 * k, 48 * k, 16 * k, 52 * k, 20 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 36 * k, 52 * k, 32 * k, 64 * k, 48 * k, 20 * k, 52 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 40 * k, 52 * k, 36 * k, 64 * k, 44 * k, 20 * k, 48 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 44 * k, 52 * k, 40 * k, 64 * k, 40 * k, 20 * k, 44 * k, 32 * k, (ImageObserver)null);
+            graphics.drawImage(bufferedimage, 48 * k, 52 * k, 44 * k, 64 * k, 52 * k, 20 * k, 56 * k, 32 * k, (ImageObserver)null);
          }
 
-         ☃x.dispose();
-         this.imageData = ((DataBufferInt)☃.getRaster().getDataBuffer()).getData();
-         this.setAreaOpaque(0, 0, 32, 16);
-         if (☃xx) {
-            this.setAreaTransparent(32, 0, 64, 32);
+         graphics.dispose();
+         this.imageData = ((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
+         this.setAreaOpaque(0 * k, 0 * k, 32 * k, 16 * k);
+         if (flag) {
+            this.setAreaTransparent(32 * k, 0 * k, 64 * k, 32 * k);
          }
 
-         this.setAreaOpaque(0, 16, 64, 32);
-         this.setAreaOpaque(16, 48, 48, 64);
-         return ☃;
+         this.setAreaOpaque(0 * k, 16 * k, 64 * k, 32 * k);
+         this.setAreaOpaque(16 * k, 48 * k, 48 * k, 64 * k);
+         return bufferedimage;
       }
    }
 
-   @Override
    public void skinAvailable() {
    }
 
-   private void setAreaTransparent(int var1, int var2, int var3, int var4) {
-      for (int ☃ = ☃; ☃ < ☃; ☃++) {
-         for (int ☃x = ☃; ☃x < ☃; ☃x++) {
-            int ☃xx = this.imageData[☃ + ☃x * this.imageWidth];
-            if ((☃xx >> 24 & 0xFF) < 128) {
+   private void setAreaTransparent(int x, int y, int width, int height) {
+      for (int i = x; i < width; i++) {
+         for (int j = y; j < height; j++) {
+            int k = this.imageData[i + j * this.imageWidth];
+            if ((k >> 24 & 0xFF) < 128) {
                return;
             }
          }
       }
 
-      for (int ☃ = ☃; ☃ < ☃; ☃++) {
-         for (int ☃xx = ☃; ☃xx < ☃; ☃xx++) {
-            this.imageData[☃ + ☃xx * this.imageWidth] = this.imageData[☃ + ☃xx * this.imageWidth] & 16777215;
+      for (int l = x; l < width; l++) {
+         for (int i1 = y; i1 < height; i1++) {
+            this.imageData[l + i1 * this.imageWidth] = this.imageData[l + i1 * this.imageWidth] & 16777215;
          }
       }
    }
 
-   private void setAreaOpaque(int var1, int var2, int var3, int var4) {
-      for (int ☃ = ☃; ☃ < ☃; ☃++) {
-         for (int ☃x = ☃; ☃x < ☃; ☃x++) {
-            this.imageData[☃ + ☃x * this.imageWidth] = this.imageData[☃ + ☃x * this.imageWidth] | 0xFF000000;
+   private void setAreaOpaque(int x, int y, int width, int height) {
+      for (int i = x; i < width; i++) {
+         for (int j = y; j < height; j++) {
+            this.imageData[i + j * this.imageWidth] = this.imageData[i + j * this.imageWidth] | 0xFF000000;
          }
       }
    }
diff --git a/patches/net/minecraft/client/renderer/ItemRenderer.java b/patches/net/minecraft/client/renderer/ItemRenderer.java
index 016e773..dad4833 100644
--- a/patches/net/minecraft/client/renderer/ItemRenderer.java
+++ b/patches/net/minecraft/client/renderer/ItemRenderer.java
@@ -8,7 +8,7 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.entity.EntityPlayerSP;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.entity.Render;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.entity.RenderPlayer;
@@ -19,6 +19,8 @@
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Items;
 import net.minecraft.item.Item;
+import net.minecraft.item.ItemBow;
+import net.minecraft.item.ItemMap;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumBlockRenderType;
@@ -28,6 +30,10 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.storage.MapData;
+import net.optifine.DynamicLights;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
 
 public class ItemRenderer {
    private static final ResourceLocation RES_MAP_BACKGROUND = new ResourceLocation("textures/map/map_background.png");
@@ -42,28 +48,28 @@ public class ItemRenderer {
    private final RenderManager renderManager;
    private final RenderItem itemRenderer;
 
-   public ItemRenderer(Minecraft var1) {
-      this.mc = ☃;
-      this.renderManager = ☃.getRenderManager();
-      this.itemRenderer = ☃.getRenderItem();
+   public ItemRenderer(Minecraft mcIn) {
+      this.mc = mcIn;
+      this.renderManager = mcIn.getRenderManager();
+      this.itemRenderer = mcIn.getRenderItem();
    }
 
-   public void renderItem(EntityLivingBase var1, ItemStack var2, ItemCameraTransforms.TransformType var3) {
-      this.renderItemSide(☃, ☃, ☃, false);
+   public void renderItem(EntityLivingBase entityIn, ItemStack heldStack, TransformType transform) {
+      this.renderItemSide(entityIn, heldStack, transform, false);
    }
 
-   public void renderItemSide(EntityLivingBase var1, ItemStack var2, ItemCameraTransforms.TransformType var3, boolean var4) {
-      if (!☃.isEmpty()) {
-         Item ☃ = ☃.getItem();
-         Block ☃x = Block.getBlockFromItem(☃);
+   public void renderItemSide(EntityLivingBase entitylivingbaseIn, ItemStack heldStack, TransformType transform, boolean leftHanded) {
+      if (!heldStack.isEmpty()) {
+         Item item = heldStack.getItem();
+         Block block = Block.getBlockFromItem(item);
          GlStateManager.pushMatrix();
-         boolean ☃xx = this.itemRenderer.shouldRenderItemIn3D(☃) && ☃x.getRenderLayer() == BlockRenderLayer.TRANSLUCENT;
-         if (☃xx) {
+         boolean flag = this.itemRenderer.shouldRenderItemIn3D(heldStack) && block.getRenderLayer() == BlockRenderLayer.TRANSLUCENT;
+         if (flag && (!Config.isShaders() || !Shaders.renderItemKeepDepthMask)) {
             GlStateManager.depthMask(false);
          }
 
-         this.itemRenderer.renderItem(☃, ☃, ☃, ☃);
-         if (☃xx) {
+         this.itemRenderer.renderItem(heldStack, entitylivingbaseIn, transform, leftHanded);
+         if (flag) {
             GlStateManager.depthMask(true);
          }
 
@@ -71,34 +77,42 @@ public void renderItemSide(EntityLivingBase var1, ItemStack var2, ItemCameraTran
       }
    }
 
-   private void rotateArroundXAndY(float var1, float var2) {
+   private void rotateArroundXAndY(float angle, float angleY) {
       GlStateManager.pushMatrix();
-      GlStateManager.rotate(☃, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃, 0.0F, 1.0F, 0.0F);
+      GlStateManager.rotate(angle, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate(angleY, 0.0F, 1.0F, 0.0F);
       RenderHelper.enableStandardItemLighting();
       GlStateManager.popMatrix();
    }
 
    private void setLightmap() {
-      AbstractClientPlayer ☃ = this.mc.player;
-      int ☃x = this.mc.world.getCombinedLight(new BlockPos(☃.posX, ☃.posY + ☃.getEyeHeight(), ☃.posZ), 0);
-      float ☃xx = ☃x & 65535;
-      float ☃xxx = ☃x >> 16;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃xx, ☃xxx);
+      AbstractClientPlayer abstractclientplayer = this.mc.player;
+      int i = this.mc
+         .world
+         .getCombinedLight(
+            new BlockPos(abstractclientplayer.posX, abstractclientplayer.posY + abstractclientplayer.getEyeHeight(), abstractclientplayer.posZ), 0
+         );
+      if (Config.isDynamicLights()) {
+         i = DynamicLights.getCombinedLight(this.mc.getRenderViewEntity(), i);
+      }
+
+      float f = i & 65535;
+      float f1 = i >> 16;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, f, f1);
    }
 
-   private void rotateArm(float var1) {
-      EntityPlayerSP ☃ = this.mc.player;
-      float ☃x = ☃.prevRenderArmPitch + (☃.renderArmPitch - ☃.prevRenderArmPitch) * ☃;
-      float ☃xx = ☃.prevRenderArmYaw + (☃.renderArmYaw - ☃.prevRenderArmYaw) * ☃;
-      GlStateManager.rotate((☃.rotationPitch - ☃x) * 0.1F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate((☃.rotationYaw - ☃xx) * 0.1F, 0.0F, 1.0F, 0.0F);
+   private void rotateArm(float p_187458_1_) {
+      EntityPlayerSP entityplayersp = this.mc.player;
+      float f = entityplayersp.prevRenderArmPitch + (entityplayersp.renderArmPitch - entityplayersp.prevRenderArmPitch) * p_187458_1_;
+      float f1 = entityplayersp.prevRenderArmYaw + (entityplayersp.renderArmYaw - entityplayersp.prevRenderArmYaw) * p_187458_1_;
+      GlStateManager.rotate((entityplayersp.rotationPitch - f) * 0.1F, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate((entityplayersp.rotationYaw - f1) * 0.1F, 0.0F, 1.0F, 0.0F);
    }
 
-   private float getMapAngleFromPitch(float var1) {
-      float ☃ = 1.0F - ☃ / 45.0F + 0.1F;
-      ☃ = MathHelper.clamp(☃, 0.0F, 1.0F);
-      return -MathHelper.cos(☃ * (float) Math.PI) * 0.5F + 0.5F;
+   private float getMapAngleFromPitch(float pitch) {
+      float f = 1.0F - pitch / 45.0F + 0.1F;
+      f = MathHelper.clamp(f, 0.0F, 1.0F);
+      return -MathHelper.cos(f * (float) Math.PI) * 0.5F + 0.5F;
    }
 
    private void renderArms() {
@@ -113,287 +127,307 @@ private void renderArms() {
       }
    }
 
-   private void renderArm(EnumHandSide var1) {
+   private void renderArm(EnumHandSide p_187455_1_) {
       this.mc.getTextureManager().bindTexture(this.mc.player.getLocationSkin());
-      Render<AbstractClientPlayer> ☃ = this.renderManager.getEntityRenderObject(this.mc.player);
-      RenderPlayer ☃x = (RenderPlayer)☃;
+      Render<AbstractClientPlayer> render = this.renderManager.getEntityRenderObject(this.mc.player);
+      RenderPlayer renderplayer = (RenderPlayer)render;
       GlStateManager.pushMatrix();
-      float ☃xx = ☃ == EnumHandSide.RIGHT ? 1.0F : -1.0F;
+      float f = p_187455_1_ == EnumHandSide.RIGHT ? 1.0F : -1.0F;
       GlStateManager.rotate(92.0F, 0.0F, 1.0F, 0.0F);
       GlStateManager.rotate(45.0F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃xx * -41.0F, 0.0F, 0.0F, 1.0F);
-      GlStateManager.translate(☃xx * 0.3F, -1.1F, 0.45F);
-      if (☃ == EnumHandSide.RIGHT) {
-         ☃x.renderRightArm(this.mc.player);
+      GlStateManager.rotate(f * -41.0F, 0.0F, 0.0F, 1.0F);
+      GlStateManager.translate(f * 0.3F, -1.1F, 0.45F);
+      if (p_187455_1_ == EnumHandSide.RIGHT) {
+         renderplayer.renderRightArm(this.mc.player);
       } else {
-         ☃x.renderLeftArm(this.mc.player);
+         renderplayer.renderLeftArm(this.mc.player);
       }
 
       GlStateManager.popMatrix();
    }
 
-   private void renderMapFirstPersonSide(float var1, EnumHandSide var2, float var3, ItemStack var4) {
-      float ☃ = ☃ == EnumHandSide.RIGHT ? 1.0F : -1.0F;
-      GlStateManager.translate(☃ * 0.125F, -0.125F, 0.0F);
+   private void renderMapFirstPersonSide(float p_187465_1_, EnumHandSide p_187465_2_, float p_187465_3_, ItemStack p_187465_4_) {
+      float f = p_187465_2_ == EnumHandSide.RIGHT ? 1.0F : -1.0F;
+      GlStateManager.translate(f * 0.125F, -0.125F, 0.0F);
       if (!this.mc.player.isInvisible()) {
          GlStateManager.pushMatrix();
-         GlStateManager.rotate(☃ * 10.0F, 0.0F, 0.0F, 1.0F);
-         this.renderArmFirstPerson(☃, ☃, ☃);
+         GlStateManager.rotate(f * 10.0F, 0.0F, 0.0F, 1.0F);
+         this.renderArmFirstPerson(p_187465_1_, p_187465_3_, p_187465_2_);
          GlStateManager.popMatrix();
       }
 
       GlStateManager.pushMatrix();
-      GlStateManager.translate(☃ * 0.51F, -0.08F + ☃ * -1.2F, -0.75F);
-      float ☃x = MathHelper.sqrt(☃);
-      float ☃xx = MathHelper.sin(☃x * (float) Math.PI);
-      float ☃xxx = -0.5F * ☃xx;
-      float ☃xxxx = 0.4F * MathHelper.sin(☃x * (float) (Math.PI * 2));
-      float ☃xxxxx = -0.3F * MathHelper.sin(☃ * (float) Math.PI);
-      GlStateManager.translate(☃ * ☃xxx, ☃xxxx - 0.3F * ☃xx, ☃xxxxx);
-      GlStateManager.rotate(☃xx * -45.0F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃ * ☃xx * -30.0F, 0.0F, 1.0F, 0.0F);
-      this.renderMapFirstPerson(☃);
+      GlStateManager.translate(f * 0.51F, -0.08F + p_187465_1_ * -1.2F, -0.75F);
+      float f1 = MathHelper.sqrt(p_187465_3_);
+      float f2 = MathHelper.sin(f1 * (float) Math.PI);
+      float f3 = -0.5F * f2;
+      float f4 = 0.4F * MathHelper.sin(f1 * (float) (Math.PI * 2));
+      float f5 = -0.3F * MathHelper.sin(p_187465_3_ * (float) Math.PI);
+      GlStateManager.translate(f * f3, f4 - 0.3F * f2, f5);
+      GlStateManager.rotate(f2 * -45.0F, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate(f * f2 * -30.0F, 0.0F, 1.0F, 0.0F);
+      this.renderMapFirstPerson(p_187465_4_);
       GlStateManager.popMatrix();
    }
 
-   private void renderMapFirstPerson(float var1, float var2, float var3) {
-      float ☃ = MathHelper.sqrt(☃);
-      float ☃x = -0.2F * MathHelper.sin(☃ * (float) Math.PI);
-      float ☃xx = -0.4F * MathHelper.sin(☃ * (float) Math.PI);
-      GlStateManager.translate(0.0F, -☃x / 2.0F, ☃xx);
-      float ☃xxx = this.getMapAngleFromPitch(☃);
-      GlStateManager.translate(0.0F, 0.04F + ☃ * -1.2F + ☃xxx * -0.5F, -0.72F);
-      GlStateManager.rotate(☃xxx * -85.0F, 1.0F, 0.0F, 0.0F);
+   private void renderMapFirstPerson(float p_187463_1_, float p_187463_2_, float p_187463_3_) {
+      float f = MathHelper.sqrt(p_187463_3_);
+      float f1 = -0.2F * MathHelper.sin(p_187463_3_ * (float) Math.PI);
+      float f2 = -0.4F * MathHelper.sin(f * (float) Math.PI);
+      GlStateManager.translate(0.0F, -f1 / 2.0F, f2);
+      float f3 = this.getMapAngleFromPitch(p_187463_1_);
+      GlStateManager.translate(0.0F, 0.04F + p_187463_2_ * -1.2F + f3 * -0.5F, -0.72F);
+      GlStateManager.rotate(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
       this.renderArms();
-      float ☃xxxx = MathHelper.sin(☃ * (float) Math.PI);
-      GlStateManager.rotate(☃xxxx * 20.0F, 1.0F, 0.0F, 0.0F);
+      float f4 = MathHelper.sin(f * (float) Math.PI);
+      GlStateManager.rotate(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
       GlStateManager.scale(2.0F, 2.0F, 2.0F);
       this.renderMapFirstPerson(this.itemStackMainHand);
    }
 
-   private void renderMapFirstPerson(ItemStack var1) {
+   private void renderMapFirstPerson(ItemStack stack) {
       GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
       GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
       GlStateManager.scale(0.38F, 0.38F, 0.38F);
       GlStateManager.disableLighting();
       this.mc.getTextureManager().bindTexture(RES_MAP_BACKGROUND);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       GlStateManager.translate(-0.5F, -0.5F, 0.0F);
       GlStateManager.scale(0.0078125F, 0.0078125F, 0.0078125F);
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃x.pos(-7.0, 135.0, 0.0).tex(0.0, 1.0).endVertex();
-      ☃x.pos(135.0, 135.0, 0.0).tex(1.0, 1.0).endVertex();
-      ☃x.pos(135.0, -7.0, 0.0).tex(1.0, 0.0).endVertex();
-      ☃x.pos(-7.0, -7.0, 0.0).tex(0.0, 0.0).endVertex();
-      ☃.draw();
-      MapData ☃xx = Items.FILLED_MAP.getMapData(☃, this.mc.world);
-      if (☃xx != null) {
-         this.mc.entityRenderer.getMapItemRenderer().renderMap(☃xx, false);
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+      bufferbuilder.pos(-7.0, 135.0, 0.0).tex(0.0, 1.0).endVertex();
+      bufferbuilder.pos(135.0, 135.0, 0.0).tex(1.0, 1.0).endVertex();
+      bufferbuilder.pos(135.0, -7.0, 0.0).tex(1.0, 0.0).endVertex();
+      bufferbuilder.pos(-7.0, -7.0, 0.0).tex(0.0, 0.0).endVertex();
+      tessellator.draw();
+      MapData mapdata = ReflectorForge.getMapData(Items.FILLED_MAP, stack, this.mc.world);
+      if (mapdata != null) {
+         this.mc.entityRenderer.getMapItemRenderer().renderMap(mapdata, false);
       }
 
       GlStateManager.enableLighting();
    }
 
-   private void renderArmFirstPerson(float var1, float var2, EnumHandSide var3) {
-      boolean ☃ = ☃ != EnumHandSide.LEFT;
-      float ☃x = ☃ ? 1.0F : -1.0F;
-      float ☃xx = MathHelper.sqrt(☃);
-      float ☃xxx = -0.3F * MathHelper.sin(☃xx * (float) Math.PI);
-      float ☃xxxx = 0.4F * MathHelper.sin(☃xx * (float) (Math.PI * 2));
-      float ☃xxxxx = -0.4F * MathHelper.sin(☃ * (float) Math.PI);
-      GlStateManager.translate(☃x * (☃xxx + 0.64000005F), ☃xxxx + -0.6F + ☃ * -0.6F, ☃xxxxx + -0.71999997F);
-      GlStateManager.rotate(☃x * 45.0F, 0.0F, 1.0F, 0.0F);
-      float ☃xxxxxx = MathHelper.sin(☃ * ☃ * (float) Math.PI);
-      float ☃xxxxxxx = MathHelper.sin(☃xx * (float) Math.PI);
-      GlStateManager.rotate(☃x * ☃xxxxxxx * 70.0F, 0.0F, 1.0F, 0.0F);
-      GlStateManager.rotate(☃x * ☃xxxxxx * -20.0F, 0.0F, 0.0F, 1.0F);
-      AbstractClientPlayer ☃xxxxxxxx = this.mc.player;
-      this.mc.getTextureManager().bindTexture(☃xxxxxxxx.getLocationSkin());
-      GlStateManager.translate(☃x * -1.0F, 3.6F, 3.5F);
-      GlStateManager.rotate(☃x * 120.0F, 0.0F, 0.0F, 1.0F);
+   private void renderArmFirstPerson(float p_187456_1_, float p_187456_2_, EnumHandSide p_187456_3_) {
+      boolean flag = p_187456_3_ != EnumHandSide.LEFT;
+      float f = flag ? 1.0F : -1.0F;
+      float f1 = MathHelper.sqrt(p_187456_2_);
+      float f2 = -0.3F * MathHelper.sin(f1 * (float) Math.PI);
+      float f3 = 0.4F * MathHelper.sin(f1 * (float) (Math.PI * 2));
+      float f4 = -0.4F * MathHelper.sin(p_187456_2_ * (float) Math.PI);
+      GlStateManager.translate(f * (f2 + 0.64000005F), f3 + -0.6F + p_187456_1_ * -0.6F, f4 + -0.71999997F);
+      GlStateManager.rotate(f * 45.0F, 0.0F, 1.0F, 0.0F);
+      float f5 = MathHelper.sin(p_187456_2_ * p_187456_2_ * (float) Math.PI);
+      float f6 = MathHelper.sin(f1 * (float) Math.PI);
+      GlStateManager.rotate(f * f6 * 70.0F, 0.0F, 1.0F, 0.0F);
+      GlStateManager.rotate(f * f5 * -20.0F, 0.0F, 0.0F, 1.0F);
+      AbstractClientPlayer abstractclientplayer = this.mc.player;
+      this.mc.getTextureManager().bindTexture(abstractclientplayer.getLocationSkin());
+      GlStateManager.translate(f * -1.0F, 3.6F, 3.5F);
+      GlStateManager.rotate(f * 120.0F, 0.0F, 0.0F, 1.0F);
       GlStateManager.rotate(200.0F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃x * -135.0F, 0.0F, 1.0F, 0.0F);
-      GlStateManager.translate(☃x * 5.6F, 0.0F, 0.0F);
-      RenderPlayer ☃xxxxxxxxx = (RenderPlayer)this.renderManager.<AbstractClientPlayer>getEntityRenderObject(☃xxxxxxxx);
+      GlStateManager.rotate(f * -135.0F, 0.0F, 1.0F, 0.0F);
+      GlStateManager.translate(f * 5.6F, 0.0F, 0.0F);
+      RenderPlayer renderplayer = (RenderPlayer)this.renderManager.getEntityRenderObject(abstractclientplayer);
       GlStateManager.disableCull();
-      if (☃) {
-         ☃xxxxxxxxx.renderRightArm(☃xxxxxxxx);
+      if (flag) {
+         renderplayer.renderRightArm(abstractclientplayer);
       } else {
-         ☃xxxxxxxxx.renderLeftArm(☃xxxxxxxx);
+         renderplayer.renderLeftArm(abstractclientplayer);
       }
 
       GlStateManager.enableCull();
    }
 
-   private void transformEatFirstPerson(float var1, EnumHandSide var2, ItemStack var3) {
-      float ☃ = this.mc.player.getItemInUseCount() - ☃ + 1.0F;
-      float ☃x = ☃ / ☃.getMaxItemUseDuration();
-      if (☃x < 0.8F) {
-         float ☃xx = MathHelper.abs(MathHelper.cos(☃ / 4.0F * (float) Math.PI) * 0.1F);
-         GlStateManager.translate(0.0F, ☃xx, 0.0F);
+   private void transformEatFirstPerson(float p_187454_1_, EnumHandSide p_187454_2_, ItemStack p_187454_3_) {
+      float f = this.mc.player.getItemInUseCount() - p_187454_1_ + 1.0F;
+      float f1 = f / p_187454_3_.getMaxItemUseDuration();
+      if (f1 < 0.8F) {
+         float f2 = MathHelper.abs(MathHelper.cos(f / 4.0F * (float) Math.PI) * 0.1F);
+         GlStateManager.translate(0.0F, f2, 0.0F);
       }
 
-      float ☃xx = 1.0F - (float)Math.pow(☃x, 27.0);
-      int ☃xxx = ☃ == EnumHandSide.RIGHT ? 1 : -1;
-      GlStateManager.translate(☃xx * 0.6F * ☃xxx, ☃xx * -0.5F, ☃xx * 0.0F);
-      GlStateManager.rotate(☃xxx * ☃xx * 90.0F, 0.0F, 1.0F, 0.0F);
-      GlStateManager.rotate(☃xx * 10.0F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃xxx * ☃xx * 30.0F, 0.0F, 0.0F, 1.0F);
+      float f3 = 1.0F - (float)Math.pow(f1, 27.0);
+      int i = p_187454_2_ == EnumHandSide.RIGHT ? 1 : -1;
+      GlStateManager.translate(f3 * 0.6F * i, f3 * -0.5F, f3 * 0.0F);
+      GlStateManager.rotate(i * f3 * 90.0F, 0.0F, 1.0F, 0.0F);
+      GlStateManager.rotate(f3 * 10.0F, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate(i * f3 * 30.0F, 0.0F, 0.0F, 1.0F);
    }
 
-   private void transformFirstPerson(EnumHandSide var1, float var2) {
-      int ☃ = ☃ == EnumHandSide.RIGHT ? 1 : -1;
-      float ☃x = MathHelper.sin(☃ * ☃ * (float) Math.PI);
-      GlStateManager.rotate(☃ * (45.0F + ☃x * -20.0F), 0.0F, 1.0F, 0.0F);
-      float ☃xx = MathHelper.sin(MathHelper.sqrt(☃) * (float) Math.PI);
-      GlStateManager.rotate(☃ * ☃xx * -20.0F, 0.0F, 0.0F, 1.0F);
-      GlStateManager.rotate(☃xx * -80.0F, 1.0F, 0.0F, 0.0F);
-      GlStateManager.rotate(☃ * -45.0F, 0.0F, 1.0F, 0.0F);
+   private void transformFirstPerson(EnumHandSide p_187453_1_, float p_187453_2_) {
+      int i = p_187453_1_ == EnumHandSide.RIGHT ? 1 : -1;
+      float f = MathHelper.sin(p_187453_2_ * p_187453_2_ * (float) Math.PI);
+      GlStateManager.rotate(i * (45.0F + f * -20.0F), 0.0F, 1.0F, 0.0F);
+      float f1 = MathHelper.sin(MathHelper.sqrt(p_187453_2_) * (float) Math.PI);
+      GlStateManager.rotate(i * f1 * -20.0F, 0.0F, 0.0F, 1.0F);
+      GlStateManager.rotate(f1 * -80.0F, 1.0F, 0.0F, 0.0F);
+      GlStateManager.rotate(i * -45.0F, 0.0F, 1.0F, 0.0F);
    }
 
-   private void transformSideFirstPerson(EnumHandSide var1, float var2) {
-      int ☃ = ☃ == EnumHandSide.RIGHT ? 1 : -1;
-      GlStateManager.translate(☃ * 0.56F, -0.52F + ☃ * -0.6F, -0.72F);
+   private void transformSideFirstPerson(EnumHandSide p_187459_1_, float p_187459_2_) {
+      int i = p_187459_1_ == EnumHandSide.RIGHT ? 1 : -1;
+      GlStateManager.translate(i * 0.56F, -0.52F + p_187459_2_ * -0.6F, -0.72F);
    }
 
-   public void renderItemInFirstPerson(float var1) {
-      AbstractClientPlayer ☃ = this.mc.player;
-      float ☃x = ☃.getSwingProgress(☃);
-      EnumHand ☃xx = (EnumHand)MoreObjects.firstNonNull(☃.swingingHand, EnumHand.MAIN_HAND);
-      float ☃xxx = ☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃;
-      float ☃xxxx = ☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃;
-      boolean ☃xxxxx = true;
-      boolean ☃xxxxxx = true;
-      if (☃.isHandActive()) {
-         ItemStack ☃xxxxxxx = ☃.getActiveItemStack();
-         if (☃xxxxxxx.getItem() == Items.BOW) {
-            EnumHand ☃xxxxxxxx = ☃.getActiveHand();
-            ☃xxxxx = ☃xxxxxxxx == EnumHand.MAIN_HAND;
-            ☃xxxxxx = !☃xxxxx;
+   public void renderItemInFirstPerson(float partialTicks) {
+      AbstractClientPlayer abstractclientplayer = this.mc.player;
+      float f = abstractclientplayer.getSwingProgress(partialTicks);
+      EnumHand enumhand = (EnumHand)MoreObjects.firstNonNull(abstractclientplayer.swingingHand, EnumHand.MAIN_HAND);
+      float f1 = abstractclientplayer.prevRotationPitch + (abstractclientplayer.rotationPitch - abstractclientplayer.prevRotationPitch) * partialTicks;
+      float f2 = abstractclientplayer.prevRotationYaw + (abstractclientplayer.rotationYaw - abstractclientplayer.prevRotationYaw) * partialTicks;
+      boolean flag = true;
+      boolean flag1 = true;
+      if (abstractclientplayer.isHandActive()) {
+         ItemStack itemstack = abstractclientplayer.getActiveItemStack();
+         if (itemstack.getItem() instanceof ItemBow) {
+            EnumHand enumhand1 = abstractclientplayer.getActiveHand();
+            flag = enumhand1 == EnumHand.MAIN_HAND;
+            flag1 = !flag;
          }
       }
 
-      this.rotateArroundXAndY(☃xxx, ☃xxxx);
+      this.rotateArroundXAndY(f1, f2);
       this.setLightmap();
-      this.rotateArm(☃);
+      this.rotateArm(partialTicks);
       GlStateManager.enableRescaleNormal();
-      if (☃xxxxx) {
-         float ☃xxxxxxx = ☃xx == EnumHand.MAIN_HAND ? ☃x : 0.0F;
-         float ☃xxxxxxxx = 1.0F - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * ☃);
-         this.renderItemInFirstPerson(☃, ☃, ☃xxx, EnumHand.MAIN_HAND, ☃xxxxxxx, this.itemStackMainHand, ☃xxxxxxxx);
+      if (flag) {
+         float f3 = enumhand == EnumHand.MAIN_HAND ? f : 0.0F;
+         float f5 = 1.0F - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
+         if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists()
+            || !Reflector.callBoolean(
+               Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[]{EnumHand.MAIN_HAND, partialTicks, f1, f3, f5, this.itemStackMainHand}
+            )) {
+            this.renderItemInFirstPerson(abstractclientplayer, partialTicks, f1, EnumHand.MAIN_HAND, f3, this.itemStackMainHand, f5);
+         }
       }
 
-      if (☃xxxxxx) {
-         float ☃xxxxxxx = ☃xx == EnumHand.OFF_HAND ? ☃x : 0.0F;
-         float ☃xxxxxxxx = 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * ☃);
-         this.renderItemInFirstPerson(☃, ☃, ☃xxx, EnumHand.OFF_HAND, ☃xxxxxxx, this.itemStackOffHand, ☃xxxxxxxx);
+      if (flag1) {
+         float f4 = enumhand == EnumHand.OFF_HAND ? f : 0.0F;
+         float f6 = 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
+         if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists()
+            || !Reflector.callBoolean(
+               Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[]{EnumHand.OFF_HAND, partialTicks, f1, f4, f6, this.itemStackOffHand}
+            )) {
+            this.renderItemInFirstPerson(abstractclientplayer, partialTicks, f1, EnumHand.OFF_HAND, f4, this.itemStackOffHand, f6);
+         }
       }
 
       GlStateManager.disableRescaleNormal();
       RenderHelper.disableStandardItemLighting();
    }
 
-   public void renderItemInFirstPerson(AbstractClientPlayer var1, float var2, float var3, EnumHand var4, float var5, ItemStack var6, float var7) {
-      boolean ☃ = ☃ == EnumHand.MAIN_HAND;
-      EnumHandSide ☃x = ☃ ? ☃.getPrimaryHand() : ☃.getPrimaryHand().opposite();
-      GlStateManager.pushMatrix();
-      if (☃.isEmpty()) {
-         if (☃ && !☃.isInvisible()) {
-            this.renderArmFirstPerson(☃, ☃, ☃x);
-         }
-      } else if (☃.getItem() == Items.FILLED_MAP) {
-         if (☃ && this.itemStackOffHand.isEmpty()) {
-            this.renderMapFirstPerson(☃, ☃, ☃);
-         } else {
-            this.renderMapFirstPersonSide(☃, ☃x, ☃, ☃);
-         }
-      } else {
-         boolean ☃xx = ☃x == EnumHandSide.RIGHT;
-         if (☃.isHandActive() && ☃.getItemInUseCount() > 0 && ☃.getActiveHand() == ☃) {
-            int ☃xxx = ☃xx ? 1 : -1;
-            switch (☃.getItemUseAction()) {
-               case NONE:
-                  this.transformSideFirstPerson(☃x, ☃);
-                  break;
-               case EAT:
-               case DRINK:
-                  this.transformEatFirstPerson(☃, ☃x, ☃);
-                  this.transformSideFirstPerson(☃x, ☃);
-                  break;
-               case BLOCK:
-                  this.transformSideFirstPerson(☃x, ☃);
-                  break;
-               case BOW:
-                  this.transformSideFirstPerson(☃x, ☃);
-                  GlStateManager.translate(☃xxx * -0.2785682F, 0.18344387F, 0.15731531F);
-                  GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
-                  GlStateManager.rotate(☃xxx * 35.3F, 0.0F, 1.0F, 0.0F);
-                  GlStateManager.rotate(☃xxx * -9.785F, 0.0F, 0.0F, 1.0F);
-                  float ☃xxxx = ☃.getMaxItemUseDuration() - (this.mc.player.getItemInUseCount() - ☃ + 1.0F);
-                  float ☃xxxxx = ☃xxxx / 20.0F;
-                  ☃xxxxx = (☃xxxxx * ☃xxxxx + ☃xxxxx * 2.0F) / 3.0F;
-                  if (☃xxxxx > 1.0F) {
-                     ☃xxxxx = 1.0F;
-                  }
-
-                  if (☃xxxxx > 0.1F) {
-                     float ☃xxxxxx = MathHelper.sin((☃xxxx - 0.1F) * 1.3F);
-                     float ☃xxxxxxx = ☃xxxxx - 0.1F;
-                     float ☃xxxxxxxx = ☃xxxxxx * ☃xxxxxxx;
-                     GlStateManager.translate(☃xxxxxxxx * 0.0F, ☃xxxxxxxx * 0.004F, ☃xxxxxxxx * 0.0F);
-                  }
-
-                  GlStateManager.translate(☃xxxxx * 0.0F, ☃xxxxx * 0.0F, ☃xxxxx * 0.04F);
-                  GlStateManager.scale(1.0F, 1.0F, 1.0F + ☃xxxxx * 0.2F);
-                  GlStateManager.rotate(☃xxx * 45.0F, 0.0F, -1.0F, 0.0F);
+   public void renderItemInFirstPerson(
+      AbstractClientPlayer p_187457_1_, float p_187457_2_, float p_187457_3_, EnumHand p_187457_4_, float p_187457_5_, ItemStack p_187457_6_, float p_187457_7_
+   ) {
+      if (!Config.isShaders() || !Shaders.isSkipRenderHand(p_187457_4_)) {
+         boolean flag = p_187457_4_ == EnumHand.MAIN_HAND;
+         EnumHandSide enumhandside = flag ? p_187457_1_.getPrimaryHand() : p_187457_1_.getPrimaryHand().opposite();
+         GlStateManager.pushMatrix();
+         if (p_187457_6_.isEmpty()) {
+            if (flag && !p_187457_1_.isInvisible()) {
+               this.renderArmFirstPerson(p_187457_7_, p_187457_5_, enumhandside);
+            }
+         } else if (p_187457_6_.getItem() instanceof ItemMap) {
+            if (flag && this.itemStackOffHand.isEmpty()) {
+               this.renderMapFirstPerson(p_187457_3_, p_187457_7_, p_187457_5_);
+            } else {
+               this.renderMapFirstPersonSide(p_187457_7_, enumhandside, p_187457_5_, p_187457_6_);
             }
          } else {
-            float ☃xxx = -0.4F * MathHelper.sin(MathHelper.sqrt(☃) * (float) Math.PI);
-            float ☃xxxxxx = 0.2F * MathHelper.sin(MathHelper.sqrt(☃) * (float) (Math.PI * 2));
-            float ☃xxxxxxx = -0.2F * MathHelper.sin(☃ * (float) Math.PI);
-            int ☃xxxxxxxx = ☃xx ? 1 : -1;
-            GlStateManager.translate(☃xxxxxxxx * ☃xxx, ☃xxxxxx, ☃xxxxxxx);
-            this.transformSideFirstPerson(☃x, ☃);
-            this.transformFirstPerson(☃x, ☃);
+            boolean flag1 = enumhandside == EnumHandSide.RIGHT;
+            if (p_187457_1_.isHandActive() && p_187457_1_.getItemInUseCount() > 0 && p_187457_1_.getActiveHand() == p_187457_4_) {
+               int j = flag1 ? 1 : -1;
+               switch (p_187457_6_.getItemUseAction()) {
+                  case NONE:
+                     this.transformSideFirstPerson(enumhandside, p_187457_7_);
+                     break;
+                  case EAT:
+                  case DRINK:
+                     this.transformEatFirstPerson(p_187457_2_, enumhandside, p_187457_6_);
+                     this.transformSideFirstPerson(enumhandside, p_187457_7_);
+                     break;
+                  case BLOCK:
+                     this.transformSideFirstPerson(enumhandside, p_187457_7_);
+                     break;
+                  case BOW:
+                     this.transformSideFirstPerson(enumhandside, p_187457_7_);
+                     GlStateManager.translate(j * -0.2785682F, 0.18344387F, 0.15731531F);
+                     GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
+                     GlStateManager.rotate(j * 35.3F, 0.0F, 1.0F, 0.0F);
+                     GlStateManager.rotate(j * -9.785F, 0.0F, 0.0F, 1.0F);
+                     float f5 = p_187457_6_.getMaxItemUseDuration() - (this.mc.player.getItemInUseCount() - p_187457_2_ + 1.0F);
+                     float f6 = f5 / 20.0F;
+                     f6 = (f6 * f6 + f6 * 2.0F) / 3.0F;
+                     if (f6 > 1.0F) {
+                        f6 = 1.0F;
+                     }
+
+                     if (f6 > 0.1F) {
+                        float f7 = MathHelper.sin((f5 - 0.1F) * 1.3F);
+                        float f3 = f6 - 0.1F;
+                        float f4 = f7 * f3;
+                        GlStateManager.translate(f4 * 0.0F, f4 * 0.004F, f4 * 0.0F);
+                     }
+
+                     GlStateManager.translate(f6 * 0.0F, f6 * 0.0F, f6 * 0.04F);
+                     GlStateManager.scale(1.0F, 1.0F, 1.0F + f6 * 0.2F);
+                     GlStateManager.rotate(j * 45.0F, 0.0F, -1.0F, 0.0F);
+               }
+            } else {
+               float f = -0.4F * MathHelper.sin(MathHelper.sqrt(p_187457_5_) * (float) Math.PI);
+               float f1 = 0.2F * MathHelper.sin(MathHelper.sqrt(p_187457_5_) * (float) (Math.PI * 2));
+               float f2 = -0.2F * MathHelper.sin(p_187457_5_ * (float) Math.PI);
+               int i = flag1 ? 1 : -1;
+               GlStateManager.translate(i * f, f1, f2);
+               this.transformSideFirstPerson(enumhandside, p_187457_7_);
+               this.transformFirstPerson(enumhandside, p_187457_5_);
+            }
+
+            this.renderItemSide(p_187457_1_, p_187457_6_, flag1 ? TransformType.FIRST_PERSON_RIGHT_HAND : TransformType.FIRST_PERSON_LEFT_HAND, !flag1);
          }
 
-         this.renderItemSide(
-            ☃, ☃, ☃xx ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !☃xx
-         );
+         GlStateManager.popMatrix();
       }
-
-      GlStateManager.popMatrix();
    }
 
-   public void renderOverlays(float var1) {
+   public void renderOverlays(float partialTicks) {
       GlStateManager.disableAlpha();
       if (this.mc.player.isEntityInsideOpaqueBlock()) {
-         IBlockState ☃ = this.mc.world.getBlockState(new BlockPos(this.mc.player));
-         EntityPlayer ☃x = this.mc.player;
-
-         for (int ☃xx = 0; ☃xx < 8; ☃xx++) {
-            double ☃xxx = ☃x.posX + ((☃xx >> 0) % 2 - 0.5F) * ☃x.width * 0.8F;
-            double ☃xxxx = ☃x.posY + ((☃xx >> 1) % 2 - 0.5F) * 0.1F;
-            double ☃xxxxx = ☃x.posZ + ((☃xx >> 2) % 2 - 0.5F) * ☃x.width * 0.8F;
-            BlockPos ☃xxxxxx = new BlockPos(☃xxx, ☃xxxx + ☃x.getEyeHeight(), ☃xxxxx);
-            IBlockState ☃xxxxxxx = this.mc.world.getBlockState(☃xxxxxx);
-            if (☃xxxxxxx.causesSuffocation()) {
-               ☃ = ☃xxxxxxx;
+         IBlockState iblockstate = this.mc.world.getBlockState(new BlockPos(this.mc.player));
+         BlockPos overlayPos = new BlockPos(this.mc.player);
+         EntityPlayer entityplayer = this.mc.player;
+
+         for (int i = 0; i < 8; i++) {
+            double d0 = entityplayer.posX + ((i >> 0) % 2 - 0.5F) * entityplayer.width * 0.8F;
+            double d1 = entityplayer.posY + ((i >> 1) % 2 - 0.5F) * 0.1F;
+            double d2 = entityplayer.posZ + ((i >> 2) % 2 - 0.5F) * entityplayer.width * 0.8F;
+            BlockPos blockpos = new BlockPos(d0, d1 + entityplayer.getEyeHeight(), d2);
+            IBlockState iblockstate1 = this.mc.world.getBlockState(blockpos);
+            if (iblockstate1.r()) {
+               iblockstate = iblockstate1;
+               overlayPos = blockpos;
             }
          }
 
-         if (☃.getRenderType() != EnumBlockRenderType.INVISIBLE) {
-            this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(☃));
+         if (iblockstate.i() != EnumBlockRenderType.INVISIBLE) {
+            Object overlayType = Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
+            if (!Reflector.callBoolean(
+               Reflector.ForgeEventFactory_renderBlockOverlay, new Object[]{this.mc.player, partialTicks, overlayType, iblockstate, overlayPos}
+            )) {
+               this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
+            }
          }
       }
 
       if (!this.mc.player.isSpectator()) {
-         if (this.mc.player.isInsideOfMaterial(Material.WATER)) {
-            this.renderWaterOverlayTexture(☃);
+         if (this.mc.player.isInsideOfMaterial(Material.WATER)
+            && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, new Object[]{this.mc.player, partialTicks})) {
+            this.renderWaterOverlayTexture(partialTicks);
          }
 
-         if (this.mc.player.isBurning()) {
+         if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, new Object[]{this.mc.player, partialTicks})) {
             this.renderFireInFirstPerson();
          }
       }
@@ -401,65 +435,70 @@ public void renderOverlays(float var1) {
       GlStateManager.enableAlpha();
    }
 
-   private void renderSuffocationOverlay(TextureAtlasSprite var1) {
+   private void renderSuffocationOverlay(TextureAtlasSprite sprite) {
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      float ☃xx = 0.1F;
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      float f = 0.1F;
       GlStateManager.color(0.1F, 0.1F, 0.1F, 0.5F);
       GlStateManager.pushMatrix();
-      float ☃xxx = -1.0F;
-      float ☃xxxx = 1.0F;
-      float ☃xxxxx = -1.0F;
-      float ☃xxxxxx = 1.0F;
-      float ☃xxxxxxx = -0.5F;
-      float ☃xxxxxxxx = ☃.getMinU();
-      float ☃xxxxxxxxx = ☃.getMaxU();
-      float ☃xxxxxxxxxx = ☃.getMinV();
-      float ☃xxxxxxxxxxx = ☃.getMaxV();
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃x.pos(-1.0, -1.0, -0.5).tex(☃xxxxxxxxx, ☃xxxxxxxxxxx).endVertex();
-      ☃x.pos(1.0, -1.0, -0.5).tex(☃xxxxxxxx, ☃xxxxxxxxxxx).endVertex();
-      ☃x.pos(1.0, 1.0, -0.5).tex(☃xxxxxxxx, ☃xxxxxxxxxx).endVertex();
-      ☃x.pos(-1.0, 1.0, -0.5).tex(☃xxxxxxxxx, ☃xxxxxxxxxx).endVertex();
-      ☃.draw();
+      float f1 = -1.0F;
+      float f2 = 1.0F;
+      float f3 = -1.0F;
+      float f4 = 1.0F;
+      float f5 = -0.5F;
+      float f6 = sprite.getMinU();
+      float f7 = sprite.getMaxU();
+      float f8 = sprite.getMinV();
+      float f9 = sprite.getMaxV();
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+      bufferbuilder.pos(-1.0, -1.0, -0.5).tex(f7, f9).endVertex();
+      bufferbuilder.pos(1.0, -1.0, -0.5).tex(f6, f9).endVertex();
+      bufferbuilder.pos(1.0, 1.0, -0.5).tex(f6, f8).endVertex();
+      bufferbuilder.pos(-1.0, 1.0, -0.5).tex(f7, f8).endVertex();
+      tessellator.draw();
       GlStateManager.popMatrix();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
 
-   private void renderWaterOverlayTexture(float var1) {
-      this.mc.getTextureManager().bindTexture(RES_UNDERWATER_OVERLAY);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      float ☃xx = this.mc.player.getBrightness();
-      GlStateManager.color(☃xx, ☃xx, ☃xx, 0.5F);
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      GlStateManager.pushMatrix();
-      float ☃xxx = 4.0F;
-      float ☃xxxx = -1.0F;
-      float ☃xxxxx = 1.0F;
-      float ☃xxxxxx = -1.0F;
-      float ☃xxxxxxx = 1.0F;
-      float ☃xxxxxxxx = -0.5F;
-      float ☃xxxxxxxxx = -this.mc.player.rotationYaw / 64.0F;
-      float ☃xxxxxxxxxx = this.mc.player.rotationPitch / 64.0F;
-      ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-      ☃x.pos(-1.0, -1.0, -0.5).tex(4.0F + ☃xxxxxxxxx, 4.0F + ☃xxxxxxxxxx).endVertex();
-      ☃x.pos(1.0, -1.0, -0.5).tex(0.0F + ☃xxxxxxxxx, 4.0F + ☃xxxxxxxxxx).endVertex();
-      ☃x.pos(1.0, 1.0, -0.5).tex(0.0F + ☃xxxxxxxxx, 0.0F + ☃xxxxxxxxxx).endVertex();
-      ☃x.pos(-1.0, 1.0, -0.5).tex(4.0F + ☃xxxxxxxxx, 0.0F + ☃xxxxxxxxxx).endVertex();
-      ☃.draw();
-      GlStateManager.popMatrix();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.disableBlend();
+   private void renderWaterOverlayTexture(float partialTicks) {
+      if (!Config.isShaders() || Shaders.isUnderwaterOverlay()) {
+         this.mc.getTextureManager().bindTexture(RES_UNDERWATER_OVERLAY);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         float f = this.mc.player.getBrightness();
+         GlStateManager.color(f, f, f, 0.5F);
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         GlStateManager.pushMatrix();
+         float f1 = 4.0F;
+         float f2 = -1.0F;
+         float f3 = 1.0F;
+         float f4 = -1.0F;
+         float f5 = 1.0F;
+         float f6 = -0.5F;
+         float f7 = -this.mc.player.rotationYaw / 64.0F;
+         float f8 = this.mc.player.rotationPitch / 64.0F;
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+         bufferbuilder.pos(-1.0, -1.0, -0.5).tex(4.0F + f7, 4.0F + f8).endVertex();
+         bufferbuilder.pos(1.0, -1.0, -0.5).tex(0.0F + f7, 4.0F + f8).endVertex();
+         bufferbuilder.pos(1.0, 1.0, -0.5).tex(0.0F + f7, 0.0F + f8).endVertex();
+         bufferbuilder.pos(-1.0, 1.0, -0.5).tex(4.0F + f7, 0.0F + f8).endVertex();
+         tessellator.draw();
+         GlStateManager.popMatrix();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.disableBlend();
+      }
    }
 
    private void renderFireInFirstPerson() {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 0.9F);
       GlStateManager.depthFunc(519);
       GlStateManager.depthMask(false);
@@ -467,29 +506,30 @@ private void renderFireInFirstPerson() {
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      float ☃xx = 1.0F;
+      float f = 1.0F;
 
-      for (int ☃xxx = 0; ☃xxx < 2; ☃xxx++) {
+      for (int i = 0; i < 2; i++) {
          GlStateManager.pushMatrix();
-         TextureAtlasSprite ☃xxxx = this.mc.getTextureMapBlocks().getAtlasSprite("minecraft:blocks/fire_layer_1");
+         TextureAtlasSprite textureatlassprite = this.mc.getTextureMapBlocks().getAtlasSprite("minecraft:blocks/fire_layer_1");
          this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-         float ☃xxxxx = ☃xxxx.getMinU();
-         float ☃xxxxxx = ☃xxxx.getMaxU();
-         float ☃xxxxxxx = ☃xxxx.getMinV();
-         float ☃xxxxxxxx = ☃xxxx.getMaxV();
-         float ☃xxxxxxxxx = -0.5F;
-         float ☃xxxxxxxxxx = 0.5F;
-         float ☃xxxxxxxxxxx = -0.5F;
-         float ☃xxxxxxxxxxxx = 0.5F;
-         float ☃xxxxxxxxxxxxx = -0.5F;
-         GlStateManager.translate(-(☃xxx * 2 - 1) * 0.24F, -0.3F, 0.0F);
-         GlStateManager.rotate((☃xxx * 2 - 1) * 10.0F, 0.0F, 1.0F, 0.0F);
-         ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-         ☃x.pos(-0.5, -0.5, -0.5).tex(☃xxxxxx, ☃xxxxxxxx).endVertex();
-         ☃x.pos(0.5, -0.5, -0.5).tex(☃xxxxx, ☃xxxxxxxx).endVertex();
-         ☃x.pos(0.5, 0.5, -0.5).tex(☃xxxxx, ☃xxxxxxx).endVertex();
-         ☃x.pos(-0.5, 0.5, -0.5).tex(☃xxxxxx, ☃xxxxxxx).endVertex();
-         ☃.draw();
+         float f1 = textureatlassprite.getMinU();
+         float f2 = textureatlassprite.getMaxU();
+         float f3 = textureatlassprite.getMinV();
+         float f4 = textureatlassprite.getMaxV();
+         float f5 = -0.5F;
+         float f6 = 0.5F;
+         float f7 = -0.5F;
+         float f8 = 0.5F;
+         float f9 = -0.5F;
+         GlStateManager.translate(-(i * 2 - 1) * 0.24F, -0.3F, 0.0F);
+         GlStateManager.rotate((i * 2 - 1) * 10.0F, 0.0F, 1.0F, 0.0F);
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+         bufferbuilder.setSprite(textureatlassprite);
+         bufferbuilder.pos(-0.5, -0.5, -0.5).tex(f2, f4).endVertex();
+         bufferbuilder.pos(0.5, -0.5, -0.5).tex(f1, f4).endVertex();
+         bufferbuilder.pos(0.5, 0.5, -0.5).tex(f1, f3).endVertex();
+         bufferbuilder.pos(-0.5, 0.5, -0.5).tex(f2, f3).endVertex();
+         tessellator.draw();
          GlStateManager.popMatrix();
       }
 
@@ -502,31 +542,55 @@ private void renderFireInFirstPerson() {
    public void updateEquippedItem() {
       this.prevEquippedProgressMainHand = this.equippedProgressMainHand;
       this.prevEquippedProgressOffHand = this.equippedProgressOffHand;
-      EntityPlayerSP ☃ = this.mc.player;
-      ItemStack ☃x = ☃.getHeldItemMainhand();
-      ItemStack ☃xx = ☃.getHeldItemOffhand();
-      if (☃.isRowingBoat()) {
+      EntityPlayerSP entityplayersp = this.mc.player;
+      ItemStack itemstack = entityplayersp.getHeldItemMainhand();
+      ItemStack itemstack1 = entityplayersp.getHeldItemOffhand();
+      if (entityplayersp.isRowingBoat()) {
          this.equippedProgressMainHand = MathHelper.clamp(this.equippedProgressMainHand - 0.4F, 0.0F, 1.0F);
          this.equippedProgressOffHand = MathHelper.clamp(this.equippedProgressOffHand - 0.4F, 0.0F, 1.0F);
       } else {
-         float ☃xxx = ☃.getCooledAttackStrength(1.0F);
-         this.equippedProgressMainHand = this.equippedProgressMainHand
-            + MathHelper.clamp((Objects.equals(this.itemStackMainHand, ☃x) ? ☃xxx * ☃xxx * ☃xxx : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
-         this.equippedProgressOffHand = this.equippedProgressOffHand
-            + MathHelper.clamp((Objects.equals(this.itemStackOffHand, ☃xx) ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         float f = entityplayersp.getCooledAttackStrength(1.0F);
+         if (Reflector.ForgeHooksClient_shouldCauseReequipAnimation.exists()) {
+            boolean requipM = Reflector.callBoolean(
+               Reflector.ForgeHooksClient_shouldCauseReequipAnimation, new Object[]{this.itemStackMainHand, itemstack, entityplayersp.inventory.currentItem}
+            );
+            boolean requipO = Reflector.callBoolean(Reflector.ForgeHooksClient_shouldCauseReequipAnimation, new Object[]{this.itemStackOffHand, itemstack1, -1});
+            if (!requipM && !Objects.equals(this.itemStackMainHand, itemstack)) {
+               this.itemStackMainHand = itemstack;
+            }
+
+            if (!requipM && !Objects.equals(this.itemStackOffHand, itemstack1)) {
+               this.itemStackOffHand = itemstack1;
+            }
+
+            this.equippedProgressMainHand = this.equippedProgressMainHand
+               + MathHelper.clamp((!requipM ? f * f * f : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
+            this.equippedProgressOffHand = this.equippedProgressOffHand + MathHelper.clamp((!requipO ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         } else {
+            this.equippedProgressMainHand = this.equippedProgressMainHand
+               + MathHelper.clamp((Objects.equals(this.itemStackMainHand, itemstack) ? f * f * f : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
+            this.equippedProgressOffHand = this.equippedProgressOffHand
+               + MathHelper.clamp((Objects.equals(this.itemStackOffHand, itemstack1) ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         }
       }
 
       if (this.equippedProgressMainHand < 0.1F) {
-         this.itemStackMainHand = ☃x;
+         this.itemStackMainHand = itemstack;
+         if (Config.isShaders()) {
+            Shaders.setItemToRenderMain(this.itemStackMainHand);
+         }
       }
 
       if (this.equippedProgressOffHand < 0.1F) {
-         this.itemStackOffHand = ☃xx;
+         this.itemStackOffHand = itemstack1;
+         if (Config.isShaders()) {
+            Shaders.setItemToRenderOff(this.itemStackOffHand);
+         }
       }
    }
 
-   public void resetEquippedProgress(EnumHand var1) {
-      if (☃ == EnumHand.MAIN_HAND) {
+   public void resetEquippedProgress(EnumHand hand) {
+      if (hand == EnumHand.MAIN_HAND) {
          this.equippedProgressMainHand = 0.0F;
       } else {
          this.equippedProgressOffHand = 0.0F;
diff --git a/patches/net/minecraft/client/renderer/Matrix4f.java b/patches/net/minecraft/client/renderer/Matrix4f.java
index 9744846..ff2cab1 100644
--- a/patches/net/minecraft/client/renderer/Matrix4f.java
+++ b/patches/net/minecraft/client/renderer/Matrix4f.java
@@ -1,23 +1,23 @@
 package net.minecraft.client.renderer;
 
 public class Matrix4f extends org.lwjgl.util.vector.Matrix4f {
-   public Matrix4f(float[] var1) {
-      this.m00 = ☃[0];
-      this.m01 = ☃[1];
-      this.m02 = ☃[2];
-      this.m03 = ☃[3];
-      this.m10 = ☃[4];
-      this.m11 = ☃[5];
-      this.m12 = ☃[6];
-      this.m13 = ☃[7];
-      this.m20 = ☃[8];
-      this.m21 = ☃[9];
-      this.m22 = ☃[10];
-      this.m23 = ☃[11];
-      this.m30 = ☃[12];
-      this.m31 = ☃[13];
-      this.m32 = ☃[14];
-      this.m33 = ☃[15];
+   public Matrix4f(float[] matrix) {
+      this.m00 = matrix[0];
+      this.m01 = matrix[1];
+      this.m02 = matrix[2];
+      this.m03 = matrix[3];
+      this.m10 = matrix[4];
+      this.m11 = matrix[5];
+      this.m12 = matrix[6];
+      this.m13 = matrix[7];
+      this.m20 = matrix[8];
+      this.m21 = matrix[9];
+      this.m22 = matrix[10];
+      this.m23 = matrix[11];
+      this.m30 = matrix[12];
+      this.m31 = matrix[13];
+      this.m32 = matrix[14];
+      this.m33 = matrix[15];
    }
 
    public Matrix4f() {
diff --git a/patches/net/minecraft/client/renderer/OpenGlHelper.java b/patches/net/minecraft/client/renderer/OpenGlHelper.java
index e6fbc87..3a72bca 100644
--- a/patches/net/minecraft/client/renderer/OpenGlHelper.java
+++ b/patches/net/minecraft/client/renderer/OpenGlHelper.java
@@ -6,6 +6,8 @@
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Locale;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
@@ -14,6 +16,7 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.Sys;
+import org.lwjgl.opengl.ARBCopyBuffer;
 import org.lwjgl.opengl.ARBFramebufferObject;
 import org.lwjgl.opengl.ARBMultitexture;
 import org.lwjgl.opengl.ARBShaderObjects;
@@ -28,6 +31,7 @@
 import org.lwjgl.opengl.GL15;
 import org.lwjgl.opengl.GL20;
 import org.lwjgl.opengl.GL30;
+import org.lwjgl.opengl.GL31;
 import org.lwjgl.opengl.GLContext;
 import oshi.SystemInfo;
 import oshi.hardware.Processor;
@@ -88,11 +92,47 @@ public class OpenGlHelper {
    private static boolean arbVbo;
    public static int GL_ARRAY_BUFFER;
    public static int GL_STATIC_DRAW;
+   public static float lastBrightnessX = 0.0F;
+   public static float lastBrightnessY = 0.0F;
+   public static boolean openGL31;
+   public static boolean vboRegions;
+   public static int GL_COPY_READ_BUFFER;
+   public static int GL_COPY_WRITE_BUFFER;
+   public static final int GL_QUADS = 7;
+   public static final int GL_TRIANGLES = 4;
 
    public static void initializeTextures() {
-      ContextCapabilities ☃ = GLContext.getCapabilities();
-      arbMultitexture = ☃.GL_ARB_multitexture && !☃.OpenGL13;
-      arbTextureEnvCombine = ☃.GL_ARB_texture_env_combine && !☃.OpenGL13;
+      Config.initDisplay();
+      ContextCapabilities contextcapabilities = GLContext.getCapabilities();
+      arbMultitexture = contextcapabilities.GL_ARB_multitexture && !contextcapabilities.OpenGL13;
+      arbTextureEnvCombine = contextcapabilities.GL_ARB_texture_env_combine && !contextcapabilities.OpenGL13;
+      openGL31 = contextcapabilities.OpenGL31;
+      if (openGL31) {
+         GL_COPY_READ_BUFFER = 36662;
+         GL_COPY_WRITE_BUFFER = 36663;
+      } else {
+         GL_COPY_READ_BUFFER = 36662;
+         GL_COPY_WRITE_BUFFER = 36663;
+      }
+
+      boolean copyBuffer = openGL31 || contextcapabilities.GL_ARB_copy_buffer;
+      boolean multiDrawArrays = contextcapabilities.OpenGL14;
+      vboRegions = copyBuffer && multiDrawArrays;
+      if (!vboRegions) {
+         List<String> list = new ArrayList<>();
+         if (!copyBuffer) {
+            list.add("OpenGL 1.3, ARB_copy_buffer");
+         }
+
+         if (!multiDrawArrays) {
+            list.add("OpenGL 1.4");
+         }
+
+         String vboRegionWarn = "VboRegions not supported, missing: " + Config.listToString(list);
+         Config.dbg(vboRegionWarn);
+         logText = logText + vboRegionWarn + "\n";
+      }
+
       if (arbMultitexture) {
          logText = logText + "Using ARB_multitexture.\n";
          defaultTexUnit = 33984;
@@ -149,12 +189,13 @@ public static void initializeTextures() {
          GL_OPERAND2_ALPHA = 34202;
       }
 
-      extBlendFuncSeparate = ☃.GL_EXT_blend_func_separate && !☃.OpenGL14;
-      openGL14 = ☃.OpenGL14 || ☃.GL_EXT_blend_func_separate;
-      framebufferSupported = openGL14 && (☃.GL_ARB_framebuffer_object || ☃.GL_EXT_framebuffer_object || ☃.OpenGL30);
+      extBlendFuncSeparate = contextcapabilities.GL_EXT_blend_func_separate && !contextcapabilities.OpenGL14;
+      openGL14 = contextcapabilities.OpenGL14 || contextcapabilities.GL_EXT_blend_func_separate;
+      framebufferSupported = openGL14
+         && (contextcapabilities.GL_ARB_framebuffer_object || contextcapabilities.GL_EXT_framebuffer_object || contextcapabilities.OpenGL30);
       if (framebufferSupported) {
          logText = logText + "Using framebuffer objects because ";
-         if (☃.OpenGL30) {
+         if (contextcapabilities.OpenGL30) {
             logText = logText + "OpenGL 3.0 is supported and separate blending is supported.\n";
             framebufferType = OpenGlHelper.FboMode.BASE;
             GL_FRAMEBUFFER = 36160;
@@ -166,7 +207,7 @@ public static void initializeTextures() {
             GL_FB_INCOMPLETE_MISS_ATTACH = 36055;
             GL_FB_INCOMPLETE_DRAW_BUFFER = 36059;
             GL_FB_INCOMPLETE_READ_BUFFER = 36060;
-         } else if (☃.GL_ARB_framebuffer_object) {
+         } else if (contextcapabilities.GL_ARB_framebuffer_object) {
             logText = logText + "ARB_framebuffer_object is supported and separate blending is supported.\n";
             framebufferType = OpenGlHelper.FboMode.ARB;
             GL_FRAMEBUFFER = 36160;
@@ -178,7 +219,7 @@ public static void initializeTextures() {
             GL_FB_INCOMPLETE_ATTACHMENT = 36054;
             GL_FB_INCOMPLETE_DRAW_BUFFER = 36059;
             GL_FB_INCOMPLETE_READ_BUFFER = 36060;
-         } else if (☃.GL_EXT_framebuffer_object) {
+         } else if (contextcapabilities.GL_EXT_framebuffer_object) {
             logText = logText + "EXT_framebuffer_object is supported.\n";
             framebufferType = OpenGlHelper.FboMode.EXT;
             GL_FRAMEBUFFER = 36160;
@@ -193,18 +234,19 @@ public static void initializeTextures() {
          }
       } else {
          logText = logText + "Not using framebuffer objects because ";
-         logText = logText + "OpenGL 1.4 is " + (☃.OpenGL14 ? "" : "not ") + "supported, ";
-         logText = logText + "EXT_blend_func_separate is " + (☃.GL_EXT_blend_func_separate ? "" : "not ") + "supported, ";
-         logText = logText + "OpenGL 3.0 is " + (☃.OpenGL30 ? "" : "not ") + "supported, ";
-         logText = logText + "ARB_framebuffer_object is " + (☃.GL_ARB_framebuffer_object ? "" : "not ") + "supported, and ";
-         logText = logText + "EXT_framebuffer_object is " + (☃.GL_EXT_framebuffer_object ? "" : "not ") + "supported.\n";
+         logText = logText + "OpenGL 1.4 is " + (contextcapabilities.OpenGL14 ? "" : "not ") + "supported, ";
+         logText = logText + "EXT_blend_func_separate is " + (contextcapabilities.GL_EXT_blend_func_separate ? "" : "not ") + "supported, ";
+         logText = logText + "OpenGL 3.0 is " + (contextcapabilities.OpenGL30 ? "" : "not ") + "supported, ";
+         logText = logText + "ARB_framebuffer_object is " + (contextcapabilities.GL_ARB_framebuffer_object ? "" : "not ") + "supported, and ";
+         logText = logText + "EXT_framebuffer_object is " + (contextcapabilities.GL_EXT_framebuffer_object ? "" : "not ") + "supported.\n";
       }
 
-      openGL21 = ☃.OpenGL21;
-      shadersAvailable = openGL21 || ☃.GL_ARB_vertex_shader && ☃.GL_ARB_fragment_shader && ☃.GL_ARB_shader_objects;
+      openGL21 = contextcapabilities.OpenGL21;
+      shadersAvailable = openGL21
+         || contextcapabilities.GL_ARB_vertex_shader && contextcapabilities.GL_ARB_fragment_shader && contextcapabilities.GL_ARB_shader_objects;
       logText = logText + "Shaders are " + (shadersAvailable ? "" : "not ") + "available because ";
       if (shadersAvailable) {
-         if (☃.OpenGL21) {
+         if (contextcapabilities.OpenGL21) {
             logText = logText + "OpenGL 2.1 is supported.\n";
             arbShaders = false;
             GL_LINK_STATUS = 35714;
@@ -220,17 +262,17 @@ public static void initializeTextures() {
             GL_FRAGMENT_SHADER = 35632;
          }
       } else {
-         logText = logText + "OpenGL 2.1 is " + (☃.OpenGL21 ? "" : "not ") + "supported, ";
-         logText = logText + "ARB_shader_objects is " + (☃.GL_ARB_shader_objects ? "" : "not ") + "supported, ";
-         logText = logText + "ARB_vertex_shader is " + (☃.GL_ARB_vertex_shader ? "" : "not ") + "supported, and ";
-         logText = logText + "ARB_fragment_shader is " + (☃.GL_ARB_fragment_shader ? "" : "not ") + "supported.\n";
+         logText = logText + "OpenGL 2.1 is " + (contextcapabilities.OpenGL21 ? "" : "not ") + "supported, ";
+         logText = logText + "ARB_shader_objects is " + (contextcapabilities.GL_ARB_shader_objects ? "" : "not ") + "supported, ";
+         logText = logText + "ARB_vertex_shader is " + (contextcapabilities.GL_ARB_vertex_shader ? "" : "not ") + "supported, and ";
+         logText = logText + "ARB_fragment_shader is " + (contextcapabilities.GL_ARB_fragment_shader ? "" : "not ") + "supported.\n";
       }
 
       shadersSupported = framebufferSupported && shadersAvailable;
-      String ☃x = GL11.glGetString(7936).toLowerCase(Locale.ROOT);
-      nvidia = ☃x.contains("nvidia");
-      arbVbo = !☃.OpenGL15 && ☃.GL_ARB_vertex_buffer_object;
-      vboSupported = ☃.OpenGL15 || arbVbo;
+      String s = GL11.glGetString(7936).toLowerCase(Locale.ROOT);
+      nvidia = s.contains("nvidia");
+      arbVbo = !contextcapabilities.OpenGL15 && contextcapabilities.GL_ARB_vertex_buffer_object;
+      vboSupported = contextcapabilities.OpenGL15 || arbVbo;
       logText = logText + "VBOs are " + (vboSupported ? "" : "not ") + "available because ";
       if (vboSupported) {
          if (arbVbo) {
@@ -244,7 +286,7 @@ public static void initializeTextures() {
          }
       }
 
-      ati = ☃x.contains("ati");
+      ati = s.contains("ati");
       if (ati) {
          if (vboSupported) {
             vboSupportedAti = true;
@@ -254,9 +296,9 @@ public static void initializeTextures() {
       }
 
       try {
-         Processor[] ☃xx = new SystemInfo().getHardware().getProcessors();
-         cpu = String.format("%dx %s", ☃xx.length, ☃xx[0]).replaceAll("\\s+", " ");
-      } catch (Throwable var3) {
+         Processor[] aprocessor = new SystemInfo().getHardware().getProcessors();
+         cpu = String.format("%dx %s", aprocessor.length, aprocessor[0]).replaceAll("\\s+", " ");
+      } catch (Throwable var5) {
       }
    }
 
@@ -268,63 +310,63 @@ public static String getLogText() {
       return logText;
    }
 
-   public static int glGetProgrami(int var0, int var1) {
-      return arbShaders ? ARBShaderObjects.glGetObjectParameteriARB(☃, ☃) : GL20.glGetProgrami(☃, ☃);
+   public static int glGetProgrami(int program, int pname) {
+      return arbShaders ? ARBShaderObjects.glGetObjectParameteriARB(program, pname) : GL20.glGetProgrami(program, pname);
    }
 
-   public static void glAttachShader(int var0, int var1) {
+   public static void glAttachShader(int program, int shaderIn) {
       if (arbShaders) {
-         ARBShaderObjects.glAttachObjectARB(☃, ☃);
+         ARBShaderObjects.glAttachObjectARB(program, shaderIn);
       } else {
-         GL20.glAttachShader(☃, ☃);
+         GL20.glAttachShader(program, shaderIn);
       }
    }
 
-   public static void glDeleteShader(int var0) {
+   public static void glDeleteShader(int shaderIn) {
       if (arbShaders) {
-         ARBShaderObjects.glDeleteObjectARB(☃);
+         ARBShaderObjects.glDeleteObjectARB(shaderIn);
       } else {
-         GL20.glDeleteShader(☃);
+         GL20.glDeleteShader(shaderIn);
       }
    }
 
-   public static int glCreateShader(int var0) {
-      return arbShaders ? ARBShaderObjects.glCreateShaderObjectARB(☃) : GL20.glCreateShader(☃);
+   public static int glCreateShader(int type) {
+      return arbShaders ? ARBShaderObjects.glCreateShaderObjectARB(type) : GL20.glCreateShader(type);
    }
 
-   public static void glShaderSource(int var0, ByteBuffer var1) {
+   public static void glShaderSource(int shaderIn, ByteBuffer string) {
       if (arbShaders) {
-         ARBShaderObjects.glShaderSourceARB(☃, ☃);
+         ARBShaderObjects.glShaderSourceARB(shaderIn, string);
       } else {
-         GL20.glShaderSource(☃, ☃);
+         GL20.glShaderSource(shaderIn, string);
       }
    }
 
-   public static void glCompileShader(int var0) {
+   public static void glCompileShader(int shaderIn) {
       if (arbShaders) {
-         ARBShaderObjects.glCompileShaderARB(☃);
+         ARBShaderObjects.glCompileShaderARB(shaderIn);
       } else {
-         GL20.glCompileShader(☃);
+         GL20.glCompileShader(shaderIn);
       }
    }
 
-   public static int glGetShaderi(int var0, int var1) {
-      return arbShaders ? ARBShaderObjects.glGetObjectParameteriARB(☃, ☃) : GL20.glGetShaderi(☃, ☃);
+   public static int glGetShaderi(int shaderIn, int pname) {
+      return arbShaders ? ARBShaderObjects.glGetObjectParameteriARB(shaderIn, pname) : GL20.glGetShaderi(shaderIn, pname);
    }
 
-   public static String glGetShaderInfoLog(int var0, int var1) {
-      return arbShaders ? ARBShaderObjects.glGetInfoLogARB(☃, ☃) : GL20.glGetShaderInfoLog(☃, ☃);
+   public static String glGetShaderInfoLog(int shaderIn, int maxLength) {
+      return arbShaders ? ARBShaderObjects.glGetInfoLogARB(shaderIn, maxLength) : GL20.glGetShaderInfoLog(shaderIn, maxLength);
    }
 
-   public static String glGetProgramInfoLog(int var0, int var1) {
-      return arbShaders ? ARBShaderObjects.glGetInfoLogARB(☃, ☃) : GL20.glGetProgramInfoLog(☃, ☃);
+   public static String glGetProgramInfoLog(int program, int maxLength) {
+      return arbShaders ? ARBShaderObjects.glGetInfoLogARB(program, maxLength) : GL20.glGetProgramInfoLog(program, maxLength);
    }
 
-   public static void glUseProgram(int var0) {
+   public static void glUseProgram(int program) {
       if (arbShaders) {
-         ARBShaderObjects.glUseProgramObjectARB(☃);
+         ARBShaderObjects.glUseProgramObjectARB(program);
       } else {
-         GL20.glUseProgram(☃);
+         GL20.glUseProgram(program);
       }
    }
 
@@ -332,214 +374,218 @@ public static int glCreateProgram() {
       return arbShaders ? ARBShaderObjects.glCreateProgramObjectARB() : GL20.glCreateProgram();
    }
 
-   public static void glDeleteProgram(int var0) {
+   public static void glDeleteProgram(int program) {
       if (arbShaders) {
-         ARBShaderObjects.glDeleteObjectARB(☃);
+         ARBShaderObjects.glDeleteObjectARB(program);
       } else {
-         GL20.glDeleteProgram(☃);
+         GL20.glDeleteProgram(program);
       }
    }
 
-   public static void glLinkProgram(int var0) {
+   public static void glLinkProgram(int program) {
       if (arbShaders) {
-         ARBShaderObjects.glLinkProgramARB(☃);
+         ARBShaderObjects.glLinkProgramARB(program);
       } else {
-         GL20.glLinkProgram(☃);
+         GL20.glLinkProgram(program);
       }
    }
 
-   public static int glGetUniformLocation(int var0, CharSequence var1) {
-      return arbShaders ? ARBShaderObjects.glGetUniformLocationARB(☃, ☃) : GL20.glGetUniformLocation(☃, ☃);
+   public static int glGetUniformLocation(int programObj, CharSequence name) {
+      return arbShaders ? ARBShaderObjects.glGetUniformLocationARB(programObj, name) : GL20.glGetUniformLocation(programObj, name);
    }
 
-   public static void glUniform1(int var0, IntBuffer var1) {
+   public static void glUniform1(int location, IntBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform1ARB(☃, ☃);
+         ARBShaderObjects.glUniform1ARB(location, values);
       } else {
-         GL20.glUniform1(☃, ☃);
+         GL20.glUniform1(location, values);
       }
    }
 
-   public static void glUniform1i(int var0, int var1) {
+   public static void glUniform1i(int location, int v0) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform1iARB(☃, ☃);
+         ARBShaderObjects.glUniform1iARB(location, v0);
       } else {
-         GL20.glUniform1i(☃, ☃);
+         GL20.glUniform1i(location, v0);
       }
    }
 
-   public static void glUniform1(int var0, FloatBuffer var1) {
+   public static void glUniform1(int location, FloatBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform1ARB(☃, ☃);
+         ARBShaderObjects.glUniform1ARB(location, values);
       } else {
-         GL20.glUniform1(☃, ☃);
+         GL20.glUniform1(location, values);
       }
    }
 
-   public static void glUniform2(int var0, IntBuffer var1) {
+   public static void glUniform2(int location, IntBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform2ARB(☃, ☃);
+         ARBShaderObjects.glUniform2ARB(location, values);
       } else {
-         GL20.glUniform2(☃, ☃);
+         GL20.glUniform2(location, values);
       }
    }
 
-   public static void glUniform2(int var0, FloatBuffer var1) {
+   public static void glUniform2(int location, FloatBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform2ARB(☃, ☃);
+         ARBShaderObjects.glUniform2ARB(location, values);
       } else {
-         GL20.glUniform2(☃, ☃);
+         GL20.glUniform2(location, values);
       }
    }
 
-   public static void glUniform3(int var0, IntBuffer var1) {
+   public static void glUniform3(int location, IntBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform3ARB(☃, ☃);
+         ARBShaderObjects.glUniform3ARB(location, values);
       } else {
-         GL20.glUniform3(☃, ☃);
+         GL20.glUniform3(location, values);
       }
    }
 
-   public static void glUniform3(int var0, FloatBuffer var1) {
+   public static void glUniform3(int location, FloatBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform3ARB(☃, ☃);
+         ARBShaderObjects.glUniform3ARB(location, values);
       } else {
-         GL20.glUniform3(☃, ☃);
+         GL20.glUniform3(location, values);
       }
    }
 
-   public static void glUniform4(int var0, IntBuffer var1) {
+   public static void glUniform4(int location, IntBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform4ARB(☃, ☃);
+         ARBShaderObjects.glUniform4ARB(location, values);
       } else {
-         GL20.glUniform4(☃, ☃);
+         GL20.glUniform4(location, values);
       }
    }
 
-   public static void glUniform4(int var0, FloatBuffer var1) {
+   public static void glUniform4(int location, FloatBuffer values) {
       if (arbShaders) {
-         ARBShaderObjects.glUniform4ARB(☃, ☃);
+         ARBShaderObjects.glUniform4ARB(location, values);
       } else {
-         GL20.glUniform4(☃, ☃);
+         GL20.glUniform4(location, values);
       }
    }
 
-   public static void glUniformMatrix2(int var0, boolean var1, FloatBuffer var2) {
+   public static void glUniformMatrix2(int location, boolean transpose, FloatBuffer matrices) {
       if (arbShaders) {
-         ARBShaderObjects.glUniformMatrix2ARB(☃, ☃, ☃);
+         ARBShaderObjects.glUniformMatrix2ARB(location, transpose, matrices);
       } else {
-         GL20.glUniformMatrix2(☃, ☃, ☃);
+         GL20.glUniformMatrix2(location, transpose, matrices);
       }
    }
 
-   public static void glUniformMatrix3(int var0, boolean var1, FloatBuffer var2) {
+   public static void glUniformMatrix3(int location, boolean transpose, FloatBuffer matrices) {
       if (arbShaders) {
-         ARBShaderObjects.glUniformMatrix3ARB(☃, ☃, ☃);
+         ARBShaderObjects.glUniformMatrix3ARB(location, transpose, matrices);
       } else {
-         GL20.glUniformMatrix3(☃, ☃, ☃);
+         GL20.glUniformMatrix3(location, transpose, matrices);
       }
    }
 
-   public static void glUniformMatrix4(int var0, boolean var1, FloatBuffer var2) {
+   public static void glUniformMatrix4(int location, boolean transpose, FloatBuffer matrices) {
       if (arbShaders) {
-         ARBShaderObjects.glUniformMatrix4ARB(☃, ☃, ☃);
+         ARBShaderObjects.glUniformMatrix4ARB(location, transpose, matrices);
       } else {
-         GL20.glUniformMatrix4(☃, ☃, ☃);
+         GL20.glUniformMatrix4(location, transpose, matrices);
       }
    }
 
-   public static int glGetAttribLocation(int var0, CharSequence var1) {
-      return arbShaders ? ARBVertexShader.glGetAttribLocationARB(☃, ☃) : GL20.glGetAttribLocation(☃, ☃);
+   public static int glGetAttribLocation(int program, CharSequence name) {
+      return arbShaders ? ARBVertexShader.glGetAttribLocationARB(program, name) : GL20.glGetAttribLocation(program, name);
    }
 
    public static int glGenBuffers() {
       return arbVbo ? ARBVertexBufferObject.glGenBuffersARB() : GL15.glGenBuffers();
    }
 
-   public static void glBindBuffer(int var0, int var1) {
+   public static void glBindBuffer(int target, int buffer) {
       if (arbVbo) {
-         ARBVertexBufferObject.glBindBufferARB(☃, ☃);
+         ARBVertexBufferObject.glBindBufferARB(target, buffer);
       } else {
-         GL15.glBindBuffer(☃, ☃);
+         GL15.glBindBuffer(target, buffer);
       }
    }
 
-   public static void glBufferData(int var0, ByteBuffer var1, int var2) {
+   public static void glBufferData(int target, ByteBuffer data, int usage) {
       if (arbVbo) {
-         ARBVertexBufferObject.glBufferDataARB(☃, ☃, ☃);
+         ARBVertexBufferObject.glBufferDataARB(target, data, usage);
       } else {
-         GL15.glBufferData(☃, ☃, ☃);
+         GL15.glBufferData(target, data, usage);
       }
    }
 
-   public static void glDeleteBuffers(int var0) {
+   public static void glDeleteBuffers(int buffer) {
       if (arbVbo) {
-         ARBVertexBufferObject.glDeleteBuffersARB(☃);
+         ARBVertexBufferObject.glDeleteBuffersARB(buffer);
       } else {
-         GL15.glDeleteBuffers(☃);
+         GL15.glDeleteBuffers(buffer);
       }
    }
 
    public static boolean useVbo() {
-      return vboSupported && Minecraft.getMinecraft().gameSettings.useVbo;
+      if (Config.isMultiTexture()) {
+         return false;
+      } else {
+         return Config.isRenderRegions() && !vboRegions ? false : vboSupported && Minecraft.getMinecraft().gameSettings.useVbo;
+      }
    }
 
-   public static void glBindFramebuffer(int var0, int var1) {
+   public static void glBindFramebuffer(int target, int framebufferIn) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glBindFramebuffer(☃, ☃);
+               GL30.glBindFramebuffer(target, framebufferIn);
                break;
             case ARB:
-               ARBFramebufferObject.glBindFramebuffer(☃, ☃);
+               ARBFramebufferObject.glBindFramebuffer(target, framebufferIn);
                break;
             case EXT:
-               EXTFramebufferObject.glBindFramebufferEXT(☃, ☃);
+               EXTFramebufferObject.glBindFramebufferEXT(target, framebufferIn);
          }
       }
    }
 
-   public static void glBindRenderbuffer(int var0, int var1) {
+   public static void glBindRenderbuffer(int target, int renderbuffer) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glBindRenderbuffer(☃, ☃);
+               GL30.glBindRenderbuffer(target, renderbuffer);
                break;
             case ARB:
-               ARBFramebufferObject.glBindRenderbuffer(☃, ☃);
+               ARBFramebufferObject.glBindRenderbuffer(target, renderbuffer);
                break;
             case EXT:
-               EXTFramebufferObject.glBindRenderbufferEXT(☃, ☃);
+               EXTFramebufferObject.glBindRenderbufferEXT(target, renderbuffer);
          }
       }
    }
 
-   public static void glDeleteRenderbuffers(int var0) {
+   public static void glDeleteRenderbuffers(int renderbuffer) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glDeleteRenderbuffers(☃);
+               GL30.glDeleteRenderbuffers(renderbuffer);
                break;
             case ARB:
-               ARBFramebufferObject.glDeleteRenderbuffers(☃);
+               ARBFramebufferObject.glDeleteRenderbuffers(renderbuffer);
                break;
             case EXT:
-               EXTFramebufferObject.glDeleteRenderbuffersEXT(☃);
+               EXTFramebufferObject.glDeleteRenderbuffersEXT(renderbuffer);
          }
       }
    }
 
-   public static void glDeleteFramebuffers(int var0) {
+   public static void glDeleteFramebuffers(int framebufferIn) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glDeleteFramebuffers(☃);
+               GL30.glDeleteFramebuffers(framebufferIn);
                break;
             case ARB:
-               ARBFramebufferObject.glDeleteFramebuffers(☃);
+               ARBFramebufferObject.glDeleteFramebuffers(framebufferIn);
                break;
             case EXT:
-               EXTFramebufferObject.glDeleteFramebuffersEXT(☃);
+               EXTFramebufferObject.glDeleteFramebuffersEXT(framebufferIn);
          }
       }
    }
@@ -578,175 +624,208 @@ public static int glGenRenderbuffers() {
       }
    }
 
-   public static void glRenderbufferStorage(int var0, int var1, int var2, int var3) {
+   public static void glRenderbufferStorage(int target, int internalFormat, int width, int height) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glRenderbufferStorage(☃, ☃, ☃, ☃);
+               GL30.glRenderbufferStorage(target, internalFormat, width, height);
                break;
             case ARB:
-               ARBFramebufferObject.glRenderbufferStorage(☃, ☃, ☃, ☃);
+               ARBFramebufferObject.glRenderbufferStorage(target, internalFormat, width, height);
                break;
             case EXT:
-               EXTFramebufferObject.glRenderbufferStorageEXT(☃, ☃, ☃, ☃);
+               EXTFramebufferObject.glRenderbufferStorageEXT(target, internalFormat, width, height);
          }
       }
    }
 
-   public static void glFramebufferRenderbuffer(int var0, int var1, int var2, int var3) {
+   public static void glFramebufferRenderbuffer(int target, int attachment, int renderBufferTarget, int renderBuffer) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glFramebufferRenderbuffer(☃, ☃, ☃, ☃);
+               GL30.glFramebufferRenderbuffer(target, attachment, renderBufferTarget, renderBuffer);
                break;
             case ARB:
-               ARBFramebufferObject.glFramebufferRenderbuffer(☃, ☃, ☃, ☃);
+               ARBFramebufferObject.glFramebufferRenderbuffer(target, attachment, renderBufferTarget, renderBuffer);
                break;
             case EXT:
-               EXTFramebufferObject.glFramebufferRenderbufferEXT(☃, ☃, ☃, ☃);
+               EXTFramebufferObject.glFramebufferRenderbufferEXT(target, attachment, renderBufferTarget, renderBuffer);
          }
       }
    }
 
-   public static int glCheckFramebufferStatus(int var0) {
+   public static int glCheckFramebufferStatus(int target) {
       if (!framebufferSupported) {
          return -1;
       } else {
          switch (framebufferType) {
             case BASE:
-               return GL30.glCheckFramebufferStatus(☃);
+               return GL30.glCheckFramebufferStatus(target);
             case ARB:
-               return ARBFramebufferObject.glCheckFramebufferStatus(☃);
+               return ARBFramebufferObject.glCheckFramebufferStatus(target);
             case EXT:
-               return EXTFramebufferObject.glCheckFramebufferStatusEXT(☃);
+               return EXTFramebufferObject.glCheckFramebufferStatusEXT(target);
             default:
                return -1;
          }
       }
    }
 
-   public static void glFramebufferTexture2D(int var0, int var1, int var2, int var3, int var4) {
+   public static void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
-               GL30.glFramebufferTexture2D(☃, ☃, ☃, ☃, ☃);
+               GL30.glFramebufferTexture2D(target, attachment, textarget, texture, level);
                break;
             case ARB:
-               ARBFramebufferObject.glFramebufferTexture2D(☃, ☃, ☃, ☃, ☃);
+               ARBFramebufferObject.glFramebufferTexture2D(target, attachment, textarget, texture, level);
                break;
             case EXT:
-               EXTFramebufferObject.glFramebufferTexture2DEXT(☃, ☃, ☃, ☃, ☃);
+               EXTFramebufferObject.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
          }
       }
    }
 
-   public static void setActiveTexture(int var0) {
+   public static void setActiveTexture(int texture) {
       if (arbMultitexture) {
-         ARBMultitexture.glActiveTextureARB(☃);
+         ARBMultitexture.glActiveTextureARB(texture);
       } else {
-         GL13.glActiveTexture(☃);
+         GL13.glActiveTexture(texture);
       }
    }
 
-   public static void setClientActiveTexture(int var0) {
+   public static void setClientActiveTexture(int texture) {
       if (arbMultitexture) {
-         ARBMultitexture.glClientActiveTextureARB(☃);
+         ARBMultitexture.glClientActiveTextureARB(texture);
       } else {
-         GL13.glClientActiveTexture(☃);
+         GL13.glClientActiveTexture(texture);
       }
    }
 
-   public static void setLightmapTextureCoords(int var0, float var1, float var2) {
+   public static void setLightmapTextureCoords(int target, float p_77475_1_, float t) {
       if (arbMultitexture) {
-         ARBMultitexture.glMultiTexCoord2fARB(☃, ☃, ☃);
+         ARBMultitexture.glMultiTexCoord2fARB(target, p_77475_1_, t);
       } else {
-         GL13.glMultiTexCoord2f(☃, ☃, ☃);
+         GL13.glMultiTexCoord2f(target, p_77475_1_, t);
+      }
+
+      if (target == lightmapTexUnit) {
+         lastBrightnessX = p_77475_1_;
+         lastBrightnessY = t;
       }
    }
 
-   public static void glBlendFunc(int var0, int var1, int var2, int var3) {
+   public static void glBlendFunc(int sFactorRGB, int dFactorRGB, int sfactorAlpha, int dfactorAlpha) {
       if (openGL14) {
          if (extBlendFuncSeparate) {
-            EXTBlendFuncSeparate.glBlendFuncSeparateEXT(☃, ☃, ☃, ☃);
+            EXTBlendFuncSeparate.glBlendFuncSeparateEXT(sFactorRGB, dFactorRGB, sfactorAlpha, dfactorAlpha);
          } else {
-            GL14.glBlendFuncSeparate(☃, ☃, ☃, ☃);
+            GL14.glBlendFuncSeparate(sFactorRGB, dFactorRGB, sfactorAlpha, dfactorAlpha);
          }
       } else {
-         GL11.glBlendFunc(☃, ☃);
+         GL11.glBlendFunc(sFactorRGB, dFactorRGB);
       }
    }
 
    public static boolean isFramebufferEnabled() {
-      return framebufferSupported && Minecraft.getMinecraft().gameSettings.fboEnable;
+      if (Config.isFastRender()) {
+         return false;
+      } else {
+         return Config.isAntialiasing() ? false : framebufferSupported && Minecraft.getMinecraft().gameSettings.fboEnable;
+      }
+   }
+
+   public static void glBufferData(int target, long size, int usage) {
+      if (arbVbo) {
+         ARBVertexBufferObject.glBufferDataARB(target, size, usage);
+      } else {
+         GL15.glBufferData(target, size, usage);
+      }
+   }
+
+   public static void glBufferSubData(int target, long offset, ByteBuffer data) {
+      if (arbVbo) {
+         ARBVertexBufferObject.glBufferSubDataARB(target, offset, data);
+      } else {
+         GL15.glBufferSubData(target, offset, data);
+      }
+   }
+
+   public static void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size) {
+      if (openGL31) {
+         GL31.glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
+      } else {
+         ARBCopyBuffer.glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
+      }
    }
 
    public static String getCpu() {
       return cpu == null ? "<unknown>" : cpu;
    }
 
-   public static void renderDirections(int var0) {
+   public static void renderDirections(int p_188785_0_) {
       GlStateManager.disableTexture2D();
       GlStateManager.depthMask(false);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       GL11.glLineWidth(4.0F);
-      ☃x.begin(1, DefaultVertexFormats.POSITION_COLOR);
-      ☃x.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
-      ☃x.pos(☃, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
-      ☃x.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
-      ☃x.pos(0.0, ☃, 0.0).color(0, 0, 0, 255).endVertex();
-      ☃x.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
-      ☃x.pos(0.0, 0.0, ☃).color(0, 0, 0, 255).endVertex();
-      ☃.draw();
+      bufferbuilder.begin(1, DefaultVertexFormats.POSITION_COLOR);
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
+      bufferbuilder.pos(p_188785_0_, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, p_188785_0_, 0.0).color(0, 0, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(0, 0, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, p_188785_0_).color(0, 0, 0, 255).endVertex();
+      tessellator.draw();
       GL11.glLineWidth(2.0F);
-      ☃x.begin(1, DefaultVertexFormats.POSITION_COLOR);
-      ☃x.pos(0.0, 0.0, 0.0).color(255, 0, 0, 255).endVertex();
-      ☃x.pos(☃, 0.0, 0.0).color(255, 0, 0, 255).endVertex();
-      ☃x.pos(0.0, 0.0, 0.0).color(0, 255, 0, 255).endVertex();
-      ☃x.pos(0.0, ☃, 0.0).color(0, 255, 0, 255).endVertex();
-      ☃x.pos(0.0, 0.0, 0.0).color(127, 127, 255, 255).endVertex();
-      ☃x.pos(0.0, 0.0, ☃).color(127, 127, 255, 255).endVertex();
-      ☃.draw();
+      bufferbuilder.begin(1, DefaultVertexFormats.POSITION_COLOR);
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(255, 0, 0, 255).endVertex();
+      bufferbuilder.pos(p_188785_0_, 0.0, 0.0).color(255, 0, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(0, 255, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, p_188785_0_, 0.0).color(0, 255, 0, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, 0.0).color(127, 127, 255, 255).endVertex();
+      bufferbuilder.pos(0.0, 0.0, p_188785_0_).color(127, 127, 255, 255).endVertex();
+      tessellator.draw();
       GL11.glLineWidth(1.0F);
       GlStateManager.depthMask(true);
       GlStateManager.enableTexture2D();
    }
 
-   public static void openFile(File var0) {
-      String ☃ = ☃.getAbsolutePath();
+   public static void openFile(File fileIn) {
+      String s = fileIn.getAbsolutePath();
       if (Util.getOSType() == Util.EnumOS.OSX) {
          try {
-            LOGGER.info(☃);
-            Runtime.getRuntime().exec(new String[]{"/usr/bin/open", ☃});
+            LOGGER.info(s);
+            Runtime.getRuntime().exec(new String[]{"/usr/bin/open", s});
             return;
          } catch (IOException var7) {
             LOGGER.error("Couldn't open file", var7);
          }
       } else if (Util.getOSType() == Util.EnumOS.WINDOWS) {
-         String ☃x = String.format("cmd.exe /C start \"Open file\" \"%s\"", ☃);
+         String s1 = String.format("cmd.exe /C start \"Open file\" \"%s\"", s);
 
          try {
-            Runtime.getRuntime().exec(☃x);
+            Runtime.getRuntime().exec(s1);
             return;
          } catch (IOException var6) {
             LOGGER.error("Couldn't open file", var6);
          }
       }
 
-      boolean ☃x = false;
+      boolean flag = false;
 
       try {
-         Class<?> ☃xx = Class.forName("java.awt.Desktop");
-         Object ☃xxx = ☃xx.getMethod("getDesktop").invoke(null);
-         ☃xx.getMethod("browse", URI.class).invoke(☃xxx, ☃.toURI());
+         Class<?> oclass = Class.forName("java.awt.Desktop");
+         Object object = oclass.getMethod("getDesktop").invoke(null);
+         oclass.getMethod("browse", URI.class).invoke(object, fileIn.toURI());
       } catch (Throwable var5) {
          LOGGER.error("Couldn't open link", var5);
-         ☃x = true;
+         flag = true;
       }
 
-      if (☃x) {
+      if (flag) {
          LOGGER.info("Opening via system class!");
-         Sys.openURL("file://" + ☃);
+         Sys.openURL("file://" + s);
       }
    }
 
diff --git a/patches/net/minecraft/client/renderer/RenderGlobal.java b/patches/net/minecraft/client/renderer/RenderGlobal.java
index b90d085..367ec09 100644
--- a/patches/net/minecraft/client/renderer/RenderGlobal.java
+++ b/patches/net/minecraft/client/renderer/RenderGlobal.java
@@ -2,15 +2,22 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.gson.JsonSyntaxException;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import javax.annotation.Nullable;
@@ -38,15 +45,19 @@
 import net.minecraft.client.renderer.culling.ClippingHelperImpl;
 import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.client.renderer.culling.ICamera;
+import net.minecraft.client.renderer.entity.RenderItemFrame;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
+import net.minecraft.client.renderer.tileentity.TileEntitySignRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumType;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
 import net.minecraft.client.shader.Framebuffer;
@@ -79,12 +90,35 @@
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
+import net.minecraft.util.math.BlockPos.PooledMutableBlockPos;
+import net.minecraft.util.math.RayTraceResult.Type;
+import net.minecraft.world.DimensionType;
 import net.minecraft.world.IWorldEventListener;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.optifine.CustomColors;
+import net.optifine.CustomSky;
+import net.optifine.DynamicLights;
+import net.optifine.Lagometer;
+import net.optifine.RandomEntities;
+import net.optifine.SmartAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.render.ChunkVisibility;
+import net.optifine.render.CloudRenderer;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
+import net.optifine.shaders.ShadowUtils;
+import net.optifine.shaders.gui.GuiShaderOptions;
+import net.optifine.util.ChunkUtils;
+import net.optifine.util.RenderChunkUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.input.Keyboard;
 import org.lwjgl.util.vector.Vector3f;
 import org.lwjgl.util.vector.Vector4f;
 
@@ -95,11 +129,11 @@ public class RenderGlobal implements IWorldEventListener, IResourceManagerReload
    private static final ResourceLocation CLOUDS_TEXTURES = new ResourceLocation("textures/environment/clouds.png");
    private static final ResourceLocation END_SKY_TEXTURES = new ResourceLocation("textures/environment/end_sky.png");
    private static final ResourceLocation FORCEFIELD_TEXTURES = new ResourceLocation("textures/misc/forcefield.png");
-   private final Minecraft mc;
+   public final Minecraft mc;
    private final TextureManager renderEngine;
    private final RenderManager renderManager;
    private WorldClient world;
-   private Set<RenderChunk> chunksToUpdate = Sets.newLinkedHashSet();
+   private Set<RenderChunk> chunksToUpdate = new ObjectLinkedOpenHashSet();
    private List<RenderGlobal.ContainerLocalRenderInformation> renderInfos = Lists.newArrayListWithCapacity(69696);
    private final Set<TileEntity> setTileEntities = Sets.newHashSet();
    private ViewFrustum viewFrustum;
@@ -111,7 +145,7 @@ public class RenderGlobal implements IWorldEventListener, IResourceManagerReload
    private VertexBuffer skyVBO;
    private VertexBuffer sky2VBO;
    private int cloudTickCounter;
-   private final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
+   public final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
    private final Map<BlockPos, ISound> mapSoundPositions = Maps.newHashMap();
    private final TextureAtlasSprite[] destroyBlockIcons = new TextureAtlasSprite[10];
    private Framebuffer entityOutlineFramebuffer;
@@ -143,14 +177,41 @@ public class RenderGlobal implements IWorldEventListener, IResourceManagerReload
    private double prevRenderSortX;
    private double prevRenderSortY;
    private double prevRenderSortZ;
-   private boolean displayListEntitiesDirty = true;
+   public boolean displayListEntitiesDirty = true;
    private boolean entityOutlinesRendered;
    private final Set<BlockPos> setLightUpdates = Sets.newHashSet();
-
-   public RenderGlobal(Minecraft var1) {
-      this.mc = ☃;
-      this.renderManager = ☃.getRenderManager();
-      this.renderEngine = ☃.getTextureManager();
+   private CloudRenderer cloudRenderer;
+   public Entity renderedEntity;
+   public Set chunksToResortTransparency = new LinkedHashSet();
+   public Set chunksToUpdateForced = new LinkedHashSet();
+   private Set<RenderChunk> chunksToUpdatePrev = new ObjectLinkedOpenHashSet();
+   private Deque visibilityDeque = new ArrayDeque();
+   private List renderInfosEntities = new ArrayList(1024);
+   private List renderInfosTileEntities = new ArrayList(1024);
+   private List renderInfosNormal = new ArrayList(1024);
+   private List renderInfosEntitiesNormal = new ArrayList(1024);
+   private List renderInfosTileEntitiesNormal = new ArrayList(1024);
+   private List renderInfosShadow = new ArrayList(1024);
+   private List renderInfosEntitiesShadow = new ArrayList(1024);
+   private List renderInfosTileEntitiesShadow = new ArrayList(1024);
+   private int renderDistance = 0;
+   private int renderDistanceSq = 0;
+   private static final Set SET_ALL_FACINGS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(EnumFacing.VALUES)));
+   private int countTileEntitiesRendered;
+   private IChunkProvider worldChunkProvider = null;
+   private Long2ObjectMap<Chunk> worldChunkProviderMap = null;
+   private int countLoadedChunksPrev = 0;
+   private RenderEnv renderEnv = new RenderEnv(Blocks.AIR.getDefaultState(), new BlockPos(0, 0, 0));
+   public boolean renderOverlayDamaged = false;
+   public boolean renderOverlayEyes = false;
+   private boolean firstWorldLoad = false;
+   private static int renderEntitiesCounter = 0;
+
+   public RenderGlobal(Minecraft mcIn) {
+      this.cloudRenderer = new CloudRenderer(mcIn);
+      this.mc = mcIn;
+      this.renderManager = mcIn.getRenderManager();
+      this.renderEngine = mcIn.getTextureManager();
       this.renderEngine.bindTexture(FORCEFIELD_TEXTURES);
       GlStateManager.glTexParameteri(3553, 10242, 10497);
       GlStateManager.glTexParameteri(3553, 10243, 10497);
@@ -166,22 +227,21 @@ public RenderGlobal(Minecraft var1) {
       }
 
       this.vertexBufferFormat = new VertexFormat();
-      this.vertexBufferFormat.addElement(new VertexFormatElement(0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.POSITION, 3));
+      this.vertexBufferFormat.addElement(new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.POSITION, 3));
       this.generateStars();
       this.generateSky();
       this.generateSky2();
    }
 
-   @Override
-   public void onResourceManagerReload(IResourceManager var1) {
+   public void onResourceManagerReload(IResourceManager resourceManager) {
       this.updateDestroyBlockIcons();
    }
 
    private void updateDestroyBlockIcons() {
-      TextureMap ☃ = this.mc.getTextureMapBlocks();
+      TextureMap texturemap = this.mc.getTextureMapBlocks();
 
-      for (int ☃x = 0; ☃x < this.destroyBlockIcons.length; ☃x++) {
-         this.destroyBlockIcons[☃x] = ☃.getAtlasSprite("minecraft:blocks/destroy_stage_" + ☃x);
+      for (int i = 0; i < this.destroyBlockIcons.length; i++) {
+         this.destroyBlockIcons[i] = texturemap.getAtlasSprite("minecraft:blocks/destroy_stage_" + i);
       }
    }
 
@@ -191,18 +251,18 @@ public void makeEntityOutlineShader() {
             ShaderLinkHelper.setNewStaticShaderLinkHelper();
          }
 
-         ResourceLocation ☃ = new ResourceLocation("shaders/post/entity_outline.json");
+         ResourceLocation resourcelocation = new ResourceLocation("shaders/post/entity_outline.json");
 
          try {
-            this.entityOutlineShader = new ShaderGroup(this.mc.getTextureManager(), this.mc.getResourceManager(), this.mc.getFramebuffer(), ☃);
+            this.entityOutlineShader = new ShaderGroup(this.mc.getTextureManager(), this.mc.getResourceManager(), this.mc.getFramebuffer(), resourcelocation);
             this.entityOutlineShader.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
             this.entityOutlineFramebuffer = this.entityOutlineShader.getFramebufferRaw("final");
          } catch (IOException var3) {
-            LOGGER.warn("Failed to load shader: {}", ☃, var3);
+            LOGGER.warn("Failed to load shader: {}", resourcelocation, var3);
             this.entityOutlineShader = null;
             this.entityOutlineFramebuffer = null;
          } catch (JsonSyntaxException var4) {
-            LOGGER.warn("Failed to load shader: {}", ☃, var4);
+            LOGGER.warn("Failed to load shader: {}", resourcelocation, var4);
             this.entityOutlineShader = null;
             this.entityOutlineFramebuffer = null;
          }
@@ -227,12 +287,14 @@ public void renderEntityOutlineFramebuffer() {
    }
 
    protected boolean isRenderEntityOutlines() {
-      return this.entityOutlineFramebuffer != null && this.entityOutlineShader != null && this.mc.player != null;
+      return !Config.isFastRender() && !Config.isShaders() && !Config.isAntialiasing()
+         ? this.entityOutlineFramebuffer != null && this.entityOutlineShader != null && this.mc.player != null
+         : false;
    }
 
    private void generateSky2() {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       if (this.sky2VBO != null) {
          this.sky2VBO.deleteGlBuffers();
       }
@@ -244,22 +306,22 @@ private void generateSky2() {
 
       if (this.vboEnabled) {
          this.sky2VBO = new VertexBuffer(this.vertexBufferFormat);
-         this.renderSky(☃x, -16.0F, true);
-         ☃x.finishDrawing();
-         ☃x.reset();
-         this.sky2VBO.bufferData(☃x.getByteBuffer());
+         this.renderSky(bufferbuilder, -16.0F, true);
+         bufferbuilder.finishDrawing();
+         bufferbuilder.reset();
+         this.sky2VBO.bufferData(bufferbuilder.getByteBuffer());
       } else {
          this.glSkyList2 = GLAllocation.generateDisplayLists(1);
          GlStateManager.glNewList(this.glSkyList2, 4864);
-         this.renderSky(☃x, -16.0F, true);
-         ☃.draw();
+         this.renderSky(bufferbuilder, -16.0F, true);
+         tessellator.draw();
          GlStateManager.glEndList();
       }
    }
 
    private void generateSky() {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       if (this.skyVBO != null) {
          this.skyVBO.deleteGlBuffers();
       }
@@ -271,44 +333,45 @@ private void generateSky() {
 
       if (this.vboEnabled) {
          this.skyVBO = new VertexBuffer(this.vertexBufferFormat);
-         this.renderSky(☃x, 16.0F, false);
-         ☃x.finishDrawing();
-         ☃x.reset();
-         this.skyVBO.bufferData(☃x.getByteBuffer());
+         this.renderSky(bufferbuilder, 16.0F, false);
+         bufferbuilder.finishDrawing();
+         bufferbuilder.reset();
+         this.skyVBO.bufferData(bufferbuilder.getByteBuffer());
       } else {
          this.glSkyList = GLAllocation.generateDisplayLists(1);
          GlStateManager.glNewList(this.glSkyList, 4864);
-         this.renderSky(☃x, 16.0F, false);
-         ☃.draw();
+         this.renderSky(bufferbuilder, 16.0F, false);
+         tessellator.draw();
          GlStateManager.glEndList();
       }
    }
 
-   private void renderSky(BufferBuilder var1, float var2, boolean var3) {
-      int ☃ = 64;
-      int ☃x = 6;
-      ☃.begin(7, DefaultVertexFormats.POSITION);
+   private void renderSky(BufferBuilder worldRendererIn, float posY, boolean reverseX) {
+      int i = 64;
+      int j = 6;
+      worldRendererIn.begin(7, DefaultVertexFormats.POSITION);
+      int skyDist = (this.renderDistance / 64 + 1) * 64 + 64;
 
-      for (int ☃xx = -384; ☃xx <= 384; ☃xx += 64) {
-         for (int ☃xxx = -384; ☃xxx <= 384; ☃xxx += 64) {
-            float ☃xxxx = ☃xx;
-            float ☃xxxxx = ☃xx + 64;
-            if (☃) {
-               ☃xxxxx = ☃xx;
-               ☃xxxx = ☃xx + 64;
+      for (int k = -skyDist; k <= skyDist; k += 64) {
+         for (int l = -skyDist; l <= skyDist; l += 64) {
+            float f = k;
+            float f1 = k + 64;
+            if (reverseX) {
+               f1 = k;
+               f = k + 64;
             }
 
-            ☃.pos(☃xxxx, ☃, ☃xxx).endVertex();
-            ☃.pos(☃xxxxx, ☃, ☃xxx).endVertex();
-            ☃.pos(☃xxxxx, ☃, ☃xxx + 64).endVertex();
-            ☃.pos(☃xxxx, ☃, ☃xxx + 64).endVertex();
+            worldRendererIn.pos(f, posY, l).endVertex();
+            worldRendererIn.pos(f1, posY, l).endVertex();
+            worldRendererIn.pos(f1, posY, l + 64).endVertex();
+            worldRendererIn.pos(f, posY, l + 64).endVertex();
          }
       }
    }
 
    private void generateStars() {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       if (this.starVBO != null) {
          this.starVBO.deleteGlBuffers();
       }
@@ -320,68 +383,67 @@ private void generateStars() {
 
       if (this.vboEnabled) {
          this.starVBO = new VertexBuffer(this.vertexBufferFormat);
-         this.renderStars(☃x);
-         ☃x.finishDrawing();
-         ☃x.reset();
-         this.starVBO.bufferData(☃x.getByteBuffer());
+         this.renderStars(bufferbuilder);
+         bufferbuilder.finishDrawing();
+         bufferbuilder.reset();
+         this.starVBO.bufferData(bufferbuilder.getByteBuffer());
       } else {
          this.starGLCallList = GLAllocation.generateDisplayLists(1);
          GlStateManager.pushMatrix();
          GlStateManager.glNewList(this.starGLCallList, 4864);
-         this.renderStars(☃x);
-         ☃.draw();
+         this.renderStars(bufferbuilder);
+         tessellator.draw();
          GlStateManager.glEndList();
          GlStateManager.popMatrix();
       }
    }
 
-   private void renderStars(BufferBuilder var1) {
-      Random ☃ = new Random(10842L);
-      ☃.begin(7, DefaultVertexFormats.POSITION);
-
-      for (int ☃x = 0; ☃x < 1500; ☃x++) {
-         double ☃xx = ☃.nextFloat() * 2.0F - 1.0F;
-         double ☃xxx = ☃.nextFloat() * 2.0F - 1.0F;
-         double ☃xxxx = ☃.nextFloat() * 2.0F - 1.0F;
-         double ☃xxxxx = 0.15F + ☃.nextFloat() * 0.1F;
-         double ☃xxxxxx = ☃xx * ☃xx + ☃xxx * ☃xxx + ☃xxxx * ☃xxxx;
-         if (☃xxxxxx < 1.0 && ☃xxxxxx > 0.01) {
-            ☃xxxxxx = 1.0 / Math.sqrt(☃xxxxxx);
-            ☃xx *= ☃xxxxxx;
-            ☃xxx *= ☃xxxxxx;
-            ☃xxxx *= ☃xxxxxx;
-            double ☃xxxxxxx = ☃xx * 100.0;
-            double ☃xxxxxxxx = ☃xxx * 100.0;
-            double ☃xxxxxxxxx = ☃xxxx * 100.0;
-            double ☃xxxxxxxxxx = Math.atan2(☃xx, ☃xxxx);
-            double ☃xxxxxxxxxxx = Math.sin(☃xxxxxxxxxx);
-            double ☃xxxxxxxxxxxx = Math.cos(☃xxxxxxxxxx);
-            double ☃xxxxxxxxxxxxx = Math.atan2(Math.sqrt(☃xx * ☃xx + ☃xxxx * ☃xxxx), ☃xxx);
-            double ☃xxxxxxxxxxxxxx = Math.sin(☃xxxxxxxxxxxxx);
-            double ☃xxxxxxxxxxxxxxx = Math.cos(☃xxxxxxxxxxxxx);
-            double ☃xxxxxxxxxxxxxxxx = ☃.nextDouble() * Math.PI * 2.0;
-            double ☃xxxxxxxxxxxxxxxxx = Math.sin(☃xxxxxxxxxxxxxxxx);
-            double ☃xxxxxxxxxxxxxxxxxx = Math.cos(☃xxxxxxxxxxxxxxxx);
-
-            for (int ☃xxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxx < 4; ☃xxxxxxxxxxxxxxxxxxx++) {
-               double ☃xxxxxxxxxxxxxxxxxxxx = 0.0;
-               double ☃xxxxxxxxxxxxxxxxxxxxx = ((☃xxxxxxxxxxxxxxxxxxx & 2) - 1) * ☃xxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxx = ((☃xxxxxxxxxxxxxxxxxxx + 1 & 2) - 1) * ☃xxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxx = 0.0;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxx + 0.0 * ☃xxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = 0.0 * ☃xxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxx;
-               double ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxx;
-               ☃.pos(☃xxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
-                  .endVertex();
-            }
-         }
-      }
-   }
-
-   public void setWorldAndLoadRenderers(@Nullable WorldClient var1) {
+   private void renderStars(BufferBuilder worldRendererIn) {
+      Random random = new Random(10842L);
+      worldRendererIn.begin(7, DefaultVertexFormats.POSITION);
+
+      for (int i = 0; i < 1500; i++) {
+         double d0 = random.nextFloat() * 2.0F - 1.0F;
+         double d1 = random.nextFloat() * 2.0F - 1.0F;
+         double d2 = random.nextFloat() * 2.0F - 1.0F;
+         double d3 = 0.15F + random.nextFloat() * 0.1F;
+         double d4 = d0 * d0 + d1 * d1 + d2 * d2;
+         if (d4 < 1.0 && d4 > 0.01) {
+            d4 = 1.0 / Math.sqrt(d4);
+            d0 *= d4;
+            d1 *= d4;
+            d2 *= d4;
+            double d5 = d0 * 100.0;
+            double d6 = d1 * 100.0;
+            double d7 = d2 * 100.0;
+            double d8 = Math.atan2(d0, d2);
+            double d9 = Math.sin(d8);
+            double d10 = Math.cos(d8);
+            double d11 = Math.atan2(Math.sqrt(d0 * d0 + d2 * d2), d1);
+            double d12 = Math.sin(d11);
+            double d13 = Math.cos(d11);
+            double d14 = random.nextDouble() * Math.PI * 2.0;
+            double d15 = Math.sin(d14);
+            double d16 = Math.cos(d14);
+
+            for (int j = 0; j < 4; j++) {
+               double d17 = 0.0;
+               double d18 = ((j & 2) - 1) * d3;
+               double d19 = ((j + 1 & 2) - 1) * d3;
+               double d20 = 0.0;
+               double d21 = d18 * d16 - d19 * d15;
+               double d22 = d19 * d16 + d18 * d15;
+               double d23 = d21 * d12 + 0.0 * d13;
+               double d24 = 0.0 * d12 - d21 * d13;
+               double d25 = d24 * d9 - d22 * d10;
+               double d26 = d22 * d9 + d24 * d10;
+               worldRendererIn.pos(d5 + d25, d6 + d23, d7 + d26).endVertex();
+            }
+         }
+      }
+   }
+
+   public void setWorldAndLoadRenderers(@Nullable WorldClient worldClientIn) {
       if (this.world != null) {
          this.world.removeEventListener(this);
       }
@@ -392,14 +454,24 @@ public void setWorldAndLoadRenderers(@Nullable WorldClient var1) {
       this.frustumUpdatePosChunkX = Integer.MIN_VALUE;
       this.frustumUpdatePosChunkY = Integer.MIN_VALUE;
       this.frustumUpdatePosChunkZ = Integer.MIN_VALUE;
-      this.renderManager.setWorld(☃);
-      this.world = ☃;
-      if (☃ != null) {
-         ☃.addEventListener(this);
+      this.renderManager.setWorld(worldClientIn);
+      this.world = worldClientIn;
+      if (Config.isDynamicLights()) {
+         DynamicLights.clear();
+      }
+
+      ChunkVisibility.reset();
+      this.worldChunkProvider = null;
+      this.worldChunkProviderMap = null;
+      this.renderEnv.reset(null, null);
+      Shaders.checkWorldChanged(this.world);
+      if (worldClientIn != null) {
+         worldClientIn.addEventListener(this);
          this.loadRenderers();
       } else {
          this.chunksToUpdate.clear();
-         this.renderInfos.clear();
+         this.chunksToUpdatePrev.clear();
+         this.clearRenderInfos();
          if (this.viewFrustum != null) {
             this.viewFrustum.deleteGlResources();
             this.viewFrustum = null;
@@ -420,25 +492,30 @@ public void loadRenderers() {
          }
 
          this.displayListEntitiesDirty = true;
-         Blocks.LEAVES.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
-         Blocks.LEAVES2.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
+         Blocks.LEAVES.setGraphicsLevel(Config.isTreesFancy());
+         Blocks.LEAVES2.setGraphicsLevel(Config.isTreesFancy());
+         BlockModelRenderer.updateAoLightValue();
+         if (Config.isDynamicLights()) {
+            DynamicLights.clear();
+         }
+
+         SmartAnimations.update();
          this.renderDistanceChunks = this.mc.gameSettings.renderDistanceChunks;
-         boolean ☃ = this.vboEnabled;
+         this.renderDistance = this.renderDistanceChunks * 16;
+         this.renderDistanceSq = this.renderDistance * this.renderDistance;
+         boolean flag = this.vboEnabled;
          this.vboEnabled = OpenGlHelper.useVbo();
-         if (☃ && !this.vboEnabled) {
+         if (flag && !this.vboEnabled) {
             this.renderContainer = new RenderList();
             this.renderChunkFactory = new ListChunkFactory();
-         } else if (!☃ && this.vboEnabled) {
+         } else if (!flag && this.vboEnabled) {
             this.renderContainer = new VboRenderList();
             this.renderChunkFactory = new VboChunkFactory();
          }
 
-         if (☃ != this.vboEnabled) {
-            this.generateStars();
-            this.generateSky();
-            this.generateSky2();
-         }
-
+         this.generateStars();
+         this.generateSky();
+         this.generateSky2();
          if (this.viewFrustum != null) {
             this.viewFrustum.deleteGlResources();
          }
@@ -450,14 +527,18 @@ public void loadRenderers() {
 
          this.viewFrustum = new ViewFrustum(this.world, this.mc.gameSettings.renderDistanceChunks, this, this.renderChunkFactory);
          if (this.world != null) {
-            Entity ☃x = this.mc.getRenderViewEntity();
-            if (☃x != null) {
-               this.viewFrustum.updateChunkPositions(☃x.posX, ☃x.posZ);
+            Entity entity = this.mc.getRenderViewEntity();
+            if (entity != null) {
+               this.viewFrustum.updateChunkPositions(entity.posX, entity.posZ);
             }
          }
 
          this.renderEntitiesStartupCounter = 2;
       }
+
+      if (this.mc.player == null) {
+         this.firstWorldLoad = true;
+      }
    }
 
    protected void stopChunkUpdates() {
@@ -465,80 +546,116 @@ protected void stopChunkUpdates() {
       this.renderDispatcher.stopChunkUpdates();
    }
 
-   public void createBindEntityOutlineFbs(int var1, int var2) {
-      if (OpenGlHelper.shadersSupported) {
-         if (this.entityOutlineShader != null) {
-            this.entityOutlineShader.createBindFramebuffers(☃, ☃);
-         }
+   public void createBindEntityOutlineFbs(int width, int height) {
+      if (OpenGlHelper.shadersSupported && this.entityOutlineShader != null) {
+         this.entityOutlineShader.createBindFramebuffers(width, height);
       }
    }
 
-   public void renderEntities(Entity var1, ICamera var2, float var3) {
+   public void renderEntities(Entity renderViewEntity, ICamera camera, float partialTicks) {
+      int pass = 0;
+      if (Reflector.MinecraftForgeClient_getRenderPass.exists()) {
+         pass = Reflector.callInt(Reflector.MinecraftForgeClient_getRenderPass, new Object[0]);
+      }
+
       if (this.renderEntitiesStartupCounter > 0) {
+         if (pass > 0) {
+            return;
+         }
+
          this.renderEntitiesStartupCounter--;
       } else {
-         double ☃ = ☃.prevPosX + (☃.posX - ☃.prevPosX) * ☃;
-         double ☃x = ☃.prevPosY + (☃.posY - ☃.prevPosY) * ☃;
-         double ☃xx = ☃.prevPosZ + (☃.posZ - ☃.prevPosZ) * ☃;
+         double d0 = renderViewEntity.prevPosX + (renderViewEntity.posX - renderViewEntity.prevPosX) * partialTicks;
+         double d1 = renderViewEntity.prevPosY + (renderViewEntity.posY - renderViewEntity.prevPosY) * partialTicks;
+         double d2 = renderViewEntity.prevPosZ + (renderViewEntity.posZ - renderViewEntity.prevPosZ) * partialTicks;
          this.world.profiler.startSection("prepare");
          TileEntityRendererDispatcher.instance
-            .prepare(this.world, this.mc.getTextureManager(), this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.objectMouseOver, ☃);
+            .prepare(this.world, this.mc.getTextureManager(), this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.objectMouseOver, partialTicks);
          this.renderManager
-            .cacheActiveRenderInfo(this.world, this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.pointedEntity, this.mc.gameSettings, ☃);
-         this.countEntitiesTotal = 0;
-         this.countEntitiesRendered = 0;
-         this.countEntitiesHidden = 0;
-         Entity ☃xxx = this.mc.getRenderViewEntity();
-         double ☃xxxx = ☃xxx.lastTickPosX + (☃xxx.posX - ☃xxx.lastTickPosX) * ☃;
-         double ☃xxxxx = ☃xxx.lastTickPosY + (☃xxx.posY - ☃xxx.lastTickPosY) * ☃;
-         double ☃xxxxxx = ☃xxx.lastTickPosZ + (☃xxx.posZ - ☃xxx.lastTickPosZ) * ☃;
-         TileEntityRendererDispatcher.staticPlayerX = ☃xxxx;
-         TileEntityRendererDispatcher.staticPlayerY = ☃xxxxx;
-         TileEntityRendererDispatcher.staticPlayerZ = ☃xxxxxx;
-         this.renderManager.setRenderPosition(☃xxxx, ☃xxxxx, ☃xxxxxx);
+            .cacheActiveRenderInfo(this.world, this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.pointedEntity, this.mc.gameSettings, partialTicks);
+         renderEntitiesCounter++;
+         if (pass == 0) {
+            this.countEntitiesTotal = 0;
+            this.countEntitiesRendered = 0;
+            this.countEntitiesHidden = 0;
+            this.countTileEntitiesRendered = 0;
+         }
+
+         Entity entity = this.mc.getRenderViewEntity();
+         double d3 = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * partialTicks;
+         double d4 = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * partialTicks;
+         double d5 = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * partialTicks;
+         TileEntityRendererDispatcher.staticPlayerX = d3;
+         TileEntityRendererDispatcher.staticPlayerY = d4;
+         TileEntityRendererDispatcher.staticPlayerZ = d5;
+         this.renderManager.setRenderPosition(d3, d4, d5);
          this.mc.entityRenderer.enableLightmap();
          this.world.profiler.endStartSection("global");
-         List<Entity> ☃xxxxxxx = this.world.getLoadedEntityList();
-         this.countEntitiesTotal = ☃xxxxxxx.size();
+         List<Entity> list = this.world.getLoadedEntityList();
+         if (pass == 0) {
+            this.countEntitiesTotal = list.size();
+         }
+
+         if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
+            GlStateManager.disableFog();
+         }
+
+         boolean forgeEntityPass = Reflector.ForgeEntity_shouldRenderInPass.exists();
+         boolean forgeTileEntityPass = Reflector.ForgeTileEntity_shouldRenderInPass.exists();
 
-         for (int ☃xxxxxxxx = 0; ☃xxxxxxxx < this.world.weatherEffects.size(); ☃xxxxxxxx++) {
-            Entity ☃xxxxxxxxx = this.world.weatherEffects.get(☃xxxxxxxx);
-            this.countEntitiesRendered++;
-            if (☃xxxxxxxxx.isInRangeToRender3d(☃, ☃x, ☃xx)) {
-               this.renderManager.renderEntityStatic(☃xxxxxxxxx, ☃, false);
+         for (int i = 0; i < this.world.weatherEffects.size(); i++) {
+            Entity entity1 = (Entity)this.world.weatherEffects.get(i);
+            if (!forgeEntityPass || Reflector.callBoolean(entity1, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{pass})) {
+               this.countEntitiesRendered++;
+               if (entity1.isInRangeToRender3d(d0, d1, d2)) {
+                  this.renderManager.renderEntityStatic(entity1, partialTicks, false);
+               }
             }
          }
 
          this.world.profiler.endStartSection("entities");
-         List<Entity> ☃xxxxxxxxx = Lists.newArrayList();
-         List<Entity> ☃xxxxxxxxxx = Lists.newArrayList();
-         BlockPos.PooledMutableBlockPos ☃xxxxxxxxxxx = BlockPos.PooledMutableBlockPos.retain();
-
-         for (RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxxx : this.renderInfos) {
-            Chunk ☃xxxxxxxxxxxxx = this.world.getChunk(☃xxxxxxxxxxxx.renderChunk.getPosition());
-            ClassInheritanceMultiMap<Entity> ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx.getEntityLists()[☃xxxxxxxxxxxx.renderChunk.getPosition().getY() / 16];
-            if (!☃xxxxxxxxxxxxxx.isEmpty()) {
-               for (Entity ☃xxxxxxxxxxxxxxx : ☃xxxxxxxxxxxxxx) {
-                  boolean ☃xxxxxxxxxxxxxxxx = this.renderManager.shouldRender(☃xxxxxxxxxxxxxxx, ☃, ☃, ☃x, ☃xx)
-                     || ☃xxxxxxxxxxxxxxx.isRidingOrBeingRiddenBy(this.mc.player);
-                  if (☃xxxxxxxxxxxxxxxx) {
-                     boolean ☃xxxxxxxxxxxxxxxxx = this.mc.getRenderViewEntity() instanceof EntityLivingBase
-                        ? ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping()
-                        : false;
-                     if ((☃xxxxxxxxxxxxxxx != this.mc.getRenderViewEntity() || this.mc.gameSettings.thirdPersonView != 0 || ☃xxxxxxxxxxxxxxxxx)
-                        && (
-                           !(☃xxxxxxxxxxxxxxx.posY >= 0.0)
-                              || !(☃xxxxxxxxxxxxxxx.posY < 256.0)
-                              || this.world.isBlockLoaded(☃xxxxxxxxxxx.setPos(☃xxxxxxxxxxxxxxx))
-                        )) {
-                        this.countEntitiesRendered++;
-                        this.renderManager.renderEntityStatic(☃xxxxxxxxxxxxxxx, ☃, false);
-                        if (this.isOutlineActive(☃xxxxxxxxxxxxxxx, ☃xxx, ☃)) {
-                           ☃xxxxxxxxx.add(☃xxxxxxxxxxxxxxx);
-                        }
+         boolean isShaders = Config.isShaders();
+         if (isShaders) {
+            Shaders.beginEntities();
+         }
 
-                        if (this.renderManager.isRenderMultipass(☃xxxxxxxxxxxxxxx)) {
-                           ☃xxxxxxxxxx.add(☃xxxxxxxxxxxxxxx);
+         RenderItemFrame.updateItemRenderDistance();
+         List<Entity> list1 = Lists.newArrayList();
+         List<Entity> list2 = Lists.newArrayList();
+         PooledMutableBlockPos blockpos$pooledmutableblockpos = PooledMutableBlockPos.retain();
+         boolean playerShadowPass = Shaders.isShadowPass && !this.mc.player.isSpectator();
+
+         for (RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation : this.renderInfosEntities) {
+            Chunk chunk = renderglobal$containerlocalrenderinformation.renderChunk.getChunk();
+            ClassInheritanceMultiMap<Entity> classinheritancemultimap = chunk.getEntityLists()[renderglobal$containerlocalrenderinformation.renderChunk
+                  .getPosition()
+                  .getY()
+               / 16];
+            if (!classinheritancemultimap.isEmpty()) {
+               for (Entity entity2 : classinheritancemultimap) {
+                  if (!forgeEntityPass || Reflector.callBoolean(entity2, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{pass})) {
+                     boolean flag = this.renderManager.shouldRender(entity2, camera, d0, d1, d2) || entity2.isRidingOrBeingRiddenBy(this.mc.player);
+                     if (flag) {
+                        boolean flag1 = this.mc.getRenderViewEntity() instanceof EntityLivingBase
+                           ? ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping()
+                           : false;
+                        if ((entity2 != this.mc.getRenderViewEntity() || playerShadowPass || this.mc.gameSettings.thirdPersonView != 0 || flag1)
+                           && (entity2.posY < 0.0 || entity2.posY >= 256.0 || this.world.isBlockLoaded(blockpos$pooledmutableblockpos.setPos(entity2)))) {
+                           this.countEntitiesRendered++;
+                           this.renderedEntity = entity2;
+                           if (isShaders) {
+                              Shaders.nextEntity(entity2);
+                           }
+
+                           this.renderManager.renderEntityStatic(entity2, partialTicks, false);
+                           this.renderedEntity = null;
+                           if (this.isOutlineActive(entity2, entity, camera)) {
+                              list1.add(entity2);
+                           }
+
+                           if (this.renderManager.isRenderMultipass(entity2)) {
+                              list2.add(entity2);
+                           }
                         }
                      }
                   }
@@ -546,32 +663,45 @@ public void renderEntities(Entity var1, ICamera var2, float var3) {
             }
          }
 
-         ☃xxxxxxxxxxx.release();
-         if (!☃xxxxxxxxxx.isEmpty()) {
-            for (Entity ☃xxxxxxxxxxxxx : ☃xxxxxxxxxx) {
-               this.renderManager.renderMultipass(☃xxxxxxxxxxxxx, ☃);
+         blockpos$pooledmutableblockpos.release();
+         if (!list2.isEmpty()) {
+            for (Entity entity3 : list2) {
+               if (!forgeEntityPass || Reflector.callBoolean(entity3, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{pass})) {
+                  if (isShaders) {
+                     Shaders.nextEntity(entity3);
+                  }
+
+                  this.renderManager.renderMultipass(entity3, partialTicks);
+               }
             }
          }
 
-         if (this.isRenderEntityOutlines() && (!☃xxxxxxxxx.isEmpty() || this.entityOutlinesRendered)) {
+         if (pass == 0 && this.isRenderEntityOutlines() && (!list1.isEmpty() || this.entityOutlinesRendered)) {
             this.world.profiler.endStartSection("entityOutlines");
             this.entityOutlineFramebuffer.framebufferClear();
-            this.entityOutlinesRendered = !☃xxxxxxxxx.isEmpty();
-            if (!☃xxxxxxxxx.isEmpty()) {
+            this.entityOutlinesRendered = !list1.isEmpty();
+            if (!list1.isEmpty()) {
                GlStateManager.depthFunc(519);
                GlStateManager.disableFog();
                this.entityOutlineFramebuffer.bindFramebuffer(false);
                RenderHelper.disableStandardItemLighting();
                this.renderManager.setRenderOutlines(true);
 
-               for (int ☃xxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxx < ☃xxxxxxxxx.size(); ☃xxxxxxxxxxxxx++) {
-                  this.renderManager.renderEntityStatic(☃xxxxxxxxx.get(☃xxxxxxxxxxxxx), ☃, false);
+               for (int j = 0; j < list1.size(); j++) {
+                  Entity entityOutline = list1.get(j);
+                  if (!forgeEntityPass || Reflector.callBoolean(entityOutline, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{pass})) {
+                     if (isShaders) {
+                        Shaders.nextEntity(entityOutline);
+                     }
+
+                     this.renderManager.renderEntityStatic(entityOutline, partialTicks, false);
+                  }
                }
 
                this.renderManager.setRenderOutlines(false);
                RenderHelper.enableStandardItemLighting();
                GlStateManager.depthMask(false);
-               this.entityOutlineShader.render(☃);
+               this.entityOutlineShader.render(partialTicks);
                GlStateManager.enableLighting();
                GlStateManager.depthMask(true);
                GlStateManager.enableFog();
@@ -585,74 +715,157 @@ public void renderEntities(Entity var1, ICamera var2, float var3) {
             this.mc.getFramebuffer().bindFramebuffer(false);
          }
 
+         if (!this.isRenderEntityOutlines() && (!list1.isEmpty() || this.entityOutlinesRendered)) {
+            this.world.profiler.endStartSection("entityOutlines");
+            this.entityOutlinesRendered = !list1.isEmpty();
+            if (!list1.isEmpty()) {
+               if (isShaders) {
+                  Shaders.beginEntitiesGlowing();
+               }
+
+               GlStateManager.disableFog();
+               GlStateManager.disableDepth();
+               this.mc.entityRenderer.disableLightmap();
+               RenderHelper.disableStandardItemLighting();
+               this.renderManager.setRenderOutlines(true);
+
+               for (int jx = 0; jx < list1.size(); jx++) {
+                  Entity entityOutline = list1.get(jx);
+                  if (!forgeEntityPass || Reflector.callBoolean(entityOutline, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{pass})) {
+                     if (isShaders) {
+                        Shaders.nextEntity(entityOutline);
+                     }
+
+                     this.renderManager.renderEntityStatic(entityOutline, partialTicks, false);
+                  }
+               }
+
+               this.renderManager.setRenderOutlines(false);
+               RenderHelper.enableStandardItemLighting();
+               this.mc.entityRenderer.enableLightmap();
+               GlStateManager.enableDepth();
+               GlStateManager.enableFog();
+               if (isShaders) {
+                  Shaders.endEntitiesGlowing();
+               }
+            }
+         }
+
+         if (isShaders) {
+            Shaders.endEntities();
+            Shaders.beginBlockEntities();
+         }
+
          this.world.profiler.endStartSection("blockentities");
          RenderHelper.enableStandardItemLighting();
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            TileEntityRendererDispatcher.instance.preDrawBatch();
+         }
+
+         TileEntitySignRenderer.updateTextRenderDistance();
 
-         for (RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxxxx : this.renderInfos) {
-            List<TileEntity> ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx.renderChunk.getCompiledChunk().getTileEntities();
-            if (!☃xxxxxxxxxxxxxx.isEmpty()) {
-               for (TileEntity ☃xxxxxxxxxxxxxxxx : ☃xxxxxxxxxxxxxx) {
-                  TileEntityRendererDispatcher.instance.render(☃xxxxxxxxxxxxxxxx, ☃, -1);
+         for (RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation1 : this.renderInfosTileEntities) {
+            List<TileEntity> list3 = renderglobal$containerlocalrenderinformation1.renderChunk.getCompiledChunk().getTileEntities();
+            if (!list3.isEmpty()) {
+               for (TileEntity tileentity2 : list3) {
+                  if (forgeTileEntityPass) {
+                     if (!Reflector.callBoolean(tileentity2, Reflector.ForgeTileEntity_shouldRenderInPass, new Object[]{pass})) {
+                        continue;
+                     }
+
+                     AxisAlignedBB aabb = (AxisAlignedBB)Reflector.call(tileentity2, Reflector.ForgeTileEntity_getRenderBoundingBox, new Object[0]);
+                     if (aabb != null && !camera.isBoundingBoxInFrustum(aabb)) {
+                        continue;
+                     }
+                  }
+
+                  if (isShaders) {
+                     Shaders.nextBlockEntity(tileentity2);
+                  }
+
+                  TileEntityRendererDispatcher.instance.render(tileentity2, partialTicks, -1);
+                  this.countTileEntitiesRendered++;
                }
             }
          }
 
          synchronized (this.setTileEntities) {
-            for (TileEntity ☃xxxxxxxxxxxxxx : this.setTileEntities) {
-               TileEntityRendererDispatcher.instance.render(☃xxxxxxxxxxxxxx, ☃, -1);
+            for (TileEntity tileentity : this.setTileEntities) {
+               if (!forgeTileEntityPass || Reflector.callBoolean(tileentity, Reflector.ForgeTileEntity_shouldRenderInPass, new Object[]{pass})) {
+                  if (isShaders) {
+                     Shaders.nextBlockEntity(tileentity);
+                  }
+
+                  TileEntityRendererDispatcher.instance.render(tileentity, partialTicks, -1);
+               }
             }
          }
 
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            TileEntityRendererDispatcher.instance.drawBatch(pass);
+         }
+
+         this.renderOverlayDamaged = true;
          this.preRenderDamagedBlocks();
 
-         for (DestroyBlockProgress ☃xxxxxxxxxxxxxx : this.damagedBlocks.values()) {
-            BlockPos ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxx.getPosition();
-            if (this.world.getBlockState(☃xxxxxxxxxxxxxxxx).getBlock().hasTileEntity()) {
-               TileEntity ☃xxxxxxxxxxxxxxxxx = this.world.getTileEntity(☃xxxxxxxxxxxxxxxx);
-               if (☃xxxxxxxxxxxxxxxxx instanceof TileEntityChest) {
-                  TileEntityChest ☃xxxxxxxxxxxxxxxxxx = (TileEntityChest)☃xxxxxxxxxxxxxxxxx;
-                  if (☃xxxxxxxxxxxxxxxxxx.adjacentChestXNeg != null) {
-                     ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx.offset(EnumFacing.WEST);
-                     ☃xxxxxxxxxxxxxxxxx = this.world.getTileEntity(☃xxxxxxxxxxxxxxxx);
-                  } else if (☃xxxxxxxxxxxxxxxxxx.adjacentChestZNeg != null) {
-                     ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx.offset(EnumFacing.NORTH);
-                     ☃xxxxxxxxxxxxxxxxx = this.world.getTileEntity(☃xxxxxxxxxxxxxxxx);
+         for (DestroyBlockProgress destroyblockprogress : this.damagedBlocks.values()) {
+            BlockPos blockpos = destroyblockprogress.getPosition();
+            if (this.world.getBlockState(blockpos).getBlock().hasTileEntity()) {
+               TileEntity tileentity1 = this.world.getTileEntity(blockpos);
+               if (tileentity1 instanceof TileEntityChest) {
+                  TileEntityChest tileentitychest = (TileEntityChest)tileentity1;
+                  if (tileentitychest.adjacentChestXNeg != null) {
+                     blockpos = blockpos.offset(EnumFacing.WEST);
+                     tileentity1 = this.world.getTileEntity(blockpos);
+                  } else if (tileentitychest.adjacentChestZNeg != null) {
+                     blockpos = blockpos.offset(EnumFacing.NORTH);
+                     tileentity1 = this.world.getTileEntity(blockpos);
                   }
                }
 
-               IBlockState ☃xxxxxxxxxxxxxxxxxx = this.world.getBlockState(☃xxxxxxxxxxxxxxxx);
-               if (☃xxxxxxxxxxxxxxxxx != null && ☃xxxxxxxxxxxxxxxxxx.hasCustomBreakingProgress()) {
-                  TileEntityRendererDispatcher.instance.render(☃xxxxxxxxxxxxxxxxx, ☃, ☃xxxxxxxxxxxxxx.getPartialBlockDamage());
+               IBlockState iblockstate = this.world.getBlockState(blockpos);
+               if (tileentity1 != null && iblockstate.h()) {
+                  if (isShaders) {
+                     Shaders.nextBlockEntity(tileentity1);
+                  }
+
+                  TileEntityRendererDispatcher.instance.render(tileentity1, partialTicks, destroyblockprogress.getPartialBlockDamage());
                }
             }
          }
 
          this.postRenderDamagedBlocks();
+         this.renderOverlayDamaged = false;
+         if (isShaders) {
+            Shaders.endBlockEntities();
+         }
+
+         renderEntitiesCounter--;
          this.mc.entityRenderer.disableLightmap();
          this.mc.profiler.endSection();
       }
    }
 
-   private boolean isOutlineActive(Entity var1, Entity var2, ICamera var3) {
-      boolean ☃ = ☃ instanceof EntityLivingBase && ((EntityLivingBase)☃).isPlayerSleeping();
-      if (☃ == ☃ && this.mc.gameSettings.thirdPersonView == 0 && !☃) {
+   private boolean isOutlineActive(Entity entityIn, Entity viewer, ICamera camera) {
+      boolean flag = viewer instanceof EntityLivingBase && ((EntityLivingBase)viewer).isPlayerSleeping();
+      if (entityIn == viewer && this.mc.gameSettings.thirdPersonView == 0 && !flag) {
          return false;
-      } else if (☃.isGlowing()) {
+      } else if (entityIn.isGlowing()) {
          return true;
       } else {
-         return this.mc.player.isSpectator() && this.mc.gameSettings.keyBindSpectatorOutlines.isKeyDown() && ☃ instanceof EntityPlayer
-            ? ☃.ignoreFrustumCheck || ☃.isBoundingBoxInFrustum(☃.getEntityBoundingBox()) || ☃.isRidingOrBeingRiddenBy(this.mc.player)
+         return this.mc.player.isSpectator() && this.mc.gameSettings.keyBindSpectatorOutlines.isKeyDown() && entityIn instanceof EntityPlayer
+            ? entityIn.ignoreFrustumCheck || camera.isBoundingBoxInFrustum(entityIn.getEntityBoundingBox()) || entityIn.isRidingOrBeingRiddenBy(this.mc.player)
             : false;
       }
    }
 
    public String getDebugInfoRenders() {
-      int ☃ = this.viewFrustum.renderChunks.length;
-      int ☃x = this.getRenderedChunks();
+      int i = this.viewFrustum.renderChunks.length;
+      int j = this.getRenderedChunks();
       return String.format(
          "C: %d/%d %sD: %d, L: %d, %s",
-         ☃x,
-         ☃,
+         j,
+         i,
          this.mc.renderChunksMany ? "(s) " : "",
          this.renderDistanceChunks,
          this.setLightUpdates.size(),
@@ -661,143 +874,214 @@ public String getDebugInfoRenders() {
    }
 
    protected int getRenderedChunks() {
-      int ☃ = 0;
+      int i = 0;
 
-      for (RenderGlobal.ContainerLocalRenderInformation ☃x : this.renderInfos) {
-         CompiledChunk ☃xx = ☃x.renderChunk.compiledChunk;
-         if (☃xx != CompiledChunk.DUMMY && !☃xx.isEmpty()) {
-            ☃++;
+      for (RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation : this.renderInfos) {
+         CompiledChunk compiledchunk = renderglobal$containerlocalrenderinformation.renderChunk.compiledChunk;
+         if (compiledchunk != CompiledChunk.DUMMY && !compiledchunk.isEmpty()) {
+            i++;
          }
       }
 
-      return ☃;
+      return i;
    }
 
    public String getDebugInfoEntities() {
-      return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden;
+      return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden + ", " + Config.getVersionDebug();
    }
 
-   public void setupTerrain(Entity var1, double var2, ICamera var4, int var5, boolean var6) {
+   public void setupTerrain(Entity viewEntity, double partialTicks, ICamera camera, int frameCount, boolean playerSpectator) {
       if (this.mc.gameSettings.renderDistanceChunks != this.renderDistanceChunks) {
          this.loadRenderers();
       }
 
       this.world.profiler.startSection("camera");
-      double ☃ = ☃.posX - this.frustumUpdatePosX;
-      double ☃x = ☃.posY - this.frustumUpdatePosY;
-      double ☃xx = ☃.posZ - this.frustumUpdatePosZ;
-      if (this.frustumUpdatePosChunkX != ☃.chunkCoordX
-         || this.frustumUpdatePosChunkY != ☃.chunkCoordY
-         || this.frustumUpdatePosChunkZ != ☃.chunkCoordZ
-         || ☃ * ☃ + ☃x * ☃x + ☃xx * ☃xx > 16.0) {
-         this.frustumUpdatePosX = ☃.posX;
-         this.frustumUpdatePosY = ☃.posY;
-         this.frustumUpdatePosZ = ☃.posZ;
-         this.frustumUpdatePosChunkX = ☃.chunkCoordX;
-         this.frustumUpdatePosChunkY = ☃.chunkCoordY;
-         this.frustumUpdatePosChunkZ = ☃.chunkCoordZ;
-         this.viewFrustum.updateChunkPositions(☃.posX, ☃.posZ);
+      double d0 = viewEntity.posX - this.frustumUpdatePosX;
+      double d1 = viewEntity.posY - this.frustumUpdatePosY;
+      double d2 = viewEntity.posZ - this.frustumUpdatePosZ;
+      if (this.frustumUpdatePosChunkX != viewEntity.chunkCoordX
+         || this.frustumUpdatePosChunkY != viewEntity.chunkCoordY
+         || this.frustumUpdatePosChunkZ != viewEntity.chunkCoordZ
+         || d0 * d0 + d1 * d1 + d2 * d2 > 16.0) {
+         this.frustumUpdatePosX = viewEntity.posX;
+         this.frustumUpdatePosY = viewEntity.posY;
+         this.frustumUpdatePosZ = viewEntity.posZ;
+         this.frustumUpdatePosChunkX = viewEntity.chunkCoordX;
+         this.frustumUpdatePosChunkY = viewEntity.chunkCoordY;
+         this.frustumUpdatePosChunkZ = viewEntity.chunkCoordZ;
+         this.viewFrustum.updateChunkPositions(viewEntity.posX, viewEntity.posZ);
+      }
+
+      if (Config.isDynamicLights()) {
+         DynamicLights.update(this);
       }
 
       this.world.profiler.endStartSection("renderlistcamera");
-      double ☃xxx = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃xxxx = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xxxxx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      this.renderContainer.initialize(☃xxx, ☃xxxx, ☃xxxxx);
+      double d3 = viewEntity.lastTickPosX + (viewEntity.posX - viewEntity.lastTickPosX) * partialTicks;
+      double d4 = viewEntity.lastTickPosY + (viewEntity.posY - viewEntity.lastTickPosY) * partialTicks;
+      double d5 = viewEntity.lastTickPosZ + (viewEntity.posZ - viewEntity.lastTickPosZ) * partialTicks;
+      this.renderContainer.initialize(d3, d4, d5);
       this.world.profiler.endStartSection("cull");
       if (this.debugFixedClippingHelper != null) {
-         Frustum ☃xxxxxx = new Frustum(this.debugFixedClippingHelper);
-         ☃xxxxxx.setPosition(this.debugTerrainFrustumPosition.x, this.debugTerrainFrustumPosition.y, this.debugTerrainFrustumPosition.z);
-         ☃ = ☃xxxxxx;
+         Frustum frustum = new Frustum(this.debugFixedClippingHelper);
+         frustum.setPosition(this.debugTerrainFrustumPosition.x, this.debugTerrainFrustumPosition.y, this.debugTerrainFrustumPosition.z);
+         camera = frustum;
       }
 
       this.mc.profiler.endStartSection("culling");
-      BlockPos ☃xxxxxx = new BlockPos(☃xxx, ☃xxxx + ☃.getEyeHeight(), ☃xxxxx);
-      RenderChunk ☃xxxxxxx = this.viewFrustum.getRenderChunk(☃xxxxxx);
-      BlockPos ☃xxxxxxxx = new BlockPos(MathHelper.floor(☃xxx / 16.0) * 16, MathHelper.floor(☃xxxx / 16.0) * 16, MathHelper.floor(☃xxxxx / 16.0) * 16);
+      BlockPos blockpos1 = new BlockPos(d3, d4 + viewEntity.getEyeHeight(), d5);
+      RenderChunk renderchunk = this.viewFrustum.getRenderChunk(blockpos1);
+      new BlockPos(MathHelper.floor(d3 / 16.0) * 16, MathHelper.floor(d4 / 16.0) * 16, MathHelper.floor(d5 / 16.0) * 16);
       this.displayListEntitiesDirty = this.displayListEntitiesDirty
          || !this.chunksToUpdate.isEmpty()
-         || ☃.posX != this.lastViewEntityX
-         || ☃.posY != this.lastViewEntityY
-         || ☃.posZ != this.lastViewEntityZ
-         || ☃.rotationPitch != this.lastViewEntityPitch
-         || ☃.rotationYaw != this.lastViewEntityYaw;
-      this.lastViewEntityX = ☃.posX;
-      this.lastViewEntityY = ☃.posY;
-      this.lastViewEntityZ = ☃.posZ;
-      this.lastViewEntityPitch = ☃.rotationPitch;
-      this.lastViewEntityYaw = ☃.rotationYaw;
-      boolean ☃xxxxxxxxx = this.debugFixedClippingHelper != null;
+         || viewEntity.posX != this.lastViewEntityX
+         || viewEntity.posY != this.lastViewEntityY
+         || viewEntity.posZ != this.lastViewEntityZ
+         || viewEntity.rotationPitch != this.lastViewEntityPitch
+         || viewEntity.rotationYaw != this.lastViewEntityYaw;
+      this.lastViewEntityX = viewEntity.posX;
+      this.lastViewEntityY = viewEntity.posY;
+      this.lastViewEntityZ = viewEntity.posZ;
+      this.lastViewEntityPitch = viewEntity.rotationPitch;
+      this.lastViewEntityYaw = viewEntity.rotationYaw;
+      boolean flag = this.debugFixedClippingHelper != null;
       this.mc.profiler.endStartSection("update");
-      if (!☃xxxxxxxxx && this.displayListEntitiesDirty) {
+      Lagometer.timerVisibility.start();
+      int countLoadedChunks = this.getCountLoadedChunks();
+      if (countLoadedChunks != this.countLoadedChunksPrev) {
+         this.countLoadedChunksPrev = countLoadedChunks;
+         this.displayListEntitiesDirty = true;
+      }
+
+      int maxChunkY = 256;
+      if (!ChunkVisibility.isFinished()) {
+         this.displayListEntitiesDirty = true;
+      }
+
+      if (!flag && this.displayListEntitiesDirty && Config.isIntegratedServerRunning()) {
+         maxChunkY = ChunkVisibility.getMaxChunkY(this.world, viewEntity, this.renderDistanceChunks);
+      }
+
+      RenderChunk renderChunkPlayer = this.viewFrustum.getRenderChunk(new BlockPos(viewEntity.posX, viewEntity.posY, viewEntity.posZ));
+      if (Shaders.isShadowPass) {
+         this.renderInfos = this.renderInfosShadow;
+         this.renderInfosEntities = this.renderInfosEntitiesShadow;
+         this.renderInfosTileEntities = this.renderInfosTileEntitiesShadow;
+         if (!flag && this.displayListEntitiesDirty) {
+            this.clearRenderInfos();
+            if (renderChunkPlayer != null && renderChunkPlayer.getPosition().getY() > maxChunkY) {
+               this.renderInfosEntities.add(renderChunkPlayer.getRenderInfo());
+            }
+
+            Iterator<RenderChunk> it = ShadowUtils.makeShadowChunkIterator(this.world, partialTicks, viewEntity, this.renderDistanceChunks, this.viewFrustum);
+
+            while (it.hasNext()) {
+               RenderChunk chunk = it.next();
+               if (chunk != null && chunk.getPosition().getY() <= maxChunkY) {
+                  RenderGlobal.ContainerLocalRenderInformation renderInfo = chunk.getRenderInfo();
+                  if (!chunk.compiledChunk.isEmpty()) {
+                     this.renderInfos.add(renderInfo);
+                  }
+
+                  if (ChunkUtils.hasEntities(chunk.getChunk())) {
+                     this.renderInfosEntities.add(renderInfo);
+                  }
+
+                  if (chunk.getCompiledChunk().getTileEntities().size() > 0) {
+                     this.renderInfosTileEntities.add(renderInfo);
+                  }
+               }
+            }
+         }
+      } else {
+         this.renderInfos = this.renderInfosNormal;
+         this.renderInfosEntities = this.renderInfosEntitiesNormal;
+         this.renderInfosTileEntities = this.renderInfosTileEntitiesNormal;
+      }
+
+      if (!flag && this.displayListEntitiesDirty && !Shaders.isShadowPass) {
          this.displayListEntitiesDirty = false;
-         this.renderInfos = Lists.newArrayList();
-         Queue<RenderGlobal.ContainerLocalRenderInformation> ☃xxxxxxxxxx = Queues.newArrayDeque();
+         this.clearRenderInfos();
+         this.visibilityDeque.clear();
+         Deque queue = this.visibilityDeque;
          Entity.setRenderDistanceWeight(MathHelper.clamp(this.mc.gameSettings.renderDistanceChunks / 8.0, 1.0, 2.5));
-         boolean ☃xxxxxxxxxxx = this.mc.renderChunksMany;
-         if (☃xxxxxxx != null) {
-            boolean ☃xxxxxxxxxxxx = false;
-            RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxxxx = new RenderGlobal.ContainerLocalRenderInformation(☃xxxxxxx, null, 0);
-            Set<EnumFacing> ☃xxxxxxxxxxxxxx = this.getVisibleFacings(☃xxxxxx);
-            if (☃xxxxxxxxxxxxxx.size() == 1) {
-               Vector3f ☃xxxxxxxxxxxxxxx = this.getViewVector(☃, ☃);
-               EnumFacing ☃xxxxxxxxxxxxxxxx = EnumFacing.getFacingFromVector(☃xxxxxxxxxxxxxxx.x, ☃xxxxxxxxxxxxxxx.y, ☃xxxxxxxxxxxxxxx.z).getOpposite();
-               ☃xxxxxxxxxxxxxx.remove(☃xxxxxxxxxxxxxxxx);
+         boolean flag1 = this.mc.renderChunksMany;
+         if (renderchunk != null && renderchunk.getPosition().getY() <= maxChunkY) {
+            boolean flag2 = false;
+            RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation3 = new RenderGlobal.ContainerLocalRenderInformation(
+               renderchunk, (EnumFacing)null, 0
+            );
+            Set set1 = SET_ALL_FACINGS;
+            if (set1.size() == 1) {
+               Vector3f vector3f = this.getViewVector(viewEntity, partialTicks);
+               EnumFacing enumfacing = EnumFacing.getFacingFromVector(vector3f.x, vector3f.y, vector3f.z).getOpposite();
+               set1.remove(enumfacing);
             }
 
-            if (☃xxxxxxxxxxxxxx.isEmpty()) {
-               ☃xxxxxxxxxxxx = true;
+            if (set1.isEmpty()) {
+               flag2 = true;
             }
 
-            if (☃xxxxxxxxxxxx && !☃) {
-               this.renderInfos.add(☃xxxxxxxxxxxxx);
+            if (flag2 && !playerSpectator) {
+               this.renderInfos.add(renderglobal$containerlocalrenderinformation3);
             } else {
-               if (☃ && this.world.getBlockState(☃xxxxxx).isOpaqueCube()) {
-                  ☃xxxxxxxxxxx = false;
+               if (playerSpectator && this.world.getBlockState(blockpos1).p()) {
+                  flag1 = false;
                }
 
-               ☃xxxxxxx.setFrameIndex(☃);
-               ☃xxxxxxxxxx.add(☃xxxxxxxxxxxxx);
+               renderchunk.setFrameIndex(frameCount);
+               queue.add(renderglobal$containerlocalrenderinformation3);
             }
          } else {
-            int ☃xxxxxxxxxxxxxxx = ☃xxxxxx.getY() > 0 ? 248 : 8;
-
-            for (int ☃xxxxxxxxxxxxxxxx = -this.renderDistanceChunks; ☃xxxxxxxxxxxxxxxx <= this.renderDistanceChunks; ☃xxxxxxxxxxxxxxxx++) {
-               for (int ☃xxxxxxxxxxxxxxxxx = -this.renderDistanceChunks; ☃xxxxxxxxxxxxxxxxx <= this.renderDistanceChunks; ☃xxxxxxxxxxxxxxxxx++) {
-                  RenderChunk ☃xxxxxxxxxxxxxxxxxx = this.viewFrustum
-                     .getRenderChunk(new BlockPos((☃xxxxxxxxxxxxxxxx << 4) + 8, ☃xxxxxxxxxxxxxxx, (☃xxxxxxxxxxxxxxxxx << 4) + 8));
-                  if (☃xxxxxxxxxxxxxxxxxx != null && ☃.isBoundingBoxInFrustum(☃xxxxxxxxxxxxxxxxxx.boundingBox)) {
-                     ☃xxxxxxxxxxxxxxxxxx.setFrameIndex(☃);
-                     ☃xxxxxxxxxx.add(new RenderGlobal.ContainerLocalRenderInformation(☃xxxxxxxxxxxxxxxxxx, null, 0));
+            int i = blockpos1.getY() > 0 ? Math.min(maxChunkY, 248) : 8;
+            if (renderChunkPlayer != null) {
+               this.renderInfosEntities.add(renderChunkPlayer.getRenderInfo());
+            }
+
+            for (int j = -this.renderDistanceChunks; j <= this.renderDistanceChunks; j++) {
+               for (int k = -this.renderDistanceChunks; k <= this.renderDistanceChunks; k++) {
+                  RenderChunk renderchunk1 = this.viewFrustum.getRenderChunk(new BlockPos((j << 4) + 8, i, (k << 4) + 8));
+                  if (renderchunk1 != null && renderchunk1.isBoundingBoxInFrustum(camera, frameCount)) {
+                     renderchunk1.setFrameIndex(frameCount);
+                     RenderGlobal.ContainerLocalRenderInformation info = renderchunk1.getRenderInfo();
+                     info.initialize(null, 0);
+                     queue.add(info);
                   }
                }
             }
          }
 
          this.mc.profiler.startSection("iteration");
+         boolean fog = Config.isFogOn();
+
+         while (!queue.isEmpty()) {
+            RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation1 = (RenderGlobal.ContainerLocalRenderInformation)queue.poll();
+            RenderChunk renderchunk3 = renderglobal$containerlocalrenderinformation1.renderChunk;
+            EnumFacing enumfacing2 = renderglobal$containerlocalrenderinformation1.facing;
+            CompiledChunk compiledChunk3 = renderchunk3.compiledChunk;
+            if (!compiledChunk3.isEmpty() || renderchunk3.needsUpdate()) {
+               this.renderInfos.add(renderglobal$containerlocalrenderinformation1);
+            }
 
-         while (!☃xxxxxxxxxx.isEmpty()) {
-            RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxx.poll();
-            RenderChunk ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx.renderChunk;
-            EnumFacing ☃xxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx.facing;
-            this.renderInfos.add(☃xxxxxxxxxxxxxxx);
-
-            for (EnumFacing ☃xxxxxxxxxxxxxxxxxxx : EnumFacing.values()) {
-               RenderChunk ☃xxxxxxxxxxxxxxxxxxxx = this.getRenderChunkOffset(☃xxxxxxxx, ☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx);
-               if ((!☃xxxxxxxxxxx || !☃xxxxxxxxxxxxxxx.hasDirection(☃xxxxxxxxxxxxxxxxxxx.getOpposite()))
-                  && (
-                     !☃xxxxxxxxxxx
-                        || ☃xxxxxxxxxxxxxxxxxx == null
-                        || ☃xxxxxxxxxxxxxxxx.getCompiledChunk().isVisible(☃xxxxxxxxxxxxxxxxxx.getOpposite(), ☃xxxxxxxxxxxxxxxxxxx)
-                  )
-                  && ☃xxxxxxxxxxxxxxxxxxxx != null
-                  && ☃xxxxxxxxxxxxxxxxxxxx.setFrameIndex(☃)
-                  && ☃.isBoundingBoxInFrustum(☃xxxxxxxxxxxxxxxxxxxx.boundingBox)) {
-                  RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxxxxxxxxxxxx = new RenderGlobal.ContainerLocalRenderInformation(
-                     ☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx.counter + 1
-                  );
-                  ☃xxxxxxxxxxxxxxxxxxxxx.setDirection(☃xxxxxxxxxxxxxxx.setFacing, ☃xxxxxxxxxxxxxxxxxxx);
-                  ☃xxxxxxxxxx.add(☃xxxxxxxxxxxxxxxxxxxxx);
+            if (ChunkUtils.hasEntities(renderchunk3.getChunk())) {
+               this.renderInfosEntities.add(renderglobal$containerlocalrenderinformation1);
+            }
+
+            if (compiledChunk3.getTileEntities().size() > 0) {
+               this.renderInfosTileEntities.add(renderglobal$containerlocalrenderinformation1);
+            }
+
+            for (EnumFacing enumfacing1 : flag1
+               ? ChunkVisibility.getFacingsNotOpposite(renderglobal$containerlocalrenderinformation1.setFacing)
+               : EnumFacing.VALUES) {
+               if (!flag1 || enumfacing2 == null || compiledChunk3.isVisible(enumfacing2.getOpposite(), enumfacing1)) {
+                  RenderChunk renderchunk2 = this.getRenderChunkOffset(blockpos1, renderchunk3, enumfacing1, fog, maxChunkY);
+                  if (renderchunk2 != null && renderchunk2.setFrameIndex(frameCount) && renderchunk2.isBoundingBoxInFrustum(camera, frameCount)) {
+                     int setFacing = renderglobal$containerlocalrenderinformation1.setFacing | 1 << enumfacing1.ordinal();
+                     RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation = renderchunk2.getRenderInfo();
+                     renderglobal$containerlocalrenderinformation.initialize(enumfacing1, setFacing);
+                     queue.add(renderglobal$containerlocalrenderinformation);
+                  }
                }
             }
          }
@@ -807,74 +1091,95 @@ public void setupTerrain(Entity var1, double var2, ICamera var4, int var5, boole
 
       this.mc.profiler.endStartSection("captureFrustum");
       if (this.debugFixTerrainFrustum) {
-         this.fixTerrainFrustum(☃xxx, ☃xxxx, ☃xxxxx);
+         this.fixTerrainFrustum(d3, d4, d5);
          this.debugFixTerrainFrustum = false;
       }
 
-      this.mc.profiler.endStartSection("rebuildNear");
-      Set<RenderChunk> ☃xxxxxxxxxx = this.chunksToUpdate;
-      this.chunksToUpdate = Sets.newLinkedHashSet();
-
-      for (RenderGlobal.ContainerLocalRenderInformation ☃xxxxxxxxxxx : this.renderInfos) {
-         RenderChunk ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxx.renderChunk;
-         if (☃xxxxxxxxxxxxxxx.needsUpdate() || ☃xxxxxxxxxx.contains(☃xxxxxxxxxxxxxxx)) {
-            this.displayListEntitiesDirty = true;
-            BlockPos ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx.getPosition().add(8, 8, 8);
-            boolean ☃xxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx.distanceSq(☃xxxxxx) < 768.0;
-            if (!☃xxxxxxxxxxxxxxx.needsImmediateUpdate() && !☃xxxxxxxxxxxxxxxxxx) {
-               this.chunksToUpdate.add(☃xxxxxxxxxxxxxxx);
-            } else {
-               this.mc.profiler.startSection("build near");
-               this.renderDispatcher.updateChunkNow(☃xxxxxxxxxxxxxxx);
-               ☃xxxxxxxxxxxxxxx.clearNeedsUpdate();
-               this.mc.profiler.endSection();
+      Lagometer.timerVisibility.end();
+      if (Shaders.isShadowPass) {
+         Shaders.mcProfilerEndSection();
+      } else {
+         this.mc.profiler.endStartSection("rebuildNear");
+         Set<RenderChunk> set = this.chunksToUpdate;
+         this.chunksToUpdate = this.chunksToUpdatePrev;
+         this.chunksToUpdatePrev = set;
+         this.chunksToUpdate.clear();
+         Lagometer.timerChunkUpdate.start();
+
+         for (RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation2 : this.renderInfos) {
+            RenderChunk renderchunk4 = renderglobal$containerlocalrenderinformation2.renderChunk;
+            if (renderchunk4.needsUpdate() || set.contains(renderchunk4)) {
+               this.displayListEntitiesDirty = true;
+               BlockPos posChunk = renderchunk4.getPosition();
+               boolean flag3 = blockpos1.distanceSq(posChunk.getX() + 8, posChunk.getY() + 8, posChunk.getZ() + 8) < 768.0;
+               if (!flag3) {
+                  this.chunksToUpdate.add(renderchunk4);
+               } else if (!renderchunk4.isPlayerUpdate()) {
+                  this.chunksToUpdateForced.add(renderchunk4);
+               } else {
+                  this.mc.profiler.startSection("build near");
+                  this.renderDispatcher.updateChunkNow(renderchunk4);
+                  renderchunk4.clearNeedsUpdate();
+                  this.mc.profiler.endSection();
+               }
             }
          }
-      }
 
-      this.chunksToUpdate.addAll(☃xxxxxxxxxx);
-      this.mc.profiler.endSection();
+         Lagometer.timerChunkUpdate.end();
+         this.chunksToUpdate.addAll(set);
+         this.mc.profiler.endSection();
+      }
    }
 
-   private Set<EnumFacing> getVisibleFacings(BlockPos var1) {
-      VisGraph ☃ = new VisGraph();
-      BlockPos ☃x = new BlockPos(☃.getX() >> 4 << 4, ☃.getY() >> 4 << 4, ☃.getZ() >> 4 << 4);
-      Chunk ☃xx = this.world.getChunk(☃x);
+   private Set<EnumFacing> getVisibleFacings(BlockPos pos) {
+      VisGraph visgraph = new VisGraph();
+      BlockPos blockpos = new BlockPos(pos.getX() >> 4 << 4, pos.getY() >> 4 << 4, pos.getZ() >> 4 << 4);
+      Chunk chunk = this.world.getChunk(blockpos);
 
-      for (BlockPos.MutableBlockPos ☃xxx : BlockPos.getAllInBoxMutable(☃x, ☃x.add(15, 15, 15))) {
-         if (☃xx.getBlockState(☃xxx).isOpaqueCube()) {
-            ☃.setOpaqueCube(☃xxx);
+      for (MutableBlockPos blockpos$mutableblockpos : BlockPos.getAllInBoxMutable(blockpos, blockpos.add(15, 15, 15))) {
+         if (chunk.getBlockState(blockpos$mutableblockpos).p()) {
+            visgraph.setOpaqueCube(blockpos$mutableblockpos);
          }
       }
 
-      return ☃.getVisibleFacings(☃);
+      return visgraph.getVisibleFacings(pos);
    }
 
    @Nullable
-   private RenderChunk getRenderChunkOffset(BlockPos var1, RenderChunk var2, EnumFacing var3) {
-      BlockPos ☃ = ☃.getBlockPosOffset16(☃);
-      if (MathHelper.abs(☃.getX() - ☃.getX()) > this.renderDistanceChunks * 16) {
+   private RenderChunk getRenderChunkOffset(BlockPos playerPos, RenderChunk renderChunkBase, EnumFacing facing, boolean fog, int yMax) {
+      RenderChunk neighbour = renderChunkBase.getRenderChunkNeighbour(facing);
+      if (neighbour == null) {
          return null;
-      } else if (☃.getY() < 0 || ☃.getY() >= 256) {
+      } else if (neighbour.getPosition().getY() > yMax) {
          return null;
       } else {
-         return MathHelper.abs(☃.getZ() - ☃.getZ()) > this.renderDistanceChunks * 16 ? null : this.viewFrustum.getRenderChunk(☃);
+         if (fog) {
+            BlockPos var4x = neighbour.getPosition();
+            int dxs = playerPos.getX() - var4x.getX();
+            int dzs = playerPos.getZ() - var4x.getZ();
+            int distSq = dxs * dxs + dzs * dzs;
+            if (distSq > this.renderDistanceSq) {
+               return null;
+            }
+         }
+
+         return neighbour;
       }
    }
 
-   private void fixTerrainFrustum(double var1, double var3, double var5) {
+   private void fixTerrainFrustum(double x, double y, double z) {
       this.debugFixedClippingHelper = new ClippingHelperImpl();
       ((ClippingHelperImpl)this.debugFixedClippingHelper).init();
-      Matrix4f ☃ = new Matrix4f(this.debugFixedClippingHelper.modelviewMatrix);
-      ☃.transpose();
-      Matrix4f ☃x = new Matrix4f(this.debugFixedClippingHelper.projectionMatrix);
-      ☃x.transpose();
-      Matrix4f ☃xx = new Matrix4f();
-      Matrix4f.mul(☃x, ☃, ☃xx);
-      ☃xx.invert();
-      this.debugTerrainFrustumPosition.x = ☃;
-      this.debugTerrainFrustumPosition.y = ☃;
-      this.debugTerrainFrustumPosition.z = ☃;
+      Matrix4f matrix4f = new Matrix4f(this.debugFixedClippingHelper.modelviewMatrix);
+      matrix4f.transpose();
+      Matrix4f matrix4f1 = new Matrix4f(this.debugFixedClippingHelper.projectionMatrix);
+      matrix4f1.transpose();
+      Matrix4f matrix4f2 = new Matrix4f();
+      Matrix4f.mul(matrix4f1, matrix4f, matrix4f2);
+      matrix4f2.invert();
+      this.debugTerrainFrustumPosition.x = x;
+      this.debugTerrainFrustumPosition.y = y;
+      this.debugTerrainFrustumPosition.z = z;
       this.debugTerrainMatrix[0] = new Vector4f(-1.0F, -1.0F, -1.0F, 1.0F);
       this.debugTerrainMatrix[1] = new Vector4f(1.0F, -1.0F, -1.0F, 1.0F);
       this.debugTerrainMatrix[2] = new Vector4f(1.0F, 1.0F, -1.0F, 1.0F);
@@ -884,45 +1189,46 @@ private void fixTerrainFrustum(double var1, double var3, double var5) {
       this.debugTerrainMatrix[6] = new Vector4f(1.0F, 1.0F, 1.0F, 1.0F);
       this.debugTerrainMatrix[7] = new Vector4f(-1.0F, 1.0F, 1.0F, 1.0F);
 
-      for (int ☃xxx = 0; ☃xxx < 8; ☃xxx++) {
-         Matrix4f.transform(☃xx, this.debugTerrainMatrix[☃xxx], this.debugTerrainMatrix[☃xxx]);
-         this.debugTerrainMatrix[☃xxx].x = this.debugTerrainMatrix[☃xxx].x / this.debugTerrainMatrix[☃xxx].w;
-         this.debugTerrainMatrix[☃xxx].y = this.debugTerrainMatrix[☃xxx].y / this.debugTerrainMatrix[☃xxx].w;
-         this.debugTerrainMatrix[☃xxx].z = this.debugTerrainMatrix[☃xxx].z / this.debugTerrainMatrix[☃xxx].w;
-         this.debugTerrainMatrix[☃xxx].w = 1.0F;
+      for (int i = 0; i < 8; i++) {
+         Matrix4f.transform(matrix4f2, this.debugTerrainMatrix[i], this.debugTerrainMatrix[i]);
+         this.debugTerrainMatrix[i].x = this.debugTerrainMatrix[i].x / this.debugTerrainMatrix[i].w;
+         this.debugTerrainMatrix[i].y = this.debugTerrainMatrix[i].y / this.debugTerrainMatrix[i].w;
+         this.debugTerrainMatrix[i].z = this.debugTerrainMatrix[i].z / this.debugTerrainMatrix[i].w;
+         this.debugTerrainMatrix[i].w = 1.0F;
       }
    }
 
-   protected Vector3f getViewVector(Entity var1, double var2) {
-      float ☃ = (float)(☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃);
-      float ☃x = (float)(☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃);
+   protected Vector3f getViewVector(Entity entityIn, double partialTicks) {
+      float f = (float)(entityIn.prevRotationPitch + (entityIn.rotationPitch - entityIn.prevRotationPitch) * partialTicks);
+      float f1 = (float)(entityIn.prevRotationYaw + (entityIn.rotationYaw - entityIn.prevRotationYaw) * partialTicks);
       if (Minecraft.getMinecraft().gameSettings.thirdPersonView == 2) {
-         ☃ += 180.0F;
+         f += 180.0F;
       }
 
-      float ☃xx = MathHelper.cos(-☃x * (float) (Math.PI / 180.0) - (float) Math.PI);
-      float ☃xxx = MathHelper.sin(-☃x * (float) (Math.PI / 180.0) - (float) Math.PI);
-      float ☃xxxx = -MathHelper.cos(-☃ * (float) (Math.PI / 180.0));
-      float ☃xxxxx = MathHelper.sin(-☃ * (float) (Math.PI / 180.0));
-      return new Vector3f(☃xxx * ☃xxxx, ☃xxxxx, ☃xx * ☃xxxx);
+      float f2 = MathHelper.cos(-f1 * (float) (Math.PI / 180.0) - (float) Math.PI);
+      float f3 = MathHelper.sin(-f1 * (float) (Math.PI / 180.0) - (float) Math.PI);
+      float f4 = -MathHelper.cos(-f * (float) (Math.PI / 180.0));
+      float f5 = MathHelper.sin(-f * (float) (Math.PI / 180.0));
+      return new Vector3f(f3 * f4, f5, f2 * f4);
    }
 
-   public int renderBlockLayer(BlockRenderLayer var1, double var2, int var4, Entity var5) {
+   public int renderBlockLayer(BlockRenderLayer blockLayerIn, double partialTicks, int pass, Entity entityIn) {
       RenderHelper.disableStandardItemLighting();
-      if (☃ == BlockRenderLayer.TRANSLUCENT) {
+      if (blockLayerIn == BlockRenderLayer.TRANSLUCENT && !Shaders.isShadowPass) {
          this.mc.profiler.startSection("translucent_sort");
-         double ☃ = ☃.posX - this.prevRenderSortX;
-         double ☃x = ☃.posY - this.prevRenderSortY;
-         double ☃xx = ☃.posZ - this.prevRenderSortZ;
-         if (☃ * ☃ + ☃x * ☃x + ☃xx * ☃xx > 1.0) {
-            this.prevRenderSortX = ☃.posX;
-            this.prevRenderSortY = ☃.posY;
-            this.prevRenderSortZ = ☃.posZ;
-            int ☃xxx = 0;
-
-            for (RenderGlobal.ContainerLocalRenderInformation ☃xxxx : this.renderInfos) {
-               if (☃xxxx.renderChunk.compiledChunk.isLayerStarted(☃) && ☃xxx++ < 15) {
-                  this.renderDispatcher.updateTransparencyLater(☃xxxx.renderChunk);
+         double d0 = entityIn.posX - this.prevRenderSortX;
+         double d1 = entityIn.posY - this.prevRenderSortY;
+         double d2 = entityIn.posZ - this.prevRenderSortZ;
+         if (d0 * d0 + d1 * d1 + d2 * d2 > 1.0) {
+            this.prevRenderSortX = entityIn.posX;
+            this.prevRenderSortY = entityIn.posY;
+            this.prevRenderSortZ = entityIn.posZ;
+            int k = 0;
+            this.chunksToResortTransparency.clear();
+
+            for (RenderGlobal.ContainerLocalRenderInformation renderglobal$containerlocalrenderinformation : this.renderInfos) {
+               if (renderglobal$containerlocalrenderinformation.renderChunk.compiledChunk.isLayerStarted(blockLayerIn) && k++ < 15) {
+                  this.chunksToResortTransparency.add(renderglobal$containerlocalrenderinformation.renderChunk);
                }
             }
          }
@@ -931,27 +1237,36 @@ public int renderBlockLayer(BlockRenderLayer var1, double var2, int var4, Entity
       }
 
       this.mc.profiler.startSection("filterempty");
-      int ☃ = 0;
-      boolean ☃x = ☃ == BlockRenderLayer.TRANSLUCENT;
-      int ☃xx = ☃x ? this.renderInfos.size() - 1 : 0;
-      int ☃xxx = ☃x ? -1 : this.renderInfos.size();
-      int ☃xxxxx = ☃x ? -1 : 1;
-
-      for (int ☃xxxxxx = ☃xx; ☃xxxxxx != ☃xxx; ☃xxxxxx += ☃xxxxx) {
-         RenderChunk ☃xxxxxxx = this.renderInfos.get(☃xxxxxx).renderChunk;
-         if (!☃xxxxxxx.getCompiledChunk().isLayerEmpty(☃)) {
-            ☃++;
-            this.renderContainer.addRenderChunk(☃xxxxxxx, ☃);
+      int l = 0;
+      boolean flag = blockLayerIn == BlockRenderLayer.TRANSLUCENT;
+      int i1 = flag ? this.renderInfos.size() - 1 : 0;
+      int i = flag ? -1 : this.renderInfos.size();
+      int j1 = flag ? -1 : 1;
+
+      for (int j = i1; j != i; j += j1) {
+         RenderChunk renderchunk = this.renderInfos.get(j).renderChunk;
+         if (!renderchunk.getCompiledChunk().isLayerEmpty(blockLayerIn)) {
+            l++;
+            this.renderContainer.addRenderChunk(renderchunk, blockLayerIn);
          }
       }
 
-      this.mc.profiler.func_194339_b(() -> "render_" + ☃);
-      this.renderBlockLayer(☃);
-      this.mc.profiler.endSection();
-      return ☃;
+      if (l == 0) {
+         this.mc.profiler.endSection();
+         return l;
+      } else {
+         if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
+            GlStateManager.disableFog();
+         }
+
+         this.mc.profiler.func_194339_b(() -> "render_" + blockLayerIn);
+         this.renderBlockLayer(blockLayerIn);
+         this.mc.profiler.endSection();
+         return l;
+      }
    }
 
-   private void renderBlockLayer(BlockRenderLayer var1) {
+   private void renderBlockLayer(BlockRenderLayer blockLayerIn) {
       this.mc.entityRenderer.enableLightmap();
       if (OpenGlHelper.useVbo()) {
          GlStateManager.glEnableClientState(32884);
@@ -963,17 +1278,25 @@ private void renderBlockLayer(BlockRenderLayer var1) {
          GlStateManager.glEnableClientState(32886);
       }
 
-      this.renderContainer.renderChunkLayer(☃);
+      if (Config.isShaders()) {
+         ShadersRender.preRenderChunkLayer(blockLayerIn);
+      }
+
+      this.renderContainer.renderChunkLayer(blockLayerIn);
+      if (Config.isShaders()) {
+         ShadersRender.postRenderChunkLayer(blockLayerIn);
+      }
+
       if (OpenGlHelper.useVbo()) {
-         for (VertexFormatElement ☃ : DefaultVertexFormats.BLOCK.getElements()) {
-            VertexFormatElement.EnumUsage ☃x = ☃.getUsage();
-            int ☃xx = ☃.getIndex();
-            switch (☃x) {
+         for (VertexFormatElement vertexformatelement : DefaultVertexFormats.BLOCK.getElements()) {
+            EnumUsage vertexformatelement$enumusage = vertexformatelement.getUsage();
+            int k1 = vertexformatelement.getIndex();
+            switch (vertexformatelement$enumusage) {
                case POSITION:
                   GlStateManager.glDisableClientState(32884);
                   break;
                case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + ☃xx);
+                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + k1);
                   GlStateManager.glDisableClientState(32888);
                   OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
                   break;
@@ -987,121 +1310,186 @@ private void renderBlockLayer(BlockRenderLayer var1) {
       this.mc.entityRenderer.disableLightmap();
    }
 
-   private void cleanupDamagedBlocks(Iterator<DestroyBlockProgress> var1) {
-      while (☃.hasNext()) {
-         DestroyBlockProgress ☃ = ☃.next();
-         int ☃x = ☃.getCreationCloudUpdateTick();
-         if (this.cloudTickCounter - ☃x > 400) {
-            ☃.remove();
+   private void cleanupDamagedBlocks(Iterator<DestroyBlockProgress> iteratorIn) {
+      while (iteratorIn.hasNext()) {
+         DestroyBlockProgress destroyblockprogress = iteratorIn.next();
+         int k1 = destroyblockprogress.getCreationCloudUpdateTick();
+         if (this.cloudTickCounter - k1 > 400) {
+            iteratorIn.remove();
          }
       }
    }
 
    public void updateClouds() {
+      if (Config.isShaders()) {
+         if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(24)) {
+            GuiShaderOptions gui = new GuiShaderOptions(null, Config.getGameSettings());
+            Config.getMinecraft().displayGuiScreen(gui);
+         }
+
+         if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(19)) {
+            Shaders.uninit();
+            Shaders.loadShaderPack();
+            Reflector.Minecraft_actionKeyF3.setValue(this.mc, Boolean.TRUE);
+         }
+      }
+
       this.cloudTickCounter++;
       if (this.cloudTickCounter % 20 == 0) {
          this.cleanupDamagedBlocks(this.damagedBlocks.values().iterator());
       }
 
       if (!this.setLightUpdates.isEmpty() && !this.renderDispatcher.hasNoFreeRenderBuilders() && this.chunksToUpdate.isEmpty()) {
-         Iterator<BlockPos> ☃ = this.setLightUpdates.iterator();
-
-         while (☃.hasNext()) {
-            BlockPos ☃x = ☃.next();
-            ☃.remove();
-            int ☃xx = ☃x.getX();
-            int ☃xxx = ☃x.getY();
-            int ☃xxxx = ☃x.getZ();
-            this.markBlocksForUpdate(☃xx - 1, ☃xxx - 1, ☃xxxx - 1, ☃xx + 1, ☃xxx + 1, ☃xxxx + 1, false);
+         Iterator<BlockPos> iterator = this.setLightUpdates.iterator();
+
+         while (iterator.hasNext()) {
+            BlockPos blockpos = iterator.next();
+            iterator.remove();
+            int k1 = blockpos.getX();
+            int l1 = blockpos.getY();
+            int i2 = blockpos.getZ();
+            this.markBlocksForUpdate(k1 - 1, l1 - 1, i2 - 1, k1 + 1, l1 + 1, i2 + 1, false);
          }
       }
    }
 
    private void renderSkyEnd() {
-      GlStateManager.disableFog();
-      GlStateManager.disableAlpha();
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      RenderHelper.disableStandardItemLighting();
-      GlStateManager.depthMask(false);
-      this.renderEngine.bindTexture(END_SKY_TEXTURES);
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      if (Config.isSkyEnabled()) {
+         GlStateManager.disableFog();
+         GlStateManager.disableAlpha();
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         RenderHelper.disableStandardItemLighting();
+         GlStateManager.depthMask(false);
+         this.renderEngine.bindTexture(END_SKY_TEXTURES);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
 
-      for (int ☃xx = 0; ☃xx < 6; ☃xx++) {
-         GlStateManager.pushMatrix();
-         if (☃xx == 1) {
-            GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
-         }
+         for (int k1 = 0; k1 < 6; k1++) {
+            GlStateManager.pushMatrix();
+            if (k1 == 1) {
+               GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (☃xx == 2) {
-            GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
-         }
+            if (k1 == 2) {
+               GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (☃xx == 3) {
-            GlStateManager.rotate(180.0F, 1.0F, 0.0F, 0.0F);
-         }
+            if (k1 == 3) {
+               GlStateManager.rotate(180.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (☃xx == 4) {
-            GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
-         }
+            if (k1 == 4) {
+               GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
+            }
+
+            if (k1 == 5) {
+               GlStateManager.rotate(-90.0F, 0.0F, 0.0F, 1.0F);
+            }
+
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            int r = 40;
+            int g = 40;
+            int b = 40;
+            if (Config.isCustomColors()) {
+               Vec3d vec3d = new Vec3d(r / 255.0, g / 255.0, b / 255.0);
+               vec3d = CustomColors.getWorldSkyColor(vec3d, this.world, this.mc.getRenderViewEntity(), 0.0F);
+               r = (int)(vec3d.x * 255.0);
+               g = (int)(vec3d.y * 255.0);
+               b = (int)(vec3d.z * 255.0);
+            }
 
-         if (☃xx == 5) {
-            GlStateManager.rotate(-90.0F, 0.0F, 0.0F, 1.0F);
+            bufferbuilder.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(r, g, b, 255).endVertex();
+            bufferbuilder.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(r, g, b, 255).endVertex();
+            bufferbuilder.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(r, g, b, 255).endVertex();
+            bufferbuilder.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(r, g, b, 255).endVertex();
+            tessellator.draw();
+            GlStateManager.popMatrix();
          }
 
-         ☃x.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         ☃x.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(40, 40, 40, 255).endVertex();
-         ☃x.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(40, 40, 40, 255).endVertex();
-         ☃x.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(40, 40, 40, 255).endVertex();
-         ☃x.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(40, 40, 40, 255).endVertex();
-         ☃.draw();
-         GlStateManager.popMatrix();
+         GlStateManager.depthMask(true);
+         GlStateManager.enableTexture2D();
+         GlStateManager.enableAlpha();
+         GlStateManager.disableBlend();
       }
-
-      GlStateManager.depthMask(true);
-      GlStateManager.enableTexture2D();
-      GlStateManager.enableAlpha();
    }
 
-   public void renderSky(float var1, int var2) {
-      if (this.mc.world.provider.getDimensionType().getId() == 1) {
+   public void renderSky(float partialTicks, int pass) {
+      if (Reflector.ForgeWorldProvider_getSkyRenderer.exists()) {
+         WorldProvider wp = this.mc.world.provider;
+         Object skyRenderer = Reflector.call(wp, Reflector.ForgeWorldProvider_getSkyRenderer, new Object[0]);
+         if (skyRenderer != null) {
+            Reflector.callVoid(skyRenderer, Reflector.IRenderHandler_render, new Object[]{partialTicks, this.world, this.mc});
+            return;
+         }
+      }
+
+      if (this.mc.world.provider.getDimensionType() == DimensionType.THE_END) {
          this.renderSkyEnd();
       } else if (this.mc.world.provider.isSurfaceWorld()) {
          GlStateManager.disableTexture2D();
-         Vec3d ☃ = this.world.getSkyColor(this.mc.getRenderViewEntity(), ☃);
-         float ☃x = (float)☃.x;
-         float ☃xx = (float)☃.y;
-         float ☃xxx = (float)☃.z;
-         if (☃ != 2) {
-            float ☃xxxx = (☃x * 30.0F + ☃xx * 59.0F + ☃xxx * 11.0F) / 100.0F;
-            float ☃xxxxx = (☃x * 30.0F + ☃xx * 70.0F) / 100.0F;
-            float ☃xxxxxx = (☃x * 30.0F + ☃xxx * 70.0F) / 100.0F;
-            ☃x = ☃xxxx;
-            ☃xx = ☃xxxxx;
-            ☃xxx = ☃xxxxxx;
-         }
-
-         GlStateManager.color(☃x, ☃xx, ☃xxx);
-         Tessellator ☃xxxx = Tessellator.getInstance();
-         BufferBuilder ☃xxxxx = ☃xxxx.getBuffer();
+         boolean isShaders = Config.isShaders();
+         if (isShaders) {
+            Shaders.disableTexture2D();
+         }
+
+         Vec3d vec3d = this.world.getSkyColor(this.mc.getRenderViewEntity(), partialTicks);
+         vec3d = CustomColors.getSkyColor(
+            vec3d, this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (isShaders) {
+            Shaders.setSkyColor(vec3d);
+         }
+
+         float f = (float)vec3d.x;
+         float f1 = (float)vec3d.y;
+         float f2 = (float)vec3d.z;
+         if (pass != 2) {
+            float f3 = (f * 30.0F + f1 * 59.0F + f2 * 11.0F) / 100.0F;
+            float f4 = (f * 30.0F + f1 * 70.0F) / 100.0F;
+            float f5 = (f * 30.0F + f2 * 70.0F) / 100.0F;
+            f = f3;
+            f1 = f4;
+            f2 = f5;
+         }
+
+         GlStateManager.color(f, f1, f2);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
          GlStateManager.depthMask(false);
          GlStateManager.enableFog();
-         GlStateManager.color(☃x, ☃xx, ☃xxx);
-         if (this.vboEnabled) {
-            this.skyVBO.bindBuffer();
-            GlStateManager.glEnableClientState(32884);
-            GlStateManager.glVertexPointer(3, 5126, 12, 0);
-            this.skyVBO.drawArrays(7);
-            this.skyVBO.unbindBuffer();
-            GlStateManager.glDisableClientState(32884);
-         } else {
-            GlStateManager.callList(this.glSkyList);
+         if (isShaders) {
+            Shaders.enableFog();
+         }
+
+         GlStateManager.color(f, f1, f2);
+         if (isShaders) {
+            Shaders.preSkyList();
+         }
+
+         if (Config.isSkyEnabled()) {
+            if (this.vboEnabled) {
+               this.skyVBO.bindBuffer();
+               GlStateManager.glEnableClientState(32884);
+               GlStateManager.glVertexPointer(3, 5126, 12, 0);
+               this.skyVBO.drawArrays(7);
+               this.skyVBO.unbindBuffer();
+               GlStateManager.glDisableClientState(32884);
+            } else {
+               GlStateManager.callList(this.glSkyList);
+            }
          }
 
          GlStateManager.disableFog();
+         if (isShaders) {
+            Shaders.disableFog();
+         }
+
          GlStateManager.disableAlpha();
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
@@ -1111,80 +1499,105 @@ public void renderSky(float var1, int var2) {
             GlStateManager.DestFactor.ZERO
          );
          RenderHelper.disableStandardItemLighting();
-         float[] ☃xxxxxx = this.world.provider.calcSunriseSunsetColors(this.world.getCelestialAngle(☃), ☃);
-         if (☃xxxxxx != null) {
+         float[] afloat = this.world.provider.calcSunriseSunsetColors(this.world.getCelestialAngle(partialTicks), partialTicks);
+         if (afloat != null && Config.isSunMoonEnabled()) {
             GlStateManager.disableTexture2D();
+            if (isShaders) {
+               Shaders.disableTexture2D();
+            }
+
             GlStateManager.shadeModel(7425);
             GlStateManager.pushMatrix();
             GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
-            GlStateManager.rotate(MathHelper.sin(this.world.getCelestialAngleRadians(☃)) < 0.0F ? 180.0F : 0.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.rotate(MathHelper.sin(this.world.getCelestialAngleRadians(partialTicks)) < 0.0F ? 180.0F : 0.0F, 0.0F, 0.0F, 1.0F);
             GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
-            float ☃xxxxxxx = ☃xxxxxx[0];
-            float ☃xxxxxxxx = ☃xxxxxx[1];
-            float ☃xxxxxxxxx = ☃xxxxxx[2];
-            if (☃ != 2) {
-               float ☃xxxxxxxxxx = (☃xxxxxxx * 30.0F + ☃xxxxxxxx * 59.0F + ☃xxxxxxxxx * 11.0F) / 100.0F;
-               float ☃xxxxxxxxxxx = (☃xxxxxxx * 30.0F + ☃xxxxxxxx * 70.0F) / 100.0F;
-               float ☃xxxxxxxxxxxx = (☃xxxxxxx * 30.0F + ☃xxxxxxxxx * 70.0F) / 100.0F;
-               ☃xxxxxxx = ☃xxxxxxxxxx;
-               ☃xxxxxxxx = ☃xxxxxxxxxxx;
-               ☃xxxxxxxxx = ☃xxxxxxxxxxxx;
-            }
-
-            ☃xxxxx.begin(6, DefaultVertexFormats.POSITION_COLOR);
-            ☃xxxxx.pos(0.0, 100.0, 0.0).color(☃xxxxxxx, ☃xxxxxxxx, ☃xxxxxxxxx, ☃xxxxxx[3]).endVertex();
-            int ☃xxxxxxxxxx = 16;
-
-            for (int ☃xxxxxxxxxxx = 0; ☃xxxxxxxxxxx <= 16; ☃xxxxxxxxxxx++) {
-               float ☃xxxxxxxxxxxx = ☃xxxxxxxxxxx * (float) (Math.PI * 2) / 16.0F;
-               float ☃xxxxxxxxxxxxx = MathHelper.sin(☃xxxxxxxxxxxx);
-               float ☃xxxxxxxxxxxxxx = MathHelper.cos(☃xxxxxxxxxxxx);
-               ☃xxxxx.pos(☃xxxxxxxxxxxxx * 120.0F, ☃xxxxxxxxxxxxxx * 120.0F, -☃xxxxxxxxxxxxxx * 40.0F * ☃xxxxxx[3])
-                  .color(☃xxxxxx[0], ☃xxxxxx[1], ☃xxxxxx[2], 0.0F)
-                  .endVertex();
-            }
-
-            ☃xxxx.draw();
+            float f6 = afloat[0];
+            float f7 = afloat[1];
+            float f8 = afloat[2];
+            if (pass != 2) {
+               float f9 = (f6 * 30.0F + f7 * 59.0F + f8 * 11.0F) / 100.0F;
+               float f10 = (f6 * 30.0F + f7 * 70.0F) / 100.0F;
+               float f11 = (f6 * 30.0F + f8 * 70.0F) / 100.0F;
+               f6 = f9;
+               f7 = f10;
+               f8 = f11;
+            }
+
+            bufferbuilder.begin(6, DefaultVertexFormats.POSITION_COLOR);
+            bufferbuilder.pos(0.0, 100.0, 0.0).color(f6, f7, f8, afloat[3]).endVertex();
+            int l1 = 16;
+
+            for (int j2 = 0; j2 <= 16; j2++) {
+               float f21 = j2 * (float) (Math.PI * 2) / 16.0F;
+               float f12 = MathHelper.sin(f21);
+               float f13 = MathHelper.cos(f21);
+               bufferbuilder.pos(f12 * 120.0F, f13 * 120.0F, -f13 * 40.0F * afloat[3]).color(afloat[0], afloat[1], afloat[2], 0.0F).endVertex();
+            }
+
+            tessellator.draw();
             GlStateManager.popMatrix();
             GlStateManager.shadeModel(7424);
          }
 
          GlStateManager.enableTexture2D();
+         if (isShaders) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
          );
          GlStateManager.pushMatrix();
-         float ☃xxxxxxx = 1.0F - this.world.getRainStrength(☃);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, ☃xxxxxxx);
+         float f16 = 1.0F - this.world.getRainStrength(partialTicks);
+         GlStateManager.color(1.0F, 1.0F, 1.0F, f16);
          GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
-         GlStateManager.rotate(this.world.getCelestialAngle(☃) * 360.0F, 1.0F, 0.0F, 0.0F);
-         float ☃xxxxxxxx = 30.0F;
-         this.renderEngine.bindTexture(SUN_TEXTURES);
-         ☃xxxxx.begin(7, DefaultVertexFormats.POSITION_TEX);
-         ☃xxxxx.pos(-☃xxxxxxxx, 100.0, -☃xxxxxxxx).tex(0.0, 0.0).endVertex();
-         ☃xxxxx.pos(☃xxxxxxxx, 100.0, -☃xxxxxxxx).tex(1.0, 0.0).endVertex();
-         ☃xxxxx.pos(☃xxxxxxxx, 100.0, ☃xxxxxxxx).tex(1.0, 1.0).endVertex();
-         ☃xxxxx.pos(-☃xxxxxxxx, 100.0, ☃xxxxxxxx).tex(0.0, 1.0).endVertex();
-         ☃xxxx.draw();
-         ☃xxxxxxxx = 20.0F;
-         this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
-         int ☃xxxxxxxxx = this.world.getMoonPhase();
-         int ☃xxxxxxxxxx = ☃xxxxxxxxx % 4;
-         int ☃xxxxxxxxxxx = ☃xxxxxxxxx / 4 % 2;
-         float ☃xxxxxxxxxxxx = (☃xxxxxxxxxx + 0) / 4.0F;
-         float ☃xxxxxxxxxxxxx = (☃xxxxxxxxxxx + 0) / 2.0F;
-         float ☃xxxxxxxxxxxxxx = (☃xxxxxxxxxx + 1) / 4.0F;
-         float ☃xxxxxxxxxxxxxxx = (☃xxxxxxxxxxx + 1) / 2.0F;
-         ☃xxxxx.begin(7, DefaultVertexFormats.POSITION_TEX);
-         ☃xxxxx.pos(-☃xxxxxxxx, -100.0, ☃xxxxxxxx).tex(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(☃xxxxxxxx, -100.0, ☃xxxxxxxx).tex(☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(☃xxxxxxxx, -100.0, -☃xxxxxxxx).tex(☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(-☃xxxxxxxx, -100.0, -☃xxxxxxxx).tex(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxx).endVertex();
-         ☃xxxx.draw();
+         CustomSky.renderSky(this.world, this.renderEngine, partialTicks);
+         if (isShaders) {
+            Shaders.preCelestialRotate();
+         }
+
+         GlStateManager.rotate(this.world.getCelestialAngle(partialTicks) * 360.0F, 1.0F, 0.0F, 0.0F);
+         if (isShaders) {
+            Shaders.postCelestialRotate();
+         }
+
+         float f17 = 30.0F;
+         if (Config.isSunTexture()) {
+            this.renderEngine.bindTexture(SUN_TEXTURES);
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+            bufferbuilder.pos(-f17, 100.0, -f17).tex(0.0, 0.0).endVertex();
+            bufferbuilder.pos(f17, 100.0, -f17).tex(1.0, 0.0).endVertex();
+            bufferbuilder.pos(f17, 100.0, f17).tex(1.0, 1.0).endVertex();
+            bufferbuilder.pos(-f17, 100.0, f17).tex(0.0, 1.0).endVertex();
+            tessellator.draw();
+         }
+
+         f17 = 20.0F;
+         if (Config.isMoonTexture()) {
+            this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
+            int k1 = this.world.getMoonPhase();
+            int i2 = k1 % 4;
+            int k2 = k1 / 4 % 2;
+            float f22 = (i2 + 0) / 4.0F;
+            float f23 = (k2 + 0) / 2.0F;
+            float f24 = (i2 + 1) / 4.0F;
+            float f14 = (k2 + 1) / 2.0F;
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+            bufferbuilder.pos(-f17, -100.0, f17).tex(f24, f14).endVertex();
+            bufferbuilder.pos(f17, -100.0, f17).tex(f22, f14).endVertex();
+            bufferbuilder.pos(f17, -100.0, -f17).tex(f22, f23).endVertex();
+            bufferbuilder.pos(-f17, -100.0, -f17).tex(f24, f23).endVertex();
+            tessellator.draw();
+         }
+
          GlStateManager.disableTexture2D();
-         float ☃xxxxxxxxxxxxxxxx = this.world.getStarBrightness(☃) * ☃xxxxxxx;
-         if (☃xxxxxxxxxxxxxxxx > 0.0F) {
-            GlStateManager.color(☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx);
+         if (isShaders) {
+            Shaders.disableTexture2D();
+         }
+
+         float f15 = this.world.getStarBrightness(partialTicks) * f16;
+         if (f15 > 0.0F && Config.isStarsEnabled() && !CustomSky.hasSkyLayers(this.world)) {
+            GlStateManager.color(f15, f15, f15, f15);
             if (this.vboEnabled) {
                this.starVBO.bindBuffer();
                GlStateManager.glEnableClientState(32884);
@@ -1201,11 +1614,19 @@ public void renderSky(float var1, int var2) {
          GlStateManager.disableBlend();
          GlStateManager.enableAlpha();
          GlStateManager.enableFog();
+         if (isShaders) {
+            Shaders.enableFog();
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.disableTexture2D();
+         if (isShaders) {
+            Shaders.disableTexture2D();
+         }
+
          GlStateManager.color(0.0F, 0.0F, 0.0F);
-         double ☃xxxxxxxxxxxxxxxxx = this.mc.player.getPositionEyes(☃).y - this.world.getHorizon();
-         if (☃xxxxxxxxxxxxxxxxx < 0.0) {
+         double d3 = this.mc.player.getPositionEyes(partialTicks).y - this.world.getHorizon();
+         if (d3 < 0.0) {
             GlStateManager.pushMatrix();
             GlStateManager.translate(0.0F, 12.0F, 0.0F);
             if (this.vboEnabled) {
@@ -1220,180 +1641,231 @@ public void renderSky(float var1, int var2) {
             }
 
             GlStateManager.popMatrix();
-            float ☃xxxxxxxxxxxxxxxxxx = 1.0F;
-            float ☃xxxxxxxxxxxxxxxxxxx = -((float)(☃xxxxxxxxxxxxxxxxx + 65.0));
-            float ☃xxxxxxxxxxxxxxxxxxxx = -1.0F;
-            ☃xxxxx.begin(7, DefaultVertexFormats.POSITION_COLOR);
-            ☃xxxxx.pos(-1.0, ☃xxxxxxxxxxxxxxxxxxx, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, ☃xxxxxxxxxxxxxxxxxxx, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, ☃xxxxxxxxxxxxxxxxxxx, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, ☃xxxxxxxxxxxxxxxxxxx, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, ☃xxxxxxxxxxxxxxxxxxx, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, ☃xxxxxxxxxxxxxxxxxxx, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, ☃xxxxxxxxxxxxxxxxxxx, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, ☃xxxxxxxxxxxxxxxxxxx, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxxx.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            ☃xxxx.draw();
+            float f18 = 1.0F;
+            float f19 = -((float)(d3 + 65.0));
+            float f20 = -1.0F;
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
+            bufferbuilder.pos(-1.0, f19, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, f19, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, f19, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, f19, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, f19, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, f19, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, f19, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, f19, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            bufferbuilder.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            tessellator.draw();
          }
 
          if (this.world.provider.isSkyColored()) {
-            GlStateManager.color(☃x * 0.2F + 0.04F, ☃xx * 0.2F + 0.04F, ☃xxx * 0.6F + 0.1F);
+            GlStateManager.color(f * 0.2F + 0.04F, f1 * 0.2F + 0.04F, f2 * 0.6F + 0.1F);
          } else {
-            GlStateManager.color(☃x, ☃xx, ☃xxx);
+            GlStateManager.color(f, f1, f2);
+         }
+
+         if (this.mc.gameSettings.renderDistanceChunks <= 4) {
+            GlStateManager.color(this.mc.entityRenderer.fogColorRed, this.mc.entityRenderer.fogColorGreen, this.mc.entityRenderer.fogColorBlue);
          }
 
          GlStateManager.pushMatrix();
-         GlStateManager.translate(0.0F, -((float)(☃xxxxxxxxxxxxxxxxx - 16.0)), 0.0F);
-         GlStateManager.callList(this.glSkyList2);
+         GlStateManager.translate(0.0F, -((float)(d3 - 16.0)), 0.0F);
+         if (Config.isSkyEnabled()) {
+            if (this.vboEnabled) {
+               this.sky2VBO.bindBuffer();
+               GlStateManager.glEnableClientState(32884);
+               GlStateManager.glVertexPointer(3, 5126, 12, 0);
+               this.sky2VBO.drawArrays(7);
+               this.sky2VBO.unbindBuffer();
+               GlStateManager.glDisableClientState(32884);
+            } else {
+               GlStateManager.callList(this.glSkyList2);
+            }
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.enableTexture2D();
+         if (isShaders) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.depthMask(true);
       }
    }
 
-   public void renderClouds(float var1, int var2, double var3, double var5, double var7) {
-      if (this.mc.world.provider.isSurfaceWorld()) {
-         if (this.mc.gameSettings.shouldRenderClouds() == 2) {
-            this.renderCloudsFancy(☃, ☃, ☃, ☃, ☃);
-         } else {
-            GlStateManager.disableCull();
-            int ☃ = 32;
-            int ☃x = 8;
-            Tessellator ☃xx = Tessellator.getInstance();
-            BufferBuilder ☃xxx = ☃xx.getBuffer();
-            this.renderEngine.bindTexture(CLOUDS_TEXTURES);
-            GlStateManager.enableBlend();
-            GlStateManager.tryBlendFuncSeparate(
-               GlStateManager.SourceFactor.SRC_ALPHA,
-               GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
-               GlStateManager.SourceFactor.ONE,
-               GlStateManager.DestFactor.ZERO
-            );
-            Vec3d ☃xxxx = this.world.getCloudColour(☃);
-            float ☃xxxxx = (float)☃xxxx.x;
-            float ☃xxxxxx = (float)☃xxxx.y;
-            float ☃xxxxxxx = (float)☃xxxx.z;
-            if (☃ != 2) {
-               float ☃xxxxxxxx = (☃xxxxx * 30.0F + ☃xxxxxx * 59.0F + ☃xxxxxxx * 11.0F) / 100.0F;
-               float ☃xxxxxxxxx = (☃xxxxx * 30.0F + ☃xxxxxx * 70.0F) / 100.0F;
-               float ☃xxxxxxxxxx = (☃xxxxx * 30.0F + ☃xxxxxxx * 70.0F) / 100.0F;
-               ☃xxxxx = ☃xxxxxxxx;
-               ☃xxxxxx = ☃xxxxxxxxx;
-               ☃xxxxxxx = ☃xxxxxxxxxx;
-            }
-
-            float ☃xxxxxxxx = 4.8828125E-4F;
-            double ☃xxxxxxxxx = this.cloudTickCounter + ☃;
-            double ☃xxxxxxxxxx = ☃ + ☃xxxxxxxxx * 0.03F;
-            int ☃xxxxxxxxxxx = MathHelper.floor(☃xxxxxxxxxx / 2048.0);
-            int ☃xxxxxxxxxxxx = MathHelper.floor(☃ / 2048.0);
-            ☃xxxxxxxxxx -= ☃xxxxxxxxxxx * 2048;
-            double var22 = ☃ - ☃xxxxxxxxxxxx * 2048;
-            float ☃xxxxxxxxxxxxx = this.world.provider.getCloudHeight() - (float)☃ + 0.33F;
-            float ☃xxxxxxxxxxxxxx = (float)(☃xxxxxxxxxx * 4.8828125E-4);
-            float ☃xxxxxxxxxxxxxxx = (float)(var22 * 4.8828125E-4);
-            ☃xxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-
-            for (int ☃xxxxxxxxxxxxxxxx = -256; ☃xxxxxxxxxxxxxxxx < 256; ☃xxxxxxxxxxxxxxxx += 32) {
-               for (int ☃xxxxxxxxxxxxxxxxx = -256; ☃xxxxxxxxxxxxxxxxx < 256; ☃xxxxxxxxxxxxxxxxx += 32) {
-                  ☃xxx.pos(☃xxxxxxxxxxxxxxxx + 0, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxx + 32)
-                     .tex((☃xxxxxxxxxxxxxxxx + 0) * 4.8828125E-4F + ☃xxxxxxxxxxxxxx, (☃xxxxxxxxxxxxxxxxx + 32) * 4.8828125E-4F + ☃xxxxxxxxxxxxxxx)
-                     .color(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, 0.8F)
-                     .endVertex();
-                  ☃xxx.pos(☃xxxxxxxxxxxxxxxx + 32, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxx + 32)
-                     .tex((☃xxxxxxxxxxxxxxxx + 32) * 4.8828125E-4F + ☃xxxxxxxxxxxxxx, (☃xxxxxxxxxxxxxxxxx + 32) * 4.8828125E-4F + ☃xxxxxxxxxxxxxxx)
-                     .color(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, 0.8F)
-                     .endVertex();
-                  ☃xxx.pos(☃xxxxxxxxxxxxxxxx + 32, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxx + 0)
-                     .tex((☃xxxxxxxxxxxxxxxx + 32) * 4.8828125E-4F + ☃xxxxxxxxxxxxxx, (☃xxxxxxxxxxxxxxxxx + 0) * 4.8828125E-4F + ☃xxxxxxxxxxxxxxx)
-                     .color(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, 0.8F)
-                     .endVertex();
-                  ☃xxx.pos(☃xxxxxxxxxxxxxxxx + 0, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxx + 0)
-                     .tex((☃xxxxxxxxxxxxxxxx + 0) * 4.8828125E-4F + ☃xxxxxxxxxxxxxx, (☃xxxxxxxxxxxxxxxxx + 0) * 4.8828125E-4F + ☃xxxxxxxxxxxxxxx)
-                     .color(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, 0.8F)
-                     .endVertex();
+   public void renderClouds(float partialTicks, int pass, double p_180447_3_, double p_180447_5_, double p_180447_7_) {
+      if (!Config.isCloudsOff()) {
+         if (Reflector.ForgeWorldProvider_getCloudRenderer.exists()) {
+            WorldProvider wp = this.mc.world.provider;
+            Object cloudRenderer = Reflector.call(wp, Reflector.ForgeWorldProvider_getCloudRenderer, new Object[0]);
+            if (cloudRenderer != null) {
+               Reflector.callVoid(cloudRenderer, Reflector.IRenderHandler_render, new Object[]{partialTicks, this.world, this.mc});
+               return;
+            }
+         }
+
+         if (this.mc.world.provider.isSurfaceWorld()) {
+            if (Config.isShaders()) {
+               Shaders.beginClouds();
+            }
+
+            if (Config.isCloudsFancy()) {
+               this.renderCloudsFancy(partialTicks, pass, p_180447_3_, p_180447_5_, p_180447_7_);
+            } else {
+               float var32 = 0.0F;
+               GlStateManager.disableCull();
+               int k1 = 32;
+               int l1 = 8;
+               Tessellator tessellator = Tessellator.getInstance();
+               BufferBuilder bufferbuilder = tessellator.getBuffer();
+               this.renderEngine.bindTexture(CLOUDS_TEXTURES);
+               GlStateManager.enableBlend();
+               GlStateManager.tryBlendFuncSeparate(
+                  GlStateManager.SourceFactor.SRC_ALPHA,
+                  GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+                  GlStateManager.SourceFactor.ONE,
+                  GlStateManager.DestFactor.ZERO
+               );
+               Vec3d vec3d = this.world.getCloudColour(var32);
+               float f = (float)vec3d.x;
+               float f1 = (float)vec3d.y;
+               float f2 = (float)vec3d.z;
+               this.cloudRenderer.prepareToRender(false, this.cloudTickCounter, partialTicks, vec3d);
+               if (this.cloudRenderer.shouldUpdateGlList()) {
+                  this.cloudRenderer.startUpdateGlList();
+                  if (pass != 2) {
+                     float f3 = (f * 30.0F + f1 * 59.0F + f2 * 11.0F) / 100.0F;
+                     float f4 = (f * 30.0F + f1 * 70.0F) / 100.0F;
+                     float f5 = (f * 30.0F + f2 * 70.0F) / 100.0F;
+                     f = f3;
+                     f1 = f4;
+                     f2 = f5;
+                  }
+
+                  float f9 = 4.8828125E-4F;
+                  double d5 = this.cloudTickCounter + var32;
+                  double d3 = p_180447_3_ + d5 * 0.03F;
+                  int i2 = MathHelper.floor(d3 / 2048.0);
+                  int j2 = MathHelper.floor(p_180447_7_ / 2048.0);
+                  d3 -= i2 * 2048;
+                  double lvt_22_1_ = p_180447_7_ - j2 * 2048;
+                  float f6 = this.world.provider.getCloudHeight() - (float)p_180447_5_ + 0.33F;
+                  f6 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
+                  float f7 = (float)(d3 * 4.8828125E-4);
+                  float f8 = (float)(lvt_22_1_ * 4.8828125E-4);
+                  bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+
+                  for (int k2 = -256; k2 < 256; k2 += 32) {
+                     for (int l2 = -256; l2 < 256; l2 += 32) {
+                        bufferbuilder.pos(k2 + 0, f6, l2 + 32)
+                           .tex((k2 + 0) * 4.8828125E-4F + f7, (l2 + 32) * 4.8828125E-4F + f8)
+                           .color(f, f1, f2, 0.8F)
+                           .endVertex();
+                        bufferbuilder.pos(k2 + 32, f6, l2 + 32)
+                           .tex((k2 + 32) * 4.8828125E-4F + f7, (l2 + 32) * 4.8828125E-4F + f8)
+                           .color(f, f1, f2, 0.8F)
+                           .endVertex();
+                        bufferbuilder.pos(k2 + 32, f6, l2 + 0)
+                           .tex((k2 + 32) * 4.8828125E-4F + f7, (l2 + 0) * 4.8828125E-4F + f8)
+                           .color(f, f1, f2, 0.8F)
+                           .endVertex();
+                        bufferbuilder.pos(k2 + 0, f6, l2 + 0)
+                           .tex((k2 + 0) * 4.8828125E-4F + f7, (l2 + 0) * 4.8828125E-4F + f8)
+                           .color(f, f1, f2, 0.8F)
+                           .endVertex();
+                     }
+                  }
+
+                  tessellator.draw();
+                  this.cloudRenderer.endUpdateGlList();
                }
+
+               this.cloudRenderer.renderGlList();
+               GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+               GlStateManager.disableBlend();
+               GlStateManager.enableCull();
             }
 
-            ☃xx.draw();
-            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-            GlStateManager.disableBlend();
-            GlStateManager.enableCull();
+            if (Config.isShaders()) {
+               Shaders.endClouds();
+            }
          }
       }
    }
 
-   public boolean hasCloudFog(double var1, double var3, double var5, float var7) {
+   public boolean hasCloudFog(double x, double y, double z, float partialTicks) {
       return false;
    }
 
-   private void renderCloudsFancy(float var1, int var2, double var3, double var5, double var7) {
+   private void renderCloudsFancy(float partialTicks, int pass, double x, double y, double z) {
+      float var51 = 0.0F;
       GlStateManager.disableCull();
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      float ☃xx = 12.0F;
-      float ☃xxx = 4.0F;
-      double ☃xxxx = this.cloudTickCounter + ☃;
-      double ☃xxxxx = (☃ + ☃xxxx * 0.03F) / 12.0;
-      double ☃xxxxxx = ☃ / 12.0 + 0.33F;
-      float ☃xxxxxxx = this.world.provider.getCloudHeight() - (float)☃ + 0.33F;
-      int ☃xxxxxxxx = MathHelper.floor(☃xxxxx / 2048.0);
-      int ☃xxxxxxxxx = MathHelper.floor(☃xxxxxx / 2048.0);
-      ☃xxxxx -= ☃xxxxxxxx * 2048;
-      ☃xxxxxx -= ☃xxxxxxxxx * 2048;
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      float f = 12.0F;
+      float f1 = 4.0F;
+      double d3 = this.cloudTickCounter + var51;
+      double d4 = (x + d3 * 0.03F) / 12.0;
+      double d5 = z / 12.0 + 0.33F;
+      float f2 = this.world.provider.getCloudHeight() - (float)y + 0.33F;
+      f2 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
+      int k1 = MathHelper.floor(d4 / 2048.0);
+      int l1 = MathHelper.floor(d5 / 2048.0);
+      d4 -= k1 * 2048;
+      d5 -= l1 * 2048;
       this.renderEngine.bindTexture(CLOUDS_TEXTURES);
       GlStateManager.enableBlend();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      Vec3d ☃xxxxxxxxxx = this.world.getCloudColour(☃);
-      float ☃xxxxxxxxxxx = (float)☃xxxxxxxxxx.x;
-      float ☃xxxxxxxxxxxx = (float)☃xxxxxxxxxx.y;
-      float ☃xxxxxxxxxxxxx = (float)☃xxxxxxxxxx.z;
-      if (☃ != 2) {
-         float ☃xxxxxxxxxxxxxx = (☃xxxxxxxxxxx * 30.0F + ☃xxxxxxxxxxxx * 59.0F + ☃xxxxxxxxxxxxx * 11.0F) / 100.0F;
-         float ☃xxxxxxxxxxxxxxx = (☃xxxxxxxxxxx * 30.0F + ☃xxxxxxxxxxxx * 70.0F) / 100.0F;
-         float ☃xxxxxxxxxxxxxxxx = (☃xxxxxxxxxxx * 30.0F + ☃xxxxxxxxxxxxx * 70.0F) / 100.0F;
-         ☃xxxxxxxxxxx = ☃xxxxxxxxxxxxxx;
-         ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx;
-         ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx;
-      }
-
-      float ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxx * 0.9F;
-      float ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx * 0.9F;
-      float ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx * 0.9F;
-      float ☃xxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx * 0.7F;
-      float ☃xxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx * 0.7F;
-      float ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx * 0.7F;
-      float ☃xxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx * 0.8F;
-      float ☃xxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx * 0.8F;
-      float ☃xxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx * 0.8F;
-      float ☃xxxxxxxxxxxxxxxxxxxxxxx = 0.00390625F;
-      float ☃xxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.floor(☃xxxxx) * 0.00390625F;
-      float ☃xxxxxxxxxxxxxxxxxxxxxxxxx = MathHelper.floor(☃xxxxxx) * 0.00390625F;
-      float ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = (float)(☃xxxxx - MathHelper.floor(☃xxxxx));
-      float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = (float)(☃xxxxxx - MathHelper.floor(☃xxxxxx));
-      int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxx = 8;
-      int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 4;
-      float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 9.765625E-4F;
+      Vec3d vec3d = this.world.getCloudColour(var51);
+      float f3 = (float)vec3d.x;
+      float f4 = (float)vec3d.y;
+      float f5 = (float)vec3d.z;
+      this.cloudRenderer.prepareToRender(true, this.cloudTickCounter, partialTicks, vec3d);
+      if (pass != 2) {
+         float f6 = (f3 * 30.0F + f4 * 59.0F + f5 * 11.0F) / 100.0F;
+         float f7 = (f3 * 30.0F + f4 * 70.0F) / 100.0F;
+         float f8 = (f3 * 30.0F + f5 * 70.0F) / 100.0F;
+         f3 = f6;
+         f4 = f7;
+         f5 = f8;
+      }
+
+      float f25 = f3 * 0.9F;
+      float f26 = f4 * 0.9F;
+      float f27 = f5 * 0.9F;
+      float f9 = f3 * 0.7F;
+      float f10 = f4 * 0.7F;
+      float f11 = f5 * 0.7F;
+      float f12 = f3 * 0.8F;
+      float f13 = f4 * 0.8F;
+      float f14 = f5 * 0.8F;
+      float f15 = 0.00390625F;
+      float f16 = MathHelper.floor(d4) * 0.00390625F;
+      float f17 = MathHelper.floor(d5) * 0.00390625F;
+      float f18 = (float)(d4 - MathHelper.floor(d4));
+      float f19 = (float)(d5 - MathHelper.floor(d5));
+      int i2 = 8;
+      int j2 = 4;
+      float f20 = 9.765625E-4F;
       GlStateManager.scale(12.0F, 1.0F, 12.0F);
 
-      for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 2; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-         if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx == 0) {
+      for (int k2 = 0; k2 < 2; k2++) {
+         if (k2 == 0) {
             GlStateManager.colorMask(false, false, false, false);
          } else {
-            switch (☃) {
+            switch (pass) {
                case 0:
                   GlStateManager.colorMask(false, true, true, true);
                   break;
@@ -1405,298 +1877,170 @@ private void renderCloudsFancy(float var1, int var2, double var3, double var5, d
             }
          }
 
-         for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = -3; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <= 4; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-            for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = -3; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <= 4; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-               ☃x.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * 8;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * 8;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxx;
-               float ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx;
-               if (☃xxxxxxx > -5.0F) {
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F, ☃xxxxxxx + 0.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx, 0.8F)
+         this.cloudRenderer.renderGlList();
+      }
+
+      if (this.cloudRenderer.shouldUpdateGlList()) {
+         this.cloudRenderer.startUpdateGlList();
+
+         for (int l2 = -3; l2 <= 4; l2++) {
+            for (int i3 = -3; i3 <= 4; i3++) {
+               bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
+               float f21 = l2 * 8;
+               float f22 = i3 * 8;
+               float f23 = f21 - f18;
+               float f24 = f22 - f19;
+               if (f2 > -5.0F) {
+                  bufferbuilder.pos(f23 + 0.0F, f2 + 0.0F, f24 + 8.0F)
+                     .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                     .color(f9, f10, f11, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F, ☃xxxxxxx + 0.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 8.0F, f2 + 0.0F, f24 + 8.0F)
+                     .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                     .color(f9, f10, f11, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F, ☃xxxxxxx + 0.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 8.0F, f2 + 0.0F, f24 + 0.0F)
+                     .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                     .color(f9, f10, f11, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F, ☃xxxxxxx + 0.0F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 0.0F, f2 + 0.0F, f24 + 0.0F)
+                     .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                     .color(f9, f10, f11, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
                }
 
-               if (☃xxxxxxx <= 5.0F) {
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F, ☃xxxxxxx + 4.0F - 9.765625E-4F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx, 0.8F)
+               if (f2 <= 5.0F) {
+                  bufferbuilder.pos(f23 + 0.0F, f2 + 4.0F - 9.765625E-4F, f24 + 8.0F)
+                     .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                     .color(f3, f4, f5, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F, ☃xxxxxxx + 4.0F - 9.765625E-4F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 8.0F, f2 + 4.0F - 9.765625E-4F, f24 + 8.0F)
+                     .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                     .color(f3, f4, f5, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F, ☃xxxxxxx + 4.0F - 9.765625E-4F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 8.0F, f2 + 4.0F - 9.765625E-4F, f24 + 0.0F)
+                     .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                     .color(f3, f4, f5, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  ☃x.pos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F, ☃xxxxxxx + 4.0F - 9.765625E-4F, ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F)
-                     .tex(
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                        (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                     )
-                     .color(☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx, 0.8F)
+                  bufferbuilder.pos(f23 + 0.0F, f2 + 4.0F - 9.765625E-4F, f24 + 0.0F)
+                     .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                     .color(f3, f4, f5, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx > -1) {
-                  for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 8; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+               if (l2 > -1) {
+                  for (int j3 = 0; j3 < 8; j3++) {
+                     bufferbuilder.pos(f23 + j3 + 0.0F, f2 + 0.0F, f24 + 8.0F)
+                        .tex((f21 + j3 + 0.5F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + j3 + 0.0F, f2 + 4.0F, f24 + 8.0F)
+                        .tex((f21 + j3 + 0.5F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + j3 + 0.0F, f2 + 4.0F, f24 + 0.0F)
+                        .tex((f21 + j3 + 0.5F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + j3 + 0.0F, f2 + 0.0F, f24 + 0.0F)
+                        .tex((f21 + j3 + 0.5F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
                   }
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <= 1) {
-                  for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 8; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+               if (l2 <= 1) {
+                  for (int k3 = 0; k3 < 8; k3++) {
+                     bufferbuilder.pos(f23 + k3 + 1.0F - 9.765625E-4F, f2 + 0.0F, f24 + 8.0F)
+                        .tex((f21 + k3 + 0.5F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + k3 + 1.0F - 9.765625E-4F, f2 + 4.0F, f24 + 8.0F)
+                        .tex((f21 + k3 + 0.5F) * 0.00390625F + f16, (f22 + 8.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + k3 + 1.0F - 9.765625E-4F, f2 + 4.0F, f24 + 0.0F)
+                        .tex((f21 + k3 + 0.5F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + k3 + 1.0F - 9.765625E-4F, f2 + 0.0F, f24 + 0.0F)
+                        .tex((f21 + k3 + 0.5F) * 0.00390625F + f16, (f22 + 0.0F) * 0.00390625F + f17)
+                        .color(f25, f26, f27, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
                   }
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx > -1) {
-                  for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 8; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+               if (i3 > -1) {
+                  for (int l3 = 0; l3 < 8; l3++) {
+                     bufferbuilder.pos(f23 + 0.0F, f2 + 4.0F, f24 + l3 + 0.0F)
+                        .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + l3 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 8.0F, f2 + 4.0F, f24 + l3 + 0.0F)
+                        .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + l3 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 8.0F, f2 + 0.0F, f24 + l3 + 0.0F)
+                        .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + l3 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 0.0F, f2 + 0.0F, f24 + l3 + 0.0F)
+                        .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + l3 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
                   }
                }
 
-               if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <= 1) {
-                  for (int ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx < 8; ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx++) {
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+               if (i3 <= 1) {
+                  for (int i4 = 0; i4 < 8; i4++) {
+                     bufferbuilder.pos(f23 + 0.0F, f2 + 4.0F, f24 + i4 + 1.0F - 9.765625E-4F)
+                        .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + i4 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F,
-                           ☃xxxxxxx + 4.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 8.0F, f2 + 4.0F, f24 + i4 + 1.0F - 9.765625E-4F)
+                        .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + i4 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 8.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 8.0F, f2 + 0.0F, f24 + i4 + 1.0F - 9.765625E-4F)
+                        .tex((f21 + 8.0F) * 0.00390625F + f16, (f22 + i4 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     ☃x.pos(
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F,
-                           ☃xxxxxxx + 0.0F,
-                           ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 1.0F - 9.765625E-4F
-                        )
-                        .tex(
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.0F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxx,
-                           (☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + 0.5F) * 0.00390625F + ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-                        )
-                        .color(☃xxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxx, 0.8F)
+                     bufferbuilder.pos(f23 + 0.0F, f2 + 0.0F, f24 + i4 + 1.0F - 9.765625E-4F)
+                        .tex((f21 + 0.0F) * 0.00390625F + f16, (f22 + i4 + 0.5F) * 0.00390625F + f17)
+                        .color(f12, f13, f14, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
                   }
                }
 
-               ☃.draw();
+               tessellator.draw();
             }
          }
+
+         this.cloudRenderer.endUpdateGlList();
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
@@ -1704,45 +2048,86 @@ private void renderCloudsFancy(float var1, int var2, double var3, double var5, d
       GlStateManager.enableCull();
    }
 
-   public void updateChunks(long var1) {
-      this.displayListEntitiesDirty = this.displayListEntitiesDirty | this.renderDispatcher.runChunkUploads(☃);
-      if (!this.chunksToUpdate.isEmpty()) {
-         Iterator<RenderChunk> ☃ = this.chunksToUpdate.iterator();
+   public void updateChunks(long finishTimeNano) {
+      finishTimeNano = (long)(finishTimeNano + 1.0E8);
+      this.displayListEntitiesDirty = this.displayListEntitiesDirty | this.renderDispatcher.runChunkUploads(finishTimeNano);
+      if (this.chunksToUpdateForced.size() > 0) {
+         Iterator itForced = this.chunksToUpdateForced.iterator();
+
+         while (itForced.hasNext()) {
+            RenderChunk rc = (RenderChunk)itForced.next();
+            if (!this.renderDispatcher.updateChunkLater(rc)) {
+               break;
+            }
+
+            rc.clearNeedsUpdate();
+            itForced.remove();
+            this.chunksToUpdate.remove(rc);
+            this.chunksToResortTransparency.remove(rc);
+         }
+      }
 
-         while (☃.hasNext()) {
-            RenderChunk ☃x = ☃.next();
-            boolean ☃xx;
-            if (☃x.needsImmediateUpdate()) {
-               ☃xx = this.renderDispatcher.updateChunkNow(☃x);
+      if (this.chunksToResortTransparency.size() > 0) {
+         Iterator itTransparency = this.chunksToResortTransparency.iterator();
+         if (itTransparency.hasNext()) {
+            RenderChunk renderChunk = (RenderChunk)itTransparency.next();
+            if (this.renderDispatcher.updateTransparencyLater(renderChunk)) {
+               itTransparency.remove();
+            }
+         }
+      }
+
+      double weightTotal = 0.0;
+      int updatesPerFrame = Config.getUpdatesPerFrame();
+      if (!this.chunksToUpdate.isEmpty()) {
+         Iterator<RenderChunk> iterator = this.chunksToUpdate.iterator();
+
+         while (iterator.hasNext()) {
+            RenderChunk renderchunk1 = iterator.next();
+            boolean empty = renderchunk1.isChunkRegionEmpty();
+            boolean flag1;
+            if (!renderchunk1.needsImmediateUpdate() && !empty) {
+               flag1 = this.renderDispatcher.updateChunkLater(renderchunk1);
             } else {
-               ☃xx = this.renderDispatcher.updateChunkLater(☃x);
+               flag1 = this.renderDispatcher.updateChunkNow(renderchunk1);
             }
 
-            if (!☃xx) {
+            if (!flag1) {
                break;
             }
 
-            ☃x.clearNeedsUpdate();
-            ☃.remove();
-            long ☃xxx = ☃ - System.nanoTime();
-            if (☃xxx < 0L) {
-               break;
+            renderchunk1.clearNeedsUpdate();
+            iterator.remove();
+            if (!empty) {
+               double weight = 2.0 * RenderChunkUtils.getRelativeBufferSize(renderchunk1);
+               weightTotal += weight;
+               if (weightTotal > updatesPerFrame) {
+                  break;
+               }
             }
          }
       }
    }
 
-   public void renderWorldBorder(Entity var1, float var2) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      WorldBorder ☃xx = this.world.getWorldBorder();
-      double ☃xxx = this.mc.gameSettings.renderDistanceChunks * 16;
-      if (!(☃.posX < ☃xx.maxX() - ☃xxx) || !(☃.posX > ☃xx.minX() + ☃xxx) || !(☃.posZ < ☃xx.maxZ() - ☃xxx) || !(☃.posZ > ☃xx.minZ() + ☃xxx)) {
-         double ☃xxxx = 1.0 - ☃xx.getClosestDistance(☃) / ☃xxx;
-         ☃xxxx = Math.pow(☃xxxx, 4.0);
-         double ☃xxxxx = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-         double ☃xxxxxx = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-         double ☃xxxxxxx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
+   public void renderWorldBorder(Entity entityIn, float partialTicks) {
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      WorldBorder worldborder = this.world.getWorldBorder();
+      double d3 = this.mc.gameSettings.renderDistanceChunks * 16;
+      if (entityIn.posX >= worldborder.maxX() - d3
+         || entityIn.posX <= worldborder.minX() + d3
+         || entityIn.posZ >= worldborder.maxZ() - d3
+         || entityIn.posZ <= worldborder.minZ() + d3) {
+         if (Config.isShaders()) {
+            Shaders.pushProgram();
+            Shaders.useProgram(Shaders.ProgramTexturedLit);
+         }
+
+         double d4 = 1.0 - worldborder.getClosestDistance(entityIn) / d3;
+         d4 = Math.pow(d4, 4.0);
+         double d5 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;
+         double d6 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;
+         double d7 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
@@ -1750,108 +2135,101 @@ public void renderWorldBorder(Entity var1, float var2) {
          this.renderEngine.bindTexture(FORCEFIELD_TEXTURES);
          GlStateManager.depthMask(false);
          GlStateManager.pushMatrix();
-         int ☃xxxxxxxx = ☃xx.getStatus().getColor();
-         float ☃xxxxxxxxx = (☃xxxxxxxx >> 16 & 0xFF) / 255.0F;
-         float ☃xxxxxxxxxx = (☃xxxxxxxx >> 8 & 0xFF) / 255.0F;
-         float ☃xxxxxxxxxxx = (☃xxxxxxxx & 0xFF) / 255.0F;
-         GlStateManager.color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, (float)☃xxxx);
+         int k1 = worldborder.getStatus().getColor();
+         float f = (k1 >> 16 & 0xFF) / 255.0F;
+         float f1 = (k1 >> 8 & 0xFF) / 255.0F;
+         float f2 = (k1 & 0xFF) / 255.0F;
+         GlStateManager.color(f, f1, f2, (float)d4);
          GlStateManager.doPolygonOffset(-3.0F, -3.0F);
          GlStateManager.enablePolygonOffset();
          GlStateManager.alphaFunc(516, 0.1F);
          GlStateManager.enableAlpha();
          GlStateManager.disableCull();
-         float ☃xxxxxxxxxxxx = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F;
-         float ☃xxxxxxxxxxxxx = 0.0F;
-         float ☃xxxxxxxxxxxxxx = 0.0F;
-         float ☃xxxxxxxxxxxxxxx = 128.0F;
-         ☃x.begin(7, DefaultVertexFormats.POSITION_TEX);
-         ☃x.setTranslation(-☃xxxxx, -☃xxxxxx, -☃xxxxxxx);
-         double ☃xxxxxxxxxxxxxxxx = Math.max((double)MathHelper.floor(☃xxxxxxx - ☃xxx), ☃xx.minZ());
-         double ☃xxxxxxxxxxxxxxxxx = Math.min((double)MathHelper.ceil(☃xxxxxxx + ☃xxx), ☃xx.maxZ());
-         if (☃xxxxx > ☃xx.maxX() - ☃xxx) {
-            float ☃xxxxxxxxxxxxxxxxxx = 0.0F;
-
-            for (double ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxx += 0.5F) {
-               double ☃xxxxxxxxxxxxxxxxxxxx = Math.min(1.0, ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx);
-               float ☃xxxxxxxxxxxxxxxxxxxxx = (float)☃xxxxxxxxxxxxxxxxxxxx * 0.5F;
-               ☃x.pos(☃xx.maxX(), 256.0, ☃xxxxxxxxxxxxxxxxxxx).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F).endVertex();
-               ☃x.pos(☃xx.maxX(), 256.0, ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx)
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F)
-                  .endVertex();
-               ☃x.pos(☃xx.maxX(), 0.0, ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx)
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F)
-                  .endVertex();
-               ☃x.pos(☃xx.maxX(), 0.0, ☃xxxxxxxxxxxxxxxxxxx).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F).endVertex();
-               ☃xxxxxxxxxxxxxxxxxxx++;
-            }
-         }
-
-         if (☃xxxxx < ☃xx.minX() + ☃xxx) {
-            float ☃xxxxxxxxxxxxxxxxxx = 0.0F;
-
-            for (double ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxx += 0.5F) {
-               double ☃xxxxxxxxxxxxxxxxxxxx = Math.min(1.0, ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx);
-               float ☃xxxxxxxxxxxxxxxxxxxxx = (float)☃xxxxxxxxxxxxxxxxxxxx * 0.5F;
-               ☃x.pos(☃xx.minX(), 256.0, ☃xxxxxxxxxxxxxxxxxxx).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F).endVertex();
-               ☃x.pos(☃xx.minX(), 256.0, ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx)
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F)
-                  .endVertex();
-               ☃x.pos(☃xx.minX(), 0.0, ☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx)
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F)
-                  .endVertex();
-               ☃x.pos(☃xx.minX(), 0.0, ☃xxxxxxxxxxxxxxxxxxx).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F).endVertex();
-               ☃xxxxxxxxxxxxxxxxxxx++;
-            }
-         }
-
-         ☃xxxxxxxxxxxxxxxx = Math.max((double)MathHelper.floor(☃xxxxx - ☃xxx), ☃xx.minX());
-         ☃xxxxxxxxxxxxxxxxx = Math.min((double)MathHelper.ceil(☃xxxxx + ☃xxx), ☃xx.maxX());
-         if (☃xxxxxxx > ☃xx.maxZ() - ☃xxx) {
-            float ☃xxxxxxxxxxxxxxxxxx = 0.0F;
-
-            for (double ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxx += 0.5F) {
-               double ☃xxxxxxxxxxxxxxxxxxxx = Math.min(1.0, ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx);
-               float ☃xxxxxxxxxxxxxxxxxxxxx = (float)☃xxxxxxxxxxxxxxxxxxxx * 0.5F;
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx, 256.0, ☃xx.maxZ()).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F).endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx, 256.0, ☃xx.maxZ())
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F)
-                  .endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx, 0.0, ☃xx.maxZ())
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F)
-                  .endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx, 0.0, ☃xx.maxZ()).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F).endVertex();
-               ☃xxxxxxxxxxxxxxxxxxx++;
-            }
-         }
-
-         if (☃xxxxxxx < ☃xx.minZ() + ☃xxx) {
-            float ☃xxxxxxxxxxxxxxxxxx = 0.0F;
-
-            for (double ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxx += 0.5F) {
-               double ☃xxxxxxxxxxxxxxxxxxxx = Math.min(1.0, ☃xxxxxxxxxxxxxxxxx - ☃xxxxxxxxxxxxxxxxxxx);
-               float ☃xxxxxxxxxxxxxxxxxxxxx = (float)☃xxxxxxxxxxxxxxxxxxxx * 0.5F;
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx, 256.0, ☃xx.minZ()).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F).endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx, 256.0, ☃xx.minZ())
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 0.0F)
-                  .endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxx, 0.0, ☃xx.minZ())
-                  .tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F)
-                  .endVertex();
-               ☃x.pos(☃xxxxxxxxxxxxxxxxxxx, 0.0, ☃xx.minZ()).tex(☃xxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxx + 128.0F).endVertex();
-               ☃xxxxxxxxxxxxxxxxxxx++;
-            }
-         }
-
-         ☃.draw();
-         ☃x.setTranslation(0.0, 0.0, 0.0);
+         float f3 = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F;
+         float f4 = 0.0F;
+         float f5 = 0.0F;
+         float f6 = 128.0F;
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+         bufferbuilder.setTranslation(-d5, -d6, -d7);
+         double d8 = Math.max((double)MathHelper.floor(d7 - d3), worldborder.minZ());
+         double d9 = Math.min((double)MathHelper.ceil(d7 + d3), worldborder.maxZ());
+         if (d5 > worldborder.maxX() - d3) {
+            float f7 = 0.0F;
+
+            for (double d10 = d8; d10 < d9; f7 += 0.5F) {
+               double d11 = Math.min(1.0, d9 - d10);
+               float f8 = (float)d11 * 0.5F;
+               bufferbuilder.pos(worldborder.maxX(), 256.0, d10).tex(f3 + f7, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(worldborder.maxX(), 256.0, d10 + d11).tex(f3 + f8 + f7, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(worldborder.maxX(), 0.0, d10 + d11).tex(f3 + f8 + f7, f3 + 128.0F).endVertex();
+               bufferbuilder.pos(worldborder.maxX(), 0.0, d10).tex(f3 + f7, f3 + 128.0F).endVertex();
+               d10++;
+            }
+         }
+
+         if (d5 < worldborder.minX() + d3) {
+            float f9 = 0.0F;
+
+            for (double d12 = d8; d12 < d9; f9 += 0.5F) {
+               double d15 = Math.min(1.0, d9 - d12);
+               float f12 = (float)d15 * 0.5F;
+               bufferbuilder.pos(worldborder.minX(), 256.0, d12).tex(f3 + f9, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(worldborder.minX(), 256.0, d12 + d15).tex(f3 + f12 + f9, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(worldborder.minX(), 0.0, d12 + d15).tex(f3 + f12 + f9, f3 + 128.0F).endVertex();
+               bufferbuilder.pos(worldborder.minX(), 0.0, d12).tex(f3 + f9, f3 + 128.0F).endVertex();
+               d12++;
+            }
+         }
+
+         d8 = Math.max((double)MathHelper.floor(d5 - d3), worldborder.minX());
+         d9 = Math.min((double)MathHelper.ceil(d5 + d3), worldborder.maxX());
+         if (d7 > worldborder.maxZ() - d3) {
+            float f10 = 0.0F;
+
+            for (double d13 = d8; d13 < d9; f10 += 0.5F) {
+               double d16 = Math.min(1.0, d9 - d13);
+               float f13 = (float)d16 * 0.5F;
+               bufferbuilder.pos(d13, 256.0, worldborder.maxZ()).tex(f3 + f10, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(d13 + d16, 256.0, worldborder.maxZ()).tex(f3 + f13 + f10, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(d13 + d16, 0.0, worldborder.maxZ()).tex(f3 + f13 + f10, f3 + 128.0F).endVertex();
+               bufferbuilder.pos(d13, 0.0, worldborder.maxZ()).tex(f3 + f10, f3 + 128.0F).endVertex();
+               d13++;
+            }
+         }
+
+         if (d7 < worldborder.minZ() + d3) {
+            float f11 = 0.0F;
+
+            for (double d14 = d8; d14 < d9; f11 += 0.5F) {
+               double d17 = Math.min(1.0, d9 - d14);
+               float f14 = (float)d17 * 0.5F;
+               bufferbuilder.pos(d14, 256.0, worldborder.minZ()).tex(f3 + f11, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(d14 + d17, 256.0, worldborder.minZ()).tex(f3 + f14 + f11, f3 + 0.0F).endVertex();
+               bufferbuilder.pos(d14 + d17, 0.0, worldborder.minZ()).tex(f3 + f14 + f11, f3 + 128.0F).endVertex();
+               bufferbuilder.pos(d14, 0.0, worldborder.minZ()).tex(f3 + f11, f3 + 128.0F).endVertex();
+               d14++;
+            }
+         }
+
+         tessellator.draw();
+         bufferbuilder.setTranslation(0.0, 0.0, 0.0);
          GlStateManager.enableCull();
          GlStateManager.disableAlpha();
          GlStateManager.doPolygonOffset(0.0F, 0.0F);
          GlStateManager.disablePolygonOffset();
          GlStateManager.enableAlpha();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
          GlStateManager.disableBlend();
          GlStateManager.popMatrix();
          GlStateManager.depthMask(true);
+         if (Config.isShaders()) {
+            Shaders.popProgram();
+         }
       }
    }
 
@@ -1861,11 +2239,14 @@ private void preRenderDamagedBlocks() {
       );
       GlStateManager.enableBlend();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 0.5F);
-      GlStateManager.doPolygonOffset(-3.0F, -3.0F);
+      GlStateManager.doPolygonOffset(-1.0F, -10.0F);
       GlStateManager.enablePolygonOffset();
       GlStateManager.alphaFunc(516, 0.1F);
       GlStateManager.enableAlpha();
       GlStateManager.pushMatrix();
+      if (Config.isShaders()) {
+         ShadersRender.beginBlockDamage();
+      }
    }
 
    private void postRenderDamagedBlocks() {
@@ -1875,53 +2256,74 @@ private void postRenderDamagedBlocks() {
       GlStateManager.enableAlpha();
       GlStateManager.depthMask(true);
       GlStateManager.popMatrix();
+      if (Config.isShaders()) {
+         ShadersRender.endBlockDamage();
+      }
    }
 
-   public void drawBlockDamageTexture(Tessellator var1, BufferBuilder var2, Entity var3, float var4) {
-      double ☃ = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃x = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
+   public void drawBlockDamageTexture(Tessellator tessellatorIn, BufferBuilder worldRendererIn, Entity entityIn, float partialTicks) {
+      double d3 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;
+      double d4 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;
+      double d5 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;
       if (!this.damagedBlocks.isEmpty()) {
          this.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
          this.preRenderDamagedBlocks();
-         ☃.begin(7, DefaultVertexFormats.BLOCK);
-         ☃.setTranslation(-☃, -☃x, -☃xx);
-         ☃.noColor();
-         Iterator<DestroyBlockProgress> ☃xxx = this.damagedBlocks.values().iterator();
-
-         while (☃xxx.hasNext()) {
-            DestroyBlockProgress ☃xxxx = ☃xxx.next();
-            BlockPos ☃xxxxx = ☃xxxx.getPosition();
-            double ☃xxxxxx = ☃xxxxx.getX() - ☃;
-            double ☃xxxxxxx = ☃xxxxx.getY() - ☃x;
-            double ☃xxxxxxxx = ☃xxxxx.getZ() - ☃xx;
-            Block ☃xxxxxxxxx = this.world.getBlockState(☃xxxxx).getBlock();
-            if (!(☃xxxxxxxxx instanceof BlockChest)
-               && !(☃xxxxxxxxx instanceof BlockEnderChest)
-               && !(☃xxxxxxxxx instanceof BlockSign)
-               && !(☃xxxxxxxxx instanceof BlockSkull)) {
-               if (☃xxxxxx * ☃xxxxxx + ☃xxxxxxx * ☃xxxxxxx + ☃xxxxxxxx * ☃xxxxxxxx > 1024.0) {
-                  ☃xxx.remove();
+         worldRendererIn.begin(7, DefaultVertexFormats.BLOCK);
+         worldRendererIn.setTranslation(-d3, -d4, -d5);
+         worldRendererIn.noColor();
+         Iterator<DestroyBlockProgress> iterator = this.damagedBlocks.values().iterator();
+
+         while (iterator.hasNext()) {
+            DestroyBlockProgress destroyblockprogress = iterator.next();
+            BlockPos blockpos = destroyblockprogress.getPosition();
+            double d6 = blockpos.getX() - d3;
+            double d7 = blockpos.getY() - d4;
+            double d8 = blockpos.getZ() - d5;
+            Block block = this.world.getBlockState(blockpos).getBlock();
+            boolean renderBreaking;
+            if (Reflector.ForgeTileEntity_canRenderBreaking.exists()) {
+               boolean tileEntityRenderBreaking = block instanceof BlockChest
+                  || block instanceof BlockEnderChest
+                  || block instanceof BlockSign
+                  || block instanceof BlockSkull;
+               if (!tileEntityRenderBreaking) {
+                  TileEntity te = this.world.getTileEntity(blockpos);
+                  if (te != null) {
+                     tileEntityRenderBreaking = Reflector.callBoolean(te, Reflector.ForgeTileEntity_canRenderBreaking, new Object[0]);
+                  }
+               }
+
+               renderBreaking = !tileEntityRenderBreaking;
+            } else {
+               renderBreaking = !(block instanceof BlockChest)
+                  && !(block instanceof BlockEnderChest)
+                  && !(block instanceof BlockSign)
+                  && !(block instanceof BlockSkull);
+            }
+
+            if (renderBreaking) {
+               if (d6 * d6 + d7 * d7 + d8 * d8 > 1024.0) {
+                  iterator.remove();
                } else {
-                  IBlockState ☃xxxxxxxxxx = this.world.getBlockState(☃xxxxx);
-                  if (☃xxxxxxxxxx.getMaterial() != Material.AIR) {
-                     int ☃xxxxxxxxxxx = ☃xxxx.getPartialBlockDamage();
-                     TextureAtlasSprite ☃xxxxxxxxxxxx = this.destroyBlockIcons[☃xxxxxxxxxxx];
-                     BlockRendererDispatcher ☃xxxxxxxxxxxxx = this.mc.getBlockRendererDispatcher();
-                     ☃xxxxxxxxxxxxx.renderBlockDamage(☃xxxxxxxxxx, ☃xxxxx, ☃xxxxxxxxxxxx, this.world);
+                  IBlockState iblockstate = this.world.getBlockState(blockpos);
+                  if (iblockstate.a() != Material.AIR) {
+                     int k1 = destroyblockprogress.getPartialBlockDamage();
+                     TextureAtlasSprite textureatlassprite = this.destroyBlockIcons[k1];
+                     BlockRendererDispatcher blockrendererdispatcher = this.mc.getBlockRendererDispatcher();
+                     blockrendererdispatcher.renderBlockDamage(iblockstate, blockpos, textureatlassprite, this.world);
                   }
                }
             }
          }
 
-         ☃.draw();
-         ☃.setTranslation(0.0, 0.0, 0.0);
+         tessellatorIn.draw();
+         worldRendererIn.setTranslation(0.0, 0.0, 0.0);
          this.postRenderDamagedBlocks();
       }
    }
 
-   public void drawSelectionBox(EntityPlayer var1, RayTraceResult var2, int var3, float var4) {
-      if (☃ == 0 && ☃.typeOfHit == RayTraceResult.Type.BLOCK) {
+   public void drawSelectionBox(EntityPlayer player, RayTraceResult movingObjectPositionIn, int execute, float partialTicks) {
+      if (execute == 0 && movingObjectPositionIn.typeOfHit == Type.BLOCK) {
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
@@ -1931,556 +2333,756 @@ public void drawSelectionBox(EntityPlayer var1, RayTraceResult var2, int var3, f
          );
          GlStateManager.glLineWidth(2.0F);
          GlStateManager.disableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.disableTexture2D();
+         }
+
          GlStateManager.depthMask(false);
-         BlockPos ☃ = ☃.getBlockPos();
-         IBlockState ☃x = this.world.getBlockState(☃);
-         if (☃x.getMaterial() != Material.AIR && this.world.getWorldBorder().contains(☃)) {
-            double ☃xx = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-            double ☃xxx = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-            double ☃xxxx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-            drawSelectionBoundingBox(☃x.getSelectedBoundingBox(this.world, ☃).grow(0.002F).offset(-☃xx, -☃xxx, -☃xxxx), 0.0F, 0.0F, 0.0F, 0.4F);
+         BlockPos blockpos = movingObjectPositionIn.getBlockPos();
+         IBlockState iblockstate = this.world.getBlockState(blockpos);
+         if (iblockstate.a() != Material.AIR && this.world.getWorldBorder().contains(blockpos)) {
+            double d3 = player.lastTickPosX + (player.posX - player.lastTickPosX) * partialTicks;
+            double d4 = player.lastTickPosY + (player.posY - player.lastTickPosY) * partialTicks;
+            double d5 = player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * partialTicks;
+            drawSelectionBoundingBox(iblockstate.c(this.world, blockpos).grow(0.002F).offset(-d3, -d4, -d5), 0.0F, 0.0F, 0.0F, 0.4F);
          }
 
          GlStateManager.depthMask(true);
          GlStateManager.enableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.disableBlend();
       }
    }
 
-   public static void drawSelectionBoundingBox(AxisAlignedBB var0, float var1, float var2, float var3, float var4) {
-      drawBoundingBox(☃.minX, ☃.minY, ☃.minZ, ☃.maxX, ☃.maxY, ☃.maxZ, ☃, ☃, ☃, ☃);
+   public static void drawSelectionBoundingBox(AxisAlignedBB box, float red, float green, float blue, float alpha) {
+      drawBoundingBox(box.minX, box.minY, box.minZ, box.maxX, box.maxY, box.maxZ, red, green, blue, alpha);
    }
 
    public static void drawBoundingBox(
-      double var0, double var2, double var4, double var6, double var8, double var10, float var12, float var13, float var14, float var15
+      double minX, double minY, double minZ, double maxX, double maxY, double maxZ, float red, float green, float blue, float alpha
    ) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      ☃x.begin(3, DefaultVertexFormats.POSITION_COLOR);
-      drawBoundingBox(☃x, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-      ☃.draw();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
+      drawBoundingBox(bufferbuilder, minX, minY, minZ, maxX, maxY, maxZ, red, green, blue, alpha);
+      tessellator.draw();
    }
 
    public static void drawBoundingBox(
-      BufferBuilder var0, double var1, double var3, double var5, double var7, double var9, double var11, float var13, float var14, float var15, float var16
+      BufferBuilder buffer, double minX, double minY, double minZ, double maxX, double maxY, double maxZ, float red, float green, float blue, float alpha
    ) {
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, 0.0F).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, 0.0F).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, 0.0F).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, 0.0F).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, 0.0F).endVertex();
-   }
-
-   public static void renderFilledBox(AxisAlignedBB var0, float var1, float var2, float var3, float var4) {
-      renderFilledBox(☃.minX, ☃.minY, ☃.minZ, ☃.maxX, ☃.maxY, ☃.maxZ, ☃, ☃, ☃, ☃);
+      buffer.pos(minX, minY, minZ).color(red, green, blue, 0.0F).endVertex();
+      buffer.pos(minX, minY, minZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, minY, minZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, minY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, minY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, minY, minZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, maxY, minZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, maxY, minZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, maxY, minZ).color(red, green, blue, 0.0F).endVertex();
+      buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(minX, minY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, minY, maxZ).color(red, green, blue, 0.0F).endVertex();
+      buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
+      buffer.pos(maxX, maxY, minZ).color(red, green, blue, 0.0F).endVertex();
+      buffer.pos(maxX, minY, minZ).color(red, green, blue, alpha).endVertex();
+   }
+
+   public static void renderFilledBox(AxisAlignedBB p_189696_0_, float p_189696_1_, float p_189696_2_, float p_189696_3_, float p_189696_4_) {
+      renderFilledBox(
+         p_189696_0_.minX,
+         p_189696_0_.minY,
+         p_189696_0_.minZ,
+         p_189696_0_.maxX,
+         p_189696_0_.maxY,
+         p_189696_0_.maxZ,
+         p_189696_1_,
+         p_189696_2_,
+         p_189696_3_,
+         p_189696_4_
+      );
    }
 
    public static void renderFilledBox(
-      double var0, double var2, double var4, double var6, double var8, double var10, float var12, float var13, float var14, float var15
+      double p_189695_0_,
+      double p_189695_2_,
+      double p_189695_4_,
+      double p_189695_6_,
+      double p_189695_8_,
+      double p_189695_10_,
+      float p_189695_12_,
+      float p_189695_13_,
+      float p_189695_14_,
+      float p_189695_15_
    ) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      ☃x.begin(5, DefaultVertexFormats.POSITION_COLOR);
-      addChainedFilledBoxVertices(☃x, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-      ☃.draw();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
+      addChainedFilledBoxVertices(
+         bufferbuilder, p_189695_0_, p_189695_2_, p_189695_4_, p_189695_6_, p_189695_8_, p_189695_10_, p_189695_12_, p_189695_13_, p_189695_14_, p_189695_15_
+      );
+      tessellator.draw();
    }
 
    public static void addChainedFilledBoxVertices(
-      BufferBuilder var0, double var1, double var3, double var5, double var7, double var9, double var11, float var13, float var14, float var15, float var16
+      BufferBuilder builder,
+      double p_189693_1_,
+      double p_189693_3_,
+      double p_189693_5_,
+      double p_189693_7_,
+      double p_189693_9_,
+      double p_189693_11_,
+      float red,
+      float green,
+      float blue,
+      float alpha
    ) {
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃, ☃, ☃).color(☃, ☃, ☃, ☃).endVertex();
-   }
-
-   private void markBlocksForUpdate(int var1, int var2, int var3, int var4, int var5, int var6, boolean var7) {
-      this.viewFrustum.markBlocksForUpdate(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-   }
-
-   @Override
-   public void notifyBlockUpdate(World var1, BlockPos var2, IBlockState var3, IBlockState var4, int var5) {
-      int ☃ = ☃.getX();
-      int ☃x = ☃.getY();
-      int ☃xx = ☃.getZ();
-      this.markBlocksForUpdate(☃ - 1, ☃x - 1, ☃xx - 1, ☃ + 1, ☃x + 1, ☃xx + 1, (☃ & 8) != 0);
-   }
-
-   @Override
-   public void notifyLightSet(BlockPos var1) {
-      this.setLightUpdates.add(☃.toImmutable());
-   }
-
-   @Override
-   public void markBlockRangeForRenderUpdate(int var1, int var2, int var3, int var4, int var5, int var6) {
-      this.markBlocksForUpdate(☃ - 1, ☃ - 1, ☃ - 1, ☃ + 1, ☃ + 1, ☃ + 1, false);
-   }
-
-   @Override
-   public void playRecord(@Nullable SoundEvent var1, BlockPos var2) {
-      ISound ☃ = this.mapSoundPositions.get(☃);
-      if (☃ != null) {
-         this.mc.getSoundHandler().stopSound(☃);
-         this.mapSoundPositions.remove(☃);
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_3_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_1_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_5_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+      builder.pos(p_189693_7_, p_189693_9_, p_189693_11_).color(red, green, blue, alpha).endVertex();
+   }
+
+   private void markBlocksForUpdate(int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean updateImmediately) {
+      this.viewFrustum.markBlocksForUpdate(minX, minY, minZ, maxX, maxY, maxZ, updateImmediately);
+   }
+
+   public void notifyBlockUpdate(World worldIn, BlockPos pos, IBlockState oldState, IBlockState newState, int flags) {
+      int k1 = pos.getX();
+      int l1 = pos.getY();
+      int i2 = pos.getZ();
+      this.markBlocksForUpdate(k1 - 1, l1 - 1, i2 - 1, k1 + 1, l1 + 1, i2 + 1, (flags & 8) != 0);
+   }
+
+   public void notifyLightSet(BlockPos pos) {
+      this.setLightUpdates.add(pos.toImmutable());
+   }
+
+   public void markBlockRangeForRenderUpdate(int x1, int y1, int z1, int x2, int y2, int z2) {
+      this.markBlocksForUpdate(x1 - 1, y1 - 1, z1 - 1, x2 + 1, y2 + 1, z2 + 1, false);
+   }
+
+   public void playRecord(@Nullable SoundEvent soundIn, BlockPos pos) {
+      ISound isound = this.mapSoundPositions.get(pos);
+      if (isound != null) {
+         this.mc.getSoundHandler().stopSound(isound);
+         this.mapSoundPositions.remove(pos);
       }
 
-      if (☃ != null) {
-         ItemRecord ☃x = ItemRecord.getBySound(☃);
-         if (☃x != null) {
-            this.mc.ingameGUI.setRecordPlayingMessage(☃x.getRecordNameLocal());
+      if (soundIn != null) {
+         ItemRecord itemrecord = ItemRecord.getBySound(soundIn);
+         if (itemrecord != null) {
+            this.mc.ingameGUI.setRecordPlayingMessage(itemrecord.getRecordNameLocal());
          }
 
-         ISound var5 = PositionedSoundRecord.getRecordSoundRecord(☃, ☃.getX(), ☃.getY(), ☃.getZ());
-         this.mapSoundPositions.put(☃, var5);
-         this.mc.getSoundHandler().playSound(var5);
+         ISound positionedsoundrecord = PositionedSoundRecord.getRecordSoundRecord(soundIn, pos.getX(), pos.getY(), pos.getZ());
+         this.mapSoundPositions.put(pos, positionedsoundrecord);
+         this.mc.getSoundHandler().playSound(positionedsoundrecord);
       }
 
-      this.setPartying(this.world, ☃, ☃ != null);
+      this.setPartying(this.world, pos, soundIn != null);
    }
 
-   private void setPartying(World var1, BlockPos var2, boolean var3) {
-      for (EntityLivingBase ☃ : ☃.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(☃).grow(3.0))) {
-         ☃.setPartying(☃, ☃);
+   private void setPartying(World p_193054_1_, BlockPos pos, boolean p_193054_3_) {
+      for (EntityLivingBase entitylivingbase : p_193054_1_.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(pos).grow(3.0))) {
+         entitylivingbase.setPartying(pos, p_193054_3_);
       }
    }
 
-   @Override
    public void playSoundToAllNearExcept(
-      @Nullable EntityPlayer var1, SoundEvent var2, SoundCategory var3, double var4, double var6, double var8, float var10, float var11
+      @Nullable EntityPlayer player, SoundEvent soundIn, SoundCategory category, double x, double y, double z, float volume, float pitch
    ) {
    }
 
-   @Override
-   public void spawnParticle(int var1, boolean var2, double var3, double var5, double var7, double var9, double var11, double var13, int... var15) {
-      this.spawnParticle(☃, ☃, false, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public void spawnParticle(
+      int particleID, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters
+   ) {
+      this.spawnParticle(particleID, ignoreRange, false, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
    }
 
-   @Override
    public void spawnParticle(
-      int var1, boolean var2, boolean var3, final double var4, final double var6, final double var8, double var10, double var12, double var14, int... var16
+      int id,
+      boolean ignoreRange,
+      boolean p_190570_3_,
+      final double x,
+      final double y,
+      final double z,
+      double xSpeed,
+      double ySpeed,
+      double zSpeed,
+      int... parameters
    ) {
       try {
-         this.spawnParticle0(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+         this.spawnParticle0(id, ignoreRange, p_190570_3_, x, y, z, xSpeed, ySpeed, zSpeed, parameters);
       } catch (Throwable var20) {
-         CrashReport ☃ = CrashReport.makeCrashReport(var20, "Exception while adding particle");
-         CrashReportCategory ☃x = ☃.makeCategory("Particle being added");
-         ☃x.addCrashSection("ID", ☃);
-         if (☃ != null) {
-            ☃x.addCrashSection("Parameters", ☃);
+         CrashReport crashreport = CrashReport.makeCrashReport(var20, "Exception while adding particle");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Particle being added");
+         crashreportcategory.addCrashSection("ID", id);
+         if (parameters != null) {
+            crashreportcategory.addCrashSection("Parameters", parameters);
          }
 
-         ☃x.addDetail("Position", new ICrashReportDetail<String>() {
+         crashreportcategory.addDetail("Position", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return CrashReportCategory.getCoordinateInfo(☃, ☃, ☃);
+               return CrashReportCategory.getCoordinateInfo(x, y, z);
             }
          });
-         throw new ReportedException(☃);
+         throw new ReportedException(crashreport);
       }
    }
 
-   private void spawnParticle(EnumParticleTypes var1, double var2, double var4, double var6, double var8, double var10, double var12, int... var14) {
-      this.spawnParticle(☃.getParticleID(), ☃.getShouldIgnoreRange(), ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   private void spawnParticle(
+      EnumParticleTypes particleIn, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters
+   ) {
+      this.spawnParticle(particleIn.getParticleID(), particleIn.getShouldIgnoreRange(), xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
    }
 
    @Nullable
-   private Particle spawnParticle0(int var1, boolean var2, double var3, double var5, double var7, double var9, double var11, double var13, int... var15) {
-      return this.spawnParticle0(☃, ☃, false, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   private Particle spawnParticle0(
+      int particleID, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters
+   ) {
+      return this.spawnParticle0(particleID, ignoreRange, false, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
    }
 
    @Nullable
    private Particle spawnParticle0(
-      int var1, boolean var2, boolean var3, double var4, double var6, double var8, double var10, double var12, double var14, int... var16
+      int particleID,
+      boolean ignoreRange,
+      boolean minParticles,
+      double xCoord,
+      double yCoord,
+      double zCoord,
+      double xSpeed,
+      double ySpeed,
+      double zSpeed,
+      int... parameters
    ) {
-      Entity ☃ = this.mc.getRenderViewEntity();
-      if (this.mc != null && ☃ != null && this.mc.effectRenderer != null) {
-         int ☃x = this.calculateParticleLevel(☃);
-         double ☃xx = ☃.posX - ☃;
-         double ☃xxx = ☃.posY - ☃;
-         double ☃xxxx = ☃.posZ - ☃;
-         if (☃) {
-            return this.mc.effectRenderer.spawnEffectParticle(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         } else if (☃xx * ☃xx + ☃xxx * ☃xxx + ☃xxxx * ☃xxxx > 1024.0) {
+      Entity entity = this.mc.getRenderViewEntity();
+      if (this.mc != null && entity != null && this.mc.effectRenderer != null) {
+         int k1 = this.calculateParticleLevel(minParticles);
+         double d3 = entity.posX - xCoord;
+         double d4 = entity.posY - yCoord;
+         double d5 = entity.posZ - zCoord;
+         if (particleID == EnumParticleTypes.EXPLOSION_HUGE.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.EXPLOSION_LARGE.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.EXPLOSION_NORMAL.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SUSPENDED.getParticleID() && !Config.isWaterParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SUSPENDED_DEPTH.getParticleID() && !Config.isVoidParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SMOKE_NORMAL.getParticleID() && !Config.isAnimatedSmoke()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SMOKE_LARGE.getParticleID() && !Config.isAnimatedSmoke()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SPELL_MOB.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SPELL.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SPELL_INSTANT.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.SPELL_WITCH.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.PORTAL.getParticleID() && !Config.isPortalParticles()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.FLAME.getParticleID() && !Config.isAnimatedFlame()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.REDSTONE.getParticleID() && !Config.isAnimatedRedstone()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.DRIP_WATER.getParticleID() && !Config.isDrippingWaterLava()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.DRIP_LAVA.getParticleID() && !Config.isDrippingWaterLava()) {
+            return null;
+         } else if (particleID == EnumParticleTypes.FIREWORKS_SPARK.getParticleID() && !Config.isFireworkParticles()) {
             return null;
          } else {
-            return ☃x > 1 ? null : this.mc.effectRenderer.spawnEffectParticle(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+            if (!ignoreRange) {
+               double maxDistSq = 1024.0;
+               if (particleID == EnumParticleTypes.CRIT.getParticleID()) {
+                  maxDistSq = 38416.0;
+               }
+
+               if (d3 * d3 + d4 * d4 + d5 * d5 > maxDistSq) {
+                  return null;
+               }
+
+               if (k1 > 1) {
+                  return null;
+               }
+            }
+
+            Particle entityFx = this.mc.effectRenderer.spawnEffectParticle(particleID, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
+            if (particleID == EnumParticleTypes.WATER_BUBBLE.getParticleID()) {
+               CustomColors.updateWaterFX(entityFx, this.world, xCoord, yCoord, zCoord, this.renderEnv);
+            }
+
+            if (particleID == EnumParticleTypes.WATER_SPLASH.getParticleID()) {
+               CustomColors.updateWaterFX(entityFx, this.world, xCoord, yCoord, zCoord, this.renderEnv);
+            }
+
+            if (particleID == EnumParticleTypes.WATER_DROP.getParticleID()) {
+               CustomColors.updateWaterFX(entityFx, this.world, xCoord, yCoord, zCoord, this.renderEnv);
+            }
+
+            if (particleID == EnumParticleTypes.TOWN_AURA.getParticleID()) {
+               CustomColors.updateMyceliumFX(entityFx);
+            }
+
+            if (particleID == EnumParticleTypes.PORTAL.getParticleID()) {
+               CustomColors.updatePortalFX(entityFx);
+            }
+
+            if (particleID == EnumParticleTypes.REDSTONE.getParticleID()) {
+               CustomColors.updateReddustFX(entityFx, this.world, xCoord, yCoord, zCoord);
+            }
+
+            return entityFx;
          }
       } else {
          return null;
       }
    }
 
-   private int calculateParticleLevel(boolean var1) {
-      int ☃ = this.mc.gameSettings.particleSetting;
-      if (☃ && ☃ == 2 && this.world.rand.nextInt(10) == 0) {
-         ☃ = 1;
+   private int calculateParticleLevel(boolean p_190572_1_) {
+      int k1 = this.mc.gameSettings.particleSetting;
+      if (p_190572_1_ && k1 == 2 && this.world.rand.nextInt(10) == 0) {
+         k1 = 1;
       }
 
-      if (☃ == 1 && this.world.rand.nextInt(3) == 0) {
-         ☃ = 2;
+      if (k1 == 1 && this.world.rand.nextInt(3) == 0) {
+         k1 = 2;
       }
 
-      return ☃;
+      return k1;
    }
 
-   @Override
-   public void onEntityAdded(Entity var1) {
+   public void onEntityAdded(Entity entityIn) {
+      RandomEntities.entityLoaded(entityIn, this.world);
+      if (Config.isDynamicLights()) {
+         DynamicLights.entityAdded(entityIn, this);
+      }
    }
 
-   @Override
-   public void onEntityRemoved(Entity var1) {
+   public void onEntityRemoved(Entity entityIn) {
+      RandomEntities.entityUnloaded(entityIn, this.world);
+      if (Config.isDynamicLights()) {
+         DynamicLights.entityRemoved(entityIn, this);
+      }
    }
 
    public void deleteAllDisplayLists() {
    }
 
-   @Override
-   public void broadcastSound(int var1, BlockPos var2, int var3) {
-      switch (☃) {
+   public void broadcastSound(int soundID, BlockPos pos, int data) {
+      switch (soundID) {
          case 1023:
          case 1028:
          case 1038:
-            Entity ☃ = this.mc.getRenderViewEntity();
-            if (☃ != null) {
-               double ☃x = ☃.getX() - ☃.posX;
-               double ☃xx = ☃.getY() - ☃.posY;
-               double ☃xxx = ☃.getZ() - ☃.posZ;
-               double ☃xxxx = Math.sqrt(☃x * ☃x + ☃xx * ☃xx + ☃xxx * ☃xxx);
-               double ☃xxxxx = ☃.posX;
-               double ☃xxxxxx = ☃.posY;
-               double ☃xxxxxxx = ☃.posZ;
-               if (☃xxxx > 0.0) {
-                  ☃xxxxx += ☃x / ☃xxxx * 2.0;
-                  ☃xxxxxx += ☃xx / ☃xxxx * 2.0;
-                  ☃xxxxxxx += ☃xxx / ☃xxxx * 2.0;
+            Entity entity = this.mc.getRenderViewEntity();
+            if (entity != null) {
+               double d3 = pos.getX() - entity.posX;
+               double d4 = pos.getY() - entity.posY;
+               double d5 = pos.getZ() - entity.posZ;
+               double d6 = Math.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
+               double d7 = entity.posX;
+               double d8 = entity.posY;
+               double d9 = entity.posZ;
+               if (d6 > 0.0) {
+                  d7 += d3 / d6 * 2.0;
+                  d8 += d4 / d6 * 2.0;
+                  d9 += d5 / d6 * 2.0;
                }
 
-               if (☃ == 1023) {
-                  this.world.playSound(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, SoundEvents.ENTITY_WITHER_SPAWN, SoundCategory.HOSTILE, 1.0F, 1.0F, false);
-               } else if (☃ == 1038) {
-                  this.world.playSound(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, SoundEvents.BLOCK_END_PORTAL_SPAWN, SoundCategory.HOSTILE, 1.0F, 1.0F, false);
+               if (soundID == 1023) {
+                  this.world.playSound(d7, d8, d9, SoundEvents.ENTITY_WITHER_SPAWN, SoundCategory.HOSTILE, 1.0F, 1.0F, false);
+               } else if (soundID == 1038) {
+                  this.world.playSound(d7, d8, d9, SoundEvents.BLOCK_END_PORTAL_SPAWN, SoundCategory.HOSTILE, 1.0F, 1.0F, false);
                } else {
-                  this.world.playSound(☃xxxxx, ☃xxxxxx, ☃xxxxxxx, SoundEvents.ENTITY_ENDERDRAGON_DEATH, SoundCategory.HOSTILE, 5.0F, 1.0F, false);
+                  this.world.playSound(d7, d8, d9, SoundEvents.ENTITY_ENDERDRAGON_DEATH, SoundCategory.HOSTILE, 5.0F, 1.0F, false);
                }
             }
       }
    }
 
-   @Override
-   public void playEvent(EntityPlayer var1, int var2, BlockPos var3, int var4) {
-      Random ☃ = this.world.rand;
-      switch (☃) {
+   public void playEvent(EntityPlayer player, int type, BlockPos blockPosIn, int data) {
+      Random random = this.world.rand;
+      switch (type) {
          case 1000:
-            this.world.playSound(☃, SoundEvents.BLOCK_DISPENSER_DISPENSE, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_DISPENSER_DISPENSE, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
             break;
          case 1001:
-            this.world.playSound(☃, SoundEvents.BLOCK_DISPENSER_FAIL, SoundCategory.BLOCKS, 1.0F, 1.2F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_DISPENSER_FAIL, SoundCategory.BLOCKS, 1.0F, 1.2F, false);
             break;
          case 1002:
-            this.world.playSound(☃, SoundEvents.BLOCK_DISPENSER_LAUNCH, SoundCategory.BLOCKS, 1.0F, 1.2F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_DISPENSER_LAUNCH, SoundCategory.BLOCKS, 1.0F, 1.2F, false);
             break;
          case 1003:
-            this.world.playSound(☃, SoundEvents.ENTITY_ENDEREYE_LAUNCH, SoundCategory.NEUTRAL, 1.0F, 1.2F, false);
+            this.world.playSound(blockPosIn, SoundEvents.ENTITY_ENDEREYE_LAUNCH, SoundCategory.NEUTRAL, 1.0F, 1.2F, false);
             break;
          case 1004:
-            this.world.playSound(☃, SoundEvents.ENTITY_FIREWORK_SHOOT, SoundCategory.NEUTRAL, 1.0F, 1.2F, false);
+            this.world.playSound(blockPosIn, SoundEvents.ENTITY_FIREWORK_SHOOT, SoundCategory.NEUTRAL, 1.0F, 1.2F, false);
             break;
          case 1005:
-            this.world.playSound(☃, SoundEvents.BLOCK_IRON_DOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_IRON_DOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1006:
-            this.world.playSound(☃, SoundEvents.BLOCK_WOODEN_DOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_WOODEN_DOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1007:
-            this.world.playSound(☃, SoundEvents.BLOCK_WOODEN_TRAPDOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.BLOCK_WOODEN_TRAPDOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1008:
-            this.world.playSound(☃, SoundEvents.BLOCK_FENCE_GATE_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_FENCE_GATE_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1009:
-            this.world.playSound(☃, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (☃.nextFloat() - ☃.nextFloat()) * 0.8F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (random.nextFloat() - random.nextFloat()) * 0.8F, false
+               );
             break;
          case 1010:
-            if (Item.getItemById(☃) instanceof ItemRecord) {
-               this.world.playRecord(☃, ((ItemRecord)Item.getItemById(☃)).getSound());
+            if (Item.getItemById(data) instanceof ItemRecord) {
+               this.world.playRecord(blockPosIn, ((ItemRecord)Item.getItemById(data)).getSound());
             } else {
-               this.world.playRecord(☃, null);
+               this.world.playRecord(blockPosIn, (SoundEvent)null);
             }
             break;
          case 1011:
-            this.world.playSound(☃, SoundEvents.BLOCK_IRON_DOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_IRON_DOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1012:
-            this.world.playSound(☃, SoundEvents.BLOCK_WOODEN_DOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_WOODEN_DOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1013:
-            this.world.playSound(☃, SoundEvents.BLOCK_WOODEN_TRAPDOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.BLOCK_WOODEN_TRAPDOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1014:
-            this.world.playSound(☃, SoundEvents.BLOCK_FENCE_GATE_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_FENCE_GATE_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1015:
-            this.world.playSound(☃, SoundEvents.ENTITY_GHAST_WARN, SoundCategory.HOSTILE, 10.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_GHAST_WARN, SoundCategory.HOSTILE, 10.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1016:
-            this.world.playSound(☃, SoundEvents.ENTITY_GHAST_SHOOT, SoundCategory.HOSTILE, 10.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_GHAST_SHOOT, SoundCategory.HOSTILE, 10.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1017:
-            this.world.playSound(☃, SoundEvents.ENTITY_ENDERDRAGON_SHOOT, SoundCategory.HOSTILE, 10.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_ENDERDRAGON_SHOOT,
+                  SoundCategory.HOSTILE,
+                  10.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1018:
-            this.world.playSound(☃, SoundEvents.ENTITY_BLAZE_SHOOT, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_BLAZE_SHOOT, SoundCategory.HOSTILE, 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1019:
             this.world
-               .playSound(☃, SoundEvents.ENTITY_ZOMBIE_ATTACK_DOOR_WOOD, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_ZOMBIE_ATTACK_DOOR_WOOD,
+                  SoundCategory.HOSTILE,
+                  2.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1020:
             this.world
-               .playSound(☃, SoundEvents.ENTITY_ZOMBIE_ATTACK_IRON_DOOR, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_ZOMBIE_ATTACK_IRON_DOOR,
+                  SoundCategory.HOSTILE,
+                  2.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1021:
             this.world
-               .playSound(☃, SoundEvents.ENTITY_ZOMBIE_BREAK_DOOR_WOOD, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_ZOMBIE_BREAK_DOOR_WOOD,
+                  SoundCategory.HOSTILE,
+                  2.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1022:
-            this.world.playSound(☃, SoundEvents.ENTITY_WITHER_BREAK_BLOCK, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_WITHER_BREAK_BLOCK,
+                  SoundCategory.HOSTILE,
+                  2.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1024:
-            this.world.playSound(☃, SoundEvents.ENTITY_WITHER_SHOOT, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_WITHER_SHOOT, SoundCategory.HOSTILE, 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1025:
-            this.world.playSound(☃, SoundEvents.ENTITY_BAT_TAKEOFF, SoundCategory.NEUTRAL, 0.05F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_BAT_TAKEOFF, SoundCategory.NEUTRAL, 0.05F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1026:
-            this.world.playSound(☃, SoundEvents.ENTITY_ZOMBIE_INFECT, SoundCategory.HOSTILE, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+            this.world
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_ZOMBIE_INFECT, SoundCategory.HOSTILE, 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F, false
+               );
             break;
          case 1027:
             this.world
-               .playSound(☃, SoundEvents.ENTITY_ZOMBIE_VILLAGER_CONVERTED, SoundCategory.NEUTRAL, 2.0F, (☃.nextFloat() - ☃.nextFloat()) * 0.2F + 1.0F, false);
+               .playSound(
+                  blockPosIn,
+                  SoundEvents.ENTITY_ZOMBIE_VILLAGER_CONVERTED,
+                  SoundCategory.NEUTRAL,
+                  2.0F,
+                  (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F,
+                  false
+               );
             break;
          case 1029:
-            this.world.playSound(☃, SoundEvents.BLOCK_ANVIL_DESTROY, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_ANVIL_DESTROY, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1030:
-            this.world.playSound(☃, SoundEvents.BLOCK_ANVIL_USE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_ANVIL_USE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1031:
-            this.world.playSound(☃, SoundEvents.BLOCK_ANVIL_LAND, SoundCategory.BLOCKS, 0.3F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_ANVIL_LAND, SoundCategory.BLOCKS, 0.3F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1032:
-            this.mc.getSoundHandler().playSound(PositionedSoundRecord.getMasterRecord(SoundEvents.BLOCK_PORTAL_TRAVEL, ☃.nextFloat() * 0.4F + 0.8F));
+            this.mc.getSoundHandler().playSound(PositionedSoundRecord.getMasterRecord(SoundEvents.BLOCK_PORTAL_TRAVEL, random.nextFloat() * 0.4F + 0.8F));
             break;
          case 1033:
-            this.world.playSound(☃, SoundEvents.BLOCK_CHORUS_FLOWER_GROW, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_CHORUS_FLOWER_GROW, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
             break;
          case 1034:
-            this.world.playSound(☃, SoundEvents.BLOCK_CHORUS_FLOWER_DEATH, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_CHORUS_FLOWER_DEATH, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
             break;
          case 1035:
-            this.world.playSound(☃, SoundEvents.BLOCK_BREWING_STAND_BREW, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
+            this.world.playSound(blockPosIn, SoundEvents.BLOCK_BREWING_STAND_BREW, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
             break;
          case 1036:
-            this.world.playSound(☃, SoundEvents.BLOCK_IRON_TRAPDOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.BLOCK_IRON_TRAPDOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1037:
-            this.world.playSound(☃, SoundEvents.BLOCK_IRON_TRAPDOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.BLOCK_IRON_TRAPDOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 2000:
-            int ☃xx = ☃ % 3 - 1;
-            int ☃xxx = ☃ / 3 % 3 - 1;
-            double ☃xxxx = ☃.getX() + ☃xx * 0.6 + 0.5;
-            double ☃xxxxx = ☃.getY() + 0.5;
-            double ☃xxxxxx = ☃.getZ() + ☃xxx * 0.6 + 0.5;
-
-            for (int ☃xxxxxxx = 0; ☃xxxxxxx < 10; ☃xxxxxxx++) {
-               double ☃xxxxxxxx = ☃.nextDouble() * 0.2 + 0.01;
-               double ☃xxxxxxxxxx = ☃xxxx + ☃xx * 0.01 + (☃.nextDouble() - 0.5) * ☃xxx * 0.5;
-               double ☃xxxxxxxxxxx = ☃xxxxx + (☃.nextDouble() - 0.5) * 0.5;
-               double ☃xxxxxxxxxxxx = ☃xxxxxx + ☃xxx * 0.01 + (☃.nextDouble() - 0.5) * ☃xx * 0.5;
-               double ☃xxxxxxxxxxxxx = ☃xx * ☃xxxxxxxx + ☃.nextGaussian() * 0.01;
-               double ☃xxxxxxxxxxxxxx = -0.03 + ☃.nextGaussian() * 0.01;
-               double ☃xxxxxxxxxxxxxxx = ☃xxx * ☃xxxxxxxx + ☃.nextGaussian() * 0.01;
-               this.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxx);
+            int j2 = data % 3 - 1;
+            int k1 = data / 3 % 3 - 1;
+            double d11 = blockPosIn.getX() + j2 * 0.6 + 0.5;
+            double d13 = blockPosIn.getY() + 0.5;
+            double d15 = blockPosIn.getZ() + k1 * 0.6 + 0.5;
+
+            for (int l2 = 0; l2 < 10; l2++) {
+               double d16 = random.nextDouble() * 0.2 + 0.01;
+               double d19 = d11 + j2 * 0.01 + (random.nextDouble() - 0.5) * k1 * 0.5;
+               double d22 = d13 + (random.nextDouble() - 0.5) * 0.5;
+               double d25 = d15 + k1 * 0.01 + (random.nextDouble() - 0.5) * j2 * 0.5;
+               double d27 = j2 * d16 + random.nextGaussian() * 0.01;
+               double d29 = -0.03 + random.nextGaussian() * 0.01;
+               double d30 = k1 * d16 + random.nextGaussian() * 0.01;
+               this.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, d19, d22, d25, d27, d29, d30);
             }
-            break;
+
+            return;
          case 2001:
-            Block ☃x = Block.getBlockById(☃ & 4095);
-            if (☃x.getDefaultState().getMaterial() != Material.AIR) {
-               SoundType ☃xx = ☃x.getSoundType();
-               this.world.playSound(☃, ☃xx.getBreakSound(), SoundCategory.BLOCKS, (☃xx.getVolume() + 1.0F) / 2.0F, ☃xx.getPitch() * 0.8F, false);
+            Block block = Block.getBlockById(data & 4095);
+            if (block.getDefaultState().a() != Material.AIR) {
+               SoundType soundtype = block.getSoundType();
+               if (Reflector.ForgeBlock_getSoundType.exists()) {
+                  soundtype = (SoundType)Reflector.call(
+                     block, Reflector.ForgeBlock_getSoundType, new Object[]{Block.getStateById(data), this.world, blockPosIn, null}
+                  );
+               }
+
+               this.world
+                  .playSound(
+                     blockPosIn, soundtype.getBreakSound(), SoundCategory.BLOCKS, (soundtype.getVolume() + 1.0F) / 2.0F, soundtype.getPitch() * 0.8F, false
+                  );
             }
 
-            this.mc.effectRenderer.addBlockDestroyEffects(☃, ☃x.getStateFromMeta(☃ >> 12 & 0xFF));
+            this.mc.effectRenderer.addBlockDestroyEffects(blockPosIn, block.getStateFromMeta(data >> 12 & 0xFF));
             break;
          case 2002:
          case 2007:
-            double ☃xx = ☃.getX();
-            double ☃xxx = ☃.getY();
-            double ☃xxxx = ☃.getZ();
+            double d9 = blockPosIn.getX();
+            double d10 = blockPosIn.getY();
+            double d12 = blockPosIn.getZ();
 
-            for (int ☃xxxxx = 0; ☃xxxxx < 8; ☃xxxxx++) {
+            for (int k2 = 0; k2 < 8; k2++) {
                this.spawnParticle(
                   EnumParticleTypes.ITEM_CRACK,
-                  ☃xx,
-                  ☃xxx,
-                  ☃xxxx,
-                  ☃.nextGaussian() * 0.15,
-                  ☃.nextDouble() * 0.2,
-                  ☃.nextGaussian() * 0.15,
+                  d9,
+                  d10,
+                  d12,
+                  random.nextGaussian() * 0.15,
+                  random.nextDouble() * 0.2,
+                  random.nextGaussian() * 0.15,
                   Item.getIdFromItem(Items.SPLASH_POTION)
                );
             }
 
-            float ☃xxxxx = (☃ >> 16 & 0xFF) / 255.0F;
-            float ☃xxxxxx = (☃ >> 8 & 0xFF) / 255.0F;
-            float ☃xxxxxxx = (☃ >> 0 & 0xFF) / 255.0F;
-            EnumParticleTypes ☃xxxxxxxx = ☃ == 2007 ? EnumParticleTypes.SPELL_INSTANT : EnumParticleTypes.SPELL;
-
-            for (int ☃xxxxxxxxx = 0; ☃xxxxxxxxx < 100; ☃xxxxxxxxx++) {
-               double ☃xxxxxxxxxx = ☃.nextDouble() * 4.0;
-               double ☃xxxxxxxxxxx = ☃.nextDouble() * Math.PI * 2.0;
-               double ☃xxxxxxxxxxxx = Math.cos(☃xxxxxxxxxxx) * ☃xxxxxxxxxx;
-               double ☃xxxxxxxxxxxxx = 0.01 + ☃.nextDouble() * 0.5;
-               double ☃xxxxxxxxxxxxxx = Math.sin(☃xxxxxxxxxxx) * ☃xxxxxxxxxx;
-               Particle ☃xxxxxxxxxxxxxxx = this.spawnParticle0(
-                  ☃xxxxxxxx.getParticleID(),
-                  ☃xxxxxxxx.getShouldIgnoreRange(),
-                  ☃xx + ☃xxxxxxxxxxxx * 0.1,
-                  ☃xxx + 0.3,
-                  ☃xxxx + ☃xxxxxxxxxxxxxx * 0.1,
-                  ☃xxxxxxxxxxxx,
-                  ☃xxxxxxxxxxxxx,
-                  ☃xxxxxxxxxxxxxx
+            float f5 = (data >> 16 & 0xFF) / 255.0F;
+            float f = (data >> 8 & 0xFF) / 255.0F;
+            float f1 = (data >> 0 & 0xFF) / 255.0F;
+            EnumParticleTypes enumparticletypes = type == 2007 ? EnumParticleTypes.SPELL_INSTANT : EnumParticleTypes.SPELL;
+
+            for (int j3 = 0; j3 < 100; j3++) {
+               double d18 = random.nextDouble() * 4.0;
+               double d21 = random.nextDouble() * Math.PI * 2.0;
+               double d24 = Math.cos(d21) * d18;
+               double d26 = 0.01 + random.nextDouble() * 0.5;
+               double d28 = Math.sin(d21) * d18;
+               Particle particle1 = this.spawnParticle0(
+                  enumparticletypes.getParticleID(), enumparticletypes.getShouldIgnoreRange(), d9 + d24 * 0.1, d10 + 0.3, d12 + d28 * 0.1, d24, d26, d28
                );
-               if (☃xxxxxxxxxxxxxxx != null) {
-                  float ☃xxxxxxxxxxxxxxxx = 0.75F + ☃.nextFloat() * 0.25F;
-                  ☃xxxxxxxxxxxxxxx.setRBGColorF(☃xxxxx * ☃xxxxxxxxxxxxxxxx, ☃xxxxxx * ☃xxxxxxxxxxxxxxxx, ☃xxxxxxx * ☃xxxxxxxxxxxxxxxx);
-                  ☃xxxxxxxxxxxxxxx.multiplyVelocity((float)☃xxxxxxxxxx);
+               if (particle1 != null) {
+                  float f4 = 0.75F + random.nextFloat() * 0.25F;
+                  particle1.setRBGColorF(f5 * f4, f * f4, f1 * f4);
+                  particle1.multiplyVelocity((float)d18);
                }
             }
 
-            this.world.playSound(☃, SoundEvents.ENTITY_SPLASH_POTION_BREAK, SoundCategory.NEUTRAL, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.ENTITY_SPLASH_POTION_BREAK, SoundCategory.NEUTRAL, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 2003:
-            double ☃xx = ☃.getX() + 0.5;
-            double ☃xxx = ☃.getY();
-            double ☃xxxx = ☃.getZ() + 0.5;
+            double d3 = blockPosIn.getX() + 0.5;
+            double d4 = blockPosIn.getY();
+            double d5 = blockPosIn.getZ() + 0.5;
 
-            for (int ☃xxxxx = 0; ☃xxxxx < 8; ☃xxxxx++) {
+            for (int l1 = 0; l1 < 8; l1++) {
                this.spawnParticle(
                   EnumParticleTypes.ITEM_CRACK,
-                  ☃xx,
-                  ☃xxx,
-                  ☃xxxx,
-                  ☃.nextGaussian() * 0.15,
-                  ☃.nextDouble() * 0.2,
-                  ☃.nextGaussian() * 0.15,
+                  d3,
+                  d4,
+                  d5,
+                  random.nextGaussian() * 0.15,
+                  random.nextDouble() * 0.2,
+                  random.nextGaussian() * 0.15,
                   Item.getIdFromItem(Items.ENDER_EYE)
                );
             }
 
-            for (double ☃xxxxx = 0.0; ☃xxxxx < Math.PI * 2; ☃xxxxx += Math.PI / 20) {
+            for (double d14 = 0.0; d14 < Math.PI * 2; d14 += Math.PI / 20) {
                this.spawnParticle(
-                  EnumParticleTypes.PORTAL,
-                  ☃xx + Math.cos(☃xxxxx) * 5.0,
-                  ☃xxx - 0.4,
-                  ☃xxxx + Math.sin(☃xxxxx) * 5.0,
-                  Math.cos(☃xxxxx) * -5.0,
-                  0.0,
-                  Math.sin(☃xxxxx) * -5.0
+                  EnumParticleTypes.PORTAL, d3 + Math.cos(d14) * 5.0, d4 - 0.4, d5 + Math.sin(d14) * 5.0, Math.cos(d14) * -5.0, 0.0, Math.sin(d14) * -5.0
                );
                this.spawnParticle(
-                  EnumParticleTypes.PORTAL,
-                  ☃xx + Math.cos(☃xxxxx) * 5.0,
-                  ☃xxx - 0.4,
-                  ☃xxxx + Math.sin(☃xxxxx) * 5.0,
-                  Math.cos(☃xxxxx) * -7.0,
-                  0.0,
-                  Math.sin(☃xxxxx) * -7.0
+                  EnumParticleTypes.PORTAL, d3 + Math.cos(d14) * 5.0, d4 - 0.4, d5 + Math.sin(d14) * 5.0, Math.cos(d14) * -7.0, 0.0, Math.sin(d14) * -7.0
                );
             }
-            break;
+
+            return;
          case 2004:
-            for (int ☃xx = 0; ☃xx < 20; ☃xx++) {
-               double ☃xxx = ☃.getX() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               double ☃xxxx = ☃.getY() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               double ☃xxxxx = ☃.getZ() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               this.world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, ☃xxx, ☃xxxx, ☃xxxxx, 0.0, 0.0, 0.0, new int[0]);
-               this.world.spawnParticle(EnumParticleTypes.FLAME, ☃xxx, ☃xxxx, ☃xxxxx, 0.0, 0.0, 0.0, new int[0]);
+            for (int i3 = 0; i3 < 20; i3++) {
+               double d17 = blockPosIn.getX() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               double d20 = blockPosIn.getY() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               double d23 = blockPosIn.getZ() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               this.world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, d17, d20, d23, 0.0, 0.0, 0.0, new int[0]);
+               this.world.spawnParticle(EnumParticleTypes.FLAME, d17, d20, d23, 0.0, 0.0, 0.0, new int[0]);
             }
-            break;
+
+            return;
          case 2005:
-            ItemDye.spawnBonemealParticles(this.world, ☃, ☃);
+            ItemDye.spawnBonemealParticles(this.world, blockPosIn, data);
             break;
          case 2006:
-            for (int ☃x = 0; ☃x < 200; ☃x++) {
-               float ☃xx = ☃.nextFloat() * 4.0F;
-               float ☃xxx = ☃.nextFloat() * (float) (Math.PI * 2);
-               double ☃xxxx = MathHelper.cos(☃xxx) * ☃xx;
-               double ☃xxxxx = 0.01 + ☃.nextDouble() * 0.5;
-               double ☃xxxxxx = MathHelper.sin(☃xxx) * ☃xx;
-               Particle ☃xxxxxxx = this.spawnParticle0(
+            for (int i2 = 0; i2 < 200; i2++) {
+               float f2 = random.nextFloat() * 4.0F;
+               float f3 = random.nextFloat() * (float) (Math.PI * 2);
+               double d6 = MathHelper.cos(f3) * f2;
+               double d7 = 0.01 + random.nextDouble() * 0.5;
+               double d8 = MathHelper.sin(f3) * f2;
+               Particle particle = this.spawnParticle0(
                   EnumParticleTypes.DRAGON_BREATH.getParticleID(),
                   false,
-                  ☃.getX() + ☃xxxx * 0.1,
-                  ☃.getY() + 0.3,
-                  ☃.getZ() + ☃xxxxxx * 0.1,
-                  ☃xxxx,
-                  ☃xxxxx,
-                  ☃xxxxxx
+                  blockPosIn.getX() + d6 * 0.1,
+                  blockPosIn.getY() + 0.3,
+                  blockPosIn.getZ() + d8 * 0.1,
+                  d6,
+                  d7,
+                  d8
                );
-               if (☃xxxxxxx != null) {
-                  ☃xxxxxxx.multiplyVelocity(☃xx);
+               if (particle != null) {
+                  particle.multiplyVelocity(f2);
                }
             }
 
             this.world
-               .playSound(☃, SoundEvents.ENTITY_ENDERDRAGON_FIREBALL_EPLD, SoundCategory.HOSTILE, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
+               .playSound(
+                  blockPosIn, SoundEvents.ENTITY_ENDERDRAGON_FIREBALL_EPLD, SoundCategory.HOSTILE, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false
+               );
             break;
          case 3000:
-            this.world.spawnParticle(EnumParticleTypes.EXPLOSION_HUGE, true, ☃.getX() + 0.5, ☃.getY() + 0.5, ☃.getZ() + 0.5, 0.0, 0.0, 0.0, new int[0]);
+            this.world
+               .spawnParticle(
+                  EnumParticleTypes.EXPLOSION_HUGE, true, blockPosIn.getX() + 0.5, blockPosIn.getY() + 0.5, blockPosIn.getZ() + 0.5, 0.0, 0.0, 0.0, new int[0]
+               );
             this.world
                .playSound(
-                  ☃,
+                  blockPosIn,
                   SoundEvents.BLOCK_END_GATEWAY_SPAWN,
                   SoundCategory.BLOCKS,
                   10.0F,
@@ -2489,23 +3091,26 @@ public void playEvent(EntityPlayer var1, int var2, BlockPos var3, int var4) {
                );
             break;
          case 3001:
-            this.world.playSound(☃, SoundEvents.ENTITY_ENDERDRAGON_GROWL, SoundCategory.HOSTILE, 64.0F, 0.8F + this.world.rand.nextFloat() * 0.3F, false);
+            this.world
+               .playSound(blockPosIn, SoundEvents.ENTITY_ENDERDRAGON_GROWL, SoundCategory.HOSTILE, 64.0F, 0.8F + this.world.rand.nextFloat() * 0.3F, false);
       }
    }
 
-   @Override
-   public void sendBlockBreakProgress(int var1, BlockPos var2, int var3) {
-      if (☃ >= 0 && ☃ < 10) {
-         DestroyBlockProgress ☃ = this.damagedBlocks.get(☃);
-         if (☃ == null || ☃.getPosition().getX() != ☃.getX() || ☃.getPosition().getY() != ☃.getY() || ☃.getPosition().getZ() != ☃.getZ()) {
-            ☃ = new DestroyBlockProgress(☃, ☃);
-            this.damagedBlocks.put(☃, ☃);
+   public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress) {
+      if (progress >= 0 && progress < 10) {
+         DestroyBlockProgress destroyblockprogress = this.damagedBlocks.get(breakerId);
+         if (destroyblockprogress == null
+            || destroyblockprogress.getPosition().getX() != pos.getX()
+            || destroyblockprogress.getPosition().getY() != pos.getY()
+            || destroyblockprogress.getPosition().getZ() != pos.getZ()) {
+            destroyblockprogress = new DestroyBlockProgress(breakerId, pos);
+            this.damagedBlocks.put(breakerId, destroyblockprogress);
          }
 
-         ☃.setPartialBlockDamage(☃);
-         ☃.setCloudUpdateTick(this.cloudTickCounter);
+         destroyblockprogress.setPartialBlockDamage(progress);
+         destroyblockprogress.setCloudUpdateTick(this.cloudTickCounter);
       } else {
-         this.damagedBlocks.remove(☃);
+         this.damagedBlocks.remove(breakerId);
       }
    }
 
@@ -2517,31 +3122,116 @@ public void setDisplayListEntitiesDirty() {
       this.displayListEntitiesDirty = true;
    }
 
-   public void updateTileEntities(Collection<TileEntity> var1, Collection<TileEntity> var2) {
+   public void resetClouds() {
+      this.cloudRenderer.reset();
+   }
+
+   public int getCountRenderers() {
+      return this.viewFrustum.renderChunks.length;
+   }
+
+   public int getCountActiveRenderers() {
+      return this.renderInfos.size();
+   }
+
+   public int getCountEntitiesRendered() {
+      return this.countEntitiesRendered;
+   }
+
+   public int getCountTileEntitiesRendered() {
+      return this.countTileEntitiesRendered;
+   }
+
+   public int getCountLoadedChunks() {
+      if (this.world == null) {
+         return 0;
+      } else {
+         IChunkProvider chunkProvider = this.world.getChunkProvider();
+         if (chunkProvider == null) {
+            return 0;
+         } else {
+            if (chunkProvider != this.worldChunkProvider) {
+               this.worldChunkProvider = chunkProvider;
+               this.worldChunkProviderMap = (Long2ObjectMap<Chunk>)Reflector.getFieldValue(chunkProvider, Reflector.ChunkProviderClient_chunkMapping);
+            }
+
+            return this.worldChunkProviderMap == null ? 0 : this.worldChunkProviderMap.size();
+         }
+      }
+   }
+
+   public int getCountChunksToUpdate() {
+      return this.chunksToUpdate.size();
+   }
+
+   public RenderChunk getRenderChunk(BlockPos pos) {
+      return this.viewFrustum.getRenderChunk(pos);
+   }
+
+   public WorldClient getWorld() {
+      return this.world;
+   }
+
+   private void clearRenderInfos() {
+      if (renderEntitiesCounter > 0) {
+         this.renderInfos = new ArrayList<>(this.renderInfos.size() + 16);
+         this.renderInfosEntities = new ArrayList(this.renderInfosEntities.size() + 16);
+         this.renderInfosTileEntities = new ArrayList(this.renderInfosTileEntities.size() + 16);
+      } else {
+         this.renderInfos.clear();
+         this.renderInfosEntities.clear();
+         this.renderInfosTileEntities.clear();
+      }
+   }
+
+   public void onPlayerPositionSet() {
+      if (this.firstWorldLoad) {
+         this.loadRenderers();
+         this.firstWorldLoad = false;
+      }
+   }
+
+   public void pauseChunkUpdates() {
+      if (this.renderDispatcher != null) {
+         this.renderDispatcher.pauseChunkUpdates();
+      }
+   }
+
+   public void resumeChunkUpdates() {
+      if (this.renderDispatcher != null) {
+         this.renderDispatcher.resumeChunkUpdates();
+      }
+   }
+
+   public void updateTileEntities(Collection<TileEntity> tileEntitiesToRemove, Collection<TileEntity> tileEntitiesToAdd) {
       synchronized (this.setTileEntities) {
-         this.setTileEntities.removeAll(☃);
-         this.setTileEntities.addAll(☃);
+         this.setTileEntities.removeAll(tileEntitiesToRemove);
+         this.setTileEntities.addAll(tileEntitiesToAdd);
       }
    }
 
-   class ContainerLocalRenderInformation {
+   public static class ContainerLocalRenderInformation {
       final RenderChunk renderChunk;
-      final EnumFacing facing;
-      byte setFacing;
-      final int counter;
+      EnumFacing facing;
+      int setFacing;
+
+      public ContainerLocalRenderInformation(RenderChunk renderChunkIn, EnumFacing facingIn, int setFacingIn) {
+         this.renderChunk = renderChunkIn;
+         this.facing = facingIn;
+         this.setFacing = setFacingIn;
+      }
 
-      private ContainerLocalRenderInformation(RenderChunk var2, EnumFacing var3, @Nullable int var4) {
-         this.renderChunk = ☃;
-         this.facing = ☃;
-         this.counter = ☃;
+      public void setDirection(byte p_189561_1_, EnumFacing p_189561_2_) {
+         this.setFacing = this.setFacing | p_189561_1_ | 1 << p_189561_2_.ordinal();
       }
 
-      public void setDirection(byte var1, EnumFacing var2) {
-         this.setFacing = (byte)(this.setFacing | ☃ | 1 << ☃.ordinal());
+      public boolean hasDirection(EnumFacing p_189560_1_) {
+         return (this.setFacing & 1 << p_189560_1_.ordinal()) > 0;
       }
 
-      public boolean hasDirection(EnumFacing var1) {
-         return (this.setFacing & 1 << ☃.ordinal()) > 0;
+      private void initialize(EnumFacing facingIn, int setFacingIn) {
+         this.facing = facingIn;
+         this.setFacing = setFacingIn;
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/RenderItem.java b/patches/net/minecraft/client/renderer/RenderItem.java
index a65ac2e..9c0c632 100644
--- a/patches/net/minecraft/client/renderer/RenderItem.java
+++ b/patches/net/minecraft/client/renderer/RenderItem.java
@@ -3,23 +3,11 @@
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
-import net.minecraft.block.BlockDirt;
-import net.minecraft.block.BlockDoublePlant;
-import net.minecraft.block.BlockFlower;
-import net.minecraft.block.BlockHugeMushroom;
-import net.minecraft.block.BlockPlanks;
-import net.minecraft.block.BlockPrismarine;
-import net.minecraft.block.BlockQuartz;
-import net.minecraft.block.BlockRedSandstone;
-import net.minecraft.block.BlockSand;
-import net.minecraft.block.BlockSandStone;
-import net.minecraft.block.BlockSilverfish;
-import net.minecraft.block.BlockStone;
-import net.minecraft.block.BlockStoneBrick;
-import net.minecraft.block.BlockStoneSlab;
-import net.minecraft.block.BlockStoneSlabNew;
-import net.minecraft.block.BlockTallGrass;
-import net.minecraft.block.BlockWall;
+import net.minecraft.block.BlockDirt.DirtType;
+import net.minecraft.block.BlockDoublePlant.EnumPlantType;
+import net.minecraft.block.BlockFlower.EnumFlowerType;
+import net.minecraft.block.BlockWall.EnumType;
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
@@ -29,6 +17,7 @@
 import net.minecraft.client.renderer.block.model.ItemTransformVec3f;
 import net.minecraft.client.renderer.block.model.ModelManager;
 import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.color.ItemColors;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.texture.TextureMap;
@@ -45,15 +34,22 @@
 import net.minecraft.init.Items;
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.item.Item;
-import net.minecraft.item.ItemFishFood;
 import net.minecraft.item.ItemStack;
-import net.minecraft.tileentity.TileEntityStructure;
+import net.minecraft.item.ItemFishFood.FishType;
+import net.minecraft.tileentity.TileEntityStructure.Mode;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3i;
 import net.minecraft.world.World;
+import net.optifine.CustomColors;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
 
 public class RenderItem implements IResourceManagerReloadListener {
    private static final ResourceLocation RES_ITEM_GLINT = new ResourceLocation("textures/misc/enchanted_item_glint.png");
@@ -62,67 +58,112 @@ public class RenderItem implements IResourceManagerReloadListener {
    private final ItemModelMesher itemModelMesher;
    private final TextureManager textureManager;
    private final ItemColors itemColors;
+   private ResourceLocation modelLocation = null;
+   private boolean renderItemGui = false;
+   public ModelManager modelManager = null;
+   private boolean renderModelHasEmissive = false;
+   private boolean renderModelEmissive = false;
+   private boolean forgeAllowEmissiveItems = Reflector.getFieldValueBoolean(Reflector.ForgeModContainer_allowEmissiveItems, false);
+
+   public RenderItem(TextureManager p_i46552_1_, ModelManager p_i46552_2_, ItemColors p_i46552_3_) {
+      this.textureManager = p_i46552_1_;
+      this.modelManager = p_i46552_2_;
+      if (Reflector.ItemModelMesherForge_Constructor.exists()) {
+         this.itemModelMesher = (ItemModelMesher)Reflector.newInstance(Reflector.ItemModelMesherForge_Constructor, new Object[]{p_i46552_2_});
+      } else {
+         this.itemModelMesher = new ItemModelMesher(p_i46552_2_);
+      }
 
-   public RenderItem(TextureManager var1, ModelManager var2, ItemColors var3) {
-      this.textureManager = ☃;
-      this.itemModelMesher = new ItemModelMesher(☃);
       this.registerItems();
-      this.itemColors = ☃;
+      this.itemColors = p_i46552_3_;
    }
 
    public ItemModelMesher getItemModelMesher() {
       return this.itemModelMesher;
    }
 
-   protected void registerItem(Item var1, int var2, String var3) {
-      this.itemModelMesher.register(☃, ☃, new ModelResourceLocation(☃, "inventory"));
+   protected void registerItem(Item itm, int subType, String identifier) {
+      this.itemModelMesher.register(itm, subType, new ModelResourceLocation(identifier, "inventory"));
    }
 
-   protected void registerBlock(Block var1, int var2, String var3) {
-      this.registerItem(Item.getItemFromBlock(☃), ☃, ☃);
+   protected void registerBlock(Block blk, int subType, String identifier) {
+      this.registerItem(Item.getItemFromBlock(blk), subType, identifier);
    }
 
-   private void registerBlock(Block var1, String var2) {
-      this.registerBlock(☃, 0, ☃);
+   private void registerBlock(Block blk, String identifier) {
+      this.registerBlock(blk, 0, identifier);
    }
 
-   private void registerItem(Item var1, String var2) {
-      this.registerItem(☃, 0, ☃);
+   private void registerItem(Item itm, String identifier) {
+      this.registerItem(itm, 0, identifier);
    }
 
-   private void renderModel(IBakedModel var1, ItemStack var2) {
-      this.renderModel(☃, -1, ☃);
+   private void renderModel(IBakedModel model, ItemStack stack) {
+      this.renderModel(model, -1, stack);
    }
 
-   private void renderModel(IBakedModel var1, int var2) {
-      this.renderModel(☃, ☃, ItemStack.EMPTY);
+   public void renderModel(IBakedModel model, int color) {
+      this.renderModel(model, color, ItemStack.EMPTY);
    }
 
-   private void renderModel(IBakedModel var1, int var2, ItemStack var3) {
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
-      ☃x.begin(7, DefaultVertexFormats.ITEM);
+   private void renderModel(IBakedModel model, int color, ItemStack stack) {
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      boolean renderTextureMap = Minecraft.getMinecraft().getTextureMapBlocks().isTextureBound();
+      boolean multiTexture = Config.isMultiTexture() && renderTextureMap;
+      if (multiTexture) {
+         bufferbuilder.setBlockLayer(BlockRenderLayer.SOLID);
+      }
+
+      bufferbuilder.begin(7, DefaultVertexFormats.ITEM);
 
-      for (EnumFacing ☃xx : EnumFacing.values()) {
-         this.renderQuads(☃x, ☃.getQuads(null, ☃xx, 0L), ☃, ☃);
+      for (EnumFacing enumfacing : EnumFacing.VALUES) {
+         this.renderQuads(bufferbuilder, model.getQuads((IBlockState)null, enumfacing, 0L), color, stack);
       }
 
-      this.renderQuads(☃x, ☃.getQuads(null, null, 0L), ☃, ☃);
-      ☃.draw();
+      this.renderQuads(bufferbuilder, model.getQuads((IBlockState)null, (EnumFacing)null, 0L), color, stack);
+      tessellator.draw();
+      if (multiTexture) {
+         bufferbuilder.setBlockLayer(null);
+         GlStateManager.bindCurrentTexture();
+      }
    }
 
-   public void renderItem(ItemStack var1, IBakedModel var2) {
-      if (!☃.isEmpty()) {
+   public void renderItem(ItemStack stack, IBakedModel model) {
+      if (!stack.isEmpty()) {
          GlStateManager.pushMatrix();
          GlStateManager.translate(-0.5F, -0.5F, -0.5F);
-         if (☃.isBuiltInRenderer()) {
+         if (model.isBuiltInRenderer()) {
             GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
             GlStateManager.enableRescaleNormal();
-            TileEntityItemStackRenderer.instance.renderByItem(☃);
+            if (Reflector.ForgeItem_getTileEntityItemStackRenderer.exists()) {
+               TileEntityItemStackRenderer teisr = (TileEntityItemStackRenderer)Reflector.call(
+                  stack.getItem(), Reflector.ForgeItem_getTileEntityItemStackRenderer, new Object[0]
+               );
+               teisr.renderByItem(stack);
+            } else {
+               TileEntityItemStackRenderer.instance.renderByItem(stack);
+            }
          } else {
-            this.renderModel(☃, ☃);
-            if (☃.hasEffect()) {
-               this.renderEffect(☃);
+            if (Config.isCustomItems()) {
+               model = CustomItems.getCustomItemModel(stack, model, this.modelLocation, false);
+               this.modelLocation = null;
+            }
+
+            this.renderModelHasEmissive = false;
+            this.renderModel(model, stack);
+            if (this.renderModelHasEmissive) {
+               float lightMapX = OpenGlHelper.lastBrightnessX;
+               float lightMapY = OpenGlHelper.lastBrightnessY;
+               OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240.0F, lightMapY);
+               this.renderModelEmissive = true;
+               this.renderModel(model, stack);
+               this.renderModelEmissive = false;
+               OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lightMapX, lightMapY);
+            }
+
+            if (stack.hasEffect() && (!Config.isCustomItems() || !CustomItems.renderCustomEffect(this, stack, model))) {
+               this.renderEffect(model);
             }
          }
 
@@ -130,98 +171,149 @@ public void renderItem(ItemStack var1, IBakedModel var2) {
       }
    }
 
-   private void renderEffect(IBakedModel var1) {
-      GlStateManager.depthMask(false);
-      GlStateManager.depthFunc(514);
-      GlStateManager.disableLighting();
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
-      this.textureManager.bindTexture(RES_ITEM_GLINT);
-      GlStateManager.matrixMode(5890);
-      GlStateManager.pushMatrix();
-      GlStateManager.scale(8.0F, 8.0F, 8.0F);
-      float ☃ = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F / 8.0F;
-      GlStateManager.translate(☃, 0.0F, 0.0F);
-      GlStateManager.rotate(-50.0F, 0.0F, 0.0F, 1.0F);
-      this.renderModel(☃, -8372020);
-      GlStateManager.popMatrix();
-      GlStateManager.pushMatrix();
-      GlStateManager.scale(8.0F, 8.0F, 8.0F);
-      float ☃x = (float)(Minecraft.getSystemTime() % 4873L) / 4873.0F / 8.0F;
-      GlStateManager.translate(-☃x, 0.0F, 0.0F);
-      GlStateManager.rotate(10.0F, 0.0F, 0.0F, 1.0F);
-      this.renderModel(☃, -8372020);
-      GlStateManager.popMatrix();
-      GlStateManager.matrixMode(5888);
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
-      GlStateManager.enableLighting();
-      GlStateManager.depthFunc(515);
-      GlStateManager.depthMask(true);
-      this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+   private void renderEffect(IBakedModel model) {
+      if (!Config.isCustomItems() || CustomItems.isUseGlint()) {
+         if (!Config.isShaders() || !Shaders.isShadowPass) {
+            GlStateManager.depthMask(false);
+            GlStateManager.depthFunc(514);
+            GlStateManager.disableLighting();
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
+            this.textureManager.bindTexture(RES_ITEM_GLINT);
+            if (Config.isShaders() && !this.renderItemGui) {
+               ShadersRender.renderEnchantedGlintBegin();
+            }
+
+            GlStateManager.matrixMode(5890);
+            GlStateManager.pushMatrix();
+            GlStateManager.scale(8.0F, 8.0F, 8.0F);
+            float f = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F / 8.0F;
+            GlStateManager.translate(f, 0.0F, 0.0F);
+            GlStateManager.rotate(-50.0F, 0.0F, 0.0F, 1.0F);
+            this.renderModel(model, -8372020);
+            GlStateManager.popMatrix();
+            GlStateManager.pushMatrix();
+            GlStateManager.scale(8.0F, 8.0F, 8.0F);
+            float f1 = (float)(Minecraft.getSystemTime() % 4873L) / 4873.0F / 8.0F;
+            GlStateManager.translate(-f1, 0.0F, 0.0F);
+            GlStateManager.rotate(10.0F, 0.0F, 0.0F, 1.0F);
+            this.renderModel(model, -8372020);
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5888);
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+            GlStateManager.enableLighting();
+            GlStateManager.depthFunc(515);
+            GlStateManager.depthMask(true);
+            this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+            if (Config.isShaders() && !this.renderItemGui) {
+               ShadersRender.renderEnchantedGlintEnd();
+            }
+         }
+      }
    }
 
-   private void putQuadNormal(BufferBuilder var1, BakedQuad var2) {
-      Vec3i ☃ = ☃.getFace().getDirectionVec();
-      ☃.putNormal(☃.getX(), ☃.getY(), ☃.getZ());
+   private void putQuadNormal(BufferBuilder renderer, BakedQuad quad) {
+      Vec3i vec3i = quad.getFace().getDirectionVec();
+      renderer.putNormal(vec3i.getX(), vec3i.getY(), vec3i.getZ());
    }
 
-   private void renderQuad(BufferBuilder var1, BakedQuad var2, int var3) {
-      ☃.addVertexData(☃.getVertexData());
-      ☃.putColor4(☃);
-      this.putQuadNormal(☃, ☃);
+   private void renderQuad(BufferBuilder renderer, BakedQuad quad, int color) {
+      if (this.renderModelEmissive) {
+         if (quad.getQuadEmissive() == null) {
+            return;
+         }
+
+         quad = quad.getQuadEmissive();
+      } else if (quad.getQuadEmissive() != null) {
+         this.renderModelHasEmissive = true;
+      }
+
+      if (renderer.isMultiTexture()) {
+         renderer.addVertexData(quad.getVertexDataSingle());
+      } else {
+         renderer.addVertexData(quad.getVertexData());
+      }
+
+      renderer.putSprite(quad.getSprite());
+      if (Reflector.ForgeHooksClient_putQuadColor.exists()) {
+         Reflector.call(Reflector.ForgeHooksClient_putQuadColor, new Object[]{renderer, quad, color});
+      } else {
+         renderer.putColor4(color);
+      }
+
+      this.putQuadNormal(renderer, quad);
    }
 
-   private void renderQuads(BufferBuilder var1, List<BakedQuad> var2, int var3, ItemStack var4) {
-      boolean ☃ = ☃ == -1 && !☃.isEmpty();
-      int ☃x = 0;
+   private void renderQuads(BufferBuilder renderer, List<BakedQuad> quads, int color, ItemStack stack) {
+      boolean flag = color == -1 && !stack.isEmpty();
+      int i = 0;
+
+      for (int j = quads.size(); i < j; i++) {
+         BakedQuad bakedquad = quads.get(i);
+         int k = color;
+         if (flag && bakedquad.hasTintIndex()) {
+            k = this.itemColors.colorMultiplier(stack, bakedquad.getTintIndex());
+            if (Config.isCustomColors()) {
+               k = CustomColors.getColorFromItemStack(stack, bakedquad.getTintIndex(), k);
+            }
 
-      for (int ☃xx = ☃.size(); ☃x < ☃xx; ☃x++) {
-         BakedQuad ☃xxx = ☃.get(☃x);
-         int ☃xxxx = ☃;
-         if (☃ && ☃xxx.hasTintIndex()) {
-            ☃xxxx = this.itemColors.colorMultiplier(☃, ☃xxx.getTintIndex());
             if (EntityRenderer.anaglyphEnable) {
-               ☃xxxx = TextureUtil.anaglyphColor(☃xxxx);
+               k = TextureUtil.anaglyphColor(k);
             }
 
-            ☃xxxx |= -16777216;
+            k |= -16777216;
          }
 
-         this.renderQuad(☃, ☃xxx, ☃xxxx);
+         this.renderQuad(renderer, bakedquad, k);
       }
    }
 
-   public boolean shouldRenderItemIn3D(ItemStack var1) {
-      IBakedModel ☃ = this.itemModelMesher.getItemModel(☃);
-      return ☃ == null ? false : ☃.isGui3d();
+   public boolean shouldRenderItemIn3D(ItemStack stack) {
+      IBakedModel ibakedmodel = this.itemModelMesher.getItemModel(stack);
+      return ibakedmodel == null ? false : ibakedmodel.isGui3d();
    }
 
-   public void renderItem(ItemStack var1, ItemCameraTransforms.TransformType var2) {
-      if (!☃.isEmpty()) {
-         IBakedModel ☃ = this.getItemModelWithOverrides(☃, null, null);
-         this.renderItemModel(☃, ☃, ☃, false);
+   public void renderItem(ItemStack stack, TransformType cameraTransformType) {
+      if (!stack.isEmpty()) {
+         IBakedModel ibakedmodel = this.getItemModelWithOverrides(stack, (World)null, (EntityLivingBase)null);
+         this.renderItemModel(stack, ibakedmodel, cameraTransformType, false);
       }
    }
 
-   public IBakedModel getItemModelWithOverrides(ItemStack var1, @Nullable World var2, @Nullable EntityLivingBase var3) {
-      IBakedModel ☃ = this.itemModelMesher.getItemModel(☃);
-      Item ☃x = ☃.getItem();
-      if (☃x != null && ☃x.hasCustomProperties()) {
-         ResourceLocation ☃xx = ☃.getOverrides().applyOverride(☃, ☃, ☃);
-         return ☃xx == null ? ☃ : this.itemModelMesher.getModelManager().getModel(new ModelResourceLocation(☃xx, "inventory"));
+   public IBakedModel getItemModelWithOverrides(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entitylivingbaseIn) {
+      IBakedModel ibakedmodel = this.itemModelMesher.getItemModel(stack);
+      Item item = stack.getItem();
+      if (Config.isCustomItems()) {
+         if (item != null && item.hasCustomProperties()) {
+            this.modelLocation = ibakedmodel.getOverrides().applyOverride(stack, worldIn, entitylivingbaseIn);
+         }
+
+         IBakedModel modelFull = CustomItems.getCustomItemModel(stack, ibakedmodel, this.modelLocation, true);
+         if (modelFull != ibakedmodel) {
+            return modelFull;
+         }
+      }
+
+      if (Reflector.ModelLoader_getInventoryVariant.exists()) {
+         return ibakedmodel.getOverrides().handleItemState(ibakedmodel, stack, worldIn, entitylivingbaseIn);
+      } else if (item != null && item.hasCustomProperties()) {
+         ResourceLocation resourcelocation = ibakedmodel.getOverrides().applyOverride(stack, worldIn, entitylivingbaseIn);
+         return resourcelocation == null
+            ? ibakedmodel
+            : this.itemModelMesher.getModelManager().getModel(new ModelResourceLocation(resourcelocation, "inventory"));
       } else {
-         return ☃;
+         return ibakedmodel;
       }
    }
 
-   public void renderItem(ItemStack var1, EntityLivingBase var2, ItemCameraTransforms.TransformType var3, boolean var4) {
-      if (!☃.isEmpty() && ☃ != null) {
-         IBakedModel ☃ = this.getItemModelWithOverrides(☃, ☃.world, ☃);
-         this.renderItemModel(☃, ☃, ☃, ☃);
+   public void renderItem(ItemStack stack, EntityLivingBase entitylivingbaseIn, TransformType transform, boolean leftHanded) {
+      if (!stack.isEmpty() && entitylivingbaseIn != null) {
+         IBakedModel ibakedmodel = this.getItemModelWithOverrides(stack, entitylivingbaseIn.world, entitylivingbaseIn);
+         this.renderItemModel(stack, ibakedmodel, transform, leftHanded);
       }
    }
 
-   protected void renderItemModel(ItemStack var1, IBakedModel var2, ItemCameraTransforms.TransformType var3, boolean var4) {
-      if (!☃.isEmpty()) {
+   protected void renderItemModel(ItemStack stack, IBakedModel bakedmodel, TransformType transform, boolean leftHanded) {
+      if (!stack.isEmpty()) {
          this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
          this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
@@ -235,13 +327,19 @@ protected void renderItemModel(ItemStack var1, IBakedModel var2, ItemCameraTrans
             GlStateManager.DestFactor.ZERO
          );
          GlStateManager.pushMatrix();
-         ItemCameraTransforms ☃ = ☃.getItemCameraTransforms();
-         ItemCameraTransforms.applyTransformSide(☃.getTransform(☃), ☃);
-         if (this.isThereOneNegativeScale(☃.getTransform(☃))) {
-            GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
+         if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
+            bakedmodel = (IBakedModel)Reflector.call(Reflector.ForgeHooksClient_handleCameraTransforms, new Object[]{bakedmodel, transform, leftHanded});
+         } else {
+            ItemCameraTransforms itemcameratransforms = bakedmodel.getItemCameraTransforms();
+            ItemCameraTransforms.applyTransformSide(itemcameratransforms.getTransform(transform), leftHanded);
+            if (this.isThereOneNegativeScale(itemcameratransforms.getTransform(transform))) {
+               GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
+            }
          }
 
-         this.renderItem(☃, ☃);
+         CustomItems.setRenderOffHand(leftHanded);
+         this.renderItem(stack, bakedmodel);
+         CustomItems.setRenderOffHand(false);
          GlStateManager.cullFace(GlStateManager.CullFace.BACK);
          GlStateManager.popMatrix();
          GlStateManager.disableRescaleNormal();
@@ -251,15 +349,16 @@ protected void renderItemModel(ItemStack var1, IBakedModel var2, ItemCameraTrans
       }
    }
 
-   private boolean isThereOneNegativeScale(ItemTransformVec3f var1) {
-      return ☃.scale.x < 0.0F ^ ☃.scale.y < 0.0F ^ ☃.scale.z < 0.0F;
+   private boolean isThereOneNegativeScale(ItemTransformVec3f itemTranformVec) {
+      return itemTranformVec.scale.x < 0.0F ^ itemTranformVec.scale.y < 0.0F ^ itemTranformVec.scale.z < 0.0F;
    }
 
-   public void renderItemIntoGUI(ItemStack var1, int var2, int var3) {
-      this.renderItemModelIntoGUI(☃, ☃, ☃, this.getItemModelWithOverrides(☃, null, null));
+   public void renderItemIntoGUI(ItemStack stack, int x, int y) {
+      this.renderItemModelIntoGUI(stack, x, y, this.getItemModelWithOverrides(stack, (World)null, (EntityLivingBase)null));
    }
 
-   protected void renderItemModelIntoGUI(ItemStack var1, int var2, int var3, IBakedModel var4) {
+   protected void renderItemModelIntoGUI(ItemStack stack, int x, int y, IBakedModel bakedmodel) {
+      this.renderItemGui = true;
       GlStateManager.pushMatrix();
       this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
@@ -269,100 +368,133 @@ protected void renderItemModelIntoGUI(ItemStack var1, int var2, int var3, IBaked
       GlStateManager.enableBlend();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      this.setupGuiTransform(☃, ☃, ☃.isGui3d());
-      ☃.getItemCameraTransforms().applyTransform(ItemCameraTransforms.TransformType.GUI);
-      this.renderItem(☃, ☃);
+      this.setupGuiTransform(x, y, bakedmodel.isGui3d());
+      if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
+         bakedmodel = (IBakedModel)Reflector.call(Reflector.ForgeHooksClient_handleCameraTransforms, new Object[]{bakedmodel, TransformType.GUI, false});
+      } else {
+         bakedmodel.getItemCameraTransforms().applyTransform(TransformType.GUI);
+      }
+
+      this.renderItem(stack, bakedmodel);
       GlStateManager.disableAlpha();
       GlStateManager.disableRescaleNormal();
       GlStateManager.disableLighting();
       GlStateManager.popMatrix();
       this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      this.renderItemGui = false;
    }
 
-   private void setupGuiTransform(int var1, int var2, boolean var3) {
-      GlStateManager.translate((float)☃, (float)☃, 100.0F + this.zLevel);
+   private void setupGuiTransform(int xPosition, int yPosition, boolean isGui3d) {
+      GlStateManager.translate((float)xPosition, (float)yPosition, 100.0F + this.zLevel);
       GlStateManager.translate(8.0F, 8.0F, 0.0F);
       GlStateManager.scale(1.0F, -1.0F, 1.0F);
       GlStateManager.scale(16.0F, 16.0F, 16.0F);
-      if (☃) {
+      if (isGui3d) {
          GlStateManager.enableLighting();
       } else {
          GlStateManager.disableLighting();
       }
    }
 
-   public void renderItemAndEffectIntoGUI(ItemStack var1, int var2, int var3) {
-      this.renderItemAndEffectIntoGUI(Minecraft.getMinecraft().player, ☃, ☃, ☃);
+   public void renderItemAndEffectIntoGUI(ItemStack stack, int xPosition, int yPosition) {
+      this.renderItemAndEffectIntoGUI(Minecraft.getMinecraft().player, stack, xPosition, yPosition);
    }
 
-   public void renderItemAndEffectIntoGUI(@Nullable EntityLivingBase var1, final ItemStack var2, int var3, int var4) {
-      if (!☃.isEmpty()) {
+   public void renderItemAndEffectIntoGUI(@Nullable EntityLivingBase p_184391_1_, final ItemStack p_184391_2_, int p_184391_3_, int p_184391_4_) {
+      if (!p_184391_2_.isEmpty()) {
          this.zLevel += 50.0F;
 
          try {
-            this.renderItemModelIntoGUI(☃, ☃, ☃, this.getItemModelWithOverrides(☃, null, ☃));
+            this.renderItemModelIntoGUI(p_184391_2_, p_184391_3_, p_184391_4_, this.getItemModelWithOverrides(p_184391_2_, (World)null, p_184391_1_));
          } catch (Throwable var8) {
-            CrashReport ☃ = CrashReport.makeCrashReport(var8, "Rendering item");
-            CrashReportCategory ☃x = ☃.makeCategory("Item being rendered");
-            ☃x.addDetail("Item Type", new ICrashReportDetail<String>() {
+            CrashReport crashreport = CrashReport.makeCrashReport(var8, "Rendering item");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Item being rendered");
+            crashreportcategory.addDetail("Item Type", new ICrashReportDetail<String>() {
                public String call() throws Exception {
-                  return String.valueOf(☃.getItem());
+                  return String.valueOf(p_184391_2_.getItem());
                }
             });
-            ☃x.addDetail("Item Aux", new ICrashReportDetail<String>() {
+            if (Reflector.IForgeRegistryEntry_Impl_getRegistryName.exists()) {
+               crashreportcategory.addDetail("Registry Name", ReflectorForge.getDetailItemRegistryName(p_184391_2_.getItem()));
+            }
+
+            crashreportcategory.addDetail("Item Aux", new ICrashReportDetail<String>() {
                public String call() throws Exception {
-                  return String.valueOf(☃.getMetadata());
+                  return String.valueOf(p_184391_2_.getMetadata());
                }
             });
-            ☃x.addDetail("Item NBT", new ICrashReportDetail<String>() {
+            crashreportcategory.addDetail("Item NBT", new ICrashReportDetail<String>() {
                public String call() throws Exception {
-                  return String.valueOf(☃.getTagCompound());
+                  return String.valueOf(p_184391_2_.getTagCompound());
                }
             });
-            ☃x.addDetail("Item Foil", new ICrashReportDetail<String>() {
+            crashreportcategory.addDetail("Item Foil", new ICrashReportDetail<String>() {
                public String call() throws Exception {
-                  return String.valueOf(☃.hasEffect());
+                  return String.valueOf(p_184391_2_.hasEffect());
                }
             });
-            throw new ReportedException(☃);
+            throw new ReportedException(crashreport);
          }
 
          this.zLevel -= 50.0F;
       }
    }
 
-   public void renderItemOverlays(FontRenderer var1, ItemStack var2, int var3, int var4) {
-      this.renderItemOverlayIntoGUI(☃, ☃, ☃, ☃, null);
+   public void renderItemOverlays(FontRenderer fr, ItemStack stack, int xPosition, int yPosition) {
+      this.renderItemOverlayIntoGUI(fr, stack, xPosition, yPosition, (String)null);
    }
 
-   public void renderItemOverlayIntoGUI(FontRenderer var1, ItemStack var2, int var3, int var4, @Nullable String var5) {
-      if (!☃.isEmpty()) {
-         if (☃.getCount() != 1 || ☃ != null) {
-            String ☃ = ☃ == null ? String.valueOf(☃.getCount()) : ☃;
+   public void renderItemOverlayIntoGUI(FontRenderer fr, ItemStack stack, int xPosition, int yPosition, @Nullable String text) {
+      if (!stack.isEmpty()) {
+         if (stack.getCount() != 1 || text != null) {
+            String s = text == null ? String.valueOf(stack.getCount()) : text;
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableBlend();
-            ☃.drawStringWithShadow(☃, ☃ + 19 - 2 - ☃.getStringWidth(☃), ☃ + 6 + 3, 16777215);
+            fr.drawStringWithShadow(s, xPosition + 19 - 2 - fr.getStringWidth(s), yPosition + 6 + 3, 16777215);
             GlStateManager.enableLighting();
             GlStateManager.enableDepth();
+            GlStateManager.enableBlend();
          }
 
-         if (☃.isItemDamaged()) {
+         if (ReflectorForge.isItemDamaged(stack)) {
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableTexture2D();
             GlStateManager.disableAlpha();
             GlStateManager.disableBlend();
-            Tessellator ☃ = Tessellator.getInstance();
-            BufferBuilder ☃x = ☃.getBuffer();
-            float ☃xx = ☃.getItemDamage();
-            float ☃xxx = ☃.getMaxDamage();
-            float ☃xxxx = Math.max(0.0F, (☃xxx - ☃xx) / ☃xxx);
-            int ☃xxxxx = Math.round(13.0F - ☃xx * 13.0F / ☃xxx);
-            int ☃xxxxxx = MathHelper.hsvToRGB(☃xxxx / 3.0F, 1.0F, 1.0F);
-            this.draw(☃x, ☃ + 2, ☃ + 13, 13, 2, 0, 0, 0, 255);
-            this.draw(☃x, ☃ + 2, ☃ + 13, ☃xxxxx, 1, ☃xxxxxx >> 16 & 0xFF, ☃xxxxxx >> 8 & 0xFF, ☃xxxxxx & 0xFF, 255);
+            Tessellator tessellator = Tessellator.getInstance();
+            BufferBuilder bufferbuilder = tessellator.getBuffer();
+            float f = stack.getItemDamage();
+            float f1 = stack.getMaxDamage();
+            float f2 = Math.max(0.0F, (f1 - f) / f1);
+            int i = Math.round(13.0F - f * 13.0F / f1);
+            int j = MathHelper.hsvToRGB(f2 / 3.0F, 1.0F, 1.0F);
+            if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
+               double health = Reflector.callDouble(stack.getItem(), Reflector.ForgeItem_getDurabilityForDisplay, new Object[]{stack});
+               int rgbfordisplay = Reflector.callInt(stack.getItem(), Reflector.ForgeItem_getRGBDurabilityForDisplay, new Object[]{stack});
+               i = Math.round(13.0F - (float)health * 13.0F);
+               j = rgbfordisplay;
+            }
+
+            if (Config.isCustomColors()) {
+               j = CustomColors.getDurabilityColor(f2, j);
+            }
+
+            if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
+               double health = Reflector.callDouble(stack.getItem(), Reflector.ForgeItem_getDurabilityForDisplay, new Object[]{stack});
+               int rgbfordisplay = Reflector.callInt(stack.getItem(), Reflector.ForgeItem_getRGBDurabilityForDisplay, new Object[]{stack});
+               i = Math.round(13.0F - (float)health * 13.0F);
+               j = rgbfordisplay;
+            }
+
+            if (Config.isCustomColors()) {
+               j = CustomColors.getDurabilityColor(f2, j);
+            }
+
+            this.draw(bufferbuilder, xPosition + 2, yPosition + 13, 13, 2, 0, 0, 0, 255);
+            this.draw(bufferbuilder, xPosition + 2, yPosition + 13, i, 1, j >> 16 & 0xFF, j >> 8 & 0xFF, j & 0xFF, 255);
             GlStateManager.enableBlend();
             GlStateManager.enableAlpha();
             GlStateManager.enableTexture2D();
@@ -370,15 +502,17 @@ public void renderItemOverlayIntoGUI(FontRenderer var1, ItemStack var2, int var3
             GlStateManager.enableDepth();
          }
 
-         EntityPlayerSP ☃ = Minecraft.getMinecraft().player;
-         float ☃x = ☃ == null ? 0.0F : ☃.getCooldownTracker().getCooldown(☃.getItem(), Minecraft.getMinecraft().getRenderPartialTicks());
-         if (☃x > 0.0F) {
+         EntityPlayerSP entityplayersp = Minecraft.getMinecraft().player;
+         float f3 = entityplayersp == null
+            ? 0.0F
+            : entityplayersp.getCooldownTracker().getCooldown(stack.getItem(), Minecraft.getMinecraft().getRenderPartialTicks());
+         if (f3 > 0.0F) {
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableTexture2D();
-            Tessellator ☃xx = Tessellator.getInstance();
-            BufferBuilder ☃xxx = ☃xx.getBuffer();
-            this.draw(☃xxx, ☃, ☃ + MathHelper.floor(16.0F * (1.0F - ☃x)), 16, MathHelper.ceil(16.0F * ☃x), 255, 255, 255, 127);
+            Tessellator tessellator1 = Tessellator.getInstance();
+            BufferBuilder bufferbuilder1 = tessellator1.getBuffer();
+            this.draw(bufferbuilder1, xPosition, yPosition + MathHelper.floor(16.0F * (1.0F - f3)), 16, MathHelper.ceil(16.0F * f3), 255, 255, 255, 127);
             GlStateManager.enableTexture2D();
             GlStateManager.enableLighting();
             GlStateManager.enableDepth();
@@ -386,12 +520,12 @@ public void renderItemOverlayIntoGUI(FontRenderer var1, ItemStack var2, int var3
       }
    }
 
-   private void draw(BufferBuilder var1, int var2, int var3, int var4, int var5, int var6, int var7, int var8, int var9) {
-      ☃.begin(7, DefaultVertexFormats.POSITION_COLOR);
-      ☃.pos(☃ + 0, ☃ + 0, 0.0).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃ + 0, ☃ + ☃, 0.0).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃ + ☃, ☃ + ☃, 0.0).color(☃, ☃, ☃, ☃).endVertex();
-      ☃.pos(☃ + ☃, ☃ + 0, 0.0).color(☃, ☃, ☃, ☃).endVertex();
+   private void draw(BufferBuilder renderer, int x, int y, int width, int height, int red, int green, int blue, int alpha) {
+      renderer.begin(7, DefaultVertexFormats.POSITION_COLOR);
+      renderer.pos(x + 0, y + 0, 0.0).color(red, green, blue, alpha).endVertex();
+      renderer.pos(x + 0, y + height, 0.0).color(red, green, blue, alpha).endVertex();
+      renderer.pos(x + width, y + height, 0.0).color(red, green, blue, alpha).endVertex();
+      renderer.pos(x + width, y + 0, 0.0).color(red, green, blue, alpha).endVertex();
       Tessellator.getInstance().draw();
    }
 
@@ -415,70 +549,70 @@ private void registerItems() {
       this.registerBlock(Blocks.CARPET, EnumDyeColor.SILVER.getMetadata(), "silver_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.WHITE.getMetadata(), "white_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.YELLOW.getMetadata(), "yellow_carpet");
-      this.registerBlock(Blocks.COBBLESTONE_WALL, BlockWall.EnumType.MOSSY.getMetadata(), "mossy_cobblestone_wall");
-      this.registerBlock(Blocks.COBBLESTONE_WALL, BlockWall.EnumType.NORMAL.getMetadata(), "cobblestone_wall");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.COARSE_DIRT.getMetadata(), "coarse_dirt");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.DIRT.getMetadata(), "dirt");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.PODZOL.getMetadata(), "podzol");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.FERN.getMeta(), "double_fern");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.GRASS.getMeta(), "double_grass");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.PAEONIA.getMeta(), "paeonia");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.ROSE.getMeta(), "double_rose");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.SUNFLOWER.getMeta(), "sunflower");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.SYRINGA.getMeta(), "syringa");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.OAK.getMetadata(), "oak_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_leaves");
-      this.registerBlock(Blocks.LEAVES2, BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_leaves");
-      this.registerBlock(Blocks.LEAVES2, BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_leaves");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.OAK.getMetadata(), "oak_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_log");
-      this.registerBlock(Blocks.LOG2, BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_log");
-      this.registerBlock(Blocks.LOG2, BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_log");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.CHISELED_STONEBRICK.getMetadata(), "chiseled_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.COBBLESTONE.getMetadata(), "cobblestone_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.CRACKED_STONEBRICK.getMetadata(), "cracked_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.MOSSY_STONEBRICK.getMetadata(), "mossy_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.STONE.getMetadata(), "stone_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.STONEBRICK.getMetadata(), "stone_brick_monster_egg");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.OAK.getMetadata(), "oak_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_planks");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.BRICKS.getMetadata(), "prismarine_bricks");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.DARK.getMetadata(), "dark_prismarine");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.ROUGH.getMetadata(), "prismarine");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.CHISELED.getMetadata(), "chiseled_quartz_block");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.DEFAULT.getMetadata(), "quartz_block");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.LINES_Y.getMetadata(), "quartz_column");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.ALLIUM.getMeta(), "allium");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.BLUE_ORCHID.getMeta(), "blue_orchid");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.HOUSTONIA.getMeta(), "houstonia");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.ORANGE_TULIP.getMeta(), "orange_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.OXEYE_DAISY.getMeta(), "oxeye_daisy");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.PINK_TULIP.getMeta(), "pink_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.POPPY.getMeta(), "poppy");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.RED_TULIP.getMeta(), "red_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.WHITE_TULIP.getMeta(), "white_tulip");
-      this.registerBlock(Blocks.SAND, BlockSand.EnumType.RED_SAND.getMetadata(), "red_sand");
-      this.registerBlock(Blocks.SAND, BlockSand.EnumType.SAND.getMetadata(), "sand");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.CHISELED.getMetadata(), "chiseled_sandstone");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.DEFAULT.getMetadata(), "sandstone");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.SMOOTH.getMetadata(), "smooth_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.CHISELED.getMetadata(), "chiseled_red_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.DEFAULT.getMetadata(), "red_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.SMOOTH.getMetadata(), "smooth_red_sandstone");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.OAK.getMetadata(), "oak_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_sapling");
+      this.registerBlock(Blocks.COBBLESTONE_WALL, EnumType.MOSSY.getMetadata(), "mossy_cobblestone_wall");
+      this.registerBlock(Blocks.COBBLESTONE_WALL, EnumType.NORMAL.getMetadata(), "cobblestone_wall");
+      this.registerBlock(Blocks.DIRT, DirtType.COARSE_DIRT.getMetadata(), "coarse_dirt");
+      this.registerBlock(Blocks.DIRT, DirtType.DIRT.getMetadata(), "dirt");
+      this.registerBlock(Blocks.DIRT, DirtType.PODZOL.getMetadata(), "podzol");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.FERN.getMeta(), "double_fern");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.GRASS.getMeta(), "double_grass");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.PAEONIA.getMeta(), "paeonia");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.ROSE.getMeta(), "double_rose");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.SUNFLOWER.getMeta(), "sunflower");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.SYRINGA.getMeta(), "syringa");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_leaves");
+      this.registerBlock(Blocks.LEAVES2, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_leaves");
+      this.registerBlock(Blocks.LEAVES2, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_leaves");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_log");
+      this.registerBlock(Blocks.LOG2, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_log");
+      this.registerBlock(Blocks.LOG2, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_log");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.CHISELED_STONEBRICK.getMetadata(), "chiseled_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.COBBLESTONE.getMetadata(), "cobblestone_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.CRACKED_STONEBRICK.getMetadata(), "cracked_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.MOSSY_STONEBRICK.getMetadata(), "mossy_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.STONE.getMetadata(), "stone_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.STONEBRICK.getMetadata(), "stone_brick_monster_egg");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_planks");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.BRICKS.getMetadata(), "prismarine_bricks");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.DARK.getMetadata(), "dark_prismarine");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.ROUGH.getMetadata(), "prismarine");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.CHISELED.getMetadata(), "chiseled_quartz_block");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.DEFAULT.getMetadata(), "quartz_block");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.LINES_Y.getMetadata(), "quartz_column");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.ALLIUM.getMeta(), "allium");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.BLUE_ORCHID.getMeta(), "blue_orchid");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.HOUSTONIA.getMeta(), "houstonia");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.ORANGE_TULIP.getMeta(), "orange_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.OXEYE_DAISY.getMeta(), "oxeye_daisy");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.PINK_TULIP.getMeta(), "pink_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.POPPY.getMeta(), "poppy");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.RED_TULIP.getMeta(), "red_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.WHITE_TULIP.getMeta(), "white_tulip");
+      this.registerBlock(Blocks.SAND, net.minecraft.block.BlockSand.EnumType.RED_SAND.getMetadata(), "red_sand");
+      this.registerBlock(Blocks.SAND, net.minecraft.block.BlockSand.EnumType.SAND.getMetadata(), "sand");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.CHISELED.getMetadata(), "chiseled_sandstone");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.DEFAULT.getMetadata(), "sandstone");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.SMOOTH.getMetadata(), "smooth_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.CHISELED.getMetadata(), "chiseled_red_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.DEFAULT.getMetadata(), "red_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.SMOOTH.getMetadata(), "smooth_red_sandstone");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_sapling");
       this.registerBlock(Blocks.SPONGE, 0, "sponge");
       this.registerBlock(Blocks.SPONGE, 1, "sponge_wet");
       this.registerBlock(Blocks.STAINED_GLASS, EnumDyeColor.BLACK.getMetadata(), "black_stained_glass");
@@ -529,35 +663,35 @@ private void registerItems() {
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.SILVER.getMetadata(), "silver_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.WHITE.getMetadata(), "white_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.YELLOW.getMetadata(), "yellow_stained_hardened_clay");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.ANDESITE.getMetadata(), "andesite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.ANDESITE_SMOOTH.getMetadata(), "andesite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.DIORITE.getMetadata(), "diorite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.DIORITE_SMOOTH.getMetadata(), "diorite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.GRANITE.getMetadata(), "granite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.GRANITE_SMOOTH.getMetadata(), "granite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.STONE.getMetadata(), "stone");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.CRACKED.getMetadata(), "cracked_stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.DEFAULT.getMetadata(), "stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.CHISELED.getMetadata(), "chiseled_stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.MOSSY.getMetadata(), "mossy_stonebrick");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.BRICK.getMetadata(), "brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.COBBLESTONE.getMetadata(), "cobblestone_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.WOOD.getMetadata(), "old_wood_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.NETHERBRICK.getMetadata(), "nether_brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.QUARTZ.getMetadata(), "quartz_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.SAND.getMetadata(), "sandstone_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.SMOOTHBRICK.getMetadata(), "stone_brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.STONE.getMetadata(), "stone_slab");
-      this.registerBlock(Blocks.STONE_SLAB2, BlockStoneSlabNew.EnumType.RED_SANDSTONE.getMetadata(), "red_sandstone_slab");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.DEAD_BUSH.getMeta(), "dead_bush");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.FERN.getMeta(), "fern");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.GRASS.getMeta(), "tall_grass");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.OAK.getMetadata(), "oak_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_slab");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.ANDESITE.getMetadata(), "andesite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.ANDESITE_SMOOTH.getMetadata(), "andesite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.DIORITE.getMetadata(), "diorite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.DIORITE_SMOOTH.getMetadata(), "diorite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.GRANITE.getMetadata(), "granite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.GRANITE_SMOOTH.getMetadata(), "granite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.STONE.getMetadata(), "stone");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.CRACKED.getMetadata(), "cracked_stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.DEFAULT.getMetadata(), "stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.CHISELED.getMetadata(), "chiseled_stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.MOSSY.getMetadata(), "mossy_stonebrick");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.BRICK.getMetadata(), "brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.COBBLESTONE.getMetadata(), "cobblestone_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.WOOD.getMetadata(), "old_wood_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.NETHERBRICK.getMetadata(), "nether_brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.QUARTZ.getMetadata(), "quartz_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.SAND.getMetadata(), "sandstone_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.SMOOTHBRICK.getMetadata(), "stone_brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.STONE.getMetadata(), "stone_slab");
+      this.registerBlock(Blocks.STONE_SLAB2, net.minecraft.block.BlockStoneSlabNew.EnumType.RED_SANDSTONE.getMetadata(), "red_sandstone_slab");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.DEAD_BUSH.getMeta(), "dead_bush");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.FERN.getMeta(), "fern");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.GRASS.getMeta(), "tall_grass");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_slab");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BLACK.getMetadata(), "black_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BLUE.getMetadata(), "blue_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BROWN.getMetadata(), "brown_wool");
@@ -686,7 +820,7 @@ private void registerItems() {
       this.registerBlock(Blocks.WEB, "web");
       this.registerBlock(Blocks.WOODEN_BUTTON, "wooden_button");
       this.registerBlock(Blocks.WOODEN_PRESSURE_PLATE, "wooden_pressure_plate");
-      this.registerBlock(Blocks.YELLOW_FLOWER, BlockFlower.EnumFlowerType.DANDELION.getMeta(), "dandelion");
+      this.registerBlock(Blocks.YELLOW_FLOWER, EnumFlowerType.DANDELION.getMeta(), "dandelion");
       this.registerBlock(Blocks.END_ROD, "end_rod");
       this.registerBlock(Blocks.CHORUS_PLANT, "chorus_plant");
       this.registerBlock(Blocks.CHORUS_FLOWER, "chorus_flower");
@@ -735,9 +869,9 @@ private void registerItems() {
       this.registerBlock(Blocks.RED_GLAZED_TERRACOTTA, "red_glazed_terracotta");
       this.registerBlock(Blocks.BLACK_GLAZED_TERRACOTTA, "black_glazed_terracotta");
 
-      for (EnumDyeColor ☃ : EnumDyeColor.values()) {
-         this.registerBlock(Blocks.CONCRETE, ☃.getMetadata(), ☃.getDyeColorName() + "_concrete");
-         this.registerBlock(Blocks.CONCRETE_POWDER, ☃.getMetadata(), ☃.getDyeColorName() + "_concrete_powder");
+      for (EnumDyeColor enumdyecolor : EnumDyeColor.values()) {
+         this.registerBlock(Blocks.CONCRETE, enumdyecolor.getMetadata(), enumdyecolor.getDyeColorName() + "_concrete");
+         this.registerBlock(Blocks.CONCRETE_POWDER, enumdyecolor.getMetadata(), enumdyecolor.getDyeColorName() + "_concrete_powder");
       }
 
       this.registerBlock(Blocks.CHEST, "chest");
@@ -850,12 +984,12 @@ private void registerItems() {
       this.registerItem(Items.FISHING_ROD, "fishing_rod");
       this.registerItem(Items.CLOCK, "clock");
       this.registerItem(Items.GLOWSTONE_DUST, "glowstone_dust");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.COD.getMetadata(), "cod");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.SALMON.getMetadata(), "salmon");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.CLOWNFISH.getMetadata(), "clownfish");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.PUFFERFISH.getMetadata(), "pufferfish");
-      this.registerItem(Items.COOKED_FISH, ItemFishFood.FishType.COD.getMetadata(), "cooked_cod");
-      this.registerItem(Items.COOKED_FISH, ItemFishFood.FishType.SALMON.getMetadata(), "cooked_salmon");
+      this.registerItem(Items.FISH, FishType.COD.getMetadata(), "cod");
+      this.registerItem(Items.FISH, FishType.SALMON.getMetadata(), "salmon");
+      this.registerItem(Items.FISH, FishType.CLOWNFISH.getMetadata(), "clownfish");
+      this.registerItem(Items.FISH, FishType.PUFFERFISH.getMetadata(), "pufferfish");
+      this.registerItem(Items.COOKED_FISH, FishType.COD.getMetadata(), "cooked_cod");
+      this.registerItem(Items.COOKED_FISH, FishType.SALMON.getMetadata(), "cooked_salmon");
       this.registerItem(Items.DYE, EnumDyeColor.BLACK.getDyeDamage(), "dye_black");
       this.registerItem(Items.DYE, EnumDyeColor.RED.getDyeDamage(), "dye_red");
       this.registerItem(Items.DYE, EnumDyeColor.GREEN.getDyeDamage(), "dye_green");
@@ -916,8 +1050,7 @@ private void registerItems() {
       this.registerItem(Items.ENDER_EYE, "ender_eye");
       this.registerItem(Items.SPECKLED_MELON, "speckled_melon");
       this.itemModelMesher.register(Items.SPAWN_EGG, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("spawn_egg", "inventory");
          }
       });
@@ -956,20 +1089,17 @@ public ModelResourceLocation getModelLocation(ItemStack var1) {
       this.registerItem(Items.LEAD, "lead");
       this.registerItem(Items.NAME_TAG, "name_tag");
       this.itemModelMesher.register(Items.BANNER, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("banner", "inventory");
          }
       });
       this.itemModelMesher.register(Items.BED, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("bed", "inventory");
          }
       });
       this.itemModelMesher.register(Items.SHIELD, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("shield", "inventory");
          }
       });
@@ -994,14 +1124,12 @@ public ModelResourceLocation getModelLocation(ItemStack var1) {
       this.registerItem(Items.PRISMARINE_CRYSTALS, "prismarine_crystals");
       this.registerItem(Items.KNOWLEDGE_BOOK, "knowledge_book");
       this.itemModelMesher.register(Items.ENCHANTED_BOOK, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("enchanted_book", "inventory");
          }
       });
       this.itemModelMesher.register(Items.FILLED_MAP, new ItemMeshDefinition() {
-         @Override
-         public ModelResourceLocation getModelLocation(ItemStack var1) {
+         public ModelResourceLocation getModelLocation(ItemStack stack) {
             return new ModelResourceLocation("filled_map", "inventory");
          }
       });
@@ -1011,19 +1139,21 @@ public ModelResourceLocation getModelLocation(ItemStack var1) {
       this.registerBlock(Blocks.BARRIER, "barrier");
       this.registerBlock(Blocks.MOB_SPAWNER, "mob_spawner");
       this.registerItem(Items.WRITTEN_BOOK, "written_book");
-      this.registerBlock(Blocks.BROWN_MUSHROOM_BLOCK, BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "brown_mushroom_block");
-      this.registerBlock(Blocks.RED_MUSHROOM_BLOCK, BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "red_mushroom_block");
+      this.registerBlock(Blocks.BROWN_MUSHROOM_BLOCK, net.minecraft.block.BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "brown_mushroom_block");
+      this.registerBlock(Blocks.RED_MUSHROOM_BLOCK, net.minecraft.block.BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "red_mushroom_block");
       this.registerBlock(Blocks.DRAGON_EGG, "dragon_egg");
       this.registerBlock(Blocks.REPEATING_COMMAND_BLOCK, "repeating_command_block");
       this.registerBlock(Blocks.CHAIN_COMMAND_BLOCK, "chain_command_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.SAVE.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.LOAD.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.CORNER.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.DATA.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.SAVE.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.LOAD.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.CORNER.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.DATA.getModeId(), "structure_block");
+      if (Reflector.ModelLoader_onRegisterItems.exists()) {
+         Reflector.call(Reflector.ModelLoader_onRegisterItems, new Object[]{this.itemModelMesher});
+      }
    }
 
-   @Override
-   public void onResourceManagerReload(IResourceManager var1) {
+   public void onResourceManagerReload(IResourceManager resourceManager) {
       this.itemModelMesher.rebuildCache();
    }
 }
diff --git a/patches/net/minecraft/client/renderer/RenderList.java b/patches/net/minecraft/client/renderer/RenderList.java
index de2defc..017ce7e 100644
--- a/patches/net/minecraft/client/renderer/RenderList.java
+++ b/patches/net/minecraft/client/renderer/RenderList.java
@@ -1,23 +1,85 @@
 package net.minecraft.client.renderer;
 
+import java.nio.Buffer;
+import java.nio.IntBuffer;
 import net.minecraft.client.renderer.chunk.ListedRenderChunk;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.util.BlockRenderLayer;
 
 public class RenderList extends ChunkRenderContainer {
+   private double viewEntityX;
+   private double viewEntityY;
+   private double viewEntityZ;
+   IntBuffer bufferLists = GLAllocation.createDirectIntBuffer(16);
+
    @Override
-   public void renderChunkLayer(BlockRenderLayer var1) {
+   public void renderChunkLayer(BlockRenderLayer layer) {
       if (this.initialized) {
-         for (RenderChunk ☃ : this.renderChunks) {
-            ListedRenderChunk ☃x = (ListedRenderChunk)☃;
-            GlStateManager.pushMatrix();
-            this.preRenderChunk(☃);
-            GlStateManager.callList(☃x.getDisplayList(☃, ☃x.getCompiledChunk()));
-            GlStateManager.popMatrix();
+         if (!Config.isRenderRegions()) {
+            for (RenderChunk renderchunk : this.renderChunks) {
+               ListedRenderChunk listedrenderchunk = (ListedRenderChunk)renderchunk;
+               GlStateManager.pushMatrix();
+               this.preRenderChunk(renderchunk);
+               GlStateManager.callList(listedrenderchunk.getDisplayList(layer, listedrenderchunk.h()));
+               GlStateManager.popMatrix();
+            }
+         } else {
+            int regionX = Integer.MIN_VALUE;
+            int regionZ = Integer.MIN_VALUE;
+
+            for (RenderChunk renderchunk : this.renderChunks) {
+               ListedRenderChunk listedrenderchunk = (ListedRenderChunk)renderchunk;
+               if (regionX != renderchunk.regionX || regionZ != renderchunk.regionZ) {
+                  if (this.bufferLists.position() > 0) {
+                     this.drawRegion(regionX, regionZ, this.bufferLists);
+                  }
+
+                  regionX = renderchunk.regionX;
+                  regionZ = renderchunk.regionZ;
+               }
+
+               if (this.bufferLists.position() >= this.bufferLists.capacity()) {
+                  IntBuffer bufferListsNew = GLAllocation.createDirectIntBuffer(this.bufferLists.capacity() * 2);
+                  ((Buffer)this.bufferLists).flip();
+                  bufferListsNew.put(this.bufferLists);
+                  this.bufferLists = bufferListsNew;
+               }
+
+               this.bufferLists.put(listedrenderchunk.getDisplayList(layer, listedrenderchunk.h()));
+            }
+
+            if (this.bufferLists.position() > 0) {
+               this.drawRegion(regionX, regionZ, this.bufferLists);
+            }
+         }
+
+         if (Config.isMultiTexture()) {
+            GlStateManager.bindCurrentTexture();
          }
 
          GlStateManager.resetColor();
          this.renderChunks.clear();
       }
    }
+
+   @Override
+   public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
+      this.viewEntityX = viewEntityXIn;
+      this.viewEntityY = viewEntityYIn;
+      this.viewEntityZ = viewEntityZIn;
+      super.initialize(viewEntityXIn, viewEntityYIn, viewEntityZIn);
+   }
+
+   private void drawRegion(int regionX, int regionZ, IntBuffer buffer) {
+      GlStateManager.pushMatrix();
+      this.preRenderRegion(regionX, 0, regionZ);
+      ((Buffer)buffer).flip();
+      GlStateManager.callLists(buffer);
+      ((Buffer)buffer).clear();
+      GlStateManager.popMatrix();
+   }
+
+   public void preRenderRegion(int x, int y, int z) {
+      GlStateManager.translate((float)(x - this.viewEntityX), (float)(y - this.viewEntityY), (float)(z - this.viewEntityZ));
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/Tessellator.java b/patches/net/minecraft/client/renderer/Tessellator.java
index b83c181..11d3d29 100644
--- a/patches/net/minecraft/client/renderer/Tessellator.java
+++ b/patches/net/minecraft/client/renderer/Tessellator.java
@@ -1,5 +1,7 @@
 package net.minecraft.client.renderer;
 
+import net.optifine.SmartAnimations;
+
 public class Tessellator {
    private final BufferBuilder buffer;
    private final WorldVertexBufferUploader vboUploader = new WorldVertexBufferUploader();
@@ -9,11 +11,15 @@ public static Tessellator getInstance() {
       return INSTANCE;
    }
 
-   public Tessellator(int var1) {
-      this.buffer = new BufferBuilder(☃);
+   public Tessellator(int bufferSize) {
+      this.buffer = new BufferBuilder(bufferSize);
    }
 
    public void draw() {
+      if (this.buffer.animatedSprites != null) {
+         SmartAnimations.spritesRendered(this.buffer.animatedSprites);
+      }
+
       this.buffer.finishDrawing();
       this.vboUploader.draw(this.buffer);
    }
diff --git a/patches/net/minecraft/client/renderer/ThreadDownloadImageData.java b/patches/net/minecraft/client/renderer/ThreadDownloadImageData.java
index e2ce7dc..309fde3 100644
--- a/patches/net/minecraft/client/renderer/ThreadDownloadImageData.java
+++ b/patches/net/minecraft/client/renderer/ThreadDownloadImageData.java
@@ -1,10 +1,13 @@
 package net.minecraft.client.renderer;
 
 import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.Proxy;
 import java.net.URL;
+import java.net.Proxy.Type;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
@@ -13,6 +16,11 @@
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.http.HttpPipeline;
+import net.optifine.http.HttpRequest;
+import net.optifine.http.HttpResponse;
+import net.optifine.player.CapeImageBuffer;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -30,23 +38,29 @@ public class ThreadDownloadImageData extends SimpleTexture {
    @Nullable
    private Thread imageThread;
    private boolean textureUploaded;
+   public Boolean imageFound = null;
+   public boolean pipeline = false;
 
-   public ThreadDownloadImageData(@Nullable File var1, String var2, ResourceLocation var3, @Nullable IImageBuffer var4) {
-      super(☃);
-      this.cacheFile = ☃;
-      this.imageUrl = ☃;
-      this.imageBuffer = ☃;
+   public ThreadDownloadImageData(@Nullable File cacheFileIn, String imageUrlIn, ResourceLocation textureResourceLocation, @Nullable IImageBuffer imageBufferIn) {
+      super(textureResourceLocation);
+      this.cacheFile = cacheFileIn;
+      this.imageUrl = imageUrlIn;
+      this.imageBuffer = imageBufferIn;
    }
 
    private void checkTextureUploaded() {
-      if (!this.textureUploaded) {
-         if (this.bufferedImage != null) {
-            if (this.textureLocation != null) {
-               this.deleteGlTexture();
-            }
+      if (!this.textureUploaded && this.bufferedImage != null) {
+         this.textureUploaded = true;
+         if (this.textureLocation != null) {
+            this.deleteGlTexture();
+         }
 
+         if (Config.isShaders()) {
+            ShadersTex.loadSimpleTexture(
+               super.getGlTextureId(), this.bufferedImage, false, false, Config.getResourceManager(), this.textureLocation, this.getMultiTexID()
+            );
+         } else {
             TextureUtil.uploadTextureImage(super.getGlTextureId(), this.bufferedImage);
-            this.textureUploaded = true;
          }
       }
    }
@@ -57,17 +71,19 @@ public int getGlTextureId() {
       return super.getGlTextureId();
    }
 
-   public void setBufferedImage(BufferedImage var1) {
-      this.bufferedImage = ☃;
+   public void setBufferedImage(BufferedImage bufferedImageIn) {
+      this.bufferedImage = bufferedImageIn;
       if (this.imageBuffer != null) {
          this.imageBuffer.skinAvailable();
       }
+
+      this.imageFound = this.bufferedImage != null;
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
       if (this.bufferedImage == null && this.textureLocation != null) {
-         super.loadTexture(☃);
+         super.loadTexture(resourceManager);
       }
 
       if (this.imageThread == null) {
@@ -79,6 +95,8 @@ public void loadTexture(IResourceManager var1) throws IOException {
                if (this.imageBuffer != null) {
                   this.setBufferedImage(this.imageBuffer.parseUserSkin(this.bufferedImage));
                }
+
+               this.loadingFinished();
             } catch (IOException var3) {
                LOGGER.error("Couldn't load skin {}", this.cacheFile, var3);
                this.loadTextureFromServer();
@@ -93,37 +111,47 @@ protected void loadTextureFromServer() {
       this.imageThread = new Thread("Texture Downloader #" + TEXTURE_DOWNLOADER_THREAD_ID.incrementAndGet()) {
          @Override
          public void run() {
-            HttpURLConnection ☃ = null;
+            HttpURLConnection httpurlconnection = null;
             ThreadDownloadImageData.LOGGER
                .debug("Downloading http texture from {} to {}", ThreadDownloadImageData.this.imageUrl, ThreadDownloadImageData.this.cacheFile);
+            if (ThreadDownloadImageData.this.shouldPipeline()) {
+               ThreadDownloadImageData.this.loadPipelined();
+            } else {
+               try {
+                  httpurlconnection = (HttpURLConnection)new URL(ThreadDownloadImageData.this.imageUrl).openConnection(Minecraft.getMinecraft().getProxy());
+                  httpurlconnection.setDoInput(true);
+                  httpurlconnection.setDoOutput(false);
+                  httpurlconnection.connect();
+                  if (httpurlconnection.getResponseCode() / 100 != 2) {
+                     if (httpurlconnection.getErrorStream() != null) {
+                        Config.readAll(httpurlconnection.getErrorStream());
+                     }
 
-            try {
-               ☃ = (HttpURLConnection)new URL(ThreadDownloadImageData.this.imageUrl).openConnection(Minecraft.getMinecraft().getProxy());
-               ☃.setDoInput(true);
-               ☃.setDoOutput(false);
-               ☃.connect();
-               if (☃.getResponseCode() / 100 == 2) {
-                  BufferedImage ☃x;
+                     return;
+                  }
+
+                  BufferedImage bufferedimage;
                   if (ThreadDownloadImageData.this.cacheFile != null) {
-                     FileUtils.copyInputStreamToFile(☃.getInputStream(), ThreadDownloadImageData.this.cacheFile);
-                     ☃x = ImageIO.read(ThreadDownloadImageData.this.cacheFile);
+                     FileUtils.copyInputStreamToFile(httpurlconnection.getInputStream(), ThreadDownloadImageData.this.cacheFile);
+                     bufferedimage = ImageIO.read(ThreadDownloadImageData.this.cacheFile);
                   } else {
-                     ☃x = TextureUtil.readBufferedImage(☃.getInputStream());
+                     bufferedimage = TextureUtil.readBufferedImage(httpurlconnection.getInputStream());
                   }
 
                   if (ThreadDownloadImageData.this.imageBuffer != null) {
-                     ☃x = ThreadDownloadImageData.this.imageBuffer.parseUserSkin(☃x);
+                     bufferedimage = ThreadDownloadImageData.this.imageBuffer.parseUserSkin(bufferedimage);
                   }
 
-                  ThreadDownloadImageData.this.setBufferedImage(☃x);
+                  ThreadDownloadImageData.this.setBufferedImage(bufferedimage);
+               } catch (Exception var6) {
+                  ThreadDownloadImageData.LOGGER.error("Couldn't download http texture: " + var6.getMessage());
                   return;
-               }
-            } catch (Exception var6) {
-               ThreadDownloadImageData.LOGGER.error("Couldn't download http texture", var6);
-               return;
-            } finally {
-               if (☃ != null) {
-                  ☃.disconnect();
+               } finally {
+                  if (httpurlconnection != null) {
+                     httpurlconnection.disconnect();
+                  }
+
+                  ThreadDownloadImageData.this.loadingFinished();
                }
             }
          }
@@ -131,4 +159,55 @@ public void run() {
       this.imageThread.setDaemon(true);
       this.imageThread.start();
    }
+
+   private boolean shouldPipeline() {
+      if (!this.pipeline) {
+         return false;
+      } else {
+         Proxy proxy = Minecraft.getMinecraft().getProxy();
+         return proxy.type() != Type.DIRECT && proxy.type() != Type.SOCKS ? false : this.imageUrl.startsWith("http://");
+      }
+   }
+
+   private void loadPipelined() {
+      try {
+         HttpRequest req = HttpPipeline.makeRequest(this.imageUrl, Minecraft.getMinecraft().getProxy());
+         HttpResponse resp = HttpPipeline.executeRequest(req);
+         if (resp.getStatus() / 100 == 2) {
+            byte[] body = resp.getBody();
+            ByteArrayInputStream bais = new ByteArrayInputStream(body);
+            BufferedImage var2;
+            if (this.cacheFile != null) {
+               FileUtils.copyInputStreamToFile(bais, this.cacheFile);
+               var2 = ImageIO.read(this.cacheFile);
+            } else {
+               var2 = TextureUtil.readBufferedImage(bais);
+            }
+
+            if (this.imageBuffer != null) {
+               var2 = this.imageBuffer.parseUserSkin(var2);
+            }
+
+            this.setBufferedImage(var2);
+            return;
+         }
+      } catch (Exception var9) {
+         LOGGER.error("Couldn't download http texture: " + var9.getClass().getName() + ": " + var9.getMessage());
+         return;
+      } finally {
+         this.loadingFinished();
+      }
+   }
+
+   private void loadingFinished() {
+      this.imageFound = this.bufferedImage != null;
+      if (this.imageBuffer instanceof CapeImageBuffer) {
+         CapeImageBuffer cib = (CapeImageBuffer)this.imageBuffer;
+         cib.cleanup();
+      }
+   }
+
+   public IImageBuffer getImageBuffer() {
+      return this.imageBuffer;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/VboRenderList.java b/patches/net/minecraft/client/renderer/VboRenderList.java
index bc4706e..cbce59d 100644
--- a/patches/net/minecraft/client/renderer/VboRenderList.java
+++ b/patches/net/minecraft/client/renderer/VboRenderList.java
@@ -3,20 +3,52 @@
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
 import net.minecraft.util.BlockRenderLayer;
+import net.optifine.render.VboRegion;
+import net.optifine.shaders.ShadersRender;
 
 public class VboRenderList extends ChunkRenderContainer {
+   private double viewEntityX;
+   private double viewEntityY;
+   private double viewEntityZ;
+
    @Override
-   public void renderChunkLayer(BlockRenderLayer var1) {
+   public void renderChunkLayer(BlockRenderLayer layer) {
       if (this.initialized) {
-         for (RenderChunk ☃ : this.renderChunks) {
-            VertexBuffer ☃x = ☃.getVertexBufferByLayer(☃.ordinal());
-            GlStateManager.pushMatrix();
-            this.preRenderChunk(☃);
-            ☃.multModelviewMatrix();
-            ☃x.bindBuffer();
-            this.setupArrayPointers();
-            ☃x.drawArrays(7);
-            GlStateManager.popMatrix();
+         if (!Config.isRenderRegions()) {
+            for (RenderChunk renderchunk : this.renderChunks) {
+               VertexBuffer vertexbuffer = renderchunk.getVertexBufferByLayer(layer.ordinal());
+               GlStateManager.pushMatrix();
+               this.preRenderChunk(renderchunk);
+               renderchunk.multModelviewMatrix();
+               vertexbuffer.bindBuffer();
+               this.setupArrayPointers();
+               vertexbuffer.drawArrays(7);
+               GlStateManager.popMatrix();
+            }
+         } else {
+            int regionX = Integer.MIN_VALUE;
+            int regionZ = Integer.MIN_VALUE;
+            VboRegion lastVboRegion = null;
+
+            for (RenderChunk renderchunk : this.renderChunks) {
+               VertexBuffer vertexbuffer = renderchunk.getVertexBufferByLayer(layer.ordinal());
+               VboRegion vboRegion = vertexbuffer.getVboRegion();
+               if (vboRegion != lastVboRegion || regionX != renderchunk.regionX || regionZ != renderchunk.regionZ) {
+                  if (lastVboRegion != null) {
+                     this.drawRegion(regionX, regionZ, lastVboRegion);
+                  }
+
+                  regionX = renderchunk.regionX;
+                  regionZ = renderchunk.regionZ;
+                  lastVboRegion = vboRegion;
+               }
+
+               vertexbuffer.drawArrays(7);
+            }
+
+            if (lastVboRegion != null) {
+               this.drawRegion(regionX, regionZ, lastVboRegion);
+            }
          }
 
          OpenGlHelper.glBindBuffer(OpenGlHelper.GL_ARRAY_BUFFER, 0);
@@ -25,12 +57,35 @@ public void renderChunkLayer(BlockRenderLayer var1) {
       }
    }
 
-   private void setupArrayPointers() {
-      GlStateManager.glVertexPointer(3, 5126, 28, 0);
-      GlStateManager.glColorPointer(4, 5121, 28, 12);
-      GlStateManager.glTexCoordPointer(2, 5126, 28, 16);
-      OpenGlHelper.setClientActiveTexture(OpenGlHelper.lightmapTexUnit);
-      GlStateManager.glTexCoordPointer(2, 5122, 28, 24);
-      OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+   public void setupArrayPointers() {
+      if (Config.isShaders()) {
+         ShadersRender.setupArrayPointersVbo();
+      } else {
+         GlStateManager.glVertexPointer(3, 5126, 28, 0);
+         GlStateManager.glColorPointer(4, 5121, 28, 12);
+         GlStateManager.glTexCoordPointer(2, 5126, 28, 16);
+         OpenGlHelper.setClientActiveTexture(OpenGlHelper.lightmapTexUnit);
+         GlStateManager.glTexCoordPointer(2, 5122, 28, 24);
+         OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+      }
+   }
+
+   @Override
+   public void initialize(double viewEntityXIn, double viewEntityYIn, double viewEntityZIn) {
+      this.viewEntityX = viewEntityXIn;
+      this.viewEntityY = viewEntityYIn;
+      this.viewEntityZ = viewEntityZIn;
+      super.initialize(viewEntityXIn, viewEntityYIn, viewEntityZIn);
+   }
+
+   private void drawRegion(int regionX, int regionZ, VboRegion vboRegion) {
+      GlStateManager.pushMatrix();
+      this.preRenderRegion(regionX, 0, regionZ);
+      vboRegion.finishDraw(this);
+      GlStateManager.popMatrix();
+   }
+
+   public void preRenderRegion(int x, int y, int z) {
+      GlStateManager.translate((float)(x - this.viewEntityX), (float)(y - this.viewEntityY), (float)(z - this.viewEntityZ));
    }
 }
diff --git a/patches/net/minecraft/client/renderer/VertexBufferUploader.java b/patches/net/minecraft/client/renderer/VertexBufferUploader.java
index 65dbd1a..dc0162b 100644
--- a/patches/net/minecraft/client/renderer/VertexBufferUploader.java
+++ b/patches/net/minecraft/client/renderer/VertexBufferUploader.java
@@ -6,12 +6,17 @@ public class VertexBufferUploader extends WorldVertexBufferUploader {
    private VertexBuffer vertexBuffer;
 
    @Override
-   public void draw(BufferBuilder var1) {
-      ☃.reset();
-      this.vertexBuffer.bufferData(☃.getByteBuffer());
+   public void draw(BufferBuilder vertexBufferIn) {
+      if (vertexBufferIn.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
+         vertexBufferIn.quadsToTriangles();
+         this.vertexBuffer.setDrawMode(vertexBufferIn.getDrawMode());
+      }
+
+      this.vertexBuffer.bufferData(vertexBufferIn.getByteBuffer());
+      vertexBufferIn.reset();
    }
 
-   public void setVertexBuffer(VertexBuffer var1) {
-      this.vertexBuffer = ☃;
+   public void setVertexBuffer(VertexBuffer vertexBufferIn) {
+      this.vertexBuffer = vertexBufferIn;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/ViewFrustum.java b/patches/net/minecraft/client/renderer/ViewFrustum.java
index dadebb8..ad4fda9 100644
--- a/patches/net/minecraft/client/renderer/ViewFrustum.java
+++ b/patches/net/minecraft/client/renderer/ViewFrustum.java
@@ -1,11 +1,17 @@
 package net.minecraft.client.renderer;
 
+import java.util.HashMap;
+import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.client.renderer.chunk.IRenderChunkFactory;
 import net.minecraft.client.renderer.chunk.RenderChunk;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.World;
+import net.optifine.render.VboRegion;
 
 public class ViewFrustum {
    protected final RenderGlobal renderGlobal;
@@ -14,127 +20,186 @@ public class ViewFrustum {
    protected int countChunksX;
    protected int countChunksZ;
    public RenderChunk[] renderChunks;
+   private Map<ChunkPos, VboRegion[]> mapVboRegions = new HashMap<>();
 
-   public ViewFrustum(World var1, int var2, RenderGlobal var3, IRenderChunkFactory var4) {
-      this.renderGlobal = ☃;
-      this.world = ☃;
-      this.setCountChunksXYZ(☃);
-      this.createRenderChunks(☃);
+   public ViewFrustum(World worldIn, int renderDistanceChunks, RenderGlobal renderGlobalIn, IRenderChunkFactory renderChunkFactory) {
+      this.renderGlobal = renderGlobalIn;
+      this.world = worldIn;
+      this.setCountChunksXYZ(renderDistanceChunks);
+      this.createRenderChunks(renderChunkFactory);
    }
 
-   protected void createRenderChunks(IRenderChunkFactory var1) {
-      int ☃ = this.countChunksX * this.countChunksY * this.countChunksZ;
-      this.renderChunks = new RenderChunk[☃];
-      int ☃x = 0;
-
-      for (int ☃xx = 0; ☃xx < this.countChunksX; ☃xx++) {
-         for (int ☃xxx = 0; ☃xxx < this.countChunksY; ☃xxx++) {
-            for (int ☃xxxx = 0; ☃xxxx < this.countChunksZ; ☃xxxx++) {
-               int ☃xxxxx = (☃xxxx * this.countChunksY + ☃xxx) * this.countChunksX + ☃xx;
-               this.renderChunks[☃xxxxx] = ☃.create(this.world, this.renderGlobal, ☃x++);
-               this.renderChunks[☃xxxxx].setPosition(☃xx * 16, ☃xxx * 16, ☃xxxx * 16);
+   protected void createRenderChunks(IRenderChunkFactory renderChunkFactory) {
+      int i = this.countChunksX * this.countChunksY * this.countChunksZ;
+      this.renderChunks = new RenderChunk[i];
+      int j = 0;
+
+      for (int k = 0; k < this.countChunksX; k++) {
+         for (int l = 0; l < this.countChunksY; l++) {
+            for (int i1 = 0; i1 < this.countChunksZ; i1++) {
+               int j1 = (i1 * this.countChunksY + l) * this.countChunksX + k;
+               this.renderChunks[j1] = renderChunkFactory.create(this.world, this.renderGlobal, j++);
+               this.renderChunks[j1].setPosition(k * 16, l * 16, i1 * 16);
+               if (Config.isVbo() && Config.isRenderRegions()) {
+                  this.updateVboRegion(this.renderChunks[j1]);
+               }
             }
          }
       }
+
+      for (int k = 0; k < this.renderChunks.length; k++) {
+         RenderChunk renderChunk = this.renderChunks[k];
+
+         for (int l = 0; l < EnumFacing.VALUES.length; l++) {
+            EnumFacing facing = EnumFacing.VALUES[l];
+            BlockPos posOffset16 = renderChunk.getBlockPosOffset16(facing);
+            RenderChunk neighbour = this.getRenderChunk(posOffset16);
+            renderChunk.setRenderChunkNeighbour(facing, neighbour);
+         }
+      }
    }
 
    public void deleteGlResources() {
-      for (RenderChunk ☃ : this.renderChunks) {
-         ☃.deleteGlResources();
+      for (RenderChunk renderchunk : this.renderChunks) {
+         renderchunk.deleteGlResources();
       }
+
+      this.deleteVboRegions();
    }
 
-   protected void setCountChunksXYZ(int var1) {
-      int ☃ = ☃ * 2 + 1;
-      this.countChunksX = ☃;
+   protected void setCountChunksXYZ(int renderDistanceChunks) {
+      int i = renderDistanceChunks * 2 + 1;
+      this.countChunksX = i;
       this.countChunksY = 16;
-      this.countChunksZ = ☃;
+      this.countChunksZ = i;
    }
 
-   public void updateChunkPositions(double var1, double var3) {
-      int ☃ = MathHelper.floor(☃) - 8;
-      int ☃x = MathHelper.floor(☃) - 8;
-      int ☃xx = this.countChunksX * 16;
+   public void updateChunkPositions(double viewEntityX, double viewEntityZ) {
+      int i = MathHelper.floor(viewEntityX) - 8;
+      int j = MathHelper.floor(viewEntityZ) - 8;
+      int k = this.countChunksX * 16;
 
-      for (int ☃xxx = 0; ☃xxx < this.countChunksX; ☃xxx++) {
-         int ☃xxxx = this.getBaseCoordinate(☃, ☃xx, ☃xxx);
+      for (int l = 0; l < this.countChunksX; l++) {
+         int i1 = this.getBaseCoordinate(i, k, l);
 
-         for (int ☃xxxxx = 0; ☃xxxxx < this.countChunksZ; ☃xxxxx++) {
-            int ☃xxxxxx = this.getBaseCoordinate(☃x, ☃xx, ☃xxxxx);
+         for (int j1 = 0; j1 < this.countChunksZ; j1++) {
+            int k1 = this.getBaseCoordinate(j, k, j1);
 
-            for (int ☃xxxxxxx = 0; ☃xxxxxxx < this.countChunksY; ☃xxxxxxx++) {
-               int ☃xxxxxxxx = ☃xxxxxxx * 16;
-               RenderChunk ☃xxxxxxxxx = this.renderChunks[(☃xxxxx * this.countChunksY + ☃xxxxxxx) * this.countChunksX + ☃xxx];
-               ☃xxxxxxxxx.setPosition(☃xxxx, ☃xxxxxxxx, ☃xxxxxx);
+            for (int l1 = 0; l1 < this.countChunksY; l1++) {
+               int i2 = l1 * 16;
+               RenderChunk renderchunk = this.renderChunks[(j1 * this.countChunksY + l1) * this.countChunksX + l];
+               renderchunk.setPosition(i1, i2, k1);
             }
          }
       }
    }
 
-   private int getBaseCoordinate(int var1, int var2, int var3) {
-      int ☃ = ☃ * 16;
-      int ☃x = ☃ - ☃ + ☃ / 2;
-      if (☃x < 0) {
-         ☃x -= ☃ - 1;
+   private int getBaseCoordinate(int p_178157_1_, int p_178157_2_, int p_178157_3_) {
+      int i = p_178157_3_ * 16;
+      int j = i - p_178157_1_ + p_178157_2_ / 2;
+      if (j < 0) {
+         j -= p_178157_2_ - 1;
       }
 
-      return ☃ - ☃x / ☃ * ☃;
+      return i - j / p_178157_2_ * p_178157_2_;
    }
 
-   public void markBlocksForUpdate(int var1, int var2, int var3, int var4, int var5, int var6, boolean var7) {
-      int ☃ = MathHelper.intFloorDiv(☃, 16);
-      int ☃x = MathHelper.intFloorDiv(☃, 16);
-      int ☃xx = MathHelper.intFloorDiv(☃, 16);
-      int ☃xxx = MathHelper.intFloorDiv(☃, 16);
-      int ☃xxxx = MathHelper.intFloorDiv(☃, 16);
-      int ☃xxxxx = MathHelper.intFloorDiv(☃, 16);
-
-      for (int ☃xxxxxx = ☃; ☃xxxxxx <= ☃xxx; ☃xxxxxx++) {
-         int ☃xxxxxxx = ☃xxxxxx % this.countChunksX;
-         if (☃xxxxxxx < 0) {
-            ☃xxxxxxx += this.countChunksX;
+   public void markBlocksForUpdate(int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean updateImmediately) {
+      int i = MathHelper.intFloorDiv(minX, 16);
+      int j = MathHelper.intFloorDiv(minY, 16);
+      int k = MathHelper.intFloorDiv(minZ, 16);
+      int l = MathHelper.intFloorDiv(maxX, 16);
+      int i1 = MathHelper.intFloorDiv(maxY, 16);
+      int j1 = MathHelper.intFloorDiv(maxZ, 16);
+
+      for (int k1 = i; k1 <= l; k1++) {
+         int l1 = k1 % this.countChunksX;
+         if (l1 < 0) {
+            l1 += this.countChunksX;
          }
 
-         for (int ☃xxxxxxxx = ☃x; ☃xxxxxxxx <= ☃xxxx; ☃xxxxxxxx++) {
-            int ☃xxxxxxxxx = ☃xxxxxxxx % this.countChunksY;
-            if (☃xxxxxxxxx < 0) {
-               ☃xxxxxxxxx += this.countChunksY;
+         for (int i2 = j; i2 <= i1; i2++) {
+            int j2 = i2 % this.countChunksY;
+            if (j2 < 0) {
+               j2 += this.countChunksY;
             }
 
-            for (int ☃xxxxxxxxxx = ☃xx; ☃xxxxxxxxxx <= ☃xxxxx; ☃xxxxxxxxxx++) {
-               int ☃xxxxxxxxxxx = ☃xxxxxxxxxx % this.countChunksZ;
-               if (☃xxxxxxxxxxx < 0) {
-                  ☃xxxxxxxxxxx += this.countChunksZ;
+            for (int k2 = k; k2 <= j1; k2++) {
+               int l2 = k2 % this.countChunksZ;
+               if (l2 < 0) {
+                  l2 += this.countChunksZ;
                }
 
-               int ☃xxxxxxxxxxxx = (☃xxxxxxxxxxx * this.countChunksY + ☃xxxxxxxxx) * this.countChunksX + ☃xxxxxxx;
-               RenderChunk ☃xxxxxxxxxxxxx = this.renderChunks[☃xxxxxxxxxxxx];
-               ☃xxxxxxxxxxxxx.setNeedsUpdate(☃);
+               int i3 = (l2 * this.countChunksY + j2) * this.countChunksX + l1;
+               RenderChunk renderchunk = this.renderChunks[i3];
+               renderchunk.setNeedsUpdate(updateImmediately);
             }
          }
       }
    }
 
    @Nullable
-   protected RenderChunk getRenderChunk(BlockPos var1) {
-      int ☃ = MathHelper.intFloorDiv(☃.getX(), 16);
-      int ☃x = MathHelper.intFloorDiv(☃.getY(), 16);
-      int ☃xx = MathHelper.intFloorDiv(☃.getZ(), 16);
-      if (☃x >= 0 && ☃x < this.countChunksY) {
-         ☃ %= this.countChunksX;
-         if (☃ < 0) {
-            ☃ += this.countChunksX;
+   public RenderChunk getRenderChunk(BlockPos pos) {
+      int i = pos.getX() >> 4;
+      int j = pos.getY() >> 4;
+      int k = pos.getZ() >> 4;
+      if (j >= 0 && j < this.countChunksY) {
+         i %= this.countChunksX;
+         if (i < 0) {
+            i += this.countChunksX;
          }
 
-         ☃xx %= this.countChunksZ;
-         if (☃xx < 0) {
-            ☃xx += this.countChunksZ;
+         k %= this.countChunksZ;
+         if (k < 0) {
+            k += this.countChunksZ;
          }
 
-         int ☃xxx = (☃xx * this.countChunksY + ☃x) * this.countChunksX + ☃;
-         return this.renderChunks[☃xxx];
+         int l = (k * this.countChunksY + j) * this.countChunksX + i;
+         return this.renderChunks[l];
       } else {
          return null;
       }
    }
+
+   private void updateVboRegion(RenderChunk renderChunk) {
+      BlockPos pos = renderChunk.getPosition();
+      int rx = pos.getX() >> 8 << 8;
+      int rz = pos.getZ() >> 8 << 8;
+      ChunkPos cp = new ChunkPos(rx, rz);
+      BlockRenderLayer[] layers = BlockRenderLayer.values();
+      VboRegion[] regions = this.mapVboRegions.get(cp);
+      if (regions == null) {
+         regions = new VboRegion[layers.length];
+
+         for (int ix = 0; ix < layers.length; ix++) {
+            regions[ix] = new VboRegion(layers[ix]);
+         }
+
+         this.mapVboRegions.put(cp, regions);
+      }
+
+      for (int ix = 0; ix < layers.length; ix++) {
+         VboRegion vr = regions[ix];
+         if (vr != null) {
+            renderChunk.getVertexBufferByLayer(ix).setVboRegion(vr);
+         }
+      }
+   }
+
+   public void deleteVboRegions() {
+      for (ChunkPos cp : this.mapVboRegions.keySet()) {
+         VboRegion[] vboRegions = this.mapVboRegions.get(cp);
+
+         for (int i = 0; i < vboRegions.length; i++) {
+            VboRegion vboRegion = vboRegions[i];
+            if (vboRegion != null) {
+               vboRegion.deleteGlBuffers();
+            }
+
+            vboRegions[i] = null;
+         }
+      }
+
+      this.mapVboRegions.clear();
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/WorldVertexBufferUploader.java b/patches/net/minecraft/client/renderer/WorldVertexBufferUploader.java
index 983904b..e6140c3 100644
--- a/patches/net/minecraft/client/renderer/WorldVertexBufferUploader.java
+++ b/patches/net/minecraft/client/renderer/WorldVertexBufferUploader.java
@@ -5,68 +5,96 @@
 import java.util.List;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.SVertexBuilder;
 
 public class WorldVertexBufferUploader {
-   public void draw(BufferBuilder var1) {
-      if (☃.getVertexCount() > 0) {
-         VertexFormat ☃ = ☃.getVertexFormat();
-         int ☃x = ☃.getSize();
-         ByteBuffer ☃xx = ☃.getByteBuffer();
-         List<VertexFormatElement> ☃xxx = ☃.getElements();
+   public void draw(BufferBuilder vertexBufferIn) {
+      if (vertexBufferIn.getVertexCount() > 0) {
+         if (vertexBufferIn.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
+            vertexBufferIn.quadsToTriangles();
+         }
+
+         VertexFormat vertexformat = vertexBufferIn.getVertexFormat();
+         int i = vertexformat.getSize();
+         ByteBuffer bytebuffer = vertexBufferIn.getByteBuffer();
+         List<VertexFormatElement> list = vertexformat.getElements();
+         boolean forgePreDrawExists = Reflector.ForgeVertexFormatElementEnumUseage_preDraw.exists();
+         boolean forgePostDrawExists = Reflector.ForgeVertexFormatElementEnumUseage_postDraw.exists();
 
-         for (int ☃xxxx = 0; ☃xxxx < ☃xxx.size(); ☃xxxx++) {
-            VertexFormatElement ☃xxxxx = ☃xxx.get(☃xxxx);
-            VertexFormatElement.EnumUsage ☃xxxxxx = ☃xxxxx.getUsage();
-            int ☃xxxxxxx = ☃xxxxx.getType().getGlConstant();
-            int ☃xxxxxxxx = ☃xxxxx.getIndex();
-            ((Buffer)☃xx).position(☃.getOffset(☃xxxx));
-            switch (☃xxxxxx) {
-               case POSITION:
-                  GlStateManager.glVertexPointer(☃xxxxx.getElementCount(), ☃xxxxxxx, ☃x, ☃xx);
-                  GlStateManager.glEnableClientState(32884);
-                  break;
-               case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + ☃xxxxxxxx);
-                  GlStateManager.glTexCoordPointer(☃xxxxx.getElementCount(), ☃xxxxxxx, ☃x, ☃xx);
-                  GlStateManager.glEnableClientState(32888);
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
-                  break;
-               case COLOR:
-                  GlStateManager.glColorPointer(☃xxxxx.getElementCount(), ☃xxxxxxx, ☃x, ☃xx);
-                  GlStateManager.glEnableClientState(32886);
-                  break;
-               case NORMAL:
-                  GlStateManager.glNormalPointer(☃xxxxxxx, ☃x, ☃xx);
-                  GlStateManager.glEnableClientState(32885);
+         for (int j = 0; j < list.size(); j++) {
+            VertexFormatElement vertexformatelement = list.get(j);
+            EnumUsage vertexformatelement$enumusage = vertexformatelement.getUsage();
+            if (forgePreDrawExists) {
+               Reflector.callVoid(
+                  vertexformatelement$enumusage, Reflector.ForgeVertexFormatElementEnumUseage_preDraw, new Object[]{vertexformat, j, i, bytebuffer}
+               );
+            } else {
+               int k = vertexformatelement.getType().getGlConstant();
+               int l = vertexformatelement.getIndex();
+               ((Buffer)bytebuffer).position(vertexformat.getOffset(j));
+               switch (vertexformatelement$enumusage) {
+                  case POSITION:
+                     GlStateManager.glVertexPointer(vertexformatelement.getElementCount(), k, i, bytebuffer);
+                     GlStateManager.glEnableClientState(32884);
+                     break;
+                  case UV:
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + l);
+                     GlStateManager.glTexCoordPointer(vertexformatelement.getElementCount(), k, i, bytebuffer);
+                     GlStateManager.glEnableClientState(32888);
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+                     break;
+                  case COLOR:
+                     GlStateManager.glColorPointer(vertexformatelement.getElementCount(), k, i, bytebuffer);
+                     GlStateManager.glEnableClientState(32886);
+                     break;
+                  case NORMAL:
+                     GlStateManager.glNormalPointer(k, i, bytebuffer);
+                     GlStateManager.glEnableClientState(32885);
+               }
             }
          }
 
-         GlStateManager.glDrawArrays(☃.getDrawMode(), 0, ☃.getVertexCount());
-         int ☃xxxx = 0;
+         if (vertexBufferIn.isMultiTexture()) {
+            vertexBufferIn.drawMultiTexture();
+         } else if (Config.isShaders()) {
+            SVertexBuilder.drawArrays(vertexBufferIn.getDrawMode(), 0, vertexBufferIn.getVertexCount(), vertexBufferIn);
+         } else {
+            GlStateManager.glDrawArrays(vertexBufferIn.getDrawMode(), 0, vertexBufferIn.getVertexCount());
+         }
+
+         int i1 = 0;
 
-         for (int ☃xxxxx = ☃xxx.size(); ☃xxxx < ☃xxxxx; ☃xxxx++) {
-            VertexFormatElement ☃xxxxxx = ☃xxx.get(☃xxxx);
-            VertexFormatElement.EnumUsage ☃xxxxxxx = ☃xxxxxx.getUsage();
-            int ☃xxxxxxxx = ☃xxxxxx.getIndex();
-            switch (☃xxxxxxx) {
-               case POSITION:
-                  GlStateManager.glDisableClientState(32884);
-                  break;
-               case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + ☃xxxxxxxx);
-                  GlStateManager.glDisableClientState(32888);
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
-                  break;
-               case COLOR:
-                  GlStateManager.glDisableClientState(32886);
-                  GlStateManager.resetColor();
-                  break;
-               case NORMAL:
-                  GlStateManager.glDisableClientState(32885);
+         for (int j1 = list.size(); i1 < j1; i1++) {
+            VertexFormatElement vertexformatelement1 = list.get(i1);
+            EnumUsage vertexformatelement$enumusage1 = vertexformatelement1.getUsage();
+            if (forgePostDrawExists) {
+               Reflector.callVoid(
+                  vertexformatelement$enumusage1, Reflector.ForgeVertexFormatElementEnumUseage_postDraw, new Object[]{vertexformat, i1, i, bytebuffer}
+               );
+            } else {
+               int k1 = vertexformatelement1.getIndex();
+               switch (vertexformatelement$enumusage1) {
+                  case POSITION:
+                     GlStateManager.glDisableClientState(32884);
+                     break;
+                  case UV:
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + k1);
+                     GlStateManager.glDisableClientState(32888);
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+                     break;
+                  case COLOR:
+                     GlStateManager.glDisableClientState(32886);
+                     GlStateManager.resetColor();
+                     break;
+                  case NORMAL:
+                     GlStateManager.glDisableClientState(32885);
+               }
             }
          }
       }
 
-      ☃.reset();
+      vertexBufferIn.reset();
    }
 }
diff --git a/patches/net/minecraft/client/renderer/block/model/BakedQuad.java b/patches/net/minecraft/client/renderer/block/model/BakedQuad.java
index 7550c9e..b8082c9 100644
--- a/patches/net/minecraft/client/renderer/block/model/BakedQuad.java
+++ b/patches/net/minecraft/client/renderer/block/model/BakedQuad.java
@@ -1,26 +1,55 @@
 package net.minecraft.client.renderer.block.model;
 
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.util.EnumFacing;
+import net.minecraftforge.client.model.pipeline.IVertexConsumer;
+import net.minecraftforge.client.model.pipeline.IVertexProducer;
+import net.optifine.model.QuadBounds;
+import net.optifine.reflect.Reflector;
 
-public class BakedQuad {
-   protected final int[] vertexData;
+public class BakedQuad implements IVertexProducer {
+   protected int[] vertexData;
    protected final int tintIndex;
-   protected final EnumFacing face;
-   protected final TextureAtlasSprite sprite;
+   protected EnumFacing face;
+   protected TextureAtlasSprite sprite;
+   private int[] vertexDataSingle = null;
+   protected boolean applyDiffuseLighting = Reflector.ForgeHooksClient_fillNormal.exists();
+   protected VertexFormat format = DefaultVertexFormats.ITEM;
+   private QuadBounds quadBounds;
+   private boolean quadEmissiveChecked;
+   private BakedQuad quadEmissive;
 
-   public BakedQuad(int[] var1, int var2, EnumFacing var3, TextureAtlasSprite var4) {
-      this.vertexData = ☃;
-      this.tintIndex = ☃;
-      this.face = ☃;
-      this.sprite = ☃;
+   public BakedQuad(int[] vertexDataIn, int tintIndexIn, EnumFacing faceIn, TextureAtlasSprite spriteIn, boolean applyDiffuseLighting, VertexFormat format) {
+      this.vertexData = vertexDataIn;
+      this.tintIndex = tintIndexIn;
+      this.face = faceIn;
+      this.sprite = spriteIn;
+      this.applyDiffuseLighting = applyDiffuseLighting;
+      this.format = format;
+      this.fixVertexData();
+   }
+
+   public BakedQuad(int[] vertexDataIn, int tintIndexIn, EnumFacing faceIn, TextureAtlasSprite spriteIn) {
+      this.vertexData = vertexDataIn;
+      this.tintIndex = tintIndexIn;
+      this.face = faceIn;
+      this.sprite = spriteIn;
+      this.fixVertexData();
    }
 
    public TextureAtlasSprite getSprite() {
+      if (this.sprite == null) {
+         this.sprite = getSpriteByUv(this.getVertexData());
+      }
+
       return this.sprite;
    }
 
    public int[] getVertexData() {
+      this.fixVertexData();
       return this.vertexData;
    }
 
@@ -33,6 +62,158 @@ public int getTintIndex() {
    }
 
    public EnumFacing getFace() {
+      if (this.face == null) {
+         this.face = FaceBakery.getFacingFromVertexData(this.getVertexData());
+      }
+
       return this.face;
    }
+
+   public int[] getVertexDataSingle() {
+      if (this.vertexDataSingle == null) {
+         this.vertexDataSingle = makeVertexDataSingle(this.getVertexData(), this.getSprite());
+      }
+
+      return this.vertexDataSingle;
+   }
+
+   private static int[] makeVertexDataSingle(int[] vd, TextureAtlasSprite sprite) {
+      int[] vdSingle = (int[])vd.clone();
+      int step = vdSingle.length / 4;
+
+      for (int i = 0; i < 4; i++) {
+         int pos = i * step;
+         float tu = Float.intBitsToFloat(vdSingle[pos + 4]);
+         float tv = Float.intBitsToFloat(vdSingle[pos + 4 + 1]);
+         float u = sprite.toSingleU(tu);
+         float v = sprite.toSingleV(tv);
+         vdSingle[pos + 4] = Float.floatToRawIntBits(u);
+         vdSingle[pos + 4 + 1] = Float.floatToRawIntBits(v);
+      }
+
+      return vdSingle;
+   }
+
+   public void pipe(IVertexConsumer consumer) {
+      Reflector.callVoid(Reflector.LightUtil_putBakedQuad, new Object[]{consumer, this});
+   }
+
+   public VertexFormat getFormat() {
+      return this.format;
+   }
+
+   public boolean shouldApplyDiffuseLighting() {
+      return this.applyDiffuseLighting;
+   }
+
+   private static TextureAtlasSprite getSpriteByUv(int[] vertexData) {
+      float uMin = 1.0F;
+      float vMin = 1.0F;
+      float uMax = 0.0F;
+      float vMax = 0.0F;
+      int step = vertexData.length / 4;
+
+      for (int i = 0; i < 4; i++) {
+         int pos = i * step;
+         float tu = Float.intBitsToFloat(vertexData[pos + 4]);
+         float tv = Float.intBitsToFloat(vertexData[pos + 4 + 1]);
+         uMin = Math.min(uMin, tu);
+         vMin = Math.min(vMin, tv);
+         uMax = Math.max(uMax, tu);
+         vMax = Math.max(vMax, tv);
+      }
+
+      float uMid = (uMin + uMax) / 2.0F;
+      float vMid = (vMin + vMax) / 2.0F;
+      return Minecraft.getMinecraft().getTextureMapBlocks().getIconByUV(uMid, vMid);
+   }
+
+   protected void fixVertexData() {
+      if (Config.isShaders()) {
+         if (this.vertexData.length == 28) {
+            this.vertexData = expandVertexData(this.vertexData);
+         }
+      } else if (this.vertexData.length == 56) {
+         this.vertexData = compactVertexData(this.vertexData);
+      }
+   }
+
+   private static int[] expandVertexData(int[] vd) {
+      int step = vd.length / 4;
+      int stepNew = step * 2;
+      int[] vdNew = new int[stepNew * 4];
+
+      for (int i = 0; i < 4; i++) {
+         System.arraycopy(vd, i * step, vdNew, i * stepNew, step);
+      }
+
+      return vdNew;
+   }
+
+   private static int[] compactVertexData(int[] vd) {
+      int step = vd.length / 4;
+      int stepNew = step / 2;
+      int[] vdNew = new int[stepNew * 4];
+
+      for (int i = 0; i < 4; i++) {
+         System.arraycopy(vd, i * step, vdNew, i * stepNew, stepNew);
+      }
+
+      return vdNew;
+   }
+
+   public QuadBounds getQuadBounds() {
+      if (this.quadBounds == null) {
+         this.quadBounds = new QuadBounds(this.getVertexData());
+      }
+
+      return this.quadBounds;
+   }
+
+   public float getMidX() {
+      QuadBounds qb = this.getQuadBounds();
+      return (qb.getMaxX() + qb.getMinX()) / 2.0F;
+   }
+
+   public double getMidY() {
+      QuadBounds qb = this.getQuadBounds();
+      return (qb.getMaxY() + qb.getMinY()) / 2.0F;
+   }
+
+   public double getMidZ() {
+      QuadBounds qb = this.getQuadBounds();
+      return (qb.getMaxZ() + qb.getMinZ()) / 2.0F;
+   }
+
+   public boolean isFaceQuad() {
+      QuadBounds qb = this.getQuadBounds();
+      return qb.isFaceQuad(this.face);
+   }
+
+   public boolean isFullQuad() {
+      QuadBounds qb = this.getQuadBounds();
+      return qb.isFullQuad(this.face);
+   }
+
+   public boolean isFullFaceQuad() {
+      return this.isFullQuad() && this.isFaceQuad();
+   }
+
+   public BakedQuad getQuadEmissive() {
+      if (this.quadEmissiveChecked) {
+         return this.quadEmissive;
+      } else {
+         if (this.quadEmissive == null && this.sprite != null && this.sprite.spriteEmissive != null) {
+            this.quadEmissive = new BakedQuadRetextured(this, this.sprite.spriteEmissive);
+         }
+
+         this.quadEmissiveChecked = true;
+         return this.quadEmissive;
+      }
+   }
+
+   @Override
+   public String toString() {
+      return "vertex: " + this.vertexData.length / 7 + ", tint: " + this.tintIndex + ", facing: " + this.face + ", sprite: " + this.sprite;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java b/patches/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java
index 419883f..f2f9dfb 100644
--- a/patches/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java
+++ b/patches/net/minecraft/client/renderer/block/model/BakedQuadRetextured.java
@@ -5,22 +5,40 @@
 
 public class BakedQuadRetextured extends BakedQuad {
    private final TextureAtlasSprite texture;
+   private final TextureAtlasSprite spriteOld;
 
-   public BakedQuadRetextured(BakedQuad var1, TextureAtlasSprite var2) {
-      super(Arrays.copyOf(☃.getVertexData(), ☃.getVertexData().length), ☃.tintIndex, FaceBakery.getFacingFromVertexData(☃.getVertexData()), ☃.getSprite());
-      this.texture = ☃;
+   public BakedQuadRetextured(BakedQuad quad, TextureAtlasSprite textureIn) {
+      super(
+         Arrays.copyOf(quad.getVertexData(), quad.getVertexData().length),
+         quad.tintIndex,
+         FaceBakery.getFacingFromVertexData(quad.getVertexData()),
+         textureIn,
+         quad.applyDiffuseLighting,
+         quad.format
+      );
+      this.texture = textureIn;
+      this.format = quad.format;
+      this.applyDiffuseLighting = quad.applyDiffuseLighting;
+      this.spriteOld = quad.getSprite();
       this.remapQuad();
+      this.fixVertexData();
    }
 
    private void remapQuad() {
-      for (int ☃ = 0; ☃ < 4; ☃++) {
-         int ☃x = 7 * ☃;
-         this.vertexData[☃x + 4] = Float.floatToRawIntBits(
-            this.texture.getInterpolatedU(this.sprite.getUnInterpolatedU(Float.intBitsToFloat(this.vertexData[☃x + 4])))
+      for (int i = 0; i < 4; i++) {
+         int j = this.format.getIntegerSize() * i;
+         int uvIndex = this.format.getUvOffsetById(0) / 4;
+         this.vertexData[j + uvIndex] = Float.floatToRawIntBits(
+            this.texture.getInterpolatedU(this.spriteOld.getUnInterpolatedU(Float.intBitsToFloat(this.vertexData[j + uvIndex])))
          );
-         this.vertexData[☃x + 4 + 1] = Float.floatToRawIntBits(
-            this.texture.getInterpolatedV(this.sprite.getUnInterpolatedV(Float.intBitsToFloat(this.vertexData[☃x + 4 + 1])))
+         this.vertexData[j + uvIndex + 1] = Float.floatToRawIntBits(
+            this.texture.getInterpolatedV(this.spriteOld.getUnInterpolatedV(Float.intBitsToFloat(this.vertexData[j + uvIndex + 1])))
          );
       }
    }
+
+   @Override
+   public TextureAtlasSprite getSprite() {
+      return this.texture;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/block/model/FaceBakery.java b/patches/net/minecraft/client/renderer/block/model/FaceBakery.java
index e3a66c5..5e3732c 100644
--- a/patches/net/minecraft/client/renderer/block/model/FaceBakery.java
+++ b/patches/net/minecraft/client/renderer/block/model/FaceBakery.java
@@ -2,310 +2,390 @@
 
 import javax.annotation.Nullable;
 import net.minecraft.client.renderer.EnumFaceDirection;
+import net.minecraft.client.renderer.EnumFaceDirection.Constants;
+import net.minecraft.client.renderer.EnumFaceDirection.VertexInformation;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3i;
+import net.minecraftforge.common.model.ITransformation;
+import net.optifine.model.BlockModelUtils;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 import org.lwjgl.util.vector.Matrix4f;
 import org.lwjgl.util.vector.Vector3f;
 import org.lwjgl.util.vector.Vector4f;
 
 public class FaceBakery {
    private static final float SCALE_ROTATION_22_5 = 1.0F / (float)Math.cos((float) (Math.PI / 8)) - 1.0F;
-   private static final float SCALE_ROTATION_GENERAL = 1.0F / (float)Math.cos((float) (Math.PI / 4)) - 1.0F;
+   private static final float SCALE_ROTATION_GENERAL = 1.0F / (float)Math.cos(Math.PI / 4) - 1.0F;
    private static final FaceBakery.Rotation[] UV_ROTATIONS = new FaceBakery.Rotation[ModelRotation.values().length * EnumFacing.values().length];
    private static final FaceBakery.Rotation UV_ROTATION_0 = new FaceBakery.Rotation() {
       @Override
-      BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4) {
-         return new BlockFaceUV(new float[]{☃, ☃, ☃, ☃}, 0);
+      BlockFaceUV makeRotatedUV(float p_188007_1_, float p_188007_2_, float p_188007_3_, float p_188007_4_) {
+         return new BlockFaceUV(new float[]{p_188007_1_, p_188007_2_, p_188007_3_, p_188007_4_}, 0);
       }
    };
    private static final FaceBakery.Rotation UV_ROTATION_270 = new FaceBakery.Rotation() {
       @Override
-      BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4) {
-         return new BlockFaceUV(new float[]{☃, 16.0F - ☃, ☃, 16.0F - ☃}, 270);
+      BlockFaceUV makeRotatedUV(float p_188007_1_, float p_188007_2_, float p_188007_3_, float p_188007_4_) {
+         return new BlockFaceUV(new float[]{p_188007_4_, 16.0F - p_188007_1_, p_188007_2_, 16.0F - p_188007_3_}, 270);
       }
    };
    private static final FaceBakery.Rotation UV_ROTATION_INVERSE = new FaceBakery.Rotation() {
       @Override
-      BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4) {
-         return new BlockFaceUV(new float[]{16.0F - ☃, 16.0F - ☃, 16.0F - ☃, 16.0F - ☃}, 0);
+      BlockFaceUV makeRotatedUV(float p_188007_1_, float p_188007_2_, float p_188007_3_, float p_188007_4_) {
+         return new BlockFaceUV(new float[]{16.0F - p_188007_1_, 16.0F - p_188007_2_, 16.0F - p_188007_3_, 16.0F - p_188007_4_}, 0);
       }
    };
    private static final FaceBakery.Rotation UV_ROTATION_90 = new FaceBakery.Rotation() {
       @Override
-      BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4) {
-         return new BlockFaceUV(new float[]{16.0F - ☃, ☃, 16.0F - ☃, ☃}, 90);
+      BlockFaceUV makeRotatedUV(float p_188007_1_, float p_188007_2_, float p_188007_3_, float p_188007_4_) {
+         return new BlockFaceUV(new float[]{16.0F - p_188007_2_, p_188007_3_, 16.0F - p_188007_4_, p_188007_1_}, 90);
       }
    };
 
    public BakedQuad makeBakedQuad(
-      Vector3f var1,
-      Vector3f var2,
-      BlockPartFace var3,
-      TextureAtlasSprite var4,
-      EnumFacing var5,
-      ModelRotation var6,
-      @Nullable BlockPartRotation var7,
-      boolean var8,
-      boolean var9
+      Vector3f posFrom,
+      Vector3f posTo,
+      BlockPartFace face,
+      TextureAtlasSprite sprite,
+      EnumFacing facing,
+      ModelRotation modelRotationIn,
+      @Nullable BlockPartRotation partRotation,
+      boolean uvLocked,
+      boolean shade
    ) {
-      BlockFaceUV ☃ = ☃.blockFaceUV;
-      if (☃) {
-         ☃ = this.applyUVLock(☃.blockFaceUV, ☃, ☃);
+      return this.makeBakedQuad(posFrom, posTo, face, sprite, facing, (ITransformation)modelRotationIn, partRotation, uvLocked, shade);
+   }
+
+   public BakedQuad makeBakedQuad(
+      Vector3f posFrom,
+      Vector3f posTo,
+      BlockPartFace face,
+      TextureAtlasSprite sprite,
+      EnumFacing facing,
+      ITransformation modelRotationIn,
+      BlockPartRotation partRotation,
+      boolean uvLocked,
+      boolean shade
+   ) {
+      BlockFaceUV blockfaceuv = face.blockFaceUV;
+      if (uvLocked) {
+         if (Reflector.ForgeHooksClient_applyUVLock.exists()) {
+            blockfaceuv = (BlockFaceUV)Reflector.call(Reflector.ForgeHooksClient_applyUVLock, new Object[]{face.blockFaceUV, facing, modelRotationIn});
+         } else {
+            blockfaceuv = this.applyUVLock(face.blockFaceUV, facing, (ModelRotation)modelRotationIn);
+         }
       }
 
-      int[] ☃x = this.makeQuadVertexData(☃, ☃, ☃, this.getPositionsDiv16(☃, ☃), ☃, ☃, ☃);
-      EnumFacing ☃xx = getFacingFromVertexData(☃x);
-      if (☃ == null) {
-         this.applyFacing(☃x, ☃xx);
+      boolean quadShade = shade && !Reflector.ForgeHooksClient_fillNormal.exists();
+      int[] aint = this.makeQuadVertexData(blockfaceuv, sprite, facing, this.getPositionsDiv16(posFrom, posTo), modelRotationIn, partRotation, quadShade);
+      EnumFacing enumfacing = getFacingFromVertexData(aint);
+      if (partRotation == null) {
+         this.applyFacing(aint, enumfacing);
       }
 
-      return new BakedQuad(☃x, ☃.tintIndex, ☃xx, ☃);
+      if (Reflector.ForgeHooksClient_fillNormal.exists()) {
+         Reflector.call(Reflector.ForgeHooksClient_fillNormal, new Object[]{aint, enumfacing});
+         return new BakedQuad(aint, face.tintIndex, enumfacing, sprite, shade, DefaultVertexFormats.ITEM);
+      } else {
+         return new BakedQuad(aint, face.tintIndex, enumfacing, sprite);
+      }
    }
 
-   private BlockFaceUV applyUVLock(BlockFaceUV var1, EnumFacing var2, ModelRotation var3) {
-      return UV_ROTATIONS[getIndex(☃, ☃)].rotateUV(☃);
+   private BlockFaceUV applyUVLock(BlockFaceUV p_188010_1_, EnumFacing p_188010_2_, ModelRotation p_188010_3_) {
+      return UV_ROTATIONS[getIndex(p_188010_3_, p_188010_2_)].rotateUV(p_188010_1_);
    }
 
    private int[] makeQuadVertexData(
-      BlockFaceUV var1, TextureAtlasSprite var2, EnumFacing var3, float[] var4, ModelRotation var5, @Nullable BlockPartRotation var6, boolean var7
+      BlockFaceUV uvs,
+      TextureAtlasSprite sprite,
+      EnumFacing orientation,
+      float[] p_188012_4_,
+      ITransformation rotationIn,
+      @Nullable BlockPartRotation partRotation,
+      boolean shade
    ) {
-      int[] ☃ = new int[28];
+      int vertexSize = 28;
+      if (Config.isShaders()) {
+         vertexSize = 56;
+      }
 
-      for (int ☃x = 0; ☃x < 4; ☃x++) {
-         this.fillVertexData(☃, ☃x, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+      int[] aint = new int[vertexSize];
+
+      for (int i = 0; i < 4; i++) {
+         this.fillVertexData(aint, i, orientation, uvs, p_188012_4_, sprite, rotationIn, partRotation, shade);
       }
 
-      return ☃;
+      return aint;
    }
 
-   private int getFaceShadeColor(EnumFacing var1) {
-      float ☃ = this.getFaceBrightness(☃);
-      int ☃x = MathHelper.clamp((int)(☃ * 255.0F), 0, 255);
-      return 0xFF000000 | ☃x << 16 | ☃x << 8 | ☃x;
+   private int getFaceShadeColor(EnumFacing facing) {
+      float f = getFaceBrightness(facing);
+      int i = MathHelper.clamp((int)(f * 255.0F), 0, 255);
+      return 0xFF000000 | i << 16 | i << 8 | i;
    }
 
-   private float getFaceBrightness(EnumFacing var1) {
-      switch (☃) {
+   public static float getFaceBrightness(EnumFacing facing) {
+      switch (facing) {
          case DOWN:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel05;
+            }
+
             return 0.5F;
          case UP:
             return 1.0F;
          case NORTH:
          case SOUTH:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel08;
+            }
+
             return 0.8F;
          case WEST:
          case EAST:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel06;
+            }
+
             return 0.6F;
          default:
             return 1.0F;
       }
    }
 
-   private float[] getPositionsDiv16(Vector3f var1, Vector3f var2) {
-      float[] ☃ = new float[EnumFacing.values().length];
-      ☃[EnumFaceDirection.Constants.WEST_INDEX] = ☃.x / 16.0F;
-      ☃[EnumFaceDirection.Constants.DOWN_INDEX] = ☃.y / 16.0F;
-      ☃[EnumFaceDirection.Constants.NORTH_INDEX] = ☃.z / 16.0F;
-      ☃[EnumFaceDirection.Constants.EAST_INDEX] = ☃.x / 16.0F;
-      ☃[EnumFaceDirection.Constants.UP_INDEX] = ☃.y / 16.0F;
-      ☃[EnumFaceDirection.Constants.SOUTH_INDEX] = ☃.z / 16.0F;
-      return ☃;
+   private float[] getPositionsDiv16(Vector3f pos1, Vector3f pos2) {
+      float[] afloat = new float[EnumFacing.values().length];
+      afloat[Constants.WEST_INDEX] = pos1.x / 16.0F;
+      afloat[Constants.DOWN_INDEX] = pos1.y / 16.0F;
+      afloat[Constants.NORTH_INDEX] = pos1.z / 16.0F;
+      afloat[Constants.EAST_INDEX] = pos2.x / 16.0F;
+      afloat[Constants.UP_INDEX] = pos2.y / 16.0F;
+      afloat[Constants.SOUTH_INDEX] = pos2.z / 16.0F;
+      return afloat;
    }
 
    private void fillVertexData(
-      int[] var1,
-      int var2,
-      EnumFacing var3,
-      BlockFaceUV var4,
-      float[] var5,
-      TextureAtlasSprite var6,
-      ModelRotation var7,
-      @Nullable BlockPartRotation var8,
-      boolean var9
+      int[] p_188015_1_,
+      int p_188015_2_,
+      EnumFacing p_188015_3_,
+      BlockFaceUV p_188015_4_,
+      float[] p_188015_5_,
+      TextureAtlasSprite p_188015_6_,
+      ITransformation p_188015_7_,
+      @Nullable BlockPartRotation p_188015_8_,
+      boolean p_188015_9_
    ) {
-      EnumFacing ☃ = ☃.rotateFace(☃);
-      int ☃x = ☃ ? this.getFaceShadeColor(☃) : -1;
-      EnumFaceDirection.VertexInformation ☃xx = EnumFaceDirection.getFacing(☃).getVertexInformation(☃);
-      Vector3f ☃xxx = new Vector3f(☃[☃xx.xIndex], ☃[☃xx.yIndex], ☃[☃xx.zIndex]);
-      this.rotatePart(☃xxx, ☃);
-      int ☃xxxx = this.rotateVertex(☃xxx, ☃, ☃, ☃);
-      this.storeVertexData(☃, ☃xxxx, ☃, ☃xxx, ☃x, ☃, ☃);
+      EnumFacing enumfacing = p_188015_7_.rotate(p_188015_3_);
+      int i = p_188015_9_ ? this.getFaceShadeColor(enumfacing) : -1;
+      VertexInformation enumfacedirection$vertexinformation = EnumFaceDirection.getFacing(p_188015_3_).getVertexInformation(p_188015_2_);
+      Vector3f vector3f = new Vector3f(
+         p_188015_5_[enumfacedirection$vertexinformation.xIndex],
+         p_188015_5_[enumfacedirection$vertexinformation.yIndex],
+         p_188015_5_[enumfacedirection$vertexinformation.zIndex]
+      );
+      this.rotatePart(vector3f, p_188015_8_);
+      int j = this.rotateVertex(vector3f, p_188015_3_, p_188015_2_, p_188015_7_);
+      BlockModelUtils.snapVertexPosition(vector3f);
+      this.storeVertexData(p_188015_1_, j, p_188015_2_, vector3f, i, p_188015_6_, p_188015_4_);
    }
 
-   private void storeVertexData(int[] var1, int var2, int var3, Vector3f var4, int var5, TextureAtlasSprite var6, BlockFaceUV var7) {
-      int ☃ = ☃ * 7;
-      ☃[☃] = Float.floatToRawIntBits(☃.x);
-      ☃[☃ + 1] = Float.floatToRawIntBits(☃.y);
-      ☃[☃ + 2] = Float.floatToRawIntBits(☃.z);
-      ☃[☃ + 3] = ☃;
-      ☃[☃ + 4] = Float.floatToRawIntBits(☃.getInterpolatedU(☃.getVertexU(☃)));
-      ☃[☃ + 4 + 1] = Float.floatToRawIntBits(☃.getInterpolatedV(☃.getVertexV(☃)));
+   private void storeVertexData(
+      int[] faceData, int storeIndex, int vertexIndex, Vector3f position, int shadeColor, TextureAtlasSprite sprite, BlockFaceUV faceUV
+   ) {
+      int step = faceData.length / 4;
+      int i = storeIndex * step;
+      faceData[i] = Float.floatToRawIntBits(position.x);
+      faceData[i + 1] = Float.floatToRawIntBits(position.y);
+      faceData[i + 2] = Float.floatToRawIntBits(position.z);
+      faceData[i + 3] = shadeColor;
+      faceData[i + 4] = Float.floatToRawIntBits(
+         sprite.getInterpolatedU(faceUV.getVertexU(vertexIndex) * 0.999 + faceUV.getVertexU((vertexIndex + 2) % 4) * 0.001)
+      );
+      faceData[i + 4 + 1] = Float.floatToRawIntBits(
+         sprite.getInterpolatedV(faceUV.getVertexV(vertexIndex) * 0.999 + faceUV.getVertexV((vertexIndex + 2) % 4) * 0.001)
+      );
    }
 
-   private void rotatePart(Vector3f var1, @Nullable BlockPartRotation var2) {
-      if (☃ != null) {
-         Matrix4f ☃ = this.getMatrixIdentity();
-         Vector3f ☃x = new Vector3f(0.0F, 0.0F, 0.0F);
-         switch (☃.axis) {
+   private void rotatePart(Vector3f p_178407_1_, @Nullable BlockPartRotation partRotation) {
+      if (partRotation != null) {
+         Matrix4f matrix4f = this.getMatrixIdentity();
+         Vector3f vector3f = new Vector3f(0.0F, 0.0F, 0.0F);
+         switch (partRotation.axis) {
             case X:
-               Matrix4f.rotate(☃.angle * (float) (Math.PI / 180.0), new Vector3f(1.0F, 0.0F, 0.0F), ☃, ☃);
-               ☃x.set(0.0F, 1.0F, 1.0F);
+               Matrix4f.rotate(partRotation.angle * (float) (Math.PI / 180.0), new Vector3f(1.0F, 0.0F, 0.0F), matrix4f, matrix4f);
+               vector3f.set(0.0F, 1.0F, 1.0F);
                break;
             case Y:
-               Matrix4f.rotate(☃.angle * (float) (Math.PI / 180.0), new Vector3f(0.0F, 1.0F, 0.0F), ☃, ☃);
-               ☃x.set(1.0F, 0.0F, 1.0F);
+               Matrix4f.rotate(partRotation.angle * (float) (Math.PI / 180.0), new Vector3f(0.0F, 1.0F, 0.0F), matrix4f, matrix4f);
+               vector3f.set(1.0F, 0.0F, 1.0F);
                break;
             case Z:
-               Matrix4f.rotate(☃.angle * (float) (Math.PI / 180.0), new Vector3f(0.0F, 0.0F, 1.0F), ☃, ☃);
-               ☃x.set(1.0F, 1.0F, 0.0F);
+               Matrix4f.rotate(partRotation.angle * (float) (Math.PI / 180.0), new Vector3f(0.0F, 0.0F, 1.0F), matrix4f, matrix4f);
+               vector3f.set(1.0F, 1.0F, 0.0F);
          }
 
-         if (☃.rescale) {
-            if (Math.abs(☃.angle) == 22.5F) {
-               ☃x.scale(SCALE_ROTATION_22_5);
+         if (partRotation.rescale) {
+            if (Math.abs(partRotation.angle) == 22.5F) {
+               vector3f.scale(SCALE_ROTATION_22_5);
             } else {
-               ☃x.scale(SCALE_ROTATION_GENERAL);
+               vector3f.scale(SCALE_ROTATION_GENERAL);
             }
 
-            Vector3f.add(☃x, new Vector3f(1.0F, 1.0F, 1.0F), ☃x);
+            Vector3f.add(vector3f, new Vector3f(1.0F, 1.0F, 1.0F), vector3f);
          } else {
-            ☃x.set(1.0F, 1.0F, 1.0F);
+            vector3f.set(1.0F, 1.0F, 1.0F);
          }
 
-         this.rotateScale(☃, new Vector3f(☃.origin), ☃, ☃x);
+         this.rotateScale(p_178407_1_, new Vector3f(partRotation.origin), matrix4f, vector3f);
       }
    }
 
-   public int rotateVertex(Vector3f var1, EnumFacing var2, int var3, ModelRotation var4) {
-      if (☃ == ModelRotation.X0_Y0) {
-         return ☃;
+   public int rotateVertex(Vector3f p_188011_1_, EnumFacing p_188011_2_, int p_188011_3_, ModelRotation p_188011_4_) {
+      return this.rotateVertex(p_188011_1_, p_188011_2_, p_188011_3_, (ITransformation)p_188011_4_);
+   }
+
+   public int rotateVertex(Vector3f position, EnumFacing facing, int vertexIndex, ITransformation modelRotationIn) {
+      if (modelRotationIn == ModelRotation.X0_Y0) {
+         return vertexIndex;
       } else {
-         this.rotateScale(☃, new Vector3f(0.5F, 0.5F, 0.5F), ☃.matrix(), new Vector3f(1.0F, 1.0F, 1.0F));
-         return ☃.rotateVertex(☃, ☃);
+         if (Reflector.ForgeHooksClient_transform.exists()) {
+            Reflector.call(Reflector.ForgeHooksClient_transform, new Object[]{position, modelRotationIn.getMatrix()});
+         } else {
+            this.rotateScale(position, new Vector3f(0.5F, 0.5F, 0.5F), ((ModelRotation)modelRotationIn).matrix(), new Vector3f(1.0F, 1.0F, 1.0F));
+         }
+
+         return modelRotationIn.rotate(facing, vertexIndex);
       }
    }
 
-   private void rotateScale(Vector3f var1, Vector3f var2, Matrix4f var3, Vector3f var4) {
-      Vector4f ☃ = new Vector4f(☃.x - ☃.x, ☃.y - ☃.y, ☃.z - ☃.z, 1.0F);
-      Matrix4f.transform(☃, ☃, ☃);
-      ☃.x = ☃.x * ☃.x;
-      ☃.y = ☃.y * ☃.y;
-      ☃.z = ☃.z * ☃.z;
-      ☃.set(☃.x + ☃.x, ☃.y + ☃.y, ☃.z + ☃.z);
+   private void rotateScale(Vector3f position, Vector3f rotationOrigin, Matrix4f rotationMatrix, Vector3f scale) {
+      Vector4f vector4f = new Vector4f(position.x - rotationOrigin.x, position.y - rotationOrigin.y, position.z - rotationOrigin.z, 1.0F);
+      Matrix4f.transform(rotationMatrix, vector4f, vector4f);
+      vector4f.x = vector4f.x * scale.x;
+      vector4f.y = vector4f.y * scale.y;
+      vector4f.z = vector4f.z * scale.z;
+      position.set(vector4f.x + rotationOrigin.x, vector4f.y + rotationOrigin.y, vector4f.z + rotationOrigin.z);
    }
 
    private Matrix4f getMatrixIdentity() {
-      Matrix4f ☃ = new Matrix4f();
-      ☃.setIdentity();
-      return ☃;
+      Matrix4f matrix4f = new Matrix4f();
+      matrix4f.setIdentity();
+      return matrix4f;
    }
 
-   public static EnumFacing getFacingFromVertexData(int[] var0) {
-      Vector3f ☃ = new Vector3f(Float.intBitsToFloat(☃[0]), Float.intBitsToFloat(☃[1]), Float.intBitsToFloat(☃[2]));
-      Vector3f ☃x = new Vector3f(Float.intBitsToFloat(☃[7]), Float.intBitsToFloat(☃[8]), Float.intBitsToFloat(☃[9]));
-      Vector3f ☃xx = new Vector3f(Float.intBitsToFloat(☃[14]), Float.intBitsToFloat(☃[15]), Float.intBitsToFloat(☃[16]));
-      Vector3f ☃xxx = new Vector3f();
-      Vector3f ☃xxxx = new Vector3f();
-      Vector3f ☃xxxxx = new Vector3f();
-      Vector3f.sub(☃, ☃x, ☃xxx);
-      Vector3f.sub(☃xx, ☃x, ☃xxxx);
-      Vector3f.cross(☃xxxx, ☃xxx, ☃xxxxx);
-      float ☃xxxxxx = (float)Math.sqrt(☃xxxxx.x * ☃xxxxx.x + ☃xxxxx.y * ☃xxxxx.y + ☃xxxxx.z * ☃xxxxx.z);
-      ☃xxxxx.x /= ☃xxxxxx;
-      ☃xxxxx.y /= ☃xxxxxx;
-      ☃xxxxx.z /= ☃xxxxxx;
-      EnumFacing ☃xxxxxxx = null;
-      float ☃xxxxxxxx = 0.0F;
-
-      for (EnumFacing ☃xxxxxxxxx : EnumFacing.values()) {
-         Vec3i ☃xxxxxxxxxx = ☃xxxxxxxxx.getDirectionVec();
-         Vector3f ☃xxxxxxxxxxx = new Vector3f(☃xxxxxxxxxx.getX(), ☃xxxxxxxxxx.getY(), ☃xxxxxxxxxx.getZ());
-         float ☃xxxxxxxxxxxx = Vector3f.dot(☃xxxxx, ☃xxxxxxxxxxx);
-         if (☃xxxxxxxxxxxx >= 0.0F && ☃xxxxxxxxxxxx > ☃xxxxxxxx) {
-            ☃xxxxxxxx = ☃xxxxxxxxxxxx;
-            ☃xxxxxxx = ☃xxxxxxxxx;
+   public static EnumFacing getFacingFromVertexData(int[] faceData) {
+      int step = faceData.length / 4;
+      int step2 = step * 2;
+      Vector3f vector3f = new Vector3f(Float.intBitsToFloat(faceData[0]), Float.intBitsToFloat(faceData[1]), Float.intBitsToFloat(faceData[2]));
+      Vector3f vector3f1 = new Vector3f(
+         Float.intBitsToFloat(faceData[step]), Float.intBitsToFloat(faceData[step + 1]), Float.intBitsToFloat(faceData[step + 2])
+      );
+      Vector3f vector3f2 = new Vector3f(
+         Float.intBitsToFloat(faceData[step2]), Float.intBitsToFloat(faceData[step2 + 1]), Float.intBitsToFloat(faceData[step2 + 2])
+      );
+      Vector3f vector3f3 = new Vector3f();
+      Vector3f vector3f4 = new Vector3f();
+      Vector3f vector3f5 = new Vector3f();
+      Vector3f.sub(vector3f, vector3f1, vector3f3);
+      Vector3f.sub(vector3f2, vector3f1, vector3f4);
+      Vector3f.cross(vector3f4, vector3f3, vector3f5);
+      float f = (float)Math.sqrt(vector3f5.x * vector3f5.x + vector3f5.y * vector3f5.y + vector3f5.z * vector3f5.z);
+      vector3f5.x /= f;
+      vector3f5.y /= f;
+      vector3f5.z /= f;
+      EnumFacing enumfacing = null;
+      float f1 = 0.0F;
+
+      for (EnumFacing enumfacing1 : EnumFacing.values()) {
+         Vec3i vec3i = enumfacing1.getDirectionVec();
+         Vector3f vector3f6 = new Vector3f(vec3i.getX(), vec3i.getY(), vec3i.getZ());
+         float f2 = Vector3f.dot(vector3f5, vector3f6);
+         if (f2 >= 0.0F && f2 > f1) {
+            f1 = f2;
+            enumfacing = enumfacing1;
          }
       }
 
-      return ☃xxxxxxx == null ? EnumFacing.UP : ☃xxxxxxx;
+      return enumfacing == null ? EnumFacing.UP : enumfacing;
    }
 
-   private void applyFacing(int[] var1, EnumFacing var2) {
-      int[] ☃ = new int[☃.length];
-      System.arraycopy(☃, 0, ☃, 0, ☃.length);
-      float[] ☃x = new float[EnumFacing.values().length];
-      ☃x[EnumFaceDirection.Constants.WEST_INDEX] = 999.0F;
-      ☃x[EnumFaceDirection.Constants.DOWN_INDEX] = 999.0F;
-      ☃x[EnumFaceDirection.Constants.NORTH_INDEX] = 999.0F;
-      ☃x[EnumFaceDirection.Constants.EAST_INDEX] = -999.0F;
-      ☃x[EnumFaceDirection.Constants.UP_INDEX] = -999.0F;
-      ☃x[EnumFaceDirection.Constants.SOUTH_INDEX] = -999.0F;
-
-      for (int ☃xx = 0; ☃xx < 4; ☃xx++) {
-         int ☃xxx = 7 * ☃xx;
-         float ☃xxxx = Float.intBitsToFloat(☃[☃xxx]);
-         float ☃xxxxx = Float.intBitsToFloat(☃[☃xxx + 1]);
-         float ☃xxxxxx = Float.intBitsToFloat(☃[☃xxx + 2]);
-         if (☃xxxx < ☃x[EnumFaceDirection.Constants.WEST_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.WEST_INDEX] = ☃xxxx;
+   private void applyFacing(int[] p_178408_1_, EnumFacing p_178408_2_) {
+      int[] aint = new int[p_178408_1_.length];
+      System.arraycopy(p_178408_1_, 0, aint, 0, p_178408_1_.length);
+      float[] afloat = new float[EnumFacing.values().length];
+      afloat[Constants.WEST_INDEX] = 999.0F;
+      afloat[Constants.DOWN_INDEX] = 999.0F;
+      afloat[Constants.NORTH_INDEX] = 999.0F;
+      afloat[Constants.EAST_INDEX] = -999.0F;
+      afloat[Constants.UP_INDEX] = -999.0F;
+      afloat[Constants.SOUTH_INDEX] = -999.0F;
+      int step = p_178408_1_.length / 4;
+
+      for (int i = 0; i < 4; i++) {
+         int j = step * i;
+         float f = Float.intBitsToFloat(aint[j]);
+         float f1 = Float.intBitsToFloat(aint[j + 1]);
+         float f2 = Float.intBitsToFloat(aint[j + 2]);
+         if (f < afloat[Constants.WEST_INDEX]) {
+            afloat[Constants.WEST_INDEX] = f;
          }
 
-         if (☃xxxxx < ☃x[EnumFaceDirection.Constants.DOWN_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.DOWN_INDEX] = ☃xxxxx;
+         if (f1 < afloat[Constants.DOWN_INDEX]) {
+            afloat[Constants.DOWN_INDEX] = f1;
          }
 
-         if (☃xxxxxx < ☃x[EnumFaceDirection.Constants.NORTH_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.NORTH_INDEX] = ☃xxxxxx;
+         if (f2 < afloat[Constants.NORTH_INDEX]) {
+            afloat[Constants.NORTH_INDEX] = f2;
          }
 
-         if (☃xxxx > ☃x[EnumFaceDirection.Constants.EAST_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.EAST_INDEX] = ☃xxxx;
+         if (f > afloat[Constants.EAST_INDEX]) {
+            afloat[Constants.EAST_INDEX] = f;
          }
 
-         if (☃xxxxx > ☃x[EnumFaceDirection.Constants.UP_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.UP_INDEX] = ☃xxxxx;
+         if (f1 > afloat[Constants.UP_INDEX]) {
+            afloat[Constants.UP_INDEX] = f1;
          }
 
-         if (☃xxxxxx > ☃x[EnumFaceDirection.Constants.SOUTH_INDEX]) {
-            ☃x[EnumFaceDirection.Constants.SOUTH_INDEX] = ☃xxxxxx;
+         if (f2 > afloat[Constants.SOUTH_INDEX]) {
+            afloat[Constants.SOUTH_INDEX] = f2;
          }
       }
 
-      EnumFaceDirection ☃xx = EnumFaceDirection.getFacing(☃);
-
-      for (int ☃xxxxxxx = 0; ☃xxxxxxx < 4; ☃xxxxxxx++) {
-         int ☃xxxxxxxx = 7 * ☃xxxxxxx;
-         EnumFaceDirection.VertexInformation ☃xxxxxxxxx = ☃xx.getVertexInformation(☃xxxxxxx);
-         float ☃xxxxxxxxxx = ☃x[☃xxxxxxxxx.xIndex];
-         float ☃xxxxxxxxxxx = ☃x[☃xxxxxxxxx.yIndex];
-         float ☃xxxxxxxxxxxx = ☃x[☃xxxxxxxxx.zIndex];
-         ☃[☃xxxxxxxx] = Float.floatToRawIntBits(☃xxxxxxxxxx);
-         ☃[☃xxxxxxxx + 1] = Float.floatToRawIntBits(☃xxxxxxxxxxx);
-         ☃[☃xxxxxxxx + 2] = Float.floatToRawIntBits(☃xxxxxxxxxxxx);
-
-         for (int ☃xxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxx < 4; ☃xxxxxxxxxxxxx++) {
-            int ☃xxxxxxxxxxxxxx = 7 * ☃xxxxxxxxxxxxx;
-            float ☃xxxxxxxxxxxxxxx = Float.intBitsToFloat(☃[☃xxxxxxxxxxxxxx]);
-            float ☃xxxxxxxxxxxxxxxx = Float.intBitsToFloat(☃[☃xxxxxxxxxxxxxx + 1]);
-            float ☃xxxxxxxxxxxxxxxxx = Float.intBitsToFloat(☃[☃xxxxxxxxxxxxxx + 2]);
-            if (MathHelper.epsilonEquals(☃xxxxxxxxxx, ☃xxxxxxxxxxxxxxx)
-               && MathHelper.epsilonEquals(☃xxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx)
-               && MathHelper.epsilonEquals(☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxx)) {
-               ☃[☃xxxxxxxx + 4] = ☃[☃xxxxxxxxxxxxxx + 4];
-               ☃[☃xxxxxxxx + 4 + 1] = ☃[☃xxxxxxxxxxxxxx + 4 + 1];
+      EnumFaceDirection enumfacedirection = EnumFaceDirection.getFacing(p_178408_2_);
+
+      for (int i1 = 0; i1 < 4; i1++) {
+         int j1 = step * i1;
+         VertexInformation enumfacedirection$vertexinformation = enumfacedirection.getVertexInformation(i1);
+         float f8 = afloat[enumfacedirection$vertexinformation.xIndex];
+         float f3 = afloat[enumfacedirection$vertexinformation.yIndex];
+         float f4 = afloat[enumfacedirection$vertexinformation.zIndex];
+         p_178408_1_[j1] = Float.floatToRawIntBits(f8);
+         p_178408_1_[j1 + 1] = Float.floatToRawIntBits(f3);
+         p_178408_1_[j1 + 2] = Float.floatToRawIntBits(f4);
+
+         for (int k = 0; k < 4; k++) {
+            int l = step * k;
+            float f5 = Float.intBitsToFloat(aint[l]);
+            float f6 = Float.intBitsToFloat(aint[l + 1]);
+            float f7 = Float.intBitsToFloat(aint[l + 2]);
+            if (MathHelper.epsilonEquals(f8, f5) && MathHelper.epsilonEquals(f3, f6) && MathHelper.epsilonEquals(f4, f7)) {
+               p_178408_1_[j1 + 4] = aint[l + 4];
+               p_178408_1_[j1 + 4 + 1] = aint[l + 4 + 1];
             }
          }
       }
    }
 
-   private static void addUvRotation(ModelRotation var0, EnumFacing var1, FaceBakery.Rotation var2) {
-      UV_ROTATIONS[getIndex(☃, ☃)] = ☃;
+   private static void addUvRotation(ModelRotation p_188013_0_, EnumFacing p_188013_1_, FaceBakery.Rotation p_188013_2_) {
+      UV_ROTATIONS[getIndex(p_188013_0_, p_188013_1_)] = p_188013_2_;
    }
 
-   private static int getIndex(ModelRotation var0, EnumFacing var1) {
-      return ModelRotation.values().length * ☃.ordinal() + ☃.ordinal();
+   private static int getIndex(ModelRotation p_188014_0_, EnumFacing p_188014_1_) {
+      return ModelRotation.values().length * p_188014_1_.ordinal() + p_188014_0_.ordinal();
    }
 
    static {
@@ -411,12 +491,12 @@ abstract static class Rotation {
       private Rotation() {
       }
 
-      public BlockFaceUV rotateUV(BlockFaceUV var1) {
-         float ☃ = ☃.getVertexU(☃.getVertexRotatedRev(0));
-         float ☃x = ☃.getVertexV(☃.getVertexRotatedRev(0));
-         float ☃xx = ☃.getVertexU(☃.getVertexRotatedRev(2));
-         float ☃xxx = ☃.getVertexV(☃.getVertexRotatedRev(2));
-         return this.makeRotatedUV(☃, ☃x, ☃xx, ☃xxx);
+      public BlockFaceUV rotateUV(BlockFaceUV p_188006_1_) {
+         float f = p_188006_1_.getVertexU(p_188006_1_.getVertexRotatedRev(0));
+         float f1 = p_188006_1_.getVertexV(p_188006_1_.getVertexRotatedRev(0));
+         float f2 = p_188006_1_.getVertexU(p_188006_1_.getVertexRotatedRev(2));
+         float f3 = p_188006_1_.getVertexV(p_188006_1_.getVertexRotatedRev(2));
+         return this.makeRotatedUV(f, f1, f2, f3);
       }
 
       abstract BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4);
diff --git a/patches/net/minecraft/client/renderer/block/model/ItemOverrideList.java b/patches/net/minecraft/client/renderer/block/model/ItemOverrideList.java
index a89c399..4cc30d6 100644
--- a/patches/net/minecraft/client/renderer/block/model/ItemOverrideList.java
+++ b/patches/net/minecraft/client/renderer/block/model/ItemOverrideList.java
@@ -1,36 +1,78 @@
 package net.minecraft.client.renderer.block.model;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.util.List;
 import javax.annotation.Nullable;
+import net.minecraft.client.Minecraft;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.World;
+import net.optifine.ItemOverrideCache;
+import net.optifine.reflect.Reflector;
 
 public class ItemOverrideList {
    public static final ItemOverrideList NONE = new ItemOverrideList();
    private final List<ItemOverride> overrides = Lists.newArrayList();
+   private ItemOverrideCache itemOverrideCache;
 
    private ItemOverrideList() {
    }
 
-   public ItemOverrideList(List<ItemOverride> var1) {
-      for (int ☃ = ☃.size() - 1; ☃ >= 0; ☃--) {
-         this.overrides.add(☃.get(☃));
+   public ItemOverrideList(List<ItemOverride> overridesIn) {
+      for (int i = overridesIn.size() - 1; i >= 0; i--) {
+         this.overrides.add(overridesIn.get(i));
+      }
+
+      if (this.overrides.size() > 65) {
+         this.itemOverrideCache = ItemOverrideCache.make(this.overrides);
       }
    }
 
    @Nullable
-   public ResourceLocation applyOverride(ItemStack var1, @Nullable World var2, @Nullable EntityLivingBase var3) {
+   public ResourceLocation applyOverride(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn) {
       if (!this.overrides.isEmpty()) {
-         for (ItemOverride ☃ : this.overrides) {
-            if (☃.matchesItemStack(☃, ☃, ☃)) {
-               return ☃.getLocation();
+         if (this.itemOverrideCache != null) {
+            ResourceLocation locationCached = this.itemOverrideCache.getModelLocation(stack, worldIn, entityIn);
+            if (locationCached != null) {
+               return locationCached == ItemOverrideCache.LOCATION_NULL ? null : locationCached;
+            }
+         }
+
+         for (ItemOverride itemoverride : this.overrides) {
+            if (itemoverride.matchesItemStack(stack, worldIn, entityIn)) {
+               if (this.itemOverrideCache != null) {
+                  this.itemOverrideCache.putModelLocation(stack, worldIn, entityIn, itemoverride.getLocation());
+               }
+
+               return itemoverride.getLocation();
             }
          }
+
+         if (this.itemOverrideCache != null) {
+            this.itemOverrideCache.putModelLocation(stack, worldIn, entityIn, ItemOverrideCache.LOCATION_NULL);
+         }
       }
 
       return null;
    }
+
+   public IBakedModel handleItemState(IBakedModel originalModel, ItemStack stack, @Nullable World world, @Nullable EntityLivingBase entity) {
+      if (!stack.isEmpty() && stack.getItem().hasCustomProperties()) {
+         ResourceLocation location = this.applyOverride(stack, world, entity);
+         if (location != null && Reflector.ModelLoader_getInventoryVariant.exists()) {
+            ModelResourceLocation locationVariant = (ModelResourceLocation)Reflector.call(
+               Reflector.ModelLoader_getInventoryVariant, new Object[]{location.toString()}
+            );
+            return Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager().getModel(locationVariant);
+         }
+      }
+
+      return originalModel;
+   }
+
+   public ImmutableList<ItemOverride> getOverrides() {
+      return ImmutableList.copyOf(this.overrides);
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/block/model/ModelBakery.java b/patches/net/minecraft/client/renderer/block/model/ModelBakery.java
index 8cd22cf..e1f2dd5 100644
--- a/patches/net/minecraft/client/renderer/block/model/ModelBakery.java
+++ b/patches/net/minecraft/client/renderer/block/model/ModelBakery.java
@@ -26,6 +26,7 @@
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.renderer.BlockModelShapes;
+import net.minecraft.client.renderer.block.model.MultipartBakedModel.Builder;
 import net.minecraft.client.renderer.block.model.multipart.Multipart;
 import net.minecraft.client.renderer.block.model.multipart.Selector;
 import net.minecraft.client.renderer.block.statemap.BlockStateMapper;
@@ -41,6 +42,13 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.registry.IRegistry;
 import net.minecraft.util.registry.RegistrySimple;
+import net.minecraftforge.common.model.ITransformation;
+import net.minecraftforge.common.model.TRSRTransformation;
+import net.minecraftforge.registries.IRegistryDelegate;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.util.StrUtils;
+import net.optifine.util.TextureUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -101,7 +109,7 @@ public class ModelBakery {
    private final BlockModelShapes blockModelShapes;
    private final FaceBakery faceBakery = new FaceBakery();
    private final ItemModelGenerator itemModelGenerator = new ItemModelGenerator();
-   private final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple<>();
+   private final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple();
    private static final String EMPTY_MODEL_RAW = "{    'elements': [        {   'from': [0, 0, 0],            'to': [16, 16, 16],            'faces': {                'down': {'uv': [0, 0, 16, 16], 'texture': '' }            }        }    ]}"
       .replaceAll("'", "\"");
    private static final ModelBlock MODEL_GENERATED = ModelBlock.deserialize(EMPTY_MODEL_RAW);
@@ -109,11 +117,12 @@ public class ModelBakery {
    private final Map<String, ResourceLocation> itemLocations = Maps.newLinkedHashMap();
    private final Map<ResourceLocation, ModelBlockDefinition> blockDefinitions = Maps.newHashMap();
    private final Map<Item, List<String>> variantNames = Maps.newIdentityHashMap();
+   private static Map<IRegistryDelegate<Item>, Set<String>> customVariantNames = Maps.newHashMap();
 
-   public ModelBakery(IResourceManager var1, TextureMap var2, BlockModelShapes var3) {
-      this.resourceManager = ☃;
-      this.textureMap = ☃;
-      this.blockModelShapes = ☃;
+   public ModelBakery(IResourceManager resourceManagerIn, TextureMap textureMapIn, BlockModelShapes blockModelShapesIn) {
+      this.resourceManager = resourceManagerIn;
+      this.textureMap = textureMapIn;
+      this.blockModelShapes = blockModelShapesIn;
    }
 
    public IRegistry<ModelResourceLocation, IBakedModel> setupModelRegistry() {
@@ -128,43 +137,51 @@ public IRegistry<ModelResourceLocation, IBakedModel> setupModelRegistry() {
    }
 
    private void loadBlocks() {
-      BlockStateMapper ☃ = this.blockModelShapes.getBlockStateMapper();
+      BlockStateMapper blockstatemapper = this.blockModelShapes.getBlockStateMapper();
 
-      for (Block ☃x : Block.REGISTRY) {
-         for (final ResourceLocation ☃xx : ☃.getBlockstateLocations(☃x)) {
+      for (Block block : Block.REGISTRY) {
+         for (ResourceLocation resourcelocation : blockstatemapper.getBlockstateLocations(block)) {
             try {
-               ModelBlockDefinition ☃xxx = this.getModelBlockDefinition(☃xx);
-               Map<IBlockState, ModelResourceLocation> ☃xxxx = ☃.getVariants(☃x);
-               if (☃xxx.hasMultipartData()) {
-                  Collection<ModelResourceLocation> ☃xxxxx = Sets.newHashSet(☃xxxx.values());
-                  ☃xxx.getMultipartData().setStateContainer(☃x.getBlockState());
-                  Collection<ModelResourceLocation> ☃xxxxxx = this.multipartVariantMap.get(☃xxx);
-                  if (☃xxxxxx == null) {
-                     ☃xxxxxx = Lists.newArrayList();
-                     this.multipartVariantMap.put(☃xxx, ☃xxxxxx);
-                  }
+               this.loadBlock(blockstatemapper, block, resourcelocation);
+            } catch (Exception var7) {
+               LOGGER.warn("Unable to load definition " + resourcelocation, var7);
+            }
+         }
+      }
+   }
 
-                  ☃xxxxxx.addAll(Lists.newArrayList(Iterables.filter(☃xxxxx, new Predicate<ModelResourceLocation>() {
-                     public boolean apply(@Nullable ModelResourceLocation var1) {
-                        return ☃.equals(☃);
-                     }
-                  })));
-               }
+   protected void loadBlock(BlockStateMapper blockstatemapper, Block block, final ResourceLocation resourcelocation) {
+      ModelBlockDefinition modelblockdefinition = this.getModelBlockDefinition(resourcelocation);
+      Map<IBlockState, ModelResourceLocation> map = blockstatemapper.getVariants(block);
+      if (modelblockdefinition.hasMultipartData()) {
+         Collection<ModelResourceLocation> collection = Sets.newHashSet(map.values());
+         modelblockdefinition.getMultipartData().setStateContainer(block.getBlockState());
+         Collection<ModelResourceLocation> collection1 = this.multipartVariantMap.get(modelblockdefinition);
+         if (collection1 == null) {
+            collection1 = Lists.newArrayList();
+         }
 
-               for (Entry<IBlockState, ModelResourceLocation> ☃xxxxx : ☃xxxx.entrySet()) {
-                  ModelResourceLocation ☃xxxxxx = ☃xxxxx.getValue();
-                  if (☃xx.equals(☃xxxxxx)) {
-                     try {
-                        this.variants.put(☃xxxxxx, ☃xxx.getVariant(☃xxxxxx.getVariant()));
-                     } catch (RuntimeException var12) {
-                        if (!☃xxx.hasMultipartData()) {
-                           LOGGER.warn("Unable to load variant: {} from {}", ☃xxxxxx.getVariant(), ☃xxxxxx);
-                        }
-                     }
-                  }
+         collection1.addAll(Lists.newArrayList(Iterables.filter(collection, new Predicate<ModelResourceLocation>() {
+            public boolean apply(@Nullable ModelResourceLocation p_apply_1_) {
+               return resourcelocation.equals(p_apply_1_);
+            }
+         })));
+         this.registerMultipartVariant(modelblockdefinition, collection1);
+      }
+
+      for (Entry<IBlockState, ModelResourceLocation> entry : map.entrySet()) {
+         ModelResourceLocation modelresourcelocation = entry.getValue();
+         if (resourcelocation.equals(modelresourcelocation)) {
+            try {
+               if (Reflector.ForgeItem_delegate.exists()) {
+                  this.registerVariant(modelblockdefinition, modelresourcelocation);
+               } else {
+                  this.variants.put(modelresourcelocation, modelblockdefinition.getVariant(modelresourcelocation.getVariant()));
+               }
+            } catch (RuntimeException var10) {
+               if (!modelblockdefinition.hasMultipartData()) {
+                  LOGGER.warn("Unable to load variant: " + modelresourcelocation.getVariant() + " from " + modelresourcelocation, var10);
                }
-            } catch (Exception var13) {
-               LOGGER.warn("Unable to load definition {}", ☃xx, var13);
             }
          }
       }
@@ -180,164 +197,185 @@ private void loadVariantItemModels() {
       this.loadVariantModels();
       this.loadMultipartVariantModels();
       this.loadItemModels();
+      CustomItems.update();
+      CustomItems.loadModels(this);
    }
 
    private void loadStaticModels() {
-      ResourceLocation ☃ = new ResourceLocation("item_frame");
-      ModelBlockDefinition ☃x = this.getModelBlockDefinition(☃);
-      this.registerVariant(☃x, new ModelResourceLocation(☃, "normal"));
-      this.registerVariant(☃x, new ModelResourceLocation(☃, "map"));
+      ResourceLocation resourcelocation = new ResourceLocation("item_frame");
+      ModelBlockDefinition modelblockdefinition = this.getModelBlockDefinition(resourcelocation);
+      this.registerVariant(modelblockdefinition, new ModelResourceLocation(resourcelocation, "normal"));
+      this.registerVariant(modelblockdefinition, new ModelResourceLocation(resourcelocation, "map"));
    }
 
-   private void registerVariant(ModelBlockDefinition var1, ModelResourceLocation var2) {
+   private void registerVariant(ModelBlockDefinition blockstateDefinition, ModelResourceLocation location) {
       try {
-         this.variants.put(☃, ☃.getVariant(☃.getVariant()));
+         this.variants.put(location, blockstateDefinition.getVariant(location.getVariant()));
       } catch (RuntimeException var4) {
-         if (!☃.hasMultipartData()) {
-            LOGGER.warn("Unable to load variant: {} from {}", ☃.getVariant(), ☃);
+         if (!blockstateDefinition.hasMultipartData()) {
+            LOGGER.warn("Unable to load variant: {} from {}", location.getVariant(), location);
          }
       }
    }
 
-   private ModelBlockDefinition getModelBlockDefinition(ResourceLocation var1) {
-      ResourceLocation ☃ = this.getBlockstateLocation(☃);
-      ModelBlockDefinition ☃x = this.blockDefinitions.get(☃);
-      if (☃x == null) {
-         ☃x = this.loadMultipartMBD(☃, ☃);
-         this.blockDefinitions.put(☃, ☃x);
+   private ModelBlockDefinition getModelBlockDefinition(ResourceLocation location) {
+      ResourceLocation resourcelocation = this.getBlockstateLocation(location);
+      ModelBlockDefinition modelblockdefinition = this.blockDefinitions.get(resourcelocation);
+      if (modelblockdefinition == null) {
+         modelblockdefinition = this.loadMultipartMBD(location, resourcelocation);
+         this.blockDefinitions.put(resourcelocation, modelblockdefinition);
       }
 
-      return ☃x;
+      return modelblockdefinition;
    }
 
-   private ModelBlockDefinition loadMultipartMBD(ResourceLocation var1, ResourceLocation var2) {
-      List<ModelBlockDefinition> ☃ = Lists.newArrayList();
+   private ModelBlockDefinition loadMultipartMBD(ResourceLocation location, ResourceLocation fileIn) {
+      List<ModelBlockDefinition> list = Lists.newArrayList();
 
       try {
-         for (IResource ☃x : this.resourceManager.getAllResources(☃)) {
-            ☃.add(this.loadModelBlockDefinition(☃, ☃x));
+         for (IResource iresource : this.resourceManager.getAllResources(fileIn)) {
+            list.add(this.loadModelBlockDefinition(location, iresource));
          }
       } catch (IOException var6) {
-         throw new RuntimeException("Encountered an exception when loading model definition of model " + ☃, var6);
+         throw new RuntimeException("Encountered an exception when loading model definition of model " + fileIn, var6);
       }
 
-      return new ModelBlockDefinition(☃);
+      return new ModelBlockDefinition(list);
    }
 
-   private ModelBlockDefinition loadModelBlockDefinition(ResourceLocation var1, IResource var2) {
-      InputStream ☃ = null;
+   private ModelBlockDefinition loadModelBlockDefinition(ResourceLocation location, IResource resource) {
+      InputStream inputstream = null;
 
-      ModelBlockDefinition var4;
+      ModelBlockDefinition lvt_4_1_;
       try {
-         ☃ = ☃.getInputStream();
-         var4 = ModelBlockDefinition.parseFromReader(new InputStreamReader(☃, StandardCharsets.UTF_8));
-      } catch (Exception var8) {
+         inputstream = resource.getInputStream();
+         if (Reflector.ForgeModelBlockDefinition_parseFromReader2.exists()) {
+            lvt_4_1_ = (ModelBlockDefinition)Reflector.call(
+               Reflector.ForgeModelBlockDefinition_parseFromReader2, new Object[]{new InputStreamReader(inputstream, StandardCharsets.UTF_8), location}
+            );
+         } else {
+            lvt_4_1_ = ModelBlockDefinition.parseFromReader(new InputStreamReader(inputstream, StandardCharsets.UTF_8));
+         }
+      } catch (Exception var9) {
          throw new RuntimeException(
             "Encountered an exception when loading model definition of '"
-               + ☃
+               + location
                + "' from: '"
-               + ☃.getResourceLocation()
+               + resource.getResourceLocation()
                + "' in resourcepack: '"
-               + ☃.getResourcePackName()
+               + resource.getResourcePackName()
                + "'",
-            var8
+            var9
          );
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(inputstream);
       }
 
-      return var4;
+      return lvt_4_1_;
    }
 
-   private ResourceLocation getBlockstateLocation(ResourceLocation var1) {
-      return new ResourceLocation(☃.getNamespace(), "blockstates/" + ☃.getPath() + ".json");
+   private ResourceLocation getBlockstateLocation(ResourceLocation location) {
+      return new ResourceLocation(location.getNamespace(), "blockstates/" + location.getPath() + ".json");
    }
 
    private void loadVariantModels() {
-      for (Entry<ModelResourceLocation, VariantList> ☃ : this.variants.entrySet()) {
-         this.loadVariantList(☃.getKey(), ☃.getValue());
+      for (Entry<ModelResourceLocation, VariantList> entry : this.variants.entrySet()) {
+         this.loadVariantList(entry.getKey(), entry.getValue());
       }
    }
 
    private void loadMultipartVariantModels() {
-      for (Entry<ModelBlockDefinition, Collection<ModelResourceLocation>> ☃ : this.multipartVariantMap.entrySet()) {
-         ModelResourceLocation ☃x = ☃.getValue().iterator().next();
+      for (Entry<ModelBlockDefinition, Collection<ModelResourceLocation>> entry : this.multipartVariantMap.entrySet()) {
+         ModelResourceLocation modelresourcelocation = entry.getValue().iterator().next();
 
-         for (VariantList ☃xx : ☃.getKey().getMultipartVariants()) {
-            this.loadVariantList(☃x, ☃xx);
+         for (VariantList variantlist : entry.getKey().getMultipartVariants()) {
+            this.loadVariantList(modelresourcelocation, variantlist);
          }
       }
    }
 
-   private void loadVariantList(ModelResourceLocation var1, VariantList var2) {
-      for (Variant ☃ : ☃.getVariantList()) {
-         ResourceLocation ☃x = ☃.getModelLocation();
-         if (this.models.get(☃x) == null) {
+   private void loadVariantList(ModelResourceLocation p_188638_1_, VariantList p_188638_2_) {
+      for (Variant variant : p_188638_2_.getVariantList()) {
+         ResourceLocation resourcelocation = variant.getModelLocation();
+         if (this.models.get(resourcelocation) == null) {
             try {
-               this.models.put(☃x, this.loadModel(☃x));
+               this.models.put(resourcelocation, this.loadModel(resourcelocation));
             } catch (Exception var7) {
-               LOGGER.warn("Unable to load block model: '{}' for variant: '{}': {} ", ☃x, ☃, var7);
+               LOGGER.warn("Unable to load block model: '{}' for variant: '{}': {} ", resourcelocation, p_188638_1_, var7);
             }
          }
       }
    }
 
-   private ModelBlock loadModel(ResourceLocation var1) throws IOException {
-      Reader ☃ = null;
-      IResource ☃x = null;
+   private ModelBlock loadModel(ResourceLocation location) throws IOException {
+      Reader reader = null;
+      IResource iresource = null;
 
-      ModelBlock ☃xx;
+      ModelBlock modelblock1;
       try {
-         String ☃xxx = ☃.getPath();
-         if ("builtin/generated".equals(☃xxx)) {
+         String s = location.getPath();
+         if ("builtin/generated".equals(s)) {
             return MODEL_GENERATED;
          }
 
-         if (!"builtin/entity".equals(☃xxx)) {
-            if (☃xxx.startsWith("builtin/")) {
-               String ☃xxxx = ☃xxx.substring("builtin/".length());
-               String ☃xxxxx = BUILT_IN_MODELS.get(☃xxxx);
-               if (☃xxxxx == null) {
-                  throw new FileNotFoundException(☃.toString());
+         if (!"builtin/entity".equals(s)) {
+            if (s.startsWith("builtin/")) {
+               String s2 = s.substring("builtin/".length());
+               String s1 = BUILT_IN_MODELS.get(s2);
+               if (s1 == null) {
+                  throw new FileNotFoundException(location.toString());
                }
 
-               ☃ = new StringReader(☃xxxxx);
+               reader = new StringReader(s1);
             } else {
-               ☃x = this.resourceManager.getResource(this.getModelLocation(☃));
-               ☃ = new InputStreamReader(☃x.getInputStream(), StandardCharsets.UTF_8);
+               location = this.getModelLocation(location);
+               iresource = this.resourceManager.getResource(location);
+               reader = new InputStreamReader(iresource.getInputStream(), StandardCharsets.UTF_8);
             }
 
-            ☃xx = ModelBlock.deserialize(☃);
-            ☃xx.name = ☃.toString();
-            return ☃xx;
+            ModelBlock lvt_5_2_ = ModelBlock.deserialize(reader);
+            lvt_5_2_.name = location.toString();
+            String basePath = TextureUtils.getBasePath(location.getPath());
+            fixModelLocations(lvt_5_2_, basePath);
+            return lvt_5_2_;
          }
 
-         ☃xx = MODEL_ENTITY;
+         ModelBlock lvt_5_2_ = MODEL_ENTITY;
+         modelblock1 = lvt_5_2_;
       } finally {
-         IOUtils.closeQuietly(☃);
-         IOUtils.closeQuietly(☃x);
+         IOUtils.closeQuietly(reader);
+         IOUtils.closeQuietly(iresource);
       }
 
-      return ☃xx;
+      return modelblock1;
    }
 
-   private ResourceLocation getModelLocation(ResourceLocation var1) {
-      return new ResourceLocation(☃.getNamespace(), "models/" + ☃.getPath() + ".json");
+   private ResourceLocation getModelLocation(ResourceLocation location) {
+      String path = location.getPath();
+      if (!path.startsWith("mcpatcher") && !path.startsWith("optifine")) {
+         return new ResourceLocation(location.getNamespace(), "models/" + location.getPath() + ".json");
+      } else {
+         if (!path.endsWith(".json")) {
+            location = new ResourceLocation(location.getNamespace(), path + ".json");
+         }
+
+         return location;
+      }
    }
 
    private void loadItemModels() {
       this.registerVariantNames();
 
-      for (Item ☃ : Item.REGISTRY) {
-         for (String ☃x : this.getVariantNames(☃)) {
-            ResourceLocation ☃xx = this.getItemLocation(☃x);
-            ResourceLocation ☃xxx = Item.REGISTRY.getNameForObject(☃);
-            this.loadItemModel(☃x, ☃xx, ☃xxx);
-            if (☃.hasCustomProperties()) {
-               ModelBlock ☃xxxx = this.models.get(☃xx);
-               if (☃xxxx != null) {
-                  for (ResourceLocation ☃xxxxx : ☃xxxx.getOverrideLocations()) {
-                     this.loadItemModel(☃xxxxx.toString(), ☃xxxxx, ☃xxx);
+      for (Item item : Item.REGISTRY) {
+         for (String s : this.getVariantNames(item)) {
+            ResourceLocation resourcelocation = this.getItemLocation(s);
+            ResourceLocation resourcelocation1 = (ResourceLocation)Item.REGISTRY.getNameForObject(item);
+            this.loadItemModel(s, resourcelocation, resourcelocation1);
+            if (item.hasCustomProperties()) {
+               ModelBlock modelblock = this.models.get(resourcelocation);
+               if (modelblock != null) {
+                  for (ResourceLocation resourcelocation2 : modelblock.getOverrideLocations()) {
+                     this.loadItemModel(resourcelocation2.toString(), resourcelocation2, resourcelocation1);
                   }
                }
             }
@@ -345,19 +383,21 @@ private void loadItemModels() {
       }
    }
 
-   private void loadItemModel(String var1, ResourceLocation var2, ResourceLocation var3) {
-      this.itemLocations.put(☃, ☃);
-      if (this.models.get(☃) == null) {
+   public void loadItemModel(String variantName, ResourceLocation location, ResourceLocation itemName) {
+      this.itemLocations.put(variantName, location);
+      if (this.models.get(location) == null) {
          try {
-            ModelBlock ☃ = this.loadModel(☃);
-            this.models.put(☃, ☃);
+            ModelBlock modelblock = this.loadModel(location);
+            this.models.put(location, modelblock);
          } catch (Exception var5) {
-            LOGGER.warn("Unable to load item model: '{}' for item: '{}'", ☃, ☃, var5);
+            LOGGER.warn("Unable to load item model: '{}' for item: '{}'", new Object[]{location, itemName});
+            LOGGER.warn(var5.getClass().getName() + ": " + var5.getMessage());
          }
       }
    }
 
    private void registerVariantNames() {
+      this.variantNames.clear();
       this.variantNames
          .put(
             Item.getItemFromBlock(Blocks.STONE),
@@ -643,336 +683,461 @@ private void registerVariantNames() {
       this.variantNames.put(Items.OAK_DOOR, Lists.newArrayList(new String[]{"oak_door"}));
       this.variantNames.put(Items.BOAT, Lists.newArrayList(new String[]{"oak_boat"}));
       this.variantNames.put(Items.TOTEM_OF_UNDYING, Lists.newArrayList(new String[]{"totem"}));
+
+      for (Entry<IRegistryDelegate<Item>, Set<String>> e : customVariantNames.entrySet()) {
+         this.variantNames.put((Item)e.getKey().get(), Lists.newArrayList(e.getValue().iterator()));
+      }
    }
 
-   private List<String> getVariantNames(Item var1) {
-      List<String> ☃ = this.variantNames.get(☃);
-      if (☃ == null) {
-         ☃ = Collections.singletonList(Item.REGISTRY.getNameForObject(☃).toString());
+   private List<String> getVariantNames(Item stack) {
+      List<String> list = this.variantNames.get(stack);
+      if (list == null) {
+         list = Collections.singletonList(((ResourceLocation)Item.REGISTRY.getNameForObject(stack)).toString());
       }
 
-      return ☃;
+      return list;
    }
 
-   private ResourceLocation getItemLocation(String var1) {
-      ResourceLocation ☃ = new ResourceLocation(☃);
-      return new ResourceLocation(☃.getNamespace(), "item/" + ☃.getPath());
+   private ResourceLocation getItemLocation(String location) {
+      ResourceLocation resourcelocation = new ResourceLocation(location);
+      if (Reflector.ForgeHooksClient.exists()) {
+         resourcelocation = new ResourceLocation(location.replaceAll("#.*", ""));
+      }
+
+      return new ResourceLocation(resourcelocation.getNamespace(), "item/" + resourcelocation.getPath());
    }
 
    private void bakeBlockModels() {
-      for (ModelResourceLocation ☃ : this.variants.keySet()) {
-         IBakedModel ☃x = this.createRandomModelForVariantList(this.variants.get(☃), ☃.toString());
-         if (☃x != null) {
-            this.bakedRegistry.putObject(☃, ☃x);
+      for (ModelResourceLocation modelresourcelocation : this.variants.keySet()) {
+         IBakedModel ibakedmodel = this.createRandomModelForVariantList(this.variants.get(modelresourcelocation), modelresourcelocation.toString());
+         if (ibakedmodel != null) {
+            this.bakedRegistry.putObject(modelresourcelocation, ibakedmodel);
          }
       }
 
-      for (Entry<ModelBlockDefinition, Collection<ModelResourceLocation>> ☃x : this.multipartVariantMap.entrySet()) {
-         ModelBlockDefinition ☃xx = ☃x.getKey();
-         Multipart ☃xxx = ☃xx.getMultipartData();
-         String ☃xxxx = Block.REGISTRY.getNameForObject(☃xxx.getStateContainer().getBlock()).toString();
-         MultipartBakedModel.Builder ☃xxxxx = new MultipartBakedModel.Builder();
+      for (Entry<ModelBlockDefinition, Collection<ModelResourceLocation>> entry : this.multipartVariantMap.entrySet()) {
+         ModelBlockDefinition modelblockdefinition = entry.getKey();
+         Multipart multipart = modelblockdefinition.getMultipartData();
+         String s = ((ResourceLocation)Block.REGISTRY.getNameForObject(multipart.getStateContainer().getBlock())).toString();
+         Builder multipartbakedmodel$builder = new Builder();
 
-         for (Selector ☃xxxxxx : ☃xxx.getSelectors()) {
-            IBakedModel ☃xxxxxxx = this.createRandomModelForVariantList(☃xxxxxx.getVariantList(), "selector of " + ☃xxxx);
-            if (☃xxxxxxx != null) {
-               ☃xxxxx.putModel(☃xxxxxx.getPredicate(☃xxx.getStateContainer()), ☃xxxxxxx);
+         for (Selector selector : multipart.getSelectors()) {
+            IBakedModel ibakedmodel1 = this.createRandomModelForVariantList(selector.getVariantList(), "selector of " + s);
+            if (ibakedmodel1 != null) {
+               multipartbakedmodel$builder.putModel(selector.getPredicate(multipart.getStateContainer()), ibakedmodel1);
             }
          }
 
-         IBakedModel ☃xxxxxxx = ☃xxxxx.makeMultipartModel();
+         IBakedModel ibakedmodel2 = multipartbakedmodel$builder.makeMultipartModel();
 
-         for (ModelResourceLocation ☃xxxxxxxx : ☃x.getValue()) {
-            if (!☃xx.hasVariant(☃xxxxxxxx.getVariant())) {
-               this.bakedRegistry.putObject(☃xxxxxxxx, ☃xxxxxxx);
+         for (ModelResourceLocation modelresourcelocation1 : entry.getValue()) {
+            if (!modelblockdefinition.hasVariant(modelresourcelocation1.getVariant())) {
+               this.bakedRegistry.putObject(modelresourcelocation1, ibakedmodel2);
             }
          }
       }
    }
 
    @Nullable
-   private IBakedModel createRandomModelForVariantList(VariantList var1, String var2) {
-      if (☃.getVariantList().isEmpty()) {
+   private IBakedModel createRandomModelForVariantList(VariantList variantsIn, String modelLocation) {
+      if (variantsIn.getVariantList().isEmpty()) {
          return null;
       } else {
-         WeightedBakedModel.Builder ☃ = new WeightedBakedModel.Builder();
-         int ☃x = 0;
-
-         for (Variant ☃xx : ☃.getVariantList()) {
-            ModelBlock ☃xxx = this.models.get(☃xx.getModelLocation());
-            if (☃xxx == null || !☃xxx.isResolved()) {
-               LOGGER.warn("Missing model for: {}", ☃);
-            } else if (☃xxx.getElements().isEmpty()) {
-               LOGGER.warn("Missing elements for: {}", ☃);
+         net.minecraft.client.renderer.block.model.WeightedBakedModel.Builder weightedbakedmodel$builder = new net.minecraft.client.renderer.block.model.WeightedBakedModel.Builder();
+         int i = 0;
+
+         for (Variant variant : variantsIn.getVariantList()) {
+            ModelBlock modelblock = this.models.get(variant.getModelLocation());
+            if (modelblock == null || !modelblock.isResolved()) {
+               LOGGER.warn("Missing model for: {}", modelLocation);
+            } else if (modelblock.getElements().isEmpty()) {
+               LOGGER.warn("Missing elements for: {}", modelLocation);
             } else {
-               IBakedModel ☃xxxx = this.bakeModel(☃xxx, ☃xx.getRotation(), ☃xx.isUvLock());
-               if (☃xxxx != null) {
-                  ☃x++;
-                  ☃.add(☃xxxx, ☃xx.getWeight());
+               IBakedModel ibakedmodel = this.bakeModel(modelblock, variant.getRotation(), variant.isUvLock());
+               if (ibakedmodel != null) {
+                  i++;
+                  weightedbakedmodel$builder.add(ibakedmodel, variant.getWeight());
                }
             }
          }
 
-         IBakedModel ☃xxx = null;
-         if (☃x == 0) {
-            LOGGER.warn("No weighted models for: {}", ☃);
-         } else if (☃x == 1) {
-            ☃xxx = ☃.first();
+         IBakedModel ibakedmodel1 = null;
+         if (i == 0) {
+            LOGGER.warn("No weighted models for: {}", modelLocation);
+         } else if (i == 1) {
+            ibakedmodel1 = weightedbakedmodel$builder.first();
          } else {
-            ☃xxx = ☃.build();
+            ibakedmodel1 = weightedbakedmodel$builder.build();
          }
 
-         return ☃xxx;
+         return ibakedmodel1;
       }
    }
 
    private void bakeItemModels() {
-      for (Entry<String, ResourceLocation> ☃ : this.itemLocations.entrySet()) {
-         ResourceLocation ☃x = ☃.getValue();
-         ModelResourceLocation ☃xx = new ModelResourceLocation(☃.getKey(), "inventory");
-         ModelBlock ☃xxx = this.models.get(☃x);
-         if (☃xxx == null || !☃xxx.isResolved()) {
-            LOGGER.warn("Missing model for: {}", ☃x);
-         } else if (☃xxx.getElements().isEmpty()) {
-            LOGGER.warn("Missing elements for: {}", ☃x);
-         } else if (this.isCustomRenderer(☃xxx)) {
-            this.bakedRegistry.putObject(☃xx, new BuiltInModel(☃xxx.getAllTransforms(), ☃xxx.createOverrides()));
+      for (Entry<String, ResourceLocation> entry : this.itemLocations.entrySet()) {
+         ResourceLocation resourcelocation = entry.getValue();
+         ModelResourceLocation modelresourcelocation = new ModelResourceLocation(entry.getKey(), "inventory");
+         if (Reflector.ForgeHooksClient.exists()) {
+            modelresourcelocation = (ModelResourceLocation)Reflector.call(Reflector.ModelLoader_getInventoryVariant, new Object[]{entry.getKey()});
+         }
+
+         ModelBlock modelblock = this.models.get(resourcelocation);
+         if (modelblock == null || !modelblock.isResolved()) {
+            LOGGER.warn("Missing model for: {}", resourcelocation);
+         } else if (modelblock.getElements().isEmpty()) {
+            LOGGER.warn("Missing elements for: {}", resourcelocation);
+         } else if (this.isCustomRenderer(modelblock)) {
+            this.bakedRegistry.putObject(modelresourcelocation, new BuiltInModel(modelblock.getAllTransforms(), modelblock.createOverrides()));
          } else {
-            IBakedModel ☃xxxx = this.bakeModel(☃xxx, ModelRotation.X0_Y0, false);
-            if (☃xxxx != null) {
-               this.bakedRegistry.putObject(☃xx, ☃xxxx);
+            IBakedModel ibakedmodel = this.bakeModel(modelblock, ModelRotation.X0_Y0, false);
+            if (ibakedmodel != null) {
+               this.bakedRegistry.putObject(modelresourcelocation, ibakedmodel);
             }
          }
       }
    }
 
    private Set<ResourceLocation> getVariantsTextureLocations() {
-      Set<ResourceLocation> ☃ = Sets.newHashSet();
-      List<ModelResourceLocation> ☃x = Lists.newArrayList(this.variants.keySet());
-      Collections.sort(☃x, new Comparator<ModelResourceLocation>() {
-         public int compare(ModelResourceLocation var1, ModelResourceLocation var2) {
-            return ☃.toString().compareTo(☃.toString());
+      Set<ResourceLocation> set = Sets.newHashSet();
+      List<ModelResourceLocation> list = Lists.newArrayList(this.variants.keySet());
+      Collections.sort(list, new Comparator<ModelResourceLocation>() {
+         public int compare(ModelResourceLocation p_compare_1_, ModelResourceLocation p_compare_2_) {
+            return p_compare_1_.toString().compareTo(p_compare_2_.toString());
          }
       });
 
-      for (ModelResourceLocation ☃xx : ☃x) {
-         VariantList ☃xxx = this.variants.get(☃xx);
+      for (ModelResourceLocation modelresourcelocation : list) {
+         VariantList variantlist = this.variants.get(modelresourcelocation);
 
-         for (Variant ☃xxxx : ☃xxx.getVariantList()) {
-            ModelBlock ☃xxxxx = this.models.get(☃xxxx.getModelLocation());
-            if (☃xxxxx == null) {
-               LOGGER.warn("Missing model for: {}", ☃xx);
+         for (Variant variant : variantlist.getVariantList()) {
+            ModelBlock modelblock = this.models.get(variant.getModelLocation());
+            if (modelblock == null) {
+               LOGGER.warn("Missing model for: {}", modelresourcelocation);
             } else {
-               ☃.addAll(this.getTextureLocations(☃xxxxx));
+               set.addAll(this.getTextureLocations(modelblock));
             }
          }
       }
 
-      for (ModelBlockDefinition ☃xx : this.multipartVariantMap.keySet()) {
-         for (VariantList ☃xxx : ☃xx.getMultipartData().getVariants()) {
-            for (Variant ☃xxxxx : ☃xxx.getVariantList()) {
-               ModelBlock ☃xxxxxx = this.models.get(☃xxxxx.getModelLocation());
-               if (☃xxxxxx == null) {
-                  LOGGER.warn("Missing model for: {}", Block.REGISTRY.getNameForObject(☃xx.getMultipartData().getStateContainer().getBlock()));
+      for (ModelBlockDefinition modelblockdefinition : this.multipartVariantMap.keySet()) {
+         for (VariantList variantlist1 : modelblockdefinition.getMultipartData().getVariants()) {
+            for (Variant variant1 : variantlist1.getVariantList()) {
+               ModelBlock modelblock1 = this.models.get(variant1.getModelLocation());
+               if (modelblock1 == null) {
+                  LOGGER.warn("Missing model for: {}", Block.REGISTRY.getNameForObject(modelblockdefinition.getMultipartData().getStateContainer().getBlock()));
                } else {
-                  ☃.addAll(this.getTextureLocations(☃xxxxxx));
+                  set.addAll(this.getTextureLocations(modelblock1));
                }
             }
          }
       }
 
-      ☃.addAll(LOCATIONS_BUILTIN_TEXTURES);
-      return ☃;
+      set.addAll(LOCATIONS_BUILTIN_TEXTURES);
+      return set;
    }
 
    @Nullable
-   private IBakedModel bakeModel(ModelBlock var1, ModelRotation var2, boolean var3) {
-      TextureAtlasSprite ☃ = this.sprites.get(new ResourceLocation(☃.resolveTextureName("particle")));
-      SimpleBakedModel.Builder ☃x = new SimpleBakedModel.Builder(☃, ☃.createOverrides()).setTexture(☃);
-      if (☃.getElements().isEmpty()) {
+   public IBakedModel bakeModel(ModelBlock modelBlockIn, ModelRotation modelRotationIn, boolean uvLocked) {
+      return this.bakeModel(modelBlockIn, (ITransformation)modelRotationIn, uvLocked);
+   }
+
+   protected IBakedModel bakeModel(ModelBlock modelBlockIn, ITransformation modelRotationIn, boolean uvLocked) {
+      TextureAtlasSprite textureatlassprite = this.sprites.get(new ResourceLocation(modelBlockIn.resolveTextureName("particle")));
+      net.minecraft.client.renderer.block.model.SimpleBakedModel.Builder simplebakedmodel$builder = new net.minecraft.client.renderer.block.model.SimpleBakedModel.Builder(
+            modelBlockIn, modelBlockIn.createOverrides()
+         )
+         .setTexture(textureatlassprite);
+      if (modelBlockIn.getElements().isEmpty()) {
          return null;
       } else {
-         for (BlockPart ☃xx : ☃.getElements()) {
-            for (EnumFacing ☃xxx : ☃xx.mapFaces.keySet()) {
-               BlockPartFace ☃xxxx = ☃xx.mapFaces.get(☃xxx);
-               TextureAtlasSprite ☃xxxxx = this.sprites.get(new ResourceLocation(☃.resolveTextureName(☃xxxx.texture)));
-               if (☃xxxx.cullFace == null) {
-                  ☃x.addGeneralQuad(this.makeBakedQuad(☃xx, ☃xxxx, ☃xxxxx, ☃xxx, ☃, ☃));
+         for (BlockPart blockpart : modelBlockIn.getElements()) {
+            for (EnumFacing enumfacing : blockpart.mapFaces.keySet()) {
+               BlockPartFace blockpartface = (BlockPartFace)blockpart.mapFaces.get(enumfacing);
+               TextureAtlasSprite textureatlassprite1 = this.sprites.get(new ResourceLocation(modelBlockIn.resolveTextureName(blockpartface.texture)));
+               boolean isMatrixInteger = true;
+               if (Reflector.ForgeHooksClient.exists()) {
+                  isMatrixInteger = TRSRTransformation.isInteger(modelRotationIn.getMatrix());
+               }
+
+               if (blockpartface.cullFace != null && isMatrixInteger) {
+                  simplebakedmodel$builder.addFaceQuad(
+                     modelRotationIn.rotate(blockpartface.cullFace),
+                     this.makeBakedQuad(blockpart, blockpartface, textureatlassprite1, enumfacing, modelRotationIn, uvLocked)
+                  );
                } else {
-                  ☃x.addFaceQuad(☃.rotateFace(☃xxxx.cullFace), this.makeBakedQuad(☃xx, ☃xxxx, ☃xxxxx, ☃xxx, ☃, ☃));
+                  simplebakedmodel$builder.addGeneralQuad(
+                     this.makeBakedQuad(blockpart, blockpartface, textureatlassprite1, enumfacing, modelRotationIn, uvLocked)
+                  );
                }
             }
          }
 
-         return ☃x.makeBakedModel();
+         return simplebakedmodel$builder.makeBakedModel();
       }
    }
 
-   private BakedQuad makeBakedQuad(BlockPart var1, BlockPartFace var2, TextureAtlasSprite var3, EnumFacing var4, ModelRotation var5, boolean var6) {
-      return this.faceBakery.makeBakedQuad(☃.positionFrom, ☃.positionTo, ☃, ☃, ☃, ☃, ☃.partRotation, ☃, ☃.shade);
+   private BakedQuad makeBakedQuad(
+      BlockPart p_177589_1_, BlockPartFace p_177589_2_, TextureAtlasSprite p_177589_3_, EnumFacing p_177589_4_, ModelRotation p_177589_5_, boolean p_177589_6_
+   ) {
+      return Reflector.ForgeHooksClient.exists()
+         ? this.makeBakedQuad(p_177589_1_, p_177589_2_, p_177589_3_, p_177589_4_, (ITransformation)p_177589_5_, p_177589_6_)
+         : this.faceBakery
+            .makeBakedQuad(
+               p_177589_1_.positionFrom,
+               p_177589_1_.positionTo,
+               p_177589_2_,
+               p_177589_3_,
+               p_177589_4_,
+               p_177589_5_,
+               p_177589_1_.partRotation,
+               p_177589_6_,
+               p_177589_1_.shade
+            );
+   }
+
+   protected BakedQuad makeBakedQuad(
+      BlockPart p_177589_1_,
+      BlockPartFace p_177589_2_,
+      TextureAtlasSprite p_177589_3_,
+      EnumFacing p_177589_4_,
+      ITransformation p_177589_5_,
+      boolean p_177589_6_
+   ) {
+      return this.faceBakery
+         .makeBakedQuad(
+            p_177589_1_.positionFrom,
+            p_177589_1_.positionTo,
+            p_177589_2_,
+            p_177589_3_,
+            p_177589_4_,
+            p_177589_5_,
+            p_177589_1_.partRotation,
+            p_177589_6_,
+            p_177589_1_.shade
+         );
    }
 
    private void loadModelsCheck() {
       this.loadModels();
 
-      for (ModelBlock ☃ : this.models.values()) {
-         ☃.getParentFromMap(this.models);
+      for (ModelBlock modelblock : this.models.values()) {
+         modelblock.getParentFromMap(this.models);
       }
 
       ModelBlock.checkModelHierarchy(this.models);
    }
 
    private void loadModels() {
-      Deque<ResourceLocation> ☃ = Queues.newArrayDeque();
-      Set<ResourceLocation> ☃x = Sets.newHashSet();
+      Deque<ResourceLocation> deque = Queues.newArrayDeque();
+      Set<ResourceLocation> set = Sets.newHashSet();
 
-      for (ResourceLocation ☃xx : this.models.keySet()) {
-         ☃x.add(☃xx);
-         this.addModelParentLocation(☃, ☃x, this.models.get(☃xx));
+      for (ResourceLocation resourcelocation : this.models.keySet()) {
+         set.add(resourcelocation);
+         this.addModelParentLocation(deque, set, this.models.get(resourcelocation));
       }
 
-      while (!☃.isEmpty()) {
-         ResourceLocation ☃xx = ☃.pop();
+      while (!deque.isEmpty()) {
+         ResourceLocation resourcelocation1 = deque.pop();
 
          try {
-            if (this.models.get(☃xx) != null) {
+            if (this.models.get(resourcelocation1) != null) {
                continue;
             }
 
-            ModelBlock ☃xxx = this.loadModel(☃xx);
-            this.models.put(☃xx, ☃xxx);
-            this.addModelParentLocation(☃, ☃x, ☃xxx);
+            ModelBlock modelblock = this.loadModel(resourcelocation1);
+            this.models.put(resourcelocation1, modelblock);
+            this.addModelParentLocation(deque, set, modelblock);
          } catch (Exception var5) {
-            LOGGER.warn("In parent chain: {}; unable to load model: '{}'", JOINER.join(this.getParentPath(☃xx)), ☃xx, var5);
+            LOGGER.warn("In parent chain: {}; unable to load model: '{}'", new Object[]{JOINER.join(this.getParentPath(resourcelocation1)), resourcelocation1});
          }
 
-         ☃x.add(☃xx);
+         set.add(resourcelocation1);
       }
    }
 
-   private void addModelParentLocation(Deque<ResourceLocation> var1, Set<ResourceLocation> var2, ModelBlock var3) {
-      ResourceLocation ☃ = ☃.getParentLocation();
-      if (☃ != null && !☃.contains(☃)) {
-         ☃.add(☃);
+   private void addModelParentLocation(Deque<ResourceLocation> p_188633_1_, Set<ResourceLocation> p_188633_2_, ModelBlock p_188633_3_) {
+      ResourceLocation resourcelocation = p_188633_3_.getParentLocation();
+      if (resourcelocation != null && !p_188633_2_.contains(resourcelocation)) {
+         p_188633_1_.add(resourcelocation);
       }
    }
 
-   private List<ResourceLocation> getParentPath(ResourceLocation var1) {
-      List<ResourceLocation> ☃ = Lists.newArrayList(new ResourceLocation[]{☃});
-      ResourceLocation ☃x = ☃;
+   private List<ResourceLocation> getParentPath(ResourceLocation p_177573_1_) {
+      List<ResourceLocation> list = Lists.newArrayList(new ResourceLocation[]{p_177573_1_});
+      ResourceLocation resourcelocation = p_177573_1_;
 
-      while ((☃x = this.getParentLocation(☃x)) != null) {
-         ☃.add(0, ☃x);
+      while ((resourcelocation = this.getParentLocation(resourcelocation)) != null) {
+         list.add(0, resourcelocation);
       }
 
-      return ☃;
+      return list;
    }
 
    @Nullable
-   private ResourceLocation getParentLocation(ResourceLocation var1) {
-      for (Entry<ResourceLocation, ModelBlock> ☃ : this.models.entrySet()) {
-         ModelBlock ☃x = ☃.getValue();
-         if (☃x != null && ☃.equals(☃x.getParentLocation())) {
-            return ☃.getKey();
+   private ResourceLocation getParentLocation(ResourceLocation p_177576_1_) {
+      for (Entry<ResourceLocation, ModelBlock> entry : this.models.entrySet()) {
+         ModelBlock modelblock = entry.getValue();
+         if (modelblock != null && p_177576_1_.equals(modelblock.getParentLocation())) {
+            return entry.getKey();
          }
       }
 
       return null;
    }
 
-   private Set<ResourceLocation> getTextureLocations(ModelBlock var1) {
-      Set<ResourceLocation> ☃ = Sets.newHashSet();
+   private Set<ResourceLocation> getTextureLocations(ModelBlock p_177585_1_) {
+      Set<ResourceLocation> set = Sets.newHashSet();
 
-      for (BlockPart ☃x : ☃.getElements()) {
-         for (BlockPartFace ☃xx : ☃x.mapFaces.values()) {
-            ResourceLocation ☃xxx = new ResourceLocation(☃.resolveTextureName(☃xx.texture));
-            ☃.add(☃xxx);
+      for (BlockPart blockpart : p_177585_1_.getElements()) {
+         for (BlockPartFace blockpartface : blockpart.mapFaces.values()) {
+            ResourceLocation resourcelocation = new ResourceLocation(p_177585_1_.resolveTextureName(blockpartface.texture));
+            set.add(resourcelocation);
          }
       }
 
-      ☃.add(new ResourceLocation(☃.resolveTextureName("particle")));
-      return ☃;
+      set.add(new ResourceLocation(p_177585_1_.resolveTextureName("particle")));
+      return set;
    }
 
    private void loadSprites() {
-      final Set<ResourceLocation> ☃ = this.getVariantsTextureLocations();
-      ☃.addAll(this.getItemsTextureLocations());
-      ☃.remove(TextureMap.LOCATION_MISSING_TEXTURE);
-      ITextureMapPopulator ☃x = new ITextureMapPopulator() {
-         @Override
-         public void registerSprites(TextureMap var1x) {
-            for (ResourceLocation ☃xx : ☃) {
-               TextureAtlasSprite ☃x = ☃.registerSprite(☃xx);
-               ModelBakery.this.sprites.put(☃xx, ☃x);
+      final Set<ResourceLocation> set = this.getVariantsTextureLocations();
+      set.addAll(this.getItemsTextureLocations());
+      set.remove(TextureMap.LOCATION_MISSING_TEXTURE);
+      ITextureMapPopulator itexturemappopulator = new ITextureMapPopulator() {
+         public void registerSprites(TextureMap textureMapIn) {
+            for (ResourceLocation resourcelocation : set) {
+               TextureAtlasSprite textureatlassprite = textureMapIn.registerSprite(resourcelocation);
+               ModelBakery.this.sprites.put(resourcelocation, textureatlassprite);
             }
          }
       };
-      this.textureMap.loadSprites(this.resourceManager, ☃x);
+      this.textureMap.loadSprites(this.resourceManager, itexturemappopulator);
       this.sprites.put(new ResourceLocation("missingno"), this.textureMap.getMissingSprite());
    }
 
    private Set<ResourceLocation> getItemsTextureLocations() {
-      Set<ResourceLocation> ☃ = Sets.newHashSet();
-
-      for (ResourceLocation ☃x : this.itemLocations.values()) {
-         ModelBlock ☃xx = this.models.get(☃x);
-         if (☃xx != null) {
-            ☃.add(new ResourceLocation(☃xx.resolveTextureName("particle")));
-            if (this.hasItemModel(☃xx)) {
-               for (String ☃xxx : ItemModelGenerator.LAYERS) {
-                  ☃.add(new ResourceLocation(☃xx.resolveTextureName(☃xxx)));
+      Set<ResourceLocation> set = Sets.newHashSet();
+
+      for (ResourceLocation resourcelocation : this.itemLocations.values()) {
+         ModelBlock modelblock = this.models.get(resourcelocation);
+         if (modelblock != null) {
+            set.add(new ResourceLocation(modelblock.resolveTextureName("particle")));
+            if (this.hasItemModel(modelblock)) {
+               for (String s : ItemModelGenerator.LAYERS) {
+                  set.add(new ResourceLocation(modelblock.resolveTextureName(s)));
                }
-            } else if (!this.isCustomRenderer(☃xx)) {
-               for (BlockPart ☃xxx : ☃xx.getElements()) {
-                  for (BlockPartFace ☃xxxx : ☃xxx.mapFaces.values()) {
-                     ResourceLocation ☃xxxxx = new ResourceLocation(☃xx.resolveTextureName(☃xxxx.texture));
-                     ☃.add(☃xxxxx);
+            } else if (!this.isCustomRenderer(modelblock)) {
+               for (BlockPart blockpart : modelblock.getElements()) {
+                  for (BlockPartFace blockpartface : blockpart.mapFaces.values()) {
+                     ResourceLocation resourcelocation1 = new ResourceLocation(modelblock.resolveTextureName(blockpartface.texture));
+                     set.add(resourcelocation1);
                   }
                }
             }
          }
       }
 
-      return ☃;
+      return set;
    }
 
-   private boolean hasItemModel(@Nullable ModelBlock var1) {
-      return ☃ == null ? false : ☃.getRootModel() == MODEL_GENERATED;
+   private boolean hasItemModel(@Nullable ModelBlock p_177581_1_) {
+      return p_177581_1_ == null ? false : p_177581_1_.getRootModel() == MODEL_GENERATED;
    }
 
-   private boolean isCustomRenderer(@Nullable ModelBlock var1) {
-      if (☃ == null) {
+   private boolean isCustomRenderer(@Nullable ModelBlock p_177587_1_) {
+      if (p_177587_1_ == null) {
          return false;
       } else {
-         ModelBlock ☃ = ☃.getRootModel();
-         return ☃ == MODEL_ENTITY;
+         ModelBlock modelblock = p_177587_1_.getRootModel();
+         return modelblock == MODEL_ENTITY;
       }
    }
 
    private void makeItemModels() {
-      for (ResourceLocation ☃ : this.itemLocations.values()) {
-         ModelBlock ☃x = this.models.get(☃);
-         if (this.hasItemModel(☃x)) {
-            ModelBlock ☃xx = this.makeItemModel(☃x);
-            if (☃xx != null) {
-               ☃xx.name = ☃.toString();
+      for (ResourceLocation resourcelocation : this.itemLocations.values()) {
+         ModelBlock modelblock = this.models.get(resourcelocation);
+         if (this.hasItemModel(modelblock)) {
+            ModelBlock modelblock1 = this.makeItemModel(modelblock);
+            if (modelblock1 != null) {
+               modelblock1.name = resourcelocation.toString();
             }
 
-            this.models.put(☃, ☃xx);
-         } else if (this.isCustomRenderer(☃x)) {
-            this.models.put(☃, ☃x);
+            this.models.put(resourcelocation, modelblock1);
+         } else if (this.isCustomRenderer(modelblock)) {
+            this.models.put(resourcelocation, modelblock);
+         }
+      }
+
+      for (TextureAtlasSprite textureatlassprite : this.sprites.values()) {
+         if (!textureatlassprite.hasAnimationMetadata()) {
+            textureatlassprite.clearFramesTextureData();
+         }
+      }
+   }
+
+   private ModelBlock makeItemModel(ModelBlock p_177582_1_) {
+      return this.itemModelGenerator.makeItemModel(this.textureMap, p_177582_1_);
+   }
+
+   public ModelBlock getModelBlock(ResourceLocation resourceLocation) {
+      return this.models.get(resourceLocation);
+   }
+
+   public static void fixModelLocations(ModelBlock modelBlock, String basePath) {
+      ResourceLocation parentLocFixed = fixModelLocation(modelBlock.parentLocation, basePath);
+      if (parentLocFixed != modelBlock.parentLocation) {
+         modelBlock.parentLocation = parentLocFixed;
+      }
+
+      if (modelBlock.textures != null) {
+         for (Entry<String, String> entry : modelBlock.textures.entrySet()) {
+            String path = entry.getValue();
+            String pathFixed = fixResourcePath(path, basePath);
+            if (pathFixed != path) {
+               entry.setValue(pathFixed);
+            }
          }
       }
+   }
 
-      for (TextureAtlasSprite ☃x : this.sprites.values()) {
-         if (!☃x.hasAnimationMetadata()) {
-            ☃x.clearFramesTextureData();
+   public static ResourceLocation fixModelLocation(ResourceLocation loc, String basePath) {
+      if (loc != null && basePath != null) {
+         if (!loc.getNamespace().equals("minecraft")) {
+            return loc;
+         } else {
+            String path = loc.getPath();
+            String pathFixed = fixResourcePath(path, basePath);
+            if (pathFixed != path) {
+               loc = new ResourceLocation(loc.getNamespace(), pathFixed);
+            }
+
+            return loc;
          }
+      } else {
+         return loc;
       }
    }
 
-   private ModelBlock makeItemModel(ModelBlock var1) {
-      return this.itemModelGenerator.makeItemModel(this.textureMap, ☃);
+   private static String fixResourcePath(String path, String basePath) {
+      path = TextureUtils.fixResourcePath(path, basePath);
+      path = StrUtils.removeSuffix(path, ".json");
+      return StrUtils.removeSuffix(path, ".png");
+   }
+
+   protected void registerMultipartVariant(ModelBlockDefinition definition, Collection<ModelResourceLocation> locations) {
+      this.multipartVariantMap.put(definition, locations);
+   }
+
+   public static void registerItemVariants(Item item, ResourceLocation... names) {
+      IRegistryDelegate delegate = (IRegistryDelegate)Reflector.getFieldValue(item, Reflector.ForgeItem_delegate);
+      if (!customVariantNames.containsKey(delegate)) {
+         customVariantNames.put(delegate, Sets.newHashSet());
+      }
+
+      for (ResourceLocation name : names) {
+         customVariantNames.get(delegate).add(name.toString());
+      }
    }
 
    static {
diff --git a/patches/net/minecraft/client/renderer/block/model/ModelRotation.java b/patches/net/minecraft/client/renderer/block/model/ModelRotation.java
index a82d295..8e01651 100644
--- a/patches/net/minecraft/client/renderer/block/model/ModelRotation.java
+++ b/patches/net/minecraft/client/renderer/block/model/ModelRotation.java
@@ -2,12 +2,18 @@
 
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Optional;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.MathHelper;
+import net.minecraftforge.common.model.IModelPart;
+import net.minecraftforge.common.model.IModelState;
+import net.minecraftforge.common.model.ITransformation;
+import net.minecraftforge.common.model.TRSRTransformation;
+import net.optifine.reflect.Reflector;
 import org.lwjgl.util.vector.Matrix4f;
 import org.lwjgl.util.vector.Vector3f;
 
-public enum ModelRotation {
+public enum ModelRotation implements IModelState, ITransformation {
    X0_Y0(0, 0),
    X0_Y90(0, 90),
    X0_Y180(0, 180),
@@ -31,70 +37,94 @@ public enum ModelRotation {
    private final int quartersX;
    private final int quartersY;
 
-   private static int combineXY(int var0, int var1) {
-      return ☃ * 360 + ☃;
+   private static int combineXY(int p_177521_0_, int p_177521_1_) {
+      return p_177521_0_ * 360 + p_177521_1_;
    }
 
-   private ModelRotation(int var3, int var4) {
-      this.combinedXY = combineXY(☃, ☃);
+   private ModelRotation(int x, int y) {
+      this.combinedXY = combineXY(x, y);
       this.matrix = new Matrix4f();
-      Matrix4f ☃ = new Matrix4f();
-      ☃.setIdentity();
-      Matrix4f.rotate(-☃ * (float) (Math.PI / 180.0), new Vector3f(1.0F, 0.0F, 0.0F), ☃, ☃);
-      this.quartersX = MathHelper.abs(☃ / 90);
-      Matrix4f ☃x = new Matrix4f();
-      ☃x.setIdentity();
-      Matrix4f.rotate(-☃ * (float) (Math.PI / 180.0), new Vector3f(0.0F, 1.0F, 0.0F), ☃x, ☃x);
-      this.quartersY = MathHelper.abs(☃ / 90);
-      Matrix4f.mul(☃x, ☃, this.matrix);
+      Matrix4f matrix4f = new Matrix4f();
+      matrix4f.setIdentity();
+      Matrix4f.rotate(-x * (float) (Math.PI / 180.0), new Vector3f(1.0F, 0.0F, 0.0F), matrix4f, matrix4f);
+      this.quartersX = MathHelper.abs(x / 90);
+      Matrix4f matrix4f1 = new Matrix4f();
+      matrix4f1.setIdentity();
+      Matrix4f.rotate(-y * (float) (Math.PI / 180.0), new Vector3f(0.0F, 1.0F, 0.0F), matrix4f1, matrix4f1);
+      this.quartersY = MathHelper.abs(y / 90);
+      Matrix4f.mul(matrix4f1, matrix4f, this.matrix);
    }
 
    public Matrix4f matrix() {
       return this.matrix;
    }
 
-   public EnumFacing rotateFace(EnumFacing var1) {
-      EnumFacing ☃ = ☃;
+   public EnumFacing rotateFace(EnumFacing facing) {
+      EnumFacing enumfacing = facing;
 
-      for (int ☃x = 0; ☃x < this.quartersX; ☃x++) {
-         ☃ = ☃.rotateAround(EnumFacing.Axis.X);
+      for (int i = 0; i < this.quartersX; i++) {
+         enumfacing = enumfacing.rotateAround(EnumFacing.Axis.X);
       }
 
-      if (☃.getAxis() != EnumFacing.Axis.Y) {
-         for (int ☃x = 0; ☃x < this.quartersY; ☃x++) {
-            ☃ = ☃.rotateAround(EnumFacing.Axis.Y);
+      if (enumfacing.getAxis() != EnumFacing.Axis.Y) {
+         for (int j = 0; j < this.quartersY; j++) {
+            enumfacing = enumfacing.rotateAround(EnumFacing.Axis.Y);
          }
       }
 
-      return ☃;
+      return enumfacing;
    }
 
-   public int rotateVertex(EnumFacing var1, int var2) {
-      int ☃ = ☃;
-      if (☃.getAxis() == EnumFacing.Axis.X) {
-         ☃ = (☃ + this.quartersX) % 4;
+   public int rotateVertex(EnumFacing facing, int vertexIndex) {
+      int i = vertexIndex;
+      if (facing.getAxis() == EnumFacing.Axis.X) {
+         i = (vertexIndex + this.quartersX) % 4;
       }
 
-      EnumFacing ☃x = ☃;
+      EnumFacing enumfacing = facing;
 
-      for (int ☃xx = 0; ☃xx < this.quartersX; ☃xx++) {
-         ☃x = ☃x.rotateAround(EnumFacing.Axis.X);
+      for (int j = 0; j < this.quartersX; j++) {
+         enumfacing = enumfacing.rotateAround(EnumFacing.Axis.X);
       }
 
-      if (☃x.getAxis() == EnumFacing.Axis.Y) {
-         ☃ = (☃ + this.quartersY) % 4;
+      if (enumfacing.getAxis() == EnumFacing.Axis.Y) {
+         i = (i + this.quartersY) % 4;
       }
 
-      return ☃;
+      return i;
    }
 
-   public static ModelRotation getModelRotation(int var0, int var1) {
-      return MAP_ROTATIONS.get(combineXY(MathHelper.normalizeAngle(☃, 360), MathHelper.normalizeAngle(☃, 360)));
+   public static ModelRotation getModelRotation(int x, int y) {
+      return MAP_ROTATIONS.get(combineXY(MathHelper.normalizeAngle(x, 360), MathHelper.normalizeAngle(y, 360)));
+   }
+
+   public Optional<TRSRTransformation> apply(Optional<? extends IModelPart> part) {
+      return Reflector.ForgeHooksClient_applyTransform_MR.exists()
+         ? (Optional)Reflector.call(Reflector.ForgeHooksClient_applyTransform_MR, new Object[]{this, part})
+         : (Optional)Reflector.call(Reflector.ForgeHooksClient_applyTransform_M4, new Object[]{this.getMatrix(), part});
+   }
+
+   public javax.vecmath.Matrix4f getMatrix() {
+      if (Reflector.ForgeHooksClient_applyTransform_MR.exists()) {
+         return TRSRTransformation.from(this).getMatrix();
+      } else {
+         return Reflector.ForgeHooksClient_getMatrix.exists()
+            ? (javax.vecmath.Matrix4f)Reflector.call(Reflector.ForgeHooksClient_getMatrix, new Object[]{this})
+            : new javax.vecmath.Matrix4f(this.matrix());
+      }
+   }
+
+   public EnumFacing rotate(EnumFacing facing) {
+      return this.rotateFace(facing);
+   }
+
+   public int rotate(EnumFacing facing, int vertexIndex) {
+      return this.rotateVertex(facing, vertexIndex);
    }
 
    static {
-      for (ModelRotation ☃ : values()) {
-         MAP_ROTATIONS.put(☃.combinedXY, ☃);
+      for (ModelRotation modelrotation : values()) {
+         MAP_ROTATIONS.put(modelrotation.combinedXY, modelrotation);
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java b/patches/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
index 4623c9c..e307b2a 100644
--- a/patches/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
+++ b/patches/net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java
@@ -7,11 +7,13 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
@@ -37,24 +39,34 @@ public class ChunkRenderDispatcher {
    private final VertexBufferUploader vertexUploader = new VertexBufferUploader();
    private final Queue<ChunkRenderDispatcher.PendingUpload> queueChunkUploads = Queues.newPriorityQueue();
    private final ChunkRenderWorker renderWorker;
+   private List<RegionRenderCacheBuilder> listPausedBuilders = new ArrayList<>();
 
    public ChunkRenderDispatcher() {
-      int ☃ = Math.max(1, (int)(Runtime.getRuntime().maxMemory() * 0.3) / 10485760);
-      int ☃x = Math.max(1, MathHelper.clamp(Runtime.getRuntime().availableProcessors(), 1, ☃ / 5));
-      this.countRenderBuilders = MathHelper.clamp(☃x * 10, 1, ☃);
-      if (☃x > 1) {
-         for (int ☃xx = 0; ☃xx < ☃x; ☃xx++) {
-            ChunkRenderWorker ☃xxx = new ChunkRenderWorker(this);
-            Thread ☃xxxx = THREAD_FACTORY.newThread(☃xxx);
-            ☃xxxx.start();
-            this.listThreadedWorkers.add(☃xxx);
-            this.listWorkerThreads.add(☃xxxx);
+      this(-1);
+   }
+
+   public ChunkRenderDispatcher(int countRenderBuilders) {
+      int i = Math.max(1, (int)(Runtime.getRuntime().maxMemory() * 0.3) / 10485760);
+      int j = Math.max(1, MathHelper.clamp(Runtime.getRuntime().availableProcessors() - 2, 1, i / 5));
+      if (countRenderBuilders < 0) {
+         this.countRenderBuilders = MathHelper.clamp(j * 8, 1, i);
+      } else {
+         this.countRenderBuilders = countRenderBuilders;
+      }
+
+      if (j > 1) {
+         for (int k = 0; k < j; k++) {
+            ChunkRenderWorker chunkrenderworker = new ChunkRenderWorker(this);
+            Thread thread = THREAD_FACTORY.newThread(chunkrenderworker);
+            thread.start();
+            this.listThreadedWorkers.add(chunkrenderworker);
+            this.listWorkerThreads.add(thread);
          }
       }
 
       this.queueFreeRenderBuilders = Queues.newArrayBlockingQueue(this.countRenderBuilders);
 
-      for (int ☃xx = 0; ☃xx < this.countRenderBuilders; ☃xx++) {
+      for (int l = 0; l < this.countRenderBuilders; l++) {
          this.queueFreeRenderBuilders.add(new RegionRenderCacheBuilder());
       }
 
@@ -67,99 +79,102 @@ public String getDebugInfo() {
          : String.format("pC: %03d, pU: %1d, aB: %1d", this.queueChunkUpdates.size(), this.queueChunkUploads.size(), this.queueFreeRenderBuilders.size());
    }
 
-   public boolean runChunkUploads(long var1) {
-      boolean ☃ = false;
+   public boolean runChunkUploads(long finishTimeNano) {
+      boolean flag = false;
 
-      boolean ☃x;
+      boolean flag1;
       do {
-         ☃x = false;
+         flag1 = false;
          if (this.listWorkerThreads.isEmpty()) {
-            ChunkCompileTaskGenerator ☃xx = this.queueChunkUpdates.poll();
-            if (☃xx != null) {
+            ChunkCompileTaskGenerator chunkcompiletaskgenerator = this.queueChunkUpdates.poll();
+            if (chunkcompiletaskgenerator != null) {
                try {
-                  this.renderWorker.processTask(☃xx);
-                  ☃x = true;
-               } catch (InterruptedException var8) {
+                  this.renderWorker.processTask(chunkcompiletaskgenerator);
+                  flag1 = true;
+               } catch (InterruptedException var9) {
                   LOGGER.warn("Skipped task due to interrupt");
                }
             }
          }
 
+         ChunkRenderDispatcher.PendingUpload pendingUpload = null;
          synchronized (this.queueChunkUploads) {
-            if (!this.queueChunkUploads.isEmpty()) {
-               this.queueChunkUploads.poll().uploadTask.run();
-               ☃x = true;
-               ☃ = true;
-            }
+            pendingUpload = this.queueChunkUploads.poll();
          }
-      } while (☃ != 0L && ☃x && ☃ >= System.nanoTime());
 
-      return ☃;
+         if (pendingUpload != null) {
+            pendingUpload.uploadTask.run();
+            flag1 = true;
+            flag = true;
+         }
+      } while (finishTimeNano != 0L && flag1 && finishTimeNano >= System.nanoTime());
+
+      return flag;
    }
 
-   public boolean updateChunkLater(RenderChunk var1) {
-      ☃.getLockCompileTask().lock();
+   public boolean updateChunkLater(RenderChunk chunkRenderer) {
+      chunkRenderer.getLockCompileTask().lock();
 
-      boolean var4;
+      boolean flag1;
       try {
-         final ChunkCompileTaskGenerator ☃ = ☃.makeCompileTaskChunk();
-         ☃.addFinishRunnable(new Runnable() {
+         final ChunkCompileTaskGenerator chunkcompiletaskgenerator = chunkRenderer.makeCompileTaskChunk();
+         chunkcompiletaskgenerator.addFinishRunnable(new Runnable() {
             @Override
             public void run() {
-               ChunkRenderDispatcher.this.queueChunkUpdates.remove(☃);
+               ChunkRenderDispatcher.this.queueChunkUpdates.remove(chunkcompiletaskgenerator);
             }
          });
-         boolean ☃x = this.queueChunkUpdates.offer(☃);
-         if (!☃x) {
-            ☃.finish();
+         boolean flag = this.queueChunkUpdates.offer(chunkcompiletaskgenerator);
+         if (!flag) {
+            chunkcompiletaskgenerator.finish();
          }
 
-         var4 = ☃x;
+         flag1 = flag;
       } finally {
-         ☃.getLockCompileTask().unlock();
+         chunkRenderer.getLockCompileTask().unlock();
       }
 
-      return var4;
+      return flag1;
    }
 
-   public boolean updateChunkNow(RenderChunk var1) {
-      ☃.getLockCompileTask().lock();
+   public boolean updateChunkNow(RenderChunk chunkRenderer) {
+      chunkRenderer.getLockCompileTask().lock();
 
-      boolean var3;
+      boolean flag;
       try {
-         ChunkCompileTaskGenerator ☃ = ☃.makeCompileTaskChunk();
+         ChunkCompileTaskGenerator chunkcompiletaskgenerator = chunkRenderer.makeCompileTaskChunk();
 
          try {
-            this.renderWorker.processTask(☃);
-         } catch (InterruptedException var7) {
+            this.renderWorker.processTask(chunkcompiletaskgenerator);
+         } catch (InterruptedException var8) {
          }
 
-         var3 = true;
+         flag = true;
       } finally {
-         ☃.getLockCompileTask().unlock();
+         chunkRenderer.getLockCompileTask().unlock();
       }
 
-      return var3;
+      return flag;
    }
 
    public void stopChunkUpdates() {
       this.clearChunkUpdates();
-      List<RegionRenderCacheBuilder> ☃ = Lists.newArrayList();
+      List<RegionRenderCacheBuilder> list = Lists.newArrayList();
 
-      while (☃.size() != this.countRenderBuilders) {
+      while (list.size() != this.countRenderBuilders) {
          this.runChunkUploads(Long.MAX_VALUE);
 
          try {
-            ☃.add(this.allocateRenderBuilder());
+            list.add(this.allocateRenderBuilder());
          } catch (InterruptedException var3) {
          }
       }
 
-      this.queueFreeRenderBuilders.addAll(☃);
+      this.queueFreeRenderBuilders.addAll(list);
    }
 
-   public void freeRenderBuilder(RegionRenderCacheBuilder var1) {
-      this.queueFreeRenderBuilders.add(☃);
+   public void freeRenderBuilder(RegionRenderCacheBuilder p_178512_1_) {
+      this.queueFreeRenderBuilders.add(p_178512_1_);
    }
 
    public RegionRenderCacheBuilder allocateRenderBuilder() throws InterruptedException {
@@ -170,75 +185,80 @@ public ChunkCompileTaskGenerator getNextChunkUpdate() throws InterruptedExceptio
       return this.queueChunkUpdates.take();
    }
 
-   public boolean updateTransparencyLater(RenderChunk var1) {
-      ☃.getLockCompileTask().lock();
+   public boolean updateTransparencyLater(RenderChunk chunkRenderer) {
+      chunkRenderer.getLockCompileTask().lock();
 
-      boolean var3;
+      boolean var4;
       try {
-         final ChunkCompileTaskGenerator ☃ = ☃.makeCompileTaskTransparency();
-         if (☃ == null) {
-            return true;
+         final ChunkCompileTaskGenerator chunkcompiletaskgenerator = chunkRenderer.makeCompileTaskTransparency();
+         if (chunkcompiletaskgenerator != null) {
+            chunkcompiletaskgenerator.addFinishRunnable(new Runnable() {
+               @Override
+               public void run() {
+                  ChunkRenderDispatcher.this.queueChunkUpdates.remove(chunkcompiletaskgenerator);
+               }
+            });
+            return this.queueChunkUpdates.offer(chunkcompiletaskgenerator);
          }
 
-         ☃.addFinishRunnable(new Runnable() {
-            @Override
-            public void run() {
-               ChunkRenderDispatcher.this.queueChunkUpdates.remove(☃);
-            }
-         });
-         var3 = this.queueChunkUpdates.offer(☃);
+         boolean flag = true;
+         var4 = flag;
       } finally {
-         ☃.getLockCompileTask().unlock();
+         chunkRenderer.getLockCompileTask().unlock();
       }
 
-      return var3;
+      return var4;
    }
 
    public ListenableFuture<Object> uploadChunk(
-      final BlockRenderLayer var1, final BufferBuilder var2, final RenderChunk var3, final CompiledChunk var4, final double var5
+      final BlockRenderLayer p_188245_1_,
+      final BufferBuilder p_188245_2_,
+      final RenderChunk p_188245_3_,
+      final CompiledChunk p_188245_4_,
+      final double p_188245_5_
    ) {
       if (Minecraft.getMinecraft().isCallingFromMinecraftThread()) {
          if (OpenGlHelper.useVbo()) {
-            this.uploadVertexBuffer(☃, ☃.getVertexBufferByLayer(☃.ordinal()));
+            this.uploadVertexBuffer(p_188245_2_, p_188245_3_.getVertexBufferByLayer(p_188245_1_.ordinal()));
          } else {
-            this.uploadDisplayList(☃, ((ListedRenderChunk)☃).getDisplayList(☃, ☃), ☃);
+            this.uploadDisplayList(p_188245_2_, ((ListedRenderChunk)p_188245_3_).getDisplayList(p_188245_1_, p_188245_4_), p_188245_3_);
          }
 
-         ☃.setTranslation(0.0, 0.0, 0.0);
+         p_188245_2_.setTranslation(0.0, 0.0, 0.0);
          return Futures.immediateFuture(null);
       } else {
-         ListenableFutureTask<Object> ☃ = ListenableFutureTask.create(new Runnable() {
+         ListenableFutureTask<Object> listenablefuturetask = ListenableFutureTask.create(new Runnable() {
             @Override
             public void run() {
-               ChunkRenderDispatcher.this.uploadChunk(☃, ☃, ☃, ☃, ☃);
+               ChunkRenderDispatcher.this.uploadChunk(p_188245_1_, p_188245_2_, p_188245_3_, p_188245_4_, p_188245_5_);
             }
          }, null);
          synchronized (this.queueChunkUploads) {
-            this.queueChunkUploads.add(new ChunkRenderDispatcher.PendingUpload(☃, ☃));
-            return ☃;
+            this.queueChunkUploads.add(new ChunkRenderDispatcher.PendingUpload(listenablefuturetask, p_188245_5_));
+            return listenablefuturetask;
          }
       }
    }
 
-   private void uploadDisplayList(BufferBuilder var1, int var2, RenderChunk var3) {
-      GlStateManager.glNewList(☃, 4864);
+   private void uploadDisplayList(BufferBuilder vertexBufferIn, int list, RenderChunk chunkRenderer) {
+      GlStateManager.glNewList(list, 4864);
       GlStateManager.pushMatrix();
-      ☃.multModelviewMatrix();
-      this.worldVertexUploader.draw(☃);
+      chunkRenderer.multModelviewMatrix();
+      this.worldVertexUploader.draw(vertexBufferIn);
       GlStateManager.popMatrix();
       GlStateManager.glEndList();
    }
 
-   private void uploadVertexBuffer(BufferBuilder var1, VertexBuffer var2) {
-      this.vertexUploader.setVertexBuffer(☃);
-      this.vertexUploader.draw(☃);
+   private void uploadVertexBuffer(BufferBuilder p_178506_1_, VertexBuffer vertexBufferIn) {
+      this.vertexUploader.setVertexBuffer(vertexBufferIn);
+      this.vertexUploader.draw(p_178506_1_);
    }
 
    public void clearChunkUpdates() {
       while (!this.queueChunkUpdates.isEmpty()) {
-         ChunkCompileTaskGenerator ☃ = this.queueChunkUpdates.poll();
-         if (☃ != null) {
-            ☃.finish();
+         ChunkCompileTaskGenerator chunkcompiletaskgenerator = this.queueChunkUpdates.poll();
+         if (chunkcompiletaskgenerator != null) {
+            chunkcompiletaskgenerator.finish();
          }
       }
    }
@@ -250,14 +270,14 @@ public boolean hasNoChunkUpdates() {
    public void stopWorkerThreads() {
       this.clearChunkUpdates();
 
-      for (ChunkRenderWorker ☃ : this.listThreadedWorkers) {
-         ☃.notifyToStop();
+      for (ChunkRenderWorker chunkrenderworker : this.listThreadedWorkers) {
+         chunkrenderworker.notifyToStop();
       }
 
-      for (Thread ☃ : this.listWorkerThreads) {
+      for (Thread thread : this.listWorkerThreads) {
          try {
-            ☃.interrupt();
-            ☃.join();
+            thread.interrupt();
+            thread.join();
          } catch (InterruptedException var4) {
             LOGGER.warn("Interrupted whilst waiting for worker to die", var4);
          }
@@ -270,17 +290,35 @@ public boolean hasNoFreeRenderBuilders() {
       return this.queueFreeRenderBuilders.isEmpty();
    }
 
+   public void pauseChunkUpdates() {
+      while (this.listPausedBuilders.size() != this.countRenderBuilders) {
+         try {
+            this.runChunkUploads(Long.MAX_VALUE);
+            RegionRenderCacheBuilder builder = this.queueFreeRenderBuilders.poll(100L, TimeUnit.MILLISECONDS);
+            if (builder != null) {
+               this.listPausedBuilders.add(builder);
+            }
+         } catch (InterruptedException var2) {
+         }
+      }
+   }
+
+   public void resumeChunkUpdates() {
+      this.queueFreeRenderBuilders.addAll(this.listPausedBuilders);
+      this.listPausedBuilders.clear();
+   }
+
    class PendingUpload implements Comparable<ChunkRenderDispatcher.PendingUpload> {
       private final ListenableFutureTask<Object> uploadTask;
       private final double distanceSq;
 
-      public PendingUpload(ListenableFutureTask<Object> var2, double var3) {
-         this.uploadTask = ☃;
-         this.distanceSq = ☃;
+      public PendingUpload(ListenableFutureTask<Object> uploadTaskIn, double distanceSqIn) {
+         this.uploadTask = uploadTaskIn;
+         this.distanceSq = distanceSqIn;
       }
 
-      public int compareTo(ChunkRenderDispatcher.PendingUpload var1) {
-         return Doubles.compare(this.distanceSq, ☃.distanceSq);
+      public int compareTo(ChunkRenderDispatcher.PendingUpload p_compareTo_1_) {
+         return Doubles.compare(this.distanceSq, p_compareTo_1_.distanceSq);
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/chunk/CompiledChunk.java b/patches/net/minecraft/client/renderer/chunk/CompiledChunk.java
index 53cb82a..1d2cdf7 100644
--- a/patches/net/minecraft/client/renderer/chunk/CompiledChunk.java
+++ b/patches/net/minecraft/client/renderer/chunk/CompiledChunk.java
@@ -1,6 +1,7 @@
 package net.minecraft.client.renderer.chunk;
 
 import com.google.common.collect.Lists;
+import java.util.BitSet;
 import java.util.List;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.tileentity.TileEntity;
@@ -10,69 +11,83 @@
 public class CompiledChunk {
    public static final CompiledChunk DUMMY = new CompiledChunk() {
       @Override
-      protected void setLayerUsed(BlockRenderLayer var1) {
+      protected void setLayerUsed(BlockRenderLayer layer) {
          throw new UnsupportedOperationException();
       }
 
       @Override
-      public void setLayerStarted(BlockRenderLayer var1) {
+      public void setLayerStarted(BlockRenderLayer layer) {
          throw new UnsupportedOperationException();
       }
 
       @Override
-      public boolean isVisible(EnumFacing var1, EnumFacing var2) {
+      public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
          return false;
       }
+
+      @Override
+      public void setAnimatedSprites(BlockRenderLayer layer, BitSet animatedSprites) {
+         throw new UnsupportedOperationException();
+      }
    };
-   private final boolean[] layersUsed = new boolean[BlockRenderLayer.values().length];
-   private final boolean[] layersStarted = new boolean[BlockRenderLayer.values().length];
+   private final boolean[] layersUsed = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
+   private final boolean[] layersStarted = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
    private boolean empty = true;
    private final List<TileEntity> tileEntities = Lists.newArrayList();
    private SetVisibility setVisibility = new SetVisibility();
    private BufferBuilder.State state;
+   private BitSet[] animatedSprites = new BitSet[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
 
    public boolean isEmpty() {
       return this.empty;
    }
 
-   protected void setLayerUsed(BlockRenderLayer var1) {
+   protected void setLayerUsed(BlockRenderLayer layer) {
       this.empty = false;
-      this.layersUsed[☃.ordinal()] = true;
+      this.layersUsed[layer.ordinal()] = true;
    }
 
-   public boolean isLayerEmpty(BlockRenderLayer var1) {
-      return !this.layersUsed[☃.ordinal()];
+   public boolean isLayerEmpty(BlockRenderLayer layer) {
+      return !this.layersUsed[layer.ordinal()];
    }
 
-   public void setLayerStarted(BlockRenderLayer var1) {
-      this.layersStarted[☃.ordinal()] = true;
+   public void setLayerStarted(BlockRenderLayer layer) {
+      this.layersStarted[layer.ordinal()] = true;
    }
 
-   public boolean isLayerStarted(BlockRenderLayer var1) {
-      return this.layersStarted[☃.ordinal()];
+   public boolean isLayerStarted(BlockRenderLayer layer) {
+      return this.layersStarted[layer.ordinal()];
    }
 
    public List<TileEntity> getTileEntities() {
       return this.tileEntities;
    }
 
-   public void addTileEntity(TileEntity var1) {
-      this.tileEntities.add(☃);
+   public void addTileEntity(TileEntity tileEntityIn) {
+      this.tileEntities.add(tileEntityIn);
    }
 
-   public boolean isVisible(EnumFacing var1, EnumFacing var2) {
-      return this.setVisibility.isVisible(☃, ☃);
+   public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
+      return this.setVisibility.isVisible(facing, facing2);
    }
 
-   public void setVisibility(SetVisibility var1) {
-      this.setVisibility = ☃;
+   public void setVisibility(SetVisibility visibility) {
+      this.setVisibility = visibility;
    }
 
    public BufferBuilder.State getState() {
       return this.state;
    }
 
-   public void setState(BufferBuilder.State var1) {
-      this.state = ☃;
+   public void setState(BufferBuilder.State stateIn) {
+      this.state = stateIn;
+   }
+
+   public BitSet getAnimatedSprites(BlockRenderLayer layer) {
+      return this.animatedSprites[layer.ordinal()];
+   }
+
+   public void setAnimatedSprites(BlockRenderLayer layer, BitSet animatedSprites) {
+      this.animatedSprites[layer.ordinal()] = animatedSprites;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/chunk/RenderChunk.java b/patches/net/minecraft/client/renderer/chunk/RenderChunk.java
index 798422b..bd82d03 100644
--- a/patches/net/minecraft/client/renderer/chunk/RenderChunk.java
+++ b/patches/net/minecraft/client/renderer/chunk/RenderChunk.java
@@ -2,20 +2,29 @@
 
 import com.google.common.collect.Sets;
 import java.nio.FloatBuffer;
+import java.util.BitSet;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockCactus;
+import net.minecraft.block.BlockRedstoneWire;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.RegionRenderCacheBuilder;
 import net.minecraft.client.renderer.RenderGlobal;
+import net.minecraft.client.renderer.ViewFrustum;
+import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator.Status;
+import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator.Type;
+import net.minecraft.client.renderer.culling.ICamera;
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
@@ -26,12 +35,22 @@
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.ChunkCache;
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.Chunk.EnumCreateEntityType;
+import net.optifine.BlockPosM;
+import net.optifine.CustomBlockLayers;
+import net.optifine.override.ChunkCacheOF;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.render.AabbFrame;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
 
 public class RenderChunk {
-   private World world;
+   private final World world;
    private final RenderGlobal renderGlobal;
    public static int renderChunksUpdated;
    public CompiledChunk compiledChunk = CompiledChunk.DUMMY;
@@ -45,141 +64,221 @@ public class RenderChunk {
    public AxisAlignedBB boundingBox;
    private int frameIndex = -1;
    private boolean needsUpdate = true;
-   private final BlockPos.MutableBlockPos position = new BlockPos.MutableBlockPos(-1, -1, -1);
-   private final BlockPos.MutableBlockPos[] mapEnumFacing = new BlockPos.MutableBlockPos[6];
+   private final MutableBlockPos position = new MutableBlockPos(-1, -1, -1);
+   private final MutableBlockPos[] mapEnumFacing = new MutableBlockPos[6];
    private boolean needsImmediateUpdate;
-   private ChunkCache worldView;
-
-   public RenderChunk(World var1, RenderGlobal var2, int var3) {
-      for (int ☃ = 0; ☃ < this.mapEnumFacing.length; ☃++) {
-         this.mapEnumFacing[☃] = new BlockPos.MutableBlockPos();
+   public static final BlockRenderLayer[] ENUM_WORLD_BLOCK_LAYERS = BlockRenderLayer.values();
+   private final BlockRenderLayer[] blockLayersSingle = new BlockRenderLayer[1];
+   private final boolean isMipmaps = Config.isMipmaps();
+   private final boolean fixBlockLayer = !Reflector.BetterFoliageClient.exists();
+   private boolean playerUpdate = false;
+   public int regionX;
+   public int regionZ;
+   private final RenderChunk[] renderChunksOfset16 = new RenderChunk[6];
+   private boolean renderChunksOffset16Updated = false;
+   private Chunk chunk;
+   private RenderChunk[] renderChunkNeighbours = new RenderChunk[EnumFacing.VALUES.length];
+   private RenderChunk[] renderChunkNeighboursValid = new RenderChunk[EnumFacing.VALUES.length];
+   private boolean renderChunkNeighboursUpated = false;
+   private RenderGlobal.ContainerLocalRenderInformation renderInfo = new RenderGlobal.ContainerLocalRenderInformation(this, null, 0);
+   public AabbFrame boundingBoxParent;
+
+   public RenderChunk(World worldIn, RenderGlobal renderGlobalIn, int indexIn) {
+      for (int i = 0; i < this.mapEnumFacing.length; i++) {
+         this.mapEnumFacing[i] = new MutableBlockPos();
       }
 
-      this.world = ☃;
-      this.renderGlobal = ☃;
-      this.index = ☃;
+      this.world = worldIn;
+      this.renderGlobal = renderGlobalIn;
+      this.index = indexIn;
       if (OpenGlHelper.useVbo()) {
-         for (int ☃ = 0; ☃ < BlockRenderLayer.values().length; ☃++) {
-            this.vertexBuffers[☃] = new VertexBuffer(DefaultVertexFormats.BLOCK);
+         for (int j = 0; j < BlockRenderLayer.values().length; j++) {
+            this.vertexBuffers[j] = new VertexBuffer(DefaultVertexFormats.BLOCK);
          }
       }
    }
 
-   public boolean setFrameIndex(int var1) {
-      if (this.frameIndex == ☃) {
+   public boolean setFrameIndex(int frameIndexIn) {
+      if (this.frameIndex == frameIndexIn) {
          return false;
       } else {
-         this.frameIndex = ☃;
+         this.frameIndex = frameIndexIn;
          return true;
       }
    }
 
-   public VertexBuffer getVertexBufferByLayer(int var1) {
-      return this.vertexBuffers[☃];
+   public VertexBuffer getVertexBufferByLayer(int layer) {
+      return this.vertexBuffers[layer];
    }
 
-   public void setPosition(int var1, int var2, int var3) {
-      if (☃ != this.position.getX() || ☃ != this.position.getY() || ☃ != this.position.getZ()) {
+   public void setPosition(int x, int y, int z) {
+      if (x != this.position.getX() || y != this.position.getY() || z != this.position.getZ()) {
          this.stopCompileTask();
-         this.position.setPos(☃, ☃, ☃);
-         this.boundingBox = new AxisAlignedBB(☃, ☃, ☃, ☃ + 16, ☃ + 16, ☃ + 16);
+         this.position.setPos(x, y, z);
+         int bits = 8;
+         this.regionX = x >> bits << bits;
+         this.regionZ = z >> bits << bits;
+         this.boundingBox = new AxisAlignedBB(x, y, z, x + 16, y + 16, z + 16);
+
+         for (EnumFacing enumfacing : EnumFacing.VALUES) {
+            this.mapEnumFacing[enumfacing.ordinal()].setPos(this.position).move(enumfacing, 16);
+         }
+
+         this.renderChunksOffset16Updated = false;
+         this.renderChunkNeighboursUpated = false;
 
-         for (EnumFacing ☃ : EnumFacing.values()) {
-            this.mapEnumFacing[☃.ordinal()].setPos(this.position).move(☃, 16);
+         for (int i = 0; i < this.renderChunkNeighbours.length; i++) {
+            RenderChunk neighbour = this.renderChunkNeighbours[i];
+            if (neighbour != null) {
+               neighbour.renderChunkNeighboursUpated = false;
+            }
          }
 
+         this.chunk = null;
+         this.boundingBoxParent = null;
          this.initModelviewMatrix();
       }
    }
 
-   public void resortTransparency(float var1, float var2, float var3, ChunkCompileTaskGenerator var4) {
-      CompiledChunk ☃ = ☃.getCompiledChunk();
-      if (☃.getState() != null && !☃.isLayerEmpty(BlockRenderLayer.TRANSLUCENT)) {
-         this.preRenderBlocks(☃.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), this.position);
-         ☃.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT).setVertexState(☃.getState());
-         this.postRenderBlocks(BlockRenderLayer.TRANSLUCENT, ☃, ☃, ☃, ☃.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), ☃);
+   public void resortTransparency(float x, float y, float z, ChunkCompileTaskGenerator generator) {
+      CompiledChunk compiledchunk = generator.getCompiledChunk();
+      if (compiledchunk.getState() != null && !compiledchunk.isLayerEmpty(BlockRenderLayer.TRANSLUCENT)) {
+         BufferBuilder bufferTranslucent = generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT);
+         this.preRenderBlocks(bufferTranslucent, this.position);
+         bufferTranslucent.setVertexState(compiledchunk.getState());
+         this.postRenderBlocks(BlockRenderLayer.TRANSLUCENT, x, y, z, bufferTranslucent, compiledchunk);
       }
    }
 
-   public void rebuildChunk(float var1, float var2, float var3, ChunkCompileTaskGenerator var4) {
-      CompiledChunk ☃ = new CompiledChunk();
-      int ☃x = 1;
-      BlockPos ☃xx = this.position;
-      BlockPos ☃xxx = ☃xx.add(15, 15, 15);
-      ☃.getLock().lock();
+   public void rebuildChunk(float x, float y, float z, ChunkCompileTaskGenerator generator) {
+      CompiledChunk compiledchunk = new CompiledChunk();
+      int i = 1;
+      BlockPos blockpos = new BlockPos(this.position);
+      BlockPos blockpos1 = blockpos.add(15, 15, 15);
+      generator.getLock().lock();
 
       try {
-         if (☃.getStatus() != ChunkCompileTaskGenerator.Status.COMPILING) {
+         if (generator.getStatus() != Status.COMPILING) {
             return;
          }
 
-         ☃.setCompiledChunk(☃);
+         generator.setCompiledChunk(compiledchunk);
       } finally {
-         ☃.getLock().unlock();
+         generator.getLock().unlock();
       }
 
-      VisGraph var9 = new VisGraph();
-      HashSet var10 = Sets.newHashSet();
-      if (!this.worldView.isEmpty()) {
+      VisGraph lvt_9_1_ = new VisGraph();
+      HashSet lvt_10_1_ = Sets.newHashSet();
+      if (!this.isChunkRegionEmpty(blockpos)) {
          renderChunksUpdated++;
-         boolean[] ☃xxxx = new boolean[BlockRenderLayer.values().length];
-         BlockRendererDispatcher ☃xxxxx = Minecraft.getMinecraft().getBlockRendererDispatcher();
-
-         for (BlockPos.MutableBlockPos ☃xxxxxx : BlockPos.getAllInBoxMutable(☃xx, ☃xxx)) {
-            IBlockState ☃xxxxxxx = this.worldView.getBlockState(☃xxxxxx);
-            Block ☃xxxxxxxx = ☃xxxxxxx.getBlock();
-            if (☃xxxxxxx.isOpaqueCube()) {
-               var9.setOpaqueCube(☃xxxxxx);
+         ChunkCacheOF blockAccess = this.makeChunkCacheOF(blockpos);
+         blockAccess.renderStart();
+         boolean[] aboolean = new boolean[ENUM_WORLD_BLOCK_LAYERS.length];
+         BlockRendererDispatcher blockrendererdispatcher = Minecraft.getMinecraft().getBlockRendererDispatcher();
+         boolean forgeBlockCanRenderInLayerExists = Reflector.ForgeBlock_canRenderInLayer.exists();
+         boolean forgeHooksSetRenderLayerExists = Reflector.ForgeHooksClient_setRenderLayer.exists();
+
+         for (BlockPosM blockpos$mutableblockpos : BlockPosM.getAllInBoxMutable(blockpos, blockpos1)) {
+            IBlockState iblockstate = blockAccess.getBlockState(blockpos$mutableblockpos);
+            Block block = iblockstate.getBlock();
+            if (iblockstate.p()) {
+               lvt_9_1_.setOpaqueCube(blockpos$mutableblockpos);
             }
 
-            if (☃xxxxxxxx.hasTileEntity()) {
-               TileEntity ☃xxxxxxxxx = this.worldView.getTileEntity(☃xxxxxx, Chunk.EnumCreateEntityType.CHECK);
-               if (☃xxxxxxxxx != null) {
-                  TileEntitySpecialRenderer<TileEntity> ☃xxxxxxxxxx = TileEntityRendererDispatcher.instance.getRenderer(☃xxxxxxxxx);
-                  if (☃xxxxxxxxxx != null) {
-                     ☃.addTileEntity(☃xxxxxxxxx);
-                     if (☃xxxxxxxxxx.isGlobalRenderer(☃xxxxxxxxx)) {
-                        var10.add(☃xxxxxxxxx);
+            if (ReflectorForge.blockHasTileEntity(iblockstate)) {
+               TileEntity tileentity = blockAccess.getTileEntity(blockpos$mutableblockpos, EnumCreateEntityType.CHECK);
+               if (tileentity != null) {
+                  TileEntitySpecialRenderer<TileEntity> tileentityspecialrenderer = TileEntityRendererDispatcher.instance.getRenderer(tileentity);
+                  if (tileentityspecialrenderer != null) {
+                     if (tileentityspecialrenderer.isGlobalRenderer(tileentity)) {
+                        lvt_10_1_.add(tileentity);
+                     } else {
+                        compiledchunk.addTileEntity(tileentity);
                      }
                   }
                }
             }
 
-            BlockRenderLayer ☃xxxxxxxxx = ☃xxxxxxxx.getRenderLayer();
-            int ☃xxxxxxxxxx = ☃xxxxxxxxx.ordinal();
-            if (☃xxxxxxxx.getDefaultState().getRenderType() != EnumBlockRenderType.INVISIBLE) {
-               BufferBuilder ☃xxxxxxxxxxx = ☃.getRegionRenderCacheBuilder().getWorldRendererByLayerId(☃xxxxxxxxxx);
-               if (!☃.isLayerStarted(☃xxxxxxxxx)) {
-                  ☃.setLayerStarted(☃xxxxxxxxx);
-                  this.preRenderBlocks(☃xxxxxxxxxxx, ☃xx);
+            BlockRenderLayer[] blockLayers;
+            if (forgeBlockCanRenderInLayerExists) {
+               blockLayers = ENUM_WORLD_BLOCK_LAYERS;
+            } else {
+               blockLayers = this.blockLayersSingle;
+               blockLayers[0] = block.getRenderLayer();
+            }
+
+            for (int ix = 0; ix < blockLayers.length; ix++) {
+               BlockRenderLayer blockrenderlayer1 = blockLayers[ix];
+               if (forgeBlockCanRenderInLayerExists) {
+                  boolean canRenderInLayer = Reflector.callBoolean(block, Reflector.ForgeBlock_canRenderInLayer, new Object[]{iblockstate, blockrenderlayer1});
+                  if (!canRenderInLayer) {
+                     continue;
+                  }
+               }
+
+               if (forgeHooksSetRenderLayerExists) {
+                  Reflector.callVoid(Reflector.ForgeHooksClient_setRenderLayer, new Object[]{blockrenderlayer1});
+               }
+
+               blockrenderlayer1 = this.fixBlockLayer(iblockstate, blockrenderlayer1);
+               int j = blockrenderlayer1.ordinal();
+               if (block.getDefaultState().i() != EnumBlockRenderType.INVISIBLE) {
+                  BufferBuilder bufferbuilder = generator.getRegionRenderCacheBuilder().getWorldRendererByLayerId(j);
+                  bufferbuilder.setBlockLayer(blockrenderlayer1);
+                  RenderEnv renderEnv = bufferbuilder.getRenderEnv(iblockstate, blockpos$mutableblockpos);
+                  renderEnv.setRegionRenderCacheBuilder(generator.getRegionRenderCacheBuilder());
+                  if (!compiledchunk.isLayerStarted(blockrenderlayer1)) {
+                     compiledchunk.setLayerStarted(blockrenderlayer1);
+                     this.preRenderBlocks(bufferbuilder, blockpos);
+                  }
+
+                  aboolean[j] |= blockrendererdispatcher.renderBlock(iblockstate, blockpos$mutableblockpos, blockAccess, bufferbuilder);
+                  if (renderEnv.isOverlaysRendered()) {
+                     this.postRenderOverlays(generator.getRegionRenderCacheBuilder(), compiledchunk, aboolean);
+                     renderEnv.setOverlaysRendered(false);
+                  }
                }
+            }
 
-               ☃xxxx[☃xxxxxxxxxx] |= ☃xxxxx.renderBlock(☃xxxxxxx, ☃xxxxxx, this.worldView, ☃xxxxxxxxxxx);
+            if (forgeHooksSetRenderLayerExists) {
+               Reflector.callVoid(Reflector.ForgeHooksClient_setRenderLayer, new Object[]{null});
             }
          }
 
-         for (BlockRenderLayer ☃xxxxxx : BlockRenderLayer.values()) {
-            if (☃xxxx[☃xxxxxx.ordinal()]) {
-               ☃.setLayerUsed(☃xxxxxx);
+         for (BlockRenderLayer blockrenderlayer : ENUM_WORLD_BLOCK_LAYERS) {
+            if (aboolean[blockrenderlayer.ordinal()]) {
+               compiledchunk.setLayerUsed(blockrenderlayer);
             }
 
-            if (☃.isLayerStarted(☃xxxxxx)) {
-               this.postRenderBlocks(☃xxxxxx, ☃, ☃, ☃, ☃.getRegionRenderCacheBuilder().getWorldRendererByLayer(☃xxxxxx), ☃);
+            if (compiledchunk.isLayerStarted(blockrenderlayer)) {
+               if (Config.isShaders()) {
+                  SVertexBuilder.calcNormalChunkLayer(generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(blockrenderlayer));
+               }
+
+               BufferBuilder bufferBuilder = generator.getRegionRenderCacheBuilder().getWorldRendererByLayer(blockrenderlayer);
+               this.postRenderBlocks(blockrenderlayer, x, y, z, bufferBuilder, compiledchunk);
+               if (bufferBuilder.animatedSprites != null) {
+                  compiledchunk.setAnimatedSprites(blockrenderlayer, (BitSet)bufferBuilder.animatedSprites.clone());
+               }
+            } else {
+               compiledchunk.setAnimatedSprites(blockrenderlayer, null);
             }
          }
+
+         blockAccess.renderFinish();
       }
 
-      ☃.setVisibility(var9.computeVisibility());
+      compiledchunk.setVisibility(lvt_9_1_.computeVisibility());
       this.lockCompileTask.lock();
 
       try {
-         Set<TileEntity> ☃xxxx = Sets.newHashSet(var10);
-         Set<TileEntity> ☃xxxxx = Sets.newHashSet(this.setTileEntities);
-         ☃xxxx.removeAll(this.setTileEntities);
-         ☃xxxxx.removeAll(var10);
+         Set<TileEntity> set = Sets.newHashSet(lvt_10_1_);
+         Set<TileEntity> set1 = Sets.newHashSet(this.setTileEntities);
+         set.removeAll(this.setTileEntities);
+         set1.removeAll(lvt_10_1_);
          this.setTileEntities.clear();
-         this.setTileEntities.addAll(var10);
-         this.renderGlobal.updateTileEntities(☃xxxxx, ☃xxxx);
+         this.setTileEntities.addAll(lvt_10_1_);
+         this.renderGlobal.updateTileEntities(set1, set);
       } finally {
          this.lockCompileTask.unlock();
       }
@@ -189,7 +288,7 @@ protected void finishCompileTask() {
       this.lockCompileTask.lock();
 
       try {
-         if (this.compileTask != null && this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.DONE) {
+         if (this.compileTask != null && this.compileTask.getStatus() != Status.DONE) {
             this.compileTask.finish();
             this.compileTask = null;
          }
@@ -205,75 +304,85 @@ public ReentrantLock getLockCompileTask() {
    public ChunkCompileTaskGenerator makeCompileTaskChunk() {
       this.lockCompileTask.lock();
 
-      ChunkCompileTaskGenerator var1;
+      ChunkCompileTaskGenerator chunkcompiletaskgenerator;
       try {
          this.finishCompileTask();
-         this.compileTask = new ChunkCompileTaskGenerator(this, ChunkCompileTaskGenerator.Type.REBUILD_CHUNK, this.getDistanceSq());
+         this.compileTask = new ChunkCompileTaskGenerator(this, Type.REBUILD_CHUNK, this.getDistanceSq());
          this.rebuildWorldView();
-         var1 = this.compileTask;
+         chunkcompiletaskgenerator = this.compileTask;
       } finally {
          this.lockCompileTask.unlock();
       }
 
-      return var1;
+      return chunkcompiletaskgenerator;
    }
 
    private void rebuildWorldView() {
-      int ☃ = 1;
-      this.worldView = new ChunkCache(this.world, this.position.add(-1, -1, -1), this.position.add(16, 16, 16), 1);
+      int i = 1;
    }
 
    @Nullable
    public ChunkCompileTaskGenerator makeCompileTaskTransparency() {
       this.lockCompileTask.lock();
 
-      Object var1;
+      ChunkCompileTaskGenerator var2;
       try {
-         if (this.compileTask == null || this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.PENDING) {
-            if (this.compileTask != null && this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.DONE) {
-               this.compileTask.finish();
-               this.compileTask = null;
-            }
+         if (this.compileTask != null && this.compileTask.getStatus() == Status.PENDING) {
+            return null;
+         }
 
-            this.compileTask = new ChunkCompileTaskGenerator(this, ChunkCompileTaskGenerator.Type.RESORT_TRANSPARENCY, this.getDistanceSq());
-            this.compileTask.setCompiledChunk(this.compiledChunk);
-            return this.compileTask;
+         if (this.compileTask != null && this.compileTask.getStatus() != Status.DONE) {
+            this.compileTask.finish();
+            this.compileTask = null;
          }
 
-         var1 = null;
+         this.compileTask = new ChunkCompileTaskGenerator(this, Type.RESORT_TRANSPARENCY, this.getDistanceSq());
+         this.compileTask.setCompiledChunk(this.compiledChunk);
+         ChunkCompileTaskGenerator chunkcompiletaskgenerator = this.compileTask;
+         var2 = chunkcompiletaskgenerator;
       } finally {
          this.lockCompileTask.unlock();
       }
 
-      return (ChunkCompileTaskGenerator)var1;
+      return var2;
    }
 
    protected double getDistanceSq() {
-      EntityPlayerSP ☃ = Minecraft.getMinecraft().player;
-      double ☃x = this.boundingBox.minX + 8.0 - ☃.posX;
-      double ☃xx = this.boundingBox.minY + 8.0 - ☃.posY;
-      double ☃xxx = this.boundingBox.minZ + 8.0 - ☃.posZ;
-      return ☃x * ☃x + ☃xx * ☃xx + ☃xxx * ☃xxx;
+      EntityPlayerSP entityplayersp = Minecraft.getMinecraft().player;
+      double d0 = this.boundingBox.minX + 8.0 - entityplayersp.posX;
+      double d1 = this.boundingBox.minY + 8.0 - entityplayersp.posY;
+      double d2 = this.boundingBox.minZ + 8.0 - entityplayersp.posZ;
+      return d0 * d0 + d1 * d1 + d2 * d2;
    }
 
-   private void preRenderBlocks(BufferBuilder var1, BlockPos var2) {
-      ☃.begin(7, DefaultVertexFormats.BLOCK);
-      ☃.setTranslation(-☃.getX(), -☃.getY(), -☃.getZ());
+   private void preRenderBlocks(BufferBuilder worldRendererIn, BlockPos pos) {
+      worldRendererIn.begin(7, DefaultVertexFormats.BLOCK);
+      if (Config.isRenderRegions()) {
+         int bits = 8;
+         int dx = pos.getX() >> bits << bits;
+         int dy = pos.getY() >> bits << bits;
+         int dz = pos.getZ() >> bits << bits;
+         dx = this.regionX;
+         dz = this.regionZ;
+         worldRendererIn.setTranslation(-dx, -dy, -dz);
+      } else {
+         worldRendererIn.setTranslation(-pos.getX(), -pos.getY(), -pos.getZ());
+      }
    }
 
-   private void postRenderBlocks(BlockRenderLayer var1, float var2, float var3, float var4, BufferBuilder var5, CompiledChunk var6) {
-      if (☃ == BlockRenderLayer.TRANSLUCENT && !☃.isLayerEmpty(☃)) {
-         ☃.sortVertexData(☃, ☃, ☃);
-         ☃.setState(☃.getVertexState());
+   private void postRenderBlocks(BlockRenderLayer layer, float x, float y, float z, BufferBuilder worldRendererIn, CompiledChunk compiledChunkIn) {
+      if (layer == BlockRenderLayer.TRANSLUCENT && !compiledChunkIn.isLayerEmpty(layer)) {
+         worldRendererIn.sortVertexData(x, y, z);
+         compiledChunkIn.setState(worldRendererIn.getVertexState());
       }
 
-      ☃.finishDrawing();
+      worldRendererIn.finishDrawing();
    }
 
    private void initModelviewMatrix() {
       GlStateManager.pushMatrix();
       GlStateManager.loadIdentity();
-      float ☃ = 1.000001F;
+      float f = 1.000001F;
       GlStateManager.translate(-8.0F, -8.0F, -8.0F);
       GlStateManager.scale(1.000001F, 1.000001F, 1.000001F);
       GlStateManager.translate(8.0F, 8.0F, 8.0F);
@@ -289,11 +398,11 @@ public CompiledChunk getCompiledChunk() {
       return this.compiledChunk;
    }
 
-   public void setCompiledChunk(CompiledChunk var1) {
+   public void setCompiledChunk(CompiledChunk compiledChunkIn) {
       this.lockCompiledChunk.lock();
 
       try {
-         this.compiledChunk = ☃;
+         this.compiledChunk = compiledChunkIn;
       } finally {
          this.lockCompiledChunk.unlock();
       }
@@ -306,11 +415,10 @@ public void stopCompileTask() {
 
    public void deleteGlResources() {
       this.stopCompileTask();
-      this.world = null;
 
-      for (int ☃ = 0; ☃ < BlockRenderLayer.values().length; ☃++) {
-         if (this.vertexBuffers[☃] != null) {
-            this.vertexBuffers[☃].deleteGlBuffers();
+      for (int i = 0; i < BlockRenderLayer.values().length; i++) {
+         if (this.vertexBuffers[i] != null) {
+            this.vertexBuffers[i].deleteGlBuffers();
          }
       }
    }
@@ -319,18 +427,22 @@ public BlockPos getPosition() {
       return this.position;
    }
 
-   public void setNeedsUpdate(boolean var1) {
+   public void setNeedsUpdate(boolean immediate) {
       if (this.needsUpdate) {
-         ☃ |= this.needsImmediateUpdate;
+         immediate |= this.needsImmediateUpdate;
       }
 
       this.needsUpdate = true;
-      this.needsImmediateUpdate = ☃;
+      this.needsImmediateUpdate = immediate;
+      if (this.isWorldPlayerUpdate()) {
+         this.playerUpdate = true;
+      }
    }
 
    public void clearNeedsUpdate() {
       this.needsUpdate = false;
       this.needsImmediateUpdate = false;
+      this.playerUpdate = false;
    }
 
    public boolean needsUpdate() {
@@ -341,11 +453,190 @@ public boolean needsImmediateUpdate() {
       return this.needsUpdate && this.needsImmediateUpdate;
    }
 
-   public BlockPos getBlockPosOffset16(EnumFacing var1) {
-      return this.mapEnumFacing[☃.ordinal()];
+   public BlockPos getBlockPosOffset16(EnumFacing facing) {
+      return this.mapEnumFacing[facing.ordinal()];
    }
 
    public World getWorld() {
       return this.world;
    }
+
+   private boolean isWorldPlayerUpdate() {
+      if (this.world instanceof WorldClient) {
+         WorldClient worldClient = (WorldClient)this.world;
+         return worldClient.isPlayerUpdate();
+      } else {
+         return false;
+      }
+   }
+
+   public boolean isPlayerUpdate() {
+      return this.playerUpdate;
+   }
+
+   private BlockRenderLayer fixBlockLayer(IBlockState blockState, BlockRenderLayer layer) {
+      if (CustomBlockLayers.isActive()) {
+         BlockRenderLayer layerCustom = CustomBlockLayers.getRenderLayer(blockState);
+         if (layerCustom != null) {
+            return layerCustom;
+         }
+      }
+
+      if (!this.fixBlockLayer) {
+         return layer;
+      } else {
+         if (this.isMipmaps) {
+            if (layer == BlockRenderLayer.CUTOUT) {
+               Block block = blockState.getBlock();
+               if (block instanceof BlockRedstoneWire) {
+                  return layer;
+               }
+
+               if (block instanceof BlockCactus) {
+                  return layer;
+               }
+
+               return BlockRenderLayer.CUTOUT_MIPPED;
+            }
+         } else if (layer == BlockRenderLayer.CUTOUT_MIPPED) {
+            return BlockRenderLayer.CUTOUT;
+         }
+
+         return layer;
+      }
+   }
+
+   private void postRenderOverlays(RegionRenderCacheBuilder regionRenderCacheBuilder, CompiledChunk compiledChunk, boolean[] layerFlags) {
+      this.postRenderOverlay(BlockRenderLayer.CUTOUT, regionRenderCacheBuilder, compiledChunk, layerFlags);
+      this.postRenderOverlay(BlockRenderLayer.CUTOUT_MIPPED, regionRenderCacheBuilder, compiledChunk, layerFlags);
+      this.postRenderOverlay(BlockRenderLayer.TRANSLUCENT, regionRenderCacheBuilder, compiledChunk, layerFlags);
+   }
+
+   private void postRenderOverlay(BlockRenderLayer layer, RegionRenderCacheBuilder regionRenderCacheBuilder, CompiledChunk compiledchunk, boolean[] layerFlags) {
+      BufferBuilder bufferOverlay = regionRenderCacheBuilder.getWorldRendererByLayer(layer);
+      if (bufferOverlay.isDrawing()) {
+         compiledchunk.setLayerStarted(layer);
+         layerFlags[layer.ordinal()] = true;
+      }
+   }
+
+   private ChunkCacheOF makeChunkCacheOF(BlockPos posIn) {
+      BlockPos posFrom = posIn.add(-1, -1, -1);
+      BlockPos posTo = posIn.add(16, 16, 16);
+      ChunkCache chunkCache = this.createRegionRenderCache(this.world, posFrom, posTo, 1);
+      if (Reflector.MinecraftForgeClient_onRebuildChunk.exists()) {
+         Reflector.call(Reflector.MinecraftForgeClient_onRebuildChunk, new Object[]{this.world, posIn, chunkCache});
+      }
+
+      return new ChunkCacheOF(chunkCache, posFrom, posTo, 1);
+   }
+
+   public RenderChunk getRenderChunkOffset16(ViewFrustum viewFrustum, EnumFacing facing) {
+      if (!this.renderChunksOffset16Updated) {
+         for (int i = 0; i < EnumFacing.VALUES.length; i++) {
+            EnumFacing ef = EnumFacing.VALUES[i];
+            BlockPos posOffset16 = this.getBlockPosOffset16(ef);
+            this.renderChunksOfset16[i] = viewFrustum.getRenderChunk(posOffset16);
+         }
+
+         this.renderChunksOffset16Updated = true;
+      }
+
+      return this.renderChunksOfset16[facing.ordinal()];
+   }
+
+   public Chunk getChunk() {
+      return this.getChunk(this.position);
+   }
+
+   private Chunk getChunk(BlockPos posIn) {
+      Chunk chunkLocal = this.chunk;
+      if (chunkLocal != null && chunkLocal.isLoaded()) {
+         return chunkLocal;
+      } else {
+         chunkLocal = this.world.getChunk(posIn);
+         this.chunk = chunkLocal;
+         return chunkLocal;
+      }
+   }
+
+   public boolean isChunkRegionEmpty() {
+      return this.isChunkRegionEmpty(this.position);
+   }
+
+   private boolean isChunkRegionEmpty(BlockPos posIn) {
+      int yStart = posIn.getY();
+      int yEnd = yStart + 15;
+      return this.getChunk(posIn).isEmptyBetween(yStart, yEnd);
+   }
+
+   public void setRenderChunkNeighbour(EnumFacing facing, RenderChunk neighbour) {
+      this.renderChunkNeighbours[facing.ordinal()] = neighbour;
+      this.renderChunkNeighboursValid[facing.ordinal()] = neighbour;
+   }
+
+   public RenderChunk getRenderChunkNeighbour(EnumFacing facing) {
+      if (!this.renderChunkNeighboursUpated) {
+         this.updateRenderChunkNeighboursValid();
+      }
+
+      return this.renderChunkNeighboursValid[facing.ordinal()];
+   }
+
+   public RenderGlobal.ContainerLocalRenderInformation getRenderInfo() {
+      return this.renderInfo;
+   }
+
+   private void updateRenderChunkNeighboursValid() {
+      int x = this.getPosition().getX();
+      int z = this.getPosition().getZ();
+      int north = EnumFacing.NORTH.ordinal();
+      int south = EnumFacing.SOUTH.ordinal();
+      int west = EnumFacing.WEST.ordinal();
+      int east = EnumFacing.EAST.ordinal();
+      this.renderChunkNeighboursValid[north] = this.renderChunkNeighbours[north].getPosition().getZ() == z - 16 ? this.renderChunkNeighbours[north] : null;
+      this.renderChunkNeighboursValid[south] = this.renderChunkNeighbours[south].getPosition().getZ() == z + 16 ? this.renderChunkNeighbours[south] : null;
+      this.renderChunkNeighboursValid[west] = this.renderChunkNeighbours[west].getPosition().getX() == x - 16 ? this.renderChunkNeighbours[west] : null;
+      this.renderChunkNeighboursValid[east] = this.renderChunkNeighbours[east].getPosition().getX() == x + 16 ? this.renderChunkNeighbours[east] : null;
+      this.renderChunkNeighboursUpated = true;
+   }
+
+   public boolean isBoundingBoxInFrustum(ICamera camera, int frameCount) {
+      return this.getBoundingBoxParent().isBoundingBoxInFrustumFully(camera, frameCount) ? true : camera.isBoundingBoxInFrustum(this.boundingBox);
+   }
+
+   public AabbFrame getBoundingBoxParent() {
+      if (this.boundingBoxParent == null) {
+         BlockPos pos = this.getPosition();
+         int x = pos.getX();
+         int y = pos.getY();
+         int z = pos.getZ();
+         int bits = 5;
+         int xp = x >> bits << bits;
+         int yp = y >> bits << bits;
+         int zp = z >> bits << bits;
+         if (xp != x || yp != y || zp != z) {
+            AabbFrame bbp = this.renderGlobal.getRenderChunk(new BlockPos(xp, yp, zp)).getBoundingBoxParent();
+            if (bbp != null && bbp.minX == xp && bbp.minY == yp && bbp.minZ == zp) {
+               this.boundingBoxParent = bbp;
+            }
+         }
+
+         if (this.boundingBoxParent == null) {
+            int delta = 1 << bits;
+            this.boundingBoxParent = new AabbFrame(xp, yp, zp, xp + delta, yp + delta, zp + delta);
+         }
+      }
+
+      return this.boundingBoxParent;
+   }
+
+   @Override
+   public String toString() {
+      return "pos: " + this.getPosition() + ", frameIndex: " + this.frameIndex;
+   }
+
+   protected ChunkCache createRegionRenderCache(World world, BlockPos from, BlockPos to, int subtract) {
+      return new ChunkCache(world, from, to, subtract);
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/chunk/SetVisibility.java b/patches/net/minecraft/client/renderer/chunk/SetVisibility.java
index ef906d8..a36f314 100644
--- a/patches/net/minecraft/client/renderer/chunk/SetVisibility.java
+++ b/patches/net/minecraft/client/renderer/chunk/SetVisibility.java
@@ -1,60 +1,83 @@
 package net.minecraft.client.renderer.chunk;
 
-import java.util.BitSet;
 import java.util.Set;
 import net.minecraft.util.EnumFacing;
 
 public class SetVisibility {
    private static final int COUNT_FACES = EnumFacing.values().length;
-   private final BitSet bitSet = new BitSet(COUNT_FACES * COUNT_FACES);
+   private long bits;
 
-   public void setManyVisible(Set<EnumFacing> var1) {
-      for (EnumFacing ☃ : ☃) {
-         for (EnumFacing ☃x : ☃) {
-            this.setVisible(☃, ☃x, true);
+   public void setManyVisible(Set<EnumFacing> facing) {
+      for (EnumFacing enumfacing : facing) {
+         for (EnumFacing enumfacing1 : facing) {
+            this.setVisible(enumfacing, enumfacing1, true);
          }
       }
    }
 
-   public void setVisible(EnumFacing var1, EnumFacing var2, boolean var3) {
-      this.bitSet.set(☃.ordinal() + ☃.ordinal() * COUNT_FACES, ☃);
-      this.bitSet.set(☃.ordinal() + ☃.ordinal() * COUNT_FACES, ☃);
+   public void setVisible(EnumFacing facing, EnumFacing facing2, boolean p_178619_3_) {
+      this.setBit(facing.ordinal() + facing2.ordinal() * COUNT_FACES, p_178619_3_);
+      this.setBit(facing2.ordinal() + facing.ordinal() * COUNT_FACES, p_178619_3_);
    }
 
-   public void setAllVisible(boolean var1) {
-      this.bitSet.set(0, this.bitSet.size(), ☃);
+   public void setAllVisible(boolean visible) {
+      if (visible) {
+         this.bits = -1L;
+      } else {
+         this.bits = 0L;
+      }
    }
 
-   public boolean isVisible(EnumFacing var1, EnumFacing var2) {
-      return this.bitSet.get(☃.ordinal() + ☃.ordinal() * COUNT_FACES);
+   public boolean isVisible(EnumFacing facing, EnumFacing facing2) {
+      return this.getBit(facing.ordinal() + facing2.ordinal() * COUNT_FACES);
    }
 
    @Override
    public String toString() {
-      StringBuilder ☃ = new StringBuilder();
-      ☃.append(' ');
+      StringBuilder stringbuilder = new StringBuilder();
+      stringbuilder.append(' ');
 
-      for (EnumFacing ☃x : EnumFacing.values()) {
-         ☃.append(' ').append(☃x.toString().toUpperCase().charAt(0));
+      for (EnumFacing enumfacing : EnumFacing.values()) {
+         stringbuilder.append(' ').append(enumfacing.toString().toUpperCase().charAt(0));
       }
 
-      ☃.append('\n');
+      stringbuilder.append('\n');
 
-      for (EnumFacing ☃x : EnumFacing.values()) {
-         ☃.append(☃x.toString().toUpperCase().charAt(0));
+      for (EnumFacing enumfacing2 : EnumFacing.values()) {
+         stringbuilder.append(enumfacing2.toString().toUpperCase().charAt(0));
 
-         for (EnumFacing ☃xx : EnumFacing.values()) {
-            if (☃x == ☃xx) {
-               ☃.append("  ");
+         for (EnumFacing enumfacing1 : EnumFacing.values()) {
+            if (enumfacing2 == enumfacing1) {
+               stringbuilder.append("  ");
             } else {
-               boolean ☃xxx = this.isVisible(☃x, ☃xx);
-               ☃.append(' ').append((char)(☃xxx ? 'Y' : 'n'));
+               boolean flag = this.isVisible(enumfacing2, enumfacing1);
+               stringbuilder.append(' ').append((char)(flag ? 'Y' : 'n'));
             }
          }
 
-         ☃.append('\n');
+         stringbuilder.append('\n');
+      }
+
+      return stringbuilder.toString();
+   }
+
+   private boolean getBit(int i) {
+      return (this.bits & 1 << i) != 0L;
+   }
+
+   private void setBit(int i, boolean on) {
+      if (on) {
+         this.setBit(i);
+      } else {
+         this.clearBit(i);
       }
+   }
+
+   private void setBit(int i) {
+      this.bits |= 1 << i;
+   }
 
-      return ☃.toString();
+   private void clearBit(int i) {
+      this.bits &= ~(1 << i);
    }
 }
diff --git a/patches/net/minecraft/client/renderer/chunk/VisGraph.java b/patches/net/minecraft/client/renderer/chunk/VisGraph.java
index 45489f2..74a706b 100644
--- a/patches/net/minecraft/client/renderer/chunk/VisGraph.java
+++ b/patches/net/minecraft/client/renderer/chunk/VisGraph.java
@@ -1,9 +1,8 @@
 package net.minecraft.client.renderer.chunk;
 
-import com.google.common.collect.Queues;
+import java.util.ArrayDeque;
 import java.util.BitSet;
 import java.util.EnumSet;
-import java.util.Queue;
 import java.util.Set;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.IntegerCache;
@@ -17,138 +16,138 @@ public class VisGraph {
    private static final int[] INDEX_OF_EDGES = new int[1352];
    private int empty = 4096;
 
-   public void setOpaqueCube(BlockPos var1) {
-      this.bitSet.set(getIndex(☃), true);
+   public void setOpaqueCube(BlockPos pos) {
+      this.bitSet.set(getIndex(pos), true);
       this.empty--;
    }
 
-   private static int getIndex(BlockPos var0) {
-      return getIndex(☃.getX() & 15, ☃.getY() & 15, ☃.getZ() & 15);
+   private static int getIndex(BlockPos pos) {
+      return getIndex(pos.getX() & 15, pos.getY() & 15, pos.getZ() & 15);
    }
 
-   private static int getIndex(int var0, int var1, int var2) {
-      return ☃ << 0 | ☃ << 8 | ☃ << 4;
+   private static int getIndex(int x, int y, int z) {
+      return x << 0 | y << 8 | z << 4;
    }
 
    public SetVisibility computeVisibility() {
-      SetVisibility ☃ = new SetVisibility();
+      SetVisibility setvisibility = new SetVisibility();
       if (4096 - this.empty < 256) {
-         ☃.setAllVisible(true);
+         setvisibility.setAllVisible(true);
       } else if (this.empty == 0) {
-         ☃.setAllVisible(false);
+         setvisibility.setAllVisible(false);
       } else {
-         for (int ☃x : INDEX_OF_EDGES) {
-            if (!this.bitSet.get(☃x)) {
-               ☃.setManyVisible(this.floodFill(☃x));
+         for (int i : INDEX_OF_EDGES) {
+            if (!this.bitSet.get(i)) {
+               setvisibility.setManyVisible(this.floodFill(i));
             }
          }
       }
 
-      return ☃;
+      return setvisibility;
    }
 
-   public Set<EnumFacing> getVisibleFacings(BlockPos var1) {
-      return this.floodFill(getIndex(☃));
+   public Set<EnumFacing> getVisibleFacings(BlockPos pos) {
+      return this.floodFill(getIndex(pos));
    }
 
-   private Set<EnumFacing> floodFill(int var1) {
-      Set<EnumFacing> ☃ = EnumSet.noneOf(EnumFacing.class);
-      Queue<Integer> ☃x = Queues.newArrayDeque();
-      ☃x.add(IntegerCache.getInteger(☃));
-      this.bitSet.set(☃, true);
-
-      while (!☃x.isEmpty()) {
-         int ☃xx = ☃x.poll();
-         this.addEdges(☃xx, ☃);
-
-         for (EnumFacing ☃xxx : EnumFacing.values()) {
-            int ☃xxxx = this.getNeighborIndexAtFace(☃xx, ☃xxx);
-            if (☃xxxx >= 0 && !this.bitSet.get(☃xxxx)) {
-               this.bitSet.set(☃xxxx, true);
-               ☃x.add(IntegerCache.getInteger(☃xxxx));
+   private Set<EnumFacing> floodFill(int pos) {
+      Set<EnumFacing> set = EnumSet.noneOf(EnumFacing.class);
+      ArrayDeque queue = new ArrayDeque(384);
+      queue.add(IntegerCache.getInteger(pos));
+      this.bitSet.set(pos, true);
+
+      while (!queue.isEmpty()) {
+         int i = (Integer)queue.poll();
+         this.addEdges(i, set);
+
+         for (EnumFacing enumfacing : EnumFacing.VALUES) {
+            int j = this.getNeighborIndexAtFace(i, enumfacing);
+            if (j >= 0 && !this.bitSet.get(j)) {
+               this.bitSet.set(j, true);
+               queue.add(IntegerCache.getInteger(j));
             }
          }
       }
 
-      return ☃;
+      return set;
    }
 
-   private void addEdges(int var1, Set<EnumFacing> var2) {
-      int ☃ = ☃ >> 0 & 15;
-      if (☃ == 0) {
-         ☃.add(EnumFacing.WEST);
-      } else if (☃ == 15) {
-         ☃.add(EnumFacing.EAST);
+   private void addEdges(int pos, Set<EnumFacing> p_178610_2_) {
+      int i = pos >> 0 & 15;
+      if (i == 0) {
+         p_178610_2_.add(EnumFacing.WEST);
+      } else if (i == 15) {
+         p_178610_2_.add(EnumFacing.EAST);
       }
 
-      int ☃x = ☃ >> 8 & 15;
-      if (☃x == 0) {
-         ☃.add(EnumFacing.DOWN);
-      } else if (☃x == 15) {
-         ☃.add(EnumFacing.UP);
+      int j = pos >> 8 & 15;
+      if (j == 0) {
+         p_178610_2_.add(EnumFacing.DOWN);
+      } else if (j == 15) {
+         p_178610_2_.add(EnumFacing.UP);
       }
 
-      int ☃xx = ☃ >> 4 & 15;
-      if (☃xx == 0) {
-         ☃.add(EnumFacing.NORTH);
-      } else if (☃xx == 15) {
-         ☃.add(EnumFacing.SOUTH);
+      int k = pos >> 4 & 15;
+      if (k == 0) {
+         p_178610_2_.add(EnumFacing.NORTH);
+      } else if (k == 15) {
+         p_178610_2_.add(EnumFacing.SOUTH);
       }
    }
 
-   private int getNeighborIndexAtFace(int var1, EnumFacing var2) {
-      switch (☃) {
+   private int getNeighborIndexAtFace(int pos, EnumFacing facing) {
+      switch (facing) {
          case DOWN:
-            if ((☃ >> 8 & 15) == 0) {
+            if ((pos >> 8 & 15) == 0) {
                return -1;
             }
 
-            return ☃ - DY;
+            return pos - DY;
          case UP:
-            if ((☃ >> 8 & 15) == 15) {
+            if ((pos >> 8 & 15) == 15) {
                return -1;
             }
 
-            return ☃ + DY;
+            return pos + DY;
          case NORTH:
-            if ((☃ >> 4 & 15) == 0) {
+            if ((pos >> 4 & 15) == 0) {
                return -1;
             }
 
-            return ☃ - DZ;
+            return pos - DZ;
          case SOUTH:
-            if ((☃ >> 4 & 15) == 15) {
+            if ((pos >> 4 & 15) == 15) {
                return -1;
             }
 
-            return ☃ + DZ;
+            return pos + DZ;
          case WEST:
-            if ((☃ >> 0 & 15) == 0) {
+            if ((pos >> 0 & 15) == 0) {
                return -1;
             }
 
-            return ☃ - DX;
+            return pos - DX;
          case EAST:
-            if ((☃ >> 0 & 15) == 15) {
+            if ((pos >> 0 & 15) == 15) {
                return -1;
             }
 
-            return ☃ + DX;
+            return pos + DX;
          default:
             return -1;
       }
    }
 
    static {
-      int ☃ = 0;
-      int ☃x = 15;
-      int ☃xx = 0;
-
-      for (int ☃xxx = 0; ☃xxx < 16; ☃xxx++) {
-         for (int ☃xxxx = 0; ☃xxxx < 16; ☃xxxx++) {
-            for (int ☃xxxxx = 0; ☃xxxxx < 16; ☃xxxxx++) {
-               if (☃xxx == 0 || ☃xxx == 15 || ☃xxxx == 0 || ☃xxxx == 15 || ☃xxxxx == 0 || ☃xxxxx == 15) {
-                  INDEX_OF_EDGES[☃xx++] = getIndex(☃xxx, ☃xxxx, ☃xxxxx);
+      int i = 0;
+      int j = 15;
+      int k = 0;
+
+      for (int l = 0; l < 16; l++) {
+         for (int i1 = 0; i1 < 16; i1++) {
+            for (int j1 = 0; j1 < 16; j1++) {
+               if (l == 0 || l == 15 || i1 == 0 || i1 == 15 || j1 == 0 || j1 == 15) {
+                  INDEX_OF_EDGES[k++] = getIndex(l, i1, j1);
                }
             }
          }
diff --git a/patches/net/minecraft/client/renderer/culling/ClippingHelper.java b/patches/net/minecraft/client/renderer/culling/ClippingHelper.java
index 213a094..ad792a3 100644
--- a/patches/net/minecraft/client/renderer/culling/ClippingHelper.java
+++ b/patches/net/minecraft/client/renderer/culling/ClippingHelper.java
@@ -5,26 +5,86 @@ public class ClippingHelper {
    public float[] projectionMatrix = new float[16];
    public float[] modelviewMatrix = new float[16];
    public float[] clippingMatrix = new float[16];
+   public boolean disabled = false;
 
-   private double dot(float[] var1, double var2, double var4, double var6) {
-      return ☃[0] * ☃ + ☃[1] * ☃ + ☃[2] * ☃ + ☃[3];
+   private float dot(float[] p_178624_1_, float p_178624_2_, float p_178624_4_, float p_178624_6_) {
+      return p_178624_1_[0] * p_178624_2_ + p_178624_1_[1] * p_178624_4_ + p_178624_1_[2] * p_178624_6_ + p_178624_1_[3];
    }
 
-   public boolean isBoxInFrustum(double var1, double var3, double var5, double var7, double var9, double var11) {
-      for (int ☃ = 0; ☃ < 6; ☃++) {
-         float[] ☃x = this.frustum[☃];
-         if (!(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)
-            && !(this.dot(☃x, ☃, ☃, ☃) > 0.0)) {
-            return false;
+   public boolean isBoxInFrustum(double p_78553_1_, double p_78553_3_, double p_78553_5_, double p_78553_7_, double p_78553_9_, double p_78553_11_) {
+      if (this.disabled) {
+         return true;
+      } else {
+         float minXf = (float)p_78553_1_;
+         float minYf = (float)p_78553_3_;
+         float minZf = (float)p_78553_5_;
+         float maxXf = (float)p_78553_7_;
+         float maxYf = (float)p_78553_9_;
+         float maxZf = (float)p_78553_11_;
+
+         for (int var13 = 0; var13 < 6; var13++) {
+            float[] frustumi = this.frustum[var13];
+            float frustumi0 = frustumi[0];
+            float frustumi1 = frustumi[1];
+            float frustumi2 = frustumi[2];
+            float frustumi3 = frustumi[3];
+            if (frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F) {
+               return false;
+            }
          }
+
+         return true;
       }
+   }
+
+   public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
+      if (this.disabled) {
+         return true;
+      } else {
+         float minXf = (float)minX;
+         float minYf = (float)minY;
+         float minZf = (float)minZ;
+         float maxXf = (float)maxX;
+         float maxYf = (float)maxY;
+         float maxZf = (float)maxZ;
 
-      return true;
+         for (int i = 0; i < 6; i++) {
+            float[] frustumi = this.frustum[i];
+            float frustumi0 = frustumi[0];
+            float frustumi1 = frustumi[1];
+            float frustumi2 = frustumi[2];
+            float frustumi3 = frustumi[3];
+            if (i < 4) {
+               if (frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+                  || frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+                  || frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+                  || frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+                  || frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+                  || frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+                  || frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+                  || frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F) {
+                  return false;
+               }
+            } else if (frustumi0 * minXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * minZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * minYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * minXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F
+               && frustumi0 * maxXf + frustumi1 * maxYf + frustumi2 * maxZf + frustumi3 <= 0.0F) {
+               return false;
+            }
+         }
+
+         return true;
+      }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/culling/Frustum.java b/patches/net/minecraft/client/renderer/culling/Frustum.java
index 86c7a7a..6286cb7 100644
--- a/patches/net/minecraft/client/renderer/culling/Frustum.java
+++ b/patches/net/minecraft/client/renderer/culling/Frustum.java
@@ -12,23 +12,26 @@ public Frustum() {
       this(ClippingHelperImpl.getInstance());
    }
 
-   public Frustum(ClippingHelper var1) {
-      this.clippingHelper = ☃;
+   public Frustum(ClippingHelper clippingHelperIn) {
+      this.clippingHelper = clippingHelperIn;
    }
 
-   @Override
-   public void setPosition(double var1, double var3, double var5) {
-      this.x = ☃;
-      this.y = ☃;
-      this.z = ☃;
+   public void setPosition(double xIn, double yIn, double zIn) {
+      this.x = xIn;
+      this.y = yIn;
+      this.z = zIn;
    }
 
-   public boolean isBoxInFrustum(double var1, double var3, double var5, double var7, double var9, double var11) {
-      return this.clippingHelper.isBoxInFrustum(☃ - this.x, ☃ - this.y, ☃ - this.z, ☃ - this.x, ☃ - this.y, ☃ - this.z);
+   public boolean isBoxInFrustum(double p_78548_1_, double p_78548_3_, double p_78548_5_, double p_78548_7_, double p_78548_9_, double p_78548_11_) {
+      return this.clippingHelper
+         .isBoxInFrustum(p_78548_1_ - this.x, p_78548_3_ - this.y, p_78548_5_ - this.z, p_78548_7_ - this.x, p_78548_9_ - this.y, p_78548_11_ - this.z);
    }
 
-   @Override
-   public boolean isBoundingBoxInFrustum(AxisAlignedBB var1) {
-      return this.isBoxInFrustum(☃.minX, ☃.minY, ☃.minZ, ☃.maxX, ☃.maxY, ☃.maxZ);
+   public boolean isBoundingBoxInFrustum(AxisAlignedBB p_78546_1_) {
+      return this.isBoxInFrustum(p_78546_1_.minX, p_78546_1_.minY, p_78546_1_.minZ, p_78546_1_.maxX, p_78546_1_.maxY, p_78546_1_.maxZ);
+   }
+
+   public boolean isBoxInFrustumFully(double minX, double minY, double minZ, double maxX, double maxY, double maxZ) {
+      return this.clippingHelper.isBoxInFrustumFully(minX - this.x, minY - this.y, minZ - this.z, maxX - this.x, maxY - this.y, maxZ - this.z);
    }
 }
diff --git a/patches/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java b/patches/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java
index a63b4e0..cb9ebb1 100644
--- a/patches/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java
+++ b/patches/net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java
@@ -4,102 +4,112 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.client.renderer.debug.DebugRenderer.IDebugRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.player.EntityPlayer;
+import net.optifine.shaders.Shaders;
 
-public class DebugRendererChunkBorder implements DebugRenderer.IDebugRenderer {
+public class DebugRendererChunkBorder implements IDebugRenderer {
    private final Minecraft minecraft;
 
-   public DebugRendererChunkBorder(Minecraft var1) {
-      this.minecraft = ☃;
+   public DebugRendererChunkBorder(Minecraft minecraftIn) {
+      this.minecraft = minecraftIn;
    }
 
-   @Override
-   public void render(float var1, long var2) {
-      EntityPlayer ☃ = this.minecraft.player;
-      Tessellator ☃x = Tessellator.getInstance();
-      BufferBuilder ☃xx = ☃x.getBuffer();
-      double ☃xxx = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃xxxx = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xxxxx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      double ☃xxxxxx = 0.0 - ☃xxxx;
-      double ☃xxxxxxx = 256.0 - ☃xxxx;
-      GlStateManager.disableTexture2D();
-      GlStateManager.disableBlend();
-      double ☃xxxxxxxx = (☃.chunkCoordX << 4) - ☃xxx;
-      double ☃xxxxxxxxx = (☃.chunkCoordZ << 4) - ☃xxxxx;
-      GlStateManager.glLineWidth(1.0F);
-      ☃xx.begin(3, DefaultVertexFormats.POSITION_COLOR);
+   public void render(float partialTicks, long finishTimeNano) {
+      if (!Shaders.isShadowPass) {
+         if (Config.isShaders()) {
+            Shaders.beginLeash();
+         }
+
+         EntityPlayer entityplayer = this.minecraft.player;
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         double d0 = entityplayer.lastTickPosX + (entityplayer.posX - entityplayer.lastTickPosX) * partialTicks;
+         double d1 = entityplayer.lastTickPosY + (entityplayer.posY - entityplayer.lastTickPosY) * partialTicks;
+         double d2 = entityplayer.lastTickPosZ + (entityplayer.posZ - entityplayer.lastTickPosZ) * partialTicks;
+         double d3 = 0.0 - d1;
+         double d4 = 256.0 - d1;
+         GlStateManager.disableTexture2D();
+         GlStateManager.disableBlend();
+         double d5 = (entityplayer.chunkCoordX << 4) - d0;
+         double d6 = (entityplayer.chunkCoordZ << 4) - d2;
+         GlStateManager.glLineWidth(1.0F);
+         bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
 
-      for (int ☃xxxxxxxxxx = -16; ☃xxxxxxxxxx <= 32; ☃xxxxxxxxxx += 16) {
-         for (int ☃xxxxxxxxxxx = -16; ☃xxxxxxxxxxx <= 32; ☃xxxxxxxxxxx += 16) {
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+         for (int i = -16; i <= 32; i += 16) {
+            for (int j = -16; j <= 32; j += 16) {
+               bufferbuilder.pos(d5 + i, d3, d6 + j).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+               bufferbuilder.pos(d5 + i, d3, d6 + j).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
+               bufferbuilder.pos(d5 + i, d4, d6 + j).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
+               bufferbuilder.pos(d5 + i, d4, d6 + j).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+            }
          }
-      }
 
-      for (int ☃xxxxxxxxxx = 2; ☃xxxxxxxxxx < 16; ☃xxxxxxxxxx += 2) {
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         for (int k = 2; k < 16; k += 2) {
+            bufferbuilder.pos(d5 + k, d3, d6).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d3, d6).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d4, d6).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d4, d6).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d3, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d3, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d4, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + k, d4, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+         }
 
-      for (int ☃xxxxxxxxxx = 2; ☃xxxxxxxxxx < 16; ☃xxxxxxxxxx += 2) {
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         for (int l = 2; l < 16; l += 2) {
+            bufferbuilder.pos(d5, d3, d6 + l).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5, d3, d6 + l).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d4, d6 + l).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d4, d6 + l).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d3, d6 + l).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d3, d6 + l).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d4, d6 + l).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d4, d6 + l).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+         }
 
-      for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx <= 256; ☃xxxxxxxxxx += 2) {
-         double ☃xxxxxxxxxxx = ☃xxxxxxxxxx - ☃xxxx;
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxxxxxx, ☃xxxxxxxxx + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         for (int i1 = 0; i1 <= 256; i1 += 2) {
+            double d7 = i1 - d1;
+            bufferbuilder.pos(d5, d7, d6).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5, d7, d6).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d7, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d7, d6 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d7, d6).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d7, d6).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d7, d6).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+         }
 
-      ☃x.draw();
-      GlStateManager.glLineWidth(2.0F);
-      ☃xx.begin(3, DefaultVertexFormats.POSITION_COLOR);
+         tessellator.draw();
+         GlStateManager.glLineWidth(2.0F);
+         bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
 
-      for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx <= 16; ☃xxxxxxxxxx += 16) {
-         for (int ☃xxxxxxxxxxx = 0; ☃xxxxxxxxxxx <= 16; ☃xxxxxxxxxxx += 16) {
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-            ☃xx.pos(☃xxxxxxxx + ☃xxxxxxxxxx, ☃xxxxxxx, ☃xxxxxxxxx + ☃xxxxxxxxxxx).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+         for (int j1 = 0; j1 <= 16; j1 += 16) {
+            for (int l1 = 0; l1 <= 16; l1 += 16) {
+               bufferbuilder.pos(d5 + j1, d3, d6 + l1).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+               bufferbuilder.pos(d5 + j1, d3, d6 + l1).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+               bufferbuilder.pos(d5 + j1, d4, d6 + l1).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+               bufferbuilder.pos(d5 + j1, d4, d6 + l1).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+            }
          }
-      }
 
-      for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx <= 256; ☃xxxxxxxxxx += 16) {
-         double ☃xxxxxxxxxxx = ☃xxxxxxxxxx - ☃xxxx;
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxxxxxx, ☃xxxxxxxxx + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx + 16.0, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         ☃xx.pos(☃xxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxxxxxx).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-      }
+         for (int k1 = 0; k1 <= 256; k1 += 16) {
+            double d8 = k1 - d1;
+            bufferbuilder.pos(d5, d8, d6).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+            bufferbuilder.pos(d5, d8, d6).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d8, d6 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d8, d6 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5 + 16.0, d8, d6).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d8, d6).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            bufferbuilder.pos(d5, d8, d6).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+         }
 
-      ☃x.draw();
-      GlStateManager.glLineWidth(1.0F);
-      GlStateManager.enableBlend();
-      GlStateManager.enableTexture2D();
+         tessellator.draw();
+         GlStateManager.glLineWidth(1.0F);
+         GlStateManager.enableBlend();
+         GlStateManager.enableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.endLeash();
+         }
+      }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/Render.java b/patches/net/minecraft/client/renderer/entity/Render.java
index 86aaa88..7402503 100644
--- a/patches/net/minecraft/client/renderer/entity/Render.java
+++ b/patches/net/minecraft/client/renderer/entity/Render.java
@@ -16,180 +16,209 @@
 import net.minecraft.entity.EntityLiving;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.scoreboard.ScorePlayerTeam;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumBlockRenderType;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.World;
+import net.optifine.entity.model.IEntityRenderer;
+import net.optifine.shaders.Shaders;
 
-public abstract class Render<T extends Entity> {
+public abstract class Render<T extends Entity> implements IEntityRenderer {
    private static final ResourceLocation SHADOW_TEXTURES = new ResourceLocation("textures/misc/shadow.png");
    protected final RenderManager renderManager;
-   protected float shadowSize;
+   public float shadowSize;
    protected float shadowOpaque = 1.0F;
    protected boolean renderOutlines;
+   private Class entityClass = null;
+   private ResourceLocation locationTextureCustom = null;
 
-   protected Render(RenderManager var1) {
-      this.renderManager = ☃;
+   protected Render(RenderManager renderManager) {
+      this.renderManager = renderManager;
    }
 
-   public void setRenderOutlines(boolean var1) {
-      this.renderOutlines = ☃;
+   public void setRenderOutlines(boolean renderOutlinesIn) {
+      this.renderOutlines = renderOutlinesIn;
    }
 
-   public boolean shouldRender(T var1, ICamera var2, double var3, double var5, double var7) {
-      AxisAlignedBB ☃ = ☃.getRenderBoundingBox().grow(0.5);
-      if (☃.hasNaN() || ☃.getAverageEdgeLength() == 0.0) {
-         ☃ = new AxisAlignedBB(☃.posX - 2.0, ☃.posY - 2.0, ☃.posZ - 2.0, ☃.posX + 2.0, ☃.posY + 2.0, ☃.posZ + 2.0);
+   public boolean shouldRender(T livingEntity, ICamera camera, double camX, double camY, double camZ) {
+      AxisAlignedBB axisalignedbb = livingEntity.getRenderBoundingBox().grow(0.5);
+      if (axisalignedbb.hasNaN() || axisalignedbb.getAverageEdgeLength() == 0.0) {
+         axisalignedbb = new AxisAlignedBB(
+            livingEntity.posX - 2.0,
+            livingEntity.posY - 2.0,
+            livingEntity.posZ - 2.0,
+            livingEntity.posX + 2.0,
+            livingEntity.posY + 2.0,
+            livingEntity.posZ + 2.0
+         );
       }
 
-      return ☃.isInRangeToRender3d(☃, ☃, ☃) && (☃.ignoreFrustumCheck || ☃.isBoundingBoxInFrustum(☃));
+      return livingEntity.isInRangeToRender3d(camX, camY, camZ) && (livingEntity.ignoreFrustumCheck || camera.isBoundingBoxInFrustum(axisalignedbb));
    }
 
-   public void doRender(T var1, double var2, double var4, double var6, float var8, float var9) {
+   public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {
       if (!this.renderOutlines) {
-         this.renderName(☃, ☃, ☃, ☃);
+         this.renderName(entity, x, y, z);
       }
    }
 
-   protected int getTeamColor(T var1) {
-      int ☃ = 16777215;
-      ScorePlayerTeam ☃x = (ScorePlayerTeam)☃.getTeam();
-      if (☃x != null) {
-         String ☃xx = FontRenderer.getFormatFromString(☃x.getPrefix());
-         if (☃xx.length() >= 2) {
-            ☃ = this.getFontRendererFromRenderManager().getColorCode(☃xx.charAt(1));
+   protected int getTeamColor(T entityIn) {
+      int i = 16777215;
+      ScorePlayerTeam scoreplayerteam = (ScorePlayerTeam)entityIn.getTeam();
+      if (scoreplayerteam != null) {
+         String s = FontRenderer.getFormatFromString(scoreplayerteam.getPrefix());
+         if (s.length() >= 2) {
+            i = this.getFontRendererFromRenderManager().getColorCode(s.charAt(1));
          }
       }
 
-      return ☃;
+      return i;
    }
 
-   protected void renderName(T var1, double var2, double var4, double var6) {
-      if (this.canRenderName(☃)) {
-         this.renderLivingLabel(☃, ☃.getDisplayName().getFormattedText(), ☃, ☃, ☃, 64);
+   protected void renderName(T entity, double x, double y, double z) {
+      if (this.canRenderName(entity)) {
+         this.renderLivingLabel(entity, entity.getDisplayName().getFormattedText(), x, y, z, 64);
       }
    }
 
-   protected boolean canRenderName(T var1) {
-      return ☃.getAlwaysRenderNameTagForRender() && ☃.hasCustomName();
+   protected boolean canRenderName(T entity) {
+      return entity.getAlwaysRenderNameTagForRender() && entity.hasCustomName();
    }
 
-   protected void renderEntityName(T var1, double var2, double var4, double var6, String var8, double var9) {
-      this.renderLivingLabel(☃, ☃, ☃, ☃, ☃, 64);
+   protected void renderEntityName(T entityIn, double x, double y, double z, String name, double distanceSq) {
+      this.renderLivingLabel(entityIn, name, x, y, z, 64);
    }
 
    @Nullable
    protected abstract ResourceLocation getEntityTexture(T var1);
 
-   protected boolean bindEntityTexture(T var1) {
-      ResourceLocation ☃ = this.getEntityTexture(☃);
-      if (☃ == null) {
+   protected boolean bindEntityTexture(T entity) {
+      ResourceLocation resourcelocation = this.getEntityTexture(entity);
+      if (this.locationTextureCustom != null) {
+         resourcelocation = this.locationTextureCustom;
+      }
+
+      if (resourcelocation == null) {
          return false;
       } else {
-         this.bindTexture(☃);
+         this.bindTexture(resourcelocation);
          return true;
       }
    }
 
-   public void bindTexture(ResourceLocation var1) {
-      this.renderManager.renderEngine.bindTexture(☃);
+   public void bindTexture(ResourceLocation location) {
+      this.renderManager.renderEngine.bindTexture(location);
    }
 
-   private void renderEntityOnFire(Entity var1, double var2, double var4, double var6, float var8) {
+   private void renderEntityOnFire(Entity entity, double x, double y, double z, float partialTicks) {
       GlStateManager.disableLighting();
-      TextureMap ☃ = Minecraft.getMinecraft().getTextureMapBlocks();
-      TextureAtlasSprite ☃x = ☃.getAtlasSprite("minecraft:blocks/fire_layer_0");
-      TextureAtlasSprite ☃xx = ☃.getAtlasSprite("minecraft:blocks/fire_layer_1");
+      TextureMap texturemap = Minecraft.getMinecraft().getTextureMapBlocks();
+      TextureAtlasSprite textureatlassprite = texturemap.getAtlasSprite("minecraft:blocks/fire_layer_0");
+      TextureAtlasSprite textureatlassprite1 = texturemap.getAtlasSprite("minecraft:blocks/fire_layer_1");
       GlStateManager.pushMatrix();
-      GlStateManager.translate((float)☃, (float)☃, (float)☃);
-      float ☃xxx = ☃.width * 1.4F;
-      GlStateManager.scale(☃xxx, ☃xxx, ☃xxx);
-      Tessellator ☃xxxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxxx = ☃xxxx.getBuffer();
-      float ☃xxxxxx = 0.5F;
-      float ☃xxxxxxx = 0.0F;
-      float ☃xxxxxxxx = ☃.height / ☃xxx;
-      float ☃xxxxxxxxx = (float)(☃.posY - ☃.getEntityBoundingBox().minY);
+      GlStateManager.translate((float)x, (float)y, (float)z);
+      float f = entity.width * 1.4F;
+      GlStateManager.scale(f, f, f);
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      float f1 = 0.5F;
+      float f2 = 0.0F;
+      float f3 = entity.height / f;
+      float f4 = (float)(entity.posY - entity.getEntityBoundingBox().minY);
       GlStateManager.rotate(-this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
-      GlStateManager.translate(0.0F, 0.0F, -0.3F + (int)☃xxxxxxxx * 0.02F);
+      GlStateManager.translate(0.0F, 0.0F, -0.3F + (int)f3 * 0.02F);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      float ☃xxxxxxxxxx = 0.0F;
-      int ☃xxxxxxxxxxx = 0;
-      ☃xxxxx.begin(7, DefaultVertexFormats.POSITION_TEX);
+      float f5 = 0.0F;
+      int i = 0;
+      boolean multitexture = Config.isMultiTexture();
+      if (multitexture) {
+         bufferbuilder.setBlockLayer(BlockRenderLayer.SOLID);
+      }
 
-      while (☃xxxxxxxx > 0.0F) {
-         TextureAtlasSprite ☃xxxxxxxxxxxx = ☃xxxxxxxxxxx % 2 == 0 ? ☃x : ☃xx;
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX);
+
+      while (f3 > 0.0F) {
+         TextureAtlasSprite textureatlassprite2 = i % 2 == 0 ? textureatlassprite : textureatlassprite1;
+         bufferbuilder.setSprite(textureatlassprite2);
          this.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-         float ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxxx.getMinU();
-         float ☃xxxxxxxxxxxxxx = ☃xxxxxxxxxxxx.getMinV();
-         float ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx.getMaxU();
-         float ☃xxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx.getMaxV();
-         if (☃xxxxxxxxxxx / 2 % 2 == 0) {
-            float ☃xxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxx;
-            ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx;
-            ☃xxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx;
+         float f6 = textureatlassprite2.getMinU();
+         float f7 = textureatlassprite2.getMinV();
+         float f8 = textureatlassprite2.getMaxU();
+         float f9 = textureatlassprite2.getMaxV();
+         if (i / 2 % 2 == 0) {
+            float f10 = f8;
+            f8 = f6;
+            f6 = f10;
          }
 
-         ☃xxxxx.pos(☃xxxxxx - 0.0F, 0.0F - ☃xxxxxxxxx, ☃xxxxxxxxxx).tex(☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(-☃xxxxxx - 0.0F, 0.0F - ☃xxxxxxxxx, ☃xxxxxxxxxx).tex(☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(-☃xxxxxx - 0.0F, 1.4F - ☃xxxxxxxxx, ☃xxxxxxxxxx).tex(☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx).endVertex();
-         ☃xxxxx.pos(☃xxxxxx - 0.0F, 1.4F - ☃xxxxxxxxx, ☃xxxxxxxxxx).tex(☃xxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxx).endVertex();
-         ☃xxxxxxxx -= 0.45F;
-         ☃xxxxxxxxx -= 0.45F;
-         ☃xxxxxx *= 0.9F;
-         ☃xxxxxxxxxx += 0.03F;
-         ☃xxxxxxxxxxx++;
+         bufferbuilder.pos(f1 - 0.0F, 0.0F - f4, f5).tex(f8, f9).endVertex();
+         bufferbuilder.pos(-f1 - 0.0F, 0.0F - f4, f5).tex(f6, f9).endVertex();
+         bufferbuilder.pos(-f1 - 0.0F, 1.4F - f4, f5).tex(f6, f7).endVertex();
+         bufferbuilder.pos(f1 - 0.0F, 1.4F - f4, f5).tex(f8, f7).endVertex();
+         f3 -= 0.45F;
+         f4 -= 0.45F;
+         f1 *= 0.9F;
+         f5 += 0.03F;
+         i++;
+      }
+
+      tessellator.draw();
+      if (multitexture) {
+         bufferbuilder.setBlockLayer(null);
+         GlStateManager.bindCurrentTexture();
       }
 
-      ☃xxxx.draw();
       GlStateManager.popMatrix();
       GlStateManager.enableLighting();
    }
 
-   private void renderShadow(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.enableBlend();
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
-      this.renderManager.renderEngine.bindTexture(SHADOW_TEXTURES);
-      World ☃ = this.getWorldFromRenderManager();
-      GlStateManager.depthMask(false);
-      float ☃x = this.shadowSize;
-      if (☃ instanceof EntityLiving) {
-         EntityLiving ☃xx = (EntityLiving)☃;
-         ☃x *= ☃xx.getRenderSizeModifier();
-         if (☃xx.isChild()) {
-            ☃x *= 0.5F;
+   private void renderShadow(Entity entityIn, double x, double y, double z, float shadowAlpha, float partialTicks) {
+      if (!Config.isShaders() || !Shaders.shouldSkipDefaultShadow) {
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+         this.renderManager.renderEngine.bindTexture(SHADOW_TEXTURES);
+         World world = this.getWorldFromRenderManager();
+         GlStateManager.depthMask(false);
+         float f = this.shadowSize;
+         if (entityIn instanceof EntityLiving) {
+            EntityLiving entityliving = (EntityLiving)entityIn;
+            f *= entityliving.getRenderSizeModifier();
+            if (entityliving.isChild()) {
+               f *= 0.5F;
+            }
          }
-      }
 
-      double ☃xx = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃xxx = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xxxx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      int ☃xxxxx = MathHelper.floor(☃xx - ☃x);
-      int ☃xxxxxx = MathHelper.floor(☃xx + ☃x);
-      int ☃xxxxxxx = MathHelper.floor(☃xxx - ☃x);
-      int ☃xxxxxxxx = MathHelper.floor(☃xxx);
-      int ☃xxxxxxxxx = MathHelper.floor(☃xxxx - ☃x);
-      int ☃xxxxxxxxxx = MathHelper.floor(☃xxxx + ☃x);
-      double ☃xxxxxxxxxxx = ☃ - ☃xx;
-      double ☃xxxxxxxxxxxx = ☃ - ☃xxx;
-      double ☃xxxxxxxxxxxxx = ☃ - ☃xxxx;
-      Tessellator ☃xxxxxxxxxxxxxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxx.getBuffer();
-      ☃xxxxxxxxxxxxxxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-
-      for (BlockPos ☃xxxxxxxxxxxxxxxx : BlockPos.getAllInBoxMutable(new BlockPos(☃xxxxx, ☃xxxxxxx, ☃xxxxxxxxx), new BlockPos(☃xxxxxx, ☃xxxxxxxx, ☃xxxxxxxxxx))) {
-         IBlockState ☃xxxxxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxxxxxxxx.down());
-         if (☃xxxxxxxxxxxxxxxxx.getRenderType() != EnumBlockRenderType.INVISIBLE && ☃.getLightFromNeighbors(☃xxxxxxxxxxxxxxxx) > 3) {
-            this.renderShadowSingle(☃xxxxxxxxxxxxxxxxx, ☃, ☃, ☃, ☃xxxxxxxxxxxxxxxx, ☃, ☃x, ☃xxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxx);
+         double d5 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;
+         double d0 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;
+         double d1 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;
+         int i = MathHelper.floor(d5 - f);
+         int j = MathHelper.floor(d5 + f);
+         int k = MathHelper.floor(d0 - f);
+         int l = MathHelper.floor(d0);
+         int i1 = MathHelper.floor(d1 - f);
+         int j1 = MathHelper.floor(d1 + f);
+         double d2 = x - d5;
+         double d3 = y - d0;
+         double d4 = z - d1;
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+
+         for (BlockPos blockpos : BlockPos.getAllInBoxMutable(new BlockPos(i, k, i1), new BlockPos(j, l, j1))) {
+            IBlockState iblockstate = world.getBlockState(blockpos.down());
+            if (iblockstate.i() != EnumBlockRenderType.INVISIBLE && world.getLightFromNeighbors(blockpos) > 3) {
+               this.renderShadowSingle(iblockstate, x, y, z, blockpos, shadowAlpha, f, d2, d3, d4);
+            }
          }
-      }
 
-      ☃xxxxxxxxxxxxxx.draw();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.disableBlend();
-      GlStateManager.depthMask(true);
+         tessellator.draw();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.disableBlend();
+         GlStateManager.depthMask(true);
+      }
    }
 
    private World getWorldFromRenderManager() {
@@ -197,83 +226,94 @@ private World getWorldFromRenderManager() {
    }
 
    private void renderShadowSingle(
-      IBlockState var1, double var2, double var4, double var6, BlockPos var8, float var9, float var10, double var11, double var13, double var15
+      IBlockState state,
+      double p_188299_2_,
+      double p_188299_4_,
+      double p_188299_6_,
+      BlockPos p_188299_8_,
+      float p_188299_9_,
+      float p_188299_10_,
+      double p_188299_11_,
+      double p_188299_13_,
+      double p_188299_15_
    ) {
-      if (☃.isFullCube()) {
-         Tessellator ☃ = Tessellator.getInstance();
-         BufferBuilder ☃x = ☃.getBuffer();
-         double ☃xx = (☃ - (☃ - (☃.getY() + ☃)) / 2.0) * 0.5 * this.getWorldFromRenderManager().getLightBrightness(☃);
-         if (!(☃xx < 0.0)) {
-            if (☃xx > 1.0) {
-               ☃xx = 1.0;
+      if (state.g()) {
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         double d0 = (p_188299_9_ - (p_188299_4_ - (p_188299_8_.getY() + p_188299_13_)) / 2.0)
+            * 0.5
+            * this.getWorldFromRenderManager().getLightBrightness(p_188299_8_);
+         if (d0 >= 0.0) {
+            if (d0 > 1.0) {
+               d0 = 1.0;
             }
 
-            AxisAlignedBB ☃xxx = ☃.getBoundingBox(this.getWorldFromRenderManager(), ☃);
-            double ☃xxxx = ☃.getX() + ☃xxx.minX + ☃;
-            double ☃xxxxx = ☃.getX() + ☃xxx.maxX + ☃;
-            double ☃xxxxxx = ☃.getY() + ☃xxx.minY + ☃ + 0.015625;
-            double ☃xxxxxxx = ☃.getZ() + ☃xxx.minZ + ☃;
-            double ☃xxxxxxxx = ☃.getZ() + ☃xxx.maxZ + ☃;
-            float ☃xxxxxxxxx = (float)((☃ - ☃xxxx) / 2.0 / ☃ + 0.5);
-            float ☃xxxxxxxxxx = (float)((☃ - ☃xxxxx) / 2.0 / ☃ + 0.5);
-            float ☃xxxxxxxxxxx = (float)((☃ - ☃xxxxxxx) / 2.0 / ☃ + 0.5);
-            float ☃xxxxxxxxxxxx = (float)((☃ - ☃xxxxxxxx) / 2.0 / ☃ + 0.5);
-            ☃x.pos(☃xxxx, ☃xxxxxx, ☃xxxxxxx).tex(☃xxxxxxxxx, ☃xxxxxxxxxxx).color(1.0F, 1.0F, 1.0F, (float)☃xx).endVertex();
-            ☃x.pos(☃xxxx, ☃xxxxxx, ☃xxxxxxxx).tex(☃xxxxxxxxx, ☃xxxxxxxxxxxx).color(1.0F, 1.0F, 1.0F, (float)☃xx).endVertex();
-            ☃x.pos(☃xxxxx, ☃xxxxxx, ☃xxxxxxxx).tex(☃xxxxxxxxxx, ☃xxxxxxxxxxxx).color(1.0F, 1.0F, 1.0F, (float)☃xx).endVertex();
-            ☃x.pos(☃xxxxx, ☃xxxxxx, ☃xxxxxxx).tex(☃xxxxxxxxxx, ☃xxxxxxxxxxx).color(1.0F, 1.0F, 1.0F, (float)☃xx).endVertex();
+            AxisAlignedBB axisalignedbb = state.e(this.getWorldFromRenderManager(), p_188299_8_);
+            double d1 = p_188299_8_.getX() + axisalignedbb.minX + p_188299_11_;
+            double d2 = p_188299_8_.getX() + axisalignedbb.maxX + p_188299_11_;
+            double d3 = p_188299_8_.getY() + axisalignedbb.minY + p_188299_13_ + 0.015625;
+            double d4 = p_188299_8_.getZ() + axisalignedbb.minZ + p_188299_15_;
+            double d5 = p_188299_8_.getZ() + axisalignedbb.maxZ + p_188299_15_;
+            float f = (float)((p_188299_2_ - d1) / 2.0 / p_188299_10_ + 0.5);
+            float f1 = (float)((p_188299_2_ - d2) / 2.0 / p_188299_10_ + 0.5);
+            float f2 = (float)((p_188299_6_ - d4) / 2.0 / p_188299_10_ + 0.5);
+            float f3 = (float)((p_188299_6_ - d5) / 2.0 / p_188299_10_ + 0.5);
+            bufferbuilder.pos(d1, d3, d4).tex(f, f2).color(1.0F, 1.0F, 1.0F, (float)d0).endVertex();
+            bufferbuilder.pos(d1, d3, d5).tex(f, f3).color(1.0F, 1.0F, 1.0F, (float)d0).endVertex();
+            bufferbuilder.pos(d2, d3, d5).tex(f1, f3).color(1.0F, 1.0F, 1.0F, (float)d0).endVertex();
+            bufferbuilder.pos(d2, d3, d4).tex(f1, f2).color(1.0F, 1.0F, 1.0F, (float)d0).endVertex();
          }
       }
    }
 
-   public static void renderOffsetAABB(AxisAlignedBB var0, double var1, double var3, double var5) {
+   public static void renderOffsetAABB(AxisAlignedBB boundingBox, double x, double y, double z) {
       GlStateManager.disableTexture2D();
-      Tessellator ☃ = Tessellator.getInstance();
-      BufferBuilder ☃x = ☃.getBuffer();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      ☃x.setTranslation(☃, ☃, ☃);
-      ☃x.begin(7, DefaultVertexFormats.POSITION_NORMAL);
-      ☃x.pos(☃.minX, ☃.maxY, ☃.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.maxY, ☃.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.minZ).normal(0.0F, -1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.minZ).normal(0.0F, -1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.maxZ).normal(0.0F, -1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.maxZ).normal(0.0F, -1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.maxY, ☃.maxZ).normal(0.0F, 1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.maxZ).normal(0.0F, 1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.minZ).normal(0.0F, 1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.maxY, ☃.minZ).normal(0.0F, 1.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.maxZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.maxY, ☃.maxZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.maxY, ☃.minZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.minX, ☃.minY, ☃.minZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.minZ).normal(1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.minZ).normal(1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.maxY, ☃.maxZ).normal(1.0F, 0.0F, 0.0F).endVertex();
-      ☃x.pos(☃.maxX, ☃.minY, ☃.maxZ).normal(1.0F, 0.0F, 0.0F).endVertex();
-      ☃.draw();
-      ☃x.setTranslation(0.0, 0.0, 0.0);
+      bufferbuilder.setTranslation(x, y, z);
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_NORMAL);
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(0.0F, 0.0F, -1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(0.0F, 0.0F, 1.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(0.0F, -1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(0.0F, -1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(0.0F, -1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(0.0F, -1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(0.0F, 1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(0.0F, 1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(0.0F, 1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(0.0F, 1.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).normal(-1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).normal(1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).normal(1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).normal(1.0F, 0.0F, 0.0F).endVertex();
+      bufferbuilder.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).normal(1.0F, 0.0F, 0.0F).endVertex();
+      tessellator.draw();
+      bufferbuilder.setTranslation(0.0, 0.0, 0.0);
       GlStateManager.enableTexture2D();
    }
 
-   public void doRenderShadowAndFire(Entity var1, double var2, double var4, double var6, float var8, float var9) {
+   public void doRenderShadowAndFire(Entity entityIn, double x, double y, double z, float yaw, float partialTicks) {
       if (this.renderManager.options != null) {
-         if (this.renderManager.options.entityShadows && this.shadowSize > 0.0F && !☃.isInvisible() && this.renderManager.isRenderShadow()) {
-            double ☃ = this.renderManager.getDistanceToCamera(☃.posX, ☃.posY, ☃.posZ);
-            float ☃x = (float)((1.0 - ☃ / 256.0) * this.shadowOpaque);
-            if (☃x > 0.0F) {
-               this.renderShadow(☃, ☃, ☃, ☃, ☃x, ☃);
+         if (this.renderManager.options.entityShadows && this.shadowSize > 0.0F && !entityIn.isInvisible() && this.renderManager.isRenderShadow()) {
+            double d0 = this.renderManager.getDistanceToCamera(entityIn.posX, entityIn.posY, entityIn.posZ);
+            float f = (float)((1.0 - d0 / 256.0) * this.shadowOpaque);
+            if (f > 0.0F) {
+               this.renderShadow(entityIn, x, y, z, f, partialTicks);
             }
          }
 
-         if (☃.canRenderOnFire() && (!(☃ instanceof EntityPlayer) || !((EntityPlayer)☃).isSpectator())) {
-            this.renderEntityOnFire(☃, ☃, ☃, ☃, ☃);
+         if (entityIn.canRenderOnFire() && (!(entityIn instanceof EntityPlayer) || !((EntityPlayer)entityIn).isSpectator())) {
+            this.renderEntityOnFire(entityIn, x, y, z, partialTicks);
          }
       }
    }
@@ -282,16 +322,16 @@ public FontRenderer getFontRendererFromRenderManager() {
       return this.renderManager.getFontRenderer();
    }
 
-   protected void renderLivingLabel(T var1, String var2, double var3, double var5, double var7, int var9) {
-      double ☃ = ☃.getDistanceSq(this.renderManager.renderViewEntity);
-      if (!(☃ > ☃ * ☃)) {
-         boolean ☃x = ☃.isSneaking();
-         float ☃xx = this.renderManager.playerViewY;
-         float ☃xxx = this.renderManager.playerViewX;
-         boolean ☃xxxx = this.renderManager.options.thirdPersonView == 2;
-         float ☃xxxxx = ☃.height + 0.5F - (☃x ? 0.25F : 0.0F);
-         int ☃xxxxxx = "deadmau5".equals(☃) ? -10 : 0;
-         EntityRenderer.drawNameplate(this.getFontRendererFromRenderManager(), ☃, (float)☃, (float)☃ + ☃xxxxx, (float)☃, ☃xxxxxx, ☃xx, ☃xxx, ☃xxxx, ☃x);
+   protected void renderLivingLabel(T entityIn, String str, double x, double y, double z, int maxDistance) {
+      double d0 = entityIn.getDistanceSq(this.renderManager.renderViewEntity);
+      if (d0 <= maxDistance * maxDistance) {
+         boolean flag = entityIn.isSneaking();
+         float f = this.renderManager.playerViewY;
+         float f1 = this.renderManager.playerViewX;
+         boolean flag1 = this.renderManager.options.thirdPersonView == 2;
+         float f2 = entityIn.height + 0.5F - (flag ? 0.25F : 0.0F);
+         int i = "deadmau5".equals(str) ? -10 : 0;
+         EntityRenderer.drawNameplate(this.getFontRendererFromRenderManager(), str, (float)x, (float)y + f2, (float)z, i, f, f1, flag1, flag);
       }
    }
 
@@ -303,6 +343,22 @@ public boolean isMultipass() {
       return false;
    }
 
-   public void renderMultipass(T var1, double var2, double var4, double var6, float var8, float var9) {
+   public void renderMultipass(T p_188300_1_, double p_188300_2_, double p_188300_4_, double p_188300_6_, float p_188300_8_, float p_188300_9_) {
+   }
+
+   public Class getEntityClass() {
+      return this.entityClass;
+   }
+
+   public void setEntityClass(Class entityClass) {
+      this.entityClass = entityClass;
+   }
+
+   public ResourceLocation getLocationTextureCustom() {
+      return this.locationTextureCustom;
+   }
+
+   public void setLocationTextureCustom(ResourceLocation locationTextureCustom) {
+      this.locationTextureCustom = locationTextureCustom;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/RenderItemFrame.java b/patches/net/minecraft/client/renderer/entity/RenderItemFrame.java
index f21abc1..4017a2b 100644
--- a/patches/net/minecraft/client/renderer/entity/RenderItemFrame.java
+++ b/patches/net/minecraft/client/renderer/entity/RenderItemFrame.java
@@ -7,16 +7,21 @@
 import net.minecraft.client.renderer.RenderHelper;
 import net.minecraft.client.renderer.RenderItem;
 import net.minecraft.client.renderer.block.model.IBakedModel;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.block.model.ModelManager;
 import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.item.EntityItemFrame;
 import net.minecraft.init.Items;
+import net.minecraft.item.ItemMap;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.storage.MapData;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
 
 public class RenderItemFrame extends Render<EntityItemFrame> {
    private static final ResourceLocation MAP_BACKGROUND_TEXTURES = new ResourceLocation("textures/map/map_background.png");
@@ -24,38 +29,39 @@ public class RenderItemFrame extends Render<EntityItemFrame> {
    private final ModelResourceLocation itemFrameModel = new ModelResourceLocation("item_frame", "normal");
    private final ModelResourceLocation mapModel = new ModelResourceLocation("item_frame", "map");
    private final RenderItem itemRenderer;
+   private static double itemRenderDistanceSq = 4096.0;
 
-   public RenderItemFrame(RenderManager var1, RenderItem var2) {
-      super(☃);
-      this.itemRenderer = ☃;
+   public RenderItemFrame(RenderManager renderManagerIn, RenderItem itemRendererIn) {
+      super(renderManagerIn);
+      this.itemRenderer = itemRendererIn;
    }
 
-   public void doRender(EntityItemFrame var1, double var2, double var4, double var6, float var8, float var9) {
+   public void doRender(EntityItemFrame entity, double x, double y, double z, float entityYaw, float partialTicks) {
       GlStateManager.pushMatrix();
-      BlockPos ☃ = ☃.getHangingPosition();
-      double ☃x = ☃.getX() - ☃.posX + ☃;
-      double ☃xx = ☃.getY() - ☃.posY + ☃;
-      double ☃xxx = ☃.getZ() - ☃.posZ + ☃;
-      GlStateManager.translate(☃x + 0.5, ☃xx + 0.5, ☃xxx + 0.5);
-      GlStateManager.rotate(180.0F - ☃.rotationYaw, 0.0F, 1.0F, 0.0F);
+      BlockPos blockpos = entity.q();
+      double d0 = blockpos.getX() - entity.posX + x;
+      double d1 = blockpos.getY() - entity.posY + y;
+      double d2 = blockpos.getZ() - entity.posZ + z;
+      GlStateManager.translate(d0 + 0.5, d1 + 0.5, d2 + 0.5);
+      GlStateManager.rotate(180.0F - entity.rotationYaw, 0.0F, 1.0F, 0.0F);
       this.renderManager.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-      BlockRendererDispatcher ☃xxxx = this.mc.getBlockRendererDispatcher();
-      ModelManager ☃xxxxx = ☃xxxx.getBlockModelShapes().getModelManager();
-      IBakedModel ☃xxxxxx;
-      if (☃.getDisplayedItem().getItem() == Items.FILLED_MAP) {
-         ☃xxxxxx = ☃xxxxx.getModel(this.mapModel);
+      BlockRendererDispatcher blockrendererdispatcher = this.mc.getBlockRendererDispatcher();
+      ModelManager modelmanager = blockrendererdispatcher.getBlockModelShapes().getModelManager();
+      IBakedModel ibakedmodel;
+      if (entity.getDisplayedItem().getItem() instanceof ItemMap) {
+         ibakedmodel = modelmanager.getModel(this.mapModel);
       } else {
-         ☃xxxxxx = ☃xxxxx.getModel(this.itemFrameModel);
+         ibakedmodel = modelmanager.getModel(this.itemFrameModel);
       }
 
       GlStateManager.pushMatrix();
       GlStateManager.translate(-0.5F, -0.5F, -0.5F);
       if (this.renderOutlines) {
          GlStateManager.enableColorMaterial();
-         GlStateManager.enableOutlineMode(this.getTeamColor(☃));
+         GlStateManager.enableOutlineMode(this.getTeamColor(entity));
       }
 
-      ☃xxxx.getBlockModelRenderer().renderModelBrightnessColor(☃xxxxxx, 1.0F, 1.0F, 1.0F, 1.0F);
+      blockrendererdispatcher.getBlockModelRenderer().renderModelBrightnessColor(ibakedmodel, 1.0F, 1.0F, 1.0F, 1.0F);
       if (this.renderOutlines) {
          GlStateManager.disableOutlineMode();
          GlStateManager.disableColorMaterial();
@@ -63,42 +69,56 @@ public void doRender(EntityItemFrame var1, double var2, double var4, double var6
 
       GlStateManager.popMatrix();
       GlStateManager.translate(0.0F, 0.0F, 0.4375F);
-      this.renderItem(☃);
+      this.renderItem(entity);
       GlStateManager.popMatrix();
-      this.renderName(☃, ☃ + ☃.facingDirection.getXOffset() * 0.3F, ☃ - 0.25, ☃ + ☃.facingDirection.getZOffset() * 0.3F);
+      this.renderName(entity, x + entity.EMPTY_EQUIPMENT.getXOffset() * 0.3F, y - 0.25, z + entity.EMPTY_EQUIPMENT.getZOffset() * 0.3F);
    }
 
    @Nullable
-   protected ResourceLocation getEntityTexture(EntityItemFrame var1) {
+   protected ResourceLocation getEntityTexture(EntityItemFrame entity) {
       return null;
    }
 
-   private void renderItem(EntityItemFrame var1) {
-      ItemStack ☃ = ☃.getDisplayedItem();
-      if (!☃.isEmpty()) {
+   private void renderItem(EntityItemFrame itemFrame) {
+      ItemStack itemstack = itemFrame.getDisplayedItem();
+      if (!itemstack.isEmpty()) {
+         if (!this.isRenderItem(itemFrame)) {
+            return;
+         }
+
+         if (!Config.zoomMode) {
+            Entity player = this.mc.player;
+            double distSq = itemFrame.getDistanceSq(player.posX, player.posY, player.posZ);
+            if (distSq > 4096.0) {
+               return;
+            }
+         }
+
          GlStateManager.pushMatrix();
          GlStateManager.disableLighting();
-         boolean ☃x = ☃.getItem() == Items.FILLED_MAP;
-         int ☃xx = ☃x ? ☃.getRotation() % 4 * 2 : ☃.getRotation();
-         GlStateManager.rotate(☃xx * 360.0F / 8.0F, 0.0F, 0.0F, 1.0F);
-         if (☃x) {
-            this.renderManager.renderEngine.bindTexture(MAP_BACKGROUND_TEXTURES);
-            GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
-            float ☃xxx = 0.0078125F;
-            GlStateManager.scale(0.0078125F, 0.0078125F, 0.0078125F);
-            GlStateManager.translate(-64.0F, -64.0F, 0.0F);
-            MapData ☃xxxx = Items.FILLED_MAP.getMapData(☃, ☃.world);
-            GlStateManager.translate(0.0F, 0.0F, -1.0F);
-            if (☃xxxx != null) {
-               this.mc.entityRenderer.getMapItemRenderer().renderMap(☃xxxx, true);
+         boolean flag = itemstack.getItem() instanceof ItemMap;
+         int i = flag ? itemFrame.getRotation() % 4 * 2 : itemFrame.getRotation();
+         GlStateManager.rotate(i * 360.0F / 8.0F, 0.0F, 0.0F, 1.0F);
+         if (!Reflector.postForgeBusEvent(Reflector.RenderItemInFrameEvent_Constructor, new Object[]{itemFrame, this})) {
+            if (flag) {
+               this.renderManager.renderEngine.bindTexture(MAP_BACKGROUND_TEXTURES);
+               GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
+               float f = 0.0078125F;
+               GlStateManager.scale(0.0078125F, 0.0078125F, 0.0078125F);
+               GlStateManager.translate(-64.0F, -64.0F, 0.0F);
+               MapData mapdata = ReflectorForge.getMapData(Items.FILLED_MAP, itemstack, itemFrame.world);
+               GlStateManager.translate(0.0F, 0.0F, -1.0F);
+               if (mapdata != null) {
+                  this.mc.entityRenderer.getMapItemRenderer().renderMap(mapdata, true);
+               }
+            } else {
+               GlStateManager.scale(0.5F, 0.5F, 0.5F);
+               GlStateManager.pushAttrib();
+               RenderHelper.enableStandardItemLighting();
+               this.itemRenderer.renderItem(itemstack, TransformType.FIXED);
+               RenderHelper.disableStandardItemLighting();
+               GlStateManager.popAttrib();
             }
-         } else {
-            GlStateManager.scale(0.5F, 0.5F, 0.5F);
-            GlStateManager.pushAttrib();
-            RenderHelper.enableStandardItemLighting();
-            this.itemRenderer.renderItem(☃, ItemCameraTransforms.TransformType.FIXED);
-            RenderHelper.disableStandardItemLighting();
-            GlStateManager.popAttrib();
          }
 
          GlStateManager.enableLighting();
@@ -106,14 +126,40 @@ private void renderItem(EntityItemFrame var1) {
       }
    }
 
-   protected void renderName(EntityItemFrame var1, double var2, double var4, double var6) {
-      if (Minecraft.isGuiEnabled() && !☃.getDisplayedItem().isEmpty() && ☃.getDisplayedItem().hasDisplayName() && this.renderManager.pointedEntity == ☃) {
-         double ☃ = ☃.getDistanceSq(this.renderManager.renderViewEntity);
-         float ☃x = ☃.isSneaking() ? 32.0F : 64.0F;
-         if (!(☃ >= ☃x * ☃x)) {
-            String ☃xx = ☃.getDisplayedItem().getDisplayName();
-            this.renderLivingLabel(☃, ☃xx, ☃, ☃, ☃, 64);
+   protected void renderName(EntityItemFrame entity, double x, double y, double z) {
+      if (Minecraft.isGuiEnabled()
+         && !entity.getDisplayedItem().isEmpty()
+         && entity.getDisplayedItem().hasDisplayName()
+         && this.renderManager.pointedEntity == entity) {
+         double d0 = entity.getDistanceSq(this.renderManager.renderViewEntity);
+         float f = entity.isSneaking() ? 32.0F : 64.0F;
+         if (d0 < f * f) {
+            String s = entity.getDisplayedItem().getDisplayName();
+            this.renderLivingLabel(entity, s, x, y, z, 64);
+         }
+      }
+   }
+
+   private boolean isRenderItem(EntityItemFrame itemFrame) {
+      if (Shaders.isShadowPass) {
+         return false;
+      } else {
+         if (!Config.zoomMode) {
+            Entity viewEntity = this.mc.getRenderViewEntity();
+            double distSq = itemFrame.getDistanceSq(viewEntity.posX, viewEntity.posY, viewEntity.posZ);
+            if (distSq > itemRenderDistanceSq) {
+               return false;
+            }
          }
+
+         return true;
       }
    }
+
+   public static void updateItemRenderDistance() {
+      Minecraft mc = Config.getMinecraft();
+      double fov = Config.limit(mc.gameSettings.fovSetting, 1.0F, 120.0F);
+      double itemRenderDistance = Math.max(6.0 * mc.displayHeight / fov, 16.0);
+      itemRenderDistanceSq = itemRenderDistance * itemRenderDistance;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/RenderLiving.java b/patches/net/minecraft/client/renderer/entity/RenderLiving.java
index 5d7967a..02df6f7 100644
--- a/patches/net/minecraft/client/renderer/entity/RenderLiving.java
+++ b/patches/net/minecraft/client/renderer/entity/RenderLiving.java
@@ -10,155 +10,143 @@
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityHanging;
 import net.minecraft.entity.EntityLiving;
+import net.optifine.shaders.Shaders;
 
 public abstract class RenderLiving<T extends EntityLiving> extends RenderLivingBase<T> {
-   public RenderLiving(RenderManager var1, ModelBase var2, float var3) {
-      super(☃, ☃, ☃);
+   public RenderLiving(RenderManager rendermanagerIn, ModelBase modelbaseIn, float shadowsizeIn) {
+      super(rendermanagerIn, modelbaseIn, shadowsizeIn);
    }
 
-   protected boolean canRenderName(T var1) {
-      return super.canRenderName(☃) && (☃.getAlwaysRenderNameTagForRender() || ☃.hasCustomName() && ☃ == this.renderManager.pointedEntity);
+   protected boolean canRenderName(T entity) {
+      return super.canRenderName(entity) && (entity.getAlwaysRenderNameTagForRender() || entity.hasCustomName() && entity == this.renderManager.pointedEntity);
    }
 
-   public boolean shouldRender(T var1, ICamera var2, double var3, double var5, double var7) {
-      if (super.shouldRender(☃, ☃, ☃, ☃, ☃)) {
+   public boolean shouldRender(T livingEntity, ICamera camera, double camX, double camY, double camZ) {
+      if (super.shouldRender(livingEntity, camera, camX, camY, camZ)) {
          return true;
-      } else if (☃.getLeashed() && ☃.getLeashHolder() != null) {
-         Entity ☃ = ☃.getLeashHolder();
-         return ☃.isBoundingBoxInFrustum(☃.getRenderBoundingBox());
+      } else if (livingEntity.getLeashed() && livingEntity.getLeashHolder() != null) {
+         Entity entity = livingEntity.getLeashHolder();
+         return camera.isBoundingBoxInFrustum(entity.getRenderBoundingBox());
       } else {
          return false;
       }
    }
 
-   public void doRender(T var1, double var2, double var4, double var6, float var8, float var9) {
-      super.doRender(☃, ☃, ☃, ☃, ☃, ☃);
+   public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {
+      super.doRender(entity, x, y, z, entityYaw, partialTicks);
       if (!this.renderOutlines) {
-         this.renderLeash(☃, ☃, ☃, ☃, ☃, ☃);
+         this.renderLeash(entity, x, y, z, entityYaw, partialTicks);
       }
    }
 
-   public void setLightmap(T var1) {
-      int ☃ = ☃.getBrightnessForRender();
-      int ☃x = ☃ % 65536;
-      int ☃xx = ☃ / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃x, ☃xx);
+   public void setLightmap(T entityLivingIn) {
+      int i = entityLivingIn.getBrightnessForRender();
+      int j = i % 65536;
+      int k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
    }
 
-   private double interpolateValue(double var1, double var3, double var5) {
-      return ☃ + (☃ - ☃) * ☃;
+   private double interpolateValue(double start, double end, double pct) {
+      return start + (end - start) * pct;
    }
 
-   protected void renderLeash(T var1, double var2, double var4, double var6, float var8, float var9) {
-      Entity ☃ = ☃.getLeashHolder();
-      if (☃ != null) {
-         ☃ -= (1.6 - ☃.height) * 0.5;
-         Tessellator ☃x = Tessellator.getInstance();
-         BufferBuilder ☃xx = ☃x.getBuffer();
-         double ☃xxx = this.interpolateValue(☃.prevRotationYaw, ☃.rotationYaw, ☃ * 0.5F) * (float) (Math.PI / 180.0);
-         double ☃xxxx = this.interpolateValue(☃.prevRotationPitch, ☃.rotationPitch, ☃ * 0.5F) * (float) (Math.PI / 180.0);
-         double ☃xxxxx = Math.cos(☃xxx);
-         double ☃xxxxxx = Math.sin(☃xxx);
-         double ☃xxxxxxx = Math.sin(☃xxxx);
-         if (☃ instanceof EntityHanging) {
-            ☃xxxxx = 0.0;
-            ☃xxxxxx = 0.0;
-            ☃xxxxxxx = -1.0;
-         }
+   protected void renderLeash(T entityLivingIn, double x, double y, double z, float entityYaw, float partialTicks) {
+      if (!Config.isShaders() || !Shaders.isShadowPass) {
+         Entity entity = entityLivingIn.getLeashHolder();
+         if (entity != null) {
+            y -= (1.6 - entityLivingIn.height) * 0.5;
+            Tessellator tessellator = Tessellator.getInstance();
+            BufferBuilder bufferbuilder = tessellator.getBuffer();
+            double d0 = this.interpolateValue(entity.prevRotationYaw, entity.rotationYaw, partialTicks * 0.5F) * (float) (Math.PI / 180.0);
+            double d1 = this.interpolateValue(entity.prevRotationPitch, entity.rotationPitch, partialTicks * 0.5F) * (float) (Math.PI / 180.0);
+            double d2 = Math.cos(d0);
+            double d3 = Math.sin(d0);
+            double d4 = Math.sin(d1);
+            if (entity instanceof EntityHanging) {
+               d2 = 0.0;
+               d3 = 0.0;
+               d4 = -1.0;
+            }
 
-         double ☃xxxxxxxx = Math.cos(☃xxxx);
-         double ☃xxxxxxxxx = this.interpolateValue(☃.prevPosX, ☃.posX, ☃) - ☃xxxxx * 0.7 - ☃xxxxxx * 0.5 * ☃xxxxxxxx;
-         double ☃xxxxxxxxxx = this.interpolateValue(☃.prevPosY + ☃.getEyeHeight() * 0.7, ☃.posY + ☃.getEyeHeight() * 0.7, ☃) - ☃xxxxxxx * 0.5 - 0.25;
-         double ☃xxxxxxxxxxx = this.interpolateValue(☃.prevPosZ, ☃.posZ, ☃) - ☃xxxxxx * 0.7 + ☃xxxxx * 0.5 * ☃xxxxxxxx;
-         double ☃xxxxxxxxxxxx = this.interpolateValue(☃.prevRenderYawOffset, ☃.renderYawOffset, ☃) * (float) (Math.PI / 180.0) + (Math.PI / 2);
-         ☃xxxxx = Math.cos(☃xxxxxxxxxxxx) * ☃.width * 0.4;
-         ☃xxxxxx = Math.sin(☃xxxxxxxxxxxx) * ☃.width * 0.4;
-         double ☃xxxxxxxxxxxxx = this.interpolateValue(☃.prevPosX, ☃.posX, ☃) + ☃xxxxx;
-         double ☃xxxxxxxxxxxxxx = this.interpolateValue(☃.prevPosY, ☃.posY, ☃);
-         double ☃xxxxxxxxxxxxxxx = this.interpolateValue(☃.prevPosZ, ☃.posZ, ☃) + ☃xxxxxx;
-         ☃ += ☃xxxxx;
-         ☃ += ☃xxxxxx;
-         double ☃xxxxxxxxxxxxxxxx = (float)(☃xxxxxxxxx - ☃xxxxxxxxxxxxx);
-         double ☃xxxxxxxxxxxxxxxxx = (float)(☃xxxxxxxxxx - ☃xxxxxxxxxxxxxx);
-         double ☃xxxxxxxxxxxxxxxxxx = (float)(☃xxxxxxxxxxx - ☃xxxxxxxxxxxxxxx);
-         GlStateManager.disableTexture2D();
-         GlStateManager.disableLighting();
-         GlStateManager.disableCull();
-         int ☃xxxxxxxxxxxxxxxxxxx = 24;
-         double ☃xxxxxxxxxxxxxxxxxxxx = 0.025;
-         ☃xx.begin(5, DefaultVertexFormats.POSITION_COLOR);
-
-         for (int ☃xxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxx <= 24; ☃xxxxxxxxxxxxxxxxxxxxx++) {
-            float ☃xxxxxxxxxxxxxxxxxxxxxx = 0.5F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxx = 0.4F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxx = 0.3F;
-            if (☃xxxxxxxxxxxxxxxxxxxxx % 2 == 0) {
-               ☃xxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
-               ☃xxxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
+            double d5 = Math.cos(d1);
+            double d6 = this.interpolateValue(entity.prevPosX, entity.posX, partialTicks) - d2 * 0.7 - d3 * 0.5 * d5;
+            double d7 = this.interpolateValue(entity.prevPosY + entity.getEyeHeight() * 0.7, entity.posY + entity.getEyeHeight() * 0.7, partialTicks)
+               - d4 * 0.5
+               - 0.25;
+            double d8 = this.interpolateValue(entity.prevPosZ, entity.posZ, partialTicks) - d3 * 0.7 + d2 * 0.5 * d5;
+            double d9 = this.interpolateValue(entityLivingIn.prevRenderYawOffset, entityLivingIn.renderYawOffset, partialTicks) * (float) (Math.PI / 180.0)
+               + (Math.PI / 2);
+            d2 = Math.cos(d9) * entityLivingIn.width * 0.4;
+            d3 = Math.sin(d9) * entityLivingIn.width * 0.4;
+            double d10 = this.interpolateValue(entityLivingIn.prevPosX, entityLivingIn.posX, partialTicks) + d2;
+            double d11 = this.interpolateValue(entityLivingIn.prevPosY, entityLivingIn.posY, partialTicks);
+            double d12 = this.interpolateValue(entityLivingIn.prevPosZ, entityLivingIn.posZ, partialTicks) + d3;
+            x += d2;
+            z += d3;
+            double d13 = (float)(d6 - d10);
+            double d14 = (float)(d7 - d11);
+            double d15 = (float)(d8 - d12);
+            GlStateManager.disableTexture2D();
+            GlStateManager.disableLighting();
+            GlStateManager.disableCull();
+            if (Config.isShaders()) {
+               Shaders.beginLeash();
             }
 
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxx / 24.0F;
-            ☃xx.pos(
-                  ☃ + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + 0.0,
-                  ☃
-                     + ☃xxxxxxxxxxxxxxxxx * (☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx) * 0.5
-                     + ((24.0F - ☃xxxxxxxxxxxxxxxxxxxxx) / 18.0F + 0.125F),
-                  ☃ + ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-               )
-               .color(☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .endVertex();
-            ☃xx.pos(
-                  ☃ + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + 0.025,
-                  ☃
-                     + ☃xxxxxxxxxxxxxxxxx * (☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx) * 0.5
-                     + ((24.0F - ☃xxxxxxxxxxxxxxxxxxxxx) / 18.0F + 0.125F)
-                     + 0.025,
-                  ☃ + ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-               )
-               .color(☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .endVertex();
-         }
+            int i = 24;
+            double d16 = 0.025;
+            bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
 
-         ☃x.draw();
-         ☃xx.begin(5, DefaultVertexFormats.POSITION_COLOR);
-
-         for (int ☃xxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxx <= 24; ☃xxxxxxxxxxxxxxxxxxxxx++) {
-            float ☃xxxxxxxxxxxxxxxxxxxxxx = 0.5F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxx = 0.4F;
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxx = 0.3F;
-            if (☃xxxxxxxxxxxxxxxxxxxxx % 2 == 0) {
-               ☃xxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
-               ☃xxxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
-               ☃xxxxxxxxxxxxxxxxxxxxxxxx *= 0.7F;
+            for (int j = 0; j <= 24; j++) {
+               float f = 0.5F;
+               float f1 = 0.4F;
+               float f2 = 0.3F;
+               if (j % 2 == 0) {
+                  f *= 0.7F;
+                  f1 *= 0.7F;
+                  f2 *= 0.7F;
+               }
+
+               float f3 = j / 24.0F;
+               bufferbuilder.pos(x + d13 * f3 + 0.0, y + d14 * (f3 * f3 + f3) * 0.5 + ((24.0F - j) / 18.0F + 0.125F), z + d15 * f3)
+                  .color(f, f1, f2, 1.0F)
+                  .endVertex();
+               bufferbuilder.pos(x + d13 * f3 + 0.025, y + d14 * (f3 * f3 + f3) * 0.5 + ((24.0F - j) / 18.0F + 0.125F) + 0.025, z + d15 * f3)
+                  .color(f, f1, f2, 1.0F)
+                  .endVertex();
             }
 
-            float ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxx / 24.0F;
-            ☃xx.pos(
-                  ☃ + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + 0.0,
-                  ☃
-                     + ☃xxxxxxxxxxxxxxxxx * (☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx) * 0.5
-                     + ((24.0F - ☃xxxxxxxxxxxxxxxxxxxxx) / 18.0F + 0.125F)
-                     + 0.025,
-                  ☃ + ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx
-               )
-               .color(☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .endVertex();
-            ☃xx.pos(
-                  ☃ + ☃xxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + 0.025,
-                  ☃
-                     + ☃xxxxxxxxxxxxxxxxx * (☃xxxxxxxxxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + ☃xxxxxxxxxxxxxxxxxxxxxxxxx) * 0.5
-                     + ((24.0F - ☃xxxxxxxxxxxxxxxxxxxxx) / 18.0F + 0.125F),
-                  ☃ + ☃xxxxxxxxxxxxxxxxxx * ☃xxxxxxxxxxxxxxxxxxxxxxxxx + 0.025
-               )
-               .color(☃xxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxx, 1.0F)
-               .endVertex();
-         }
+            tessellator.draw();
+            bufferbuilder.begin(5, DefaultVertexFormats.POSITION_COLOR);
+
+            for (int k = 0; k <= 24; k++) {
+               float f4 = 0.5F;
+               float f5 = 0.4F;
+               float f6 = 0.3F;
+               if (k % 2 == 0) {
+                  f4 *= 0.7F;
+                  f5 *= 0.7F;
+                  f6 *= 0.7F;
+               }
 
-         ☃x.draw();
-         GlStateManager.enableLighting();
-         GlStateManager.enableTexture2D();
-         GlStateManager.enableCull();
+               float f7 = k / 24.0F;
+               bufferbuilder.pos(x + d13 * f7 + 0.0, y + d14 * (f7 * f7 + f7) * 0.5 + ((24.0F - k) / 18.0F + 0.125F) + 0.025, z + d15 * f7)
+                  .color(f4, f5, f6, 1.0F)
+                  .endVertex();
+               bufferbuilder.pos(x + d13 * f7 + 0.025, y + d14 * (f7 * f7 + f7) * 0.5 + ((24.0F - k) / 18.0F + 0.125F), z + d15 * f7 + 0.025)
+                  .color(f4, f5, f6, 1.0F)
+                  .endVertex();
+            }
+
+            tessellator.draw();
+            if (Config.isShaders()) {
+               Shaders.endLeash();
+            }
+
+            GlStateManager.enableLighting();
+            GlStateManager.enableTexture2D();
+            GlStateManager.enableCull();
+         }
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/RenderLivingBase.java b/patches/net/minecraft/client/renderer/entity/RenderLivingBase.java
index fef1b7e..191d2df 100644
--- a/patches/net/minecraft/client/renderer/entity/RenderLivingBase.java
+++ b/patches/net/minecraft/client/renderer/entity/RenderLivingBase.java
@@ -7,6 +7,7 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelSpider;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
@@ -16,157 +17,232 @@
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EnumPlayerModelParts;
 import net.minecraft.scoreboard.Team;
+import net.minecraft.scoreboard.Team.EnumVisible;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.text.TextFormatting;
+import net.optifine.EmissiveTextures;
+import net.optifine.entity.model.CustomEntityModels;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public abstract class RenderLivingBase<T extends EntityLivingBase> extends Render<T> {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final DynamicTexture TEXTURE_BRIGHTNESS = new DynamicTexture(16, 16);
-   protected ModelBase mainModel;
+   public ModelBase mainModel;
    protected FloatBuffer brightnessBuffer = GLAllocation.createDirectFloatBuffer(4);
    protected List<LayerRenderer<T>> layerRenderers = Lists.newArrayList();
    protected boolean renderMarker;
-
-   public RenderLivingBase(RenderManager var1, ModelBase var2, float var3) {
-      super(☃);
-      this.mainModel = ☃;
-      this.shadowSize = ☃;
+   public static float NAME_TAG_RANGE = 64.0F;
+   public static float NAME_TAG_RANGE_SNEAK = 32.0F;
+   public EntityLivingBase renderEntity;
+   public float renderLimbSwing;
+   public float renderLimbSwingAmount;
+   public float renderAgeInTicks;
+   public float renderHeadYaw;
+   public float renderHeadPitch;
+   public float renderScaleFactor;
+   public float renderPartialTicks;
+   private boolean renderModelPushMatrix;
+   private boolean renderLayersPushMatrix;
+   public static final boolean animateModelLiving = Boolean.getBoolean("animate.model.living");
+
+   public RenderLivingBase(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn) {
+      super(renderManagerIn);
+      this.mainModel = modelBaseIn;
+      this.shadowSize = shadowSizeIn;
+      this.renderModelPushMatrix = this.mainModel instanceof ModelSpider;
    }
 
-   protected <V extends EntityLivingBase, U extends LayerRenderer<V>> boolean addLayer(U var1) {
-      return this.layerRenderers.add(☃);
+   public <V extends EntityLivingBase, U extends LayerRenderer<V>> boolean addLayer(U layer) {
+      return this.layerRenderers.add(layer);
    }
 
    public ModelBase getMainModel() {
       return this.mainModel;
    }
 
-   protected float interpolateRotation(float var1, float var2, float var3) {
-      float ☃ = ☃ - ☃;
+   protected float interpolateRotation(float prevYawOffset, float yawOffset, float partialTicks) {
+      float f = yawOffset - prevYawOffset;
 
-      while (☃ < -180.0F) {
-         ☃ += 360.0F;
+      while (f < -180.0F) {
+         f += 360.0F;
       }
 
-      while (☃ >= 180.0F) {
-         ☃ -= 360.0F;
+      while (f >= 180.0F) {
+         f -= 360.0F;
       }
 
-      return ☃ + ☃ * ☃;
+      return prevYawOffset + partialTicks * f;
    }
 
    public void transformHeldFull3DItemLayer() {
    }
 
-   public void doRender(T var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.pushMatrix();
-      GlStateManager.disableCull();
-      this.mainModel.swingProgress = this.getSwingProgress(☃, ☃);
-      this.mainModel.isRiding = ☃.isRiding();
-      this.mainModel.isChild = ☃.isChild();
-
-      try {
-         float ☃ = this.interpolateRotation(☃.prevRenderYawOffset, ☃.renderYawOffset, ☃);
-         float ☃x = this.interpolateRotation(☃.prevRotationYawHead, ☃.rotationYawHead, ☃);
-         float ☃xx = ☃x - ☃;
-         if (☃.isRiding() && ☃.getRidingEntity() instanceof EntityLivingBase) {
-            EntityLivingBase ☃xxx = (EntityLivingBase)☃.getRidingEntity();
-            ☃ = this.interpolateRotation(☃xxx.prevRenderYawOffset, ☃xxx.renderYawOffset, ☃);
-            ☃xx = ☃x - ☃;
-            float ☃xxxx = MathHelper.wrapDegrees(☃xx);
-            if (☃xxxx < -85.0F) {
-               ☃xxxx = -85.0F;
-            }
-
-            if (☃xxxx >= 85.0F) {
-               ☃xxxx = 85.0F;
-            }
-
-            ☃ = ☃x - ☃xxxx;
-            if (☃xxxx * ☃xxxx > 2500.0F) {
-               ☃ += ☃xxxx * 0.2F;
-            }
+   public void doRender(T entity, double x, double y, double z, float entityYaw, float partialTicks) {
+      if (!Reflector.RenderLivingEvent_Pre_Constructor.exists()
+         || !Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Pre_Constructor, new Object[]{entity, this, partialTicks, x, y, z})) {
+         if (animateModelLiving) {
+            entity.limbSwingAmount = 1.0F;
+         }
 
-            ☃xx = ☃x - ☃;
+         GlStateManager.pushMatrix();
+         GlStateManager.disableCull();
+         this.mainModel.swingProgress = this.getSwingProgress(entity, partialTicks);
+         this.mainModel.isRiding = entity.isRiding();
+         if (Reflector.ForgeEntity_shouldRiderSit.exists()) {
+            this.mainModel.isRiding = entity.isRiding()
+               && entity.getRidingEntity() != null
+               && Reflector.callBoolean(entity.getRidingEntity(), Reflector.ForgeEntity_shouldRiderSit, new Object[0]);
          }
 
-         float ☃xxxxx = ☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃;
-         this.renderLivingAt(☃, ☃, ☃, ☃);
-         float ☃xxxxxx = this.handleRotationFloat(☃, ☃);
-         this.applyRotations(☃, ☃xxxxxx, ☃, ☃);
-         float ☃xxxxxxx = this.prepareScale(☃, ☃);
-         float ☃xxxxxxxx = 0.0F;
-         float ☃xxxxxxxxx = 0.0F;
-         if (!☃.isRiding()) {
-            ☃xxxxxxxx = ☃.prevLimbSwingAmount + (☃.limbSwingAmount - ☃.prevLimbSwingAmount) * ☃;
-            ☃xxxxxxxxx = ☃.limbSwing - ☃.limbSwingAmount * (1.0F - ☃);
-            if (☃.isChild()) {
-               ☃xxxxxxxxx *= 3.0F;
+         this.mainModel.isChild = entity.isChild();
+
+         try {
+            float f = this.interpolateRotation(entity.prevRenderYawOffset, entity.renderYawOffset, partialTicks);
+            float f1 = this.interpolateRotation(entity.prevRotationYawHead, entity.rotationYawHead, partialTicks);
+            float f2 = f1 - f;
+            if (this.mainModel.isRiding && entity.getRidingEntity() instanceof EntityLivingBase) {
+               EntityLivingBase entitylivingbase = (EntityLivingBase)entity.getRidingEntity();
+               f = this.interpolateRotation(entitylivingbase.prevRenderYawOffset, entitylivingbase.renderYawOffset, partialTicks);
+               f2 = f1 - f;
+               float f3 = MathHelper.wrapDegrees(f2);
+               if (f3 < -85.0F) {
+                  f3 = -85.0F;
+               }
+
+               if (f3 >= 85.0F) {
+                  f3 = 85.0F;
+               }
+
+               f = f1 - f3;
+               if (f3 * f3 > 2500.0F) {
+                  f += f3 * 0.2F;
+               }
+
+               f2 = f1 - f;
             }
 
-            if (☃xxxxxxxx > 1.0F) {
-               ☃xxxxxxxx = 1.0F;
+            float f7 = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
+            this.renderLivingAt(entity, x, y, z);
+            float f8 = this.handleRotationFloat(entity, partialTicks);
+            this.applyRotations(entity, f8, f, partialTicks);
+            float f4 = this.prepareScale(entity, partialTicks);
+            float f5 = 0.0F;
+            float f6 = 0.0F;
+            if (!entity.isRiding()) {
+               f5 = entity.prevLimbSwingAmount + (entity.limbSwingAmount - entity.prevLimbSwingAmount) * partialTicks;
+               f6 = entity.limbSwing - entity.limbSwingAmount * (1.0F - partialTicks);
+               if (entity.isChild()) {
+                  f6 *= 3.0F;
+               }
+
+               if (f5 > 1.0F) {
+                  f5 = 1.0F;
+               }
             }
-         }
 
-         GlStateManager.enableAlpha();
-         this.mainModel.setLivingAnimations(☃, ☃xxxxxxxxx, ☃xxxxxxxx, ☃);
-         this.mainModel.setRotationAngles(☃xxxxxxxxx, ☃xxxxxxxx, ☃xxxxxx, ☃xx, ☃xxxxx, ☃xxxxxxx, ☃);
-         if (this.renderOutlines) {
-            boolean ☃xxxxxxxxxx = this.setScoreTeamColor(☃);
-            GlStateManager.enableColorMaterial();
-            GlStateManager.enableOutlineMode(this.getTeamColor(☃));
-            if (!this.renderMarker) {
-               this.renderModel(☃, ☃xxxxxxxxx, ☃xxxxxxxx, ☃xxxxxx, ☃xx, ☃xxxxx, ☃xxxxxxx);
+            GlStateManager.enableAlpha();
+            this.mainModel.setLivingAnimations(entity, f6, f5, partialTicks);
+            this.mainModel.setRotationAngles(f6, f5, f8, f2, f7, f4, entity);
+            if (CustomEntityModels.isActive()) {
+               this.renderEntity = entity;
+               this.renderLimbSwing = f6;
+               this.renderLimbSwingAmount = f5;
+               this.renderAgeInTicks = f8;
+               this.renderHeadYaw = f2;
+               this.renderHeadPitch = f7;
+               this.renderScaleFactor = f4;
+               this.renderPartialTicks = partialTicks;
             }
 
-            if (!(☃ instanceof EntityPlayer) || !((EntityPlayer)☃).isSpectator()) {
-               this.renderLayers(☃, ☃xxxxxxxxx, ☃xxxxxxxx, ☃, ☃xxxxxx, ☃xx, ☃xxxxx, ☃xxxxxxx);
+            if (this.renderOutlines) {
+               boolean flag1 = this.setScoreTeamColor(entity);
+               GlStateManager.enableColorMaterial();
+               GlStateManager.enableOutlineMode(this.getTeamColor(entity));
+               if (!this.renderMarker) {
+                  this.renderModel(entity, f6, f5, f8, f2, f7, f4);
+               }
+
+               if (!(entity instanceof EntityPlayer) || !((EntityPlayer)entity).isSpectator()) {
+                  this.renderLayers(entity, f6, f5, partialTicks, f8, f2, f7, f4);
+               }
+
+               GlStateManager.disableOutlineMode();
+               GlStateManager.disableColorMaterial();
+               if (flag1) {
+                  this.unsetScoreTeamColor();
+               }
+            } else {
+               boolean flag = this.setDoRenderBrightness(entity, partialTicks);
+               if (EmissiveTextures.isActive()) {
+                  EmissiveTextures.beginRender();
+               }
+
+               if (this.renderModelPushMatrix) {
+                  GlStateManager.pushMatrix();
+               }
+
+               this.renderModel(entity, f6, f5, f8, f2, f7, f4);
+               if (this.renderModelPushMatrix) {
+                  GlStateManager.popMatrix();
+               }
+
+               if (EmissiveTextures.isActive()) {
+                  if (EmissiveTextures.hasEmissive()) {
+                     this.renderModelPushMatrix = true;
+                     EmissiveTextures.beginRenderEmissive();
+                     GlStateManager.pushMatrix();
+                     this.renderModel(entity, f6, f5, f8, f2, f7, f4);
+                     GlStateManager.popMatrix();
+                     EmissiveTextures.endRenderEmissive();
+                  }
+
+                  EmissiveTextures.endRender();
+               }
+
+               if (flag) {
+                  this.unsetBrightness();
+               }
+
+               GlStateManager.depthMask(true);
+               if (!(entity instanceof EntityPlayer) || !((EntityPlayer)entity).isSpectator()) {
+                  this.renderLayers(entity, f6, f5, partialTicks, f8, f2, f7, f4);
+               }
             }
 
-            GlStateManager.disableOutlineMode();
-            GlStateManager.disableColorMaterial();
-            if (☃xxxxxxxxxx) {
-               this.unsetScoreTeamColor();
-            }
-         } else {
-            boolean ☃xxxxxxxxxxx = this.setDoRenderBrightness(☃, ☃);
-            this.renderModel(☃, ☃xxxxxxxxx, ☃xxxxxxxx, ☃xxxxxx, ☃xx, ☃xxxxx, ☃xxxxxxx);
-            if (☃xxxxxxxxxxx) {
-               this.unsetBrightness();
+            if (CustomEntityModels.isActive()) {
+               this.renderEntity = null;
             }
 
-            GlStateManager.depthMask(true);
-            if (!(☃ instanceof EntityPlayer) || !((EntityPlayer)☃).isSpectator()) {
-               this.renderLayers(☃, ☃xxxxxxxxx, ☃xxxxxxxx, ☃, ☃xxxxxx, ☃xx, ☃xxxxx, ☃xxxxxxx);
-            }
+            GlStateManager.disableRescaleNormal();
+         } catch (Exception var19) {
+            LOGGER.error("Couldn't render entity", var19);
          }
 
-         GlStateManager.disableRescaleNormal();
-      } catch (Exception var19) {
-         LOGGER.error("Couldn't render entity", var19);
+         GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
+         GlStateManager.enableTexture2D();
+         GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+         GlStateManager.enableCull();
+         GlStateManager.popMatrix();
+         super.doRender(entity, x, y, z, entityYaw, partialTicks);
+         if (Reflector.RenderLivingEvent_Post_Constructor.exists()) {
+            Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Post_Constructor, new Object[]{entity, this, partialTicks, x, y, z});
+         }
       }
-
-      GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
-      GlStateManager.enableTexture2D();
-      GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
-      GlStateManager.enableCull();
-      GlStateManager.popMatrix();
-      super.doRender(☃, ☃, ☃, ☃, ☃, ☃);
    }
 
-   public float prepareScale(T var1, float var2) {
+   public float prepareScale(T entitylivingbaseIn, float partialTicks) {
       GlStateManager.enableRescaleNormal();
       GlStateManager.scale(-1.0F, -1.0F, 1.0F);
-      this.preRenderCallback(☃, ☃);
-      float ☃ = 0.0625F;
+      this.preRenderCallback(entitylivingbaseIn, partialTicks);
+      float f = 0.0625F;
       GlStateManager.translate(0.0F, -1.501F, 0.0F);
       return 0.0625F;
    }
 
-   protected boolean setScoreTeamColor(T var1) {
+   protected boolean setScoreTeamColor(T entityLivingBaseIn) {
       GlStateManager.disableLighting();
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
       GlStateManager.disableTexture2D();
@@ -181,41 +257,43 @@ protected void unsetScoreTeamColor() {
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }
 
-   protected void renderModel(T var1, float var2, float var3, float var4, float var5, float var6, float var7) {
-      boolean ☃ = this.isVisible(☃);
-      boolean ☃x = !☃ && !☃.isInvisibleToPlayer(Minecraft.getMinecraft().player);
-      if (☃ || ☃x) {
-         if (!this.bindEntityTexture(☃)) {
+   protected void renderModel(
+      T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor
+   ) {
+      boolean flag = this.isVisible(entitylivingbaseIn);
+      boolean flag1 = !flag && !entitylivingbaseIn.isInvisibleToPlayer(Minecraft.getMinecraft().player);
+      if (flag || flag1) {
+         if (!this.bindEntityTexture(entitylivingbaseIn)) {
             return;
          }
 
-         if (☃x) {
+         if (flag1) {
             GlStateManager.enableBlendProfile(GlStateManager.Profile.TRANSPARENT_MODEL);
          }
 
-         this.mainModel.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         if (☃x) {
+         this.mainModel.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor);
+         if (flag1) {
             GlStateManager.disableBlendProfile(GlStateManager.Profile.TRANSPARENT_MODEL);
          }
       }
    }
 
-   protected boolean isVisible(T var1) {
-      return !☃.isInvisible() || this.renderOutlines;
+   protected boolean isVisible(T p_193115_1_) {
+      return !p_193115_1_.isInvisible() || this.renderOutlines;
    }
 
-   protected boolean setDoRenderBrightness(T var1, float var2) {
-      return this.setBrightness(☃, ☃, true);
+   protected boolean setDoRenderBrightness(T entityLivingBaseIn, float partialTicks) {
+      return this.setBrightness(entityLivingBaseIn, partialTicks, true);
    }
 
-   protected boolean setBrightness(T var1, float var2, boolean var3) {
-      float ☃ = ☃.getBrightness();
-      int ☃x = this.getColorMultiplier(☃, ☃, ☃);
-      boolean ☃xx = (☃x >> 24 & 0xFF) > 0;
-      boolean ☃xxx = ☃.hurtTime > 0 || ☃.deathTime > 0;
-      if (!☃xx && !☃xxx) {
+   protected boolean setBrightness(T entitylivingbaseIn, float partialTicks, boolean combineTextures) {
+      float f = entitylivingbaseIn.getBrightness();
+      int i = this.getColorMultiplier(entitylivingbaseIn, f, partialTicks);
+      boolean flag = (i >> 24 & 0xFF) > 0;
+      boolean flag1 = entitylivingbaseIn.hurtTime > 0 || entitylivingbaseIn.deathTime > 0;
+      if (!flag && !flag1) {
          return false;
-      } else if (!☃xx && !☃) {
+      } else if (!flag && !combineTextures) {
          return false;
       } else {
          GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
@@ -243,20 +321,26 @@ protected boolean setBrightness(T var1, float var2, boolean var3) {
          GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_SOURCE0_ALPHA, OpenGlHelper.GL_PREVIOUS);
          GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_OPERAND0_ALPHA, 770);
          ((Buffer)this.brightnessBuffer).position(0);
-         if (☃xxx) {
+         if (flag1) {
             this.brightnessBuffer.put(1.0F);
             this.brightnessBuffer.put(0.0F);
             this.brightnessBuffer.put(0.0F);
             this.brightnessBuffer.put(0.3F);
+            if (Config.isShaders()) {
+               Shaders.setEntityColor(1.0F, 0.0F, 0.0F, 0.3F);
+            }
          } else {
-            float ☃xxxx = (☃x >> 24 & 0xFF) / 255.0F;
-            float ☃xxxxx = (☃x >> 16 & 0xFF) / 255.0F;
-            float ☃xxxxxx = (☃x >> 8 & 0xFF) / 255.0F;
-            float ☃xxxxxxx = (☃x & 0xFF) / 255.0F;
-            this.brightnessBuffer.put(☃xxxxx);
-            this.brightnessBuffer.put(☃xxxxxx);
-            this.brightnessBuffer.put(☃xxxxxxx);
-            this.brightnessBuffer.put(1.0F - ☃xxxx);
+            float f1 = (i >> 24 & 0xFF) / 255.0F;
+            float f2 = (i >> 16 & 0xFF) / 255.0F;
+            float f3 = (i >> 8 & 0xFF) / 255.0F;
+            float f4 = (i & 0xFF) / 255.0F;
+            this.brightnessBuffer.put(f2);
+            this.brightnessBuffer.put(f3);
+            this.brightnessBuffer.put(f4);
+            this.brightnessBuffer.put(1.0F - f1);
+            if (Config.isShaders()) {
+               Shaders.setEntityColor(f2, f3, f4, 1.0F - f1);
+            }
          }
 
          ((Buffer)this.brightnessBuffer).flip();
@@ -316,105 +400,146 @@ protected void unsetBrightness() {
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_OPERAND0_ALPHA, 770);
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_SOURCE0_ALPHA, 5890);
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.setEntityColor(0.0F, 0.0F, 0.0F, 0.0F);
+      }
    }
 
-   protected void renderLivingAt(T var1, double var2, double var4, double var6) {
-      GlStateManager.translate((float)☃, (float)☃, (float)☃);
+   protected void renderLivingAt(T entityLivingBaseIn, double x, double y, double z) {
+      GlStateManager.translate((float)x, (float)y, (float)z);
    }
 
-   protected void applyRotations(T var1, float var2, float var3, float var4) {
-      GlStateManager.rotate(180.0F - ☃, 0.0F, 1.0F, 0.0F);
-      if (☃.deathTime > 0) {
-         float ☃ = (☃.deathTime + ☃ - 1.0F) / 20.0F * 1.6F;
-         ☃ = MathHelper.sqrt(☃);
-         if (☃ > 1.0F) {
-            ☃ = 1.0F;
+   protected void applyRotations(T entityLiving, float p_77043_2_, float rotationYaw, float partialTicks) {
+      GlStateManager.rotate(180.0F - rotationYaw, 0.0F, 1.0F, 0.0F);
+      if (entityLiving.deathTime > 0) {
+         float f = (entityLiving.deathTime + partialTicks - 1.0F) / 20.0F * 1.6F;
+         f = MathHelper.sqrt(f);
+         if (f > 1.0F) {
+            f = 1.0F;
          }
 
-         GlStateManager.rotate(☃ * this.getDeathMaxRotation(☃), 0.0F, 0.0F, 1.0F);
+         GlStateManager.rotate(f * this.getDeathMaxRotation(entityLiving), 0.0F, 0.0F, 1.0F);
       } else {
-         String ☃ = TextFormatting.getTextWithoutFormattingCodes(☃.getName());
-         if (☃ != null
-            && ("Dinnerbone".equals(☃) || "Grumm".equals(☃))
-            && (!(☃ instanceof EntityPlayer) || ((EntityPlayer)☃).isWearing(EnumPlayerModelParts.CAPE))) {
-            GlStateManager.translate(0.0F, ☃.height + 0.1F, 0.0F);
+         String s = TextFormatting.getTextWithoutFormattingCodes(entityLiving.getName());
+         if (s != null
+            && ("Dinnerbone".equals(s) || "Grumm".equals(s))
+            && (!(entityLiving instanceof EntityPlayer) || ((EntityPlayer)entityLiving).isWearing(EnumPlayerModelParts.CAPE))) {
+            GlStateManager.translate(0.0F, entityLiving.height + 0.1F, 0.0F);
             GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
          }
       }
    }
 
-   protected float getSwingProgress(T var1, float var2) {
-      return ☃.getSwingProgress(☃);
+   protected float getSwingProgress(T livingBase, float partialTickTime) {
+      return livingBase.getSwingProgress(partialTickTime);
    }
 
-   protected float handleRotationFloat(T var1, float var2) {
-      return ☃.ticksExisted + ☃;
+   protected float handleRotationFloat(T livingBase, float partialTicks) {
+      return livingBase.ticksExisted + partialTicks;
    }
 
-   protected void renderLayers(T var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      for (LayerRenderer<T> ☃ : this.layerRenderers) {
-         boolean ☃x = this.setBrightness(☃, ☃, ☃.shouldCombineTextures());
-         ☃.doRenderLayer(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         if (☃x) {
+   protected void renderLayers(
+      T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scaleIn
+   ) {
+      for (LayerRenderer<T> layerrenderer : this.layerRenderers) {
+         boolean flag = this.setBrightness(entitylivingbaseIn, partialTicks, layerrenderer.shouldCombineTextures());
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.beginRender();
+         }
+
+         if (this.renderLayersPushMatrix) {
+            GlStateManager.pushMatrix();
+         }
+
+         layerrenderer.doRenderLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scaleIn);
+         if (this.renderLayersPushMatrix) {
+            GlStateManager.popMatrix();
+         }
+
+         if (EmissiveTextures.isActive()) {
+            if (EmissiveTextures.hasEmissive()) {
+               this.renderLayersPushMatrix = true;
+               EmissiveTextures.beginRenderEmissive();
+               GlStateManager.pushMatrix();
+               layerrenderer.doRenderLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scaleIn);
+               GlStateManager.popMatrix();
+               EmissiveTextures.endRenderEmissive();
+            }
+
+            EmissiveTextures.endRender();
+         }
+
+         if (flag) {
             this.unsetBrightness();
          }
       }
    }
 
-   protected float getDeathMaxRotation(T var1) {
+   protected float getDeathMaxRotation(T entityLivingBaseIn) {
       return 90.0F;
    }
 
-   protected int getColorMultiplier(T var1, float var2, float var3) {
+   protected int getColorMultiplier(T entitylivingbaseIn, float lightBrightness, float partialTickTime) {
       return 0;
    }
 
-   protected void preRenderCallback(T var1, float var2) {
+   protected void preRenderCallback(T entitylivingbaseIn, float partialTickTime) {
    }
 
-   public void renderName(T var1, double var2, double var4, double var6) {
-      if (this.canRenderName(☃)) {
-         double ☃ = ☃.getDistanceSq(this.renderManager.renderViewEntity);
-         float ☃x = ☃.isSneaking() ? 32.0F : 64.0F;
-         if (!(☃ >= ☃x * ☃x)) {
-            String ☃xx = ☃.getDisplayName().getFormattedText();
-            GlStateManager.alphaFunc(516, 0.1F);
-            this.renderEntityName(☃, ☃, ☃, ☃, ☃xx, ☃);
+   public void renderName(T entity, double x, double y, double z) {
+      if (!Reflector.RenderLivingEvent_Specials_Pre_Constructor.exists()
+         || !Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Specials_Pre_Constructor, new Object[]{entity, this, x, y, z})) {
+         if (this.canRenderName(entity)) {
+            double d0 = entity.getDistanceSq(this.renderManager.renderViewEntity);
+            float f = entity.isSneaking() ? NAME_TAG_RANGE_SNEAK : NAME_TAG_RANGE;
+            if (d0 < f * f) {
+               String s = entity.getDisplayName().getFormattedText();
+               GlStateManager.alphaFunc(516, 0.1F);
+               this.renderEntityName(entity, x, y, z, s, d0);
+            }
+         }
+
+         if (Reflector.RenderLivingEvent_Specials_Post_Constructor.exists()) {
+            Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Specials_Post_Constructor, new Object[]{entity, this, x, y, z});
          }
       }
    }
 
-   protected boolean canRenderName(T var1) {
-      EntityPlayerSP ☃ = Minecraft.getMinecraft().player;
-      boolean ☃x = !☃.isInvisibleToPlayer(☃);
-      if (☃ != ☃) {
-         Team ☃xx = ☃.getTeam();
-         Team ☃xxx = ☃.getTeam();
-         if (☃xx != null) {
-            Team.EnumVisible ☃xxxx = ☃xx.getNameTagVisibility();
-            switch (☃xxxx) {
+   protected boolean canRenderName(T entity) {
+      EntityPlayerSP entityplayersp = Minecraft.getMinecraft().player;
+      boolean flag = !entity.isInvisibleToPlayer(entityplayersp);
+      if (entity != entityplayersp) {
+         Team team = entity.getTeam();
+         Team team1 = entityplayersp.getTeam();
+         if (team != null) {
+            EnumVisible team$enumvisible = team.getNameTagVisibility();
+            switch (team$enumvisible) {
                case ALWAYS:
-                  return ☃x;
+                  return flag;
                case NEVER:
                   return false;
                case HIDE_FOR_OTHER_TEAMS:
-                  return ☃xxx == null ? ☃x : ☃xx.isSameTeam(☃xxx) && (☃xx.getSeeFriendlyInvisiblesEnabled() || ☃x);
+                  return team1 == null ? flag : team.isSameTeam(team1) && (team.getSeeFriendlyInvisiblesEnabled() || flag);
                case HIDE_FOR_OWN_TEAM:
-                  return ☃xxx == null ? ☃x : !☃xx.isSameTeam(☃xxx) && ☃x;
+                  return team1 == null ? flag : !team.isSameTeam(team1) && flag;
                default:
                   return true;
             }
          }
       }
 
-      return Minecraft.isGuiEnabled() && ☃ != this.renderManager.renderViewEntity && ☃x && !☃.isBeingRidden();
+      return Minecraft.isGuiEnabled() && entity != this.renderManager.renderViewEntity && flag && !entity.isBeingRidden();
+   }
+
+   public List<LayerRenderer<T>> getLayerRenderers() {
+      return this.layerRenderers;
    }
 
    static {
-      int[] ☃ = TEXTURE_BRIGHTNESS.getTextureData();
+      int[] aint = TEXTURE_BRIGHTNESS.getTextureData();
 
-      for (int ☃x = 0; ☃x < 256; ☃x++) {
-         ☃[☃x] = -1;
+      for (int i = 0; i < 256; i++) {
+         aint[i] = -1;
       }
 
       TEXTURE_BRIGHTNESS.updateDynamicTexture();
diff --git a/patches/net/minecraft/client/renderer/entity/RenderManager.java b/patches/net/minecraft/client/renderer/entity/RenderManager.java
index f763116..acd07b3 100644
--- a/patches/net/minecraft/client/renderer/entity/RenderManager.java
+++ b/patches/net/minecraft/client/renderer/entity/RenderManager.java
@@ -1,6 +1,7 @@
 package net.minecraft.client.renderer.entity;
 
 import com.google.common.collect.Maps;
+import java.util.Collections;
 import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
@@ -106,11 +107,16 @@
 import net.minecraft.entity.projectile.EntityWitherSkull;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
+import net.optifine.entity.model.CustomEntityModels;
+import net.optifine.player.PlayerItemsLayer;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 
 public class RenderManager {
    private final Map<Class<? extends Entity>, Render<? extends Entity>> entityRenderMap = Maps.newHashMap();
@@ -133,9 +139,10 @@ public class RenderManager {
    private boolean renderOutlines;
    private boolean renderShadow = true;
    private boolean debugBoundingBox;
+   public Render renderRender = null;
 
-   public RenderManager(TextureManager var1, RenderItem var2) {
-      this.renderEngine = ☃;
+   public RenderManager(TextureManager renderEngineIn, RenderItem itemRendererIn) {
+      this.renderEngine = renderEngineIn;
       this.entityRenderMap.put(EntityCaveSpider.class, new RenderCaveSpider(this));
       this.entityRenderMap.put(EntitySpider.class, new RenderSpider(this));
       this.entityRenderMap.put(EntityPig.class, new RenderPig(this));
@@ -182,23 +189,23 @@ public RenderManager(TextureManager var1, RenderItem var2) {
       this.entityRenderMap.put(EntityWither.class, new RenderWither(this));
       this.entityRenderMap.put(Entity.class, new RenderEntity(this));
       this.entityRenderMap.put(EntityPainting.class, new RenderPainting(this));
-      this.entityRenderMap.put(EntityItemFrame.class, new RenderItemFrame(this, ☃));
+      this.entityRenderMap.put(EntityItemFrame.class, new RenderItemFrame(this, itemRendererIn));
       this.entityRenderMap.put(EntityLeashKnot.class, new RenderLeashKnot(this));
       this.entityRenderMap.put(EntityTippedArrow.class, new RenderTippedArrow(this));
       this.entityRenderMap.put(EntitySpectralArrow.class, new RenderSpectralArrow(this));
-      this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball<>(this, Items.SNOWBALL, ☃));
-      this.entityRenderMap.put(EntityEnderPearl.class, new RenderSnowball<>(this, Items.ENDER_PEARL, ☃));
-      this.entityRenderMap.put(EntityEnderEye.class, new RenderSnowball<>(this, Items.ENDER_EYE, ☃));
-      this.entityRenderMap.put(EntityEgg.class, new RenderSnowball<>(this, Items.EGG, ☃));
-      this.entityRenderMap.put(EntityPotion.class, new RenderPotion(this, ☃));
-      this.entityRenderMap.put(EntityExpBottle.class, new RenderSnowball<>(this, Items.EXPERIENCE_BOTTLE, ☃));
-      this.entityRenderMap.put(EntityFireworkRocket.class, new RenderSnowball<>(this, Items.FIREWORKS, ☃));
+      this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball(this, Items.SNOWBALL, itemRendererIn));
+      this.entityRenderMap.put(EntityEnderPearl.class, new RenderSnowball(this, Items.ENDER_PEARL, itemRendererIn));
+      this.entityRenderMap.put(EntityEnderEye.class, new RenderSnowball(this, Items.ENDER_EYE, itemRendererIn));
+      this.entityRenderMap.put(EntityEgg.class, new RenderSnowball(this, Items.EGG, itemRendererIn));
+      this.entityRenderMap.put(EntityPotion.class, new RenderPotion(this, itemRendererIn));
+      this.entityRenderMap.put(EntityExpBottle.class, new RenderSnowball(this, Items.EXPERIENCE_BOTTLE, itemRendererIn));
+      this.entityRenderMap.put(EntityFireworkRocket.class, new RenderSnowball(this, Items.FIREWORKS, itemRendererIn));
       this.entityRenderMap.put(EntityLargeFireball.class, new RenderFireball(this, 2.0F));
       this.entityRenderMap.put(EntitySmallFireball.class, new RenderFireball(this, 0.5F));
       this.entityRenderMap.put(EntityDragonFireball.class, new RenderDragonFireball(this));
       this.entityRenderMap.put(EntityWitherSkull.class, new RenderWitherSkull(this));
       this.entityRenderMap.put(EntityShulkerBullet.class, new RenderShulkerBullet(this));
-      this.entityRenderMap.put(EntityItem.class, new RenderEntityItem(this, ☃));
+      this.entityRenderMap.put(EntityItem.class, new RenderEntityItem(this, itemRendererIn));
       this.entityRenderMap.put(EntityXPOrb.class, new RenderXPOrb(this));
       this.entityRenderMap.put(EntityTNTPrimed.class, new RenderTNTPrimed(this));
       this.entityRenderMap.put(EntityFallingBlock.class, new RenderFallingBlock(this));
@@ -221,263 +228,294 @@ public RenderManager(TextureManager var1, RenderItem var2) {
       this.playerRenderer = new RenderPlayer(this);
       this.skinMap.put("default", this.playerRenderer);
       this.skinMap.put("slim", new RenderPlayer(this, true));
+      PlayerItemsLayer.register(this.skinMap);
+      if (Reflector.RenderingRegistry_loadEntityRenderers.exists()) {
+         Reflector.call(Reflector.RenderingRegistry_loadEntityRenderers, new Object[]{this, this.entityRenderMap});
+      }
    }
 
-   public void setRenderPosition(double var1, double var3, double var5) {
-      this.renderPosX = ☃;
-      this.renderPosY = ☃;
-      this.renderPosZ = ☃;
+   public void setRenderPosition(double renderPosXIn, double renderPosYIn, double renderPosZIn) {
+      this.renderPosX = renderPosXIn;
+      this.renderPosY = renderPosYIn;
+      this.renderPosZ = renderPosZIn;
    }
 
-   public <T extends Entity> Render<T> getEntityClassRenderObject(Class<? extends Entity> var1) {
-      Render<? extends Entity> ☃ = this.entityRenderMap.get(☃);
-      if (☃ == null && ☃ != Entity.class) {
-         ☃ = this.getEntityClassRenderObject((Class<? extends Entity>)☃.getSuperclass());
-         this.entityRenderMap.put(☃, ☃);
+   public <T extends Entity> Render<T> getEntityClassRenderObject(Class<? extends Entity> entityClass) {
+      Render<T> render = (Render<T>)this.entityRenderMap.get(entityClass);
+      if (render == null && entityClass != Entity.class) {
+         render = this.getEntityClassRenderObject((Class<? extends Entity>)entityClass.getSuperclass());
+         this.entityRenderMap.put(entityClass, render);
       }
 
-      return (Render<T>)☃;
+      return render;
    }
 
    @Nullable
-   public <T extends Entity> Render<T> getEntityRenderObject(Entity var1) {
-      if (☃ instanceof AbstractClientPlayer) {
-         String ☃ = ((AbstractClientPlayer)☃).getSkinType();
-         RenderPlayer ☃x = this.skinMap.get(☃);
-         return ☃x != null ? ☃x : this.playerRenderer;
+   public <T extends Entity> Render<T> getEntityRenderObject(Entity entityIn) {
+      if (entityIn instanceof AbstractClientPlayer) {
+         String s = ((AbstractClientPlayer)entityIn).getSkinType();
+         RenderPlayer renderplayer = this.skinMap.get(s);
+         return renderplayer != null ? renderplayer : this.playerRenderer;
       } else {
-         return this.getEntityClassRenderObject((Class<? extends Entity>)☃.getClass());
+         return this.getEntityClassRenderObject((Class<? extends Entity>)entityIn.getClass());
       }
    }
 
-   public void cacheActiveRenderInfo(World var1, FontRenderer var2, Entity var3, Entity var4, GameSettings var5, float var6) {
-      this.world = ☃;
-      this.options = ☃;
-      this.renderViewEntity = ☃;
-      this.pointedEntity = ☃;
-      this.textRenderer = ☃;
-      if (☃ instanceof EntityLivingBase && ((EntityLivingBase)☃).isPlayerSleeping()) {
-         IBlockState ☃ = ☃.getBlockState(new BlockPos(☃));
-         Block ☃x = ☃.getBlock();
-         if (☃x == Blocks.BED) {
-            int ☃xx = ☃.getValue(BlockBed.FACING).getHorizontalIndex();
-            this.playerViewY = ☃xx * 90 + 180;
+   public void cacheActiveRenderInfo(
+      World worldIn, FontRenderer textRendererIn, Entity livingPlayerIn, Entity pointedEntityIn, GameSettings optionsIn, float partialTicks
+   ) {
+      this.world = worldIn;
+      this.options = optionsIn;
+      this.renderViewEntity = livingPlayerIn;
+      this.pointedEntity = pointedEntityIn;
+      this.textRenderer = textRendererIn;
+      if (livingPlayerIn instanceof EntityLivingBase && ((EntityLivingBase)livingPlayerIn).isPlayerSleeping()) {
+         IBlockState iblockstate = worldIn.getBlockState(new BlockPos(livingPlayerIn));
+         Block block = iblockstate.getBlock();
+         if (Reflector.callBoolean(
+            block, Reflector.ForgeBlock_isBed, new Object[]{iblockstate, worldIn, new BlockPos(livingPlayerIn), (EntityLivingBase)livingPlayerIn}
+         )) {
+            EnumFacing facing = (EnumFacing)Reflector.call(
+               block, Reflector.ForgeBlock_getBedDirection, new Object[]{iblockstate, worldIn, new BlockPos(livingPlayerIn)}
+            );
+            int i = facing.getHorizontalIndex();
+            this.playerViewY = i * 90 + 180;
+            this.playerViewX = 0.0F;
+         } else if (block == Blocks.BED) {
+            int i = ((EnumFacing)iblockstate.getValue(BlockBed.D)).getHorizontalIndex();
+            this.playerViewY = i * 90 + 180;
             this.playerViewX = 0.0F;
          }
       } else {
-         this.playerViewY = ☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃;
-         this.playerViewX = ☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃;
+         this.playerViewY = livingPlayerIn.prevRotationYaw + (livingPlayerIn.rotationYaw - livingPlayerIn.prevRotationYaw) * partialTicks;
+         this.playerViewX = livingPlayerIn.prevRotationPitch + (livingPlayerIn.rotationPitch - livingPlayerIn.prevRotationPitch) * partialTicks;
       }
 
-      if (☃.thirdPersonView == 2) {
+      if (optionsIn.thirdPersonView == 2) {
          this.playerViewY += 180.0F;
       }
 
-      this.viewerPosX = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      this.viewerPosY = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      this.viewerPosZ = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
+      this.viewerPosX = livingPlayerIn.lastTickPosX + (livingPlayerIn.posX - livingPlayerIn.lastTickPosX) * partialTicks;
+      this.viewerPosY = livingPlayerIn.lastTickPosY + (livingPlayerIn.posY - livingPlayerIn.lastTickPosY) * partialTicks;
+      this.viewerPosZ = livingPlayerIn.lastTickPosZ + (livingPlayerIn.posZ - livingPlayerIn.lastTickPosZ) * partialTicks;
    }
 
-   public void setPlayerViewY(float var1) {
-      this.playerViewY = ☃;
+   public void setPlayerViewY(float playerViewYIn) {
+      this.playerViewY = playerViewYIn;
    }
 
    public boolean isRenderShadow() {
       return this.renderShadow;
    }
 
-   public void setRenderShadow(boolean var1) {
-      this.renderShadow = ☃;
+   public void setRenderShadow(boolean renderShadowIn) {
+      this.renderShadow = renderShadowIn;
    }
 
-   public void setDebugBoundingBox(boolean var1) {
-      this.debugBoundingBox = ☃;
+   public void setDebugBoundingBox(boolean debugBoundingBoxIn) {
+      this.debugBoundingBox = debugBoundingBoxIn;
    }
 
    public boolean isDebugBoundingBox() {
       return this.debugBoundingBox;
    }
 
-   public boolean isRenderMultipass(Entity var1) {
-      return this.getEntityRenderObject(☃).isMultipass();
+   public boolean isRenderMultipass(Entity p_188390_1_) {
+      return this.getEntityRenderObject(p_188390_1_).isMultipass();
    }
 
-   public boolean shouldRender(Entity var1, ICamera var2, double var3, double var5, double var7) {
-      Render<Entity> ☃ = this.getEntityRenderObject(☃);
-      return ☃ != null && ☃.shouldRender(☃, ☃, ☃, ☃, ☃);
+   public boolean shouldRender(Entity entityIn, ICamera camera, double camX, double camY, double camZ) {
+      Render<Entity> render = this.getEntityRenderObject(entityIn);
+      return render != null && render.shouldRender(entityIn, camera, camX, camY, camZ);
    }
 
-   public void renderEntityStatic(Entity var1, float var2, boolean var3) {
-      if (☃.ticksExisted == 0) {
-         ☃.lastTickPosX = ☃.posX;
-         ☃.lastTickPosY = ☃.posY;
-         ☃.lastTickPosZ = ☃.posZ;
+   public void renderEntityStatic(Entity entityIn, float partialTicks, boolean p_188388_3_) {
+      if (entityIn.ticksExisted == 0) {
+         entityIn.lastTickPosX = entityIn.posX;
+         entityIn.lastTickPosY = entityIn.posY;
+         entityIn.lastTickPosZ = entityIn.posZ;
       }
 
-      double ☃ = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃x = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      float ☃xxx = ☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃;
-      int ☃xxxx = ☃.getBrightnessForRender();
-      if (☃.isBurning()) {
-         ☃xxxx = 15728880;
+      double d0 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;
+      double d1 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;
+      double d2 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;
+      float f = entityIn.prevRotationYaw + (entityIn.rotationYaw - entityIn.prevRotationYaw) * partialTicks;
+      int i = entityIn.getBrightnessForRender();
+      if (entityIn.isBurning()) {
+         i = 15728880;
       }
 
-      int ☃xxxxx = ☃xxxx % 65536;
-      int ☃xxxxxx = ☃xxxx / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃xxxxx, ☃xxxxxx);
+      int j = i % 65536;
+      int k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      this.renderEntity(☃, ☃ - this.renderPosX, ☃x - this.renderPosY, ☃xx - this.renderPosZ, ☃xxx, ☃, ☃);
+      this.renderEntity(entityIn, d0 - this.renderPosX, d1 - this.renderPosY, d2 - this.renderPosZ, f, partialTicks, p_188388_3_);
    }
 
-   public void renderEntity(Entity var1, double var2, double var4, double var6, float var8, float var9, boolean var10) {
-      Render<Entity> ☃ = null;
+   public void renderEntity(Entity entityIn, double x, double y, double z, float yaw, float partialTicks, boolean p_188391_10_) {
+      Render<Entity> render = null;
 
       try {
-         ☃ = this.getEntityRenderObject(☃);
-         if (☃ != null && this.renderEngine != null) {
+         render = this.getEntityRenderObject(entityIn);
+         if (render != null && this.renderEngine != null) {
             try {
-               ☃.setRenderOutlines(this.renderOutlines);
-               ☃.doRender(☃, ☃, ☃, ☃, ☃, ☃);
-            } catch (Throwable var17) {
-               throw new ReportedException(CrashReport.makeCrashReport(var17, "Rendering entity in world"));
+               render.setRenderOutlines(this.renderOutlines);
+               if (CustomEntityModels.isActive()) {
+                  this.renderRender = render;
+               }
+
+               render.doRender(entityIn, x, y, z, yaw, partialTicks);
+            } catch (Throwable var18) {
+               throw new ReportedException(CrashReport.makeCrashReport(var18, "Rendering entity in world"));
             }
 
             try {
                if (!this.renderOutlines) {
-                  ☃.doRenderShadowAndFire(☃, ☃, ☃, ☃, ☃, ☃);
+                  render.doRenderShadowAndFire(entityIn, x, y, z, yaw, partialTicks);
                }
-            } catch (Throwable var18) {
-               throw new ReportedException(CrashReport.makeCrashReport(var18, "Post-rendering entity in world"));
+            } catch (Throwable var17) {
+               throw new ReportedException(CrashReport.makeCrashReport(var17, "Post-rendering entity in world"));
             }
 
-            if (this.debugBoundingBox && !☃.isInvisible() && !☃ && !Minecraft.getMinecraft().isReducedDebug()) {
+            if (this.debugBoundingBox && !entityIn.isInvisible() && !p_188391_10_ && !Minecraft.getMinecraft().isReducedDebug()) {
                try {
-                  this.renderDebugBoundingBox(☃, ☃, ☃, ☃, ☃, ☃);
+                  this.renderDebugBoundingBox(entityIn, x, y, z, yaw, partialTicks);
                } catch (Throwable var16) {
                   throw new ReportedException(CrashReport.makeCrashReport(var16, "Rendering entity hitbox in world"));
                }
             }
          }
       } catch (Throwable var19) {
-         CrashReport ☃x = CrashReport.makeCrashReport(var19, "Rendering entity in world");
-         CrashReportCategory ☃xx = ☃x.makeCategory("Entity being rendered");
-         ☃.addEntityCrashInfo(☃xx);
-         CrashReportCategory ☃xxx = ☃x.makeCategory("Renderer details");
-         ☃xxx.addCrashSection("Assigned renderer", ☃);
-         ☃xxx.addCrashSection("Location", CrashReportCategory.getCoordinateInfo(☃, ☃, ☃));
-         ☃xxx.addCrashSection("Rotation", ☃);
-         ☃xxx.addCrashSection("Delta", ☃);
-         throw new ReportedException(☃x);
+         CrashReport crashreport = CrashReport.makeCrashReport(var19, "Rendering entity in world");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being rendered");
+         entityIn.addEntityCrashInfo(crashreportcategory);
+         CrashReportCategory crashreportcategory1 = crashreport.makeCategory("Renderer details");
+         crashreportcategory1.addCrashSection("Assigned renderer", render);
+         crashreportcategory1.addCrashSection("Location", CrashReportCategory.getCoordinateInfo(x, y, z));
+         crashreportcategory1.addCrashSection("Rotation", yaw);
+         crashreportcategory1.addCrashSection("Delta", partialTicks);
+         throw new ReportedException(crashreport);
       }
    }
 
-   public void renderMultipass(Entity var1, float var2) {
-      if (☃.ticksExisted == 0) {
-         ☃.lastTickPosX = ☃.posX;
-         ☃.lastTickPosY = ☃.posY;
-         ☃.lastTickPosZ = ☃.posZ;
+   public void renderMultipass(Entity p_188389_1_, float p_188389_2_) {
+      if (p_188389_1_.ticksExisted == 0) {
+         p_188389_1_.lastTickPosX = p_188389_1_.posX;
+         p_188389_1_.lastTickPosY = p_188389_1_.posY;
+         p_188389_1_.lastTickPosZ = p_188389_1_.posZ;
       }
 
-      double ☃ = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      double ☃x = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      double ☃xx = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
-      float ☃xxx = ☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃;
-      int ☃xxxx = ☃.getBrightnessForRender();
-      if (☃.isBurning()) {
-         ☃xxxx = 15728880;
+      double d0 = p_188389_1_.lastTickPosX + (p_188389_1_.posX - p_188389_1_.lastTickPosX) * p_188389_2_;
+      double d1 = p_188389_1_.lastTickPosY + (p_188389_1_.posY - p_188389_1_.lastTickPosY) * p_188389_2_;
+      double d2 = p_188389_1_.lastTickPosZ + (p_188389_1_.posZ - p_188389_1_.lastTickPosZ) * p_188389_2_;
+      float f = p_188389_1_.prevRotationYaw + (p_188389_1_.rotationYaw - p_188389_1_.prevRotationYaw) * p_188389_2_;
+      int i = p_188389_1_.getBrightnessForRender();
+      if (p_188389_1_.isBurning()) {
+         i = 15728880;
       }
 
-      int ☃xxxxx = ☃xxxx % 65536;
-      int ☃xxxxxx = ☃xxxx / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃xxxxx, ☃xxxxxx);
+      int j = i % 65536;
+      int k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      Render<Entity> ☃xxxxxxx = this.getEntityRenderObject(☃);
-      if (☃xxxxxxx != null && this.renderEngine != null) {
-         ☃xxxxxxx.renderMultipass(☃, ☃ - this.renderPosX, ☃x - this.renderPosY, ☃xx - this.renderPosZ, ☃xxx, ☃);
+      Render<Entity> render = this.getEntityRenderObject(p_188389_1_);
+      if (render != null && this.renderEngine != null) {
+         render.renderMultipass(p_188389_1_, d0 - this.renderPosX, d1 - this.renderPosY, d2 - this.renderPosZ, f, p_188389_2_);
       }
    }
 
-   private void renderDebugBoundingBox(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.depthMask(false);
-      GlStateManager.disableTexture2D();
-      GlStateManager.disableLighting();
-      GlStateManager.disableCull();
-      GlStateManager.disableBlend();
-      float ☃ = ☃.width / 2.0F;
-      AxisAlignedBB ☃x = ☃.getEntityBoundingBox();
-      RenderGlobal.drawBoundingBox(
-         ☃x.minX - ☃.posX + ☃,
-         ☃x.minY - ☃.posY + ☃,
-         ☃x.minZ - ☃.posZ + ☃,
-         ☃x.maxX - ☃.posX + ☃,
-         ☃x.maxY - ☃.posY + ☃,
-         ☃x.maxZ - ☃.posZ + ☃,
-         1.0F,
-         1.0F,
-         1.0F,
-         1.0F
-      );
-      Entity[] ☃xx = ☃.getParts();
-      if (☃xx != null) {
-         for (Entity ☃xxx : ☃xx) {
-            double ☃xxxx = (☃xxx.posX - ☃xxx.prevPosX) * ☃;
-            double ☃xxxxx = (☃xxx.posY - ☃xxx.prevPosY) * ☃;
-            double ☃xxxxxx = (☃xxx.posZ - ☃xxx.prevPosZ) * ☃;
-            AxisAlignedBB ☃xxxxxxx = ☃xxx.getEntityBoundingBox();
+   private void renderDebugBoundingBox(Entity entityIn, double x, double y, double z, float entityYaw, float partialTicks) {
+      if (!Shaders.isShadowPass) {
+         GlStateManager.depthMask(false);
+         GlStateManager.disableTexture2D();
+         GlStateManager.disableLighting();
+         GlStateManager.disableCull();
+         GlStateManager.disableBlend();
+         float f = entityIn.width / 2.0F;
+         AxisAlignedBB axisalignedbb = entityIn.getEntityBoundingBox();
+         RenderGlobal.drawBoundingBox(
+            axisalignedbb.minX - entityIn.posX + x,
+            axisalignedbb.minY - entityIn.posY + y,
+            axisalignedbb.minZ - entityIn.posZ + z,
+            axisalignedbb.maxX - entityIn.posX + x,
+            axisalignedbb.maxY - entityIn.posY + y,
+            axisalignedbb.maxZ - entityIn.posZ + z,
+            1.0F,
+            1.0F,
+            1.0F,
+            1.0F
+         );
+         Entity[] aentity = entityIn.getParts();
+         if (aentity != null) {
+            for (Entity entity : aentity) {
+               double d0 = (entity.posX - entity.prevPosX) * partialTicks;
+               double d1 = (entity.posY - entity.prevPosY) * partialTicks;
+               double d2 = (entity.posZ - entity.prevPosZ) * partialTicks;
+               AxisAlignedBB axisalignedbb1 = entity.getEntityBoundingBox();
+               RenderGlobal.drawBoundingBox(
+                  axisalignedbb1.minX - this.renderPosX + d0,
+                  axisalignedbb1.minY - this.renderPosY + d1,
+                  axisalignedbb1.minZ - this.renderPosZ + d2,
+                  axisalignedbb1.maxX - this.renderPosX + d0,
+                  axisalignedbb1.maxY - this.renderPosY + d1,
+                  axisalignedbb1.maxZ - this.renderPosZ + d2,
+                  0.25F,
+                  1.0F,
+                  0.0F,
+                  1.0F
+               );
+            }
+         }
+
+         if (entityIn instanceof EntityLivingBase) {
+            float f1 = 0.01F;
             RenderGlobal.drawBoundingBox(
-               ☃xxxxxxx.minX - this.renderPosX + ☃xxxx,
-               ☃xxxxxxx.minY - this.renderPosY + ☃xxxxx,
-               ☃xxxxxxx.minZ - this.renderPosZ + ☃xxxxxx,
-               ☃xxxxxxx.maxX - this.renderPosX + ☃xxxx,
-               ☃xxxxxxx.maxY - this.renderPosY + ☃xxxxx,
-               ☃xxxxxxx.maxZ - this.renderPosZ + ☃xxxxxx,
-               0.25F,
-               1.0F,
-               0.0F,
-               1.0F
+               x - f, y + entityIn.getEyeHeight() - 0.01F, z - f, x + f, y + entityIn.getEyeHeight() + 0.01F, z + f, 1.0F, 0.0F, 0.0F, 1.0F
             );
          }
-      }
 
-      if (☃ instanceof EntityLivingBase) {
-         float ☃xxx = 0.01F;
-         RenderGlobal.drawBoundingBox(☃ - ☃, ☃ + ☃.getEyeHeight() - 0.01F, ☃ - ☃, ☃ + ☃, ☃ + ☃.getEyeHeight() + 0.01F, ☃ + ☃, 1.0F, 0.0F, 0.0F, 1.0F);
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         Vec3d vec3d = entityIn.getLook(partialTicks);
+         bufferbuilder.begin(3, DefaultVertexFormats.POSITION_COLOR);
+         bufferbuilder.pos(x, y + entityIn.getEyeHeight(), z).color(0, 0, 255, 255).endVertex();
+         bufferbuilder.pos(x + vec3d.x * 2.0, y + entityIn.getEyeHeight() + vec3d.y * 2.0, z + vec3d.z * 2.0).color(0, 0, 255, 255).endVertex();
+         tessellator.draw();
+         GlStateManager.enableTexture2D();
+         GlStateManager.enableLighting();
+         GlStateManager.enableCull();
+         GlStateManager.disableBlend();
+         GlStateManager.depthMask(true);
       }
-
-      Tessellator ☃xxx = Tessellator.getInstance();
-      BufferBuilder ☃xxxx = ☃xxx.getBuffer();
-      Vec3d ☃xxxxx = ☃.getLook(☃);
-      ☃xxxx.begin(3, DefaultVertexFormats.POSITION_COLOR);
-      ☃xxxx.pos(☃, ☃ + ☃.getEyeHeight(), ☃).color(0, 0, 255, 255).endVertex();
-      ☃xxxx.pos(☃ + ☃xxxxx.x * 2.0, ☃ + ☃.getEyeHeight() + ☃xxxxx.y * 2.0, ☃ + ☃xxxxx.z * 2.0).color(0, 0, 255, 255).endVertex();
-      ☃xxx.draw();
-      GlStateManager.enableTexture2D();
-      GlStateManager.enableLighting();
-      GlStateManager.enableCull();
-      GlStateManager.disableBlend();
-      GlStateManager.depthMask(true);
    }
 
-   public void setWorld(@Nullable World var1) {
-      this.world = ☃;
-      if (☃ == null) {
+   public void setWorld(@Nullable World worldIn) {
+      this.world = worldIn;
+      if (worldIn == null) {
          this.renderViewEntity = null;
       }
    }
 
-   public double getDistanceToCamera(double var1, double var3, double var5) {
-      double ☃ = ☃ - this.viewerPosX;
-      double ☃x = ☃ - this.viewerPosY;
-      double ☃xx = ☃ - this.viewerPosZ;
-      return ☃ * ☃ + ☃x * ☃x + ☃xx * ☃xx;
+   public double getDistanceToCamera(double x, double y, double z) {
+      double d0 = x - this.viewerPosX;
+      double d1 = y - this.viewerPosY;
+      double d2 = z - this.viewerPosZ;
+      return d0 * d0 + d1 * d1 + d2 * d2;
    }
 
    public FontRenderer getFontRenderer() {
       return this.textRenderer;
    }
 
-   public void setRenderOutlines(boolean var1) {
-      this.renderOutlines = ☃;
+   public void setRenderOutlines(boolean renderOutlinesIn) {
+      this.renderOutlines = renderOutlinesIn;
+   }
+
+   public Map<Class, Render> getEntityRenderMap() {
+      return this.entityRenderMap;
+   }
+
+   public Map<String, RenderPlayer> getSkinMap() {
+      return Collections.unmodifiableMap(this.skinMap);
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/RenderXPOrb.java b/patches/net/minecraft/client/renderer/entity/RenderXPOrb.java
index 47ceace..f8d0641 100644
--- a/patches/net/minecraft/client/renderer/entity/RenderXPOrb.java
+++ b/patches/net/minecraft/client/renderer/entity/RenderXPOrb.java
@@ -9,61 +9,78 @@
 import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.CustomColors;
 
 public class RenderXPOrb extends Render<EntityXPOrb> {
    private static final ResourceLocation EXPERIENCE_ORB_TEXTURES = new ResourceLocation("textures/entity/experience_orb.png");
 
-   public RenderXPOrb(RenderManager var1) {
-      super(☃);
+   public RenderXPOrb(RenderManager renderManagerIn) {
+      super(renderManagerIn);
       this.shadowSize = 0.15F;
       this.shadowOpaque = 0.75F;
    }
 
-   public void doRender(EntityXPOrb var1, double var2, double var4, double var6, float var8, float var9) {
+   public void doRender(EntityXPOrb entity, double x, double y, double z, float entityYaw, float partialTicks) {
       if (!this.renderOutlines) {
          GlStateManager.pushMatrix();
-         GlStateManager.translate((float)☃, (float)☃, (float)☃);
-         this.bindEntityTexture(☃);
+         GlStateManager.translate((float)x, (float)y, (float)z);
+         this.bindEntityTexture(entity);
          RenderHelper.enableStandardItemLighting();
-         int ☃ = ☃.getTextureByXP();
-         float ☃x = (☃ % 4 * 16 + 0) / 64.0F;
-         float ☃xx = (☃ % 4 * 16 + 16) / 64.0F;
-         float ☃xxx = (☃ / 4 * 16 + 0) / 64.0F;
-         float ☃xxxx = (☃ / 4 * 16 + 16) / 64.0F;
-         float ☃xxxxx = 1.0F;
-         float ☃xxxxxx = 0.5F;
-         float ☃xxxxxxx = 0.25F;
-         int ☃xxxxxxxx = ☃.getBrightnessForRender();
-         int ☃xxxxxxxxx = ☃xxxxxxxx % 65536;
-         int ☃xxxxxxxxxx = ☃xxxxxxxx / 65536;
-         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃xxxxxxxxx, ☃xxxxxxxxxx);
+         int i = entity.getTextureByXP();
+         float f = (i % 4 * 16 + 0) / 64.0F;
+         float f1 = (i % 4 * 16 + 16) / 64.0F;
+         float f2 = (i / 4 * 16 + 0) / 64.0F;
+         float f3 = (i / 4 * 16 + 16) / 64.0F;
+         float f4 = 1.0F;
+         float f5 = 0.5F;
+         float f6 = 0.25F;
+         int j = entity.getBrightnessForRender();
+         int k = j % 65536;
+         int l = j / 65536;
+         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, k, l);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         float ☃xxxxxxxxxxx = 255.0F;
-         float ☃xxxxxxxxxxxx = (☃.xpColor + ☃) / 2.0F;
-         ☃xxxxxxxxxx = (int)((MathHelper.sin(☃xxxxxxxxxxxx + 0.0F) + 1.0F) * 0.5F * 255.0F);
-         int ☃xxxxxxxxxxxxx = 255;
-         int ☃xxxxxxxxxxxxxx = (int)((MathHelper.sin(☃xxxxxxxxxxxx + (float) (Math.PI * 4.0 / 3.0)) + 1.0F) * 0.1F * 255.0F);
+         float f8 = 255.0F;
+         float f9 = (entity.xpColor + partialTicks) / 2.0F;
+         if (Config.isCustomColors()) {
+            f9 = CustomColors.getXpOrbTimer(f9);
+         }
+
+         l = (int)((MathHelper.sin(f9 + 0.0F) + 1.0F) * 0.5F * 255.0F);
+         int i1 = 255;
+         int j1 = (int)((MathHelper.sin(f9 + (float) (Math.PI * 4.0 / 3.0)) + 1.0F) * 0.1F * 255.0F);
          GlStateManager.translate(0.0F, 0.1F, 0.0F);
          GlStateManager.rotate(180.0F - this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
          GlStateManager.rotate((this.renderManager.options.thirdPersonView == 2 ? -1 : 1) * -this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
-         float ☃xxxxxxxxxxxxxxx = 0.3F;
+         float f7 = 0.3F;
          GlStateManager.scale(0.3F, 0.3F, 0.3F);
-         Tessellator ☃xxxxxxxxxxxxxxxx = Tessellator.getInstance();
-         BufferBuilder ☃xxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxx.getBuffer();
-         ☃xxxxxxxxxxxxxxxxx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
-         ☃xxxxxxxxxxxxxxxxx.pos(-0.5, -0.25, 0.0).tex(☃x, ☃xxxx).color(☃xxxxxxxxxx, 255, ☃xxxxxxxxxxxxxx, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         ☃xxxxxxxxxxxxxxxxx.pos(0.5, -0.25, 0.0).tex(☃xx, ☃xxxx).color(☃xxxxxxxxxx, 255, ☃xxxxxxxxxxxxxx, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         ☃xxxxxxxxxxxxxxxxx.pos(0.5, 0.75, 0.0).tex(☃xx, ☃xxx).color(☃xxxxxxxxxx, 255, ☃xxxxxxxxxxxxxx, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         ☃xxxxxxxxxxxxxxxxx.pos(-0.5, 0.75, 0.0).tex(☃x, ☃xxx).color(☃xxxxxxxxxx, 255, ☃xxxxxxxxxxxxxx, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         ☃xxxxxxxxxxxxxxxx.draw();
+         Tessellator tessellator = Tessellator.getInstance();
+         BufferBuilder bufferbuilder = tessellator.getBuffer();
+         bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
+         int red = l;
+         int green = 255;
+         int blue = j1;
+         if (Config.isCustomColors()) {
+            int col = CustomColors.getXpOrbColor(f9);
+            if (col >= 0) {
+               red = col >> 16 & 0xFF;
+               green = col >> 8 & 0xFF;
+               blue = col >> 0 & 0xFF;
+            }
+         }
+
+         bufferbuilder.pos(-0.5, -0.25, 0.0).tex(f, f3).color(red, green, blue, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         bufferbuilder.pos(0.5, -0.25, 0.0).tex(f1, f3).color(red, green, blue, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         bufferbuilder.pos(0.5, 0.75, 0.0).tex(f1, f2).color(red, green, blue, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         bufferbuilder.pos(-0.5, 0.75, 0.0).tex(f, f2).color(red, green, blue, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         tessellator.draw();
          GlStateManager.disableBlend();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
-         super.doRender(☃, ☃, ☃, ☃, ☃, ☃);
+         super.doRender(entity, x, y, z, entityYaw, partialTicks);
       }
    }
 
-   protected ResourceLocation getEntityTexture(EntityXPOrb var1) {
+   protected ResourceLocation getEntityTexture(EntityXPOrb entity) {
       return EXPERIENCE_ORB_TEXTURES;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java b/patches/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java
index 42b1bae..ec287a9 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerArmorBase.java
@@ -6,11 +6,17 @@
 import net.minecraft.client.model.ModelBase;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderLivingBase;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.item.ItemArmor;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
 
 public abstract class LayerArmorBase<T extends ModelBase> implements LayerRenderer<EntityLivingBase> {
    protected static final ResourceLocation ENCHANTED_ITEM_GLINT_RES = new ResourceLocation("textures/misc/enchanted_item_glint.png");
@@ -24,123 +30,237 @@ public abstract class LayerArmorBase<T extends ModelBase> implements LayerRender
    private boolean skipRenderGlint;
    private static final Map<String, ResourceLocation> ARMOR_TEXTURE_RES_MAP = Maps.newHashMap();
 
-   public LayerArmorBase(RenderLivingBase<?> var1) {
-      this.renderer = ☃;
+   public LayerArmorBase(RenderLivingBase<?> rendererIn) {
+      this.renderer = rendererIn;
       this.initArmor();
    }
 
-   @Override
-   public void doRenderLayer(EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.renderArmorLayer(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, EntityEquipmentSlot.CHEST);
-      this.renderArmorLayer(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, EntityEquipmentSlot.LEGS);
-      this.renderArmorLayer(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, EntityEquipmentSlot.FEET);
-      this.renderArmorLayer(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, EntityEquipmentSlot.HEAD);
+   public void doRenderLayer(
+      EntityLivingBase entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      this.renderArmorLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, EntityEquipmentSlot.CHEST);
+      this.renderArmorLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, EntityEquipmentSlot.LEGS);
+      this.renderArmorLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, EntityEquipmentSlot.FEET);
+      this.renderArmorLayer(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale, EntityEquipmentSlot.HEAD);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 
    private void renderArmorLayer(
-      EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8, EntityEquipmentSlot var9
+      EntityLivingBase entityLivingBaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale,
+      EntityEquipmentSlot slotIn
    ) {
-      ItemStack ☃ = ☃.getItemStackFromSlot(☃);
-      if (☃.getItem() instanceof ItemArmor) {
-         ItemArmor ☃x = (ItemArmor)☃.getItem();
-         if (☃x.getEquipmentSlot() == ☃) {
-            T ☃xx = this.getModelFromSlot(☃);
-            ☃xx.setModelAttributes(this.renderer.getMainModel());
-            ☃xx.setLivingAnimations(☃, ☃, ☃, ☃);
-            this.setModelSlotVisible(☃xx, ☃);
-            boolean ☃xxx = this.isLegSlot(☃);
-            this.renderer.bindTexture(this.getArmorResource(☃x, ☃xxx));
-            switch (☃x.getArmorMaterial()) {
+      ItemStack itemstack = entityLivingBaseIn.getItemStackFromSlot(slotIn);
+      if (itemstack.getItem() instanceof ItemArmor) {
+         ItemArmor itemarmor = (ItemArmor)itemstack.getItem();
+         if (itemarmor.getEquipmentSlot() == slotIn) {
+            T t = this.getModelFromSlot(slotIn);
+            if (Reflector.ForgeHooksClient.exists()) {
+               t = this.getArmorModelHook(entityLivingBaseIn, itemstack, slotIn, t);
+            }
+
+            t.setModelAttributes(this.renderer.getMainModel());
+            t.setLivingAnimations(entityLivingBaseIn, limbSwing, limbSwingAmount, partialTicks);
+            this.setModelSlotVisible(t, slotIn);
+            boolean flag = this.isLegSlot(slotIn);
+            if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(itemstack, slotIn, null)) {
+               if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
+                  this.renderer.bindTexture(this.getArmorResource(entityLivingBaseIn, itemstack, slotIn, null));
+               } else {
+                  this.renderer.bindTexture(this.getArmorResource(itemarmor, flag));
+               }
+            }
+
+            if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
+               if (ReflectorForge.armorHasOverlay(itemarmor, itemstack)) {
+                  int i = itemarmor.getColor(itemstack);
+                  float f = (i >> 16 & 0xFF) / 255.0F;
+                  float f1 = (i >> 8 & 0xFF) / 255.0F;
+                  float f2 = (i & 0xFF) / 255.0F;
+                  GlStateManager.color(this.colorR * f, this.colorG * f1, this.colorB * f2, this.alpha);
+                  t.render(entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+                  if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(itemstack, slotIn, "overlay")) {
+                     this.renderer.bindTexture(this.getArmorResource(entityLivingBaseIn, itemstack, slotIn, "overlay"));
+                  }
+               }
+
+               GlStateManager.color(this.colorR, this.colorG, this.colorB, this.alpha);
+               t.render(entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+               if (!this.skipRenderGlint
+                  && itemstack.hasEffect()
+                  && (
+                     !Config.isCustomItems()
+                        || !CustomItems.renderCustomArmorEffect(
+                           entityLivingBaseIn, itemstack, t, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale
+                        )
+                  )) {
+                  renderEnchantedGlint(this.renderer, entityLivingBaseIn, t, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale);
+               }
+
+               return;
+            }
+
+            switch (itemarmor.getArmorMaterial()) {
                case LEATHER:
-                  int ☃xxxx = ☃x.getColor(☃);
-                  float ☃xxxxx = (☃xxxx >> 16 & 0xFF) / 255.0F;
-                  float ☃xxxxxx = (☃xxxx >> 8 & 0xFF) / 255.0F;
-                  float ☃xxxxxxx = (☃xxxx & 0xFF) / 255.0F;
-                  GlStateManager.color(this.colorR * ☃xxxxx, this.colorG * ☃xxxxxx, this.colorB * ☃xxxxxxx, this.alpha);
-                  ☃xx.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-                  this.renderer.bindTexture(this.getArmorResource(☃x, ☃xxx, "overlay"));
+                  int i = itemarmor.getColor(itemstack);
+                  float f = (i >> 16 & 0xFF) / 255.0F;
+                  float f1 = (i >> 8 & 0xFF) / 255.0F;
+                  float f2 = (i & 0xFF) / 255.0F;
+                  GlStateManager.color(this.colorR * f, this.colorG * f1, this.colorB * f2, this.alpha);
+                  t.render(entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+                  if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(itemstack, slotIn, "overlay")) {
+                     this.renderer.bindTexture(this.getArmorResource(itemarmor, flag, "overlay"));
+                  }
                case CHAIN:
                case IRON:
                case GOLD:
                case DIAMOND:
                   GlStateManager.color(this.colorR, this.colorG, this.colorB, this.alpha);
-                  ☃xx.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-               default:
-                  if (!this.skipRenderGlint && ☃.isItemEnchanted()) {
-                     renderEnchantedGlint(this.renderer, ☃, ☃xx, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
-                  }
+                  t.render(entityLivingBaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+            }
+
+            if (!this.skipRenderGlint
+               && itemstack.isItemEnchanted()
+               && (
+                  !Config.isCustomItems()
+                     || !CustomItems.renderCustomArmorEffect(
+                        entityLivingBaseIn, itemstack, t, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale
+                     )
+               )) {
+               renderEnchantedGlint(this.renderer, entityLivingBaseIn, t, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale);
             }
          }
       }
    }
 
-   public T getModelFromSlot(EntityEquipmentSlot var1) {
-      return this.isLegSlot(☃) ? this.modelLeggings : this.modelArmor;
+   public T getModelFromSlot(EntityEquipmentSlot slotIn) {
+      return this.isLegSlot(slotIn) ? this.modelLeggings : this.modelArmor;
    }
 
-   private boolean isLegSlot(EntityEquipmentSlot var1) {
-      return ☃ == EntityEquipmentSlot.LEGS;
+   private boolean isLegSlot(EntityEquipmentSlot slotIn) {
+      return slotIn == EntityEquipmentSlot.LEGS;
    }
 
    public static void renderEnchantedGlint(
-      RenderLivingBase<?> var0, EntityLivingBase var1, ModelBase var2, float var3, float var4, float var5, float var6, float var7, float var8, float var9
+      RenderLivingBase<?> p_188364_0_,
+      EntityLivingBase p_188364_1_,
+      ModelBase model,
+      float p_188364_3_,
+      float p_188364_4_,
+      float p_188364_5_,
+      float p_188364_6_,
+      float p_188364_7_,
+      float p_188364_8_,
+      float p_188364_9_
    ) {
-      float ☃ = ☃.ticksExisted + ☃;
-      ☃.bindTexture(ENCHANTED_ITEM_GLINT_RES);
-      Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      GlStateManager.enableBlend();
-      GlStateManager.depthFunc(514);
-      GlStateManager.depthMask(false);
-      float ☃x = 0.5F;
-      GlStateManager.color(0.5F, 0.5F, 0.5F, 1.0F);
-
-      for (int ☃xx = 0; ☃xx < 2; ☃xx++) {
-         GlStateManager.disableLighting();
-         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
-         float ☃xxx = 0.76F;
-         GlStateManager.color(0.38F, 0.19F, 0.608F, 1.0F);
+      if (!Config.isShaders() || !Shaders.isShadowPass) {
+         float f = p_188364_1_.ticksExisted + p_188364_5_;
+         p_188364_0_.bindTexture(ENCHANTED_ITEM_GLINT_RES);
+         if (Config.isShaders()) {
+            ShadersRender.renderEnchantedGlintBegin();
+         }
+
+         Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+         GlStateManager.enableBlend();
+         GlStateManager.depthFunc(514);
+         GlStateManager.depthMask(false);
+         float f1 = 0.5F;
+         GlStateManager.color(0.5F, 0.5F, 0.5F, 1.0F);
+
+         for (int i = 0; i < 2; i++) {
+            GlStateManager.disableLighting();
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
+            float f2 = 0.76F;
+            GlStateManager.color(0.38F, 0.19F, 0.608F, 1.0F);
+            GlStateManager.matrixMode(5890);
+            GlStateManager.loadIdentity();
+            float f3 = 0.33333334F;
+            GlStateManager.scale(0.33333334F, 0.33333334F, 0.33333334F);
+            GlStateManager.rotate(30.0F - i * 60.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.translate(0.0F, f * (0.001F + i * 0.003F) * 20.0F, 0.0F);
+            GlStateManager.matrixMode(5888);
+            model.render(p_188364_1_, p_188364_3_, p_188364_4_, p_188364_6_, p_188364_7_, p_188364_8_, p_188364_9_);
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+         }
+
          GlStateManager.matrixMode(5890);
          GlStateManager.loadIdentity();
-         float ☃xxxx = 0.33333334F;
-         GlStateManager.scale(0.33333334F, 0.33333334F, 0.33333334F);
-         GlStateManager.rotate(30.0F - ☃xx * 60.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.translate(0.0F, ☃ * (0.001F + ☃xx * 0.003F) * 20.0F, 0.0F);
          GlStateManager.matrixMode(5888);
-         ☃.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+         GlStateManager.enableLighting();
+         GlStateManager.depthMask(true);
+         GlStateManager.depthFunc(515);
+         GlStateManager.disableBlend();
+         Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
+         if (Config.isShaders()) {
+            ShadersRender.renderEnchantedGlintEnd();
+         }
       }
-
-      GlStateManager.matrixMode(5890);
-      GlStateManager.loadIdentity();
-      GlStateManager.matrixMode(5888);
-      GlStateManager.enableLighting();
-      GlStateManager.depthMask(true);
-      GlStateManager.depthFunc(515);
-      GlStateManager.disableBlend();
-      Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
    }
 
-   private ResourceLocation getArmorResource(ItemArmor var1, boolean var2) {
-      return this.getArmorResource(☃, ☃, null);
+   private ResourceLocation getArmorResource(ItemArmor armor, boolean p_177181_2_) {
+      return this.getArmorResource(armor, p_177181_2_, (String)null);
    }
 
-   private ResourceLocation getArmorResource(ItemArmor var1, boolean var2, String var3) {
-      String ☃ = String.format("textures/models/armor/%s_layer_%d%s.png", ☃.getArmorMaterial().getName(), ☃ ? 2 : 1, ☃ == null ? "" : String.format("_%s", ☃));
-      ResourceLocation ☃x = ARMOR_TEXTURE_RES_MAP.get(☃);
-      if (☃x == null) {
-         ☃x = new ResourceLocation(☃);
-         ARMOR_TEXTURE_RES_MAP.put(☃, ☃x);
+   private ResourceLocation getArmorResource(ItemArmor armor, boolean p_177178_2_, String p_177178_3_) {
+      String s = String.format(
+         "textures/models/armor/%s_layer_%d%s.png",
+         armor.getArmorMaterial().getName(),
+         p_177178_2_ ? 2 : 1,
+         p_177178_3_ == null ? "" : String.format("_%s", p_177178_3_)
+      );
+      ResourceLocation resourcelocation = ARMOR_TEXTURE_RES_MAP.get(s);
+      if (resourcelocation == null) {
+         resourcelocation = new ResourceLocation(s);
+         ARMOR_TEXTURE_RES_MAP.put(s, resourcelocation);
       }
 
-      return ☃x;
+      return resourcelocation;
    }
 
    protected abstract void initArmor();
 
    protected abstract void setModelSlotVisible(T var1, EntityEquipmentSlot var2);
+
+   protected T getArmorModelHook(EntityLivingBase entity, ItemStack itemStack, EntityEquipmentSlot slot, T model) {
+      return model;
+   }
+
+   public ResourceLocation getArmorResource(Entity entity, ItemStack stack, EntityEquipmentSlot slot, String type) {
+      ItemArmor item = (ItemArmor)stack.getItem();
+      String texture = item.getArmorMaterial().getName();
+      String domain = "minecraft";
+      int idx = texture.indexOf(58);
+      if (idx != -1) {
+         domain = texture.substring(0, idx);
+         texture = texture.substring(idx + 1);
+      }
+
+      String s1 = String.format(
+         "%s:textures/models/armor/%s_layer_%d%s.png", domain, texture, this.isLegSlot(slot) ? 2 : 1, type == null ? "" : String.format("_%s", type)
+      );
+      s1 = Reflector.callString(Reflector.ForgeHooksClient_getArmorTexture, new Object[]{entity, stack, s1, slot, type});
+      ResourceLocation resourcelocation = ARMOR_TEXTURE_RES_MAP.get(s1);
+      if (resourcelocation == null) {
+         resourcelocation = new ResourceLocation(s1);
+         ARMOR_TEXTURE_RES_MAP.put(s1, resourcelocation);
+      }
+
+      return resourcelocation;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerCape.java b/patches/net/minecraft/client/renderer/entity/layers/LayerCape.java
index 079b9d6..2bb4417 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerCape.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerCape.java
@@ -12,43 +12,76 @@
 public class LayerCape implements LayerRenderer<AbstractClientPlayer> {
    private final RenderPlayer playerRenderer;
 
-   public LayerCape(RenderPlayer var1) {
-      this.playerRenderer = ☃;
+   public LayerCape(RenderPlayer playerRendererIn) {
+      this.playerRenderer = playerRendererIn;
    }
 
-   public void doRenderLayer(AbstractClientPlayer var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (☃.hasPlayerInfo() && !☃.isInvisible() && ☃.isWearing(EnumPlayerModelParts.CAPE) && ☃.getLocationCape() != null) {
-         ItemStack ☃ = ☃.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
-         if (☃.getItem() != Items.ELYTRA) {
+   public void doRenderLayer(
+      AbstractClientPlayer entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      if (entitylivingbaseIn.hasPlayerInfo()
+         && !entitylivingbaseIn.isInvisible()
+         && entitylivingbaseIn.isWearing(EnumPlayerModelParts.CAPE)
+         && entitylivingbaseIn.getLocationCape() != null) {
+         ItemStack itemstack = entitylivingbaseIn.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
+         if (itemstack.getItem() != Items.ELYTRA) {
             GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-            this.playerRenderer.bindTexture(☃.getLocationCape());
+            this.playerRenderer.bindTexture(entitylivingbaseIn.getLocationCape());
             GlStateManager.pushMatrix();
             GlStateManager.translate(0.0F, 0.0F, 0.125F);
-            double ☃x = ☃.prevChasingPosX + (☃.chasingPosX - ☃.prevChasingPosX) * ☃ - (☃.prevPosX + (☃.posX - ☃.prevPosX) * ☃);
-            double ☃xx = ☃.prevChasingPosY + (☃.chasingPosY - ☃.prevChasingPosY) * ☃ - (☃.prevPosY + (☃.posY - ☃.prevPosY) * ☃);
-            double ☃xxx = ☃.prevChasingPosZ + (☃.chasingPosZ - ☃.prevChasingPosZ) * ☃ - (☃.prevPosZ + (☃.posZ - ☃.prevPosZ) * ☃);
-            float ☃xxxx = ☃.prevRenderYawOffset + (☃.renderYawOffset - ☃.prevRenderYawOffset) * ☃;
-            double ☃xxxxx = MathHelper.sin(☃xxxx * (float) (Math.PI / 180.0));
-            double ☃xxxxxx = -MathHelper.cos(☃xxxx * (float) (Math.PI / 180.0));
-            float ☃xxxxxxx = (float)☃xx * 10.0F;
-            ☃xxxxxxx = MathHelper.clamp(☃xxxxxxx, -6.0F, 32.0F);
-            float ☃xxxxxxxx = (float)(☃x * ☃xxxxx + ☃xxx * ☃xxxxxx) * 100.0F;
-            float ☃xxxxxxxxx = (float)(☃x * ☃xxxxxx - ☃xxx * ☃xxxxx) * 100.0F;
-            if (☃xxxxxxxx < 0.0F) {
-               ☃xxxxxxxx = 0.0F;
+            double d0 = entitylivingbaseIn.prevChasingPosX
+               + (entitylivingbaseIn.chasingPosX - entitylivingbaseIn.prevChasingPosX) * partialTicks
+               - (entitylivingbaseIn.prevPosX + (entitylivingbaseIn.posX - entitylivingbaseIn.prevPosX) * partialTicks);
+            double d1 = entitylivingbaseIn.prevChasingPosY
+               + (entitylivingbaseIn.chasingPosY - entitylivingbaseIn.prevChasingPosY) * partialTicks
+               - (entitylivingbaseIn.prevPosY + (entitylivingbaseIn.posY - entitylivingbaseIn.prevPosY) * partialTicks);
+            double d2 = entitylivingbaseIn.prevChasingPosZ
+               + (entitylivingbaseIn.chasingPosZ - entitylivingbaseIn.prevChasingPosZ) * partialTicks
+               - (entitylivingbaseIn.prevPosZ + (entitylivingbaseIn.posZ - entitylivingbaseIn.prevPosZ) * partialTicks);
+            float f = entitylivingbaseIn.prevRenderYawOffset + (entitylivingbaseIn.renderYawOffset - entitylivingbaseIn.prevRenderYawOffset) * partialTicks;
+            double d3 = MathHelper.sin(f * (float) (Math.PI / 180.0));
+            double d4 = -MathHelper.cos(f * (float) (Math.PI / 180.0));
+            float f1 = (float)d1 * 10.0F;
+            f1 = MathHelper.clamp(f1, -6.0F, 32.0F);
+            float f2 = (float)(d0 * d3 + d2 * d4) * 100.0F;
+            float f3 = (float)(d0 * d4 - d2 * d3) * 100.0F;
+            if (f2 < 0.0F) {
+               f2 = 0.0F;
             }
 
-            float ☃xxxxxxxxxx = ☃.prevCameraYaw + (☃.cameraYaw - ☃.prevCameraYaw) * ☃;
-            ☃xxxxxxx += MathHelper.sin((☃.prevDistanceWalkedModified + (☃.distanceWalkedModified - ☃.prevDistanceWalkedModified) * ☃) * 6.0F)
+            if (f2 > 165.0F) {
+               f2 = 165.0F;
+            }
+
+            if (f1 < -5.0F) {
+               f1 = -5.0F;
+            }
+
+            float f4 = entitylivingbaseIn.prevCameraYaw + (entitylivingbaseIn.cameraYaw - entitylivingbaseIn.prevCameraYaw) * partialTicks;
+            f1 += MathHelper.sin(
+                  (
+                        entitylivingbaseIn.prevDistanceWalkedModified
+                           + (entitylivingbaseIn.distanceWalkedModified - entitylivingbaseIn.prevDistanceWalkedModified) * partialTicks
+                     )
+                     * 6.0F
+               )
                * 32.0F
-               * ☃xxxxxxxxxx;
-            if (☃.isSneaking()) {
-               ☃xxxxxxx += 25.0F;
+               * f4;
+            if (entitylivingbaseIn.isSneaking()) {
+               f1 += 25.0F;
+               GlStateManager.translate(0.0F, 0.142F, -0.0178F);
             }
 
-            GlStateManager.rotate(6.0F + ☃xxxxxxxx / 2.0F + ☃xxxxxxx, 1.0F, 0.0F, 0.0F);
-            GlStateManager.rotate(☃xxxxxxxxx / 2.0F, 0.0F, 0.0F, 1.0F);
-            GlStateManager.rotate(-☃xxxxxxxxx / 2.0F, 0.0F, 1.0F, 0.0F);
+            GlStateManager.rotate(6.0F + f2 / 2.0F + f1, 1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(f3 / 2.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.rotate(-f3 / 2.0F, 0.0F, 1.0F, 0.0F);
             GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
             this.playerRenderer.getMainModel().renderCape(0.0625F);
             GlStateManager.popMatrix();
@@ -56,7 +89,6 @@ public void doRenderLayer(AbstractClientPlayer var1, float var2, float var3, flo
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerElytra.java b/patches/net/minecraft/client/renderer/entity/layers/LayerElytra.java
index 2e7f9c9..e99bc1c 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerElytra.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerElytra.java
@@ -10,42 +10,66 @@
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomItems;
 
 public class LayerElytra implements LayerRenderer<EntityLivingBase> {
    private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");
    protected final RenderLivingBase<?> renderPlayer;
    private final ModelElytra modelElytra = new ModelElytra();
 
-   public LayerElytra(RenderLivingBase<?> var1) {
-      this.renderPlayer = ☃;
+   public LayerElytra(RenderLivingBase<?> p_i47185_1_) {
+      this.renderPlayer = p_i47185_1_;
    }
 
-   @Override
-   public void doRenderLayer(EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      ItemStack ☃ = ☃.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
-      if (☃.getItem() == Items.ELYTRA) {
+   public void doRenderLayer(
+      EntityLivingBase entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      ItemStack itemstack = entitylivingbaseIn.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
+      if (itemstack.getItem() == Items.ELYTRA) {
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
          GlStateManager.enableBlend();
          GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
-         if (☃ instanceof AbstractClientPlayer) {
-            AbstractClientPlayer ☃x = (AbstractClientPlayer)☃;
-            if (☃x.isPlayerInfoSet() && ☃x.getLocationElytra() != null) {
-               this.renderPlayer.bindTexture(☃x.getLocationElytra());
-            } else if (☃x.hasPlayerInfo() && ☃x.getLocationCape() != null && ☃x.isWearing(EnumPlayerModelParts.CAPE)) {
-               this.renderPlayer.bindTexture(☃x.getLocationCape());
+         if (entitylivingbaseIn instanceof AbstractClientPlayer) {
+            AbstractClientPlayer abstractclientplayer = (AbstractClientPlayer)entitylivingbaseIn;
+            if (abstractclientplayer.isPlayerInfoSet() && abstractclientplayer.getLocationElytra() != null) {
+               this.renderPlayer.bindTexture(abstractclientplayer.getLocationElytra());
+            } else if (abstractclientplayer.hasElytraCape()
+               && abstractclientplayer.hasPlayerInfo()
+               && abstractclientplayer.getLocationCape() != null
+               && abstractclientplayer.isWearing(EnumPlayerModelParts.CAPE)) {
+               this.renderPlayer.bindTexture(abstractclientplayer.getLocationCape());
             } else {
-               this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
+               ResourceLocation locElytra = TEXTURE_ELYTRA;
+               if (Config.isCustomItems()) {
+                  locElytra = CustomItems.getCustomElytraTexture(itemstack, locElytra);
+               }
+
+               this.renderPlayer.bindTexture(locElytra);
             }
          } else {
-            this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
+            ResourceLocation locElytra = TEXTURE_ELYTRA;
+            if (Config.isCustomItems()) {
+               locElytra = CustomItems.getCustomElytraTexture(itemstack, locElytra);
+            }
+
+            this.renderPlayer.bindTexture(locElytra);
          }
 
          GlStateManager.pushMatrix();
          GlStateManager.translate(0.0F, 0.0F, 0.125F);
-         this.modelElytra.setRotationAngles(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         this.modelElytra.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-         if (☃.isItemEnchanted()) {
-            LayerArmorBase.renderEnchantedGlint(this.renderPlayer, ☃, this.modelElytra, ☃, ☃, ☃, ☃, ☃, ☃, ☃);
+         this.modelElytra.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, entitylivingbaseIn);
+         this.modelElytra.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+         if (itemstack.isItemEnchanted()) {
+            LayerArmorBase.renderEnchantedGlint(
+               this.renderPlayer, entitylivingbaseIn, this.modelElytra, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale
+            );
          }
 
          GlStateManager.disableBlend();
@@ -53,7 +77,6 @@ public void doRenderLayer(EntityLivingBase var1, float var2, float var3, float v
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java b/patches/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java
index cae5a3b..26aada1 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java
@@ -6,38 +6,57 @@
 import net.minecraft.client.renderer.entity.RenderDragon;
 import net.minecraft.entity.boss.EntityDragon;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEnderDragonEyes implements LayerRenderer<EntityDragon> {
    private static final ResourceLocation TEXTURE = new ResourceLocation("textures/entity/enderdragon/dragon_eyes.png");
    private final RenderDragon dragonRenderer;
 
-   public LayerEnderDragonEyes(RenderDragon var1) {
-      this.dragonRenderer = ☃;
+   public LayerEnderDragonEyes(RenderDragon dragonRendererIn) {
+      this.dragonRenderer = dragonRendererIn;
    }
 
-   public void doRenderLayer(EntityDragon var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.dragonRenderer.bindTexture(TEXTURE);
+   public void doRenderLayer(
+      EntityDragon entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      this.dragonRenderer.a(TEXTURE);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
       GlStateManager.disableLighting();
       GlStateManager.depthFunc(514);
-      int ☃ = 61680;
-      int ☃x = 61680;
-      int ☃xx = 0;
+      int i = 61680;
+      int j = 61680;
+      int k = 0;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
       GlStateManager.enableLighting();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      this.dragonRenderer.getMainModel().render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
+      this.dragonRenderer.b().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-      this.dragonRenderer.setLightmap(☃);
+      this.dragonRenderer.c(entitylivingbaseIn);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
       GlStateManager.depthFunc(515);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java b/patches/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java
index a2f5541..260bcfe 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java
@@ -6,38 +6,57 @@
 import net.minecraft.client.renderer.entity.RenderEnderman;
 import net.minecraft.entity.monster.EntityEnderman;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEndermanEyes implements LayerRenderer<EntityEnderman> {
    private static final ResourceLocation RES_ENDERMAN_EYES = new ResourceLocation("textures/entity/enderman/enderman_eyes.png");
    private final RenderEnderman endermanRenderer;
 
-   public LayerEndermanEyes(RenderEnderman var1) {
-      this.endermanRenderer = ☃;
+   public LayerEndermanEyes(RenderEnderman endermanRendererIn) {
+      this.endermanRenderer = endermanRendererIn;
    }
 
-   public void doRenderLayer(EntityEnderman var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.endermanRenderer.bindTexture(RES_ENDERMAN_EYES);
+   public void doRenderLayer(
+      EntityEnderman entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      this.endermanRenderer.a(RES_ENDERMAN_EYES);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
       GlStateManager.disableLighting();
-      GlStateManager.depthMask(!☃.isInvisible());
-      int ☃ = 61680;
-      int ☃x = 61680;
-      int ☃xx = 0;
+      GlStateManager.depthMask(!entitylivingbaseIn.isInvisible());
+      int i = 61680;
+      int j = 61680;
+      int k = 0;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
       GlStateManager.enableLighting();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      this.endermanRenderer.getMainModel().render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
+      this.endermanRenderer.getMainModel().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-      this.endermanRenderer.setLightmap(☃);
+      this.endermanRenderer.c(entitylivingbaseIn);
       GlStateManager.depthMask(true);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java b/patches/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java
index cfd2440..6192440 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java
@@ -2,18 +2,21 @@
 
 import java.util.UUID;
 import javax.annotation.Nullable;
+import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.model.ModelBase;
 import net.minecraft.client.model.ModelParrot;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderLivingBase;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.entity.RenderParrot;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityList;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.passive.EntityParrot;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEntityOnShoulder implements LayerRenderer<EntityPlayer> {
    private final RenderManager renderManager;
@@ -28,36 +31,73 @@ public class LayerEntityOnShoulder implements LayerRenderer<EntityPlayer> {
    private UUID rightUniqueId;
    private Class<?> rightEntityClass;
 
-   public LayerEntityOnShoulder(RenderManager var1) {
-      this.renderManager = ☃;
+   public LayerEntityOnShoulder(RenderManager p_i47370_1_) {
+      this.renderManager = p_i47370_1_;
    }
 
-   public void doRenderLayer(EntityPlayer var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (☃.getLeftShoulderEntity() != null || ☃.getRightShoulderEntity() != null) {
+   public void doRenderLayer(
+      EntityPlayer entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      if (entitylivingbaseIn.getLeftShoulderEntity() != null || entitylivingbaseIn.getRightShoulderEntity() != null) {
          GlStateManager.enableRescaleNormal();
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         NBTTagCompound ☃ = ☃.getLeftShoulderEntity();
-         if (!☃.isEmpty()) {
-            LayerEntityOnShoulder.DataHolder ☃x = this.renderEntityOnShoulder(
-               ☃, this.leftUniqueId, ☃, this.leftRenderer, this.leftModel, this.leftResource, this.leftEntityClass, ☃, ☃, ☃, ☃, ☃, ☃, ☃, true
+         NBTTagCompound nbttagcompound = entitylivingbaseIn.getLeftShoulderEntity();
+         if (!nbttagcompound.isEmpty()) {
+            LayerEntityOnShoulder.DataHolder layerentityonshoulder$dataholder = this.renderEntityOnShoulder(
+               entitylivingbaseIn,
+               this.leftUniqueId,
+               nbttagcompound,
+               this.leftRenderer,
+               this.leftModel,
+               this.leftResource,
+               this.leftEntityClass,
+               limbSwing,
+               limbSwingAmount,
+               partialTicks,
+               ageInTicks,
+               netHeadYaw,
+               headPitch,
+               scale,
+               true
             );
-            this.leftUniqueId = ☃x.entityId;
-            this.leftRenderer = ☃x.renderer;
-            this.leftResource = ☃x.textureLocation;
-            this.leftModel = ☃x.model;
-            this.leftEntityClass = ☃x.clazz;
+            this.leftUniqueId = layerentityonshoulder$dataholder.entityId;
+            this.leftRenderer = layerentityonshoulder$dataholder.renderer;
+            this.leftResource = layerentityonshoulder$dataholder.textureLocation;
+            this.leftModel = layerentityonshoulder$dataholder.model;
+            this.leftEntityClass = layerentityonshoulder$dataholder.clazz;
          }
 
-         NBTTagCompound ☃x = ☃.getRightShoulderEntity();
-         if (!☃x.isEmpty()) {
-            LayerEntityOnShoulder.DataHolder ☃xx = this.renderEntityOnShoulder(
-               ☃, this.rightUniqueId, ☃x, this.rightRenderer, this.rightModel, this.rightResource, this.rightEntityClass, ☃, ☃, ☃, ☃, ☃, ☃, ☃, false
+         NBTTagCompound nbttagcompound1 = entitylivingbaseIn.getRightShoulderEntity();
+         if (!nbttagcompound1.isEmpty()) {
+            LayerEntityOnShoulder.DataHolder layerentityonshoulder$dataholder1 = this.renderEntityOnShoulder(
+               entitylivingbaseIn,
+               this.rightUniqueId,
+               nbttagcompound1,
+               this.rightRenderer,
+               this.rightModel,
+               this.rightResource,
+               this.rightEntityClass,
+               limbSwing,
+               limbSwingAmount,
+               partialTicks,
+               ageInTicks,
+               netHeadYaw,
+               headPitch,
+               scale,
+               false
             );
-            this.rightUniqueId = ☃xx.entityId;
-            this.rightRenderer = ☃xx.renderer;
-            this.rightResource = ☃xx.textureLocation;
-            this.rightModel = ☃xx.model;
-            this.rightEntityClass = ☃xx.clazz;
+            this.rightUniqueId = layerentityonshoulder$dataholder1.entityId;
+            this.rightRenderer = layerentityonshoulder$dataholder1.renderer;
+            this.rightResource = layerentityonshoulder$dataholder1.textureLocation;
+            this.rightModel = layerentityonshoulder$dataholder1.model;
+            this.rightEntityClass = layerentityonshoulder$dataholder1.clazz;
          }
 
          GlStateManager.disableRescaleNormal();
@@ -65,49 +105,65 @@ public void doRenderLayer(EntityPlayer var1, float var2, float var3, float var4,
    }
 
    private LayerEntityOnShoulder.DataHolder renderEntityOnShoulder(
-      EntityPlayer var1,
-      @Nullable UUID var2,
-      NBTTagCompound var3,
-      RenderLivingBase<? extends EntityLivingBase> var4,
-      ModelBase var5,
-      ResourceLocation var6,
-      Class<?> var7,
-      float var8,
-      float var9,
-      float var10,
-      float var11,
-      float var12,
-      float var13,
-      float var14,
-      boolean var15
+      EntityPlayer p_192864_1_,
+      @Nullable UUID p_192864_2_,
+      NBTTagCompound p_192864_3_,
+      RenderLivingBase<? extends EntityLivingBase> p_192864_4_,
+      ModelBase p_192864_5_,
+      ResourceLocation p_192864_6_,
+      Class<?> p_192864_7_,
+      float p_192864_8_,
+      float p_192864_9_,
+      float p_192864_10_,
+      float p_192864_11_,
+      float p_192864_12_,
+      float p_192864_13_,
+      float p_192864_14_,
+      boolean p_192864_15_
    ) {
-      if (☃ == null || !☃.equals(☃.getUniqueId("UUID"))) {
-         ☃ = ☃.getUniqueId("UUID");
-         ☃ = EntityList.getClassFromName(☃.getString("id"));
-         if (☃ == EntityParrot.class) {
-            ☃ = new RenderParrot(this.renderManager);
-            ☃ = new ModelParrot();
-            ☃ = RenderParrot.PARROT_TEXTURES[☃.getInteger("Variant")];
+      if (p_192864_2_ == null || !p_192864_2_.equals(p_192864_3_.getUniqueId("UUID"))) {
+         p_192864_2_ = p_192864_3_.getUniqueId("UUID");
+         p_192864_7_ = EntityList.getClassFromName(p_192864_3_.getString("id"));
+         if (p_192864_7_ == EntityParrot.class) {
+            p_192864_4_ = new RenderParrot(this.renderManager);
+            p_192864_5_ = new ModelParrot();
+            p_192864_6_ = RenderParrot.PARROT_TEXTURES[p_192864_3_.getInteger("Variant")];
+         }
+      }
+
+      Entity renderedEntityOld = Config.getRenderGlobal().renderedEntity;
+      if (p_192864_1_ instanceof AbstractClientPlayer) {
+         AbstractClientPlayer acp = (AbstractClientPlayer)p_192864_1_;
+         Entity entityShoulder = p_192864_2_ == this.leftUniqueId ? acp.entityShoulderLeft : acp.entityShoulderRight;
+         if (entityShoulder != null) {
+            Config.getRenderGlobal().renderedEntity = entityShoulder;
+            if (Config.isShaders()) {
+               Shaders.nextEntity(entityShoulder);
+            }
          }
       }
 
-      ☃.bindTexture(☃);
+      p_192864_4_.bindTexture(p_192864_6_);
       GlStateManager.pushMatrix();
-      float ☃ = ☃.isSneaking() ? -1.3F : -1.5F;
-      float ☃x = ☃ ? 0.4F : -0.4F;
-      GlStateManager.translate(☃x, ☃, 0.0F);
-      if (☃ == EntityParrot.class) {
-         ☃ = 0.0F;
+      float f = p_192864_1_.isSneaking() ? -1.3F : -1.5F;
+      float f1 = p_192864_15_ ? 0.4F : -0.4F;
+      GlStateManager.translate(f1, f, 0.0F);
+      if (p_192864_7_ == EntityParrot.class) {
+         p_192864_11_ = 0.0F;
       }
 
-      ☃.setLivingAnimations(☃, ☃, ☃, ☃);
-      ☃.setRotationAngles(☃, ☃, ☃, ☃, ☃, ☃, ☃);
-      ☃.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+      p_192864_5_.setLivingAnimations(p_192864_1_, p_192864_8_, p_192864_9_, p_192864_10_);
+      p_192864_5_.setRotationAngles(p_192864_8_, p_192864_9_, p_192864_11_, p_192864_12_, p_192864_13_, p_192864_14_, p_192864_1_);
+      p_192864_5_.render(p_192864_1_, p_192864_8_, p_192864_9_, p_192864_11_, p_192864_12_, p_192864_13_, p_192864_14_);
       GlStateManager.popMatrix();
-      return new LayerEntityOnShoulder.DataHolder(☃, ☃, ☃, ☃, ☃);
+      Config.getRenderGlobal().renderedEntity = renderedEntityOld;
+      if (Config.isShaders()) {
+         Shaders.nextEntity(renderedEntityOld);
+      }
+
+      return new LayerEntityOnShoulder.DataHolder(p_192864_2_, p_192864_4_, p_192864_5_, p_192864_6_, p_192864_7_);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
@@ -119,12 +175,14 @@ class DataHolder {
       public ResourceLocation textureLocation;
       public Class<?> clazz;
 
-      public DataHolder(UUID var2, RenderLivingBase<? extends EntityLivingBase> var3, ModelBase var4, ResourceLocation var5, Class<?> var6) {
-         this.entityId = ☃;
-         this.renderer = ☃;
-         this.model = ☃;
-         this.textureLocation = ☃;
-         this.clazz = ☃;
+      public DataHolder(
+         UUID p_i47463_2_, RenderLivingBase<? extends EntityLivingBase> p_i47463_3_, ModelBase p_i47463_4_, ResourceLocation p_i47463_5_, Class<?> p_i47463_6_
+      ) {
+         this.entityId = p_i47463_2_;
+         this.renderer = p_i47463_3_;
+         this.model = p_i47463_4_;
+         this.textureLocation = p_i47463_5_;
+         this.clazz = p_i47463_6_;
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java b/patches/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java
index 253966d..2742e54 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java
@@ -1,24 +1,57 @@
 package net.minecraft.client.renderer.entity.layers;
 
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.model.ModelRenderer;
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderMooshroom;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.entity.passive.EntityMooshroom;
 import net.minecraft.init.Blocks;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.MathHelper;
 
 public class LayerMooshroomMushroom implements LayerRenderer<EntityMooshroom> {
    private final RenderMooshroom mooshroomRenderer;
+   private ModelRenderer modelRendererMushroom;
+   private static final ResourceLocation LOCATION_MUSHROOM_RED = new ResourceLocation("textures/entity/cow/mushroom_red.png");
+   private static boolean hasTextureMushroom = false;
 
-   public LayerMooshroomMushroom(RenderMooshroom var1) {
-      this.mooshroomRenderer = ☃;
+   public static void update() {
+      hasTextureMushroom = Config.hasResource(LOCATION_MUSHROOM_RED);
    }
 
-   public void doRenderLayer(EntityMooshroom var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (!☃.isChild() && !☃.isInvisible()) {
-         BlockRendererDispatcher ☃ = Minecraft.getMinecraft().getBlockRendererDispatcher();
-         this.mooshroomRenderer.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+   public LayerMooshroomMushroom(RenderMooshroom mooshroomRendererIn) {
+      this.mooshroomRenderer = mooshroomRendererIn;
+      this.modelRendererMushroom = new ModelRenderer(this.mooshroomRenderer.f);
+      this.modelRendererMushroom.setTextureSize(16, 16);
+      this.modelRendererMushroom.rotationPointX = -6.0F;
+      this.modelRendererMushroom.rotationPointZ = -8.0F;
+      this.modelRendererMushroom.rotateAngleY = MathHelper.PI / 4.0F;
+      int[][] faceUvs = new int[][]{null, null, {16, 16, 0, 0}, {16, 16, 0, 0}, null, null};
+      this.modelRendererMushroom.addBox(faceUvs, 0.0F, 0.0F, 10.0F, 20.0F, 16.0F, 0.0F, 0.0F);
+      int[][] faceUvs2 = new int[][]{null, null, null, null, {16, 16, 0, 0}, {16, 16, 0, 0}};
+      this.modelRendererMushroom.addBox(faceUvs2, 10.0F, 0.0F, 0.0F, 0.0F, 16.0F, 20.0F, 0.0F);
+   }
+
+   public void doRenderLayer(
+      EntityMooshroom entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      if (!entitylivingbaseIn.l_() && !entitylivingbaseIn.aX()) {
+         BlockRendererDispatcher blockrendererdispatcher = Minecraft.getMinecraft().getBlockRendererDispatcher();
+         if (hasTextureMushroom) {
+            this.mooshroomRenderer.a(LOCATION_MUSHROOM_RED);
+         } else {
+            this.mooshroomRenderer.a(TextureMap.LOCATION_BLOCKS_TEXTURE);
+         }
+
          GlStateManager.enableCull();
          GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
          GlStateManager.pushMatrix();
@@ -27,29 +60,43 @@ public void doRenderLayer(EntityMooshroom var1, float var2, float var3, float va
          GlStateManager.rotate(42.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.pushMatrix();
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         ☃.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.pushMatrix();
          GlStateManager.translate(0.1F, 0.0F, -0.6F);
          GlStateManager.rotate(42.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         ☃.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.popMatrix();
          GlStateManager.pushMatrix();
-         this.mooshroomRenderer.getMainModel().head.postRender(0.0625F);
+         this.mooshroomRenderer.getMainModel().modelTextureMap.postRender(0.0625F);
          GlStateManager.scale(1.0F, -1.0F, 1.0F);
          GlStateManager.translate(0.0F, 0.7F, -0.2F);
          GlStateManager.rotate(12.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         ☃.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            blockrendererdispatcher.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.cullFace(GlStateManager.CullFace.BACK);
          GlStateManager.disableCull();
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java b/patches/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java
index 60cf20d..0bbf745 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerSheepWool.java
@@ -6,45 +6,59 @@
 import net.minecraft.entity.passive.EntitySheep;
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
 
 public class LayerSheepWool implements LayerRenderer<EntitySheep> {
    private static final ResourceLocation TEXTURE = new ResourceLocation("textures/entity/sheep/sheep_fur.png");
    private final RenderSheep sheepRenderer;
-   private final ModelSheep1 sheepModel = new ModelSheep1();
+   public ModelSheep1 sheepModel = new ModelSheep1();
 
-   public LayerSheepWool(RenderSheep var1) {
-      this.sheepRenderer = ☃;
+   public LayerSheepWool(RenderSheep sheepRendererIn) {
+      this.sheepRenderer = sheepRendererIn;
    }
 
-   public void doRenderLayer(EntitySheep var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (!☃.getSheared() && !☃.isInvisible()) {
+   public void doRenderLayer(
+      EntitySheep entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      if (!entitylivingbaseIn.getSheared() && !entitylivingbaseIn.isInvisible()) {
          this.sheepRenderer.bindTexture(TEXTURE);
-         if (☃.hasCustomName() && "jeb_".equals(☃.getCustomNameTag())) {
-            int ☃ = 25;
-            int ☃x = ☃.ticksExisted / 25 + ☃.getEntityId();
-            int ☃xx = EnumDyeColor.values().length;
-            int ☃xxx = ☃x % ☃xx;
-            int ☃xxxx = (☃x + 1) % ☃xx;
-            float ☃xxxxx = (☃.ticksExisted % 25 + ☃) / 25.0F;
-            float[] ☃xxxxxx = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(☃xxx));
-            float[] ☃xxxxxxx = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(☃xxxx));
-            GlStateManager.color(
-               ☃xxxxxx[0] * (1.0F - ☃xxxxx) + ☃xxxxxxx[0] * ☃xxxxx,
-               ☃xxxxxx[1] * (1.0F - ☃xxxxx) + ☃xxxxxxx[1] * ☃xxxxx,
-               ☃xxxxxx[2] * (1.0F - ☃xxxxx) + ☃xxxxxxx[2] * ☃xxxxx
-            );
+         if (entitylivingbaseIn.hasCustomName() && "jeb_".equals(entitylivingbaseIn.getCustomNameTag())) {
+            int i1 = 25;
+            int i = entitylivingbaseIn.ticksExisted / 25 + entitylivingbaseIn.getEntityId();
+            int j = EnumDyeColor.values().length;
+            int k = i % j;
+            int l = (i + 1) % j;
+            float f = (entitylivingbaseIn.ticksExisted % 25 + partialTicks) / 25.0F;
+            float[] afloat1 = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(k));
+            float[] afloat2 = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(l));
+            if (Config.isCustomColors()) {
+               afloat1 = CustomColors.getSheepColors(EnumDyeColor.byMetadata(k), afloat1);
+               afloat2 = CustomColors.getSheepColors(EnumDyeColor.byMetadata(l), afloat2);
+            }
+
+            GlStateManager.color(afloat1[0] * (1.0F - f) + afloat2[0] * f, afloat1[1] * (1.0F - f) + afloat2[1] * f, afloat1[2] * (1.0F - f) + afloat2[2] * f);
          } else {
-            float[] ☃ = EntitySheep.getDyeRgb(☃.getFleeceColor());
-            GlStateManager.color(☃[0], ☃[1], ☃[2]);
+            float[] afloat = EntitySheep.getDyeRgb(entitylivingbaseIn.getFleeceColor());
+            if (Config.isCustomColors()) {
+               afloat = CustomColors.getSheepColors(entitylivingbaseIn.getFleeceColor(), afloat);
+            }
+
+            GlStateManager.color(afloat[0], afloat[1], afloat[2]);
          }
 
-         this.sheepModel.setModelAttributes(this.sheepRenderer.getMainModel());
-         this.sheepModel.setLivingAnimations(☃, ☃, ☃, ☃);
-         this.sheepModel.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+         this.sheepModel.setModelAttributes(this.sheepRenderer.b());
+         this.sheepModel.setLivingAnimations(entitylivingbaseIn, limbSwing, limbSwingAmount, partialTicks);
+         this.sheepModel.render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java b/patches/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java
index cbee7ba..f885b33 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java
@@ -6,44 +6,56 @@
 import net.minecraft.client.renderer.entity.RenderSpider;
 import net.minecraft.entity.monster.EntitySpider;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerSpiderEyes<T extends EntitySpider> implements LayerRenderer<T> {
    private static final ResourceLocation SPIDER_EYES = new ResourceLocation("textures/entity/spider_eyes.png");
    private final RenderSpider<T> spiderRenderer;
 
-   public LayerSpiderEyes(RenderSpider<T> var1) {
-      this.spiderRenderer = ☃;
+   public LayerSpiderEyes(RenderSpider<T> spiderRendererIn) {
+      this.spiderRenderer = spiderRendererIn;
    }
 
-   public void doRenderLayer(T var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.spiderRenderer.bindTexture(SPIDER_EYES);
+   public void doRenderLayer(
+      T entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale
+   ) {
+      this.spiderRenderer.a(SPIDER_EYES);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
-      if (☃.isInvisible()) {
+      if (entitylivingbaseIn.isInvisible()) {
          GlStateManager.depthMask(false);
       } else {
          GlStateManager.depthMask(true);
       }
 
-      int ☃ = 61680;
-      int ☃x = ☃ % 65536;
-      int ☃xx = ☃ / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃x, ☃xx);
+      int i = 61680;
+      int j = i % 65536;
+      int k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      this.spiderRenderer.getMainModel().render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
+      this.spiderRenderer.b().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-      ☃ = ☃.getBrightnessForRender();
-      ☃x = ☃ % 65536;
-      ☃xx = ☃ / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃x, ☃xx);
-      this.spiderRenderer.setLightmap(☃);
+      i = entitylivingbaseIn.getBrightnessForRender();
+      j = i % 65536;
+      k = i / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
+      this.spiderRenderer.c(entitylivingbaseIn);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
diff --git a/patches/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java b/patches/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java
index e37c6e2..c816af7 100644
--- a/patches/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java
+++ b/patches/net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java
@@ -4,25 +4,38 @@
 import net.minecraft.client.renderer.entity.RenderWolf;
 import net.minecraft.entity.passive.EntityWolf;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
 
 public class LayerWolfCollar implements LayerRenderer<EntityWolf> {
    private static final ResourceLocation WOLF_COLLAR = new ResourceLocation("textures/entity/wolf/wolf_collar.png");
    private final RenderWolf wolfRenderer;
 
-   public LayerWolfCollar(RenderWolf var1) {
-      this.wolfRenderer = ☃;
+   public LayerWolfCollar(RenderWolf wolfRendererIn) {
+      this.wolfRenderer = wolfRendererIn;
    }
 
-   public void doRenderLayer(EntityWolf var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (☃.isTamed() && !☃.isInvisible()) {
-         this.wolfRenderer.bindTexture(WOLF_COLLAR);
-         float[] ☃ = ☃.getCollarColor().getColorComponentValues();
-         GlStateManager.color(☃[0], ☃[1], ☃[2]);
-         this.wolfRenderer.getMainModel().render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+   public void doRenderLayer(
+      EntityWolf entitylivingbaseIn,
+      float limbSwing,
+      float limbSwingAmount,
+      float partialTicks,
+      float ageInTicks,
+      float netHeadYaw,
+      float headPitch,
+      float scale
+   ) {
+      if (entitylivingbaseIn.dl() && !entitylivingbaseIn.isInvisible()) {
+         this.wolfRenderer.a(WOLF_COLLAR);
+         float[] afloat = entitylivingbaseIn.getCollarColor().getColorComponentValues();
+         if (Config.isCustomColors()) {
+            afloat = CustomColors.getWolfCollarColors(entitylivingbaseIn.getCollarColor(), afloat);
+         }
+
+         GlStateManager.color(afloat[0], afloat[1], afloat[2]);
+         this.wolfRenderer.b().render(entitylivingbaseIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
diff --git a/patches/net/minecraft/client/renderer/texture/AbstractTexture.java b/patches/net/minecraft/client/renderer/texture/AbstractTexture.java
index 2a85a24..9d13d7d 100644
--- a/patches/net/minecraft/client/renderer/texture/AbstractTexture.java
+++ b/patches/net/minecraft/client/renderer/texture/AbstractTexture.java
@@ -1,6 +1,8 @@
 package net.minecraft.client.renderer.texture;
 
 import net.minecraft.client.renderer.GlStateManager;
+import net.optifine.shaders.MultiTexID;
+import net.optifine.shaders.ShadersTex;
 
 public abstract class AbstractTexture implements ITextureObject {
    protected int glTextureId = -1;
@@ -8,29 +10,31 @@ public abstract class AbstractTexture implements ITextureObject {
    protected boolean mipmap;
    protected boolean blurLast;
    protected boolean mipmapLast;
+   public MultiTexID multiTex;
 
-   public void setBlurMipmapDirect(boolean var1, boolean var2) {
-      this.blur = ☃;
-      this.mipmap = ☃;
-      int ☃;
-      int ☃x;
-      if (☃) {
-         ☃ = ☃ ? 9987 : 9729;
-         ☃x = 9729;
+   public void setBlurMipmapDirect(boolean blurIn, boolean mipmapIn) {
+      this.blur = blurIn;
+      this.mipmap = mipmapIn;
+      int i;
+      int j;
+      if (blurIn) {
+         i = mipmapIn ? 9987 : 9729;
+         j = 9729;
       } else {
-         ☃ = ☃ ? 9986 : 9728;
-         ☃x = 9728;
+         i = mipmapIn ? 9986 : 9728;
+         j = 9728;
       }
 
-      GlStateManager.glTexParameteri(3553, 10241, ☃);
-      GlStateManager.glTexParameteri(3553, 10240, ☃x);
+      GlStateManager.bindTexture(this.getGlTextureId());
+      GlStateManager.glTexParameteri(3553, 10241, i);
+      GlStateManager.glTexParameteri(3553, 10240, j);
    }
 
    @Override
-   public void setBlurMipmap(boolean var1, boolean var2) {
+   public void setBlurMipmap(boolean blurIn, boolean mipmapIn) {
       this.blurLast = this.blur;
       this.mipmapLast = this.mipmap;
-      this.setBlurMipmapDirect(☃, ☃);
+      this.setBlurMipmapDirect(blurIn, mipmapIn);
    }
 
    @Override
@@ -48,9 +52,15 @@ public int getGlTextureId() {
    }
 
    public void deleteGlTexture() {
+      ShadersTex.deleteTextures(this, this.glTextureId);
       if (this.glTextureId != -1) {
          TextureUtil.deleteTexture(this.glTextureId);
          this.glTextureId = -1;
       }
    }
+
+   @Override
+   public MultiTexID getMultiTexID() {
+      return ShadersTex.getMultiTexID(this);
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/DynamicTexture.java b/patches/net/minecraft/client/renderer/texture/DynamicTexture.java
index bb23a35..3d520d0 100644
--- a/patches/net/minecraft/client/renderer/texture/DynamicTexture.java
+++ b/patches/net/minecraft/client/renderer/texture/DynamicTexture.java
@@ -3,31 +3,47 @@
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import net.minecraft.client.resources.IResourceManager;
+import net.optifine.shaders.ShadersTex;
 
 public class DynamicTexture extends AbstractTexture {
    private final int[] dynamicTextureData;
    private final int width;
    private final int height;
+   private boolean shadersInitialized = false;
 
-   public DynamicTexture(BufferedImage var1) {
-      this(☃.getWidth(), ☃.getHeight());
-      ☃.getRGB(0, 0, ☃.getWidth(), ☃.getHeight(), this.dynamicTextureData, 0, ☃.getWidth());
+   public DynamicTexture(BufferedImage bufferedImage) {
+      this(bufferedImage.getWidth(), bufferedImage.getHeight());
+      bufferedImage.getRGB(0, 0, bufferedImage.getWidth(), bufferedImage.getHeight(), this.dynamicTextureData, 0, bufferedImage.getWidth());
       this.updateDynamicTexture();
    }
 
-   public DynamicTexture(int var1, int var2) {
-      this.width = ☃;
-      this.height = ☃;
-      this.dynamicTextureData = new int[☃ * ☃];
-      TextureUtil.allocateTexture(this.getGlTextureId(), ☃, ☃);
+   public DynamicTexture(int textureWidth, int textureHeight) {
+      this.width = textureWidth;
+      this.height = textureHeight;
+      this.dynamicTextureData = new int[textureWidth * textureHeight * 3];
+      if (Config.isShaders()) {
+         ShadersTex.initDynamicTexture(this.getGlTextureId(), textureWidth, textureHeight, this);
+         this.shadersInitialized = true;
+      } else {
+         TextureUtil.allocateTexture(this.getGlTextureId(), textureWidth, textureHeight);
+      }
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
    }
 
    public void updateDynamicTexture() {
-      TextureUtil.uploadTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height);
+      if (Config.isShaders()) {
+         if (!this.shadersInitialized) {
+            ShadersTex.initDynamicTexture(this.getGlTextureId(), this.width, this.height, this);
+            this.shadersInitialized = true;
+         }
+
+         ShadersTex.updateDynamicTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height, this);
+      } else {
+         TextureUtil.uploadTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height);
+      }
    }
 
    public int[] getTextureData() {
diff --git a/patches/net/minecraft/client/renderer/texture/ITextureObject.java b/patches/net/minecraft/client/renderer/texture/ITextureObject.java
index e3ea8a3..8b31f2d 100644
--- a/patches/net/minecraft/client/renderer/texture/ITextureObject.java
+++ b/patches/net/minecraft/client/renderer/texture/ITextureObject.java
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 import net.minecraft.client.resources.IResourceManager;
+import net.optifine.shaders.MultiTexID;
 
 public interface ITextureObject {
    void setBlurMipmap(boolean var1, boolean var2);
@@ -11,4 +12,6 @@ public interface ITextureObject {
    void loadTexture(IResourceManager var1) throws IOException;
 
    int getGlTextureId();
+
+   MultiTexID getMultiTexID();
 }
diff --git a/patches/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java b/patches/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java
index 81c3df7..2d5b8b4 100644
--- a/patches/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java
+++ b/patches/net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java
@@ -2,6 +2,7 @@
 
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.util.List;
 import net.minecraft.client.resources.IResource;
@@ -9,6 +10,8 @@
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -19,76 +22,84 @@ public class LayeredColorMaskTexture extends AbstractTexture {
    private final List<String> listTextures;
    private final List<EnumDyeColor> listDyeColors;
 
-   public LayeredColorMaskTexture(ResourceLocation var1, List<String> var2, List<EnumDyeColor> var3) {
-      this.textureLocation = ☃;
-      this.listTextures = ☃;
-      this.listDyeColors = ☃;
+   public LayeredColorMaskTexture(ResourceLocation textureLocationIn, List<String> p_i46101_2_, List<EnumDyeColor> p_i46101_3_) {
+      this.textureLocation = textureLocationIn;
+      this.listTextures = p_i46101_2_;
+      this.listDyeColors = p_i46101_3_;
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
       this.deleteGlTexture();
-      IResource ☃ = null;
+      IResource iresource = null;
 
-      BufferedImage ☃x;
-      label198: {
+      BufferedImage bufferedimage;
+      label201: {
          try {
-            ☃ = ☃.getResource(this.textureLocation);
-            BufferedImage ☃xx = TextureUtil.readBufferedImage(☃.getInputStream());
-            int ☃xxx = ☃xx.getType();
-            if (☃xxx == 0) {
-               ☃xxx = 6;
+            iresource = resourceManager.getResource(this.textureLocation);
+            BufferedImage bufferedimage1 = TextureUtil.readBufferedImage(iresource.getInputStream());
+            int i = bufferedimage1.getType();
+            if (i == 0) {
+               i = 6;
             }
 
-            ☃x = new BufferedImage(☃xx.getWidth(), ☃xx.getHeight(), ☃xxx);
-            Graphics ☃xxxx = ☃x.getGraphics();
-            ☃xxxx.drawImage(☃xx, 0, 0, null);
-            int ☃xxxxx = 0;
+            bufferedimage = new BufferedImage(bufferedimage1.getWidth(), bufferedimage1.getHeight(), i);
+            Graphics graphics = bufferedimage.getGraphics();
+            graphics.drawImage(bufferedimage1, 0, 0, (ImageObserver)null);
+            int j = 0;
 
             while (true) {
-               if (☃xxxxx >= 17 || ☃xxxxx >= this.listTextures.size() || ☃xxxxx >= this.listDyeColors.size()) {
-                  break label198;
+               if (j >= 17 || j >= this.listTextures.size() || j >= this.listDyeColors.size()) {
+                  break label201;
                }
 
-               IResource ☃xxxxxx = null;
+               IResource iresource1 = null;
 
                try {
-                  String ☃xxxxxxx = this.listTextures.get(☃xxxxx);
-                  int ☃xxxxxxxx = this.listDyeColors.get(☃xxxxx).getColorValue();
-                  if (☃xxxxxxx != null) {
-                     ☃xxxxxx = ☃.getResource(new ResourceLocation(☃xxxxxxx));
-                     BufferedImage ☃xxxxxxxxx = TextureUtil.readBufferedImage(☃xxxxxx.getInputStream());
-                     if (☃xxxxxxxxx.getWidth() == ☃x.getWidth() && ☃xxxxxxxxx.getHeight() == ☃x.getHeight() && ☃xxxxxxxxx.getType() == 6) {
-                        for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx < ☃xxxxxxxxx.getHeight(); ☃xxxxxxxxxx++) {
-                           for (int ☃xxxxxxxxxxx = 0; ☃xxxxxxxxxxx < ☃xxxxxxxxx.getWidth(); ☃xxxxxxxxxxx++) {
-                              int ☃xxxxxxxxxxxx = ☃xxxxxxxxx.getRGB(☃xxxxxxxxxxx, ☃xxxxxxxxxx);
-                              if ((☃xxxxxxxxxxxx & 0xFF000000) != 0) {
-                                 int ☃xxxxxxxxxxxxx = (☃xxxxxxxxxxxx & 0xFF0000) << 8 & 0xFF000000;
-                                 int ☃xxxxxxxxxxxxxx = ☃xx.getRGB(☃xxxxxxxxxxx, ☃xxxxxxxxxx);
-                                 int ☃xxxxxxxxxxxxxxx = MathHelper.multiplyColor(☃xxxxxxxxxxxxxx, ☃xxxxxxxx) & 16777215;
-                                 ☃xxxxxxxxx.setRGB(☃xxxxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxxxx | ☃xxxxxxxxxxxxxxx);
+                  String s = this.listTextures.get(j);
+                  int k = this.listDyeColors.get(j).getColorValue();
+                  if (s != null) {
+                     iresource1 = resourceManager.getResource(new ResourceLocation(s));
+                     BufferedImage bufferedimage2 = Reflector.MinecraftForgeClient_getImageLayer.exists()
+                        ? (BufferedImage)Reflector.call(Reflector.MinecraftForgeClient_getImageLayer, new Object[]{new ResourceLocation(s), resourceManager})
+                        : TextureUtil.readBufferedImage(iresource1.getInputStream());
+                     if (bufferedimage2.getWidth() == bufferedimage.getWidth()
+                        && bufferedimage2.getHeight() == bufferedimage.getHeight()
+                        && bufferedimage2.getType() == 6) {
+                        for (int l = 0; l < bufferedimage2.getHeight(); l++) {
+                           for (int i1 = 0; i1 < bufferedimage2.getWidth(); i1++) {
+                              int j1 = bufferedimage2.getRGB(i1, l);
+                              if ((j1 & 0xFF000000) != 0) {
+                                 int k1 = (j1 & 0xFF0000) << 8 & 0xFF000000;
+                                 int l1 = bufferedimage1.getRGB(i1, l);
+                                 int i2 = MathHelper.multiplyColor(l1, k) & 16777215;
+                                 bufferedimage2.setRGB(i1, l, k1 | i2);
                               }
                            }
                         }
 
-                        ☃x.getGraphics().drawImage(☃xxxxxxxxx, 0, 0, null);
+                        bufferedimage.getGraphics().drawImage(bufferedimage2, 0, 0, (ImageObserver)null);
                      }
                   }
                } finally {
-                  IOUtils.closeQuietly(☃xxxxxx);
+                  IOUtils.closeQuietly(iresource1);
                }
 
-               ☃xxxxx++;
+               j++;
             }
          } catch (IOException var27) {
             LOGGER.error("Couldn't load layered image", var27);
          } finally {
-            IOUtils.closeQuietly(☃);
+            IOUtils.closeQuietly(iresource);
          }
 
          return;
       }
 
-      TextureUtil.uploadTextureImage(this.getGlTextureId(), ☃x);
+      if (Config.isShaders()) {
+         ShadersTex.loadSimpleTexture(this.getGlTextureId(), bufferedimage, false, false, resourceManager, this.textureLocation, this.getMultiTexID());
+      } else {
+         TextureUtil.uploadTextureImage(this.getGlTextureId(), bufferedimage);
+      }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/LayeredTexture.java b/patches/net/minecraft/client/renderer/texture/LayeredTexture.java
index 186ce3e..b887262 100644
--- a/patches/net/minecraft/client/renderer/texture/LayeredTexture.java
+++ b/patches/net/minecraft/client/renderer/texture/LayeredTexture.java
@@ -2,11 +2,13 @@
 
 import com.google.common.collect.Lists;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.util.List;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -14,39 +16,47 @@
 public class LayeredTexture extends AbstractTexture {
    private static final Logger LOGGER = LogManager.getLogger();
    public final List<String> layeredTextureNames;
+   private ResourceLocation textureLocation;
 
-   public LayeredTexture(String... var1) {
-      this.layeredTextureNames = Lists.newArrayList(☃);
+   public LayeredTexture(String... textureNames) {
+      this.layeredTextureNames = Lists.newArrayList(textureNames);
+      if (textureNames.length > 0 && textureNames[0] != null) {
+         this.textureLocation = new ResourceLocation(textureNames[0]);
+      }
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
       this.deleteGlTexture();
-      BufferedImage ☃ = null;
+      BufferedImage bufferedimage = null;
 
-      for (String ☃x : this.layeredTextureNames) {
-         IResource ☃xx = null;
+      for (String s : this.layeredTextureNames) {
+         IResource iresource = null;
 
          try {
-            if (☃x != null) {
-               ☃xx = ☃.getResource(new ResourceLocation(☃x));
-               BufferedImage ☃xxx = TextureUtil.readBufferedImage(☃xx.getInputStream());
-               if (☃ == null) {
-                  ☃ = new BufferedImage(☃xxx.getWidth(), ☃xxx.getHeight(), 2);
+            if (s != null) {
+               iresource = resourceManager.getResource(new ResourceLocation(s));
+               BufferedImage bufferedimage1 = TextureUtil.readBufferedImage(iresource.getInputStream());
+               if (bufferedimage == null) {
+                  bufferedimage = new BufferedImage(bufferedimage1.getWidth(), bufferedimage1.getHeight(), 2);
                }
 
-               ☃.getGraphics().drawImage(☃xxx, 0, 0, null);
+               bufferedimage.getGraphics().drawImage(bufferedimage1, 0, 0, (ImageObserver)null);
             }
             continue;
          } catch (IOException var10) {
             LOGGER.error("Couldn't load layered image", var10);
          } finally {
-            IOUtils.closeQuietly(☃xx);
+            IOUtils.closeQuietly(iresource);
          }
 
          return;
       }
 
-      TextureUtil.uploadTextureImage(this.getGlTextureId(), ☃);
+      if (Config.isShaders()) {
+         ShadersTex.loadSimpleTexture(this.getGlTextureId(), bufferedimage, false, false, resourceManager, this.textureLocation, this.getMultiTexID());
+      } else {
+         TextureUtil.uploadTextureImage(this.getGlTextureId(), bufferedimage);
+      }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/SimpleTexture.java b/patches/net/minecraft/client/renderer/texture/SimpleTexture.java
index 63ba5e9..d67ab19 100644
--- a/patches/net/minecraft/client/renderer/texture/SimpleTexture.java
+++ b/patches/net/minecraft/client/renderer/texture/SimpleTexture.java
@@ -6,6 +6,8 @@
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.data.TextureMetadataSection;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.EmissiveTextures;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -13,36 +15,46 @@
 public class SimpleTexture extends AbstractTexture {
    private static final Logger LOGGER = LogManager.getLogger();
    protected final ResourceLocation textureLocation;
+   public ResourceLocation locationEmissive;
+   public boolean isEmissive;
 
-   public SimpleTexture(ResourceLocation var1) {
-      this.textureLocation = ☃;
+   public SimpleTexture(ResourceLocation textureResourceLocation) {
+      this.textureLocation = textureResourceLocation;
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
       this.deleteGlTexture();
-      IResource ☃ = null;
+      IResource iresource = null;
 
       try {
-         ☃ = ☃.getResource(this.textureLocation);
-         BufferedImage ☃x = TextureUtil.readBufferedImage(☃.getInputStream());
-         boolean ☃xx = false;
-         boolean ☃xxx = false;
-         if (☃.hasMetadata()) {
+         iresource = resourceManager.getResource(this.textureLocation);
+         BufferedImage bufferedimage = TextureUtil.readBufferedImage(iresource.getInputStream());
+         boolean flag = false;
+         boolean flag1 = false;
+         if (iresource.hasMetadata()) {
             try {
-               TextureMetadataSection ☃xxxx = ☃.getMetadata("texture");
-               if (☃xxxx != null) {
-                  ☃xx = ☃xxxx.getTextureBlur();
-                  ☃xxx = ☃xxxx.getTextureClamp();
+               TextureMetadataSection texturemetadatasection = (TextureMetadataSection)iresource.getMetadata("texture");
+               if (texturemetadatasection != null) {
+                  flag = texturemetadatasection.getTextureBlur();
+                  flag1 = texturemetadatasection.getTextureClamp();
                }
             } catch (RuntimeException var10) {
                LOGGER.warn("Failed reading metadata of: {}", this.textureLocation, var10);
             }
          }
 
-         TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(), ☃x, ☃xx, ☃xxx);
+         if (Config.isShaders()) {
+            ShadersTex.loadSimpleTexture(this.getGlTextureId(), bufferedimage, flag, flag1, resourceManager, this.textureLocation, this.getMultiTexID());
+         } else {
+            TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(), bufferedimage, flag, flag1);
+         }
+
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.loadTexture(this.textureLocation, this);
+         }
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(iresource);
       }
    }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/Stitcher.java b/patches/net/minecraft/client/renderer/texture/Stitcher.java
index 3d29854..5122cc1 100644
--- a/patches/net/minecraft/client/renderer/texture/Stitcher.java
+++ b/patches/net/minecraft/client/renderer/texture/Stitcher.java
@@ -7,6 +7,7 @@
 import java.util.Set;
 import net.minecraft.client.renderer.StitcherException;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.util.MathUtils;
 
 public class Stitcher {
    private final int mipmapLevelStitcher;
@@ -18,11 +19,11 @@ public class Stitcher {
    private final int maxHeight;
    private final int maxTileDimension;
 
-   public Stitcher(int var1, int var2, int var3, int var4) {
-      this.mipmapLevelStitcher = ☃;
-      this.maxWidth = ☃;
-      this.maxHeight = ☃;
-      this.maxTileDimension = ☃;
+   public Stitcher(int maxWidthIn, int maxHeightIn, int maxTileDimensionIn, int mipmapLevelStitcherIn) {
+      this.mipmapLevelStitcher = mipmapLevelStitcherIn;
+      this.maxWidth = maxWidthIn;
+      this.maxHeight = maxHeightIn;
+      this.maxTileDimension = maxTileDimensionIn;
    }
 
    public int getCurrentWidth() {
@@ -33,28 +34,32 @@ public int getCurrentHeight() {
       return this.currentHeight;
    }
 
-   public void addSprite(TextureAtlasSprite var1) {
-      Stitcher.Holder ☃ = new Stitcher.Holder(☃, this.mipmapLevelStitcher);
+   public void addSprite(TextureAtlasSprite textureAtlas) {
+      Stitcher.Holder stitcher$holder = new Stitcher.Holder(textureAtlas, this.mipmapLevelStitcher);
       if (this.maxTileDimension > 0) {
-         ☃.setNewDimension(this.maxTileDimension);
+         stitcher$holder.setNewDimension(this.maxTileDimension);
       }
 
-      this.setStitchHolders.add(☃);
+      this.setStitchHolders.add(stitcher$holder);
    }
 
    public void doStitch() {
-      Stitcher.Holder[] ☃ = this.setStitchHolders.toArray(new Stitcher.Holder[this.setStitchHolders.size()]);
-      Arrays.sort((Object[])☃);
-
-      for (Stitcher.Holder ☃x : ☃) {
-         if (!this.allocateSlot(☃x)) {
-            String ☃xx = String.format(
-               "Unable to fit: %s - size: %dx%d - Maybe try a lowerresolution resourcepack?",
-               ☃x.getAtlasSprite().getIconName(),
-               ☃x.getAtlasSprite().getIconWidth(),
-               ☃x.getAtlasSprite().getIconHeight()
+      Stitcher.Holder[] astitcher$holder = this.setStitchHolders.toArray(new Stitcher.Holder[this.setStitchHolders.size()]);
+      Arrays.sort(astitcher$holder);
+
+      for (Stitcher.Holder stitcher$holder : astitcher$holder) {
+         if (!this.allocateSlot(stitcher$holder)) {
+            String s = String.format(
+               "Unable to fit: %s, size: %dx%d, atlas: %dx%d, atlasMax: %dx%d - Maybe try a lower resolution resourcepack?",
+               stitcher$holder.getAtlasSprite().getIconName(),
+               stitcher$holder.getAtlasSprite().getIconWidth(),
+               stitcher$holder.getAtlasSprite().getIconHeight(),
+               this.currentWidth,
+               this.currentHeight,
+               this.maxWidth,
+               this.maxHeight
             );
-            throw new StitcherException(☃x, ☃xx);
+            throw new StitcherException(stitcher$holder, s);
          }
       }
 
@@ -63,90 +68,89 @@ public void doStitch() {
    }
 
    public List<TextureAtlasSprite> getStichSlots() {
-      List<Stitcher.Slot> ☃ = Lists.newArrayList();
+      List<Stitcher.Slot> list = Lists.newArrayList();
 
-      for (Stitcher.Slot ☃x : this.stitchSlots) {
-         ☃x.getAllStitchSlots(☃);
+      for (Stitcher.Slot stitcher$slot : this.stitchSlots) {
+         stitcher$slot.getAllStitchSlots(list);
       }
 
-      List<TextureAtlasSprite> ☃x = Lists.newArrayList();
+      List<TextureAtlasSprite> list1 = Lists.newArrayList();
 
-      for (Stitcher.Slot ☃xx : ☃) {
-         Stitcher.Holder ☃xxx = ☃xx.getStitchHolder();
-         TextureAtlasSprite ☃xxxx = ☃xxx.getAtlasSprite();
-         ☃xxxx.initSprite(this.currentWidth, this.currentHeight, ☃xx.getOriginX(), ☃xx.getOriginY(), ☃xxx.isRotated());
-         ☃x.add(☃xxxx);
+      for (Stitcher.Slot stitcher$slot1 : list) {
+         Stitcher.Holder stitcher$holder = stitcher$slot1.getStitchHolder();
+         TextureAtlasSprite textureatlassprite = stitcher$holder.getAtlasSprite();
+         textureatlassprite.initSprite(
+            this.currentWidth, this.currentHeight, stitcher$slot1.getOriginX(), stitcher$slot1.getOriginY(), stitcher$holder.isRotated()
+         );
+         list1.add(textureatlassprite);
       }
 
-      return ☃x;
+      return list1;
    }
 
-   private static int getMipmapDimension(int var0, int var1) {
-      return (☃ >> ☃) + ((☃ & (1 << ☃) - 1) == 0 ? 0 : 1) << ☃;
+   private static int getMipmapDimension(int p_147969_0_, int p_147969_1_) {
+      return (p_147969_0_ >> p_147969_1_) + ((p_147969_0_ & (1 << p_147969_1_) - 1) == 0 ? 0 : 1) << p_147969_1_;
    }
 
-   private boolean allocateSlot(Stitcher.Holder var1) {
-      TextureAtlasSprite ☃ = ☃.getAtlasSprite();
-      boolean ☃x = ☃.getIconWidth() != ☃.getIconHeight();
+   private boolean allocateSlot(Stitcher.Holder p_94310_1_) {
+      TextureAtlasSprite textureatlassprite = p_94310_1_.getAtlasSprite();
+      boolean flag = textureatlassprite.getIconWidth() != textureatlassprite.getIconHeight();
 
-      for (int ☃xx = 0; ☃xx < this.stitchSlots.size(); ☃xx++) {
-         if (this.stitchSlots.get(☃xx).addSlot(☃)) {
+      for (int i = 0; i < this.stitchSlots.size(); i++) {
+         if (this.stitchSlots.get(i).addSlot(p_94310_1_)) {
             return true;
          }
 
-         if (☃x) {
-            ☃.rotate();
-            if (this.stitchSlots.get(☃xx).addSlot(☃)) {
+         if (flag) {
+            p_94310_1_.rotate();
+            if (this.stitchSlots.get(i).addSlot(p_94310_1_)) {
                return true;
             }
 
-            ☃.rotate();
+            p_94310_1_.rotate();
          }
       }
 
-      return this.expandAndAllocateSlot(☃);
+      return this.expandAndAllocateSlot(p_94310_1_);
    }
 
-   private boolean expandAndAllocateSlot(Stitcher.Holder var1) {
-      int ☃ = Math.min(☃.getWidth(), ☃.getHeight());
-      int ☃x = Math.max(☃.getWidth(), ☃.getHeight());
-      int ☃xx = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth);
-      int ☃xxx = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight);
-      int ☃xxxx = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth + ☃);
-      int ☃xxxxx = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight + ☃);
-      boolean ☃xxxxxx = ☃xxxx <= this.maxWidth;
-      boolean ☃xxxxxxx = ☃xxxxx <= this.maxHeight;
-      if (!☃xxxxxx && !☃xxxxxxx) {
+   private boolean expandAndAllocateSlot(Stitcher.Holder p_94311_1_) {
+      int i = Math.min(p_94311_1_.getWidth(), p_94311_1_.getHeight());
+      int j = Math.max(p_94311_1_.getWidth(), p_94311_1_.getHeight());
+      int k = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth);
+      int l = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight);
+      int i1 = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth + i);
+      int j1 = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight + i);
+      boolean flag1 = i1 <= this.maxWidth;
+      boolean flag2 = j1 <= this.maxHeight;
+      if (!flag1 && !flag2) {
          return false;
       } else {
-         boolean ☃xxxxxxxx = ☃xxxxxx && ☃xx != ☃xxxx;
-         boolean ☃xxxxxxxxx = ☃xxxxxxx && ☃xxx != ☃xxxxx;
-         boolean ☃xxxxxxxxxx;
-         if (☃xxxxxxxx ^ ☃xxxxxxxxx) {
-            ☃xxxxxxxxxx = ☃xxxxxxxx;
-         } else {
-            ☃xxxxxxxxxx = ☃xxxxxx && ☃xx <= ☃xxx;
+         int po2DownHeight = MathUtils.roundDownToPowerOfTwo(this.currentHeight);
+         boolean flag = flag1 && i1 <= 2 * po2DownHeight;
+         if (this.currentWidth == 0 && this.currentHeight == 0) {
+            flag = true;
          }
 
-         Stitcher.Slot ☃xxxxxxxxxxx;
-         if (☃xxxxxxxxxx) {
-            if (☃.getWidth() > ☃.getHeight()) {
-               ☃.rotate();
+         Stitcher.Slot stitcher$slot;
+         if (flag) {
+            if (p_94311_1_.getWidth() > p_94311_1_.getHeight()) {
+               p_94311_1_.rotate();
             }
 
             if (this.currentHeight == 0) {
-               this.currentHeight = ☃.getHeight();
+               this.currentHeight = p_94311_1_.getHeight();
             }
 
-            ☃xxxxxxxxxxx = new Stitcher.Slot(this.currentWidth, 0, ☃.getWidth(), this.currentHeight);
-            this.currentWidth = this.currentWidth + ☃.getWidth();
+            stitcher$slot = new Stitcher.Slot(this.currentWidth, 0, p_94311_1_.getWidth(), this.currentHeight);
+            this.currentWidth = this.currentWidth + p_94311_1_.getWidth();
          } else {
-            ☃xxxxxxxxxxx = new Stitcher.Slot(0, this.currentHeight, this.currentWidth, ☃.getHeight());
-            this.currentHeight = this.currentHeight + ☃.getHeight();
+            stitcher$slot = new Stitcher.Slot(0, this.currentHeight, this.currentWidth, p_94311_1_.getHeight());
+            this.currentHeight = this.currentHeight + p_94311_1_.getHeight();
          }
 
-         ☃xxxxxxxxxxx.addSlot(☃);
-         this.stitchSlots.add(☃xxxxxxxxxxx);
+         stitcher$slot.addSlot(p_94311_1_);
+         this.stitchSlots.add(stitcher$slot);
          return true;
       }
    }
@@ -159,12 +163,12 @@ public static class Holder implements Comparable<Stitcher.Holder> {
       private boolean rotated;
       private float scaleFactor = 1.0F;
 
-      public Holder(TextureAtlasSprite var1, int var2) {
-         this.sprite = ☃;
-         this.width = ☃.getIconWidth();
-         this.height = ☃.getIconHeight();
-         this.mipmapLevelHolder = ☃;
-         this.rotated = Stitcher.getMipmapDimension(this.height, ☃) > Stitcher.getMipmapDimension(this.width, ☃);
+      public Holder(TextureAtlasSprite theTextureIn, int mipmapLevelHolderIn) {
+         this.sprite = theTextureIn;
+         this.width = theTextureIn.getIconWidth();
+         this.height = theTextureIn.getIconHeight();
+         this.mipmapLevelHolder = mipmapLevelHolderIn;
+         this.rotated = Stitcher.getMipmapDimension(this.height, mipmapLevelHolderIn) > Stitcher.getMipmapDimension(this.width, mipmapLevelHolderIn);
       }
 
       public TextureAtlasSprite getAtlasSprite() {
@@ -172,13 +176,13 @@ public TextureAtlasSprite getAtlasSprite() {
       }
 
       public int getWidth() {
-         int ☃ = this.rotated ? this.height : this.width;
-         return Stitcher.getMipmapDimension((int)(☃ * this.scaleFactor), this.mipmapLevelHolder);
+         int i = this.rotated ? this.height : this.width;
+         return Stitcher.getMipmapDimension((int)(i * this.scaleFactor), this.mipmapLevelHolder);
       }
 
       public int getHeight() {
-         int ☃ = this.rotated ? this.width : this.height;
-         return Stitcher.getMipmapDimension((int)(☃ * this.scaleFactor), this.mipmapLevelHolder);
+         int i = this.rotated ? this.width : this.height;
+         return Stitcher.getMipmapDimension((int)(i * this.scaleFactor), this.mipmapLevelHolder);
       }
 
       public void rotate() {
@@ -189,34 +193,34 @@ public boolean isRotated() {
          return this.rotated;
       }
 
-      public void setNewDimension(int var1) {
-         if (this.width > ☃ && this.height > ☃) {
-            this.scaleFactor = (float)☃ / Math.min(this.width, this.height);
+      public void setNewDimension(int p_94196_1_) {
+         if (this.width > p_94196_1_ && this.height > p_94196_1_) {
+            this.scaleFactor = (float)p_94196_1_ / Math.min(this.width, this.height);
          }
       }
 
       @Override
       public String toString() {
-         return "Holder{width=" + this.width + ", height=" + this.height + '}';
+         return "Holder{width=" + this.width + ", height=" + this.height + ", name=" + this.sprite.getIconName() + '}';
       }
 
-      public int compareTo(Stitcher.Holder var1) {
-         int ☃;
-         if (this.getHeight() == ☃.getHeight()) {
-            if (this.getWidth() == ☃.getWidth()) {
+      public int compareTo(Stitcher.Holder p_compareTo_1_) {
+         int i;
+         if (this.getHeight() == p_compareTo_1_.getHeight()) {
+            if (this.getWidth() == p_compareTo_1_.getWidth()) {
                if (this.sprite.getIconName() == null) {
-                  return ☃.sprite.getIconName() == null ? 0 : -1;
+                  return p_compareTo_1_.sprite.getIconName() == null ? 0 : -1;
                }
 
-               return this.sprite.getIconName().compareTo(☃.sprite.getIconName());
+               return this.sprite.getIconName().compareTo(p_compareTo_1_.sprite.getIconName());
             }
 
-            ☃ = this.getWidth() < ☃.getWidth() ? 1 : -1;
+            i = this.getWidth() < p_compareTo_1_.getWidth() ? 1 : -1;
          } else {
-            ☃ = this.getHeight() < ☃.getHeight() ? 1 : -1;
+            i = this.getHeight() < p_compareTo_1_.getHeight() ? 1 : -1;
          }
 
-         return ☃;
+         return i;
       }
    }
 
@@ -228,11 +232,11 @@ public static class Slot {
       private List<Stitcher.Slot> subSlots;
       private Stitcher.Holder holder;
 
-      public Slot(int var1, int var2, int var3, int var4) {
-         this.originX = ☃;
-         this.originY = ☃;
-         this.width = ☃;
-         this.height = ☃;
+      public Slot(int originXIn, int originYIn, int widthIn, int heightIn) {
+         this.originX = originXIn;
+         this.originY = originYIn;
+         this.width = widthIn;
+         this.height = heightIn;
       }
 
       public Stitcher.Holder getStitchHolder() {
@@ -247,41 +251,41 @@ public int getOriginY() {
          return this.originY;
       }
 
-      public boolean addSlot(Stitcher.Holder var1) {
+      public boolean addSlot(Stitcher.Holder holderIn) {
          if (this.holder != null) {
             return false;
          } else {
-            int ☃ = ☃.getWidth();
-            int ☃x = ☃.getHeight();
-            if (☃ <= this.width && ☃x <= this.height) {
-               if (☃ == this.width && ☃x == this.height) {
-                  this.holder = ☃;
+            int i = holderIn.getWidth();
+            int j = holderIn.getHeight();
+            if (i <= this.width && j <= this.height) {
+               if (i == this.width && j == this.height) {
+                  this.holder = holderIn;
                   return true;
                } else {
                   if (this.subSlots == null) {
                      this.subSlots = Lists.newArrayListWithCapacity(1);
-                     this.subSlots.add(new Stitcher.Slot(this.originX, this.originY, ☃, ☃x));
-                     int ☃xx = this.width - ☃;
-                     int ☃xxx = this.height - ☃x;
-                     if (☃xxx > 0 && ☃xx > 0) {
-                        int ☃xxxx = Math.max(this.height, ☃xx);
-                        int ☃xxxxx = Math.max(this.width, ☃xxx);
-                        if (☃xxxx >= ☃xxxxx) {
-                           this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + ☃x, ☃, ☃xxx));
-                           this.subSlots.add(new Stitcher.Slot(this.originX + ☃, this.originY, ☃xx, this.height));
+                     this.subSlots.add(new Stitcher.Slot(this.originX, this.originY, i, j));
+                     int k = this.width - i;
+                     int l = this.height - j;
+                     if (l > 0 && k > 0) {
+                        int i1 = Math.max(this.height, k);
+                        int j1 = Math.max(this.width, l);
+                        if (i1 >= j1) {
+                           this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + j, i, l));
+                           this.subSlots.add(new Stitcher.Slot(this.originX + i, this.originY, k, this.height));
                         } else {
-                           this.subSlots.add(new Stitcher.Slot(this.originX + ☃, this.originY, ☃xx, ☃x));
-                           this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + ☃x, this.width, ☃xxx));
+                           this.subSlots.add(new Stitcher.Slot(this.originX + i, this.originY, k, j));
+                           this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + j, this.width, l));
                         }
-                     } else if (☃xx == 0) {
-                        this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + ☃x, ☃, ☃xxx));
-                     } else if (☃xxx == 0) {
-                        this.subSlots.add(new Stitcher.Slot(this.originX + ☃, this.originY, ☃xx, ☃x));
+                     } else if (k == 0) {
+                        this.subSlots.add(new Stitcher.Slot(this.originX, this.originY + j, i, l));
+                     } else if (l == 0) {
+                        this.subSlots.add(new Stitcher.Slot(this.originX + i, this.originY, k, j));
                      }
                   }
 
-                  for (Stitcher.Slot ☃xx : this.subSlots) {
-                     if (☃xx.addSlot(☃)) {
+                  for (Stitcher.Slot stitcher$slot : this.subSlots) {
+                     if (stitcher$slot.addSlot(holderIn)) {
                         return true;
                      }
                   }
@@ -294,12 +298,12 @@ public boolean addSlot(Stitcher.Holder var1) {
          }
       }
 
-      public void getAllStitchSlots(List<Stitcher.Slot> var1) {
+      public void getAllStitchSlots(List<Stitcher.Slot> p_94184_1_) {
          if (this.holder != null) {
-            ☃.add(this);
+            p_94184_1_.add(this);
          } else if (this.subSlots != null) {
-            for (Stitcher.Slot ☃ : this.subSlots) {
-               ☃.getAllStitchSlots(☃);
+            for (Stitcher.Slot stitcher$slot : this.subSlots) {
+               stitcher$slot.getAllStitchSlots(p_94184_1_);
             }
          }
       }
diff --git a/patches/net/minecraft/client/renderer/texture/TextureAtlasSprite.java b/patches/net/minecraft/client/renderer/texture/TextureAtlasSprite.java
index af094b6..c3f368e 100644
--- a/patches/net/minecraft/client/renderer/texture/TextureAtlasSprite.java
+++ b/patches/net/minecraft/client/renderer/texture/TextureAtlasSprite.java
@@ -1,10 +1,15 @@
 package net.minecraft.client.renderer.texture;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.awt.image.BufferedImage;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
+import java.util.function.Function;
 import net.minecraft.client.resources.IResource;
+import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.data.AnimationFrame;
 import net.minecraft.client.resources.data.AnimationMetadataSection;
 import net.minecraft.crash.CrashReport;
@@ -12,6 +17,10 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.SmartAnimations;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.CounterInt;
+import net.optifine.util.TextureUtils;
 
 public class TextureAtlasSprite {
    private final String iconName;
@@ -29,37 +38,90 @@ public class TextureAtlasSprite {
    private float maxV;
    protected int frameCounter;
    protected int tickCounter;
-
-   protected TextureAtlasSprite(String var1) {
-      this.iconName = ☃;
+   private int indexInMap = -1;
+   public float baseU;
+   public float baseV;
+   public int sheetWidth;
+   public int sheetHeight;
+   public int glSpriteTextureId = -1;
+   public TextureAtlasSprite spriteSingle = null;
+   public boolean isSpriteSingle = false;
+   public int mipmapLevels = 0;
+   public TextureAtlasSprite spriteNormal = null;
+   public TextureAtlasSprite spriteSpecular = null;
+   public boolean isShadersSprite = false;
+   public boolean isDependencyParent = false;
+   public boolean isEmissive = false;
+   public TextureAtlasSprite spriteEmissive = null;
+   private int animationIndex = -1;
+   private boolean animationActive = false;
+
+   private TextureAtlasSprite(String iconName, boolean isSpritesingle) {
+      this.iconName = iconName;
+      this.isSpriteSingle = isSpritesingle;
+   }
+
+   public TextureAtlasSprite(String spriteName) {
+      this.iconName = spriteName;
+      if (Config.isMultiTexture()) {
+         this.spriteSingle = new TextureAtlasSprite(this.getIconName() + ".spriteSingle", true);
+      }
    }
 
-   protected static TextureAtlasSprite makeAtlasSprite(ResourceLocation var0) {
-      return new TextureAtlasSprite(☃.toString());
-   }
+   protected static TextureAtlasSprite makeAtlasSprite(ResourceLocation spriteResourceLocation) {
+      return new TextureAtlasSprite(spriteResourceLocation.toString());
+   }
+
+   public void initSprite(int inX, int inY, int originInX, int originInY, boolean rotatedIn) {
+      this.originX = originInX;
+      this.originY = originInY;
+      this.rotated = rotatedIn;
+      float f = (float)(0.01F / inX);
+      float f1 = (float)(0.01F / inY);
+      this.minU = originInX / (float)inX + f;
+      this.maxU = (originInX + this.width) / (float)inX - f;
+      this.minV = (float)originInY / inY + f1;
+      this.maxV = (float)(originInY + this.height) / inY - f1;
+      this.baseU = Math.min(this.minU, this.maxU);
+      this.baseV = Math.min(this.minV, this.maxV);
+      if (this.spriteSingle != null) {
+         this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
+      }
+
+      if (this.spriteNormal != null) {
+         this.spriteNormal.copyFrom(this);
+      }
 
-   public void initSprite(int var1, int var2, int var3, int var4, boolean var5) {
-      this.originX = ☃;
-      this.originY = ☃;
-      this.rotated = ☃;
-      float ☃ = (float)(0.01F / ☃);
-      float ☃x = (float)(0.01F / ☃);
-      this.minU = ☃ / (float)☃ + ☃;
-      this.maxU = (☃ + this.width) / (float)☃ - ☃;
-      this.minV = (float)☃ / ☃ + ☃x;
-      this.maxV = (float)(☃ + this.height) / ☃ - ☃x;
+      if (this.spriteSpecular != null) {
+         this.spriteSpecular.copyFrom(this);
+      }
    }
 
-   public void copyFrom(TextureAtlasSprite var1) {
-      this.originX = ☃.originX;
-      this.originY = ☃.originY;
-      this.width = ☃.width;
-      this.height = ☃.height;
-      this.rotated = ☃.rotated;
-      this.minU = ☃.minU;
-      this.maxU = ☃.maxU;
-      this.minV = ☃.minV;
-      this.maxV = ☃.maxV;
+   public void copyFrom(TextureAtlasSprite atlasSpirit) {
+      this.originX = atlasSpirit.originX;
+      this.originY = atlasSpirit.originY;
+      this.width = atlasSpirit.width;
+      this.height = atlasSpirit.height;
+      this.rotated = atlasSpirit.rotated;
+      this.minU = atlasSpirit.minU;
+      this.maxU = atlasSpirit.maxU;
+      this.minV = atlasSpirit.minV;
+      this.maxV = atlasSpirit.maxV;
+      if (atlasSpirit != Config.getTextureMap().getMissingSprite()) {
+         this.indexInMap = atlasSpirit.indexInMap;
+      }
+
+      this.baseU = atlasSpirit.baseU;
+      this.baseV = atlasSpirit.baseV;
+      this.sheetWidth = atlasSpirit.sheetWidth;
+      this.sheetHeight = atlasSpirit.sheetHeight;
+      this.glSpriteTextureId = atlasSpirit.glSpriteTextureId;
+      this.mipmapLevels = atlasSpirit.mipmapLevels;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
+      }
+
+      this.animationIndex = atlasSpirit.animationIndex;
    }
 
    public int getOriginX() {
@@ -86,14 +148,14 @@ public float getMaxU() {
       return this.maxU;
    }
 
-   public float getInterpolatedU(double var1) {
-      float ☃ = this.maxU - this.minU;
-      return this.minU + ☃ * (float)☃ / 16.0F;
+   public float getInterpolatedU(double u) {
+      float f = this.maxU - this.minU;
+      return this.minU + f * (float)u / 16.0F;
    }
 
-   public float getUnInterpolatedU(float var1) {
-      float ☃ = this.maxU - this.minU;
-      return (☃ - this.minU) / ☃ * 16.0F;
+   public float getUnInterpolatedU(float u) {
+      float f = this.maxU - this.minU;
+      return (u - this.minU) / f * 16.0F;
    }
 
    public float getMinV() {
@@ -104,14 +166,14 @@ public float getMaxV() {
       return this.maxV;
    }
 
-   public float getInterpolatedV(double var1) {
-      float ☃ = this.maxV - this.minV;
-      return this.minV + ☃ * (float)☃ / 16.0F;
+   public float getInterpolatedV(double v) {
+      float f = this.maxV - this.minV;
+      return this.minV + f * (float)v / 16.0F;
    }
 
-   public float getUnInterpolatedV(float var1) {
-      float ☃ = this.maxV - this.minV;
-      return (☃ - this.minV) / ☃ * 16.0F;
+   public float getUnInterpolatedV(float p_188536_1_) {
+      float f = this.maxV - this.minV;
+      return (p_188536_1_ - this.minV) / f * 16.0F;
    }
 
    public String getIconName() {
@@ -119,46 +181,59 @@ public String getIconName() {
    }
 
    public void updateAnimation() {
-      this.tickCounter++;
-      if (this.tickCounter >= this.animationMetadata.getFrameTimeSingle(this.frameCounter)) {
-         int ☃ = this.animationMetadata.getFrameIndex(this.frameCounter);
-         int ☃x = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
-         this.frameCounter = (this.frameCounter + 1) % ☃x;
-         this.tickCounter = 0;
-         int ☃xx = this.animationMetadata.getFrameIndex(this.frameCounter);
-         if (☃ != ☃xx && ☃xx >= 0 && ☃xx < this.framesTextureData.size()) {
-            TextureUtil.uploadTextureMipmap(this.framesTextureData.get(☃xx), this.width, this.height, this.originX, this.originY, false, false);
+      if (this.animationMetadata != null) {
+         this.animationActive = SmartAnimations.isActive() ? SmartAnimations.isSpriteRendered(this.animationIndex) : true;
+         this.tickCounter++;
+         if (this.tickCounter >= this.animationMetadata.getFrameTimeSingle(this.frameCounter)) {
+            int i = this.animationMetadata.getFrameIndex(this.frameCounter);
+            int j = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
+            this.frameCounter = (this.frameCounter + 1) % j;
+            this.tickCounter = 0;
+            int k = this.animationMetadata.getFrameIndex(this.frameCounter);
+            boolean texBlur = false;
+            boolean texClamp = this.isSpriteSingle;
+            if (!this.animationActive) {
+               return;
+            }
+
+            if (i != k && k >= 0 && k < this.framesTextureData.size()) {
+               TextureUtil.uploadTextureMipmap(this.framesTextureData.get(k), this.width, this.height, this.originX, this.originY, texBlur, texClamp);
+            }
+         } else if (this.animationMetadata.isInterpolate()) {
+            if (!this.animationActive) {
+               return;
+            }
+
+            this.updateAnimationInterpolated();
          }
-      } else if (this.animationMetadata.isInterpolate()) {
-         this.updateAnimationInterpolated();
       }
    }
 
    private void updateAnimationInterpolated() {
-      double ☃ = 1.0 - (double)this.tickCounter / this.animationMetadata.getFrameTimeSingle(this.frameCounter);
-      int ☃x = this.animationMetadata.getFrameIndex(this.frameCounter);
-      int ☃xx = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
-      int ☃xxx = this.animationMetadata.getFrameIndex((this.frameCounter + 1) % ☃xx);
-      if (☃x != ☃xxx && ☃xxx >= 0 && ☃xxx < this.framesTextureData.size()) {
-         int[][] ☃xxxx = this.framesTextureData.get(☃x);
-         int[][] ☃xxxxx = this.framesTextureData.get(☃xxx);
-         if (this.interpolatedFrameData == null || this.interpolatedFrameData.length != ☃xxxx.length) {
-            this.interpolatedFrameData = new int[☃xxxx.length][];
+      double d0 = 1.0 - (double)this.tickCounter / this.animationMetadata.getFrameTimeSingle(this.frameCounter);
+      int i = this.animationMetadata.getFrameIndex(this.frameCounter);
+      int j = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
+      int k = this.animationMetadata.getFrameIndex((this.frameCounter + 1) % j);
+      if (i != k && k >= 0 && k < this.framesTextureData.size()) {
+         int[][] aint = this.framesTextureData.get(i);
+         int[][] aint1 = this.framesTextureData.get(k);
+         if (this.interpolatedFrameData == null || this.interpolatedFrameData.length != aint.length) {
+            this.interpolatedFrameData = new int[aint.length][];
          }
 
-         for (int ☃xxxxxx = 0; ☃xxxxxx < ☃xxxx.length; ☃xxxxxx++) {
-            if (this.interpolatedFrameData[☃xxxxxx] == null) {
-               this.interpolatedFrameData[☃xxxxxx] = new int[☃xxxx[☃xxxxxx].length];
+         for (int l = 0; l < aint.length; l++) {
+            if (this.interpolatedFrameData[l] == null) {
+               this.interpolatedFrameData[l] = new int[aint[l].length];
             }
 
-            if (☃xxxxxx < ☃xxxxx.length && ☃xxxxx[☃xxxxxx].length == ☃xxxx[☃xxxxxx].length) {
-               for (int ☃xxxxxxx = 0; ☃xxxxxxx < ☃xxxx[☃xxxxxx].length; ☃xxxxxxx++) {
-                  int ☃xxxxxxxx = ☃xxxx[☃xxxxxx][☃xxxxxxx];
-                  int ☃xxxxxxxxx = ☃xxxxx[☃xxxxxx][☃xxxxxxx];
-                  int ☃xxxxxxxxxx = this.interpolateColor(☃, ☃xxxxxxxx >> 16 & 0xFF, ☃xxxxxxxxx >> 16 & 0xFF);
-                  int ☃xxxxxxxxxxx = this.interpolateColor(☃, ☃xxxxxxxx >> 8 & 0xFF, ☃xxxxxxxxx >> 8 & 0xFF);
-                  int ☃xxxxxxxxxxxx = this.interpolateColor(☃, ☃xxxxxxxx & 0xFF, ☃xxxxxxxxx & 0xFF);
-                  this.interpolatedFrameData[☃xxxxxx][☃xxxxxxx] = ☃xxxxxxxx & 0xFF000000 | ☃xxxxxxxxxx << 16 | ☃xxxxxxxxxxx << 8 | ☃xxxxxxxxxxxx;
+            if (l < aint1.length && aint1[l].length == aint[l].length) {
+               for (int i1 = 0; i1 < aint[l].length; i1++) {
+                  int j1 = aint[l][i1];
+                  int k1 = aint1[l][i1];
+                  int l1 = this.interpolateColor(d0, j1 >> 16 & 0xFF, k1 >> 16 & 0xFF);
+                  int i2 = this.interpolateColor(d0, j1 >> 8 & 0xFF, k1 >> 8 & 0xFF);
+                  int j2 = this.interpolateColor(d0, j1 & 0xFF, k1 & 0xFF);
+                  this.interpolatedFrameData[l][i1] = j1 & 0xFF000000 | l1 << 16 | i2 << 8 | j2;
                }
             }
          }
@@ -167,138 +242,189 @@ private void updateAnimationInterpolated() {
       }
    }
 
-   private int interpolateColor(double var1, int var3, int var4) {
-      return (int)(☃ * ☃ + (1.0 - ☃) * ☃);
+   private int interpolateColor(double p_188535_1_, int p_188535_3_, int p_188535_4_) {
+      return (int)(p_188535_1_ * p_188535_3_ + (1.0 - p_188535_1_) * p_188535_4_);
    }
 
-   public int[][] getFrameTextureData(int var1) {
-      return this.framesTextureData.get(☃);
+   public int[][] getFrameTextureData(int index) {
+      return this.framesTextureData.get(index);
    }
 
    public int getFrameCount() {
       return this.framesTextureData.size();
    }
 
-   public void setIconWidth(int var1) {
-      this.width = ☃;
+   public void setIconWidth(int newWidth) {
+      this.width = newWidth;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setIconWidth(this.width);
+      }
    }
 
-   public void setIconHeight(int var1) {
-      this.height = ☃;
+   public void setIconHeight(int newHeight) {
+      this.height = newHeight;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setIconHeight(this.height);
+      }
    }
 
-   public void loadSprite(PngSizeInfo var1, boolean var2) throws IOException {
+   public void loadSprite(PngSizeInfo sizeInfo, boolean p_188538_2_) throws IOException {
       this.resetSprite();
-      this.width = ☃.pngWidth;
-      this.height = ☃.pngHeight;
-      if (☃) {
+      this.width = sizeInfo.pngWidth;
+      this.height = sizeInfo.pngHeight;
+      if (p_188538_2_) {
          this.height = this.width;
-      } else if (☃.pngHeight != ☃.pngWidth) {
+      } else if (sizeInfo.pngHeight != sizeInfo.pngWidth) {
          throw new RuntimeException("broken aspect ratio and not an animation");
       }
+
+      if (this.spriteSingle != null) {
+         this.spriteSingle.width = this.width;
+         this.spriteSingle.height = this.height;
+      }
    }
 
-   public void loadSpriteFrames(IResource var1, int var2) throws IOException {
-      BufferedImage ☃ = TextureUtil.readBufferedImage(☃.getInputStream());
-      AnimationMetadataSection ☃x = ☃.getMetadata("animation");
-      int[][] ☃xx = new int[☃][];
-      ☃xx[0] = new int[☃.getWidth() * ☃.getHeight()];
-      ☃.getRGB(0, 0, ☃.getWidth(), ☃.getHeight(), ☃xx[0], 0, ☃.getWidth());
-      if (☃x == null) {
-         this.framesTextureData.add(☃xx);
+   public void loadSpriteFrames(IResource resource, int mipmaplevels) throws IOException {
+      BufferedImage bufferedimage = TextureUtil.readBufferedImage(resource.getInputStream());
+      if (this.width != bufferedimage.getWidth()) {
+         bufferedimage = TextureUtils.scaleImage(bufferedimage, this.width);
+      }
+
+      AnimationMetadataSection animationmetadatasection = (AnimationMetadataSection)resource.getMetadata("animation");
+      int[][] aint = new int[mipmaplevels][];
+      aint[0] = new int[bufferedimage.getWidth() * bufferedimage.getHeight()];
+      bufferedimage.getRGB(0, 0, bufferedimage.getWidth(), bufferedimage.getHeight(), aint[0], 0, bufferedimage.getWidth());
+      if (animationmetadatasection == null) {
+         this.framesTextureData.add(aint);
       } else {
-         int ☃xxx = ☃.getHeight() / this.width;
-         if (☃x.getFrameCount() > 0) {
-            for (int ☃xxxx : ☃x.getFrameIndexSet()) {
-               if (☃xxxx >= ☃xxx) {
-                  throw new RuntimeException("invalid frameindex " + ☃xxxx);
+         int i = bufferedimage.getHeight() / this.width;
+         if (animationmetadatasection.getFrameCount() > 0) {
+            for (int j : animationmetadatasection.getFrameIndexSet()) {
+               if (j >= i) {
+                  throw new RuntimeException("invalid frameindex " + j);
                }
 
-               this.allocateFrameTextureData(☃xxxx);
-               this.framesTextureData.set(☃xxxx, getFrameTextureData(☃xx, this.width, this.width, ☃xxxx));
+               this.allocateFrameTextureData(j);
+               this.framesTextureData.set(j, getFrameTextureData(aint, this.width, this.width, j));
             }
 
-            this.animationMetadata = ☃x;
+            this.animationMetadata = animationmetadatasection;
          } else {
-            List<AnimationFrame> ☃xxxx = Lists.newArrayList();
+            List<AnimationFrame> list = Lists.newArrayList();
 
-            for (int ☃xxxxx = 0; ☃xxxxx < ☃xxx; ☃xxxxx++) {
-               this.framesTextureData.add(getFrameTextureData(☃xx, this.width, this.width, ☃xxxxx));
-               ☃xxxx.add(new AnimationFrame(☃xxxxx, -1));
+            for (int k = 0; k < i; k++) {
+               this.framesTextureData.add(getFrameTextureData(aint, this.width, this.width, k));
+               list.add(new AnimationFrame(k, -1));
             }
 
-            this.animationMetadata = new AnimationMetadataSection(☃xxxx, this.width, this.height, ☃x.getFrameTime(), ☃x.isInterpolate());
+            this.animationMetadata = new AnimationMetadataSection(
+               list, this.width, this.height, animationmetadatasection.getFrameTime(), animationmetadatasection.isInterpolate()
+            );
+         }
+      }
+
+      if (!this.isShadersSprite) {
+         if (Config.isShaders()) {
+            this.loadShadersSprites();
+         }
+
+         for (int ix = 0; ix < this.framesTextureData.size(); ix++) {
+            int[][] datas = this.framesTextureData.get(ix);
+            if (datas != null && !this.iconName.startsWith("minecraft:blocks/leaves_")) {
+               for (int di = 0; di < datas.length; di++) {
+                  int[] data = datas[di];
+                  this.fixTransparentColor(data);
+               }
+            }
+         }
+
+         if (this.spriteSingle != null) {
+            IResource resourceSingle = Config.getResourceManager().getResource(resource.getResourceLocation());
+            this.spriteSingle.loadSpriteFrames(resourceSingle, mipmaplevels);
          }
       }
    }
 
-   public void generateMipmaps(int var1) {
-      List<int[][]> ☃ = Lists.newArrayList();
+   public void generateMipmaps(int level) {
+      List<int[][]> list = Lists.newArrayList();
 
-      for (int ☃x = 0; ☃x < this.framesTextureData.size(); ☃x++) {
-         final int[][] ☃xx = this.framesTextureData.get(☃x);
-         if (☃xx != null) {
+      for (int i = 0; i < this.framesTextureData.size(); i++) {
+         final int[][] aint = this.framesTextureData.get(i);
+         if (aint != null) {
             try {
-               ☃.add(TextureUtil.generateMipmapData(☃, this.width, ☃xx));
+               list.add(TextureUtil.generateMipmapData(level, this.width, aint));
             } catch (Throwable var8) {
-               CrashReport ☃xxx = CrashReport.makeCrashReport(var8, "Generating mipmaps for frame");
-               CrashReportCategory ☃xxxx = ☃xxx.makeCategory("Frame being iterated");
-               ☃xxxx.addCrashSection("Frame index", ☃x);
-               ☃xxxx.addDetail("Frame sizes", new ICrashReportDetail<String>() {
+               CrashReport crashreport = CrashReport.makeCrashReport(var8, "Generating mipmaps for frame");
+               CrashReportCategory crashreportcategory = crashreport.makeCategory("Frame being iterated");
+               crashreportcategory.addCrashSection("Frame index", i);
+               crashreportcategory.addDetail("Frame sizes", new ICrashReportDetail<String>() {
                   public String call() throws Exception {
-                     StringBuilder ☃xxxxx = new StringBuilder();
+                     StringBuilder stringbuilder = new StringBuilder();
 
-                     for (int[] ☃x : ☃) {
-                        if (☃xxxxx.length() > 0) {
-                           ☃xxxxx.append(", ");
+                     for (int[] aint1 : aint) {
+                        if (stringbuilder.length() > 0) {
+                           stringbuilder.append(", ");
                         }
 
-                        ☃xxxxx.append(☃x == null ? "null" : ☃x.length);
+                        stringbuilder.append(aint1 == null ? "null" : aint1.length);
                      }
 
-                     return ☃xxxxx.toString();
+                     return stringbuilder.toString();
                   }
                });
-               throw new ReportedException(☃xxx);
+               throw new ReportedException(crashreport);
             }
          }
       }
 
-      this.setFramesTextureData(☃);
+      this.setFramesTextureData(list);
+      if (this.spriteSingle != null) {
+         this.spriteSingle.generateMipmaps(level);
+      }
    }
 
-   private void allocateFrameTextureData(int var1) {
-      if (this.framesTextureData.size() <= ☃) {
-         for (int ☃ = this.framesTextureData.size(); ☃ <= ☃; ☃++) {
+   private void allocateFrameTextureData(int index) {
+      if (this.framesTextureData.size() <= index) {
+         for (int i = this.framesTextureData.size(); i <= index; i++) {
             this.framesTextureData.add(null);
          }
       }
+
+      if (this.spriteSingle != null) {
+         this.spriteSingle.allocateFrameTextureData(index);
+      }
    }
 
-   private static int[][] getFrameTextureData(int[][] var0, int var1, int var2, int var3) {
-      int[][] ☃ = new int[☃.length][];
+   private static int[][] getFrameTextureData(int[][] data, int rows, int columns, int p_147962_3_) {
+      int[][] aint = new int[data.length][];
 
-      for (int ☃x = 0; ☃x < ☃.length; ☃x++) {
-         int[] ☃xx = ☃[☃x];
-         if (☃xx != null) {
-            ☃[☃x] = new int[(☃ >> ☃x) * (☃ >> ☃x)];
-            System.arraycopy(☃xx, ☃ * ☃[☃x].length, ☃[☃x], 0, ☃[☃x].length);
+      for (int i = 0; i < data.length; i++) {
+         int[] aint1 = data[i];
+         if (aint1 != null) {
+            aint[i] = new int[(rows >> i) * (columns >> i)];
+            System.arraycopy(aint1, p_147962_3_ * aint[i].length, aint[i], 0, aint[i].length);
          }
       }
 
-      return ☃;
+      return aint;
    }
 
    public void clearFramesTextureData() {
       this.framesTextureData.clear();
+      if (this.spriteSingle != null) {
+         this.spriteSingle.clearFramesTextureData();
+      }
    }
 
    public boolean hasAnimationMetadata() {
       return this.animationMetadata != null;
    }
 
-   public void setFramesTextureData(List<int[][]> var1) {
-      this.framesTextureData = ☃;
+   public void setFramesTextureData(List<int[][]> newFramesTextureData) {
+      this.framesTextureData = newFramesTextureData;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setFramesTextureData(newFramesTextureData);
+      }
    }
 
    private void resetSprite() {
@@ -306,6 +432,9 @@ private void resetSprite() {
       this.setFramesTextureData(Lists.newArrayList());
       this.frameCounter = 0;
       this.tickCounter = 0;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.resetSprite();
+      }
    }
 
    @Override
@@ -335,4 +464,166 @@ public String toString() {
          + this.maxV
          + '}';
    }
+
+   public boolean hasCustomLoader(IResourceManager manager, ResourceLocation location) {
+      return false;
+   }
+
+   public boolean load(IResourceManager manager, ResourceLocation location, Function<ResourceLocation, TextureAtlasSprite> textureGetter) {
+      return true;
+   }
+
+   public Collection<ResourceLocation> getDependencies() {
+      return ImmutableList.of();
+   }
+
+   public int getIndexInMap() {
+      return this.indexInMap;
+   }
+
+   public void setIndexInMap(int indexInMap) {
+      this.indexInMap = indexInMap;
+   }
+
+   public void updateIndexInMap(CounterInt counter) {
+      if (this.indexInMap < 0) {
+         this.indexInMap = counter.nextValue();
+      }
+   }
+
+   public int getAnimationIndex() {
+      return this.animationIndex;
+   }
+
+   public void setAnimationIndex(int animationIndex) {
+      this.animationIndex = animationIndex;
+      if (this.spriteNormal != null) {
+         this.spriteNormal.setAnimationIndex(animationIndex);
+      }
+
+      if (this.spriteSpecular != null) {
+         this.spriteSpecular.setAnimationIndex(animationIndex);
+      }
+   }
+
+   public boolean isAnimationActive() {
+      return this.animationActive;
+   }
+
+   private void fixTransparentColor(int[] data) {
+      if (data != null) {
+         long redSum = 0L;
+         long greenSum = 0L;
+         long blueSum = 0L;
+         long count = 0L;
+
+         for (int i = 0; i < data.length; i++) {
+            int col = data[i];
+            int alpha = col >> 24 & 0xFF;
+            if (alpha >= 16) {
+               int red = col >> 16 & 0xFF;
+               int green = col >> 8 & 0xFF;
+               int blue = col & 0xFF;
+               redSum += red;
+               greenSum += green;
+               blueSum += blue;
+               count++;
+            }
+         }
+
+         if (count > 0L) {
+            int redAvg = (int)(redSum / count);
+            int greenAvg = (int)(greenSum / count);
+            int blueAvg = (int)(blueSum / count);
+            int colAvg = redAvg << 16 | greenAvg << 8 | blueAvg;
+
+            for (int ix = 0; ix < data.length; ix++) {
+               int col = data[ix];
+               int alpha = col >> 24 & 0xFF;
+               if (alpha <= 16) {
+                  data[ix] = colAvg;
+               }
+            }
+         }
+      }
+   }
+
+   public double getSpriteU16(float atlasU) {
+      float dU = this.maxU - this.minU;
+      return (atlasU - this.minU) / dU * 16.0F;
+   }
+
+   public double getSpriteV16(float atlasV) {
+      float dV = this.maxV - this.minV;
+      return (atlasV - this.minV) / dV * 16.0F;
+   }
+
+   public void bindSpriteTexture() {
+      if (this.glSpriteTextureId < 0) {
+         this.glSpriteTextureId = TextureUtil.glGenTextures();
+         TextureUtil.allocateTextureImpl(this.glSpriteTextureId, this.mipmapLevels, this.width, this.height);
+         TextureUtils.applyAnisotropicLevel();
+      }
+
+      TextureUtils.bindTexture(this.glSpriteTextureId);
+   }
+
+   public void deleteSpriteTexture() {
+      if (this.glSpriteTextureId >= 0) {
+         TextureUtil.deleteTexture(this.glSpriteTextureId);
+         this.glSpriteTextureId = -1;
+      }
+   }
+
+   public float toSingleU(float u) {
+      u -= this.baseU;
+      float ku = (float)this.sheetWidth / this.width;
+      return u * ku;
+   }
+
+   public float toSingleV(float v) {
+      v -= this.baseV;
+      float kv = (float)this.sheetHeight / this.height;
+      return v * kv;
+   }
+
+   public List<int[][]> getFramesTextureData() {
+      List<int[][]> datas = new ArrayList<>();
+      datas.addAll(this.framesTextureData);
+      return datas;
+   }
+
+   public AnimationMetadataSection getAnimationMetadata() {
+      return this.animationMetadata;
+   }
+
+   public void setAnimationMetadata(AnimationMetadataSection animationMetadata) {
+      this.animationMetadata = animationMetadata;
+   }
+
+   private void loadShadersSprites() {
+      if (Shaders.configNormalMap) {
+         String nameNormal = this.iconName + "_n";
+         ResourceLocation locNormal = new ResourceLocation(nameNormal);
+         locNormal = Config.getTextureMap().completeResourceLocation(locNormal);
+         if (Config.hasResource(locNormal)) {
+            this.spriteNormal = new TextureAtlasSprite(nameNormal);
+            this.spriteNormal.isShadersSprite = true;
+            this.spriteNormal.copyFrom(this);
+            Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteNormal);
+         }
+      }
+
+      if (Shaders.configSpecularMap) {
+         String nameSpecular = this.iconName + "_s";
+         ResourceLocation locSpecular = new ResourceLocation(nameSpecular);
+         locSpecular = Config.getTextureMap().completeResourceLocation(locSpecular);
+         if (Config.hasResource(locSpecular)) {
+            this.spriteSpecular = new TextureAtlasSprite(nameSpecular);
+            this.spriteSpecular.isShadersSprite = true;
+            this.spriteSpecular.copyFrom(this);
+            Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteSpecular);
+         }
+      }
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/TextureManager.java b/patches/net/minecraft/client/renderer/texture/TextureManager.java
index da66436..bfb4316 100644
--- a/patches/net/minecraft/client/renderer/texture/TextureManager.java
+++ b/patches/net/minecraft/client/renderer/texture/TextureManager.java
@@ -3,9 +3,11 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.io.IOException;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.Map.Entry;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
@@ -14,6 +16,10 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomGuis;
+import net.optifine.EmissiveTextures;
+import net.optifine.RandomEntities;
+import net.optifine.shaders.ShadersTex;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -24,103 +30,165 @@ public class TextureManager implements ITickable, IResourceManagerReloadListener
    private final List<ITickable> listTickables = Lists.newArrayList();
    private final Map<String, Integer> mapTextureCounters = Maps.newHashMap();
    private final IResourceManager resourceManager;
+   private ITextureObject boundTexture;
+   private ResourceLocation boundTextureLocation;
 
-   public TextureManager(IResourceManager var1) {
-      this.resourceManager = ☃;
+   public TextureManager(IResourceManager resourceManager) {
+      this.resourceManager = resourceManager;
    }
 
-   public void bindTexture(ResourceLocation var1) {
-      ITextureObject ☃ = this.mapTextureObjects.get(☃);
-      if (☃ == null) {
-         ☃ = new SimpleTexture(☃);
-         this.loadTexture(☃, ☃);
+   public void bindTexture(ResourceLocation resource) {
+      if (Config.isRandomEntities()) {
+         resource = RandomEntities.getTextureLocation(resource);
       }
 
-      TextureUtil.bindTexture(☃.getGlTextureId());
+      if (Config.isCustomGuis()) {
+         resource = CustomGuis.getTextureLocation(resource);
+      }
+
+      ITextureObject itextureobject = this.mapTextureObjects.get(resource);
+      if (EmissiveTextures.isActive()) {
+         itextureobject = EmissiveTextures.getEmissiveTexture(itextureobject, this.mapTextureObjects);
+      }
+
+      if (itextureobject == null) {
+         itextureobject = new SimpleTexture(resource);
+         this.loadTexture(resource, itextureobject);
+      }
+
+      if (Config.isShaders()) {
+         ShadersTex.bindTexture(itextureobject);
+      } else {
+         TextureUtil.bindTexture(itextureobject.getGlTextureId());
+      }
+
+      this.boundTexture = itextureobject;
+      this.boundTextureLocation = resource;
    }
 
-   public boolean loadTickableTexture(ResourceLocation var1, ITickableTextureObject var2) {
-      if (this.loadTexture(☃, ☃)) {
-         this.listTickables.add(☃);
+   public boolean loadTickableTexture(ResourceLocation textureLocation, ITickableTextureObject textureObj) {
+      if (this.loadTexture(textureLocation, textureObj)) {
+         this.listTickables.add(textureObj);
          return true;
       } else {
          return false;
       }
    }
 
-   public boolean loadTexture(ResourceLocation var1, final ITextureObject var2) {
-      boolean ☃ = true;
+   public boolean loadTexture(ResourceLocation textureLocation, final ITextureObject textureObj) {
+      boolean flag = true;
 
       try {
-         ☃.loadTexture(this.resourceManager);
+         textureObj.loadTexture(this.resourceManager);
       } catch (IOException var8) {
-         if (☃ != RESOURCE_LOCATION_EMPTY) {
-            LOGGER.warn("Failed to load texture: {}", ☃, var8);
+         if (textureLocation != RESOURCE_LOCATION_EMPTY) {
+            LOGGER.warn("Failed to load texture: {}", textureLocation, var8);
          }
 
-         ☃ = TextureUtil.MISSING_TEXTURE;
-         this.mapTextureObjects.put(☃, ☃);
-         ☃ = false;
+         textureObj = TextureUtil.MISSING_TEXTURE;
+         this.mapTextureObjects.put(textureLocation, textureObj);
+         flag = false;
       } catch (Throwable var9) {
-         CrashReport ☃x = CrashReport.makeCrashReport(var9, "Registering texture");
-         CrashReportCategory ☃xx = ☃x.makeCategory("Resource location being registered");
-         ☃xx.addCrashSection("Resource location", ☃);
-         ☃xx.addDetail("Texture object class", new ICrashReportDetail<String>() {
+         CrashReport crashreport = CrashReport.makeCrashReport(var9, "Registering texture");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Resource location being registered");
+         crashreportcategory.addCrashSection("Resource location", textureLocation);
+         crashreportcategory.addDetail("Texture object class", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return ☃.getClass().getName();
+               return textureObj.getClass().getName();
             }
          });
-         throw new ReportedException(☃x);
+         throw new ReportedException(crashreport);
       }
 
-      this.mapTextureObjects.put(☃, ☃);
-      return ☃;
+      this.mapTextureObjects.put(textureLocation, textureObj);
+      return flag;
    }
 
-   public ITextureObject getTexture(ResourceLocation var1) {
-      return this.mapTextureObjects.get(☃);
+   public ITextureObject getTexture(ResourceLocation textureLocation) {
+      return this.mapTextureObjects.get(textureLocation);
    }
 
-   public ResourceLocation getDynamicTextureLocation(String var1, DynamicTexture var2) {
-      Integer ☃ = this.mapTextureCounters.get(☃);
-      if (☃ == null) {
-         ☃ = 1;
+   public ResourceLocation getDynamicTextureLocation(String name, DynamicTexture texture) {
+      if (name.equals("logo")) {
+         texture = Config.getMojangLogoTexture(texture);
+      }
+
+      Integer integer = this.mapTextureCounters.get(name);
+      if (integer == null) {
+         integer = 1;
       } else {
-         ☃ = ☃ + 1;
+         integer = integer + 1;
       }
 
-      this.mapTextureCounters.put(☃, ☃);
-      ResourceLocation ☃x = new ResourceLocation(String.format("dynamic/%s_%d", ☃, ☃));
-      this.loadTexture(☃x, ☃);
-      return ☃x;
+      this.mapTextureCounters.put(name, integer);
+      ResourceLocation resourcelocation = new ResourceLocation(String.format("dynamic/%s_%d", name, integer));
+      this.loadTexture(resourcelocation, texture);
+      return resourcelocation;
    }
 
-   @Override
    public void tick() {
-      for (ITickable ☃ : this.listTickables) {
-         ☃.tick();
+      for (ITickable itickable : this.listTickables) {
+         itickable.tick();
       }
    }
 
-   public void deleteTexture(ResourceLocation var1) {
-      ITextureObject ☃ = this.getTexture(☃);
-      if (☃ != null) {
-         TextureUtil.deleteTexture(☃.getGlTextureId());
+   public void deleteTexture(ResourceLocation textureLocation) {
+      ITextureObject itextureobject = this.getTexture(textureLocation);
+      if (itextureobject != null) {
+         this.mapTextureObjects.remove(textureLocation);
+         TextureUtil.deleteTexture(itextureobject.getGlTextureId());
       }
    }
 
-   @Override
-   public void onResourceManagerReload(IResourceManager var1) {
-      Iterator<Entry<ResourceLocation, ITextureObject>> ☃ = this.mapTextureObjects.entrySet().iterator();
+   public void onResourceManagerReload(IResourceManager resourceManager) {
+      Config.dbg("*** Reloading textures ***");
+      Config.log("Resource packs: " + Config.getResourcePackNames());
+      Iterator it = this.mapTextureObjects.keySet().iterator();
+
+      while (it.hasNext()) {
+         ResourceLocation loc = (ResourceLocation)it.next();
+         String path = loc.getPath();
+         if (path.startsWith("mcpatcher/") || path.startsWith("optifine/") || EmissiveTextures.isEmissive(loc)) {
+            ITextureObject tex = this.mapTextureObjects.get(loc);
+            if (tex instanceof AbstractTexture) {
+               AbstractTexture at = (AbstractTexture)tex;
+               at.deleteGlTexture();
+            }
+
+            it.remove();
+         }
+      }
+
+      EmissiveTextures.update();
+      Set<Entry<ResourceLocation, ITextureObject>> entries = new HashSet<>(this.mapTextureObjects.entrySet());
+      Iterator<Entry<ResourceLocation, ITextureObject>> iterator = entries.iterator();
 
-      while (☃.hasNext()) {
-         Entry<ResourceLocation, ITextureObject> ☃x = ☃.next();
-         ITextureObject ☃xx = ☃x.getValue();
-         if (☃xx == TextureUtil.MISSING_TEXTURE) {
-            ☃.remove();
+      while (iterator.hasNext()) {
+         Entry<ResourceLocation, ITextureObject> entry = iterator.next();
+         ITextureObject itextureobject = entry.getValue();
+         if (itextureobject == TextureUtil.MISSING_TEXTURE) {
+            iterator.remove();
          } else {
-            this.loadTexture(☃x.getKey(), ☃xx);
+            this.loadTexture(entry.getKey(), itextureobject);
+         }
+      }
+   }
+
+   public void reloadBannerTextures() {
+      for (Entry<ResourceLocation, ITextureObject> entry : new HashSet<>(this.mapTextureObjects.entrySet())) {
+         ResourceLocation loc = entry.getKey();
+         ITextureObject tex = entry.getValue();
+         if (tex instanceof LayeredColorMaskTexture) {
+            this.loadTexture(loc, tex);
          }
       }
    }
+
+   public ITextureObject getBoundTexture() {
+      return this.boundTexture;
+   }
+
+   public ResourceLocation getBoundTextureLocation() {
+      return this.boundTextureLocation;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/TextureMap.java b/patches/net/minecraft/client/renderer/texture/TextureMap.java
index bad4b3b..ad9d9b8 100644
--- a/patches/net/minecraft/client/renderer/texture/TextureMap.java
+++ b/patches/net/minecraft/client/renderer/texture/TextureMap.java
@@ -2,12 +2,19 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import java.awt.Dimension;
+import java.awt.image.BufferedImage;
 import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
-import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.StitcherException;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
@@ -17,6 +24,17 @@
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.BetterGrass;
+import net.optifine.ConnectedTextures;
+import net.optifine.CustomItems;
+import net.optifine.EmissiveTextures;
+import net.optifine.SmartAnimations;
+import net.optifine.SpriteDependencies;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.ShadersTex;
+import net.optifine.util.CounterInt;
+import net.optifine.util.TextureUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -25,242 +43,751 @@ public class TextureMap extends AbstractTexture implements ITickableTextureObjec
    private static final Logger LOGGER = LogManager.getLogger();
    public static final ResourceLocation LOCATION_MISSING_TEXTURE = new ResourceLocation("missingno");
    public static final ResourceLocation LOCATION_BLOCKS_TEXTURE = new ResourceLocation("textures/atlas/blocks.png");
-   private final List<TextureAtlasSprite> listAnimatedSprites = Lists.newArrayList();
-   private final Map<String, TextureAtlasSprite> mapRegisteredSprites = Maps.newHashMap();
-   private final Map<String, TextureAtlasSprite> mapUploadedSprites = Maps.newHashMap();
+   private final List<TextureAtlasSprite> listAnimatedSprites;
+   private final Map<String, TextureAtlasSprite> mapRegisteredSprites;
+   private final Map<String, TextureAtlasSprite> mapUploadedSprites;
    private final String basePath;
    private final ITextureMapPopulator iconCreator;
    private int mipmapLevels;
-   private final TextureAtlasSprite missingImage = new TextureAtlasSprite("missingno");
+   private final TextureAtlasSprite missingImage;
+   private TextureAtlasSprite[] iconGrid = null;
+   private int iconGridSize = -1;
+   private int iconGridCountX = -1;
+   private int iconGridCountY = -1;
+   private double iconGridSizeU = -1.0;
+   private double iconGridSizeV = -1.0;
+   private CounterInt counterIndexInMap = new CounterInt(0);
+   public int atlasWidth = 0;
+   public int atlasHeight = 0;
+   private int countAnimationsActive;
+   private int frameCountAnimations;
+
+   public TextureMap(String basePathIn) {
+      this(basePathIn, (ITextureMapPopulator)null);
+   }
+
+   public TextureMap(String basePathIn, boolean skipFirst) {
+      this(basePathIn, (ITextureMapPopulator)null, skipFirst);
+   }
 
-   public TextureMap(String var1) {
-      this(☃, null);
+   public TextureMap(String basePathIn, @Nullable ITextureMapPopulator iconCreatorIn) {
+      this(basePathIn, iconCreatorIn, false);
    }
 
-   public TextureMap(String var1, @Nullable ITextureMapPopulator var2) {
-      this.basePath = ☃;
-      this.iconCreator = ☃;
+   public TextureMap(String basePathIn, ITextureMapPopulator iconCreatorIn, boolean skipFirst) {
+      this.listAnimatedSprites = Lists.newArrayList();
+      this.mapRegisteredSprites = Maps.newHashMap();
+      this.mapUploadedSprites = Maps.newHashMap();
+      this.missingImage = new TextureAtlasSprite("missingno");
+      this.basePath = basePathIn;
+      this.iconCreator = iconCreatorIn;
    }
 
    private void initMissingImage() {
-      int[] ☃ = TextureUtil.MISSING_TEXTURE_DATA;
-      this.missingImage.setIconWidth(16);
-      this.missingImage.setIconHeight(16);
-      int[][] ☃x = new int[this.mipmapLevels + 1][];
-      ☃x[0] = ☃;
-      this.missingImage.setFramesTextureData(Lists.newArrayList(new int[][][]{☃x}));
+      int size = this.getMinSpriteSize();
+      int[] aint = this.getMissingImageData(size);
+      this.missingImage.setIconWidth(size);
+      this.missingImage.setIconHeight(size);
+      int[][] aint1 = new int[this.mipmapLevels + 1][];
+      aint1[0] = aint;
+      this.missingImage.setFramesTextureData(Lists.newArrayList(new int[][][]{aint1}));
+      this.missingImage.setIndexInMap(this.counterIndexInMap.nextValue());
    }
 
    @Override
-   public void loadTexture(IResourceManager var1) throws IOException {
+   public void loadTexture(IResourceManager resourceManager) throws IOException {
       if (this.iconCreator != null) {
-         this.loadSprites(☃, this.iconCreator);
+         this.loadSprites(resourceManager, this.iconCreator);
       }
    }
 
-   public void loadSprites(IResourceManager var1, ITextureMapPopulator var2) {
+   public void loadSprites(IResourceManager resourceManager, ITextureMapPopulator iconCreatorIn) {
       this.mapRegisteredSprites.clear();
-      ☃.registerSprites(this);
+      this.counterIndexInMap.reset();
+      Reflector.callVoid(Reflector.ForgeHooksClient_onTextureStitchedPre, new Object[]{this});
+      iconCreatorIn.registerSprites(this);
+      if (this.mipmapLevels >= 4) {
+         this.mipmapLevels = this.detectMaxMipmapLevel(this.mapRegisteredSprites, resourceManager);
+         Config.log("Mipmap levels: " + this.mipmapLevels);
+      }
+
       this.initMissingImage();
       this.deleteGlTexture();
-      this.loadTextureAtlas(☃);
+      this.loadTextureAtlas(resourceManager);
    }
 
-   public void loadTextureAtlas(IResourceManager var1) {
-      int ☃ = Minecraft.getGLMaximumTextureSize();
-      Stitcher ☃x = new Stitcher(☃, ☃, 0, this.mipmapLevels);
+   public void loadTextureAtlas(IResourceManager resourceManager) {
+      Config.dbg("Multitexture: " + Config.isMultiTexture());
+      if (Config.isMultiTexture()) {
+         for (TextureAtlasSprite ts : this.mapUploadedSprites.values()) {
+            ts.deleteSpriteTexture();
+         }
+      }
+
+      ConnectedTextures.updateIcons(this);
+      CustomItems.updateIcons(this);
+      BetterGrass.updateIcons(this);
+      int i = TextureUtils.getGLMaximumTextureSize();
+      Stitcher stitcher = new Stitcher(i, i, 0, this.mipmapLevels);
       this.mapUploadedSprites.clear();
       this.listAnimatedSprites.clear();
-      int ☃xx = Integer.MAX_VALUE;
-      int ☃xxx = 1 << this.mipmapLevels;
-
-      for (Entry<String, TextureAtlasSprite> ☃xxxx : this.mapRegisteredSprites.entrySet()) {
-         TextureAtlasSprite ☃xxxxx = ☃xxxx.getValue();
-         ResourceLocation ☃xxxxxx = this.getResourceLocation(☃xxxxx);
-         IResource ☃xxxxxxx = null;
+      int j = Integer.MAX_VALUE;
+      int minSpriteSize = this.getMinSpriteSize();
+      this.iconGridSize = minSpriteSize;
+      int k = 1 << this.mipmapLevels;
+      int countCustomLoader = 0;
+      int countCustomLoaderSkipped = 0;
+      SpriteDependencies.reset();
+      List<TextureAtlasSprite> listRegisteredSprites = new ArrayList<>(this.mapRegisteredSprites.values());
+
+      for (int ix = 0; ix < listRegisteredSprites.size(); ix++) {
+         TextureAtlasSprite textureatlassprite = SpriteDependencies.resolveDependencies(listRegisteredSprites, ix, this);
+         ResourceLocation resourcelocation = this.getResourceLocation(textureatlassprite);
+         IResource iresource = null;
+         textureatlassprite.updateIndexInMap(this.counterIndexInMap);
+         if (textureatlassprite.hasCustomLoader(resourceManager, resourcelocation)) {
+            if (textureatlassprite.load(resourceManager, resourcelocation, lx -> this.mapRegisteredSprites.get(lx.toString()))) {
+               Config.detail("Custom loader (skipped): " + textureatlassprite);
+               countCustomLoaderSkipped++;
+               continue;
+            }
 
-         try {
-            PngSizeInfo ☃xxxxxxxx = PngSizeInfo.makeFromResource(☃.getResource(☃xxxxxx));
-            ☃xxxxxxx = ☃.getResource(☃xxxxxx);
-            boolean ☃xxxxxxxxx = ☃xxxxxxx.getMetadata("animation") != null;
-            ☃xxxxx.loadSprite(☃xxxxxxxx, ☃xxxxxxxxx);
-         } catch (RuntimeException var22) {
-            LOGGER.error("Unable to parse metadata from {}", ☃xxxxxx, var22);
-            continue;
-         } catch (IOException var23) {
-            LOGGER.error("Using missing texture, unable to load {}", ☃xxxxxx, var23);
-            continue;
-         } finally {
-            IOUtils.closeQuietly(☃xxxxxxx);
+            Config.detail("Custom loader: " + textureatlassprite);
+            countCustomLoader++;
+         } else {
+            try {
+               PngSizeInfo pngsizeinfo = PngSizeInfo.makeFromResource(resourceManager.getResource(resourcelocation));
+               iresource = resourceManager.getResource(resourcelocation);
+               boolean flag = iresource.getMetadata("animation") != null;
+               textureatlassprite.loadSprite(pngsizeinfo, flag);
+            } catch (RuntimeException var31) {
+               LOGGER.error("Unable to parse metadata from {}", resourcelocation, var31);
+               ReflectorForge.FMLClientHandler_trackBrokenTexture(resourcelocation, var31.getMessage());
+               continue;
+            } catch (IOException var32) {
+               LOGGER.error("Using missing texture, unable to load " + resourcelocation + ", " + var32.getClass().getName());
+               ReflectorForge.FMLClientHandler_trackMissingTexture(resourcelocation);
+               continue;
+            } finally {
+               IOUtils.closeQuietly(iresource);
+            }
          }
 
-         ☃xx = Math.min(☃xx, Math.min(☃xxxxx.getIconWidth(), ☃xxxxx.getIconHeight()));
-         int ☃xxxxxxxx = Math.min(Integer.lowestOneBit(☃xxxxx.getIconWidth()), Integer.lowestOneBit(☃xxxxx.getIconHeight()));
-         if (☃xxxxxxxx < ☃xxx) {
-            LOGGER.warn(
-               "Texture {} with size {}x{} limits mip level from {} to {}",
-               ☃xxxxxx,
-               ☃xxxxx.getIconWidth(),
-               ☃xxxxx.getIconHeight(),
-               MathHelper.log2(☃xxx),
-               MathHelper.log2(☃xxxxxxxx)
-            );
-            ☃xxx = ☃xxxxxxxx;
+         int ws = textureatlassprite.getIconWidth();
+         int hs = textureatlassprite.getIconHeight();
+         if (ws >= 1 && hs >= 1) {
+            if (ws < minSpriteSize || this.mipmapLevels > 0) {
+               int ws2 = this.mipmapLevels > 0 ? TextureUtils.scaleToGrid(ws, minSpriteSize) : TextureUtils.scaleToMin(ws, minSpriteSize);
+               if (ws2 != ws) {
+                  if (!TextureUtils.isPowerOfTwo(ws)) {
+                     Config.log("Scaled non power of 2: " + textureatlassprite.getIconName() + ", " + ws + " -> " + ws2);
+                  } else {
+                     Config.log("Scaled too small texture: " + textureatlassprite.getIconName() + ", " + ws + " -> " + ws2);
+                  }
+
+                  int hs2 = hs * ws2 / ws;
+                  textureatlassprite.setIconWidth(ws2);
+                  textureatlassprite.setIconHeight(hs2);
+               }
+            }
+
+            j = Math.min(j, Math.min(textureatlassprite.getIconWidth(), textureatlassprite.getIconHeight()));
+            int j1 = Math.min(Integer.lowestOneBit(textureatlassprite.getIconWidth()), Integer.lowestOneBit(textureatlassprite.getIconHeight()));
+            if (j1 < k) {
+               LOGGER.warn(
+                  "Texture {} with size {}x{} limits mip level from {} to {}",
+                  resourcelocation,
+                  textureatlassprite.getIconWidth(),
+                  textureatlassprite.getIconHeight(),
+                  MathHelper.log2(k),
+                  MathHelper.log2(j1)
+               );
+               k = j1;
+            }
+
+            if (this.generateMipmaps(resourceManager, textureatlassprite)) {
+               stitcher.addSprite(textureatlassprite);
+            }
+         } else {
+            Config.warn("Invalid sprite size: " + textureatlassprite);
          }
+      }
+
+      if (countCustomLoader > 0) {
+         Config.dbg("Custom loader sprites: " + countCustomLoader);
+      }
+
+      if (countCustomLoaderSkipped > 0) {
+         Config.dbg("Custom loader sprites (skipped): " + countCustomLoaderSkipped);
+      }
 
-         ☃x.addSprite(☃xxxxx);
+      if (SpriteDependencies.getCountDependencies() > 0) {
+         Config.dbg("Sprite dependencies: " + SpriteDependencies.getCountDependencies());
       }
 
-      int ☃xxxx = Math.min(☃xx, ☃xxx);
-      int ☃xxxxx = MathHelper.log2(☃xxxx);
-      if (☃xxxxx < this.mipmapLevels) {
-         LOGGER.warn("{}: dropping miplevel from {} to {}, because of minimum power of two: {}", this.basePath, this.mipmapLevels, ☃xxxxx, ☃xxxx);
-         this.mipmapLevels = ☃xxxxx;
+      int l = Math.min(j, k);
+      int i1 = MathHelper.log2(l);
+      if (i1 < 0) {
+         i1 = 0;
+      }
+
+      if (i1 < this.mipmapLevels) {
+         LOGGER.warn("{}: dropping miplevel from {} to {}, because of minimum power of two: {}", this.basePath, this.mipmapLevels, i1, l);
+         this.mipmapLevels = i1;
       }
 
       this.missingImage.generateMipmaps(this.mipmapLevels);
-      ☃x.addSprite(this.missingImage);
+      stitcher.addSprite(this.missingImage);
 
       try {
-         ☃x.doStitch();
-      } catch (StitcherException var21) {
-         throw var21;
+         stitcher.doStitch();
+      } catch (StitcherException var30) {
+         throw var30;
       }
 
-      LOGGER.info("Created: {}x{} {}-atlas", ☃x.getCurrentWidth(), ☃x.getCurrentHeight(), this.basePath);
-      TextureUtil.allocateTextureImpl(this.getGlTextureId(), this.mipmapLevels, ☃x.getCurrentWidth(), ☃x.getCurrentHeight());
-      Map<String, TextureAtlasSprite> ☃xxxxxx = Maps.newHashMap(this.mapRegisteredSprites);
+      LOGGER.info("Created: {}x{} {}-atlas", stitcher.getCurrentWidth(), stitcher.getCurrentHeight(), this.basePath);
+      if (Config.isShaders()) {
+         ShadersTex.allocateTextureMap(this.getGlTextureId(), this.mipmapLevels, stitcher.getCurrentWidth(), stitcher.getCurrentHeight(), stitcher, this);
+      } else {
+         TextureUtil.allocateTextureImpl(this.getGlTextureId(), this.mipmapLevels, stitcher.getCurrentWidth(), stitcher.getCurrentHeight());
+      }
 
-      for (TextureAtlasSprite ☃xxxxxxx : ☃x.getStichSlots()) {
-         if (☃xxxxxxx == this.missingImage || this.generateMipmaps(☃, ☃xxxxxxx)) {
-            String ☃xxxxxxxx = ☃xxxxxxx.getIconName();
-            ☃xxxxxx.remove(☃xxxxxxxx);
-            this.mapUploadedSprites.put(☃xxxxxxxx, ☃xxxxxxx);
+      Map<String, TextureAtlasSprite> map = Maps.newHashMap(this.mapRegisteredSprites);
 
-            try {
+      for (TextureAtlasSprite textureatlassprite1 : stitcher.getStichSlots()) {
+         String s = textureatlassprite1.getIconName();
+         map.remove(s);
+         this.mapUploadedSprites.put(s, textureatlassprite1);
+
+         try {
+            if (Config.isShaders()) {
+               ShadersTex.uploadTexSubForLoadAtlas(
+                  this,
+                  textureatlassprite1.getIconName(),
+                  textureatlassprite1.getFrameTextureData(0),
+                  textureatlassprite1.getIconWidth(),
+                  textureatlassprite1.getIconHeight(),
+                  textureatlassprite1.getOriginX(),
+                  textureatlassprite1.getOriginY(),
+                  false,
+                  false
+               );
+            } else {
                TextureUtil.uploadTextureMipmap(
-                  ☃xxxxxxx.getFrameTextureData(0),
-                  ☃xxxxxxx.getIconWidth(),
-                  ☃xxxxxxx.getIconHeight(),
-                  ☃xxxxxxx.getOriginX(),
-                  ☃xxxxxxx.getOriginY(),
+                  textureatlassprite1.getFrameTextureData(0),
+                  textureatlassprite1.getIconWidth(),
+                  textureatlassprite1.getIconHeight(),
+                  textureatlassprite1.getOriginX(),
+                  textureatlassprite1.getOriginY(),
                   false,
                   false
                );
-            } catch (Throwable var20) {
-               CrashReport ☃xxxxxxxxx = CrashReport.makeCrashReport(var20, "Stitching texture atlas");
-               CrashReportCategory ☃xxxxxxxxxx = ☃xxxxxxxxx.makeCategory("Texture being stitched together");
-               ☃xxxxxxxxxx.addCrashSection("Atlas path", this.basePath);
-               ☃xxxxxxxxxx.addCrashSection("Sprite", ☃xxxxxxx);
-               throw new ReportedException(☃xxxxxxxxx);
             }
+         } catch (Throwable var29) {
+            CrashReport crashreport = CrashReport.makeCrashReport(var29, "Stitching texture atlas");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Texture being stitched together");
+            crashreportcategory.addCrashSection("Atlas path", this.basePath);
+            crashreportcategory.addCrashSection("Sprite", textureatlassprite1);
+            throw new ReportedException(crashreport);
+         }
+
+         if (textureatlassprite1.hasAnimationMetadata()) {
+            textureatlassprite1.setAnimationIndex(this.listAnimatedSprites.size());
+            this.listAnimatedSprites.add(textureatlassprite1);
+         }
+      }
 
-            if (☃xxxxxxx.hasAnimationMetadata()) {
-               this.listAnimatedSprites.add(☃xxxxxxx);
+      for (TextureAtlasSprite textureatlassprite2 : map.values()) {
+         textureatlassprite2.copyFrom(this.missingImage);
+      }
+
+      Config.log("Animated sprites: " + this.listAnimatedSprites.size());
+      if (Config.isMultiTexture()) {
+         int sheetWidth = stitcher.getCurrentWidth();
+         int sheetHeight = stitcher.getCurrentHeight();
+
+         for (TextureAtlasSprite tas : stitcher.getStichSlots()) {
+            tas.sheetWidth = sheetWidth;
+            tas.sheetHeight = sheetHeight;
+            tas.mipmapLevels = this.mipmapLevels;
+            TextureAtlasSprite ss = tas.spriteSingle;
+            if (ss != null) {
+               if (ss.getIconWidth() <= 0) {
+                  ss.setIconWidth(tas.getIconWidth());
+                  ss.setIconHeight(tas.getIconHeight());
+                  ss.initSprite(tas.getIconWidth(), tas.getIconHeight(), 0, 0, false);
+                  ss.clearFramesTextureData();
+                  List<int[][]> frameDatas = tas.getFramesTextureData();
+                  ss.setFramesTextureData(frameDatas);
+                  ss.setAnimationMetadata(tas.getAnimationMetadata());
+               }
+
+               ss.sheetWidth = sheetWidth;
+               ss.sheetHeight = sheetHeight;
+               ss.mipmapLevels = this.mipmapLevels;
+               ss.setAnimationIndex(tas.getAnimationIndex());
+               tas.bindSpriteTexture();
+               boolean texBlur = false;
+               boolean texClamp = true;
+
+               try {
+                  TextureUtil.uploadTextureMipmap(
+                     ss.getFrameTextureData(0), ss.getIconWidth(), ss.getIconHeight(), ss.getOriginX(), ss.getOriginY(), texBlur, texClamp
+                  );
+               } catch (Exception var28) {
+                  Config.dbg("Error uploading sprite single: " + ss + ", parent: " + tas);
+                  var28.printStackTrace();
+               }
             }
          }
+
+         Config.getMinecraft().getTextureManager().bindTexture(LOCATION_BLOCKS_TEXTURE);
       }
 
-      for (TextureAtlasSprite ☃xxxxxxxx : ☃xxxxxx.values()) {
-         ☃xxxxxxxx.copyFrom(this.missingImage);
+      Reflector.callVoid(Reflector.ForgeHooksClient_onTextureStitchedPost, new Object[]{this});
+      this.updateIconGrid(stitcher.getCurrentWidth(), stitcher.getCurrentHeight());
+      if (Config.equals(System.getProperty("saveTextureMap"), "true")) {
+         Config.dbg("Exporting texture map: " + this.basePath);
+         TextureUtils.saveGlTexture(
+            "debug/" + this.basePath.replaceAll("/", "_"), this.getGlTextureId(), this.mipmapLevels, stitcher.getCurrentWidth(), stitcher.getCurrentHeight()
+         );
       }
    }
 
-   private boolean generateMipmaps(IResourceManager var1, final TextureAtlasSprite var2) {
-      ResourceLocation ☃ = this.getResourceLocation(☃);
-      IResource ☃x = null;
+   public boolean generateMipmaps(IResourceManager resourceManager, final TextureAtlasSprite texture) {
+      ResourceLocation resourcelocation = this.getResourceLocation(texture);
+      IResource iresource = null;
+      if (texture.hasCustomLoader(resourceManager, resourcelocation)) {
+         TextureUtils.generateCustomMipmaps(texture, this.mipmapLevels);
+      } else {
+         label60: {
+            boolean crashreportcategory;
+            try {
+               iresource = resourceManager.getResource(resourcelocation);
+               texture.loadSpriteFrames(iresource, this.mipmapLevels + 1);
+               break label60;
+            } catch (RuntimeException var14) {
+               LOGGER.error("Unable to parse metadata from {}", resourcelocation, var14);
+               return false;
+            } catch (IOException var15) {
+               LOGGER.error("Using missing texture, unable to load {}", resourcelocation, var15);
+               boolean flag = false;
+               crashreportcategory = flag;
+            } finally {
+               IOUtils.closeQuietly(iresource);
+            }
 
-      label45: {
-         boolean var6;
-         try {
-            ☃x = ☃.getResource(☃);
-            ☃.loadSpriteFrames(☃x, this.mipmapLevels + 1);
-            break label45;
-         } catch (RuntimeException var13) {
-            LOGGER.error("Unable to parse metadata from {}", ☃, var13);
-            return false;
-         } catch (IOException var14) {
-            LOGGER.error("Using missing texture, unable to load {}", ☃, var14);
-            var6 = false;
-         } finally {
-            IOUtils.closeQuietly(☃x);
+            return crashreportcategory;
          }
-
-         return var6;
       }
 
       try {
-         ☃.generateMipmaps(this.mipmapLevels);
+         texture.generateMipmaps(this.mipmapLevels);
          return true;
-      } catch (Throwable var12) {
-         CrashReport ☃xx = CrashReport.makeCrashReport(var12, "Applying mipmap");
-         CrashReportCategory ☃xxx = ☃xx.makeCategory("Sprite being mipmapped");
-         ☃xxx.addDetail("Sprite name", new ICrashReportDetail<String>() {
+      } catch (Throwable var13) {
+         CrashReport crashreport = CrashReport.makeCrashReport(var13, "Applying mipmap");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Sprite being mipmapped");
+         crashreportcategory.addDetail("Sprite name", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return ☃.getIconName();
+               return texture.getIconName();
             }
          });
-         ☃xxx.addDetail("Sprite size", new ICrashReportDetail<String>() {
+         crashreportcategory.addDetail("Sprite size", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return ☃.getIconWidth() + " x " + ☃.getIconHeight();
+               return texture.getIconWidth() + " x " + texture.getIconHeight();
             }
          });
-         ☃xxx.addDetail("Sprite frames", new ICrashReportDetail<String>() {
+         crashreportcategory.addDetail("Sprite frames", new ICrashReportDetail<String>() {
             public String call() throws Exception {
-               return ☃.getFrameCount() + " frames";
+               return texture.getFrameCount() + " frames";
             }
          });
-         ☃xxx.addCrashSection("Mipmap levels", this.mipmapLevels);
-         throw new ReportedException(☃xx);
+         crashreportcategory.addCrashSection("Mipmap levels", this.mipmapLevels);
+         throw new ReportedException(crashreport);
       }
    }
 
-   private ResourceLocation getResourceLocation(TextureAtlasSprite var1) {
-      ResourceLocation ☃ = new ResourceLocation(☃.getIconName());
-      return new ResourceLocation(☃.getNamespace(), String.format("%s/%s%s", this.basePath, ☃.getPath(), ".png"));
+   public ResourceLocation getResourceLocation(TextureAtlasSprite p_184396_1_) {
+      ResourceLocation resourcelocation = new ResourceLocation(p_184396_1_.getIconName());
+      return this.completeResourceLocation(resourcelocation);
+   }
+
+   public ResourceLocation completeResourceLocation(ResourceLocation resourcelocation) {
+      return this.isAbsoluteLocation(resourcelocation)
+         ? new ResourceLocation(resourcelocation.getNamespace(), resourcelocation.getPath() + ".png")
+         : new ResourceLocation(resourcelocation.getNamespace(), String.format("%s/%s%s", this.basePath, resourcelocation.getPath(), ".png"));
    }
 
-   public TextureAtlasSprite getAtlasSprite(String var1) {
-      TextureAtlasSprite ☃ = this.mapUploadedSprites.get(☃);
-      if (☃ == null) {
-         ☃ = this.missingImage;
+   public TextureAtlasSprite getAtlasSprite(String iconName) {
+      TextureAtlasSprite textureatlassprite = this.mapUploadedSprites.get(iconName);
+      if (textureatlassprite == null) {
+         textureatlassprite = this.missingImage;
       }
 
-      return ☃;
+      return textureatlassprite;
    }
 
    public void updateAnimations() {
+      boolean hasNormal = false;
+      boolean hasSpecular = false;
       TextureUtil.bindTexture(this.getGlTextureId());
+      int countActive = 0;
+
+      for (TextureAtlasSprite textureatlassprite : this.listAnimatedSprites) {
+         if (this.isTerrainAnimationActive(textureatlassprite)) {
+            textureatlassprite.updateAnimation();
+            if (textureatlassprite.isAnimationActive()) {
+               countActive++;
+            }
+
+            if (textureatlassprite.spriteNormal != null) {
+               hasNormal = true;
+            }
+
+            if (textureatlassprite.spriteSpecular != null) {
+               hasSpecular = true;
+            }
+         }
+      }
+
+      if (Config.isMultiTexture()) {
+         for (TextureAtlasSprite ts : this.listAnimatedSprites) {
+            if (this.isTerrainAnimationActive(ts)) {
+               TextureAtlasSprite spriteSingle = ts.spriteSingle;
+               if (spriteSingle != null) {
+                  if (ts == TextureUtils.iconClock || ts == TextureUtils.iconCompass) {
+                     spriteSingle.frameCounter = ts.frameCounter;
+                  }
+
+                  ts.bindSpriteTexture();
+                  spriteSingle.updateAnimation();
+                  if (spriteSingle.isAnimationActive()) {
+                     countActive++;
+                  }
+               }
+            }
+         }
 
-      for (TextureAtlasSprite ☃ : this.listAnimatedSprites) {
-         ☃.updateAnimation();
+         TextureUtil.bindTexture(this.getGlTextureId());
+      }
+
+      if (Config.isShaders()) {
+         if (hasNormal) {
+            TextureUtil.bindTexture(this.getMultiTexID().norm);
+
+            for (TextureAtlasSprite textureatlasspritex : this.listAnimatedSprites) {
+               if (textureatlasspritex.spriteNormal != null && this.isTerrainAnimationActive(textureatlasspritex)) {
+                  if (textureatlasspritex == TextureUtils.iconClock || textureatlasspritex == TextureUtils.iconCompass) {
+                     textureatlasspritex.spriteNormal.frameCounter = textureatlasspritex.frameCounter;
+                  }
+
+                  textureatlasspritex.spriteNormal.updateAnimation();
+                  if (textureatlasspritex.spriteNormal.isAnimationActive()) {
+                     countActive++;
+                  }
+               }
+            }
+         }
+
+         if (hasSpecular) {
+            TextureUtil.bindTexture(this.getMultiTexID().spec);
+
+            for (TextureAtlasSprite textureatlasspritexx : this.listAnimatedSprites) {
+               if (textureatlasspritexx.spriteSpecular != null && this.isTerrainAnimationActive(textureatlasspritexx)) {
+                  if (textureatlasspritexx == TextureUtils.iconClock || textureatlasspritexx == TextureUtils.iconCompass) {
+                     textureatlasspritexx.spriteNormal.frameCounter = textureatlasspritexx.frameCounter;
+                  }
+
+                  textureatlasspritexx.spriteSpecular.updateAnimation();
+                  if (textureatlasspritexx.spriteSpecular.isAnimationActive()) {
+                     countActive++;
+                  }
+               }
+            }
+         }
+
+         if (hasNormal || hasSpecular) {
+            TextureUtil.bindTexture(this.getGlTextureId());
+         }
+      }
+
+      int frameCount = Config.getMinecraft().entityRenderer.frameCount;
+      if (frameCount != this.frameCountAnimations) {
+         this.countAnimationsActive = countActive;
+         this.frameCountAnimations = frameCount;
+      }
+
+      if (SmartAnimations.isActive()) {
+         SmartAnimations.resetSpritesRendered();
       }
    }
 
-   public TextureAtlasSprite registerSprite(ResourceLocation var1) {
-      if (☃ == null) {
+   public TextureAtlasSprite registerSprite(ResourceLocation location) {
+      if (location == null) {
          throw new IllegalArgumentException("Location cannot be null!");
       } else {
-         TextureAtlasSprite ☃ = this.mapRegisteredSprites.get(☃);
-         if (☃ == null) {
-            ☃ = TextureAtlasSprite.makeAtlasSprite(☃);
-            this.mapRegisteredSprites.put(☃.toString(), ☃);
+         TextureAtlasSprite textureatlassprite = this.mapRegisteredSprites.get(location.toString());
+         if (textureatlassprite == null) {
+            textureatlassprite = TextureAtlasSprite.makeAtlasSprite(location);
+            this.mapRegisteredSprites.put(location.toString(), textureatlassprite);
+            textureatlassprite.updateIndexInMap(this.counterIndexInMap);
+            if (Config.isEmissiveTextures()) {
+               this.checkEmissive(location, textureatlassprite);
+            }
          }
 
-         return ☃;
+         return textureatlassprite;
       }
    }
 
-   @Override
    public void tick() {
       this.updateAnimations();
    }
 
-   public void setMipmapLevels(int var1) {
-      this.mipmapLevels = ☃;
+   public void setMipmapLevels(int mipmapLevelsIn) {
+      this.mipmapLevels = mipmapLevelsIn;
    }
 
    public TextureAtlasSprite getMissingSprite() {
       return this.missingImage;
    }
+
+   @Nullable
+   public TextureAtlasSprite getTextureExtry(String name) {
+      return this.mapRegisteredSprites.get(name);
+   }
+
+   public boolean setTextureEntry(TextureAtlasSprite entry) {
+      String name = entry.getIconName();
+      if (!this.mapRegisteredSprites.containsKey(name)) {
+         this.mapRegisteredSprites.put(name, entry);
+         entry.updateIndexInMap(this.counterIndexInMap);
+         return true;
+      } else {
+         return false;
+      }
+   }
+
+   public String getBasePath() {
+      return this.basePath;
+   }
+
+   public int getMipmapLevels() {
+      return this.mipmapLevels;
+   }
+
+   private boolean isAbsoluteLocation(ResourceLocation loc) {
+      String path = loc.getPath();
+      return this.isAbsoluteLocationPath(path);
+   }
+
+   private boolean isAbsoluteLocationPath(String resPath) {
+      String path = resPath.toLowerCase();
+      return path.startsWith("mcpatcher/") || path.startsWith("optifine/");
+   }
+
+   public TextureAtlasSprite getSpriteSafe(String name) {
+      ResourceLocation loc = new ResourceLocation(name);
+      return this.mapRegisteredSprites.get(loc.toString());
+   }
+
+   public TextureAtlasSprite getRegisteredSprite(ResourceLocation loc) {
+      return this.mapRegisteredSprites.get(loc.toString());
+   }
+
+   private boolean isTerrainAnimationActive(TextureAtlasSprite ts) {
+      if (ts == TextureUtils.iconWaterStill || ts == TextureUtils.iconWaterFlow) {
+         return Config.isAnimatedWater();
+      } else if (ts == TextureUtils.iconLavaStill || ts == TextureUtils.iconLavaFlow) {
+         return Config.isAnimatedLava();
+      } else if (ts == TextureUtils.iconFireLayer0 || ts == TextureUtils.iconFireLayer1) {
+         return Config.isAnimatedFire();
+      } else if (ts == TextureUtils.iconPortal) {
+         return Config.isAnimatedPortal();
+      } else {
+         return ts != TextureUtils.iconClock && ts != TextureUtils.iconCompass ? Config.isAnimatedTerrain() : true;
+      }
+   }
+
+   public int getCountRegisteredSprites() {
+      return this.counterIndexInMap.getValue();
+   }
+
+   private int detectMaxMipmapLevel(Map mapSprites, IResourceManager rm) {
+      int minSize = this.detectMinimumSpriteSize(mapSprites, rm, 20);
+      if (minSize < 16) {
+         minSize = 16;
+      }
+
+      minSize = MathHelper.smallestEncompassingPowerOfTwo(minSize);
+      if (minSize > 16) {
+         Config.log("Sprite size: " + minSize);
+      }
+
+      int minLevel = MathHelper.log2(minSize);
+      if (minLevel < 4) {
+         minLevel = 4;
+      }
+
+      return minLevel;
+   }
+
+   private int detectMinimumSpriteSize(Map mapSprites, IResourceManager rm, int percentScale) {
+      Map mapSizeCounts = new HashMap();
+
+      for (Entry entry : mapSprites.entrySet()) {
+         TextureAtlasSprite sprite = (TextureAtlasSprite)entry.getValue();
+         ResourceLocation loc = new ResourceLocation(sprite.getIconName());
+         ResourceLocation locComplete = this.completeResourceLocation(loc);
+         if (!sprite.hasCustomLoader(rm, loc)) {
+            try {
+               IResource res = rm.getResource(locComplete);
+               if (res != null) {
+                  InputStream in = res.getInputStream();
+                  if (in != null) {
+                     Dimension dim = TextureUtils.getImageSize(in, "png");
+                     in.close();
+                     if (dim != null) {
+                        int width = dim.width;
+                        int width2 = MathHelper.smallestEncompassingPowerOfTwo(width);
+                        if (!mapSizeCounts.containsKey(width2)) {
+                           mapSizeCounts.put(width2, 1);
+                        } else {
+                           int count = (Integer)mapSizeCounts.get(width2);
+                           mapSizeCounts.put(width2, count + 1);
+                        }
+                     }
+                  }
+               }
+            } catch (Exception var17) {
+            }
+         }
+      }
+
+      int countSprites = 0;
+      Set setSizes = mapSizeCounts.keySet();
+      Set setSizesSorted = new TreeSet(setSizes);
+
+      for (int size : setSizesSorted) {
+         int count = (Integer)mapSizeCounts.get(size);
+         countSprites += count;
+      }
+
+      int minSize = 16;
+      int countScale = 0;
+      int countScaleMax = countSprites * percentScale / 100;
+
+      for (int size : setSizesSorted) {
+         int count = (Integer)mapSizeCounts.get(size);
+         countScale += count;
+         if (size > minSize) {
+            minSize = size;
+         }
+
+         if (countScale > countScaleMax) {
+            return minSize;
+         }
+      }
+
+      return minSize;
+   }
+
+   private int getMinSpriteSize() {
+      int minSize = 1 << this.mipmapLevels;
+      if (minSize < 8) {
+         minSize = 8;
+      }
+
+      return minSize;
+   }
+
+   private int[] getMissingImageData(int size) {
+      BufferedImage bi = new BufferedImage(16, 16, 2);
+      bi.setRGB(0, 0, 16, 16, TextureUtil.MISSING_TEXTURE_DATA, 0, 16);
+      BufferedImage bi2 = TextureUtils.scaleImage(bi, size);
+      int[] data = new int[size * size];
+      bi2.getRGB(0, 0, size, size, data, 0, size);
+      return data;
+   }
+
+   public boolean isTextureBound() {
+      int boundTexId = GlStateManager.getBoundTexture();
+      int texId = this.getGlTextureId();
+      return boundTexId == texId;
+   }
+
+   private void updateIconGrid(int sheetWidth, int sheetHeight) {
+      this.iconGridCountX = -1;
+      this.iconGridCountY = -1;
+      this.iconGrid = null;
+      if (this.iconGridSize > 0) {
+         this.iconGridCountX = sheetWidth / this.iconGridSize;
+         this.iconGridCountY = sheetHeight / this.iconGridSize;
+         this.iconGrid = new TextureAtlasSprite[this.iconGridCountX * this.iconGridCountY];
+         this.iconGridSizeU = 1.0 / this.iconGridCountX;
+         this.iconGridSizeV = 1.0 / this.iconGridCountY;
+
+         for (TextureAtlasSprite ts : this.mapUploadedSprites.values()) {
+            double deltaU = 0.5 / sheetWidth;
+            double deltaV = 0.5 / sheetHeight;
+            double uMin = Math.min(ts.getMinU(), ts.getMaxU()) + deltaU;
+            double vMin = Math.min(ts.getMinV(), ts.getMaxV()) + deltaV;
+            double uMax = Math.max(ts.getMinU(), ts.getMaxU()) - deltaU;
+            double vMax = Math.max(ts.getMinV(), ts.getMaxV()) - deltaV;
+            int iuMin = (int)(uMin / this.iconGridSizeU);
+            int ivMin = (int)(vMin / this.iconGridSizeV);
+            int iuMax = (int)(uMax / this.iconGridSizeU);
+            int ivMax = (int)(vMax / this.iconGridSizeV);
+
+            for (int iu = iuMin; iu <= iuMax; iu++) {
+               if (iu >= 0 && iu < this.iconGridCountX) {
+                  for (int iv = ivMin; iv <= ivMax; iv++) {
+                     if (iv >= 0 && iv < this.iconGridCountX) {
+                        int index = iv * this.iconGridCountX + iu;
+                        this.iconGrid[index] = ts;
+                     } else {
+                        Config.warn("Invalid grid V: " + iv + ", icon: " + ts.getIconName());
+                     }
+                  }
+               } else {
+                  Config.warn("Invalid grid U: " + iu + ", icon: " + ts.getIconName());
+               }
+            }
+         }
+      }
+   }
+
+   public TextureAtlasSprite getIconByUV(double u, double v) {
+      if (this.iconGrid == null) {
+         return null;
+      } else {
+         int iu = (int)(u / this.iconGridSizeU);
+         int iv = (int)(v / this.iconGridSizeV);
+         int index = iv * this.iconGridCountX + iu;
+         return index >= 0 && index <= this.iconGrid.length ? this.iconGrid[index] : null;
+      }
+   }
+
+   private void checkEmissive(ResourceLocation locSprite, TextureAtlasSprite sprite) {
+      String suffixEm = EmissiveTextures.getSuffixEmissive();
+      if (suffixEm != null) {
+         if (!locSprite.getPath().endsWith(suffixEm)) {
+            ResourceLocation locSpriteEm = new ResourceLocation(locSprite.getNamespace(), locSprite.getPath() + suffixEm);
+            ResourceLocation locPngEm = this.completeResourceLocation(locSpriteEm);
+            if (Config.hasResource(locPngEm)) {
+               TextureAtlasSprite spriteEmissive = this.registerSprite(locSpriteEm);
+               spriteEmissive.isEmissive = true;
+               sprite.spriteEmissive = spriteEmissive;
+            }
+         }
+      }
+   }
+
+   public int getCountAnimations() {
+      return this.listAnimatedSprites.size();
+   }
+
+   public int getCountAnimationsActive() {
+      return this.countAnimationsActive;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/texture/TextureUtil.java b/patches/net/minecraft/client/renderer/texture/TextureUtil.java
index aec2e05..5bf7645 100644
--- a/patches/net/minecraft/client/renderer/texture/TextureUtil.java
+++ b/patches/net/minecraft/client/renderer/texture/TextureUtil.java
@@ -12,6 +12,8 @@
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.Mipmaps;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -23,312 +25,302 @@ public class TextureUtil {
    public static final int[] MISSING_TEXTURE_DATA = MISSING_TEXTURE.getTextureData();
    private static final float[] COLOR_GAMMAS;
    private static final int[] MIPMAP_BUFFER;
+   private static int[] dataArray = new int[4194304];
 
-   private static float getColorGamma(int var0) {
-      return COLOR_GAMMAS[☃ & 0xFF];
+   private static float getColorGamma(int p_188543_0_) {
+      return COLOR_GAMMAS[p_188543_0_ & 0xFF];
    }
 
    public static int glGenTextures() {
       return GlStateManager.generateTexture();
    }
 
-   public static void deleteTexture(int var0) {
-      GlStateManager.deleteTexture(☃);
+   public static void deleteTexture(int textureId) {
+      GlStateManager.deleteTexture(textureId);
    }
 
-   public static int uploadTextureImage(int var0, BufferedImage var1) {
-      return uploadTextureImageAllocate(☃, ☃, false, false);
+   public static int uploadTextureImage(int textureId, BufferedImage texture) {
+      return uploadTextureImageAllocate(textureId, texture, false, false);
    }
 
-   public static void uploadTexture(int var0, int[] var1, int var2, int var3) {
-      bindTexture(☃);
-      uploadTextureSub(0, ☃, ☃, ☃, 0, 0, false, false, false);
+   public static void uploadTexture(int textureId, int[] p_110988_1_, int p_110988_2_, int p_110988_3_) {
+      bindTexture(textureId);
+      uploadTextureSub(0, p_110988_1_, p_110988_2_, p_110988_3_, 0, 0, false, false, false);
    }
 
-   public static int[][] generateMipmapData(int var0, int var1, int[][] var2) {
-      int[][] ☃ = new int[☃ + 1][];
-      ☃[0] = ☃[0];
-      if (☃ > 0) {
-         boolean ☃x = false;
+   public static int[][] generateMipmapData(int p_147949_0_, int p_147949_1_, int[][] p_147949_2_) {
+      int[][] aint = new int[p_147949_0_ + 1][];
+      aint[0] = p_147949_2_[0];
+      if (p_147949_0_ > 0) {
+         boolean flag = false;
 
-         for (int ☃xx = 0; ☃xx < ☃.length; ☃xx++) {
-            if (☃[0][☃xx] >> 24 == 0) {
-               ☃x = true;
+         for (int i = 0; i < p_147949_2_[0].length; i++) {
+            if (p_147949_2_[0][i] >> 24 == 0) {
+               flag = true;
                break;
             }
          }
 
-         for (int ☃xxx = 1; ☃xxx <= ☃; ☃xxx++) {
-            if (☃[☃xxx] != null) {
-               ☃[☃xxx] = ☃[☃xxx];
+         for (int l1 = 1; l1 <= p_147949_0_; l1++) {
+            if (p_147949_2_[l1] != null) {
+               aint[l1] = p_147949_2_[l1];
             } else {
-               int[] ☃xxxx = ☃[☃xxx - 1];
-               int[] ☃xxxxx = new int[☃xxxx.length >> 2];
-               int ☃xxxxxx = ☃ >> ☃xxx;
-               int ☃xxxxxxx = ☃xxxxx.length / ☃xxxxxx;
-               int ☃xxxxxxxx = ☃xxxxxx << 1;
-
-               for (int ☃xxxxxxxxx = 0; ☃xxxxxxxxx < ☃xxxxxx; ☃xxxxxxxxx++) {
-                  for (int ☃xxxxxxxxxx = 0; ☃xxxxxxxxxx < ☃xxxxxxx; ☃xxxxxxxxxx++) {
-                     int ☃xxxxxxxxxxx = 2 * (☃xxxxxxxxx + ☃xxxxxxxxxx * ☃xxxxxxxx);
-                     ☃xxxxx[☃xxxxxxxxx + ☃xxxxxxxxxx * ☃xxxxxx] = blendColors(
-                        ☃xxxx[☃xxxxxxxxxxx + 0], ☃xxxx[☃xxxxxxxxxxx + 1], ☃xxxx[☃xxxxxxxxxxx + 0 + ☃xxxxxxxx], ☃xxxx[☃xxxxxxxxxxx + 1 + ☃xxxxxxxx], ☃x
-                     );
+               int[] aint1 = aint[l1 - 1];
+               int[] aint2 = new int[aint1.length >> 2];
+               int j = p_147949_1_ >> l1;
+               int k = aint2.length / j;
+               int l = j << 1;
+
+               for (int i1 = 0; i1 < j; i1++) {
+                  for (int j1 = 0; j1 < k; j1++) {
+                     int k1 = 2 * (i1 + j1 * l);
+                     aint2[i1 + j1 * j] = blendColors(aint1[k1 + 0], aint1[k1 + 1], aint1[k1 + 0 + l], aint1[k1 + 1 + l], flag);
                   }
                }
 
-               ☃[☃xxx] = ☃xxxxx;
+               aint[l1] = aint2;
             }
          }
       }
 
-      return ☃;
+      return aint;
    }
 
-   private static int blendColors(int var0, int var1, int var2, int var3, boolean var4) {
-      if (☃) {
-         MIPMAP_BUFFER[0] = ☃;
-         MIPMAP_BUFFER[1] = ☃;
-         MIPMAP_BUFFER[2] = ☃;
-         MIPMAP_BUFFER[3] = ☃;
-         float ☃ = 0.0F;
-         float ☃x = 0.0F;
-         float ☃xx = 0.0F;
-         float ☃xxx = 0.0F;
-
-         for (int ☃xxxx = 0; ☃xxxx < 4; ☃xxxx++) {
-            if (MIPMAP_BUFFER[☃xxxx] >> 24 != 0) {
-               ☃ += getColorGamma(MIPMAP_BUFFER[☃xxxx] >> 24);
-               ☃x += getColorGamma(MIPMAP_BUFFER[☃xxxx] >> 16);
-               ☃xx += getColorGamma(MIPMAP_BUFFER[☃xxxx] >> 8);
-               ☃xxx += getColorGamma(MIPMAP_BUFFER[☃xxxx] >> 0);
-            }
-         }
-
-         ☃ /= 4.0F;
-         ☃x /= 4.0F;
-         ☃xx /= 4.0F;
-         ☃xxx /= 4.0F;
-         int ☃xxxxx = (int)(Math.pow(☃, 0.45454545454545453) * 255.0);
-         int ☃xxxxxx = (int)(Math.pow(☃x, 0.45454545454545453) * 255.0);
-         int ☃xxxxxxx = (int)(Math.pow(☃xx, 0.45454545454545453) * 255.0);
-         int ☃xxxxxxxx = (int)(Math.pow(☃xxx, 0.45454545454545453) * 255.0);
-         if (☃xxxxx < 96) {
-            ☃xxxxx = 0;
-         }
-
-         return ☃xxxxx << 24 | ☃xxxxxx << 16 | ☃xxxxxxx << 8 | ☃xxxxxxxx;
-      } else {
-         int ☃ = blendColorComponent(☃, ☃, ☃, ☃, 24);
-         int ☃x = blendColorComponent(☃, ☃, ☃, ☃, 16);
-         int ☃xx = blendColorComponent(☃, ☃, ☃, ☃, 8);
-         int ☃xxx = blendColorComponent(☃, ☃, ☃, ☃, 0);
-         return ☃ << 24 | ☃x << 16 | ☃xx << 8 | ☃xxx;
-      }
+   private static int blendColors(int p_147943_0_, int p_147943_1_, int p_147943_2_, int p_147943_3_, boolean p_147943_4_) {
+      return Mipmaps.alphaBlend(p_147943_0_, p_147943_1_, p_147943_2_, p_147943_3_);
    }
 
-   private static int blendColorComponent(int var0, int var1, int var2, int var3, int var4) {
-      float ☃ = getColorGamma(☃ >> ☃);
-      float ☃x = getColorGamma(☃ >> ☃);
-      float ☃xx = getColorGamma(☃ >> ☃);
-      float ☃xxx = getColorGamma(☃ >> ☃);
-      float ☃xxxx = (float)((float)Math.pow((☃ + ☃x + ☃xx + ☃xxx) * 0.25, 0.45454545454545453));
-      return (int)(☃xxxx * 255.0);
+   private static int blendColorComponent(int p_147944_0_, int p_147944_1_, int p_147944_2_, int p_147944_3_, int p_147944_4_) {
+      float f = getColorGamma(p_147944_0_ >> p_147944_4_);
+      float f1 = getColorGamma(p_147944_1_ >> p_147944_4_);
+      float f2 = getColorGamma(p_147944_2_ >> p_147944_4_);
+      float f3 = getColorGamma(p_147944_3_ >> p_147944_4_);
+      float f4 = (float)((float)Math.pow((f + f1 + f2 + f3) * 0.25, 0.45454545454545453));
+      return (int)(f4 * 255.0);
    }
 
-   public static void uploadTextureMipmap(int[][] var0, int var1, int var2, int var3, int var4, boolean var5, boolean var6) {
-      for (int ☃ = 0; ☃ < ☃.length; ☃++) {
-         int[] ☃x = ☃[☃];
-         uploadTextureSub(☃, ☃x, ☃ >> ☃, ☃ >> ☃, ☃ >> ☃, ☃ >> ☃, ☃, ☃, ☃.length > 1);
+   public static void uploadTextureMipmap(
+      int[][] p_147955_0_, int p_147955_1_, int p_147955_2_, int p_147955_3_, int p_147955_4_, boolean p_147955_5_, boolean p_147955_6_
+   ) {
+      for (int i = 0; i < p_147955_0_.length; i++) {
+         int[] aint = p_147955_0_[i];
+         uploadTextureSub(i, aint, p_147955_1_ >> i, p_147955_2_ >> i, p_147955_3_ >> i, p_147955_4_ >> i, p_147955_5_, p_147955_6_, p_147955_0_.length > 1);
       }
    }
 
-   private static void uploadTextureSub(int var0, int[] var1, int var2, int var3, int var4, int var5, boolean var6, boolean var7, boolean var8) {
-      int ☃ = 4194304 / ☃;
-      setTextureBlurMipmap(☃, ☃);
-      setTextureClamped(☃);
-      int ☃x = 0;
-
-      while (☃x < ☃ * ☃) {
-         int ☃xx = ☃x / ☃;
-         int ☃xxx = Math.min(☃, ☃ - ☃xx);
-         int ☃xxxx = ☃ * ☃xxx;
-         copyToBufferPos(☃, ☃x, ☃xxxx);
-         GlStateManager.glTexSubImage2D(3553, ☃, ☃, ☃ + ☃xx, ☃, ☃xxx, 32993, 33639, DATA_BUFFER);
-         ☃x += ☃ * ☃xxx;
+   private static void uploadTextureSub(
+      int p_147947_0_,
+      int[] p_147947_1_,
+      int p_147947_2_,
+      int p_147947_3_,
+      int p_147947_4_,
+      int p_147947_5_,
+      boolean p_147947_6_,
+      boolean p_147947_7_,
+      boolean p_147947_8_
+   ) {
+      int i = 4194304 / p_147947_2_;
+      setTextureBlurMipmap(p_147947_6_, p_147947_8_);
+      setTextureClamped(p_147947_7_);
+      int j = 0;
+
+      while (j < p_147947_2_ * p_147947_3_) {
+         int k = j / p_147947_2_;
+         int l = Math.min(i, p_147947_3_ - k);
+         int i1 = p_147947_2_ * l;
+         copyToBufferPos(p_147947_1_, j, i1);
+         GlStateManager.glTexSubImage2D(3553, p_147947_0_, p_147947_4_, p_147947_5_ + k, p_147947_2_, l, 32993, 33639, DATA_BUFFER);
+         j += p_147947_2_ * l;
       }
    }
 
-   public static int uploadTextureImageAllocate(int var0, BufferedImage var1, boolean var2, boolean var3) {
-      allocateTexture(☃, ☃.getWidth(), ☃.getHeight());
-      return uploadTextureImageSub(☃, ☃, 0, 0, ☃, ☃);
+   public static int uploadTextureImageAllocate(int textureId, BufferedImage texture, boolean blur, boolean clamp) {
+      allocateTexture(textureId, texture.getWidth(), texture.getHeight());
+      return uploadTextureImageSub(textureId, texture, 0, 0, blur, clamp);
    }
 
-   public static void allocateTexture(int var0, int var1, int var2) {
-      allocateTextureImpl(☃, 0, ☃, ☃);
+   public static void allocateTexture(int textureId, int width, int height) {
+      allocateTextureImpl(textureId, 0, width, height);
    }
 
-   public static void allocateTextureImpl(int var0, int var1, int var2, int var3) {
-      deleteTexture(☃);
-      bindTexture(☃);
-      if (☃ >= 0) {
-         GlStateManager.glTexParameteri(3553, 33085, ☃);
+   public static void allocateTextureImpl(int glTextureId, int mipmapLevels, int width, int height) {
+      Object monitor = TextureUtil.class;
+      if (Reflector.SplashScreen.exists()) {
+         monitor = Reflector.SplashScreen.getTargetClass();
+      }
+
+      synchronized (monitor) {
+         deleteTexture(glTextureId);
+         bindTexture(glTextureId);
+      }
+
+      if (mipmapLevels >= 0) {
+         GlStateManager.glTexParameteri(3553, 33085, mipmapLevels);
          GlStateManager.glTexParameteri(3553, 33082, 0);
-         GlStateManager.glTexParameteri(3553, 33083, ☃);
+         GlStateManager.glTexParameteri(3553, 33083, mipmapLevels);
          GlStateManager.glTexParameterf(3553, 34049, 0.0F);
       }
 
-      for (int ☃ = 0; ☃ <= ☃; ☃++) {
-         GlStateManager.glTexImage2D(3553, ☃, 6408, ☃ >> ☃, ☃ >> ☃, 0, 32993, 33639, null);
+      for (int i = 0; i <= mipmapLevels; i++) {
+         GlStateManager.glTexImage2D(3553, i, 6408, width >> i, height >> i, 0, 32993, 33639, (IntBuffer)null);
       }
    }
 
-   public static int uploadTextureImageSub(int var0, BufferedImage var1, int var2, int var3, boolean var4, boolean var5) {
-      bindTexture(☃);
-      uploadTextureImageSubImpl(☃, ☃, ☃, ☃, ☃);
-      return ☃;
+   public static int uploadTextureImageSub(int textureId, BufferedImage p_110995_1_, int p_110995_2_, int p_110995_3_, boolean p_110995_4_, boolean p_110995_5_) {
+      bindTexture(textureId);
+      uploadTextureImageSubImpl(p_110995_1_, p_110995_2_, p_110995_3_, p_110995_4_, p_110995_5_);
+      return textureId;
    }
 
-   private static void uploadTextureImageSubImpl(BufferedImage var0, int var1, int var2, boolean var3, boolean var4) {
-      int ☃ = ☃.getWidth();
-      int ☃x = ☃.getHeight();
-      int ☃xx = 4194304 / ☃;
-      int[] ☃xxx = new int[☃xx * ☃];
-      setTextureBlurred(☃);
-      setTextureClamped(☃);
-
-      for (int ☃xxxx = 0; ☃xxxx < ☃ * ☃x; ☃xxxx += ☃ * ☃xx) {
-         int ☃xxxxx = ☃xxxx / ☃;
-         int ☃xxxxxx = Math.min(☃xx, ☃x - ☃xxxxx);
-         int ☃xxxxxxx = ☃ * ☃xxxxxx;
-         ☃.getRGB(0, ☃xxxxx, ☃, ☃xxxxxx, ☃xxx, 0, ☃);
-         copyToBuffer(☃xxx, ☃xxxxxxx);
-         GlStateManager.glTexSubImage2D(3553, 0, ☃, ☃ + ☃xxxxx, ☃, ☃xxxxxx, 32993, 33639, DATA_BUFFER);
+   private static void uploadTextureImageSubImpl(BufferedImage p_110993_0_, int p_110993_1_, int p_110993_2_, boolean p_110993_3_, boolean p_110993_4_) {
+      int i = p_110993_0_.getWidth();
+      int j = p_110993_0_.getHeight();
+      int k = 4194304 / i;
+      int[] aint = dataArray;
+      setTextureBlurred(p_110993_3_);
+      setTextureClamped(p_110993_4_);
+
+      for (int l = 0; l < i * j; l += i * k) {
+         int i1 = l / i;
+         int j1 = Math.min(k, j - i1);
+         int k1 = i * j1;
+         p_110993_0_.getRGB(0, i1, i, j1, aint, 0, i);
+         copyToBuffer(aint, k1);
+         GlStateManager.glTexSubImage2D(3553, 0, p_110993_1_, p_110993_2_ + i1, i, j1, 32993, 33639, DATA_BUFFER);
       }
    }
 
-   private static void setTextureClamped(boolean var0) {
-      if (☃) {
-         GlStateManager.glTexParameteri(3553, 10242, 10496);
-         GlStateManager.glTexParameteri(3553, 10243, 10496);
+   public static void setTextureClamped(boolean p_110997_0_) {
+      if (p_110997_0_) {
+         GlStateManager.glTexParameteri(3553, 10242, 33071);
+         GlStateManager.glTexParameteri(3553, 10243, 33071);
       } else {
          GlStateManager.glTexParameteri(3553, 10242, 10497);
          GlStateManager.glTexParameteri(3553, 10243, 10497);
       }
    }
 
-   private static void setTextureBlurred(boolean var0) {
-      setTextureBlurMipmap(☃, false);
+   private static void setTextureBlurred(boolean p_147951_0_) {
+      setTextureBlurMipmap(p_147951_0_, false);
    }
 
-   private static void setTextureBlurMipmap(boolean var0, boolean var1) {
-      if (☃) {
-         GlStateManager.glTexParameteri(3553, 10241, ☃ ? 9987 : 9729);
+   public static void setTextureBlurMipmap(boolean p_147954_0_, boolean p_147954_1_) {
+      if (p_147954_0_) {
+         GlStateManager.glTexParameteri(3553, 10241, p_147954_1_ ? 9987 : 9729);
          GlStateManager.glTexParameteri(3553, 10240, 9729);
       } else {
-         GlStateManager.glTexParameteri(3553, 10241, ☃ ? 9986 : 9728);
+         int mipmapType = Config.getMipmapType();
+         GlStateManager.glTexParameteri(3553, 10241, p_147954_1_ ? mipmapType : 9728);
          GlStateManager.glTexParameteri(3553, 10240, 9728);
       }
    }
 
-   private static void copyToBuffer(int[] var0, int var1) {
-      copyToBufferPos(☃, 0, ☃);
+   private static void copyToBuffer(int[] p_110990_0_, int p_110990_1_) {
+      copyToBufferPos(p_110990_0_, 0, p_110990_1_);
    }
 
-   private static void copyToBufferPos(int[] var0, int var1, int var2) {
-      int[] ☃ = ☃;
+   private static void copyToBufferPos(int[] p_110994_0_, int p_110994_1_, int p_110994_2_) {
+      int[] aint = p_110994_0_;
       if (Minecraft.getMinecraft().gameSettings.anaglyph) {
-         ☃ = updateAnaglyph(☃);
+         aint = updateAnaglyph(p_110994_0_);
       }
 
       ((Buffer)DATA_BUFFER).clear();
-      DATA_BUFFER.put(☃, ☃, ☃);
-      ((Buffer)DATA_BUFFER).position(0).limit(☃);
+      DATA_BUFFER.put(aint, p_110994_1_, p_110994_2_);
+      ((Buffer)DATA_BUFFER).position(0).limit(p_110994_2_);
    }
 
-   static void bindTexture(int var0) {
-      GlStateManager.bindTexture(☃);
+   static void bindTexture(int p_94277_0_) {
+      GlStateManager.bindTexture(p_94277_0_);
    }
 
-   public static int[] readImageData(IResourceManager var0, ResourceLocation var1) throws IOException {
-      IResource ☃ = null;
+   public static int[] readImageData(IResourceManager resourceManager, ResourceLocation imageLocation) throws IOException {
+      IResource iresource = null;
 
-      int[] var7;
+      Object i;
       try {
-         ☃ = ☃.getResource(☃);
-         BufferedImage ☃x = readBufferedImage(☃.getInputStream());
-         int ☃xx = ☃x.getWidth();
-         int ☃xxx = ☃x.getHeight();
-         int[] ☃xxxx = new int[☃xx * ☃xxx];
-         ☃x.getRGB(0, 0, ☃xx, ☃xxx, ☃xxxx, 0, ☃xx);
-         var7 = ☃xxxx;
+         iresource = resourceManager.getResource(imageLocation);
+         BufferedImage bufferedimage = readBufferedImage(iresource.getInputStream());
+         if (bufferedimage != null) {
+            int ix = bufferedimage.getWidth();
+            int j = bufferedimage.getHeight();
+            int[] aint = new int[ix * j];
+            bufferedimage.getRGB(0, 0, ix, j, aint, 0, ix);
+            return aint;
+         }
+
+         i = null;
       } finally {
-         IOUtils.closeQuietly(☃);
+         IOUtils.closeQuietly(iresource);
       }
 
-      return var7;
+      return (int[])i;
    }
 
-   public static BufferedImage readBufferedImage(InputStream var0) throws IOException {
-      BufferedImage var1;
-      try {
-         var1 = ImageIO.read(☃);
-      } finally {
-         IOUtils.closeQuietly(☃);
-      }
+   public static BufferedImage readBufferedImage(InputStream imageStream) throws IOException {
+      if (imageStream == null) {
+         return null;
+      } else {
+         BufferedImage bufferedimage;
+         try {
+            bufferedimage = ImageIO.read(imageStream);
+         } finally {
+            IOUtils.closeQuietly(imageStream);
+         }
 
-      return var1;
+         return bufferedimage;
+      }
    }
 
-   public static int[] updateAnaglyph(int[] var0) {
-      int[] ☃ = new int[☃.length];
+   public static int[] updateAnaglyph(int[] p_110985_0_) {
+      int[] aint = new int[p_110985_0_.length];
 
-      for (int ☃x = 0; ☃x < ☃.length; ☃x++) {
-         ☃[☃x] = anaglyphColor(☃[☃x]);
+      for (int i = 0; i < p_110985_0_.length; i++) {
+         aint[i] = anaglyphColor(p_110985_0_[i]);
       }
 
-      return ☃;
+      return aint;
    }
 
-   public static int anaglyphColor(int var0) {
-      int ☃ = ☃ >> 24 & 0xFF;
-      int ☃x = ☃ >> 16 & 0xFF;
-      int ☃xx = ☃ >> 8 & 0xFF;
-      int ☃xxx = ☃ & 0xFF;
-      int ☃xxxx = (☃x * 30 + ☃xx * 59 + ☃xxx * 11) / 100;
-      int ☃xxxxx = (☃x * 30 + ☃xx * 70) / 100;
-      int ☃xxxxxx = (☃x * 30 + ☃xxx * 70) / 100;
-      return ☃ << 24 | ☃xxxx << 16 | ☃xxxxx << 8 | ☃xxxxxx;
+   public static int anaglyphColor(int p_177054_0_) {
+      int i = p_177054_0_ >> 24 & 0xFF;
+      int j = p_177054_0_ >> 16 & 0xFF;
+      int k = p_177054_0_ >> 8 & 0xFF;
+      int l = p_177054_0_ & 0xFF;
+      int i1 = (j * 30 + k * 59 + l * 11) / 100;
+      int j1 = (j * 30 + k * 70) / 100;
+      int k1 = (j * 30 + l * 70) / 100;
+      return i << 24 | i1 << 16 | j1 << 8 | k1;
    }
 
-   public static void processPixelValues(int[] var0, int var1, int var2) {
-      int[] ☃ = new int[☃];
-      int ☃x = ☃ / 2;
+   public static void processPixelValues(int[] p_147953_0_, int p_147953_1_, int p_147953_2_) {
+      int[] aint = new int[p_147953_1_];
+      int i = p_147953_2_ / 2;
 
-      for (int ☃xx = 0; ☃xx < ☃x; ☃xx++) {
-         System.arraycopy(☃, ☃xx * ☃, ☃, 0, ☃);
-         System.arraycopy(☃, (☃ - 1 - ☃xx) * ☃, ☃, ☃xx * ☃, ☃);
-         System.arraycopy(☃, 0, ☃, (☃ - 1 - ☃xx) * ☃, ☃);
+      for (int j = 0; j < i; j++) {
+         System.arraycopy(p_147953_0_, j * p_147953_1_, aint, 0, p_147953_1_);
+         System.arraycopy(p_147953_0_, (p_147953_2_ - 1 - j) * p_147953_1_, p_147953_0_, j * p_147953_1_, p_147953_1_);
+         System.arraycopy(aint, 0, p_147953_0_, (p_147953_2_ - 1 - j) * p_147953_1_, p_147953_1_);
       }
    }
 
    static {
-      int ☃ = -16777216;
-      int ☃x = -524040;
-      int[] ☃xx = new int[]{-524040, -524040, -524040, -524040, -524040, -524040, -524040, -524040};
-      int[] ☃xxx = new int[]{-16777216, -16777216, -16777216, -16777216, -16777216, -16777216, -16777216, -16777216};
-      int ☃xxxx = ☃xx.length;
-
-      for (int ☃xxxxx = 0; ☃xxxxx < 16; ☃xxxxx++) {
-         System.arraycopy(☃xxxxx < ☃xxxx ? ☃xx : ☃xxx, 0, MISSING_TEXTURE_DATA, 16 * ☃xxxxx, ☃xxxx);
-         System.arraycopy(☃xxxxx < ☃xxxx ? ☃xxx : ☃xx, 0, MISSING_TEXTURE_DATA, 16 * ☃xxxxx + ☃xxxx, ☃xxxx);
+      int i = -16777216;
+      int j = -524040;
+      int[] aint = new int[]{-524040, -524040, -524040, -524040, -524040, -524040, -524040, -524040};
+      int[] aint1 = new int[]{-16777216, -16777216, -16777216, -16777216, -16777216, -16777216, -16777216, -16777216};
+      int k = aint.length;
+
+      for (int l = 0; l < 16; l++) {
+         System.arraycopy(l < k ? aint : aint1, 0, MISSING_TEXTURE_DATA, 16 * l, k);
+         System.arraycopy(l < k ? aint1 : aint, 0, MISSING_TEXTURE_DATA, 16 * l + k, k);
       }
 
       MISSING_TEXTURE.updateDynamicTexture();
       COLOR_GAMMAS = new float[256];
 
-      for (int ☃xxxxx = 0; ☃xxxxx < COLOR_GAMMAS.length; ☃xxxxx++) {
-         COLOR_GAMMAS[☃xxxxx] = (float)Math.pow(☃xxxxx / 255.0F, 2.2);
+      for (int i1 = 0; i1 < COLOR_GAMMAS.length; i1++) {
+         COLOR_GAMMAS[i1] = (float)Math.pow(i1 / 255.0F, 2.2);
       }
 
       MIPMAP_BUFFER = new int[4];
diff --git a/patches/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java b/patches/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java
index bc7a3a1..6fdedb5 100644
--- a/patches/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java
+++ b/patches/net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java
@@ -6,41 +6,67 @@
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.tileentity.TileEntityBeacon;
+import net.minecraft.tileentity.TileEntityBeacon.BeamSegment;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.shaders.Shaders;
 
 public class TileEntityBeaconRenderer extends TileEntitySpecialRenderer<TileEntityBeacon> {
    public static final ResourceLocation TEXTURE_BEACON_BEAM = new ResourceLocation("textures/entity/beacon_beam.png");
 
-   public void render(TileEntityBeacon var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      this.renderBeacon(☃, ☃, ☃, ☃, ☃.shouldBeamRender(), ☃.getBeamSegments(), ☃.getWorld().getTotalWorldTime());
+   public void render(TileEntityBeacon te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
+      this.renderBeacon(x, y, z, partialTicks, te.shouldBeamRender(), te.getBeamSegments(), te.D().getTotalWorldTime());
    }
 
-   public void renderBeacon(double var1, double var3, double var5, double var7, double var9, List<TileEntityBeacon.BeamSegment> var11, double var12) {
-      GlStateManager.alphaFunc(516, 0.1F);
-      this.bindTexture(TEXTURE_BEACON_BEAM);
-      if (☃ > 0.0) {
-         GlStateManager.disableFog();
-         int ☃ = 0;
+   public void renderBeacon(double x, double y, double z, double partialTicks, double textureScale, List<BeamSegment> beamSegments, double totalWorldTime) {
+      if (!(textureScale <= 0.0) && beamSegments.size() > 0) {
+         if (Config.isShaders()) {
+            Shaders.beginBeacon();
+         }
+
+         GlStateManager.alphaFunc(516, 0.1F);
+         this.bindTexture(TEXTURE_BEACON_BEAM);
+         if (textureScale > 0.0) {
+            GlStateManager.disableFog();
+            int i = 0;
 
-         for (int ☃x = 0; ☃x < ☃.size(); ☃x++) {
-            TileEntityBeacon.BeamSegment ☃xx = ☃.get(☃x);
-            renderBeamSegment(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃xx.getHeight(), ☃xx.getColors());
-            ☃ += ☃xx.getHeight();
+            for (int j = 0; j < beamSegments.size(); j++) {
+               BeamSegment tileentitybeacon$beamsegment = beamSegments.get(j);
+               renderBeamSegment(
+                  x, y, z, partialTicks, textureScale, totalWorldTime, i, tileentitybeacon$beamsegment.getHeight(), tileentitybeacon$beamsegment.getColors()
+               );
+               i += tileentitybeacon$beamsegment.getHeight();
+            }
+
+            GlStateManager.enableFog();
          }
 
-         GlStateManager.enableFog();
+         if (Config.isShaders()) {
+            Shaders.endBeacon();
+         }
       }
    }
 
-   public static void renderBeamSegment(double var0, double var2, double var4, double var6, double var8, double var10, int var12, int var13, float[] var14) {
-      renderBeamSegment(☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, ☃, 0.2, 0.25);
+   public static void renderBeamSegment(
+      double x, double y, double z, double partialTicks, double textureScale, double totalWorldTime, int yOffset, int height, float[] colors
+   ) {
+      renderBeamSegment(x, y, z, partialTicks, textureScale, totalWorldTime, yOffset, height, colors, 0.2, 0.25);
    }
 
    public static void renderBeamSegment(
-      double var0, double var2, double var4, double var6, double var8, double var10, int var12, int var13, float[] var14, double var15, double var17
+      double x,
+      double y,
+      double z,
+      double partialTicks,
+      double textureScale,
+      double totalWorldTime,
+      int yOffset,
+      int height,
+      float[] colors,
+      double beamRadius,
+      double glowRadius
    ) {
-      int ☃ = ☃ + ☃;
+      int i = yOffset + height;
       GlStateManager.glTexParameteri(3553, 10242, 10497);
       GlStateManager.glTexParameteri(3553, 10243, 10497);
       GlStateManager.disableLighting();
@@ -50,86 +76,90 @@ public static void renderBeamSegment(
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      Tessellator ☃x = Tessellator.getInstance();
-      BufferBuilder ☃xx = ☃x.getBuffer();
-      double ☃xxx = ☃ + ☃;
-      double ☃xxxx = ☃ < 0 ? ☃xxx : -☃xxx;
-      double ☃xxxxx = MathHelper.frac(☃xxxx * 0.2 - MathHelper.floor(☃xxxx * 0.1));
-      float ☃xxxxxx = ☃[0];
-      float ☃xxxxxxx = ☃[1];
-      float ☃xxxxxxxx = ☃[2];
-      double ☃xxxxxxxxx = ☃xxx * 0.025 * -1.5;
-      double ☃xxxxxxxxxx = 0.5 + Math.cos(☃xxxxxxxxx + (Math.PI * 3.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxx = 0.5 + Math.sin(☃xxxxxxxxx + (Math.PI * 3.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxxx = 0.5 + Math.cos(☃xxxxxxxxx + (Math.PI / 4)) * ☃;
-      double ☃xxxxxxxxxxxxx = 0.5 + Math.sin(☃xxxxxxxxx + (Math.PI / 4)) * ☃;
-      double ☃xxxxxxxxxxxxxx = 0.5 + Math.cos(☃xxxxxxxxx + (Math.PI * 5.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxxxxxx = 0.5 + Math.sin(☃xxxxxxxxx + (Math.PI * 5.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxxxxxxx = 0.5 + Math.cos(☃xxxxxxxxx + (Math.PI * 7.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxxxxxxxx = 0.5 + Math.sin(☃xxxxxxxxx + (Math.PI * 7.0 / 4.0)) * ☃;
-      double ☃xxxxxxxxxxxxxxxxxx = 0.0;
-      double ☃xxxxxxxxxxxxxxxxxxx = 1.0;
-      double ☃xxxxxxxxxxxxxxxxxxxx = -1.0 + ☃xxxxx;
-      double ☃xxxxxxxxxxxxxxxxxxxxx = ☃ * ☃ * (0.5 / ☃) + ☃xxxxxxxxxxxxxxxxxxxx;
-      ☃xx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-      ☃xx.pos(☃ + ☃xxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 1.0F).endVertex();
-      ☃x.draw();
+      Tessellator tessellator = Tessellator.getInstance();
+      BufferBuilder bufferbuilder = tessellator.getBuffer();
+      double d0 = totalWorldTime + partialTicks;
+      double d1 = height < 0 ? d0 : -d0;
+      double d2 = MathHelper.frac(d1 * 0.2 - MathHelper.floor(d1 * 0.1));
+      float f = colors[0];
+      float f1 = colors[1];
+      float f2 = colors[2];
+      double d3 = d0 * 0.025 * -1.5;
+      double d4 = 0.5 + Math.cos(d3 + (Math.PI * 3.0 / 4.0)) * beamRadius;
+      double d5 = 0.5 + Math.sin(d3 + (Math.PI * 3.0 / 4.0)) * beamRadius;
+      double d6 = 0.5 + Math.cos(d3 + (Math.PI / 4)) * beamRadius;
+      double d7 = 0.5 + Math.sin(d3 + (Math.PI / 4)) * beamRadius;
+      double d8 = 0.5 + Math.cos(d3 + (Math.PI * 5.0 / 4.0)) * beamRadius;
+      double d9 = 0.5 + Math.sin(d3 + (Math.PI * 5.0 / 4.0)) * beamRadius;
+      double d10 = 0.5 + Math.cos(d3 + (Math.PI * 7.0 / 4.0)) * beamRadius;
+      double d11 = 0.5 + Math.sin(d3 + (Math.PI * 7.0 / 4.0)) * beamRadius;
+      double d12 = 0.0;
+      double d13 = 1.0;
+      double d14 = -1.0 + d2;
+      double d15 = height * textureScale * (0.5 / beamRadius) + d14;
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      bufferbuilder.pos(x + d4, y + i, z + d5).tex(1.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d4, y + yOffset, z + d5).tex(1.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d6, y + yOffset, z + d7).tex(0.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d6, y + i, z + d7).tex(0.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d10, y + i, z + d11).tex(1.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d10, y + yOffset, z + d11).tex(1.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d8, y + yOffset, z + d9).tex(0.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d8, y + i, z + d9).tex(0.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d6, y + i, z + d7).tex(1.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d6, y + yOffset, z + d7).tex(1.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d10, y + yOffset, z + d11).tex(0.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d10, y + i, z + d11).tex(0.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d8, y + i, z + d9).tex(1.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d8, y + yOffset, z + d9).tex(1.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d4, y + yOffset, z + d5).tex(0.0, d14).color(f, f1, f2, 1.0F).endVertex();
+      bufferbuilder.pos(x + d4, y + i, z + d5).tex(0.0, d15).color(f, f1, f2, 1.0F).endVertex();
+      tessellator.draw();
       GlStateManager.enableBlend();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.depthMask(false);
-      ☃xxxxxxxxx = 0.5 - ☃;
-      ☃xxxxxxxxxx = 0.5 - ☃;
-      ☃xxxxxxxxxxx = 0.5 + ☃;
-      ☃xxxxxxxxxxxx = 0.5 - ☃;
-      ☃xxxxxxxxxxxxx = 0.5 - ☃;
-      ☃xxxxxxxxxxxxxx = 0.5 + ☃;
-      ☃xxxxxxxxxxxxxxx = 0.5 + ☃;
-      ☃xxxxxxxxxxxxxxxx = 0.5 + ☃;
-      ☃xxxxxxxxxxxxxxxxx = 0.0;
-      ☃xxxxxxxxxxxxxxxxxx = 1.0;
-      ☃xxxxxxxxxxxxxxxxxxx = -1.0 + ☃xxxxx;
-      ☃xxxxxxxxxxxxxxxxxxxx = ☃ * ☃ + ☃xxxxxxxxxxxxxxxxxxx;
-      ☃xx.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-      ☃xx.pos(☃ + ☃xxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxxxxxx).tex(1.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃xx.pos(☃ + ☃xxxxxxxxx, ☃ + ☃, ☃ + ☃xxxxxxxxxx).tex(0.0, ☃xxxxxxxxxxxxxxxxxxxx).color(☃xxxxxx, ☃xxxxxxx, ☃xxxxxxxx, 0.125F).endVertex();
-      ☃x.draw();
+      if (Config.isShaders()) {
+         GlStateManager.depthMask(Shaders.isBeaconBeamDepth());
+      }
+
+      d3 = 0.5 - glowRadius;
+      d4 = 0.5 - glowRadius;
+      d5 = 0.5 + glowRadius;
+      d6 = 0.5 - glowRadius;
+      d7 = 0.5 - glowRadius;
+      d8 = 0.5 + glowRadius;
+      d9 = 0.5 + glowRadius;
+      d10 = 0.5 + glowRadius;
+      d11 = 0.0;
+      d12 = 1.0;
+      d13 = -1.0 + d2;
+      d14 = height * textureScale + d13;
+      bufferbuilder.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      bufferbuilder.pos(x + d3, y + i, z + d4).tex(1.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d3, y + yOffset, z + d4).tex(1.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d5, y + yOffset, z + d6).tex(0.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d5, y + i, z + d6).tex(0.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d9, y + i, z + d10).tex(1.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d9, y + yOffset, z + d10).tex(1.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d7, y + yOffset, z + d8).tex(0.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d7, y + i, z + d8).tex(0.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d5, y + i, z + d6).tex(1.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d5, y + yOffset, z + d6).tex(1.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d9, y + yOffset, z + d10).tex(0.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d9, y + i, z + d10).tex(0.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d7, y + i, z + d8).tex(1.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d7, y + yOffset, z + d8).tex(1.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d3, y + yOffset, z + d4).tex(0.0, d13).color(f, f1, f2, 0.125F).endVertex();
+      bufferbuilder.pos(x + d3, y + i, z + d4).tex(0.0, d14).color(f, f1, f2, 0.125F).endVertex();
+      tessellator.draw();
       GlStateManager.enableLighting();
       GlStateManager.enableTexture2D();
       GlStateManager.depthMask(true);
    }
 
-   public boolean isGlobalRenderer(TileEntityBeacon var1) {
+   public boolean isGlobalRenderer(TileEntityBeacon te) {
       return true;
    }
 }
diff --git a/patches/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java b/patches/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java
index 458c658..bfc3c8a 100644
--- a/patches/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java
+++ b/patches/net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java
@@ -12,6 +12,7 @@
 import net.minecraft.tileentity.TileEntityEndPortal;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.ShadersRender;
 
 public class TileEntityEndPortalRenderer extends TileEntitySpecialRenderer<TileEntityEndPortal> {
    private static final ResourceLocation END_SKY_TEXTURE = new ResourceLocation("textures/environment/end_sky.png");
@@ -21,154 +22,156 @@ public class TileEntityEndPortalRenderer extends TileEntitySpecialRenderer<TileE
    private static final FloatBuffer PROJECTION = GLAllocation.createDirectFloatBuffer(16);
    private final FloatBuffer buffer = GLAllocation.createDirectFloatBuffer(16);
 
-   public void render(TileEntityEndPortal var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      GlStateManager.disableLighting();
-      RANDOM.setSeed(31100L);
-      GlStateManager.getFloat(2982, MODELVIEW);
-      GlStateManager.getFloat(2983, PROJECTION);
-      double ☃ = ☃ * ☃ + ☃ * ☃ + ☃ * ☃;
-      int ☃x = this.getPasses(☃);
-      float ☃xx = this.getOffset();
-      boolean ☃xxx = false;
-
-      for (int ☃xxxx = 0; ☃xxxx < ☃x; ☃xxxx++) {
-         GlStateManager.pushMatrix();
-         float ☃xxxxx = 2.0F / (18 - ☃xxxx);
-         if (☃xxxx == 0) {
+   public void render(TileEntityEndPortal te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
+      if (!Config.isShaders() || !ShadersRender.renderEndPortal(te, x, y, z, partialTicks, destroyStage, this.getOffset())) {
+         GlStateManager.disableLighting();
+         RANDOM.setSeed(31100L);
+         GlStateManager.getFloat(2982, MODELVIEW);
+         GlStateManager.getFloat(2983, PROJECTION);
+         double d0 = x * x + y * y + z * z;
+         int i = this.getPasses(d0);
+         float f = this.getOffset();
+         boolean flag = false;
+
+         for (int j = 0; j < i; j++) {
+            GlStateManager.pushMatrix();
+            float f1 = 2.0F / (18 - j);
+            if (j == 0) {
+               this.bindTexture(END_SKY_TEXTURE);
+               f1 = 0.15F;
+               GlStateManager.enableBlend();
+               GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+            }
+
+            if (j >= 1) {
+               this.bindTexture(END_PORTAL_TEXTURE);
+               flag = true;
+               Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+            }
+
+            if (j == 1) {
+               GlStateManager.enableBlend();
+               GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+            }
+
+            GlStateManager.texGen(GlStateManager.TexGen.S, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.T, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.R, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));
+            GlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));
+            GlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5890);
+            GlStateManager.pushMatrix();
+            GlStateManager.loadIdentity();
+            GlStateManager.translate(0.5F, 0.5F, 0.0F);
+            GlStateManager.scale(0.5F, 0.5F, 1.0F);
+            float f2 = j + 1;
+            GlStateManager.translate(17.0F / f2, (2.0F + f2 / 1.5F) * ((float)Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);
+            GlStateManager.rotate((f2 * f2 * 4321.0F + f2 * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.scale(4.5F - f2 / 4.0F, 4.5F - f2 / 4.0F, 1.0F);
+            GlStateManager.multMatrix(PROJECTION);
+            GlStateManager.multMatrix(MODELVIEW);
+            Tessellator tessellator = Tessellator.getInstance();
+            BufferBuilder bufferbuilder = tessellator.getBuffer();
+            bufferbuilder.begin(7, DefaultVertexFormats.POSITION_COLOR);
+            float f3 = (RANDOM.nextFloat() * 0.5F + 0.1F) * f1;
+            float f4 = (RANDOM.nextFloat() * 0.5F + 0.4F) * f1;
+            float f5 = (RANDOM.nextFloat() * 0.5F + 0.5F) * f1;
+            if (te.shouldRenderFace(EnumFacing.SOUTH)) {
+               bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            if (te.shouldRenderFace(EnumFacing.NORTH)) {
+               bufferbuilder.pos(x, y + 1.0, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y + 1.0, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            if (te.shouldRenderFace(EnumFacing.EAST)) {
+               bufferbuilder.pos(x + 1.0, y + 1.0, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            if (te.shouldRenderFace(EnumFacing.WEST)) {
+               bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y + 1.0, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y + 1.0, z).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            if (te.shouldRenderFace(EnumFacing.DOWN)) {
+               bufferbuilder.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            if (te.shouldRenderFace(EnumFacing.UP)) {
+               bufferbuilder.pos(x, y + f, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y + f, z + 1.0).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x + 1.0, y + f, z).color(f3, f4, f5, 1.0F).endVertex();
+               bufferbuilder.pos(x, y + f, z).color(f3, f4, f5, 1.0F).endVertex();
+            }
+
+            tessellator.draw();
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5888);
             this.bindTexture(END_SKY_TEXTURE);
-            ☃xxxxx = 0.15F;
-            GlStateManager.enableBlend();
-            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
          }
 
-         if (☃xxxx >= 1) {
-            this.bindTexture(END_PORTAL_TEXTURE);
-            ☃xxx = true;
-            Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+         GlStateManager.disableBlend();
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);
+         GlStateManager.enableLighting();
+         if (flag) {
+            Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
          }
-
-         if (☃xxxx == 1) {
-            GlStateManager.enableBlend();
-            GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
-         }
-
-         GlStateManager.texGen(GlStateManager.TexGen.S, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.T, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.R, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));
-         GlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));
-         GlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);
-         GlStateManager.popMatrix();
-         GlStateManager.matrixMode(5890);
-         GlStateManager.pushMatrix();
-         GlStateManager.loadIdentity();
-         GlStateManager.translate(0.5F, 0.5F, 0.0F);
-         GlStateManager.scale(0.5F, 0.5F, 1.0F);
-         float ☃xxxxxx = ☃xxxx + 1;
-         GlStateManager.translate(17.0F / ☃xxxxxx, (2.0F + ☃xxxxxx / 1.5F) * ((float)Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);
-         GlStateManager.rotate((☃xxxxxx * ☃xxxxxx * 4321.0F + ☃xxxxxx * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.scale(4.5F - ☃xxxxxx / 4.0F, 4.5F - ☃xxxxxx / 4.0F, 1.0F);
-         GlStateManager.multMatrix(PROJECTION);
-         GlStateManager.multMatrix(MODELVIEW);
-         Tessellator ☃xxxxxxx = Tessellator.getInstance();
-         BufferBuilder ☃xxxxxxxx = ☃xxxxxxx.getBuffer();
-         ☃xxxxxxxx.begin(7, DefaultVertexFormats.POSITION_COLOR);
-         float ☃xxxxxxxxx = (RANDOM.nextFloat() * 0.5F + 0.1F) * ☃xxxxx;
-         float ☃xxxxxxxxxx = (RANDOM.nextFloat() * 0.5F + 0.4F) * ☃xxxxx;
-         float ☃xxxxxxxxxxx = (RANDOM.nextFloat() * 0.5F + 0.5F) * ☃xxxxx;
-         if (☃.shouldRenderFace(EnumFacing.SOUTH)) {
-            ☃xxxxxxxx.pos(☃, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + 1.0, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃ + 1.0, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         if (☃.shouldRenderFace(EnumFacing.NORTH)) {
-            ☃xxxxxxxx.pos(☃, ☃ + 1.0, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + 1.0, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         if (☃.shouldRenderFace(EnumFacing.EAST)) {
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + 1.0, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + 1.0, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         if (☃.shouldRenderFace(EnumFacing.WEST)) {
-            ☃xxxxxxxx.pos(☃, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃ + 1.0, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃ + 1.0, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         if (☃.shouldRenderFace(EnumFacing.DOWN)) {
-            ☃xxxxxxxx.pos(☃, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         if (☃.shouldRenderFace(EnumFacing.UP)) {
-            ☃xxxxxxxx.pos(☃, ☃ + ☃xx, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + ☃xx, ☃ + 1.0).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃ + 1.0, ☃ + ☃xx, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-            ☃xxxxxxxx.pos(☃, ☃ + ☃xx, ☃).color(☃xxxxxxxxx, ☃xxxxxxxxxx, ☃xxxxxxxxxxx, 1.0F).endVertex();
-         }
-
-         ☃xxxxxxx.draw();
-         GlStateManager.popMatrix();
-         GlStateManager.matrixMode(5888);
-         this.bindTexture(END_SKY_TEXTURE);
-      }
-
-      GlStateManager.disableBlend();
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);
-      GlStateManager.enableLighting();
-      if (☃xxx) {
-         Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
       }
    }
 
-   protected int getPasses(double var1) {
-      int ☃;
-      if (☃ > 36864.0) {
-         ☃ = 1;
-      } else if (☃ > 25600.0) {
-         ☃ = 3;
-      } else if (☃ > 16384.0) {
-         ☃ = 5;
-      } else if (☃ > 9216.0) {
-         ☃ = 7;
-      } else if (☃ > 4096.0) {
-         ☃ = 9;
-      } else if (☃ > 1024.0) {
-         ☃ = 11;
-      } else if (☃ > 576.0) {
-         ☃ = 13;
-      } else if (☃ > 256.0) {
-         ☃ = 14;
+   protected int getPasses(double p_191286_1_) {
+      int i;
+      if (p_191286_1_ > 36864.0) {
+         i = 1;
+      } else if (p_191286_1_ > 25600.0) {
+         i = 3;
+      } else if (p_191286_1_ > 16384.0) {
+         i = 5;
+      } else if (p_191286_1_ > 9216.0) {
+         i = 7;
+      } else if (p_191286_1_ > 4096.0) {
+         i = 9;
+      } else if (p_191286_1_ > 1024.0) {
+         i = 11;
+      } else if (p_191286_1_ > 576.0) {
+         i = 13;
+      } else if (p_191286_1_ > 256.0) {
+         i = 14;
       } else {
-         ☃ = 15;
+         i = 15;
       }
 
-      return ☃;
+      return i;
    }
 
    protected float getOffset() {
       return 0.75F;
    }
 
-   private FloatBuffer getBuffer(float var1, float var2, float var3, float var4) {
+   private FloatBuffer getBuffer(float p_147525_1_, float p_147525_2_, float p_147525_3_, float p_147525_4_) {
       ((Buffer)this.buffer).clear();
-      this.buffer.put(☃).put(☃).put(☃).put(☃);
+      this.buffer.put(p_147525_1_).put(p_147525_2_).put(p_147525_3_).put(p_147525_4_);
       ((Buffer)this.buffer).flip();
       return this.buffer;
    }
diff --git a/patches/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java b/patches/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java
index 4d4fb70..972346a 100644
--- a/patches/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java
+++ b/patches/net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java
@@ -3,12 +3,16 @@
 import com.google.common.collect.Maps;
 import java.util.Map;
 import javax.annotation.Nullable;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.model.ModelShulker;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.RenderHelper;
+import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureManager;
+import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
@@ -30,12 +34,15 @@
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
+import net.optifine.EmissiveTextures;
+import net.optifine.reflect.Reflector;
 
 public class TileEntityRendererDispatcher {
-   private final Map<Class<? extends TileEntity>, TileEntitySpecialRenderer<? extends TileEntity>> renderers = Maps.newHashMap();
+   public final Map<Class<? extends TileEntity>, TileEntitySpecialRenderer<? extends TileEntity>> renderers = Maps.newHashMap();
    public static TileEntityRendererDispatcher instance = new TileEntityRendererDispatcher();
-   private FontRenderer fontRenderer;
+   public FontRenderer fontRenderer;
    public static double staticPlayerX;
    public static double staticPlayerY;
    public static double staticPlayerZ;
@@ -48,6 +55,9 @@ public class TileEntityRendererDispatcher {
    public double entityX;
    public double entityY;
    public double entityZ;
+   public TileEntity tileEntityRendered;
+   private Tessellator batchBuffer = new Tessellator(2097152);
+   private boolean drawingBatch = false;
 
    private TileEntityRendererDispatcher() {
       this.renderers.put(TileEntitySign.class, new TileEntitySignRenderer());
@@ -65,80 +75,124 @@ private TileEntityRendererDispatcher() {
       this.renderers.put(TileEntityShulkerBox.class, new TileEntityShulkerBoxRenderer(new ModelShulker()));
       this.renderers.put(TileEntityBed.class, new TileEntityBedRenderer());
 
-      for (TileEntitySpecialRenderer<?> ☃ : this.renderers.values()) {
-         ☃.setRendererDispatcher(this);
+      for (TileEntitySpecialRenderer<?> tileentityspecialrenderer : this.renderers.values()) {
+         tileentityspecialrenderer.setRendererDispatcher(this);
       }
    }
 
-   public <T extends TileEntity> TileEntitySpecialRenderer<T> getRenderer(Class<? extends TileEntity> var1) {
-      TileEntitySpecialRenderer<? extends TileEntity> ☃ = this.renderers.get(☃);
-      if (☃ == null && ☃ != TileEntity.class) {
-         ☃ = this.getRenderer((Class<? extends TileEntity>)☃.getSuperclass());
-         this.renderers.put(☃, ☃);
+   public <T extends TileEntity> TileEntitySpecialRenderer<T> getRenderer(Class<? extends TileEntity> teClass) {
+      TileEntitySpecialRenderer<T> tileentityspecialrenderer = (TileEntitySpecialRenderer<T>)this.renderers.get(teClass);
+      if (tileentityspecialrenderer == null && teClass != TileEntity.class) {
+         tileentityspecialrenderer = this.getRenderer((Class<? extends TileEntity>)teClass.getSuperclass());
+         this.renderers.put(teClass, tileentityspecialrenderer);
       }
 
-      return (TileEntitySpecialRenderer<T>)☃;
+      return tileentityspecialrenderer;
    }
 
    @Nullable
-   public <T extends TileEntity> TileEntitySpecialRenderer<T> getRenderer(@Nullable TileEntity var1) {
-      return ☃ == null ? null : this.getRenderer((Class<? extends TileEntity>)☃.getClass());
+   public <T extends TileEntity> TileEntitySpecialRenderer<T> getRenderer(@Nullable TileEntity tileEntityIn) {
+      return tileEntityIn != null && !tileEntityIn.isInvalid() ? this.getRenderer((Class<? extends TileEntity>)tileEntityIn.getClass()) : null;
    }
 
-   public void prepare(World var1, TextureManager var2, FontRenderer var3, Entity var4, RayTraceResult var5, float var6) {
-      if (this.world != ☃) {
-         this.setWorld(☃);
+   public void prepare(
+      World worldIn, TextureManager renderEngineIn, FontRenderer fontRendererIn, Entity entityIn, RayTraceResult cameraHitResultIn, float p_190056_6_
+   ) {
+      if (this.world != worldIn) {
+         this.setWorld(worldIn);
       }
 
-      this.renderEngine = ☃;
-      this.entity = ☃;
-      this.fontRenderer = ☃;
-      this.cameraHitResult = ☃;
-      this.entityYaw = ☃.prevRotationYaw + (☃.rotationYaw - ☃.prevRotationYaw) * ☃;
-      this.entityPitch = ☃.prevRotationPitch + (☃.rotationPitch - ☃.prevRotationPitch) * ☃;
-      this.entityX = ☃.lastTickPosX + (☃.posX - ☃.lastTickPosX) * ☃;
-      this.entityY = ☃.lastTickPosY + (☃.posY - ☃.lastTickPosY) * ☃;
-      this.entityZ = ☃.lastTickPosZ + (☃.posZ - ☃.lastTickPosZ) * ☃;
+      this.renderEngine = renderEngineIn;
+      this.entity = entityIn;
+      this.fontRenderer = fontRendererIn;
+      this.cameraHitResult = cameraHitResultIn;
+      this.entityYaw = entityIn.prevRotationYaw + (entityIn.rotationYaw - entityIn.prevRotationYaw) * p_190056_6_;
+      this.entityPitch = entityIn.prevRotationPitch + (entityIn.rotationPitch - entityIn.prevRotationPitch) * p_190056_6_;
+      this.entityX = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * p_190056_6_;
+      this.entityY = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * p_190056_6_;
+      this.entityZ = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * p_190056_6_;
    }
 
-   public void render(TileEntity var1, float var2, int var3) {
-      if (☃.getDistanceSq(this.entityX, this.entityY, this.entityZ) < ☃.getMaxRenderDistanceSquared()) {
-         RenderHelper.enableStandardItemLighting();
-         int ☃ = this.world.getCombinedLight(☃.getPos(), 0);
-         int ☃x = ☃ % 65536;
-         int ☃xx = ☃ / 65536;
-         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, ☃x, ☃xx);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         BlockPos ☃xxx = ☃.getPos();
-         this.render(☃, ☃xxx.getX() - staticPlayerX, ☃xxx.getY() - staticPlayerY, ☃xxx.getZ() - staticPlayerZ, ☃, ☃, 1.0F);
+   public void render(TileEntity tileentityIn, float partialTicks, int destroyStage) {
+      if (tileentityIn.getDistanceSq(this.entityX, this.entityY, this.entityZ) < tileentityIn.getMaxRenderDistanceSquared()) {
+         boolean setLightmap = true;
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            setLightmap = !this.drawingBatch || !Reflector.callBoolean(tileentityIn, Reflector.ForgeTileEntity_hasFastRenderer, new Object[0]);
+         }
+
+         if (setLightmap) {
+            RenderHelper.enableStandardItemLighting();
+            int i = this.world.getCombinedLight(tileentityIn.getPos(), 0);
+            int j = i % 65536;
+            int k = i / 65536;
+            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, j, k);
+            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         }
+
+         BlockPos blockpos = tileentityIn.getPos();
+         if (!this.world.isBlockLoaded(blockpos, false)) {
+            return;
+         }
+
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.beginRender();
+         }
+
+         this.render(
+            tileentityIn, blockpos.getX() - staticPlayerX, blockpos.getY() - staticPlayerY, blockpos.getZ() - staticPlayerZ, partialTicks, destroyStage, 1.0F
+         );
+         if (EmissiveTextures.isActive()) {
+            if (EmissiveTextures.hasEmissive()) {
+               EmissiveTextures.beginRenderEmissive();
+               this.render(
+                  tileentityIn,
+                  blockpos.getX() - staticPlayerX,
+                  blockpos.getY() - staticPlayerY,
+                  blockpos.getZ() - staticPlayerZ,
+                  partialTicks,
+                  destroyStage,
+                  1.0F
+               );
+               EmissiveTextures.endRenderEmissive();
+            }
+
+            EmissiveTextures.endRender();
+         }
       }
    }
 
-   public void render(TileEntity var1, double var2, double var4, double var6, float var8) {
-      this.render(☃, ☃, ☃, ☃, ☃, 1.0F);
+   public void render(TileEntity tileEntityIn, double x, double y, double z, float partialTicks) {
+      this.render(tileEntityIn, x, y, z, partialTicks, 1.0F);
    }
 
-   public void render(TileEntity var1, double var2, double var4, double var6, float var8, float var9) {
-      this.render(☃, ☃, ☃, ☃, ☃, -1, ☃);
+   public void render(TileEntity p_192855_1_, double p_192855_2_, double p_192855_4_, double p_192855_6_, float p_192855_8_, float p_192855_9_) {
+      this.render(p_192855_1_, p_192855_2_, p_192855_4_, p_192855_6_, p_192855_8_, -1, p_192855_9_);
    }
 
-   public void render(TileEntity var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      TileEntitySpecialRenderer<TileEntity> ☃ = this.getRenderer(☃);
-      if (☃ != null) {
+   public void render(TileEntity tileEntityIn, double x, double y, double z, float partialTicks, int destroyStage, float p_192854_10_) {
+      TileEntitySpecialRenderer<TileEntity> tileentityspecialrenderer = this.getRenderer(tileEntityIn);
+      if (tileentityspecialrenderer != null) {
          try {
-            ☃.render(☃, ☃, ☃, ☃, ☃, ☃, ☃);
+            this.tileEntityRendered = tileEntityIn;
+            if (this.drawingBatch && Reflector.callBoolean(tileEntityIn, Reflector.ForgeTileEntity_hasFastRenderer, new Object[0])) {
+               tileentityspecialrenderer.renderTileEntityFast(tileEntityIn, x, y, z, partialTicks, destroyStage, p_192854_10_, this.batchBuffer.getBuffer());
+            } else {
+               tileentityspecialrenderer.render(tileEntityIn, x, y, z, partialTicks, destroyStage, p_192854_10_);
+            }
+
+            this.tileEntityRendered = null;
          } catch (Throwable var15) {
-            CrashReport ☃x = CrashReport.makeCrashReport(var15, "Rendering Block Entity");
-            CrashReportCategory ☃xx = ☃x.makeCategory("Block Entity Details");
-            ☃.addInfoToCrashReport(☃xx);
-            throw new ReportedException(☃x);
+            CrashReport crashreport = CrashReport.makeCrashReport(var15, "Rendering Block Entity");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Block Entity Details");
+            tileEntityIn.addInfoToCrashReport(crashreportcategory);
+            throw new ReportedException(crashreport);
          }
       }
    }
 
-   public void setWorld(@Nullable World var1) {
-      this.world = ☃;
-      if (☃ == null) {
+   public void setWorld(@Nullable World worldIn) {
+      this.world = worldIn;
+      if (worldIn == null) {
          this.entity = null;
       }
    }
@@ -146,4 +200,35 @@ public void setWorld(@Nullable World var1) {
    public FontRenderer getFontRenderer() {
       return this.fontRenderer;
    }
+
+   public void preDrawBatch() {
+      this.batchBuffer.getBuffer().begin(7, DefaultVertexFormats.BLOCK);
+      this.drawingBatch = true;
+   }
+
+   public void drawBatch(int pass) {
+      this.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+      RenderHelper.disableStandardItemLighting();
+      GlStateManager.blendFunc(770, 771);
+      GlStateManager.enableBlend();
+      GlStateManager.disableCull();
+      if (Minecraft.isAmbientOcclusionEnabled()) {
+         GlStateManager.shadeModel(7425);
+      } else {
+         GlStateManager.shadeModel(7424);
+      }
+
+      if (pass > 0) {
+         Vec3d cameraPos = (Vec3d)Reflector.call(Reflector.ActiveRenderInfo_getCameraPosition, new Object[0]);
+         if (cameraPos != null) {
+            this.batchBuffer.getBuffer().sortVertexData((float)cameraPos.x, (float)cameraPos.y, (float)cameraPos.z);
+         } else {
+            this.batchBuffer.getBuffer().sortVertexData(0.0F, 0.0F, 0.0F);
+         }
+      }
+
+      this.batchBuffer.draw();
+      RenderHelper.enableStandardItemLighting();
+      this.drawingBatch = false;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java b/patches/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java
index da6ba5b..f486379 100644
--- a/patches/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java
+++ b/patches/net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java
@@ -2,51 +2,56 @@
 
 import java.util.List;
 import net.minecraft.block.Block;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiUtilRenderComponents;
 import net.minecraft.client.model.ModelSign;
 import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.entity.Entity;
 import net.minecraft.init.Blocks;
 import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.text.ITextComponent;
+import net.optifine.CustomColors;
+import net.optifine.shaders.Shaders;
 
 public class TileEntitySignRenderer extends TileEntitySpecialRenderer<TileEntitySign> {
    private static final ResourceLocation SIGN_TEXTURE = new ResourceLocation("textures/entity/sign.png");
    private final ModelSign model = new ModelSign();
+   private static double textRenderDistanceSq = 4096.0;
 
-   public void render(TileEntitySign var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      Block ☃ = ☃.getBlockType();
+   public void render(TileEntitySign te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
+      Block block = te.x();
       GlStateManager.pushMatrix();
-      float ☃x = 0.6666667F;
-      if (☃ == Blocks.STANDING_SIGN) {
-         GlStateManager.translate((float)☃ + 0.5F, (float)☃ + 0.5F, (float)☃ + 0.5F);
-         float ☃xx = ☃.getBlockMetadata() * 360 / 16.0F;
-         GlStateManager.rotate(-☃xx, 0.0F, 1.0F, 0.0F);
+      float f = 0.6666667F;
+      if (block == Blocks.STANDING_SIGN) {
+         GlStateManager.translate((float)x + 0.5F, (float)y + 0.5F, (float)z + 0.5F);
+         float f1 = te.v() * 360 / 16.0F;
+         GlStateManager.rotate(-f1, 0.0F, 1.0F, 0.0F);
          this.model.signStick.showModel = true;
       } else {
-         int ☃xx = ☃.getBlockMetadata();
-         float ☃xxx = 0.0F;
-         if (☃xx == 2) {
-            ☃xxx = 180.0F;
+         int k = te.v();
+         float f2 = 0.0F;
+         if (k == 2) {
+            f2 = 180.0F;
          }
 
-         if (☃xx == 4) {
-            ☃xxx = 90.0F;
+         if (k == 4) {
+            f2 = 90.0F;
          }
 
-         if (☃xx == 5) {
-            ☃xxx = -90.0F;
+         if (k == 5) {
+            f2 = -90.0F;
          }
 
-         GlStateManager.translate((float)☃ + 0.5F, (float)☃ + 0.5F, (float)☃ + 0.5F);
-         GlStateManager.rotate(-☃xxx, 0.0F, 1.0F, 0.0F);
+         GlStateManager.translate((float)x + 0.5F, (float)y + 0.5F, (float)z + 0.5F);
+         GlStateManager.rotate(-f2, 0.0F, 1.0F, 0.0F);
          GlStateManager.translate(0.0F, -0.3125F, -0.4375F);
          this.model.signStick.showModel = false;
       }
 
-      if (☃ >= 0) {
-         this.bindTexture(DESTROY_STAGES[☃]);
+      if (destroyStage >= 0) {
+         this.bindTexture(DESTROY_STAGES[destroyStage]);
          GlStateManager.matrixMode(5890);
          GlStateManager.pushMatrix();
          GlStateManager.scale(4.0F, 2.0F, 1.0F);
@@ -61,24 +66,30 @@ public void render(TileEntitySign var1, double var2, double var4, double var6, f
       GlStateManager.scale(0.6666667F, -0.6666667F, -0.6666667F);
       this.model.renderSign();
       GlStateManager.popMatrix();
-      FontRenderer ☃xxxx = this.getFontRenderer();
-      float ☃xxxxx = 0.010416667F;
-      GlStateManager.translate(0.0F, 0.33333334F, 0.046666667F);
-      GlStateManager.scale(0.010416667F, -0.010416667F, 0.010416667F);
-      GlStateManager.glNormal3f(0.0F, 0.0F, -0.010416667F);
-      GlStateManager.depthMask(false);
-      int ☃xxxxxx = 0;
-      if (☃ < 0) {
-         for (int ☃xxxxxxx = 0; ☃xxxxxxx < ☃.signText.length; ☃xxxxxxx++) {
-            if (☃.signText[☃xxxxxxx] != null) {
-               ITextComponent ☃xxxxxxxx = ☃.signText[☃xxxxxxx];
-               List<ITextComponent> ☃xxxxxxxxx = GuiUtilRenderComponents.splitText(☃xxxxxxxx, 90, ☃xxxx, false, true);
-               String ☃xxxxxxxxxx = ☃xxxxxxxxx != null && !☃xxxxxxxxx.isEmpty() ? ☃xxxxxxxxx.get(0).getFormattedText() : "";
-               if (☃xxxxxxx == ☃.lineBeingEdited) {
-                  ☃xxxxxxxxxx = "> " + ☃xxxxxxxxxx + " <";
-                  ☃xxxx.drawString(☃xxxxxxxxxx, -☃xxxx.getStringWidth(☃xxxxxxxxxx) / 2, ☃xxxxxxx * 10 - ☃.signText.length * 5, 0);
-               } else {
-                  ☃xxxx.drawString(☃xxxxxxxxxx, -☃xxxx.getStringWidth(☃xxxxxxxxxx) / 2, ☃xxxxxxx * 10 - ☃.signText.length * 5, 0);
+      if (isRenderText(te)) {
+         FontRenderer fontrenderer = this.getFontRenderer();
+         float f3 = 0.010416667F;
+         GlStateManager.translate(0.0F, 0.33333334F, 0.046666667F);
+         GlStateManager.scale(0.010416667F, -0.010416667F, 0.010416667F);
+         GlStateManager.glNormal3f(0.0F, 0.0F, -0.010416667F);
+         GlStateManager.depthMask(false);
+         int i = 0;
+         if (Config.isCustomColors()) {
+            i = CustomColors.getSignTextColor(i);
+         }
+
+         if (destroyStage < 0) {
+            for (int j = 0; j < te.signText.length; j++) {
+               if (te.signText[j] != null) {
+                  ITextComponent itextcomponent = te.signText[j];
+                  List<ITextComponent> list = GuiUtilRenderComponents.splitText(itextcomponent, 90, fontrenderer, false, true);
+                  String s = list != null && !list.isEmpty() ? list.get(0).getFormattedText() : "";
+                  if (j == te.lineBeingEdited) {
+                     s = "> " + s + " <";
+                     fontrenderer.drawString(s, -fontrenderer.getStringWidth(s) / 2, j * 10 - te.signText.length * 5, i);
+                  } else {
+                     fontrenderer.drawString(s, -fontrenderer.getStringWidth(s) / 2, j * 10 - te.signText.length * 5, i);
+                  }
                }
             }
          }
@@ -87,10 +98,33 @@ public void render(TileEntitySign var1, double var2, double var4, double var6, f
       GlStateManager.depthMask(true);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.popMatrix();
-      if (☃ >= 0) {
+      if (destroyStage >= 0) {
          GlStateManager.matrixMode(5890);
          GlStateManager.popMatrix();
          GlStateManager.matrixMode(5888);
       }
    }
+
+   private static boolean isRenderText(TileEntitySign tileEntity) {
+      if (Shaders.isShadowPass) {
+         return false;
+      } else {
+         if (!Config.zoomMode && tileEntity.lineBeingEdited < 0) {
+            Entity viewEntity = Config.getMinecraft().getRenderViewEntity();
+            double distSq = tileEntity.a(viewEntity.posX, viewEntity.posY, viewEntity.posZ);
+            if (distSq > textRenderDistanceSq) {
+               return false;
+            }
+         }
+
+         return true;
+      }
+   }
+
+   public static void updateTextRenderDistance() {
+      Minecraft mc = Config.getMinecraft();
+      double fov = Config.limit(mc.gameSettings.fovSetting, 1.0F, 120.0F);
+      double textRenderDistance = Math.max(1.5 * mc.displayHeight / fov, 16.0);
+      textRenderDistanceSq = textRenderDistance * textRenderDistance;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java b/patches/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java
index 5f31ac3..ea37719 100644
--- a/patches/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java
+++ b/patches/net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java
@@ -1,6 +1,7 @@
 package net.minecraft.client.renderer.tileentity;
 
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.EntityRenderer;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
@@ -10,8 +11,9 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.world.World;
+import net.optifine.entity.model.IEntityRenderer;
 
-public abstract class TileEntitySpecialRenderer<T extends TileEntity> {
+public abstract class TileEntitySpecialRenderer<T extends TileEntity> implements IEntityRenderer {
    protected static final ResourceLocation[] DESTROY_STAGES = new ResourceLocation[]{
       new ResourceLocation("textures/blocks/destroy_stage_0.png"),
       new ResourceLocation("textures/blocks/destroy_stage_1.png"),
@@ -25,19 +27,23 @@ public abstract class TileEntitySpecialRenderer<T extends TileEntity> {
       new ResourceLocation("textures/blocks/destroy_stage_9.png")
    };
    protected TileEntityRendererDispatcher rendererDispatcher;
+   private Class tileEntityClass = null;
+   private ResourceLocation locationTextureCustom = null;
 
-   public void render(T var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      ITextComponent ☃ = ☃.getDisplayName();
-      if (☃ != null && this.rendererDispatcher.cameraHitResult != null && ☃.getPos().equals(this.rendererDispatcher.cameraHitResult.getBlockPos())) {
+   public void render(T te, double x, double y, double z, float partialTicks, int destroyStage, float alpha) {
+      ITextComponent itextcomponent = te.getDisplayName();
+      if (itextcomponent != null
+         && this.rendererDispatcher.cameraHitResult != null
+         && te.getPos().equals(this.rendererDispatcher.cameraHitResult.getBlockPos())) {
          this.setLightmapDisabled(true);
-         this.drawNameplate(☃, ☃.getFormattedText(), ☃, ☃, ☃, 12);
+         this.drawNameplate(te, itextcomponent.getFormattedText(), x, y, z, 12);
          this.setLightmapDisabled(false);
       }
    }
 
-   protected void setLightmapDisabled(boolean var1) {
+   protected void setLightmapDisabled(boolean disabled) {
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
-      if (☃) {
+      if (disabled) {
          GlStateManager.disableTexture2D();
       } else {
          GlStateManager.enableTexture2D();
@@ -46,10 +52,10 @@ protected void setLightmapDisabled(boolean var1) {
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }
 
-   protected void bindTexture(ResourceLocation var1) {
-      TextureManager ☃ = this.rendererDispatcher.renderEngine;
-      if (☃ != null) {
-         ☃.bindTexture(☃);
+   protected void bindTexture(ResourceLocation location) {
+      TextureManager texturemanager = this.rendererDispatcher.renderEngine;
+      if (texturemanager != null) {
+         texturemanager.bindTexture(location);
       }
    }
 
@@ -57,26 +63,45 @@ protected World getWorld() {
       return this.rendererDispatcher.world;
    }
 
-   public void setRendererDispatcher(TileEntityRendererDispatcher var1) {
-      this.rendererDispatcher = ☃;
+   public void setRendererDispatcher(TileEntityRendererDispatcher rendererDispatcherIn) {
+      this.rendererDispatcher = rendererDispatcherIn;
    }
 
    public FontRenderer getFontRenderer() {
       return this.rendererDispatcher.getFontRenderer();
    }
 
-   public boolean isGlobalRenderer(T var1) {
+   public boolean isGlobalRenderer(T te) {
       return false;
    }
 
-   protected void drawNameplate(T var1, String var2, double var3, double var5, double var7, int var9) {
-      Entity ☃ = this.rendererDispatcher.entity;
-      double ☃x = ☃.getDistanceSq(☃.posX, ☃.posY, ☃.posZ);
-      if (!(☃x > ☃ * ☃)) {
-         float ☃xx = this.rendererDispatcher.entityYaw;
-         float ☃xxx = this.rendererDispatcher.entityPitch;
-         boolean ☃xxxx = false;
-         EntityRenderer.drawNameplate(this.getFontRenderer(), ☃, (float)☃ + 0.5F, (float)☃ + 1.5F, (float)☃ + 0.5F, 0, ☃xx, ☃xxx, false, false);
+   protected void drawNameplate(T te, String str, double x, double y, double z, int maxDistance) {
+      Entity entity = this.rendererDispatcher.entity;
+      double d0 = te.getDistanceSq(entity.posX, entity.posY, entity.posZ);
+      if (d0 <= maxDistance * maxDistance) {
+         float f = this.rendererDispatcher.entityYaw;
+         float f1 = this.rendererDispatcher.entityPitch;
+         boolean flag = false;
+         EntityRenderer.drawNameplate(this.getFontRenderer(), str, (float)x + 0.5F, (float)y + 1.5F, (float)z + 0.5F, 0, f, f1, false, false);
       }
    }
+
+   public void renderTileEntityFast(T te, double x, double y, double z, float partialTicks, int destroyStage, float partial, BufferBuilder buffer) {
+   }
+
+   public Class getEntityClass() {
+      return this.tileEntityClass;
+   }
+
+   public void setEntityClass(Class tileEntityClass) {
+      this.tileEntityClass = tileEntityClass;
+   }
+
+   public ResourceLocation getLocationTextureCustom() {
+      return this.locationTextureCustom;
+   }
+
+   public void setLocationTextureCustom(ResourceLocation locationTextureCustom) {
+      this.locationTextureCustom = locationTextureCustom;
+   }
 }
diff --git a/patches/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java b/patches/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java
index afb6904..06aa34d 100644
--- a/patches/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java
+++ b/patches/net/minecraft/client/renderer/vertex/DefaultVertexFormats.java
@@ -1,8 +1,20 @@
 package net.minecraft.client.renderer.vertex;
 
+import java.lang.reflect.Field;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumType;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.optifine.reflect.ReflectorClass;
+import net.optifine.reflect.ReflectorField;
+import net.optifine.shaders.SVertexFormat;
+
 public class DefaultVertexFormats {
-   public static final VertexFormat BLOCK = new VertexFormat();
-   public static final VertexFormat ITEM = new VertexFormat();
+   public static VertexFormat BLOCK = new VertexFormat();
+   public static VertexFormat ITEM = new VertexFormat();
+   private static final VertexFormat BLOCK_VANILLA = BLOCK;
+   private static final VertexFormat ITEM_VANILLA = ITEM;
+   public static ReflectorClass Attributes = new ReflectorClass("net.minecraftforge.client.model.Attributes");
+   public static ReflectorField Attributes_DEFAULT_BAKED_FORMAT = new ReflectorField(Attributes, "DEFAULT_BAKED_FORMAT");
+   private static final VertexFormat FORGE_BAKED = SVertexFormat.duplicate((VertexFormat)getFieldValue(Attributes_DEFAULT_BAKED_FORMAT));
    public static final VertexFormat OLDMODEL_POSITION_TEX_NORMAL = new VertexFormat();
    public static final VertexFormat PARTICLE_POSITION_TEX_COLOR_LMAP = new VertexFormat();
    public static final VertexFormat POSITION = new VertexFormat();
@@ -13,14 +25,38 @@ public class DefaultVertexFormats {
    public static final VertexFormat POSITION_TEX_NORMAL = new VertexFormat();
    public static final VertexFormat POSITION_TEX_LMAP_COLOR = new VertexFormat();
    public static final VertexFormat POSITION_TEX_COLOR_NORMAL = new VertexFormat();
-   public static final VertexFormatElement POSITION_3F = new VertexFormatElement(
-      0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.POSITION, 3
-   );
-   public static final VertexFormatElement COLOR_4UB = new VertexFormatElement(0, VertexFormatElement.EnumType.UBYTE, VertexFormatElement.EnumUsage.COLOR, 4);
-   public static final VertexFormatElement TEX_2F = new VertexFormatElement(0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.UV, 2);
-   public static final VertexFormatElement TEX_2S = new VertexFormatElement(1, VertexFormatElement.EnumType.SHORT, VertexFormatElement.EnumUsage.UV, 2);
-   public static final VertexFormatElement NORMAL_3B = new VertexFormatElement(0, VertexFormatElement.EnumType.BYTE, VertexFormatElement.EnumUsage.NORMAL, 3);
-   public static final VertexFormatElement PADDING_1B = new VertexFormatElement(0, VertexFormatElement.EnumType.BYTE, VertexFormatElement.EnumUsage.PADDING, 1);
+   public static final VertexFormatElement POSITION_3F = new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.POSITION, 3);
+   public static final VertexFormatElement COLOR_4UB = new VertexFormatElement(0, EnumType.UBYTE, EnumUsage.COLOR, 4);
+   public static final VertexFormatElement TEX_2F = new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.UV, 2);
+   public static final VertexFormatElement TEX_2S = new VertexFormatElement(1, EnumType.SHORT, EnumUsage.UV, 2);
+   public static final VertexFormatElement NORMAL_3B = new VertexFormatElement(0, EnumType.BYTE, EnumUsage.NORMAL, 3);
+   public static final VertexFormatElement PADDING_1B = new VertexFormatElement(0, EnumType.BYTE, EnumUsage.PADDING, 1);
+
+   public static void updateVertexFormats() {
+      if (Config.isShaders()) {
+         BLOCK = SVertexFormat.makeDefVertexFormatBlock();
+         ITEM = SVertexFormat.makeDefVertexFormatItem();
+         if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
+            SVertexFormat.setDefBakedFormat((VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue());
+         }
+      } else {
+         BLOCK = BLOCK_VANILLA;
+         ITEM = ITEM_VANILLA;
+         if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
+            SVertexFormat.copy(FORGE_BAKED, (VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue());
+         }
+      }
+   }
+
+   public static Object getFieldValue(ReflectorField refField) {
+      try {
+         Field field = refField.getTargetField();
+         return field == null ? null : field.get(null);
+      } catch (Throwable var3) {
+         var3.printStackTrace();
+         return null;
+      }
+   }
 
    static {
       BLOCK.addElement(POSITION_3F);
diff --git a/patches/net/minecraft/client/renderer/vertex/VertexBuffer.java b/patches/net/minecraft/client/renderer/vertex/VertexBuffer.java
index 11150cb..f8c648f 100644
--- a/patches/net/minecraft/client/renderer/vertex/VertexBuffer.java
+++ b/patches/net/minecraft/client/renderer/vertex/VertexBuffer.java
@@ -3,14 +3,19 @@
 import java.nio.ByteBuffer;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.optifine.render.VboRange;
+import net.optifine.render.VboRegion;
 
 public class VertexBuffer {
    private int glBufferId;
    private final VertexFormat vertexFormat;
    private int count;
+   private VboRegion vboRegion;
+   private VboRange vboRange;
+   private int drawMode;
 
-   public VertexBuffer(VertexFormat var1) {
-      this.vertexFormat = ☃;
+   public VertexBuffer(VertexFormat vertexFormatIn) {
+      this.vertexFormat = vertexFormatIn;
       this.glBufferId = OpenGlHelper.glGenBuffers();
    }
 
@@ -18,15 +23,27 @@ public void bindBuffer() {
       OpenGlHelper.glBindBuffer(OpenGlHelper.GL_ARRAY_BUFFER, this.glBufferId);
    }
 
-   public void bufferData(ByteBuffer var1) {
-      this.bindBuffer();
-      OpenGlHelper.glBufferData(OpenGlHelper.GL_ARRAY_BUFFER, ☃, 35044);
-      this.unbindBuffer();
-      this.count = ☃.limit() / this.vertexFormat.getSize();
+   public void bufferData(ByteBuffer data) {
+      if (this.vboRegion != null) {
+         this.vboRegion.bufferData(data, this.vboRange);
+      } else {
+         this.bindBuffer();
+         OpenGlHelper.glBufferData(OpenGlHelper.GL_ARRAY_BUFFER, data, 35044);
+         this.unbindBuffer();
+         this.count = data.limit() / this.vertexFormat.getSize();
+      }
    }
 
-   public void drawArrays(int var1) {
-      GlStateManager.glDrawArrays(☃, 0, this.count);
+   public void drawArrays(int mode) {
+      if (this.drawMode > 0) {
+         mode = this.drawMode;
+      }
+
+      if (this.vboRegion != null) {
+         this.vboRegion.drawArrays(mode, this.vboRange);
+      } else {
+         GlStateManager.glDrawArrays(mode, 0, this.count);
+      }
    }
 
    public void unbindBuffer() {
@@ -39,4 +56,28 @@ public void deleteGlBuffers() {
          this.glBufferId = -1;
       }
    }
+
+   public void setVboRegion(VboRegion vboRegion) {
+      if (vboRegion != null) {
+         this.deleteGlBuffers();
+         this.vboRegion = vboRegion;
+         this.vboRange = new VboRange();
+      }
+   }
+
+   public VboRegion getVboRegion() {
+      return this.vboRegion;
+   }
+
+   public VboRange getVboRange() {
+      return this.vboRange;
+   }
+
+   public int getDrawMode() {
+      return this.drawMode;
+   }
+
+   public void setDrawMode(int drawMode) {
+      this.drawMode = drawMode;
+   }
 }
diff --git a/patches/net/minecraft/client/resources/AbstractResourcePack.java b/patches/net/minecraft/client/resources/AbstractResourcePack.java
index 6a14283..bc43efc 100644
--- a/patches/net/minecraft/client/resources/AbstractResourcePack.java
+++ b/patches/net/minecraft/client/resources/AbstractResourcePack.java
@@ -20,65 +20,60 @@
 
 public abstract class AbstractResourcePack implements IResourcePack {
    private static final Logger LOGGER = LogManager.getLogger();
-   protected final File resourcePackFile;
+   public final File resourcePackFile;
 
-   public AbstractResourcePack(File var1) {
-      this.resourcePackFile = ☃;
+   public AbstractResourcePack(File resourcePackFileIn) {
+      this.resourcePackFile = resourcePackFileIn;
    }
 
-   private static String locationToName(ResourceLocation var0) {
-      return String.format("%s/%s/%s", "assets", ☃.getNamespace(), ☃.getPath());
+   private static String locationToName(ResourceLocation location) {
+      return String.format("%s/%s/%s", "assets", location.getNamespace(), location.getPath());
    }
 
-   protected static String getRelativeName(File var0, File var1) {
-      return ☃.toURI().relativize(☃.toURI()).getPath();
+   protected static String getRelativeName(File p_110595_0_, File p_110595_1_) {
+      return p_110595_0_.toURI().relativize(p_110595_1_.toURI()).getPath();
    }
 
-   @Override
-   public InputStream getInputStream(ResourceLocation var1) throws IOException {
-      return this.getInputStreamByName(locationToName(☃));
+   public InputStream getInputStream(ResourceLocation location) throws IOException {
+      return this.getInputStreamByName(locationToName(location));
    }
 
-   @Override
-   public boolean resourceExists(ResourceLocation var1) {
-      return this.hasResourceName(locationToName(☃));
+   public boolean resourceExists(ResourceLocation location) {
+      return this.hasResourceName(locationToName(location));
    }
 
    protected abstract InputStream getInputStreamByName(String var1) throws IOException;
 
    protected abstract boolean hasResourceName(String var1);
 
-   protected void logNameNotLowercase(String var1) {
-      LOGGER.warn("ResourcePack: ignored non-lowercase namespace: {} in {}", ☃, this.resourcePackFile);
+   protected void logNameNotLowercase(String name) {
+      LOGGER.warn("ResourcePack: ignored non-lowercase namespace: {} in {}", name, this.resourcePackFile);
    }
 
-   @Override
-   public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer var1, String var2) throws IOException {
-      return readMetadata(☃, this.getInputStreamByName("pack.mcmeta"), ☃);
+   public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException {
+      return readMetadata(metadataSerializer, this.getInputStreamByName("pack.mcmeta"), metadataSectionName);
    }
 
-   static <T extends IMetadataSection> T readMetadata(MetadataSerializer var0, InputStream var1, String var2) {
-      JsonObject ☃ = null;
-      BufferedReader ☃x = null;
+   static <T extends IMetadataSection> T readMetadata(MetadataSerializer metadataSerializer, InputStream p_110596_1_, String sectionName) {
+      JsonObject jsonobject = null;
+      BufferedReader bufferedreader = null;
 
       try {
-         ☃x = new BufferedReader(new InputStreamReader(☃, StandardCharsets.UTF_8));
-         ☃ = new JsonParser().parse(☃x).getAsJsonObject();
+         bufferedreader = new BufferedReader(new InputStreamReader(p_110596_1_, StandardCharsets.UTF_8));
+         jsonobject = new JsonParser().parse(bufferedreader).getAsJsonObject();
       } catch (RuntimeException var9) {
          throw new JsonParseException(var9);
       } finally {
-         IOUtils.closeQuietly(☃x);
+         IOUtils.closeQuietly(bufferedreader);
       }
 
-      return ☃.parseMetadataSection(☃, ☃);
+      return (T)metadataSerializer.parseMetadataSection(sectionName, jsonobject);
    }
 
-   @Override
    public BufferedImage getPackImage() throws IOException {
       return TextureUtil.readBufferedImage(this.getInputStreamByName("pack.png"));
    }
 
-   @Override
    public String getPackName() {
       return this.resourcePackFile.getName();
    }
diff --git a/patches/net/minecraft/client/resources/DefaultResourcePack.java b/patches/net/minecraft/client/resources/DefaultResourcePack.java
index 13057b8..92dcd17 100644
--- a/patches/net/minecraft/client/resources/DefaultResourcePack.java
+++ b/patches/net/minecraft/client/resources/DefaultResourcePack.java
@@ -14,78 +14,92 @@
 import net.minecraft.client.resources.data.IMetadataSection;
 import net.minecraft.client.resources.data.MetadataSerializer;
 import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Util;
+import net.optifine.reflect.ReflectorForge;
 
 public class DefaultResourcePack implements IResourcePack {
    public static final Set<String> DEFAULT_RESOURCE_DOMAINS = ImmutableSet.of("minecraft", "realms");
    private final ResourceIndex resourceIndex;
+   private static final boolean ON_WINDOWS = Util.getOSType() == Util.EnumOS.WINDOWS;
 
-   public DefaultResourcePack(ResourceIndex var1) {
-      this.resourceIndex = ☃;
+   public DefaultResourcePack(ResourceIndex resourceIndexIn) {
+      this.resourceIndex = resourceIndexIn;
    }
 
-   @Override
-   public InputStream getInputStream(ResourceLocation var1) throws IOException {
-      InputStream ☃ = this.getInputStreamAssets(☃);
-      if (☃ != null) {
-         return ☃;
+   public InputStream getInputStream(ResourceLocation location) throws IOException {
+      InputStream inputstream = this.getInputStreamAssets(location);
+      if (inputstream != null) {
+         return inputstream;
       } else {
-         InputStream ☃x = this.getResourceStream(☃);
-         if (☃x != null) {
-            return ☃x;
+         InputStream inputstream1 = this.getResourceStream(location);
+         if (inputstream1 != null) {
+            return inputstream1;
          } else {
-            throw new FileNotFoundException(☃.getPath());
+            throw new FileNotFoundException(location.getPath());
          }
       }
    }
 
    @Nullable
-   public InputStream getInputStreamAssets(ResourceLocation var1) throws FileNotFoundException {
-      File ☃ = this.resourceIndex.getFile(☃);
-      return ☃ != null && ☃.isFile() ? new FileInputStream(☃) : null;
+   public InputStream getInputStreamAssets(ResourceLocation location) throws IOException, FileNotFoundException {
+      File file1 = this.resourceIndex.getFile(location);
+      return file1 != null && file1.isFile() ? new FileInputStream(file1) : null;
    }
 
    @Nullable
-   private InputStream getResourceStream(ResourceLocation var1) {
-      String ☃ = "/assets/" + ☃.getNamespace() + "/" + ☃.getPath();
-
-      try {
-         URL ☃x = DefaultResourcePack.class.getResource(☃);
-         return ☃x != null && FolderResourcePack.validatePath(new File(☃x.getFile()), ☃) ? DefaultResourcePack.class.getResourceAsStream(☃) : null;
-      } catch (IOException var4) {
-         return DefaultResourcePack.class.getResourceAsStream(☃);
+   private InputStream getResourceStream(ResourceLocation location) {
+      String s = "/assets/" + location.getNamespace() + "/" + location.getPath();
+      InputStream is = ReflectorForge.getOptiFineResourceStream(s);
+      if (is != null) {
+         return is;
+      } else {
+         try {
+            URL url = DefaultResourcePack.class.getResource(s);
+            return url != null && this.validatePath(new File(url.getFile()), s) ? DefaultResourcePack.class.getResourceAsStream(s) : null;
+         } catch (IOException var5) {
+            return DefaultResourcePack.class.getResourceAsStream(s);
+         }
       }
    }
 
-   @Override
-   public boolean resourceExists(ResourceLocation var1) {
-      return this.getResourceStream(☃) != null || this.resourceIndex.isFileExisting(☃);
+   public boolean resourceExists(ResourceLocation location) {
+      return this.getResourceStream(location) != null || this.resourceIndex.isFileExisting(location);
    }
 
-   @Override
    public Set<String> getResourceDomains() {
       return DEFAULT_RESOURCE_DOMAINS;
    }
 
    @Nullable
-   @Override
-   public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer var1, String var2) throws IOException {
+   public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException {
       try {
-         InputStream ☃ = new FileInputStream(this.resourceIndex.getPackMcmeta());
-         return AbstractResourcePack.readMetadata(☃, ☃, ☃);
+         InputStream inputstream = new FileInputStream(this.resourceIndex.getPackMcmeta());
+         return AbstractResourcePack.readMetadata(metadataSerializer, inputstream, metadataSectionName);
       } catch (RuntimeException var4) {
          return null;
-      } catch (FileNotFoundException var5) {
+      } catch (FileNotFoundException var51) {
          return null;
       }
    }
 
-   @Override
    public BufferedImage getPackImage() throws IOException {
       return TextureUtil.readBufferedImage(DefaultResourcePack.class.getResourceAsStream("/" + new ResourceLocation("pack.png").getPath()));
    }
 
-   @Override
    public String getPackName() {
       return "Default";
    }
+
+   private boolean validatePath(File file, String path) throws IOException {
+      String s = file.getPath();
+      if (s.startsWith("file:")) {
+         if (ON_WINDOWS) {
+            s = s.replace("\\", "/");
+         }
+
+         return s.endsWith(path);
+      } else {
+         return FolderResourcePack.validatePath(file, path);
+      }
+   }
 }
diff --git a/patches/net/minecraft/client/resources/I18n.java b/patches/net/minecraft/client/resources/I18n.java
index c92960f..b128689 100644
--- a/patches/net/minecraft/client/resources/I18n.java
+++ b/patches/net/minecraft/client/resources/I18n.java
@@ -1,17 +1,23 @@
 package net.minecraft.client.resources;
 
+import java.util.Map;
+
 public class I18n {
    private static Locale i18nLocale;
 
-   static void setLocale(Locale var0) {
-      i18nLocale = ☃;
+   static void setLocale(Locale i18nLocaleIn) {
+      i18nLocale = i18nLocaleIn;
+   }
+
+   public static String format(String translateKey, Object... parameters) {
+      return i18nLocale.formatMessage(translateKey, parameters);
    }
 
-   public static String format(String var0, Object... var1) {
-      return i18nLocale.formatMessage(☃, ☃);
+   public static boolean hasKey(String key) {
+      return i18nLocale.hasKey(key);
    }
 
-   public static boolean hasKey(String var0) {
-      return i18nLocale.hasKey(☃);
+   public static Map getLocaleProperties() {
+      return i18nLocale.properties;
    }
 }
diff --git a/patches/net/minecraft/client/resources/ResourcePackRepository.java b/patches/net/minecraft/client/resources/ResourcePackRepository.java
index b46d330..d500f71 100644
--- a/patches/net/minecraft/client/resources/ResourcePackRepository.java
+++ b/patches/net/minecraft/client/resources/ResourcePackRepository.java
@@ -13,10 +13,12 @@
 import java.io.FileFilter;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.regex.Pattern;
@@ -36,6 +38,7 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.comparator.LastModifiedFileComparator;
+import org.apache.commons.io.filefilter.IOFileFilter;
 import org.apache.commons.io.filefilter.TrueFileFilter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -44,10 +47,10 @@ public class ResourcePackRepository {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final FileFilter RESOURCE_PACK_FILTER = new FileFilter() {
       @Override
-      public boolean accept(File var1) {
-         boolean ☃ = ☃.isFile() && ☃.getName().endsWith(".zip");
-         boolean ☃x = ☃.isDirectory() && new File(☃, "pack.mcmeta").isFile();
-         return ☃ || ☃x;
+      public boolean accept(File p_accept_1_) {
+         boolean flag = p_accept_1_.isFile() && p_accept_1_.getName().endsWith(".zip");
+         boolean flag1 = p_accept_1_.isDirectory() && new File(p_accept_1_, "pack.mcmeta").isFile();
+         return flag || flag1;
       }
    };
    private static final Pattern SHA1 = Pattern.compile("^[a-fA-F0-9]{40}$");
@@ -60,40 +63,47 @@ public boolean accept(File var1) {
    private final ReentrantLock lock = new ReentrantLock();
    private ListenableFuture<Object> downloadingPacks;
    private List<ResourcePackRepository.Entry> repositoryEntriesAll = Lists.newArrayList();
-   private final List<ResourcePackRepository.Entry> repositoryEntries = Lists.newArrayList();
-
-   public ResourcePackRepository(File var1, File var2, IResourcePack var3, MetadataSerializer var4, GameSettings var5) {
-      this.dirResourcepacks = ☃;
-      this.dirServerResourcepacks = ☃;
-      this.rprDefaultResourcePack = ☃;
-      this.rprMetadataSerializer = ☃;
+   public final List<ResourcePackRepository.Entry> repositoryEntries = Lists.newArrayList();
+
+   public ResourcePackRepository(
+      File dirResourcepacksIn,
+      File dirServerResourcepacksIn,
+      IResourcePack rprDefaultResourcePackIn,
+      MetadataSerializer rprMetadataSerializerIn,
+      GameSettings settings
+   ) {
+      this.dirResourcepacks = dirResourcepacksIn;
+      this.dirServerResourcepacks = dirServerResourcepacksIn;
+      this.rprDefaultResourcePack = rprDefaultResourcePackIn;
+      this.rprMetadataSerializer = rprMetadataSerializerIn;
       this.fixDirResourcepacks();
       this.updateRepositoryEntriesAll();
-      Iterator<String> ☃ = ☃.resourcePacks.iterator();
+      Iterator<String> iterator = settings.resourcePacks.iterator();
 
-      while (☃.hasNext()) {
-         String ☃x = ☃.next();
+      while (iterator.hasNext()) {
+         String s = iterator.next();
 
-         for (ResourcePackRepository.Entry ☃xx : this.repositoryEntriesAll) {
-            if (☃xx.getResourcePackName().equals(☃x)) {
-               if (☃xx.getPackFormat() == 3 || ☃.incompatibleResourcePacks.contains(☃xx.getResourcePackName())) {
-                  this.repositoryEntries.add(☃xx);
+         for (ResourcePackRepository.Entry resourcepackrepository$entry : this.repositoryEntriesAll) {
+            if (resourcepackrepository$entry.getResourcePackName().equals(s)) {
+               if (resourcepackrepository$entry.getPackFormat() == 3
+                  || settings.incompatibleResourcePacks.contains(resourcepackrepository$entry.getResourcePackName())) {
+                  this.repositoryEntries.add(resourcepackrepository$entry);
                   break;
                }
 
-               ☃.remove();
-               LOGGER.warn("Removed selected resource pack {} because it's no longer compatible", ☃xx.getResourcePackName());
+               iterator.remove();
+               LOGGER.warn("Removed selected resource pack {} because it's no longer compatible", resourcepackrepository$entry.getResourcePackName());
             }
          }
       }
    }
 
    public static Map<String, String> getDownloadHeaders() {
-      Map<String, String> ☃ = Maps.newHashMap();
-      ☃.put("X-Minecraft-Username", Minecraft.getMinecraft().getSession().getUsername());
-      ☃.put("X-Minecraft-UUID", Minecraft.getMinecraft().getSession().getPlayerID());
-      ☃.put("X-Minecraft-Version", "1.12.2");
-      return ☃;
+      Map<String, String> map = Maps.newHashMap();
+      map.put("X-Minecraft-Username", Minecraft.getMinecraft().getSession().getUsername());
+      map.put("X-Minecraft-UUID", Minecraft.getMinecraft().getSession().getPlayerID());
+      map.put("X-Minecraft-Version", "1.12.2");
+      return map;
    }
 
    private void fixDirResourcepacks() {
@@ -110,62 +120,62 @@ private List<File> getResourcePackFiles() {
       return this.dirResourcepacks.isDirectory() ? Arrays.asList(this.dirResourcepacks.listFiles(RESOURCE_PACK_FILTER)) : Collections.emptyList();
    }
 
-   private IResourcePack getResourcePack(File var1) {
-      IResourcePack ☃;
-      if (☃.isDirectory()) {
-         ☃ = new FolderResourcePack(☃);
+   private IResourcePack getResourcePack(File p_191399_1_) {
+      IResourcePack iresourcepack;
+      if (p_191399_1_.isDirectory()) {
+         iresourcepack = new FolderResourcePack(p_191399_1_);
       } else {
-         ☃ = new FileResourcePack(☃);
+         iresourcepack = new FileResourcePack(p_191399_1_);
       }
 
       try {
-         PackMetadataSection ☃x = ☃.getPackMetadata(this.rprMetadataSerializer, "pack");
-         if (☃x != null && ☃x.getPackFormat() == 2) {
-            return new LegacyV2Adapter(☃);
+         PackMetadataSection packmetadatasection = (PackMetadataSection)iresourcepack.getPackMetadata(this.rprMetadataSerializer, "pack");
+         if (packmetadatasection != null && packmetadatasection.getPackFormat() == 2) {
+            return new LegacyV2Adapter(iresourcepack);
          }
       } catch (Exception var4) {
       }
 
-      return ☃;
+      return iresourcepack;
    }
 
    public void updateRepositoryEntriesAll() {
-      List<ResourcePackRepository.Entry> ☃ = Lists.newArrayList();
-
-      for (File ☃x : this.getResourcePackFiles()) {
-         ResourcePackRepository.Entry ☃xx = new ResourcePackRepository.Entry(☃x);
-         if (this.repositoryEntriesAll.contains(☃xx)) {
-            int ☃xxx = this.repositoryEntriesAll.indexOf(☃xx);
-            if (☃xxx > -1 && ☃xxx < this.repositoryEntriesAll.size()) {
-               ☃.add(this.repositoryEntriesAll.get(☃xxx));
+      List<ResourcePackRepository.Entry> list = Lists.newArrayList();
+
+      for (File file1 : this.getResourcePackFiles()) {
+         ResourcePackRepository.Entry resourcepackrepository$entry = new ResourcePackRepository.Entry(file1);
+         if (this.repositoryEntriesAll.contains(resourcepackrepository$entry)) {
+            int i = this.repositoryEntriesAll.indexOf(resourcepackrepository$entry);
+            if (i > -1 && i < this.repositoryEntriesAll.size()) {
+               list.add(this.repositoryEntriesAll.get(i));
             }
          } else {
             try {
-               ☃xx.updateResourcePack();
-               ☃.add(☃xx);
-            } catch (Exception var6) {
-               ☃.remove(☃xx);
+               resourcepackrepository$entry.updateResourcePack();
+               list.add(resourcepackrepository$entry);
+            } catch (Exception var61) {
+               list.remove(resourcepackrepository$entry);
             }
          }
       }
 
-      this.repositoryEntriesAll.removeAll(☃);
+      this.repositoryEntriesAll.removeAll(list);
 
-      for (ResourcePackRepository.Entry ☃xx : this.repositoryEntriesAll) {
-         ☃xx.closeResourcePack();
+      for (ResourcePackRepository.Entry resourcepackrepository$entry1 : this.repositoryEntriesAll) {
+         resourcepackrepository$entry1.closeResourcePack();
       }
 
-      this.repositoryEntriesAll = ☃;
+      this.repositoryEntriesAll = list;
    }
 
    @Nullable
    public ResourcePackRepository.Entry getResourcePackEntry() {
       if (this.serverResourcePack != null) {
-         ResourcePackRepository.Entry ☃ = new ResourcePackRepository.Entry(this.serverResourcePack);
+         ResourcePackRepository.Entry resourcepackrepository$entry = new ResourcePackRepository.Entry(this.serverResourcePack);
 
          try {
-            ☃.updateResourcePack();
-            return ☃;
+            resourcepackrepository$entry.updateResourcePack();
+            return resourcepackrepository$entry;
          } catch (IOException var3) {
          }
       }
@@ -181,58 +191,58 @@ public List<ResourcePackRepository.Entry> getRepositoryEntries() {
       return ImmutableList.copyOf(this.repositoryEntries);
    }
 
-   public void setRepositories(List<ResourcePackRepository.Entry> var1) {
+   public void setRepositories(List<ResourcePackRepository.Entry> repositories) {
       this.repositoryEntries.clear();
-      this.repositoryEntries.addAll(☃);
+      this.repositoryEntries.addAll(repositories);
    }
 
    public File getDirResourcepacks() {
       return this.dirResourcepacks;
    }
 
-   public ListenableFuture<Object> downloadResourcePack(String var1, String var2) {
-      String ☃ = DigestUtils.sha1Hex(☃);
-      final String ☃x = SHA1.matcher(☃).matches() ? ☃ : "";
-      final File ☃xx = new File(this.dirServerResourcepacks, ☃);
+   public ListenableFuture<Object> downloadResourcePack(String url, String hash) {
+      String s = DigestUtils.sha1Hex(url);
+      final String s1 = SHA1.matcher(hash).matches() ? hash : "";
+      final File file1 = new File(this.dirServerResourcepacks, s);
       this.lock.lock();
 
       try {
          this.clearResourcePack();
-         if (☃xx.exists()) {
-            if (this.checkHash(☃x, ☃xx)) {
-               return this.setServerResourcePack(☃xx);
+         if (file1.exists()) {
+            if (this.checkHash(s1, file1)) {
+               return this.setServerResourcePack(file1);
             }
 
-            LOGGER.warn("Deleting file {}", ☃xx);
-            FileUtils.deleteQuietly(☃xx);
+            LOGGER.warn("Deleting file {}", file1);
+            FileUtils.deleteQuietly(file1);
          }
 
          this.deleteOldServerResourcesPacks();
-         final GuiScreenWorking ☃xxx = new GuiScreenWorking();
-         Map<String, String> ☃xxxx = getDownloadHeaders();
-         final Minecraft ☃xxxxx = Minecraft.getMinecraft();
-         Futures.getUnchecked(☃xxxxx.addScheduledTask(new Runnable() {
+         final GuiScreenWorking guiscreenworking = new GuiScreenWorking();
+         Map<String, String> map = getDownloadHeaders();
+         final Minecraft minecraft = Minecraft.getMinecraft();
+         Futures.getUnchecked(minecraft.addScheduledTask(new Runnable() {
             @Override
             public void run() {
-               ☃.displayGuiScreen(☃);
+               minecraft.displayGuiScreen(guiscreenworking);
             }
          }));
-         final SettableFuture<Object> ☃xxxxxx = SettableFuture.create();
-         this.downloadingPacks = HttpUtil.downloadResourcePack(☃xx, ☃, ☃xxxx, 52428800, ☃xxx, ☃xxxxx.getProxy());
+         final SettableFuture<Object> settablefuture = SettableFuture.create();
+         this.downloadingPacks = HttpUtil.downloadResourcePack(file1, url, map, 52428800, guiscreenworking, minecraft.getProxy());
          Futures.addCallback(this.downloadingPacks, new FutureCallback<Object>() {
-            public void onSuccess(@Nullable Object var1) {
-               if (ResourcePackRepository.this.checkHash(☃, ☃)) {
-                  ResourcePackRepository.this.setServerResourcePack(☃);
-                  ☃.set(null);
+            public void onSuccess(@Nullable Object p_onSuccess_1_) {
+               if (ResourcePackRepository.this.checkHash(s1, file1)) {
+                  ResourcePackRepository.this.setServerResourcePack(file1);
+                  settablefuture.set(null);
                } else {
-                  ResourcePackRepository.LOGGER.warn("Deleting file {}", ☃);
-                  FileUtils.deleteQuietly(☃);
+                  ResourcePackRepository.LOGGER.warn("Deleting file {}", file1);
+                  FileUtils.deleteQuietly(file1);
                }
             }
 
-            public void onFailure(Throwable var1) {
-               FileUtils.deleteQuietly(☃);
-               ☃.setException(☃);
+            public void onFailure(Throwable p_onFailure_1_) {
+               FileUtils.deleteQuietly(file1);
+               settablefuture.setException(p_onFailure_1_);
             }
          });
          return this.downloadingPacks;
@@ -241,32 +251,39 @@ public void onFailure(Throwable var1) {
       }
    }
 
-   private boolean checkHash(String var1, File var2) {
+   private boolean checkHash(String p_190113_1_, File p_190113_2_) {
+      InputStream is = null;
+
+      boolean var5;
       try {
-         String ☃ = DigestUtils.sha1Hex(new FileInputStream(☃));
-         if (☃.isEmpty()) {
-            LOGGER.info("Found file {} without verification hash", ☃);
+         String s = DigestUtils.sha1Hex(is = new FileInputStream(p_190113_2_));
+         if (p_190113_1_.isEmpty()) {
+            LOGGER.info("Found file {} without verification hash", p_190113_2_);
             return true;
          }
 
-         if (☃.toLowerCase(java.util.Locale.ROOT).equals(☃.toLowerCase(java.util.Locale.ROOT))) {
-            LOGGER.info("Found file {} matching requested hash {}", ☃, ☃);
-            return true;
+         if (!s.toLowerCase(Locale.ROOT).equals(p_190113_1_.toLowerCase(Locale.ROOT))) {
+            LOGGER.warn("File {} had wrong hash (expected {}, found {}).", p_190113_2_, p_190113_1_, s);
+            return false;
          }
 
-         LOGGER.warn("File {} had wrong hash (expected {}, found {}).", ☃, ☃, ☃);
-      } catch (IOException var4) {
-         LOGGER.warn("File {} couldn't be hashed.", ☃, var4);
+         LOGGER.info("Found file {} matching requested hash {}", p_190113_2_, p_190113_1_);
+         var5 = true;
+      } catch (IOException var9) {
+         LOGGER.warn("File {} couldn't be hashed.", p_190113_2_, var9);
+         return false;
+      } finally {
+         IOUtils.closeQuietly(is);
       }
 
-      return false;
+      return var5;
    }
 
-   private boolean validatePack(File var1) {
-      ResourcePackRepository.Entry ☃ = new ResourcePackRepository.Entry(☃);
+   private boolean validatePack(File p_190112_1_) {
+      ResourcePackRepository.Entry resourcepackrepository$entry = new ResourcePackRepository.Entry(p_190112_1_);
 
       try {
-         ☃.updateResourcePack();
+         resourcepackrepository$entry.updateResourcePack();
          return true;
       } catch (Exception var4) {
          LOGGER.warn("Server resourcepack is invalid, ignoring it", var4);
@@ -276,14 +293,14 @@ private boolean validatePack(File var1) {
 
    private void deleteOldServerResourcesPacks() {
       try {
-         List<File> ☃ = Lists.newArrayList(FileUtils.listFiles(this.dirServerResourcepacks, TrueFileFilter.TRUE, null));
-         Collections.sort(☃, LastModifiedFileComparator.LASTMODIFIED_REVERSE);
-         int ☃x = 0;
-
-         for (File ☃xx : ☃) {
-            if (☃x++ >= 10) {
-               LOGGER.info("Deleting old server resource pack {}", ☃xx.getName());
-               FileUtils.deleteQuietly(☃xx);
+         List<File> list = Lists.newArrayList(FileUtils.listFiles(this.dirServerResourcepacks, TrueFileFilter.TRUE, (IOFileFilter)null));
+         Collections.sort(list, LastModifiedFileComparator.LASTMODIFIED_REVERSE);
+         int i = 0;
+
+         for (File file1 : list) {
+            if (i++ >= 10) {
+               LOGGER.info("Deleting old server resource pack {}", file1.getName());
+               FileUtils.deleteQuietly(file1);
             }
          }
       } catch (IllegalArgumentException var5) {
@@ -291,11 +308,11 @@ private void deleteOldServerResourcesPacks() {
       }
    }
 
-   public ListenableFuture<Object> setServerResourcePack(File var1) {
-      if (!this.validatePack(☃)) {
+   public ListenableFuture<Object> setServerResourcePack(File resourceFile) {
+      if (!this.validatePack(resourceFile)) {
          return Futures.immediateFailedFuture(new RuntimeException("Invalid resourcepack"));
       } else {
-         this.serverResourcePack = new FileResourcePack(☃);
+         this.serverResourcePack = new FileResourcePack(resourceFile);
          return Minecraft.getMinecraft().scheduleResourcesRefresh();
       }
    }
@@ -328,42 +345,43 @@ public class Entry {
       private PackMetadataSection rePackMetadataSection;
       private ResourceLocation locationTexturePackIcon;
 
-      private Entry(File var2) {
-         this(ResourcePackRepository.this.getResourcePack(☃));
+      private Entry(File resourcePackFileIn) {
+         this(ResourcePackRepository.this.getResourcePack(resourcePackFileIn));
       }
 
-      private Entry(IResourcePack var2) {
-         this.reResourcePack = ☃;
+      private Entry(IResourcePack reResourcePackIn) {
+         this.reResourcePack = reResourcePackIn;
       }
 
       public void updateResourcePack() throws IOException {
-         this.rePackMetadataSection = this.reResourcePack.getPackMetadata(ResourcePackRepository.this.rprMetadataSerializer, "pack");
+         this.rePackMetadataSection = (PackMetadataSection)this.reResourcePack.getPackMetadata(ResourcePackRepository.this.rprMetadataSerializer, "pack");
          this.closeResourcePack();
       }
 
-      public void bindTexturePackIcon(TextureManager var1) {
-         BufferedImage ☃ = null;
-
-         try {
-            ☃ = this.reResourcePack.getPackImage();
-         } catch (IOException var5) {
-         }
-
-         if (☃ == null) {
+      public void bindTexturePackIcon(TextureManager textureManagerIn) {
+         BufferedImage bufferedimage = null;
+         if (this.locationTexturePackIcon == null) {
             try {
-               ☃ = TextureUtil.readBufferedImage(
-                  Minecraft.getMinecraft().getResourceManager().getResource(ResourcePackRepository.UNKNOWN_PACK_TEXTURE).getInputStream()
-               );
-            } catch (IOException var4) {
-               throw new Error("Couldn't bind resource pack icon", var4);
+               bufferedimage = this.reResourcePack.getPackImage();
+            } catch (IOException var5) {
+            }
+
+            if (bufferedimage == null) {
+               try {
+                  bufferedimage = TextureUtil.readBufferedImage(
+                     Minecraft.getMinecraft().getResourceManager().getResource(ResourcePackRepository.UNKNOWN_PACK_TEXTURE).getInputStream()
+                  );
+               } catch (IOException var4) {
+                  throw new Error("Couldn't bind resource pack icon", var4);
+               }
             }
          }
 
          if (this.locationTexturePackIcon == null) {
-            this.locationTexturePackIcon = ☃.getDynamicTextureLocation("texturepackicon", new DynamicTexture(☃));
+            this.locationTexturePackIcon = textureManagerIn.getDynamicTextureLocation("texturepackicon", new DynamicTexture(bufferedimage));
          }
 
-         ☃.bindTexture(this.locationTexturePackIcon);
+         textureManagerIn.bindTexture(this.locationTexturePackIcon);
       }
 
       public void closeResourcePack() {
@@ -391,11 +409,11 @@ public int getPackFormat() {
       }
 
       @Override
-      public boolean equals(Object var1) {
-         if (this == ☃) {
+      public boolean equals(Object p_equals_1_) {
+         if (this == p_equals_1_) {
             return true;
          } else {
-            return ☃ instanceof ResourcePackRepository.Entry ? this.toString().equals(☃.toString()) : false;
+            return p_equals_1_ instanceof ResourcePackRepository.Entry ? this.toString().equals(p_equals_1_.toString()) : false;
          }
       }
 
diff --git a/patches/net/minecraft/client/settings/GameSettings.java b/patches/net/minecraft/client/settings/GameSettings.java
index 2134e2d..77f12e6 100644
--- a/patches/net/minecraft/client/settings/GameSettings.java
+++ b/patches/net/minecraft/client/settings/GameSettings.java
@@ -6,26 +6,31 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.gson.Gson;
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiNewChat;
+import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.client.gui.chat.NarratorChatListener;
+import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.tutorial.TutorialSteps;
-import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EnumPlayerModelParts;
+import net.minecraft.entity.player.EntityPlayer.EnumChatVisibility;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.play.client.CPacketClientSettings;
 import net.minecraft.util.EnumHandSide;
@@ -34,6 +39,18 @@
 import net.minecraft.util.datafix.FixTypes;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.EnumDifficulty;
+import net.minecraftforge.client.resource.IResourceType;
+import net.optifine.ClearWater;
+import net.optifine.CustomColors;
+import net.optifine.CustomGuis;
+import net.optifine.CustomSky;
+import net.optifine.DynamicLights;
+import net.optifine.Lang;
+import net.optifine.NaturalTextures;
+import net.optifine.RandomEntities;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.KeyUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -41,6 +58,7 @@
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.DisplayMode;
 
 public class GameSettings {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -84,7 +102,7 @@ public Type getOwnerType() {
    public int ambientOcclusion = 2;
    public List<String> resourcePacks = Lists.newArrayList();
    public List<String> incompatibleResourcePacks = Lists.newArrayList();
-   public EntityPlayer.EnumChatVisibility chatVisibility = EntityPlayer.EnumChatVisibility.FULL;
+   public EnumChatVisibility chatVisibility = EnumChatVisibility.FULL;
    public boolean chatColours = true;
    public boolean chatLinks = true;
    public boolean chatLinksPrompt = true;
@@ -152,74 +170,215 @@ public Type getOwnerType() {
    };
    public KeyBinding keyBindSaveToolbar = new KeyBinding("key.saveToolbarActivator", 46, "key.categories.creative");
    public KeyBinding keyBindLoadToolbar = new KeyBinding("key.loadToolbarActivator", 45, "key.categories.creative");
-   public KeyBinding[] keyBindings = (KeyBinding[])ArrayUtils.addAll(
-      new KeyBinding[]{
-         this.keyBindAttack,
-         this.keyBindUseItem,
-         this.keyBindForward,
-         this.keyBindLeft,
-         this.keyBindBack,
-         this.keyBindRight,
-         this.keyBindJump,
-         this.keyBindSneak,
-         this.keyBindSprint,
-         this.keyBindDrop,
-         this.keyBindInventory,
-         this.keyBindChat,
-         this.keyBindPlayerList,
-         this.keyBindPickBlock,
-         this.keyBindCommand,
-         this.keyBindScreenshot,
-         this.keyBindTogglePerspective,
-         this.keyBindSmoothCamera,
-         this.keyBindFullscreen,
-         this.keyBindSpectatorOutlines,
-         this.keyBindSwapHands,
-         this.keyBindSaveToolbar,
-         this.keyBindLoadToolbar,
-         this.keyBindAdvancements
-      },
-      this.keyBindsHotbar
-   );
+   public KeyBinding[] keyBindings;
    protected Minecraft mc;
    private File optionsFile;
-   public EnumDifficulty difficulty = EnumDifficulty.NORMAL;
+   public EnumDifficulty difficulty;
    public boolean hideGUI;
    public int thirdPersonView;
    public boolean showDebugInfo;
    public boolean showDebugProfilerChart;
    public boolean showLagometer;
-   public String lastServer = "";
+   public String lastServer;
    public boolean smoothCamera;
    public boolean debugCamEnable;
-   public float fovSetting = 70.0F;
+   public float fovSetting;
    public float gammaSetting;
    public float saturation;
    public int guiScale;
    public int particleSetting;
    public int narrator;
-   public String language = "en_us";
+   public String language;
    public boolean forceUnicodeFont;
-
-   public GameSettings(Minecraft var1, File var2) {
-      this.mc = ☃;
-      this.optionsFile = new File(☃, "options.txt");
-      if (☃.isJava64bit() && Runtime.getRuntime().maxMemory() >= 1000000000L) {
+   public int ofFogType = 1;
+   public float ofFogStart = 0.8F;
+   public int ofMipmapType = 0;
+   public boolean ofOcclusionFancy = false;
+   public boolean ofSmoothFps = false;
+   public boolean ofSmoothWorld = Config.isSingleProcessor();
+   public boolean ofLazyChunkLoading = Config.isSingleProcessor();
+   public boolean ofRenderRegions = false;
+   public boolean ofSmartAnimations = false;
+   public float ofAoLevel = 1.0F;
+   public int ofAaLevel = 0;
+   public int ofAfLevel = 1;
+   public int ofClouds = 0;
+   public float ofCloudsHeight = 0.0F;
+   public int ofTrees = 0;
+   public int ofRain = 0;
+   public int ofDroppedItems = 0;
+   public int ofBetterGrass = 3;
+   public int ofAutoSaveTicks = 4000;
+   public boolean ofLagometer = false;
+   public boolean ofProfiler = false;
+   public boolean ofShowFps = false;
+   public boolean ofWeather = true;
+   public boolean ofSky = true;
+   public boolean ofStars = true;
+   public boolean ofSunMoon = true;
+   public int ofVignette = 0;
+   public int ofChunkUpdates = 1;
+   public boolean ofChunkUpdatesDynamic = false;
+   public int ofTime = 0;
+   public boolean ofClearWater = false;
+   public boolean ofBetterSnow = false;
+   public String ofFullscreenMode = "Default";
+   public boolean ofSwampColors = true;
+   public boolean ofRandomEntities = true;
+   public boolean ofSmoothBiomes = true;
+   public boolean ofCustomFonts = true;
+   public boolean ofCustomColors = true;
+   public boolean ofCustomSky = true;
+   public boolean ofShowCapes = true;
+   public int ofConnectedTextures = 2;
+   public boolean ofCustomItems = true;
+   public boolean ofNaturalTextures = false;
+   public boolean ofEmissiveTextures = true;
+   public boolean ofFastMath = false;
+   public boolean ofFastRender = false;
+   public int ofTranslucentBlocks = 0;
+   public boolean ofDynamicFov = true;
+   public boolean ofAlternateBlocks = true;
+   public int ofDynamicLights = 3;
+   public boolean ofCustomEntityModels = true;
+   public boolean ofCustomGuis = true;
+   public boolean ofShowGlErrors = true;
+   public int ofScreenshotSize = 1;
+   public int ofAnimatedWater = 0;
+   public int ofAnimatedLava = 0;
+   public boolean ofAnimatedFire = true;
+   public boolean ofAnimatedPortal = true;
+   public boolean ofAnimatedRedstone = true;
+   public boolean ofAnimatedExplosion = true;
+   public boolean ofAnimatedFlame = true;
+   public boolean ofAnimatedSmoke = true;
+   public boolean ofVoidParticles = true;
+   public boolean ofWaterParticles = true;
+   public boolean ofRainSplash = true;
+   public boolean ofPortalParticles = true;
+   public boolean ofPotionParticles = true;
+   public boolean ofFireworkParticles = true;
+   public boolean ofDrippingWaterLava = true;
+   public boolean ofAnimatedTerrain = true;
+   public boolean ofAnimatedTextures = true;
+   public static final int DEFAULT = 0;
+   public static final int FAST = 1;
+   public static final int FANCY = 2;
+   public static final int OFF = 3;
+   public static final int SMART = 4;
+   public static final int ANIM_ON = 0;
+   public static final int ANIM_GENERATED = 1;
+   public static final int ANIM_OFF = 2;
+   public static final String DEFAULT_STR = "Default";
+   private static final int[] OF_TREES_VALUES = new int[]{0, 1, 4, 2};
+   private static final int[] OF_DYNAMIC_LIGHTS = new int[]{3, 1, 2};
+   private static final String[] KEYS_DYNAMIC_LIGHTS = new String[]{"options.off", "options.graphics.fast", "options.graphics.fancy"};
+   public KeyBinding ofKeyBindZoom;
+   private File optionsFileOF;
+   private boolean needsResourceRefresh = false;
+
+   public GameSettings(Minecraft mcIn, File optionsFileIn) {
+      this.setForgeKeybindProperties();
+      this.keyBindings = (KeyBinding[])ArrayUtils.addAll(
+         new KeyBinding[]{
+            this.keyBindAttack,
+            this.keyBindUseItem,
+            this.keyBindForward,
+            this.keyBindLeft,
+            this.keyBindBack,
+            this.keyBindRight,
+            this.keyBindJump,
+            this.keyBindSneak,
+            this.keyBindSprint,
+            this.keyBindDrop,
+            this.keyBindInventory,
+            this.keyBindChat,
+            this.keyBindPlayerList,
+            this.keyBindPickBlock,
+            this.keyBindCommand,
+            this.keyBindScreenshot,
+            this.keyBindTogglePerspective,
+            this.keyBindSmoothCamera,
+            this.keyBindFullscreen,
+            this.keyBindSpectatorOutlines,
+            this.keyBindSwapHands,
+            this.keyBindSaveToolbar,
+            this.keyBindLoadToolbar,
+            this.keyBindAdvancements
+         },
+         this.keyBindsHotbar
+      );
+      this.difficulty = EnumDifficulty.NORMAL;
+      this.lastServer = "";
+      this.fovSetting = 70.0F;
+      this.language = "en_us";
+      this.mc = mcIn;
+      this.optionsFile = new File(optionsFileIn, "options.txt");
+      if (mcIn.isJava64bit() && Runtime.getRuntime().maxMemory() >= 1000000000L) {
          GameSettings.Options.RENDER_DISTANCE.setValueMax(32.0F);
+         long MB = 1000000L;
+         if (Runtime.getRuntime().maxMemory() >= 1500L * MB) {
+            GameSettings.Options.RENDER_DISTANCE.setValueMax(48.0F);
+         }
+
+         if (Runtime.getRuntime().maxMemory() >= 2500L * MB) {
+            GameSettings.Options.RENDER_DISTANCE.setValueMax(64.0F);
+         }
       } else {
          GameSettings.Options.RENDER_DISTANCE.setValueMax(16.0F);
       }
 
-      this.renderDistanceChunks = ☃.isJava64bit() ? 12 : 8;
+      this.renderDistanceChunks = mcIn.isJava64bit() ? 12 : 8;
+      this.optionsFileOF = new File(optionsFileIn, "optionsof.txt");
+      this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+      this.ofKeyBindZoom = new KeyBinding("of.key.zoom", 46, "key.categories.misc");
+      this.keyBindings = (KeyBinding[])ArrayUtils.add(this.keyBindings, this.ofKeyBindZoom);
+      KeyUtils.fixKeyConflicts(this.keyBindings, new KeyBinding[]{this.ofKeyBindZoom});
+      this.renderDistanceChunks = 8;
       this.loadOptions();
+      Config.initGameSettings(this);
    }
 
    public GameSettings() {
+      this.setForgeKeybindProperties();
+      this.keyBindings = (KeyBinding[])ArrayUtils.addAll(
+         new KeyBinding[]{
+            this.keyBindAttack,
+            this.keyBindUseItem,
+            this.keyBindForward,
+            this.keyBindLeft,
+            this.keyBindBack,
+            this.keyBindRight,
+            this.keyBindJump,
+            this.keyBindSneak,
+            this.keyBindSprint,
+            this.keyBindDrop,
+            this.keyBindInventory,
+            this.keyBindChat,
+            this.keyBindPlayerList,
+            this.keyBindPickBlock,
+            this.keyBindCommand,
+            this.keyBindScreenshot,
+            this.keyBindTogglePerspective,
+            this.keyBindSmoothCamera,
+            this.keyBindFullscreen,
+            this.keyBindSpectatorOutlines,
+            this.keyBindSwapHands,
+            this.keyBindSaveToolbar,
+            this.keyBindLoadToolbar,
+            this.keyBindAdvancements
+         },
+         this.keyBindsHotbar
+      );
+      this.difficulty = EnumDifficulty.NORMAL;
+      this.lastServer = "";
+      this.fovSetting = 70.0F;
+      this.language = "en_us";
    }
 
-   public static String getKeyDisplayString(int var0) {
-      if (☃ < 0) {
-         switch (☃) {
+   public static String getKeyDisplayString(int key) {
+      if (key < 0) {
+         switch (key) {
             case -100:
                return I18n.format("key.mouse.left");
             case -99:
@@ -227,73 +386,81 @@ public static String getKeyDisplayString(int var0) {
             case -98:
                return I18n.format("key.mouse.middle");
             default:
-               return I18n.format("key.mouseButton", ☃ + 101);
+               return I18n.format("key.mouseButton", key + 101);
          }
       } else {
-         return ☃ < 256 ? Keyboard.getKeyName(☃) : String.format("%c", (char)(☃ - 256)).toUpperCase();
+         return key < 256 ? Keyboard.getKeyName(key) : String.format("%c", (char)(key - 256)).toUpperCase();
       }
    }
 
-   public static boolean isKeyDown(KeyBinding var0) {
-      int ☃ = ☃.getKeyCode();
-      if (☃ == 0 || ☃ >= 256) {
-         return false;
+   public static boolean isKeyDown(KeyBinding key) {
+      int i = key.getKeyCode();
+      if (i != 0 && i < 256) {
+         return i < 0 ? Mouse.isButtonDown(i + 100) : Keyboard.isKeyDown(i);
       } else {
-         return ☃ < 0 ? Mouse.isButtonDown(☃ + 100) : Keyboard.isKeyDown(☃);
+         return false;
       }
    }
 
-   public void setOptionKeyBinding(KeyBinding var1, int var2) {
-      ☃.setKeyCode(☃);
+   public void setOptionKeyBinding(KeyBinding key, int keyCode) {
+      key.setKeyCode(keyCode);
       this.saveOptions();
    }
 
-   public void setOptionFloatValue(GameSettings.Options var1, float var2) {
-      if (☃ == GameSettings.Options.SENSITIVITY) {
-         this.mouseSensitivity = ☃;
+   public void setOptionFloatValue(GameSettings.Options settingsOption, float value) {
+      this.setOptionFloatValueOF(settingsOption, value);
+      if (settingsOption == GameSettings.Options.SENSITIVITY) {
+         this.mouseSensitivity = value;
       }
 
-      if (☃ == GameSettings.Options.FOV) {
-         this.fovSetting = ☃;
+      if (settingsOption == GameSettings.Options.FOV) {
+         this.fovSetting = value;
       }
 
-      if (☃ == GameSettings.Options.GAMMA) {
-         this.gammaSetting = ☃;
+      if (settingsOption == GameSettings.Options.GAMMA) {
+         this.gammaSetting = value;
       }
 
-      if (☃ == GameSettings.Options.FRAMERATE_LIMIT) {
-         this.limitFramerate = (int)☃;
+      if (settingsOption == GameSettings.Options.FRAMERATE_LIMIT) {
+         this.limitFramerate = (int)value;
+         this.enableVsync = false;
+         if (this.limitFramerate <= 0) {
+            this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+            this.enableVsync = true;
+         }
+
+         this.updateVSync();
       }
 
-      if (☃ == GameSettings.Options.CHAT_OPACITY) {
-         this.chatOpacity = ☃;
+      if (settingsOption == GameSettings.Options.CHAT_OPACITY) {
+         this.chatOpacity = value;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
 
-      if (☃ == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
-         this.chatHeightFocused = ☃;
+      if (settingsOption == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
+         this.chatHeightFocused = value;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
 
-      if (☃ == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
-         this.chatHeightUnfocused = ☃;
+      if (settingsOption == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
+         this.chatHeightUnfocused = value;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
 
-      if (☃ == GameSettings.Options.CHAT_WIDTH) {
-         this.chatWidth = ☃;
+      if (settingsOption == GameSettings.Options.CHAT_WIDTH) {
+         this.chatWidth = value;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
 
-      if (☃ == GameSettings.Options.CHAT_SCALE) {
-         this.chatScale = ☃;
+      if (settingsOption == GameSettings.Options.CHAT_SCALE) {
+         this.chatScale = value;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
 
-      if (☃ == GameSettings.Options.MIPMAP_LEVELS) {
-         int ☃ = this.mipmapLevels;
-         this.mipmapLevels = (int)☃;
-         if (☃ != ☃) {
+      if (settingsOption == GameSettings.Options.MIPMAP_LEVELS) {
+         int i = this.mipmapLevels;
+         this.mipmapLevels = (int)value;
+         if (i != value) {
             this.mc.getTextureMapBlocks().setMipmapLevels(this.mipmapLevels);
             this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
             this.mc.getTextureMapBlocks().setBlurMipmapDirect(false, this.mipmapLevels > 0);
@@ -301,133 +468,166 @@ public void setOptionFloatValue(GameSettings.Options var1, float var2) {
          }
       }
 
-      if (☃ == GameSettings.Options.RENDER_DISTANCE) {
-         this.renderDistanceChunks = (int)☃;
+      if (settingsOption == GameSettings.Options.RENDER_DISTANCE) {
+         this.renderDistanceChunks = (int)value;
          this.mc.renderGlobal.setDisplayListEntitiesDirty();
       }
    }
 
-   public void setOptionValue(GameSettings.Options var1, int var2) {
-      if (☃ == GameSettings.Options.RENDER_DISTANCE) {
-         this.setOptionFloatValue(☃, MathHelper.clamp((float)(this.renderDistanceChunks + ☃), ☃.getValueMin(), ☃.getValueMax()));
+   public void setOptionValue(GameSettings.Options settingsOption, int value) {
+      this.setOptionValueOF(settingsOption, value);
+      if (settingsOption == GameSettings.Options.RENDER_DISTANCE) {
+         this.setOptionFloatValue(
+            settingsOption, MathHelper.clamp((float)(this.renderDistanceChunks + value), settingsOption.getValueMin(), settingsOption.getValueMax())
+         );
       }
 
-      if (☃ == GameSettings.Options.MAIN_HAND) {
+      if (settingsOption == GameSettings.Options.MAIN_HAND) {
          this.mainHand = this.mainHand.opposite();
       }
 
-      if (☃ == GameSettings.Options.INVERT_MOUSE) {
+      if (settingsOption == GameSettings.Options.INVERT_MOUSE) {
          this.invertMouse = !this.invertMouse;
       }
 
-      if (☃ == GameSettings.Options.GUI_SCALE) {
-         this.guiScale = this.guiScale + ☃ & 3;
+      if (settingsOption == GameSettings.Options.GUI_SCALE) {
+         this.guiScale += value;
+         if (GuiScreen.isShiftKeyDown()) {
+            this.guiScale = 0;
+         }
+
+         DisplayMode mode = Config.getLargestDisplayMode();
+         int maxScaleWidth = mode.getWidth() / 320;
+         int maxScaleHeight = mode.getHeight() / 240;
+         int maxGuiScale = Math.min(maxScaleWidth, maxScaleHeight);
+         if (this.guiScale < 0) {
+            this.guiScale = maxGuiScale - 1;
+         }
+
+         if (this.mc.isUnicode() && this.guiScale % 2 != 0) {
+            this.guiScale += value;
+         }
+
+         if (this.guiScale < 0 || this.guiScale >= maxGuiScale) {
+            this.guiScale = 0;
+         }
       }
 
-      if (☃ == GameSettings.Options.PARTICLES) {
-         this.particleSetting = (this.particleSetting + ☃) % 3;
+      if (settingsOption == GameSettings.Options.PARTICLES) {
+         this.particleSetting = (this.particleSetting + value) % 3;
       }
 
-      if (☃ == GameSettings.Options.VIEW_BOBBING) {
+      if (settingsOption == GameSettings.Options.VIEW_BOBBING) {
          this.viewBobbing = !this.viewBobbing;
       }
 
-      if (☃ == GameSettings.Options.RENDER_CLOUDS) {
-         this.clouds = (this.clouds + ☃) % 3;
+      if (settingsOption == GameSettings.Options.RENDER_CLOUDS) {
+         this.clouds = (this.clouds + value) % 3;
       }
 
-      if (☃ == GameSettings.Options.FORCE_UNICODE_FONT) {
+      if (settingsOption == GameSettings.Options.FORCE_UNICODE_FONT) {
          this.forceUnicodeFont = !this.forceUnicodeFont;
          this.mc.fontRenderer.setUnicodeFlag(this.mc.getLanguageManager().isCurrentLocaleUnicode() || this.forceUnicodeFont);
       }
 
-      if (☃ == GameSettings.Options.FBO_ENABLE) {
+      if (settingsOption == GameSettings.Options.FBO_ENABLE) {
          this.fboEnable = !this.fboEnable;
       }
 
-      if (☃ == GameSettings.Options.ANAGLYPH) {
+      if (settingsOption == GameSettings.Options.ANAGLYPH) {
+         if (!this.anaglyph && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.an.shaders1"), Lang.get("of.message.an.shaders2"));
+            return;
+         }
+
          this.anaglyph = !this.anaglyph;
          this.mc.refreshResources();
+         if (Reflector.FMLClientHandler_refreshResources.exists()) {
+            Object instance = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+            IResourceType type = (IResourceType)Reflector.VanillaResourceType_TEXTURES.getValue();
+            Reflector.call(instance, Reflector.FMLClientHandler_refreshResources, new IResourceType[]{type});
+         }
       }
 
-      if (☃ == GameSettings.Options.GRAPHICS) {
+      if (settingsOption == GameSettings.Options.GRAPHICS) {
          this.fancyGraphics = !this.fancyGraphics;
+         this.updateRenderClouds();
          this.mc.renderGlobal.loadRenderers();
       }
 
-      if (☃ == GameSettings.Options.AMBIENT_OCCLUSION) {
-         this.ambientOcclusion = (this.ambientOcclusion + ☃) % 3;
+      if (settingsOption == GameSettings.Options.AMBIENT_OCCLUSION) {
+         this.ambientOcclusion = (this.ambientOcclusion + value) % 3;
          this.mc.renderGlobal.loadRenderers();
       }
 
-      if (☃ == GameSettings.Options.CHAT_VISIBILITY) {
-         this.chatVisibility = EntityPlayer.EnumChatVisibility.getEnumChatVisibility((this.chatVisibility.getChatVisibility() + ☃) % 3);
+      if (settingsOption == GameSettings.Options.CHAT_VISIBILITY) {
+         this.chatVisibility = EnumChatVisibility.getEnumChatVisibility((this.chatVisibility.getChatVisibility() + value) % 3);
       }
 
-      if (☃ == GameSettings.Options.CHAT_COLOR) {
+      if (settingsOption == GameSettings.Options.CHAT_COLOR) {
          this.chatColours = !this.chatColours;
       }
 
-      if (☃ == GameSettings.Options.CHAT_LINKS) {
+      if (settingsOption == GameSettings.Options.CHAT_LINKS) {
          this.chatLinks = !this.chatLinks;
       }
 
-      if (☃ == GameSettings.Options.CHAT_LINKS_PROMPT) {
+      if (settingsOption == GameSettings.Options.CHAT_LINKS_PROMPT) {
          this.chatLinksPrompt = !this.chatLinksPrompt;
       }
 
-      if (☃ == GameSettings.Options.SNOOPER_ENABLED) {
+      if (settingsOption == GameSettings.Options.SNOOPER_ENABLED) {
          this.snooperEnabled = !this.snooperEnabled;
       }
 
-      if (☃ == GameSettings.Options.TOUCHSCREEN) {
+      if (settingsOption == GameSettings.Options.TOUCHSCREEN) {
          this.touchscreen = !this.touchscreen;
       }
 
-      if (☃ == GameSettings.Options.USE_FULLSCREEN) {
+      if (settingsOption == GameSettings.Options.USE_FULLSCREEN) {
          this.fullScreen = !this.fullScreen;
          if (this.mc.isFullScreen() != this.fullScreen) {
             this.mc.toggleFullscreen();
          }
       }
 
-      if (☃ == GameSettings.Options.ENABLE_VSYNC) {
+      if (settingsOption == GameSettings.Options.ENABLE_VSYNC) {
          this.enableVsync = !this.enableVsync;
          Display.setVSyncEnabled(this.enableVsync);
       }
 
-      if (☃ == GameSettings.Options.USE_VBO) {
+      if (settingsOption == GameSettings.Options.USE_VBO) {
          this.useVbo = !this.useVbo;
          this.mc.renderGlobal.loadRenderers();
       }
 
-      if (☃ == GameSettings.Options.REDUCED_DEBUG_INFO) {
+      if (settingsOption == GameSettings.Options.REDUCED_DEBUG_INFO) {
          this.reducedDebugInfo = !this.reducedDebugInfo;
       }
 
-      if (☃ == GameSettings.Options.ENTITY_SHADOWS) {
+      if (settingsOption == GameSettings.Options.ENTITY_SHADOWS) {
          this.entityShadows = !this.entityShadows;
       }
 
-      if (☃ == GameSettings.Options.ATTACK_INDICATOR) {
-         this.attackIndicator = (this.attackIndicator + ☃) % 3;
+      if (settingsOption == GameSettings.Options.ATTACK_INDICATOR) {
+         this.attackIndicator = (this.attackIndicator + value) % 3;
       }
 
-      if (☃ == GameSettings.Options.SHOW_SUBTITLES) {
+      if (settingsOption == GameSettings.Options.SHOW_SUBTITLES) {
          this.showSubtitles = !this.showSubtitles;
       }
 
-      if (☃ == GameSettings.Options.REALMS_NOTIFICATIONS) {
+      if (settingsOption == GameSettings.Options.REALMS_NOTIFICATIONS) {
          this.realmsNotifications = !this.realmsNotifications;
       }
 
-      if (☃ == GameSettings.Options.AUTO_JUMP) {
+      if (settingsOption == GameSettings.Options.AUTO_JUMP) {
          this.autoJump = !this.autoJump;
       }
 
-      if (☃ == GameSettings.Options.NARRATOR) {
+      if (settingsOption == GameSettings.Options.NARRATOR) {
          if (NarratorChatListener.INSTANCE.isActive()) {
-            this.narrator = (this.narrator + ☃) % NARRATOR_MODES.length;
+            this.narrator = (this.narrator + value) % NARRATOR_MODES.length;
          } else {
             this.narrator = 0;
          }
@@ -438,36 +638,39 @@ public void setOptionValue(GameSettings.Options var1, int var2) {
       this.saveOptions();
    }
 
-   public float getOptionFloatValue(GameSettings.Options var1) {
-      if (☃ == GameSettings.Options.FOV) {
+   public float getOptionFloatValue(GameSettings.Options settingOption) {
+      float valOF = this.getOptionFloatValueOF(settingOption);
+      if (valOF != Float.MAX_VALUE) {
+         return valOF;
+      } else if (settingOption == GameSettings.Options.FOV) {
          return this.fovSetting;
-      } else if (☃ == GameSettings.Options.GAMMA) {
+      } else if (settingOption == GameSettings.Options.GAMMA) {
          return this.gammaSetting;
-      } else if (☃ == GameSettings.Options.SATURATION) {
+      } else if (settingOption == GameSettings.Options.SATURATION) {
          return this.saturation;
-      } else if (☃ == GameSettings.Options.SENSITIVITY) {
+      } else if (settingOption == GameSettings.Options.SENSITIVITY) {
          return this.mouseSensitivity;
-      } else if (☃ == GameSettings.Options.CHAT_OPACITY) {
+      } else if (settingOption == GameSettings.Options.CHAT_OPACITY) {
          return this.chatOpacity;
-      } else if (☃ == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
+      } else if (settingOption == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
          return this.chatHeightFocused;
-      } else if (☃ == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
+      } else if (settingOption == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
          return this.chatHeightUnfocused;
-      } else if (☃ == GameSettings.Options.CHAT_SCALE) {
+      } else if (settingOption == GameSettings.Options.CHAT_SCALE) {
          return this.chatScale;
-      } else if (☃ == GameSettings.Options.CHAT_WIDTH) {
+      } else if (settingOption == GameSettings.Options.CHAT_WIDTH) {
          return this.chatWidth;
-      } else if (☃ == GameSettings.Options.FRAMERATE_LIMIT) {
+      } else if (settingOption == GameSettings.Options.FRAMERATE_LIMIT) {
          return this.limitFramerate;
-      } else if (☃ == GameSettings.Options.MIPMAP_LEVELS) {
+      } else if (settingOption == GameSettings.Options.MIPMAP_LEVELS) {
          return this.mipmapLevels;
       } else {
-         return ☃ == GameSettings.Options.RENDER_DISTANCE ? this.renderDistanceChunks : 0.0F;
+         return settingOption == GameSettings.Options.RENDER_DISTANCE ? this.renderDistanceChunks : 0.0F;
       }
    }
 
-   public boolean getOptionOrdinalValue(GameSettings.Options var1) {
-      switch (☃) {
+   public boolean getOptionOrdinalValue(GameSettings.Options settingOption) {
+      switch (settingOption) {
          case INVERT_MOUSE:
             return this.invertMouse;
          case VIEW_BOBBING:
@@ -511,541 +714,2045 @@ public boolean getOptionOrdinalValue(GameSettings.Options var1) {
       }
    }
 
-   private static String getTranslation(String[] var0, int var1) {
-      if (☃ < 0 || ☃ >= ☃.length) {
-         ☃ = 0;
+   private static String getTranslation(String[] strArray, int index) {
+      if (index < 0 || index >= strArray.length) {
+         index = 0;
       }
 
-      return I18n.format(☃[☃]);
+      return I18n.format(strArray[index]);
    }
 
-   public String getKeyBinding(GameSettings.Options var1) {
-      String ☃ = I18n.format(☃.getTranslation()) + ": ";
-      if (☃.isFloat()) {
-         float ☃x = this.getOptionFloatValue(☃);
-         float ☃xx = ☃.normalizeValue(☃x);
-         if (☃ == GameSettings.Options.SENSITIVITY) {
-            if (☃xx == 0.0F) {
-               return ☃ + I18n.format("options.sensitivity.min");
+   public String getKeyBinding(GameSettings.Options settingOption) {
+      String strOF = this.getKeyBindingOF(settingOption);
+      if (strOF != null) {
+         return strOF;
+      } else {
+         String s = I18n.format(settingOption.getTranslation()) + ": ";
+         if (settingOption.isFloat()) {
+            float f1 = this.getOptionFloatValue(settingOption);
+            float f = settingOption.normalizeValue(f1);
+            if (settingOption == GameSettings.Options.SENSITIVITY) {
+               if (f == 0.0F) {
+                  return s + I18n.format("options.sensitivity.min");
+               } else {
+                  return f == 1.0F ? s + I18n.format("options.sensitivity.max") : s + (int)(f * 200.0F) + "%";
+               }
+            } else if (settingOption == GameSettings.Options.FOV) {
+               if (f1 == 70.0F) {
+                  return s + I18n.format("options.fov.min");
+               } else {
+                  return f1 == 110.0F ? s + I18n.format("options.fov.max") : s + (int)f1;
+               }
+            } else if (settingOption == GameSettings.Options.FRAMERATE_LIMIT) {
+               return f1 == settingOption.valueMax ? s + I18n.format("options.framerateLimit.max") : s + I18n.format("options.framerate", (int)f1);
+            } else if (settingOption == GameSettings.Options.RENDER_CLOUDS) {
+               return f1 == settingOption.valueMin ? s + I18n.format("options.cloudHeight.min") : s + ((int)f1 + 128);
+            } else if (settingOption == GameSettings.Options.GAMMA) {
+               if (f == 0.0F) {
+                  return s + I18n.format("options.gamma.min");
+               } else {
+                  return f == 1.0F ? s + I18n.format("options.gamma.max") : s + "+" + (int)(f * 100.0F) + "%";
+               }
+            } else if (settingOption == GameSettings.Options.SATURATION) {
+               return s + (int)(f * 400.0F) + "%";
+            } else if (settingOption == GameSettings.Options.CHAT_OPACITY) {
+               return s + (int)(f * 90.0F + 10.0F) + "%";
+            } else if (settingOption == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
+               return s + GuiNewChat.calculateChatboxHeight(f) + "px";
+            } else if (settingOption == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
+               return s + GuiNewChat.calculateChatboxHeight(f) + "px";
+            } else if (settingOption == GameSettings.Options.CHAT_WIDTH) {
+               return s + GuiNewChat.calculateChatboxWidth(f) + "px";
+            } else if (settingOption == GameSettings.Options.RENDER_DISTANCE) {
+               return s + I18n.format("options.chunks", (int)f1);
+            } else if (settingOption == GameSettings.Options.MIPMAP_LEVELS) {
+               if (f1 >= 4.0) {
+                  return s + Lang.get("of.general.max");
+               } else {
+                  return f1 == 0.0F ? s + I18n.format("options.off") : s + (int)f1;
+               }
             } else {
-               return ☃xx == 1.0F ? ☃ + I18n.format("options.sensitivity.max") : ☃ + (int)(☃xx * 200.0F) + "%";
+               return f == 0.0F ? s + I18n.format("options.off") : s + (int)(f * 100.0F) + "%";
             }
-         } else if (☃ == GameSettings.Options.FOV) {
-            if (☃x == 70.0F) {
-               return ☃ + I18n.format("options.fov.min");
+         } else if (settingOption.isBoolean()) {
+            boolean flag = this.getOptionOrdinalValue(settingOption);
+            return flag ? s + I18n.format("options.on") : s + I18n.format("options.off");
+         } else if (settingOption == GameSettings.Options.MAIN_HAND) {
+            return s + this.mainHand;
+         } else if (settingOption == GameSettings.Options.GUI_SCALE) {
+            return this.guiScale >= GUISCALES.length ? s + this.guiScale + "x" : s + getTranslation(GUISCALES, this.guiScale);
+         } else if (settingOption == GameSettings.Options.CHAT_VISIBILITY) {
+            return s + I18n.format(this.chatVisibility.getResourceKey());
+         } else if (settingOption == GameSettings.Options.PARTICLES) {
+            return s + getTranslation(PARTICLES, this.particleSetting);
+         } else if (settingOption == GameSettings.Options.AMBIENT_OCCLUSION) {
+            return s + getTranslation(AMBIENT_OCCLUSIONS, this.ambientOcclusion);
+         } else if (settingOption == GameSettings.Options.RENDER_CLOUDS) {
+            return s + getTranslation(CLOUDS_TYPES, this.clouds);
+         } else if (settingOption == GameSettings.Options.GRAPHICS) {
+            if (this.fancyGraphics) {
+               return s + I18n.format("options.graphics.fancy");
             } else {
-               return ☃x == 110.0F ? ☃ + I18n.format("options.fov.max") : ☃ + (int)☃x;
+               String s1 = "options.graphics.fast";
+               return s + I18n.format("options.graphics.fast");
+            }
+         } else if (settingOption == GameSettings.Options.ATTACK_INDICATOR) {
+            return s + getTranslation(ATTACK_INDICATORS, this.attackIndicator);
+         } else if (settingOption == GameSettings.Options.NARRATOR) {
+            return NarratorChatListener.INSTANCE.isActive()
+               ? s + getTranslation(NARRATOR_MODES, this.narrator)
+               : s + I18n.format("options.narrator.notavailable");
+         } else {
+            return s;
+         }
+      }
+   }
+
+   public void loadOptions() {
+      FileInputStream is = null;
+
+      label542: {
+         try {
+            if (this.optionsFile.exists()) {
+               this.soundLevels.clear();
+               List<String> list = IOUtils.readLines(is = new FileInputStream(this.optionsFile), StandardCharsets.UTF_8);
+               NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+               for (String s : list) {
+                  try {
+                     Iterator<String> iterator = COLON_SPLITTER.omitEmptyStrings().limit(2).split(s).iterator();
+                     nbttagcompound.setString(iterator.next(), iterator.next());
+                  } catch (Exception var18) {
+                     LOGGER.warn("Skipping bad option: {}", s);
+                  }
+               }
+
+               nbttagcompound = this.dataFix(nbttagcompound);
+
+               for (String s1 : nbttagcompound.getKeySet()) {
+                  String s2 = nbttagcompound.getString(s1);
+
+                  try {
+                     if ("mouseSensitivity".equals(s1)) {
+                        this.mouseSensitivity = this.parseFloat(s2);
+                     }
+
+                     if ("fov".equals(s1)) {
+                        this.fovSetting = this.parseFloat(s2) * 40.0F + 70.0F;
+                     }
+
+                     if ("gamma".equals(s1)) {
+                        this.gammaSetting = this.parseFloat(s2);
+                     }
+
+                     if ("saturation".equals(s1)) {
+                        this.saturation = this.parseFloat(s2);
+                     }
+
+                     if ("invertYMouse".equals(s1)) {
+                        this.invertMouse = "true".equals(s2);
+                     }
+
+                     if ("renderDistance".equals(s1)) {
+                        this.renderDistanceChunks = Integer.parseInt(s2);
+                     }
+
+                     if ("guiScale".equals(s1)) {
+                        this.guiScale = Integer.parseInt(s2);
+                     }
+
+                     if ("particles".equals(s1)) {
+                        this.particleSetting = Integer.parseInt(s2);
+                     }
+
+                     if ("bobView".equals(s1)) {
+                        this.viewBobbing = "true".equals(s2);
+                     }
+
+                     if ("anaglyph3d".equals(s1)) {
+                        this.anaglyph = "true".equals(s2);
+                     }
+
+                     if ("maxFps".equals(s1)) {
+                        this.limitFramerate = Integer.parseInt(s2);
+                        if (this.enableVsync) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+
+                        if (this.limitFramerate <= 0) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+                     }
+
+                     if ("fboEnable".equals(s1)) {
+                        this.fboEnable = "true".equals(s2);
+                     }
+
+                     if ("difficulty".equals(s1)) {
+                        this.difficulty = EnumDifficulty.byId(Integer.parseInt(s2));
+                     }
+
+                     if ("fancyGraphics".equals(s1)) {
+                        this.fancyGraphics = "true".equals(s2);
+                        this.updateRenderClouds();
+                     }
+
+                     if ("tutorialStep".equals(s1)) {
+                        this.tutorialStep = TutorialSteps.getTutorial(s2);
+                     }
+
+                     if ("ao".equals(s1)) {
+                        if ("true".equals(s2)) {
+                           this.ambientOcclusion = 2;
+                        } else if ("false".equals(s2)) {
+                           this.ambientOcclusion = 0;
+                        } else {
+                           this.ambientOcclusion = Integer.parseInt(s2);
+                        }
+                     }
+
+                     if ("renderClouds".equals(s1)) {
+                        if ("true".equals(s2)) {
+                           this.clouds = 2;
+                        } else if ("false".equals(s2)) {
+                           this.clouds = 0;
+                        } else if ("fast".equals(s2)) {
+                           this.clouds = 1;
+                        }
+                     }
+
+                     if ("attackIndicator".equals(s1)) {
+                        if ("0".equals(s2)) {
+                           this.attackIndicator = 0;
+                        } else if ("1".equals(s2)) {
+                           this.attackIndicator = 1;
+                        } else if ("2".equals(s2)) {
+                           this.attackIndicator = 2;
+                        }
+                     }
+
+                     if ("resourcePacks".equals(s1)) {
+                        this.resourcePacks = (List<String>)JsonUtils.gsonDeserialize(GSON, s2, TYPE_LIST_STRING);
+                        if (this.resourcePacks == null) {
+                           this.resourcePacks = Lists.newArrayList();
+                        }
+                     }
+
+                     if ("incompatibleResourcePacks".equals(s1)) {
+                        this.incompatibleResourcePacks = (List<String>)JsonUtils.gsonDeserialize(GSON, s2, TYPE_LIST_STRING);
+                        if (this.incompatibleResourcePacks == null) {
+                           this.incompatibleResourcePacks = Lists.newArrayList();
+                        }
+                     }
+
+                     if ("lastServer".equals(s1)) {
+                        this.lastServer = s2;
+                     }
+
+                     if ("lang".equals(s1)) {
+                        this.language = s2;
+                     }
+
+                     if ("chatVisibility".equals(s1)) {
+                        this.chatVisibility = EnumChatVisibility.getEnumChatVisibility(Integer.parseInt(s2));
+                     }
+
+                     if ("chatColors".equals(s1)) {
+                        this.chatColours = "true".equals(s2);
+                     }
+
+                     if ("chatLinks".equals(s1)) {
+                        this.chatLinks = "true".equals(s2);
+                     }
+
+                     if ("chatLinksPrompt".equals(s1)) {
+                        this.chatLinksPrompt = "true".equals(s2);
+                     }
+
+                     if ("chatOpacity".equals(s1)) {
+                        this.chatOpacity = this.parseFloat(s2);
+                     }
+
+                     if ("snooperEnabled".equals(s1)) {
+                        this.snooperEnabled = "true".equals(s2);
+                     }
+
+                     if ("fullscreen".equals(s1)) {
+                        this.fullScreen = "true".equals(s2);
+                     }
+
+                     if ("enableVsync".equals(s1)) {
+                        this.enableVsync = "true".equals(s2);
+                        if (this.enableVsync) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+
+                        this.updateVSync();
+                     }
+
+                     if ("useVbo".equals(s1)) {
+                        this.useVbo = "true".equals(s2);
+                     }
+
+                     if ("hideServerAddress".equals(s1)) {
+                        this.hideServerAddress = "true".equals(s2);
+                     }
+
+                     if ("advancedItemTooltips".equals(s1)) {
+                        this.advancedItemTooltips = "true".equals(s2);
+                     }
+
+                     if ("pauseOnLostFocus".equals(s1)) {
+                        this.pauseOnLostFocus = "true".equals(s2);
+                     }
+
+                     if ("touchscreen".equals(s1)) {
+                        this.touchscreen = "true".equals(s2);
+                     }
+
+                     if ("overrideHeight".equals(s1)) {
+                        this.overrideHeight = Integer.parseInt(s2);
+                     }
+
+                     if ("overrideWidth".equals(s1)) {
+                        this.overrideWidth = Integer.parseInt(s2);
+                     }
+
+                     if ("heldItemTooltips".equals(s1)) {
+                        this.heldItemTooltips = "true".equals(s2);
+                     }
+
+                     if ("chatHeightFocused".equals(s1)) {
+                        this.chatHeightFocused = this.parseFloat(s2);
+                     }
+
+                     if ("chatHeightUnfocused".equals(s1)) {
+                        this.chatHeightUnfocused = this.parseFloat(s2);
+                     }
+
+                     if ("chatScale".equals(s1)) {
+                        this.chatScale = this.parseFloat(s2);
+                     }
+
+                     if ("chatWidth".equals(s1)) {
+                        this.chatWidth = this.parseFloat(s2);
+                     }
+
+                     if ("mipmapLevels".equals(s1)) {
+                        this.mipmapLevels = Integer.parseInt(s2);
+                     }
+
+                     if ("forceUnicodeFont".equals(s1)) {
+                        this.forceUnicodeFont = "true".equals(s2);
+                     }
+
+                     if ("reducedDebugInfo".equals(s1)) {
+                        this.reducedDebugInfo = "true".equals(s2);
+                     }
+
+                     if ("useNativeTransport".equals(s1)) {
+                        this.useNativeTransport = "true".equals(s2);
+                     }
+
+                     if ("entityShadows".equals(s1)) {
+                        this.entityShadows = "true".equals(s2);
+                     }
+
+                     if ("mainHand".equals(s1)) {
+                        this.mainHand = "left".equals(s2) ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
+                     }
+
+                     if ("showSubtitles".equals(s1)) {
+                        this.showSubtitles = "true".equals(s2);
+                     }
+
+                     if ("realmsNotifications".equals(s1)) {
+                        this.realmsNotifications = "true".equals(s2);
+                     }
+
+                     if ("enableWeakAttacks".equals(s1)) {
+                        this.enableWeakAttacks = "true".equals(s2);
+                     }
+
+                     if ("autoJump".equals(s1)) {
+                        this.autoJump = "true".equals(s2);
+                     }
+
+                     if ("narrator".equals(s1)) {
+                        this.narrator = Integer.parseInt(s2);
+                     }
+
+                     for (KeyBinding keybinding : this.keyBindings) {
+                        if (s1.equals("key_" + keybinding.getKeyDescription())) {
+                           if (Reflector.KeyModifier_valueFromString.exists()) {
+                              if (s2.indexOf(58) != -1) {
+                                 String[] t = s2.split(":");
+                                 Object keyModifier = Reflector.call(Reflector.KeyModifier_valueFromString, new Object[]{t[1]});
+                                 Reflector.call(keybinding, Reflector.ForgeKeyBinding_setKeyModifierAndCode, new Object[]{keyModifier, Integer.parseInt(t[0])});
+                              } else {
+                                 Object keyModifierNone = Reflector.getFieldValue(Reflector.KeyModifier_NONE);
+                                 Reflector.call(
+                                    keybinding, Reflector.ForgeKeyBinding_setKeyModifierAndCode, new Object[]{keyModifierNone, Integer.parseInt(s2)}
+                                 );
+                              }
+                           } else {
+                              keybinding.setKeyCode(Integer.parseInt(s2));
+                           }
+                        }
+                     }
+
+                     for (SoundCategory soundcategory : SoundCategory.values()) {
+                        if (s1.equals("soundCategory_" + soundcategory.getName())) {
+                           this.soundLevels.put(soundcategory, this.parseFloat(s2));
+                        }
+                     }
+
+                     for (EnumPlayerModelParts enumplayermodelparts : EnumPlayerModelParts.values()) {
+                        if (s1.equals("modelPart_" + enumplayermodelparts.getPartName())) {
+                           this.setModelPartEnabled(enumplayermodelparts, "true".equals(s2));
+                        }
+                     }
+                  } catch (Exception var19) {
+                     LOGGER.warn("Skipping bad option: {}:{}", s1, s2);
+                     var19.printStackTrace();
+                  }
+               }
+
+               KeyBinding.resetKeyBindingArrayAndHash();
+               break label542;
             }
-         } else if (☃ == GameSettings.Options.FRAMERATE_LIMIT) {
-            return ☃x == ☃.valueMax ? ☃ + I18n.format("options.framerateLimit.max") : ☃ + I18n.format("options.framerate", (int)☃x);
-         } else if (☃ == GameSettings.Options.RENDER_CLOUDS) {
-            return ☃x == ☃.valueMin ? ☃ + I18n.format("options.cloudHeight.min") : ☃ + ((int)☃x + 128);
-         } else if (☃ == GameSettings.Options.GAMMA) {
-            if (☃xx == 0.0F) {
-               return ☃ + I18n.format("options.gamma.min");
+         } catch (Exception var20) {
+            LOGGER.error("Failed to load options", var20);
+            break label542;
+         } finally {
+            IOUtils.closeQuietly(is);
+         }
+
+         return;
+      }
+
+      this.loadOfOptions();
+   }
+
+   private NBTTagCompound dataFix(NBTTagCompound p_189988_1_) {
+      int i = 0;
+
+      try {
+         i = Integer.parseInt(p_189988_1_.getString("version"));
+      } catch (RuntimeException var4) {
+      }
+
+      return this.mc.getDataFixer().process(FixTypes.OPTIONS, p_189988_1_, i);
+   }
+
+   private float parseFloat(String str) {
+      if ("true".equals(str)) {
+         return 1.0F;
+      } else {
+         return "false".equals(str) ? 0.0F : Float.parseFloat(str);
+      }
+   }
+
+   public void saveOptions() {
+      if (Reflector.FMLClientHandler.exists()) {
+         Object fml = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+         if (fml != null && Reflector.callBoolean(fml, Reflector.FMLClientHandler_isLoading, new Object[0])) {
+            return;
+         }
+      }
+
+      PrintWriter printwriter = null;
+
+      try {
+         printwriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFile), StandardCharsets.UTF_8));
+         printwriter.println("version:1343");
+         printwriter.println("invertYMouse:" + this.invertMouse);
+         printwriter.println("mouseSensitivity:" + this.mouseSensitivity);
+         printwriter.println("fov:" + (this.fovSetting - 70.0F) / 40.0F);
+         printwriter.println("gamma:" + this.gammaSetting);
+         printwriter.println("saturation:" + this.saturation);
+         printwriter.println("renderDistance:" + this.renderDistanceChunks);
+         printwriter.println("guiScale:" + this.guiScale);
+         printwriter.println("particles:" + this.particleSetting);
+         printwriter.println("bobView:" + this.viewBobbing);
+         printwriter.println("anaglyph3d:" + this.anaglyph);
+         printwriter.println("maxFps:" + this.limitFramerate);
+         printwriter.println("fboEnable:" + this.fboEnable);
+         printwriter.println("difficulty:" + this.difficulty.getId());
+         printwriter.println("fancyGraphics:" + this.fancyGraphics);
+         printwriter.println("ao:" + this.ambientOcclusion);
+         switch (this.clouds) {
+            case 0:
+               printwriter.println("renderClouds:false");
+               break;
+            case 1:
+               printwriter.println("renderClouds:fast");
+               break;
+            case 2:
+               printwriter.println("renderClouds:true");
+         }
+
+         printwriter.println("resourcePacks:" + GSON.toJson(this.resourcePacks));
+         printwriter.println("incompatibleResourcePacks:" + GSON.toJson(this.incompatibleResourcePacks));
+         printwriter.println("lastServer:" + this.lastServer);
+         printwriter.println("lang:" + this.language);
+         printwriter.println("chatVisibility:" + this.chatVisibility.getChatVisibility());
+         printwriter.println("chatColors:" + this.chatColours);
+         printwriter.println("chatLinks:" + this.chatLinks);
+         printwriter.println("chatLinksPrompt:" + this.chatLinksPrompt);
+         printwriter.println("chatOpacity:" + this.chatOpacity);
+         printwriter.println("snooperEnabled:" + this.snooperEnabled);
+         printwriter.println("fullscreen:" + this.fullScreen);
+         printwriter.println("enableVsync:" + this.enableVsync);
+         printwriter.println("useVbo:" + this.useVbo);
+         printwriter.println("hideServerAddress:" + this.hideServerAddress);
+         printwriter.println("advancedItemTooltips:" + this.advancedItemTooltips);
+         printwriter.println("pauseOnLostFocus:" + this.pauseOnLostFocus);
+         printwriter.println("touchscreen:" + this.touchscreen);
+         printwriter.println("overrideWidth:" + this.overrideWidth);
+         printwriter.println("overrideHeight:" + this.overrideHeight);
+         printwriter.println("heldItemTooltips:" + this.heldItemTooltips);
+         printwriter.println("chatHeightFocused:" + this.chatHeightFocused);
+         printwriter.println("chatHeightUnfocused:" + this.chatHeightUnfocused);
+         printwriter.println("chatScale:" + this.chatScale);
+         printwriter.println("chatWidth:" + this.chatWidth);
+         printwriter.println("mipmapLevels:" + this.mipmapLevels);
+         printwriter.println("forceUnicodeFont:" + this.forceUnicodeFont);
+         printwriter.println("reducedDebugInfo:" + this.reducedDebugInfo);
+         printwriter.println("useNativeTransport:" + this.useNativeTransport);
+         printwriter.println("entityShadows:" + this.entityShadows);
+         printwriter.println("mainHand:" + (this.mainHand == EnumHandSide.LEFT ? "left" : "right"));
+         printwriter.println("attackIndicator:" + this.attackIndicator);
+         printwriter.println("showSubtitles:" + this.showSubtitles);
+         printwriter.println("realmsNotifications:" + this.realmsNotifications);
+         printwriter.println("enableWeakAttacks:" + this.enableWeakAttacks);
+         printwriter.println("autoJump:" + this.autoJump);
+         printwriter.println("narrator:" + this.narrator);
+         printwriter.println("tutorialStep:" + this.tutorialStep.getName());
+
+         for (KeyBinding keybinding : this.keyBindings) {
+            if (Reflector.ForgeKeyBinding_getKeyModifier.exists()) {
+               String keyString = "key_" + keybinding.getKeyDescription() + ":" + keybinding.getKeyCode();
+               Object keyModifier = Reflector.call(keybinding, Reflector.ForgeKeyBinding_getKeyModifier, new Object[0]);
+               Object keyModifierNone = Reflector.getFieldValue(Reflector.KeyModifier_NONE);
+               printwriter.println(keyModifier != keyModifierNone ? keyString + ":" + keyModifier : keyString);
             } else {
-               return ☃xx == 1.0F ? ☃ + I18n.format("options.gamma.max") : ☃ + "+" + (int)(☃xx * 100.0F) + "%";
+               printwriter.println("key_" + keybinding.getKeyDescription() + ":" + keybinding.getKeyCode());
+            }
+         }
+
+         for (SoundCategory soundcategory : SoundCategory.values()) {
+            printwriter.println("soundCategory_" + soundcategory.getName() + ":" + this.getSoundLevel(soundcategory));
+         }
+
+         for (EnumPlayerModelParts enumplayermodelparts : EnumPlayerModelParts.values()) {
+            printwriter.println("modelPart_" + enumplayermodelparts.getPartName() + ":" + this.setModelParts.contains(enumplayermodelparts));
+         }
+      } catch (Exception var12) {
+         LOGGER.error("Failed to save options", var12);
+      } finally {
+         IOUtils.closeQuietly(printwriter);
+      }
+
+      this.saveOfOptions();
+      this.sendSettingsToServer();
+   }
+
+   public float getSoundLevel(SoundCategory category) {
+      return this.soundLevels.containsKey(category) ? this.soundLevels.get(category) : 1.0F;
+   }
+
+   public void setSoundLevel(SoundCategory category, float volume) {
+      this.mc.getSoundHandler().setSoundLevel(category, volume);
+      this.soundLevels.put(category, volume);
+   }
+
+   public void sendSettingsToServer() {
+      if (this.mc.player != null) {
+         int i = 0;
+
+         for (EnumPlayerModelParts enumplayermodelparts : this.setModelParts) {
+            i |= enumplayermodelparts.getPartMask();
+         }
+
+         this.mc
+            .player
+            .connection
+            .sendPacket(new CPacketClientSettings(this.language, this.renderDistanceChunks, this.chatVisibility, this.chatColours, i, this.mainHand));
+      }
+   }
+
+   public Set<EnumPlayerModelParts> getModelParts() {
+      return ImmutableSet.copyOf(this.setModelParts);
+   }
+
+   public void setModelPartEnabled(EnumPlayerModelParts modelPart, boolean enable) {
+      if (enable) {
+         this.setModelParts.add(modelPart);
+      } else {
+         this.setModelParts.remove(modelPart);
+      }
+
+      this.sendSettingsToServer();
+   }
+
+   public void switchModelPartEnabled(EnumPlayerModelParts modelPart) {
+      if (this.getModelParts().contains(modelPart)) {
+         this.setModelParts.remove(modelPart);
+      } else {
+         this.setModelParts.add(modelPart);
+      }
+
+      this.sendSettingsToServer();
+   }
+
+   public int shouldRenderClouds() {
+      return this.renderDistanceChunks >= 4 ? this.clouds : 0;
+   }
+
+   public boolean isUsingNativeTransport() {
+      return this.useNativeTransport;
+   }
+
+   private void setOptionFloatValueOF(GameSettings.Options option, float val) {
+      if (option == GameSettings.Options.CLOUD_HEIGHT) {
+         this.ofCloudsHeight = val;
+         this.mc.renderGlobal.resetClouds();
+      }
+
+      if (option == GameSettings.Options.AO_LEVEL) {
+         this.ofAoLevel = val;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (option == GameSettings.Options.AA_LEVEL) {
+         int valInt = (int)val;
+         if (valInt > 0 && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.aa.shaders1"), Lang.get("of.message.aa.shaders2"));
+            return;
+         }
+
+         int[] aaLevels = new int[]{0, 2, 4, 6, 8, 12, 16};
+         this.ofAaLevel = 0;
+
+         for (int l = 0; l < aaLevels.length; l++) {
+            if (valInt >= aaLevels[l]) {
+               this.ofAaLevel = aaLevels[l];
             }
-         } else if (☃ == GameSettings.Options.SATURATION) {
-            return ☃ + (int)(☃xx * 400.0F) + "%";
-         } else if (☃ == GameSettings.Options.CHAT_OPACITY) {
-            return ☃ + (int)(☃xx * 90.0F + 10.0F) + "%";
-         } else if (☃ == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
-            return ☃ + GuiNewChat.calculateChatboxHeight(☃xx) + "px";
-         } else if (☃ == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
-            return ☃ + GuiNewChat.calculateChatboxHeight(☃xx) + "px";
-         } else if (☃ == GameSettings.Options.CHAT_WIDTH) {
-            return ☃ + GuiNewChat.calculateChatboxWidth(☃xx) + "px";
-         } else if (☃ == GameSettings.Options.RENDER_DISTANCE) {
-            return ☃ + I18n.format("options.chunks", (int)☃x);
-         } else if (☃ == GameSettings.Options.MIPMAP_LEVELS) {
-            return ☃x == 0.0F ? ☃ + I18n.format("options.off") : ☃ + (int)☃x;
+         }
+
+         this.ofAaLevel = Config.limit(this.ofAaLevel, 0, 16);
+      }
+
+      if (option == GameSettings.Options.AF_LEVEL) {
+         int valInt = (int)val;
+         if (valInt > 1 && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.af.shaders1"), Lang.get("of.message.af.shaders2"));
+            return;
+         }
+
+         this.ofAfLevel = 1;
+
+         while (this.ofAfLevel * 2 <= valInt) {
+            this.ofAfLevel *= 2;
+         }
+
+         this.ofAfLevel = Config.limit(this.ofAfLevel, 1, 16);
+         this.mc.refreshResources();
+      }
+
+      if (option == GameSettings.Options.MIPMAP_TYPE) {
+         int valInt = (int)val;
+         this.ofMipmapType = Config.limit(valInt, 0, 3);
+         this.mc.refreshResources();
+      }
+
+      if (option == GameSettings.Options.FULLSCREEN_MODE) {
+         int index = (int)val - 1;
+         String[] modeNames = Config.getDisplayModeNames();
+         if (index < 0 || index >= modeNames.length) {
+            this.ofFullscreenMode = "Default";
+            return;
+         }
+
+         this.ofFullscreenMode = modeNames[index];
+      }
+   }
+
+   private float getOptionFloatValueOF(GameSettings.Options settingOption) {
+      if (settingOption == GameSettings.Options.CLOUD_HEIGHT) {
+         return this.ofCloudsHeight;
+      } else if (settingOption == GameSettings.Options.AO_LEVEL) {
+         return this.ofAoLevel;
+      } else if (settingOption == GameSettings.Options.AA_LEVEL) {
+         return this.ofAaLevel;
+      } else if (settingOption == GameSettings.Options.AF_LEVEL) {
+         return this.ofAfLevel;
+      } else if (settingOption == GameSettings.Options.MIPMAP_TYPE) {
+         return this.ofMipmapType;
+      } else if (settingOption == GameSettings.Options.FRAMERATE_LIMIT) {
+         return this.limitFramerate == GameSettings.Options.FRAMERATE_LIMIT.getValueMax() && this.enableVsync ? 0.0F : this.limitFramerate;
+      } else if (settingOption == GameSettings.Options.FULLSCREEN_MODE) {
+         if (this.ofFullscreenMode.equals("Default")) {
+            return 0.0F;
          } else {
-            return ☃xx == 0.0F ? ☃ + I18n.format("options.off") : ☃ + (int)(☃xx * 100.0F) + "%";
-         }
-      } else if (☃.isBoolean()) {
-         boolean ☃x = this.getOptionOrdinalValue(☃);
-         return ☃x ? ☃ + I18n.format("options.on") : ☃ + I18n.format("options.off");
-      } else if (☃ == GameSettings.Options.MAIN_HAND) {
-         return ☃ + this.mainHand;
-      } else if (☃ == GameSettings.Options.GUI_SCALE) {
-         return ☃ + getTranslation(GUISCALES, this.guiScale);
-      } else if (☃ == GameSettings.Options.CHAT_VISIBILITY) {
-         return ☃ + I18n.format(this.chatVisibility.getResourceKey());
-      } else if (☃ == GameSettings.Options.PARTICLES) {
-         return ☃ + getTranslation(PARTICLES, this.particleSetting);
-      } else if (☃ == GameSettings.Options.AMBIENT_OCCLUSION) {
-         return ☃ + getTranslation(AMBIENT_OCCLUSIONS, this.ambientOcclusion);
-      } else if (☃ == GameSettings.Options.RENDER_CLOUDS) {
-         return ☃ + getTranslation(CLOUDS_TYPES, this.clouds);
-      } else if (☃ == GameSettings.Options.GRAPHICS) {
-         if (this.fancyGraphics) {
-            return ☃ + I18n.format("options.graphics.fancy");
+            List modeList = Arrays.asList(Config.getDisplayModeNames());
+            int index = modeList.indexOf(this.ofFullscreenMode);
+            return index < 0 ? 0.0F : index + 1;
+         }
+      } else {
+         return Float.MAX_VALUE;
+      }
+   }
+
+   private void setOptionValueOF(GameSettings.Options par1EnumOptions, int par2) {
+      if (par1EnumOptions == GameSettings.Options.FOG_FANCY) {
+         switch (this.ofFogType) {
+            case 1:
+               this.ofFogType = 2;
+               if (!Config.isFancyFogAvailable()) {
+                  this.ofFogType = 3;
+               }
+               break;
+            case 2:
+               this.ofFogType = 3;
+               break;
+            case 3:
+               this.ofFogType = 1;
+               break;
+            default:
+               this.ofFogType = 1;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.FOG_START) {
+         this.ofFogStart += 0.2F;
+         if (this.ofFogStart > 0.81F) {
+            this.ofFogStart = 0.2F;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SMOOTH_FPS) {
+         this.ofSmoothFps = !this.ofSmoothFps;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SMOOTH_WORLD) {
+         this.ofSmoothWorld = !this.ofSmoothWorld;
+         Config.updateThreadPriorities();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CLOUDS) {
+         this.ofClouds++;
+         if (this.ofClouds > 3) {
+            this.ofClouds = 0;
+         }
+
+         this.updateRenderClouds();
+         this.mc.renderGlobal.resetClouds();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.TREES) {
+         this.ofTrees = nextValue(this.ofTrees, OF_TREES_VALUES);
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.DROPPED_ITEMS) {
+         this.ofDroppedItems++;
+         if (this.ofDroppedItems > 2) {
+            this.ofDroppedItems = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.RAIN) {
+         this.ofRain++;
+         if (this.ofRain > 3) {
+            this.ofRain = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_WATER) {
+         this.ofAnimatedWater++;
+         if (this.ofAnimatedWater == 1) {
+            this.ofAnimatedWater++;
+         }
+
+         if (this.ofAnimatedWater > 2) {
+            this.ofAnimatedWater = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_LAVA) {
+         this.ofAnimatedLava++;
+         if (this.ofAnimatedLava == 1) {
+            this.ofAnimatedLava++;
+         }
+
+         if (this.ofAnimatedLava > 2) {
+            this.ofAnimatedLava = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_FIRE) {
+         this.ofAnimatedFire = !this.ofAnimatedFire;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_PORTAL) {
+         this.ofAnimatedPortal = !this.ofAnimatedPortal;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_REDSTONE) {
+         this.ofAnimatedRedstone = !this.ofAnimatedRedstone;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_EXPLOSION) {
+         this.ofAnimatedExplosion = !this.ofAnimatedExplosion;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_FLAME) {
+         this.ofAnimatedFlame = !this.ofAnimatedFlame;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_SMOKE) {
+         this.ofAnimatedSmoke = !this.ofAnimatedSmoke;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.VOID_PARTICLES) {
+         this.ofVoidParticles = !this.ofVoidParticles;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.WATER_PARTICLES) {
+         this.ofWaterParticles = !this.ofWaterParticles;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.PORTAL_PARTICLES) {
+         this.ofPortalParticles = !this.ofPortalParticles;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.POTION_PARTICLES) {
+         this.ofPotionParticles = !this.ofPotionParticles;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.FIREWORK_PARTICLES) {
+         this.ofFireworkParticles = !this.ofFireworkParticles;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.DRIPPING_WATER_LAVA) {
+         this.ofDrippingWaterLava = !this.ofDrippingWaterLava;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_TERRAIN) {
+         this.ofAnimatedTerrain = !this.ofAnimatedTerrain;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ANIMATED_TEXTURES) {
+         this.ofAnimatedTextures = !this.ofAnimatedTextures;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.RAIN_SPLASH) {
+         this.ofRainSplash = !this.ofRainSplash;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.LAGOMETER) {
+         this.ofLagometer = !this.ofLagometer;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SHOW_FPS) {
+         this.ofShowFps = !this.ofShowFps;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.AUTOSAVE_TICKS) {
+         int step = 900;
+         this.ofAutoSaveTicks = Math.max(this.ofAutoSaveTicks / step * step, step);
+         this.ofAutoSaveTicks *= 2;
+         if (this.ofAutoSaveTicks > 32 * step) {
+            this.ofAutoSaveTicks = step;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.BETTER_GRASS) {
+         this.ofBetterGrass++;
+         if (this.ofBetterGrass > 3) {
+            this.ofBetterGrass = 1;
+         }
+
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CONNECTED_TEXTURES) {
+         this.ofConnectedTextures++;
+         if (this.ofConnectedTextures > 3) {
+            this.ofConnectedTextures = 1;
+         }
+
+         if (this.ofConnectedTextures == 2) {
+            this.mc.renderGlobal.loadRenderers();
          } else {
-            String ☃x = "options.graphics.fast";
-            return ☃ + I18n.format("options.graphics.fast");
+            this.mc.refreshResources();
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.WEATHER) {
+         this.ofWeather = !this.ofWeather;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SKY) {
+         this.ofSky = !this.ofSky;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.STARS) {
+         this.ofStars = !this.ofStars;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SUN_MOON) {
+         this.ofSunMoon = !this.ofSunMoon;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.VIGNETTE) {
+         this.ofVignette++;
+         if (this.ofVignette > 2) {
+            this.ofVignette = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CHUNK_UPDATES) {
+         this.ofChunkUpdates++;
+         if (this.ofChunkUpdates > 5) {
+            this.ofChunkUpdates = 1;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CHUNK_UPDATES_DYNAMIC) {
+         this.ofChunkUpdatesDynamic = !this.ofChunkUpdatesDynamic;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.TIME) {
+         this.ofTime++;
+         if (this.ofTime > 2) {
+            this.ofTime = 0;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CLEAR_WATER) {
+         this.ofClearWater = !this.ofClearWater;
+         this.updateWaterOpacity();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.PROFILER) {
+         this.ofProfiler = !this.ofProfiler;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.BETTER_SNOW) {
+         this.ofBetterSnow = !this.ofBetterSnow;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SWAMP_COLORS) {
+         this.ofSwampColors = !this.ofSwampColors;
+         CustomColors.updateUseDefaultGrassFoliageColors();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.RANDOM_ENTITIES) {
+         this.ofRandomEntities = !this.ofRandomEntities;
+         RandomEntities.update();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SMOOTH_BIOMES) {
+         this.ofSmoothBiomes = !this.ofSmoothBiomes;
+         CustomColors.updateUseDefaultGrassFoliageColors();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_FONTS) {
+         this.ofCustomFonts = !this.ofCustomFonts;
+         this.mc.fontRenderer.onResourceManagerReload(Config.getResourceManager());
+         this.mc.standardGalacticFontRenderer.onResourceManagerReload(Config.getResourceManager());
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_COLORS) {
+         this.ofCustomColors = !this.ofCustomColors;
+         CustomColors.update();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_ITEMS) {
+         this.ofCustomItems = !this.ofCustomItems;
+         this.mc.refreshResources();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_SKY) {
+         this.ofCustomSky = !this.ofCustomSky;
+         CustomSky.update();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SHOW_CAPES) {
+         this.ofShowCapes = !this.ofShowCapes;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.NATURAL_TEXTURES) {
+         this.ofNaturalTextures = !this.ofNaturalTextures;
+         NaturalTextures.update();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.EMISSIVE_TEXTURES) {
+         this.ofEmissiveTextures = !this.ofEmissiveTextures;
+         this.mc.refreshResources();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.FAST_MATH) {
+         this.ofFastMath = !this.ofFastMath;
+         MathHelper.fastMath = this.ofFastMath;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.FAST_RENDER) {
+         if (!this.ofFastRender && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.fr.shaders1"), Lang.get("of.message.fr.shaders2"));
+            return;
+         }
+
+         this.ofFastRender = !this.ofFastRender;
+         if (this.ofFastRender) {
+            this.mc.entityRenderer.stopUseShader();
+         }
+
+         Config.updateFramebufferSize();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.TRANSLUCENT_BLOCKS) {
+         if (this.ofTranslucentBlocks == 0) {
+            this.ofTranslucentBlocks = 1;
+         } else if (this.ofTranslucentBlocks == 1) {
+            this.ofTranslucentBlocks = 2;
+         } else if (this.ofTranslucentBlocks == 2) {
+            this.ofTranslucentBlocks = 0;
+         } else {
+            this.ofTranslucentBlocks = 0;
+         }
+
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.LAZY_CHUNK_LOADING) {
+         this.ofLazyChunkLoading = !this.ofLazyChunkLoading;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.RENDER_REGIONS) {
+         this.ofRenderRegions = !this.ofRenderRegions;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SMART_ANIMATIONS) {
+         this.ofSmartAnimations = !this.ofSmartAnimations;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.DYNAMIC_FOV) {
+         this.ofDynamicFov = !this.ofDynamicFov;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ALTERNATE_BLOCKS) {
+         this.ofAlternateBlocks = !this.ofAlternateBlocks;
+         this.mc.refreshResources();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.DYNAMIC_LIGHTS) {
+         this.ofDynamicLights = nextValue(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+         DynamicLights.removeLights(this.mc.renderGlobal);
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SCREENSHOT_SIZE) {
+         this.ofScreenshotSize++;
+         if (this.ofScreenshotSize > 4) {
+            this.ofScreenshotSize = 1;
+         }
+
+         if (!OpenGlHelper.isFramebufferEnabled()) {
+            this.ofScreenshotSize = 1;
+         }
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_ENTITY_MODELS) {
+         this.ofCustomEntityModels = !this.ofCustomEntityModels;
+         this.mc.refreshResources();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.CUSTOM_GUIS) {
+         this.ofCustomGuis = !this.ofCustomGuis;
+         CustomGuis.update();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.SHOW_GL_ERRORS) {
+         this.ofShowGlErrors = !this.ofShowGlErrors;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.HELD_ITEM_TOOLTIPS) {
+         this.heldItemTooltips = !this.heldItemTooltips;
+      }
+
+      if (par1EnumOptions == GameSettings.Options.ADVANCED_TOOLTIPS) {
+         this.advancedItemTooltips = !this.advancedItemTooltips;
+      }
+   }
+
+   private String getKeyBindingOF(GameSettings.Options par1EnumOptions) {
+      String var2 = I18n.format(par1EnumOptions.getTranslation()) + ": ";
+      if (var2 == null) {
+         var2 = par1EnumOptions.getTranslation();
+      }
+
+      if (par1EnumOptions == GameSettings.Options.RENDER_DISTANCE) {
+         int distChunks = (int)this.getOptionFloatValue(par1EnumOptions);
+         String str = I18n.format("of.options.renderDistance.tiny");
+         int baseDist = 2;
+         if (distChunks >= 4) {
+            str = I18n.format("of.options.renderDistance.short");
+            baseDist = 4;
+         }
+
+         if (distChunks >= 8) {
+            str = I18n.format("of.options.renderDistance.normal");
+            baseDist = 8;
+         }
+
+         if (distChunks >= 16) {
+            str = I18n.format("of.options.renderDistance.far");
+            baseDist = 16;
+         }
+
+         if (distChunks >= 32) {
+            str = Lang.get("of.options.renderDistance.extreme");
+            baseDist = 32;
+         }
+
+         if (distChunks >= 48) {
+            str = Lang.get("of.options.renderDistance.insane");
+            baseDist = 48;
+         }
+
+         if (distChunks >= 64) {
+            str = Lang.get("of.options.renderDistance.ludicrous");
+            baseDist = 64;
+         }
+
+         int diff = this.renderDistanceChunks - baseDist;
+         String descr = str;
+         if (diff > 0) {
+            descr = str + "+";
+         }
+
+         return var2 + distChunks + " " + descr + "";
+      } else if (par1EnumOptions == GameSettings.Options.FOG_FANCY) {
+         switch (this.ofFogType) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.FOG_START) {
+         return var2 + this.ofFogStart;
+      } else if (par1EnumOptions == GameSettings.Options.MIPMAP_TYPE) {
+         switch (this.ofMipmapType) {
+            case 0:
+               return var2 + Lang.get("of.options.mipmap.nearest");
+            case 1:
+               return var2 + Lang.get("of.options.mipmap.linear");
+            case 2:
+               return var2 + Lang.get("of.options.mipmap.bilinear");
+            case 3:
+               return var2 + Lang.get("of.options.mipmap.trilinear");
+            default:
+               return var2 + "of.options.mipmap.nearest";
+         }
+      } else if (par1EnumOptions == GameSettings.Options.SMOOTH_FPS) {
+         return this.ofSmoothFps ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SMOOTH_WORLD) {
+         return this.ofSmoothWorld ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CLOUDS) {
+         switch (this.ofClouds) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.TREES) {
+         switch (this.ofTrees) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+            default:
+               return var2 + Lang.getDefault();
+            case 4:
+               return var2 + Lang.get("of.general.smart");
+         }
+      } else if (par1EnumOptions == GameSettings.Options.DROPPED_ITEMS) {
+         switch (this.ofDroppedItems) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.RAIN) {
+         switch (this.ofRain) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_WATER) {
+         switch (this.ofAnimatedWater) {
+            case 1:
+               return var2 + Lang.get("of.options.animation.dynamic");
+            case 2:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOn();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_LAVA) {
+         switch (this.ofAnimatedLava) {
+            case 1:
+               return var2 + Lang.get("of.options.animation.dynamic");
+            case 2:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOn();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_FIRE) {
+         return this.ofAnimatedFire ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_PORTAL) {
+         return this.ofAnimatedPortal ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_REDSTONE) {
+         return this.ofAnimatedRedstone ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_EXPLOSION) {
+         return this.ofAnimatedExplosion ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_FLAME) {
+         return this.ofAnimatedFlame ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_SMOKE) {
+         return this.ofAnimatedSmoke ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.VOID_PARTICLES) {
+         return this.ofVoidParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.WATER_PARTICLES) {
+         return this.ofWaterParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.PORTAL_PARTICLES) {
+         return this.ofPortalParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.POTION_PARTICLES) {
+         return this.ofPotionParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.FIREWORK_PARTICLES) {
+         return this.ofFireworkParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.DRIPPING_WATER_LAVA) {
+         return this.ofDrippingWaterLava ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_TERRAIN) {
+         return this.ofAnimatedTerrain ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ANIMATED_TEXTURES) {
+         return this.ofAnimatedTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.RAIN_SPLASH) {
+         return this.ofRainSplash ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.LAGOMETER) {
+         return this.ofLagometer ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SHOW_FPS) {
+         return this.ofShowFps ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.AUTOSAVE_TICKS) {
+         int step = 900;
+         if (this.ofAutoSaveTicks <= step) {
+            return var2 + Lang.get("of.options.save.45s");
+         } else if (this.ofAutoSaveTicks <= 2 * step) {
+            return var2 + Lang.get("of.options.save.90s");
+         } else if (this.ofAutoSaveTicks <= 4 * step) {
+            return var2 + Lang.get("of.options.save.3min");
+         } else if (this.ofAutoSaveTicks <= 8 * step) {
+            return var2 + Lang.get("of.options.save.6min");
+         } else {
+            return this.ofAutoSaveTicks <= 16 * step ? var2 + Lang.get("of.options.save.12min") : var2 + Lang.get("of.options.save.24min");
+         }
+      } else if (par1EnumOptions == GameSettings.Options.BETTER_GRASS) {
+         switch (this.ofBetterGrass) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.CONNECTED_TEXTURES) {
+         switch (this.ofConnectedTextures) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.WEATHER) {
+         return this.ofWeather ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SKY) {
+         return this.ofSky ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.STARS) {
+         return this.ofStars ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SUN_MOON) {
+         return this.ofSunMoon ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.VIGNETTE) {
+         switch (this.ofVignette) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.CHUNK_UPDATES) {
+         return var2 + this.ofChunkUpdates;
+      } else if (par1EnumOptions == GameSettings.Options.CHUNK_UPDATES_DYNAMIC) {
+         return this.ofChunkUpdatesDynamic ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.TIME) {
+         if (this.ofTime == 1) {
+            return var2 + Lang.get("of.options.time.dayOnly");
+         } else {
+            return this.ofTime == 2 ? var2 + Lang.get("of.options.time.nightOnly") : var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.CLEAR_WATER) {
+         return this.ofClearWater ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.AA_LEVEL) {
+         String suffix = "";
+         if (this.ofAaLevel != Config.getAntialiasingLevel()) {
+            suffix = " (" + Lang.get("of.general.restart") + ")";
+         }
+
+         return this.ofAaLevel == 0 ? var2 + Lang.getOff() + suffix : var2 + this.ofAaLevel + suffix;
+      } else if (par1EnumOptions == GameSettings.Options.AF_LEVEL) {
+         return this.ofAfLevel == 1 ? var2 + Lang.getOff() : var2 + this.ofAfLevel;
+      } else if (par1EnumOptions == GameSettings.Options.PROFILER) {
+         return this.ofProfiler ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.BETTER_SNOW) {
+         return this.ofBetterSnow ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SWAMP_COLORS) {
+         return this.ofSwampColors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.RANDOM_ENTITIES) {
+         return this.ofRandomEntities ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SMOOTH_BIOMES) {
+         return this.ofSmoothBiomes ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_FONTS) {
+         return this.ofCustomFonts ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_COLORS) {
+         return this.ofCustomColors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_SKY) {
+         return this.ofCustomSky ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SHOW_CAPES) {
+         return this.ofShowCapes ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_ITEMS) {
+         return this.ofCustomItems ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.NATURAL_TEXTURES) {
+         return this.ofNaturalTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.EMISSIVE_TEXTURES) {
+         return this.ofEmissiveTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.FAST_MATH) {
+         return this.ofFastMath ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.FAST_RENDER) {
+         return this.ofFastRender ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.TRANSLUCENT_BLOCKS) {
+         if (this.ofTranslucentBlocks == 1) {
+            return var2 + Lang.getFast();
+         } else {
+            return this.ofTranslucentBlocks == 2 ? var2 + Lang.getFancy() : var2 + Lang.getDefault();
+         }
+      } else if (par1EnumOptions == GameSettings.Options.LAZY_CHUNK_LOADING) {
+         return this.ofLazyChunkLoading ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.RENDER_REGIONS) {
+         return this.ofRenderRegions ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SMART_ANIMATIONS) {
+         return this.ofSmartAnimations ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.DYNAMIC_FOV) {
+         return this.ofDynamicFov ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ALTERNATE_BLOCKS) {
+         return this.ofAlternateBlocks ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.DYNAMIC_LIGHTS) {
+         int index = indexOf(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+         return var2 + getTranslation(KEYS_DYNAMIC_LIGHTS, index);
+      } else if (par1EnumOptions == GameSettings.Options.SCREENSHOT_SIZE) {
+         return this.ofScreenshotSize <= 1 ? var2 + Lang.getDefault() : var2 + this.ofScreenshotSize + "x";
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_ENTITY_MODELS) {
+         return this.ofCustomEntityModels ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.CUSTOM_GUIS) {
+         return this.ofCustomGuis ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.SHOW_GL_ERRORS) {
+         return this.ofShowGlErrors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.FULLSCREEN_MODE) {
+         return this.ofFullscreenMode.equals("Default") ? var2 + Lang.getDefault() : var2 + this.ofFullscreenMode;
+      } else if (par1EnumOptions == GameSettings.Options.HELD_ITEM_TOOLTIPS) {
+         return this.heldItemTooltips ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.ADVANCED_TOOLTIPS) {
+         return this.advancedItemTooltips ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (par1EnumOptions == GameSettings.Options.FRAMERATE_LIMIT) {
+         float var6 = this.getOptionFloatValue(par1EnumOptions);
+         if (var6 == 0.0F) {
+            return var2 + Lang.get("of.options.framerateLimit.vsync");
+         } else {
+            return var6 == par1EnumOptions.valueMax ? var2 + I18n.format("options.framerateLimit.max") : var2 + (int)var6 + " fps";
          }
-      } else if (☃ == GameSettings.Options.ATTACK_INDICATOR) {
-         return ☃ + getTranslation(ATTACK_INDICATORS, this.attackIndicator);
-      } else if (☃ == GameSettings.Options.NARRATOR) {
-         return NarratorChatListener.INSTANCE.isActive() ? ☃ + getTranslation(NARRATOR_MODES, this.narrator) : ☃ + I18n.format("options.narrator.notavailable");
       } else {
-         return ☃;
+         return null;
       }
    }
 
-   public void loadOptions() {
+   public void loadOfOptions() {
       try {
-         if (!this.optionsFile.exists()) {
+         File ofReadFile = this.optionsFileOF;
+         if (!ofReadFile.exists()) {
+            ofReadFile = this.optionsFile;
+         }
+
+         if (!ofReadFile.exists()) {
             return;
          }
 
-         this.soundLevels.clear();
-         List<String> ☃ = IOUtils.readLines(new FileInputStream(this.optionsFile));
-         NBTTagCompound ☃x = new NBTTagCompound();
+         BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(new FileInputStream(ofReadFile), StandardCharsets.UTF_8));
+         String s = "";
 
-         for (String ☃xx : ☃) {
+         while ((s = bufferedreader.readLine()) != null) {
             try {
-               Iterator<String> ☃xxx = COLON_SPLITTER.omitEmptyStrings().limit(2).split(☃xx).iterator();
-               ☃x.setString(☃xxx.next(), ☃xxx.next());
-            } catch (Exception var10) {
-               LOGGER.warn("Skipping bad option: {}", ☃xx);
-            }
-         }
+               String[] as = s.split(":");
+               if (as[0].equals("ofRenderDistanceChunks") && as.length >= 2) {
+                  this.renderDistanceChunks = Integer.valueOf(as[1]);
+                  this.renderDistanceChunks = Config.limit(this.renderDistanceChunks, 2, 1024);
+               }
 
-         ☃x = this.dataFix(☃x);
+               if (as[0].equals("ofFogType") && as.length >= 2) {
+                  this.ofFogType = Integer.valueOf(as[1]);
+                  this.ofFogType = Config.limit(this.ofFogType, 1, 3);
+               }
 
-         for (String ☃xx : ☃x.getKeySet()) {
-            String ☃xxx = ☃x.getString(☃xx);
+               if (as[0].equals("ofFogStart") && as.length >= 2) {
+                  this.ofFogStart = Float.valueOf(as[1]);
+                  if (this.ofFogStart < 0.2F) {
+                     this.ofFogStart = 0.2F;
+                  }
 
-            try {
-               if ("mouseSensitivity".equals(☃xx)) {
-                  this.mouseSensitivity = this.parseFloat(☃xxx);
+                  if (this.ofFogStart > 0.81F) {
+                     this.ofFogStart = 0.8F;
+                  }
                }
 
-               if ("fov".equals(☃xx)) {
-                  this.fovSetting = this.parseFloat(☃xxx) * 40.0F + 70.0F;
+               if (as[0].equals("ofMipmapType") && as.length >= 2) {
+                  this.ofMipmapType = Integer.valueOf(as[1]);
+                  this.ofMipmapType = Config.limit(this.ofMipmapType, 0, 3);
                }
 
-               if ("gamma".equals(☃xx)) {
-                  this.gammaSetting = this.parseFloat(☃xxx);
+               if (as[0].equals("ofOcclusionFancy") && as.length >= 2) {
+                  this.ofOcclusionFancy = Boolean.valueOf(as[1]);
                }
 
-               if ("saturation".equals(☃xx)) {
-                  this.saturation = this.parseFloat(☃xxx);
+               if (as[0].equals("ofSmoothFps") && as.length >= 2) {
+                  this.ofSmoothFps = Boolean.valueOf(as[1]);
                }
 
-               if ("invertYMouse".equals(☃xx)) {
-                  this.invertMouse = "true".equals(☃xxx);
+               if (as[0].equals("ofSmoothWorld") && as.length >= 2) {
+                  this.ofSmoothWorld = Boolean.valueOf(as[1]);
                }
 
-               if ("renderDistance".equals(☃xx)) {
-                  this.renderDistanceChunks = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofAoLevel") && as.length >= 2) {
+                  this.ofAoLevel = Float.valueOf(as[1]);
+                  this.ofAoLevel = Config.limit(this.ofAoLevel, 0.0F, 1.0F);
                }
 
-               if ("guiScale".equals(☃xx)) {
-                  this.guiScale = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofClouds") && as.length >= 2) {
+                  this.ofClouds = Integer.valueOf(as[1]);
+                  this.ofClouds = Config.limit(this.ofClouds, 0, 3);
+                  this.updateRenderClouds();
                }
 
-               if ("particles".equals(☃xx)) {
-                  this.particleSetting = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofCloudsHeight") && as.length >= 2) {
+                  this.ofCloudsHeight = Float.valueOf(as[1]);
+                  this.ofCloudsHeight = Config.limit(this.ofCloudsHeight, 0.0F, 1.0F);
                }
 
-               if ("bobView".equals(☃xx)) {
-                  this.viewBobbing = "true".equals(☃xxx);
+               if (as[0].equals("ofTrees") && as.length >= 2) {
+                  this.ofTrees = Integer.valueOf(as[1]);
+                  this.ofTrees = limit(this.ofTrees, OF_TREES_VALUES);
                }
 
-               if ("anaglyph3d".equals(☃xx)) {
-                  this.anaglyph = "true".equals(☃xxx);
+               if (as[0].equals("ofDroppedItems") && as.length >= 2) {
+                  this.ofDroppedItems = Integer.valueOf(as[1]);
+                  this.ofDroppedItems = Config.limit(this.ofDroppedItems, 0, 2);
                }
 
-               if ("maxFps".equals(☃xx)) {
-                  this.limitFramerate = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofRain") && as.length >= 2) {
+                  this.ofRain = Integer.valueOf(as[1]);
+                  this.ofRain = Config.limit(this.ofRain, 0, 3);
                }
 
-               if ("fboEnable".equals(☃xx)) {
-                  this.fboEnable = "true".equals(☃xxx);
+               if (as[0].equals("ofAnimatedWater") && as.length >= 2) {
+                  this.ofAnimatedWater = Integer.valueOf(as[1]);
+                  this.ofAnimatedWater = Config.limit(this.ofAnimatedWater, 0, 2);
                }
 
-               if ("difficulty".equals(☃xx)) {
-                  this.difficulty = EnumDifficulty.byId(Integer.parseInt(☃xxx));
+               if (as[0].equals("ofAnimatedLava") && as.length >= 2) {
+                  this.ofAnimatedLava = Integer.valueOf(as[1]);
+                  this.ofAnimatedLava = Config.limit(this.ofAnimatedLava, 0, 2);
                }
 
-               if ("fancyGraphics".equals(☃xx)) {
-                  this.fancyGraphics = "true".equals(☃xxx);
+               if (as[0].equals("ofAnimatedFire") && as.length >= 2) {
+                  this.ofAnimatedFire = Boolean.valueOf(as[1]);
                }
 
-               if ("tutorialStep".equals(☃xx)) {
-                  this.tutorialStep = TutorialSteps.getTutorial(☃xxx);
+               if (as[0].equals("ofAnimatedPortal") && as.length >= 2) {
+                  this.ofAnimatedPortal = Boolean.valueOf(as[1]);
                }
 
-               if ("ao".equals(☃xx)) {
-                  if ("true".equals(☃xxx)) {
-                     this.ambientOcclusion = 2;
-                  } else if ("false".equals(☃xxx)) {
-                     this.ambientOcclusion = 0;
-                  } else {
-                     this.ambientOcclusion = Integer.parseInt(☃xxx);
-                  }
+               if (as[0].equals("ofAnimatedRedstone") && as.length >= 2) {
+                  this.ofAnimatedRedstone = Boolean.valueOf(as[1]);
                }
 
-               if ("renderClouds".equals(☃xx)) {
-                  if ("true".equals(☃xxx)) {
-                     this.clouds = 2;
-                  } else if ("false".equals(☃xxx)) {
-                     this.clouds = 0;
-                  } else if ("fast".equals(☃xxx)) {
-                     this.clouds = 1;
-                  }
+               if (as[0].equals("ofAnimatedExplosion") && as.length >= 2) {
+                  this.ofAnimatedExplosion = Boolean.valueOf(as[1]);
                }
 
-               if ("attackIndicator".equals(☃xx)) {
-                  if ("0".equals(☃xxx)) {
-                     this.attackIndicator = 0;
-                  } else if ("1".equals(☃xxx)) {
-                     this.attackIndicator = 1;
-                  } else if ("2".equals(☃xxx)) {
-                     this.attackIndicator = 2;
-                  }
+               if (as[0].equals("ofAnimatedFlame") && as.length >= 2) {
+                  this.ofAnimatedFlame = Boolean.valueOf(as[1]);
                }
 
-               if ("resourcePacks".equals(☃xx)) {
-                  this.resourcePacks = JsonUtils.gsonDeserialize(GSON, ☃xxx, TYPE_LIST_STRING);
-                  if (this.resourcePacks == null) {
-                     this.resourcePacks = Lists.newArrayList();
-                  }
+               if (as[0].equals("ofAnimatedSmoke") && as.length >= 2) {
+                  this.ofAnimatedSmoke = Boolean.valueOf(as[1]);
                }
 
-               if ("incompatibleResourcePacks".equals(☃xx)) {
-                  this.incompatibleResourcePacks = JsonUtils.gsonDeserialize(GSON, ☃xxx, TYPE_LIST_STRING);
-                  if (this.incompatibleResourcePacks == null) {
-                     this.incompatibleResourcePacks = Lists.newArrayList();
-                  }
+               if (as[0].equals("ofVoidParticles") && as.length >= 2) {
+                  this.ofVoidParticles = Boolean.valueOf(as[1]);
                }
 
-               if ("lastServer".equals(☃xx)) {
-                  this.lastServer = ☃xxx;
+               if (as[0].equals("ofWaterParticles") && as.length >= 2) {
+                  this.ofWaterParticles = Boolean.valueOf(as[1]);
                }
 
-               if ("lang".equals(☃xx)) {
-                  this.language = ☃xxx;
+               if (as[0].equals("ofPortalParticles") && as.length >= 2) {
+                  this.ofPortalParticles = Boolean.valueOf(as[1]);
                }
 
-               if ("chatVisibility".equals(☃xx)) {
-                  this.chatVisibility = EntityPlayer.EnumChatVisibility.getEnumChatVisibility(Integer.parseInt(☃xxx));
+               if (as[0].equals("ofPotionParticles") && as.length >= 2) {
+                  this.ofPotionParticles = Boolean.valueOf(as[1]);
                }
 
-               if ("chatColors".equals(☃xx)) {
-                  this.chatColours = "true".equals(☃xxx);
+               if (as[0].equals("ofFireworkParticles") && as.length >= 2) {
+                  this.ofFireworkParticles = Boolean.valueOf(as[1]);
                }
 
-               if ("chatLinks".equals(☃xx)) {
-                  this.chatLinks = "true".equals(☃xxx);
+               if (as[0].equals("ofDrippingWaterLava") && as.length >= 2) {
+                  this.ofDrippingWaterLava = Boolean.valueOf(as[1]);
                }
 
-               if ("chatLinksPrompt".equals(☃xx)) {
-                  this.chatLinksPrompt = "true".equals(☃xxx);
+               if (as[0].equals("ofAnimatedTerrain") && as.length >= 2) {
+                  this.ofAnimatedTerrain = Boolean.valueOf(as[1]);
                }
 
-               if ("chatOpacity".equals(☃xx)) {
-                  this.chatOpacity = this.parseFloat(☃xxx);
+               if (as[0].equals("ofAnimatedTextures") && as.length >= 2) {
+                  this.ofAnimatedTextures = Boolean.valueOf(as[1]);
                }
 
-               if ("snooperEnabled".equals(☃xx)) {
-                  this.snooperEnabled = "true".equals(☃xxx);
+               if (as[0].equals("ofRainSplash") && as.length >= 2) {
+                  this.ofRainSplash = Boolean.valueOf(as[1]);
                }
 
-               if ("fullscreen".equals(☃xx)) {
-                  this.fullScreen = "true".equals(☃xxx);
+               if (as[0].equals("ofLagometer") && as.length >= 2) {
+                  this.ofLagometer = Boolean.valueOf(as[1]);
                }
 
-               if ("enableVsync".equals(☃xx)) {
-                  this.enableVsync = "true".equals(☃xxx);
+               if (as[0].equals("ofShowFps") && as.length >= 2) {
+                  this.ofShowFps = Boolean.valueOf(as[1]);
                }
 
-               if ("useVbo".equals(☃xx)) {
-                  this.useVbo = "true".equals(☃xxx);
+               if (as[0].equals("ofAutoSaveTicks") && as.length >= 2) {
+                  this.ofAutoSaveTicks = Integer.valueOf(as[1]);
+                  this.ofAutoSaveTicks = Config.limit(this.ofAutoSaveTicks, 40, 40000);
                }
 
-               if ("hideServerAddress".equals(☃xx)) {
-                  this.hideServerAddress = "true".equals(☃xxx);
+               if (as[0].equals("ofBetterGrass") && as.length >= 2) {
+                  this.ofBetterGrass = Integer.valueOf(as[1]);
+                  this.ofBetterGrass = Config.limit(this.ofBetterGrass, 1, 3);
                }
 
-               if ("advancedItemTooltips".equals(☃xx)) {
-                  this.advancedItemTooltips = "true".equals(☃xxx);
+               if (as[0].equals("ofConnectedTextures") && as.length >= 2) {
+                  this.ofConnectedTextures = Integer.valueOf(as[1]);
+                  this.ofConnectedTextures = Config.limit(this.ofConnectedTextures, 1, 3);
                }
 
-               if ("pauseOnLostFocus".equals(☃xx)) {
-                  this.pauseOnLostFocus = "true".equals(☃xxx);
+               if (as[0].equals("ofWeather") && as.length >= 2) {
+                  this.ofWeather = Boolean.valueOf(as[1]);
                }
 
-               if ("touchscreen".equals(☃xx)) {
-                  this.touchscreen = "true".equals(☃xxx);
+               if (as[0].equals("ofSky") && as.length >= 2) {
+                  this.ofSky = Boolean.valueOf(as[1]);
                }
 
-               if ("overrideHeight".equals(☃xx)) {
-                  this.overrideHeight = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofStars") && as.length >= 2) {
+                  this.ofStars = Boolean.valueOf(as[1]);
                }
 
-               if ("overrideWidth".equals(☃xx)) {
-                  this.overrideWidth = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofSunMoon") && as.length >= 2) {
+                  this.ofSunMoon = Boolean.valueOf(as[1]);
                }
 
-               if ("heldItemTooltips".equals(☃xx)) {
-                  this.heldItemTooltips = "true".equals(☃xxx);
+               if (as[0].equals("ofVignette") && as.length >= 2) {
+                  this.ofVignette = Integer.valueOf(as[1]);
+                  this.ofVignette = Config.limit(this.ofVignette, 0, 2);
                }
 
-               if ("chatHeightFocused".equals(☃xx)) {
-                  this.chatHeightFocused = this.parseFloat(☃xxx);
+               if (as[0].equals("ofChunkUpdates") && as.length >= 2) {
+                  this.ofChunkUpdates = Integer.valueOf(as[1]);
+                  this.ofChunkUpdates = Config.limit(this.ofChunkUpdates, 1, 5);
                }
 
-               if ("chatHeightUnfocused".equals(☃xx)) {
-                  this.chatHeightUnfocused = this.parseFloat(☃xxx);
+               if (as[0].equals("ofChunkUpdatesDynamic") && as.length >= 2) {
+                  this.ofChunkUpdatesDynamic = Boolean.valueOf(as[1]);
                }
 
-               if ("chatScale".equals(☃xx)) {
-                  this.chatScale = this.parseFloat(☃xxx);
+               if (as[0].equals("ofTime") && as.length >= 2) {
+                  this.ofTime = Integer.valueOf(as[1]);
+                  this.ofTime = Config.limit(this.ofTime, 0, 2);
                }
 
-               if ("chatWidth".equals(☃xx)) {
-                  this.chatWidth = this.parseFloat(☃xxx);
+               if (as[0].equals("ofClearWater") && as.length >= 2) {
+                  this.ofClearWater = Boolean.valueOf(as[1]);
+                  this.updateWaterOpacity();
                }
 
-               if ("mipmapLevels".equals(☃xx)) {
-                  this.mipmapLevels = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofAaLevel") && as.length >= 2) {
+                  this.ofAaLevel = Integer.valueOf(as[1]);
+                  this.ofAaLevel = Config.limit(this.ofAaLevel, 0, 16);
                }
 
-               if ("forceUnicodeFont".equals(☃xx)) {
-                  this.forceUnicodeFont = "true".equals(☃xxx);
+               if (as[0].equals("ofAfLevel") && as.length >= 2) {
+                  this.ofAfLevel = Integer.valueOf(as[1]);
+                  this.ofAfLevel = Config.limit(this.ofAfLevel, 1, 16);
                }
 
-               if ("reducedDebugInfo".equals(☃xx)) {
-                  this.reducedDebugInfo = "true".equals(☃xxx);
+               if (as[0].equals("ofProfiler") && as.length >= 2) {
+                  this.ofProfiler = Boolean.valueOf(as[1]);
                }
 
-               if ("useNativeTransport".equals(☃xx)) {
-                  this.useNativeTransport = "true".equals(☃xxx);
+               if (as[0].equals("ofBetterSnow") && as.length >= 2) {
+                  this.ofBetterSnow = Boolean.valueOf(as[1]);
                }
 
-               if ("entityShadows".equals(☃xx)) {
-                  this.entityShadows = "true".equals(☃xxx);
+               if (as[0].equals("ofSwampColors") && as.length >= 2) {
+                  this.ofSwampColors = Boolean.valueOf(as[1]);
                }
 
-               if ("mainHand".equals(☃xx)) {
-                  this.mainHand = "left".equals(☃xxx) ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
+               if (as[0].equals("ofRandomEntities") && as.length >= 2) {
+                  this.ofRandomEntities = Boolean.valueOf(as[1]);
                }
 
-               if ("showSubtitles".equals(☃xx)) {
-                  this.showSubtitles = "true".equals(☃xxx);
+               if (as[0].equals("ofSmoothBiomes") && as.length >= 2) {
+                  this.ofSmoothBiomes = Boolean.valueOf(as[1]);
                }
 
-               if ("realmsNotifications".equals(☃xx)) {
-                  this.realmsNotifications = "true".equals(☃xxx);
+               if (as[0].equals("ofCustomFonts") && as.length >= 2) {
+                  this.ofCustomFonts = Boolean.valueOf(as[1]);
                }
 
-               if ("enableWeakAttacks".equals(☃xx)) {
-                  this.enableWeakAttacks = "true".equals(☃xxx);
+               if (as[0].equals("ofCustomColors") && as.length >= 2) {
+                  this.ofCustomColors = Boolean.valueOf(as[1]);
                }
 
-               if ("autoJump".equals(☃xx)) {
-                  this.autoJump = "true".equals(☃xxx);
+               if (as[0].equals("ofCustomItems") && as.length >= 2) {
+                  this.ofCustomItems = Boolean.valueOf(as[1]);
                }
 
-               if ("narrator".equals(☃xx)) {
-                  this.narrator = Integer.parseInt(☃xxx);
+               if (as[0].equals("ofCustomSky") && as.length >= 2) {
+                  this.ofCustomSky = Boolean.valueOf(as[1]);
                }
 
-               for (KeyBinding ☃xxxx : this.keyBindings) {
-                  if (☃xx.equals("key_" + ☃xxxx.getKeyDescription())) {
-                     ☃xxxx.setKeyCode(Integer.parseInt(☃xxx));
-                  }
+               if (as[0].equals("ofShowCapes") && as.length >= 2) {
+                  this.ofShowCapes = Boolean.valueOf(as[1]);
                }
 
-               for (SoundCategory ☃xxxxx : SoundCategory.values()) {
-                  if (☃xx.equals("soundCategory_" + ☃xxxxx.getName())) {
-                     this.soundLevels.put(☃xxxxx, this.parseFloat(☃xxx));
-                  }
+               if (as[0].equals("ofNaturalTextures") && as.length >= 2) {
+                  this.ofNaturalTextures = Boolean.valueOf(as[1]);
                }
 
-               for (EnumPlayerModelParts ☃xxxxxx : EnumPlayerModelParts.values()) {
-                  if (☃xx.equals("modelPart_" + ☃xxxxxx.getPartName())) {
-                     this.setModelPartEnabled(☃xxxxxx, "true".equals(☃xxx));
-                  }
+               if (as[0].equals("ofEmissiveTextures") && as.length >= 2) {
+                  this.ofEmissiveTextures = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofLazyChunkLoading") && as.length >= 2) {
+                  this.ofLazyChunkLoading = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofRenderRegions") && as.length >= 2) {
+                  this.ofRenderRegions = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofSmartAnimations") && as.length >= 2) {
+                  this.ofSmartAnimations = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofDynamicFov") && as.length >= 2) {
+                  this.ofDynamicFov = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofAlternateBlocks") && as.length >= 2) {
+                  this.ofAlternateBlocks = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofDynamicLights") && as.length >= 2) {
+                  this.ofDynamicLights = Integer.valueOf(as[1]);
+                  this.ofDynamicLights = limit(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+               }
+
+               if (as[0].equals("ofScreenshotSize") && as.length >= 2) {
+                  this.ofScreenshotSize = Integer.valueOf(as[1]);
+                  this.ofScreenshotSize = Config.limit(this.ofScreenshotSize, 1, 4);
                }
-            } catch (Exception var11) {
-               LOGGER.warn("Skipping bad option: {}:{}", ☃xx, ☃xxx);
+
+               if (as[0].equals("ofCustomEntityModels") && as.length >= 2) {
+                  this.ofCustomEntityModels = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofCustomGuis") && as.length >= 2) {
+                  this.ofCustomGuis = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofShowGlErrors") && as.length >= 2) {
+                  this.ofShowGlErrors = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofFullscreenMode") && as.length >= 2) {
+                  this.ofFullscreenMode = as[1];
+               }
+
+               if (as[0].equals("ofFastMath") && as.length >= 2) {
+                  this.ofFastMath = Boolean.valueOf(as[1]);
+                  MathHelper.fastMath = this.ofFastMath;
+               }
+
+               if (as[0].equals("ofFastRender") && as.length >= 2) {
+                  this.ofFastRender = Boolean.valueOf(as[1]);
+               }
+
+               if (as[0].equals("ofTranslucentBlocks") && as.length >= 2) {
+                  this.ofTranslucentBlocks = Integer.valueOf(as[1]);
+                  this.ofTranslucentBlocks = Config.limit(this.ofTranslucentBlocks, 0, 2);
+               }
+
+               if (as[0].equals("key_" + this.ofKeyBindZoom.getKeyDescription())) {
+                  this.ofKeyBindZoom.setKeyCode(Integer.parseInt(as[1]));
+               }
+            } catch (Exception var5) {
+               Config.dbg("Skipping bad option: " + s);
+               var5.printStackTrace();
             }
          }
 
+         KeyUtils.fixKeyConflicts(this.keyBindings, new KeyBinding[]{this.ofKeyBindZoom});
          KeyBinding.resetKeyBindingArrayAndHash();
-      } catch (Exception var12) {
-         LOGGER.error("Failed to load options", var12);
+         bufferedreader.close();
+      } catch (Exception var6) {
+         Config.warn("Failed to load options");
+         var6.printStackTrace();
       }
    }
 
-   private NBTTagCompound dataFix(NBTTagCompound var1) {
-      int ☃ = 0;
-
+   public void saveOfOptions() {
       try {
-         ☃ = Integer.parseInt(☃.getString("version"));
-      } catch (RuntimeException var4) {
+         PrintWriter printwriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFileOF), StandardCharsets.UTF_8));
+         printwriter.println("ofFogType:" + this.ofFogType);
+         printwriter.println("ofFogStart:" + this.ofFogStart);
+         printwriter.println("ofMipmapType:" + this.ofMipmapType);
+         printwriter.println("ofOcclusionFancy:" + this.ofOcclusionFancy);
+         printwriter.println("ofSmoothFps:" + this.ofSmoothFps);
+         printwriter.println("ofSmoothWorld:" + this.ofSmoothWorld);
+         printwriter.println("ofAoLevel:" + this.ofAoLevel);
+         printwriter.println("ofClouds:" + this.ofClouds);
+         printwriter.println("ofCloudsHeight:" + this.ofCloudsHeight);
+         printwriter.println("ofTrees:" + this.ofTrees);
+         printwriter.println("ofDroppedItems:" + this.ofDroppedItems);
+         printwriter.println("ofRain:" + this.ofRain);
+         printwriter.println("ofAnimatedWater:" + this.ofAnimatedWater);
+         printwriter.println("ofAnimatedLava:" + this.ofAnimatedLava);
+         printwriter.println("ofAnimatedFire:" + this.ofAnimatedFire);
+         printwriter.println("ofAnimatedPortal:" + this.ofAnimatedPortal);
+         printwriter.println("ofAnimatedRedstone:" + this.ofAnimatedRedstone);
+         printwriter.println("ofAnimatedExplosion:" + this.ofAnimatedExplosion);
+         printwriter.println("ofAnimatedFlame:" + this.ofAnimatedFlame);
+         printwriter.println("ofAnimatedSmoke:" + this.ofAnimatedSmoke);
+         printwriter.println("ofVoidParticles:" + this.ofVoidParticles);
+         printwriter.println("ofWaterParticles:" + this.ofWaterParticles);
+         printwriter.println("ofPortalParticles:" + this.ofPortalParticles);
+         printwriter.println("ofPotionParticles:" + this.ofPotionParticles);
+         printwriter.println("ofFireworkParticles:" + this.ofFireworkParticles);
+         printwriter.println("ofDrippingWaterLava:" + this.ofDrippingWaterLava);
+         printwriter.println("ofAnimatedTerrain:" + this.ofAnimatedTerrain);
+         printwriter.println("ofAnimatedTextures:" + this.ofAnimatedTextures);
+         printwriter.println("ofRainSplash:" + this.ofRainSplash);
+         printwriter.println("ofLagometer:" + this.ofLagometer);
+         printwriter.println("ofShowFps:" + this.ofShowFps);
+         printwriter.println("ofAutoSaveTicks:" + this.ofAutoSaveTicks);
+         printwriter.println("ofBetterGrass:" + this.ofBetterGrass);
+         printwriter.println("ofConnectedTextures:" + this.ofConnectedTextures);
+         printwriter.println("ofWeather:" + this.ofWeather);
+         printwriter.println("ofSky:" + this.ofSky);
+         printwriter.println("ofStars:" + this.ofStars);
+         printwriter.println("ofSunMoon:" + this.ofSunMoon);
+         printwriter.println("ofVignette:" + this.ofVignette);
+         printwriter.println("ofChunkUpdates:" + this.ofChunkUpdates);
+         printwriter.println("ofChunkUpdatesDynamic:" + this.ofChunkUpdatesDynamic);
+         printwriter.println("ofTime:" + this.ofTime);
+         printwriter.println("ofClearWater:" + this.ofClearWater);
+         printwriter.println("ofAaLevel:" + this.ofAaLevel);
+         printwriter.println("ofAfLevel:" + this.ofAfLevel);
+         printwriter.println("ofProfiler:" + this.ofProfiler);
+         printwriter.println("ofBetterSnow:" + this.ofBetterSnow);
+         printwriter.println("ofSwampColors:" + this.ofSwampColors);
+         printwriter.println("ofRandomEntities:" + this.ofRandomEntities);
+         printwriter.println("ofSmoothBiomes:" + this.ofSmoothBiomes);
+         printwriter.println("ofCustomFonts:" + this.ofCustomFonts);
+         printwriter.println("ofCustomColors:" + this.ofCustomColors);
+         printwriter.println("ofCustomItems:" + this.ofCustomItems);
+         printwriter.println("ofCustomSky:" + this.ofCustomSky);
+         printwriter.println("ofShowCapes:" + this.ofShowCapes);
+         printwriter.println("ofNaturalTextures:" + this.ofNaturalTextures);
+         printwriter.println("ofEmissiveTextures:" + this.ofEmissiveTextures);
+         printwriter.println("ofLazyChunkLoading:" + this.ofLazyChunkLoading);
+         printwriter.println("ofRenderRegions:" + this.ofRenderRegions);
+         printwriter.println("ofSmartAnimations:" + this.ofSmartAnimations);
+         printwriter.println("ofDynamicFov:" + this.ofDynamicFov);
+         printwriter.println("ofAlternateBlocks:" + this.ofAlternateBlocks);
+         printwriter.println("ofDynamicLights:" + this.ofDynamicLights);
+         printwriter.println("ofScreenshotSize:" + this.ofScreenshotSize);
+         printwriter.println("ofCustomEntityModels:" + this.ofCustomEntityModels);
+         printwriter.println("ofCustomGuis:" + this.ofCustomGuis);
+         printwriter.println("ofShowGlErrors:" + this.ofShowGlErrors);
+         printwriter.println("ofFullscreenMode:" + this.ofFullscreenMode);
+         printwriter.println("ofFastMath:" + this.ofFastMath);
+         printwriter.println("ofFastRender:" + this.ofFastRender);
+         printwriter.println("ofTranslucentBlocks:" + this.ofTranslucentBlocks);
+         printwriter.println("key_" + this.ofKeyBindZoom.getKeyDescription() + ":" + this.ofKeyBindZoom.getKeyCode());
+         printwriter.close();
+      } catch (Exception var2) {
+         Config.warn("Failed to save options");
+         var2.printStackTrace();
       }
-
-      return this.mc.getDataFixer().process(FixTypes.OPTIONS, ☃, ☃);
    }
 
-   private float parseFloat(String var1) {
-      if ("true".equals(☃)) {
-         return 1.0F;
-      } else {
-         return "false".equals(☃) ? 0.0F : Float.parseFloat(☃);
+   private void updateRenderClouds() {
+      switch (this.ofClouds) {
+         case 1:
+            this.clouds = 1;
+            break;
+         case 2:
+            this.clouds = 2;
+            break;
+         case 3:
+            this.clouds = 0;
+            break;
+         default:
+            if (this.fancyGraphics) {
+               this.clouds = 2;
+            } else {
+               this.clouds = 1;
+            }
       }
    }
 
-   public void saveOptions() {
-      PrintWriter ☃ = null;
-
-      try {
-         ☃ = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFile), StandardCharsets.UTF_8));
-         ☃.println("version:1343");
-         ☃.println("invertYMouse:" + this.invertMouse);
-         ☃.println("mouseSensitivity:" + this.mouseSensitivity);
-         ☃.println("fov:" + (this.fovSetting - 70.0F) / 40.0F);
-         ☃.println("gamma:" + this.gammaSetting);
-         ☃.println("saturation:" + this.saturation);
-         ☃.println("renderDistance:" + this.renderDistanceChunks);
-         ☃.println("guiScale:" + this.guiScale);
-         ☃.println("particles:" + this.particleSetting);
-         ☃.println("bobView:" + this.viewBobbing);
-         ☃.println("anaglyph3d:" + this.anaglyph);
-         ☃.println("maxFps:" + this.limitFramerate);
-         ☃.println("fboEnable:" + this.fboEnable);
-         ☃.println("difficulty:" + this.difficulty.getId());
-         ☃.println("fancyGraphics:" + this.fancyGraphics);
-         ☃.println("ao:" + this.ambientOcclusion);
-         switch (this.clouds) {
-            case 0:
-               ☃.println("renderClouds:false");
-               break;
-            case 1:
-               ☃.println("renderClouds:fast");
-               break;
-            case 2:
-               ☃.println("renderClouds:true");
-         }
-
-         ☃.println("resourcePacks:" + GSON.toJson(this.resourcePacks));
-         ☃.println("incompatibleResourcePacks:" + GSON.toJson(this.incompatibleResourcePacks));
-         ☃.println("lastServer:" + this.lastServer);
-         ☃.println("lang:" + this.language);
-         ☃.println("chatVisibility:" + this.chatVisibility.getChatVisibility());
-         ☃.println("chatColors:" + this.chatColours);
-         ☃.println("chatLinks:" + this.chatLinks);
-         ☃.println("chatLinksPrompt:" + this.chatLinksPrompt);
-         ☃.println("chatOpacity:" + this.chatOpacity);
-         ☃.println("snooperEnabled:" + this.snooperEnabled);
-         ☃.println("fullscreen:" + this.fullScreen);
-         ☃.println("enableVsync:" + this.enableVsync);
-         ☃.println("useVbo:" + this.useVbo);
-         ☃.println("hideServerAddress:" + this.hideServerAddress);
-         ☃.println("advancedItemTooltips:" + this.advancedItemTooltips);
-         ☃.println("pauseOnLostFocus:" + this.pauseOnLostFocus);
-         ☃.println("touchscreen:" + this.touchscreen);
-         ☃.println("overrideWidth:" + this.overrideWidth);
-         ☃.println("overrideHeight:" + this.overrideHeight);
-         ☃.println("heldItemTooltips:" + this.heldItemTooltips);
-         ☃.println("chatHeightFocused:" + this.chatHeightFocused);
-         ☃.println("chatHeightUnfocused:" + this.chatHeightUnfocused);
-         ☃.println("chatScale:" + this.chatScale);
-         ☃.println("chatWidth:" + this.chatWidth);
-         ☃.println("mipmapLevels:" + this.mipmapLevels);
-         ☃.println("forceUnicodeFont:" + this.forceUnicodeFont);
-         ☃.println("reducedDebugInfo:" + this.reducedDebugInfo);
-         ☃.println("useNativeTransport:" + this.useNativeTransport);
-         ☃.println("entityShadows:" + this.entityShadows);
-         ☃.println("mainHand:" + (this.mainHand == EnumHandSide.LEFT ? "left" : "right"));
-         ☃.println("attackIndicator:" + this.attackIndicator);
-         ☃.println("showSubtitles:" + this.showSubtitles);
-         ☃.println("realmsNotifications:" + this.realmsNotifications);
-         ☃.println("enableWeakAttacks:" + this.enableWeakAttacks);
-         ☃.println("autoJump:" + this.autoJump);
-         ☃.println("narrator:" + this.narrator);
-         ☃.println("tutorialStep:" + this.tutorialStep.getName());
-
-         for (KeyBinding ☃x : this.keyBindings) {
-            ☃.println("key_" + ☃x.getKeyDescription() + ":" + ☃x.getKeyCode());
-         }
-
-         for (SoundCategory ☃x : SoundCategory.values()) {
-            ☃.println("soundCategory_" + ☃x.getName() + ":" + this.getSoundLevel(☃x));
-         }
-
-         for (EnumPlayerModelParts ☃x : EnumPlayerModelParts.values()) {
-            ☃.println("modelPart_" + ☃x.getPartName() + ":" + this.setModelParts.contains(☃x));
-         }
-      } catch (Exception var9) {
-         LOGGER.error("Failed to save options", var9);
-      } finally {
-         IOUtils.closeQuietly(☃);
-      }
-
-      this.sendSettingsToServer();
+   public void resetSettings() {
+      this.renderDistanceChunks = 8;
+      this.viewBobbing = true;
+      this.anaglyph = false;
+      this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+      this.enableVsync = false;
+      this.updateVSync();
+      this.mipmapLevels = 4;
+      this.fancyGraphics = true;
+      this.ambientOcclusion = 2;
+      this.clouds = 2;
+      this.fovSetting = 70.0F;
+      this.gammaSetting = 0.0F;
+      this.guiScale = 0;
+      this.particleSetting = 0;
+      this.heldItemTooltips = true;
+      this.useVbo = false;
+      this.forceUnicodeFont = false;
+      this.ofFogType = 1;
+      this.ofFogStart = 0.8F;
+      this.ofMipmapType = 0;
+      this.ofOcclusionFancy = false;
+      this.ofSmartAnimations = false;
+      this.ofSmoothFps = false;
+      Config.updateAvailableProcessors();
+      this.ofSmoothWorld = Config.isSingleProcessor();
+      this.ofLazyChunkLoading = false;
+      this.ofRenderRegions = false;
+      this.ofFastMath = false;
+      this.ofFastRender = false;
+      this.ofTranslucentBlocks = 0;
+      this.ofDynamicFov = true;
+      this.ofAlternateBlocks = true;
+      this.ofDynamicLights = 3;
+      this.ofScreenshotSize = 1;
+      this.ofCustomEntityModels = true;
+      this.ofCustomGuis = true;
+      this.ofShowGlErrors = true;
+      this.ofAoLevel = 1.0F;
+      this.ofAaLevel = 0;
+      this.ofAfLevel = 1;
+      this.ofClouds = 0;
+      this.ofCloudsHeight = 0.0F;
+      this.ofTrees = 0;
+      this.ofRain = 0;
+      this.ofBetterGrass = 3;
+      this.ofAutoSaveTicks = 4000;
+      this.ofLagometer = false;
+      this.ofShowFps = false;
+      this.ofProfiler = false;
+      this.ofWeather = true;
+      this.ofSky = true;
+      this.ofStars = true;
+      this.ofSunMoon = true;
+      this.ofVignette = 0;
+      this.ofChunkUpdates = 1;
+      this.ofChunkUpdatesDynamic = false;
+      this.ofTime = 0;
+      this.ofClearWater = false;
+      this.ofBetterSnow = false;
+      this.ofFullscreenMode = "Default";
+      this.ofSwampColors = true;
+      this.ofRandomEntities = true;
+      this.ofSmoothBiomes = true;
+      this.ofCustomFonts = true;
+      this.ofCustomColors = true;
+      this.ofCustomItems = true;
+      this.ofCustomSky = true;
+      this.ofShowCapes = true;
+      this.ofConnectedTextures = 2;
+      this.ofNaturalTextures = false;
+      this.ofEmissiveTextures = true;
+      this.ofAnimatedWater = 0;
+      this.ofAnimatedLava = 0;
+      this.ofAnimatedFire = true;
+      this.ofAnimatedPortal = true;
+      this.ofAnimatedRedstone = true;
+      this.ofAnimatedExplosion = true;
+      this.ofAnimatedFlame = true;
+      this.ofAnimatedSmoke = true;
+      this.ofVoidParticles = true;
+      this.ofWaterParticles = true;
+      this.ofRainSplash = true;
+      this.ofPortalParticles = true;
+      this.ofPotionParticles = true;
+      this.ofFireworkParticles = true;
+      this.ofDrippingWaterLava = true;
+      this.ofAnimatedTerrain = true;
+      this.ofAnimatedTextures = true;
+      Shaders.setShaderPack("OFF");
+      Shaders.configAntialiasingLevel = 0;
+      Shaders.uninit();
+      Shaders.storeConfig();
+      this.updateWaterOpacity();
+      this.mc.refreshResources();
+      this.saveOptions();
    }
 
-   public float getSoundLevel(SoundCategory var1) {
-      return this.soundLevels.containsKey(☃) ? this.soundLevels.get(☃) : 1.0F;
+   public void updateVSync() {
+      Display.setVSyncEnabled(this.enableVsync);
    }
 
-   public void setSoundLevel(SoundCategory var1, float var2) {
-      this.mc.getSoundHandler().setSoundLevel(☃, ☃);
-      this.soundLevels.put(☃, ☃);
+   private void updateWaterOpacity() {
+      if (Config.isIntegratedServerRunning()) {
+         Config.waterOpacityChanged = true;
+      }
+
+      ClearWater.updateWaterOpacity(this, this.mc.world);
    }
 
-   public void sendSettingsToServer() {
-      if (this.mc.player != null) {
-         int ☃ = 0;
+   public void setAllAnimations(boolean flag) {
+      int animVal = flag ? 0 : 2;
+      this.ofAnimatedWater = animVal;
+      this.ofAnimatedLava = animVal;
+      this.ofAnimatedFire = flag;
+      this.ofAnimatedPortal = flag;
+      this.ofAnimatedRedstone = flag;
+      this.ofAnimatedExplosion = flag;
+      this.ofAnimatedFlame = flag;
+      this.ofAnimatedSmoke = flag;
+      this.ofVoidParticles = flag;
+      this.ofWaterParticles = flag;
+      this.ofRainSplash = flag;
+      this.ofPortalParticles = flag;
+      this.ofPotionParticles = flag;
+      this.ofFireworkParticles = flag;
+      this.particleSetting = flag ? 0 : 2;
+      this.ofDrippingWaterLava = flag;
+      this.ofAnimatedTerrain = flag;
+      this.ofAnimatedTextures = flag;
+   }
 
-         for (EnumPlayerModelParts ☃x : this.setModelParts) {
-            ☃ |= ☃x.getPartMask();
+   private static int nextValue(int val, int[] vals) {
+      int index = indexOf(val, vals);
+      if (index < 0) {
+         return vals[0];
+      } else {
+         if (++index >= vals.length) {
+            index = 0;
          }
 
-         this.mc
-            .player
-            .connection
-            .sendPacket(new CPacketClientSettings(this.language, this.renderDistanceChunks, this.chatVisibility, this.chatColours, ☃, this.mainHand));
+         return vals[index];
       }
    }
 
-   public Set<EnumPlayerModelParts> getModelParts() {
-      return ImmutableSet.copyOf(this.setModelParts);
+   private static int limit(int val, int[] vals) {
+      int index = indexOf(val, vals);
+      return index < 0 ? vals[0] : val;
    }
 
-   public void setModelPartEnabled(EnumPlayerModelParts var1, boolean var2) {
-      if (☃) {
-         this.setModelParts.add(☃);
-      } else {
-         this.setModelParts.remove(☃);
+   private static int indexOf(int val, int[] vals) {
+      for (int i = 0; i < vals.length; i++) {
+         if (vals[i] == val) {
+            return i;
+         }
       }
 
-      this.sendSettingsToServer();
+      return -1;
    }
 
-   public void switchModelPartEnabled(EnumPlayerModelParts var1) {
-      if (this.getModelParts().contains(☃)) {
-         this.setModelParts.remove(☃);
-      } else {
-         this.setModelParts.add(☃);
+   private void setForgeKeybindProperties() {
+      if (Reflector.KeyConflictContext_IN_GAME.exists()) {
+         if (Reflector.ForgeKeyBinding_setKeyConflictContext.exists()) {
+            Object inGame = Reflector.getFieldValue(Reflector.KeyConflictContext_IN_GAME);
+            Reflector.call(this.keyBindForward, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindLeft, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindBack, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindRight, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindJump, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindSneak, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindSprint, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindAttack, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindChat, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindPlayerList, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindCommand, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindTogglePerspective, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindSmoothCamera, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+            Reflector.call(this.keyBindSwapHands, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{inGame});
+         }
       }
-
-      this.sendSettingsToServer();
    }
 
-   public int shouldRenderClouds() {
-      return this.renderDistanceChunks >= 4 ? this.clouds : 0;
-   }
-
-   public boolean isUsingNativeTransport() {
-      return this.useNativeTransport;
+   public void onGuiClosed() {
+      if (this.needsResourceRefresh) {
+         this.mc.scheduleResourcesRefresh();
+         this.needsResourceRefresh = false;
+      }
    }
 
    public static enum Options {
@@ -1057,7 +2764,7 @@ public static enum Options {
       RENDER_DISTANCE("options.renderDistance", true, false, 2.0F, 16.0F, 1.0F),
       VIEW_BOBBING("options.viewBobbing", false, true),
       ANAGLYPH("options.anaglyph", false, true),
-      FRAMERATE_LIMIT("options.framerateLimit", true, false, 10.0F, 260.0F, 10.0F),
+      FRAMERATE_LIMIT("options.framerateLimit", true, false, 0.0F, 260.0F, 5.0F),
       FBO_ENABLE("options.fboEnable", false, true),
       RENDER_CLOUDS("options.renderClouds", false, false),
       GRAPHICS("options.graphics", false, false),
@@ -1088,7 +2795,79 @@ public static enum Options {
       SHOW_SUBTITLES("options.showSubtitles", false, true),
       REALMS_NOTIFICATIONS("options.realmsNotifications", false, true),
       AUTO_JUMP("options.autoJump", false, true),
-      NARRATOR("options.narrator", false, false);
+      NARRATOR("options.narrator", false, false),
+      FOG_FANCY("of.options.FOG_FANCY", false, false),
+      FOG_START("of.options.FOG_START", false, false),
+      MIPMAP_TYPE("of.options.MIPMAP_TYPE", true, false, 0.0F, 3.0F, 1.0F),
+      SMOOTH_FPS("of.options.SMOOTH_FPS", false, false),
+      CLOUDS("of.options.CLOUDS", false, false),
+      CLOUD_HEIGHT("of.options.CLOUD_HEIGHT", true, false),
+      TREES("of.options.TREES", false, false),
+      RAIN("of.options.RAIN", false, false),
+      ANIMATED_WATER("of.options.ANIMATED_WATER", false, false),
+      ANIMATED_LAVA("of.options.ANIMATED_LAVA", false, false),
+      ANIMATED_FIRE("of.options.ANIMATED_FIRE", false, false),
+      ANIMATED_PORTAL("of.options.ANIMATED_PORTAL", false, false),
+      AO_LEVEL("of.options.AO_LEVEL", true, false),
+      LAGOMETER("of.options.LAGOMETER", false, false),
+      SHOW_FPS("of.options.SHOW_FPS", false, false),
+      AUTOSAVE_TICKS("of.options.AUTOSAVE_TICKS", false, false),
+      BETTER_GRASS("of.options.BETTER_GRASS", false, false),
+      ANIMATED_REDSTONE("of.options.ANIMATED_REDSTONE", false, false),
+      ANIMATED_EXPLOSION("of.options.ANIMATED_EXPLOSION", false, false),
+      ANIMATED_FLAME("of.options.ANIMATED_FLAME", false, false),
+      ANIMATED_SMOKE("of.options.ANIMATED_SMOKE", false, false),
+      WEATHER("of.options.WEATHER", false, false),
+      SKY("of.options.SKY", false, false),
+      STARS("of.options.STARS", false, false),
+      SUN_MOON("of.options.SUN_MOON", false, false),
+      VIGNETTE("of.options.VIGNETTE", false, false),
+      CHUNK_UPDATES("of.options.CHUNK_UPDATES", false, false),
+      CHUNK_UPDATES_DYNAMIC("of.options.CHUNK_UPDATES_DYNAMIC", false, false),
+      TIME("of.options.TIME", false, false),
+      CLEAR_WATER("of.options.CLEAR_WATER", false, false),
+      SMOOTH_WORLD("of.options.SMOOTH_WORLD", false, false),
+      VOID_PARTICLES("of.options.VOID_PARTICLES", false, false),
+      WATER_PARTICLES("of.options.WATER_PARTICLES", false, false),
+      RAIN_SPLASH("of.options.RAIN_SPLASH", false, false),
+      PORTAL_PARTICLES("of.options.PORTAL_PARTICLES", false, false),
+      POTION_PARTICLES("of.options.POTION_PARTICLES", false, false),
+      FIREWORK_PARTICLES("of.options.FIREWORK_PARTICLES", false, false),
+      PROFILER("of.options.PROFILER", false, false),
+      DRIPPING_WATER_LAVA("of.options.DRIPPING_WATER_LAVA", false, false),
+      BETTER_SNOW("of.options.BETTER_SNOW", false, false),
+      FULLSCREEN_MODE("of.options.FULLSCREEN_MODE", true, false, 0.0F, Config.getDisplayModes().length, 1.0F),
+      ANIMATED_TERRAIN("of.options.ANIMATED_TERRAIN", false, false),
+      SWAMP_COLORS("of.options.SWAMP_COLORS", false, false),
+      RANDOM_ENTITIES("of.options.RANDOM_ENTITIES", false, false),
+      SMOOTH_BIOMES("of.options.SMOOTH_BIOMES", false, false),
+      CUSTOM_FONTS("of.options.CUSTOM_FONTS", false, false),
+      CUSTOM_COLORS("of.options.CUSTOM_COLORS", false, false),
+      SHOW_CAPES("of.options.SHOW_CAPES", false, false),
+      CONNECTED_TEXTURES("of.options.CONNECTED_TEXTURES", false, false),
+      CUSTOM_ITEMS("of.options.CUSTOM_ITEMS", false, false),
+      AA_LEVEL("of.options.AA_LEVEL", true, false, 0.0F, 16.0F, 1.0F),
+      AF_LEVEL("of.options.AF_LEVEL", true, false, 1.0F, 16.0F, 1.0F),
+      ANIMATED_TEXTURES("of.options.ANIMATED_TEXTURES", false, false),
+      NATURAL_TEXTURES("of.options.NATURAL_TEXTURES", false, false),
+      EMISSIVE_TEXTURES("of.options.EMISSIVE_TEXTURES", false, false),
+      HELD_ITEM_TOOLTIPS("of.options.HELD_ITEM_TOOLTIPS", false, false),
+      DROPPED_ITEMS("of.options.DROPPED_ITEMS", false, false),
+      LAZY_CHUNK_LOADING("of.options.LAZY_CHUNK_LOADING", false, false),
+      CUSTOM_SKY("of.options.CUSTOM_SKY", false, false),
+      FAST_MATH("of.options.FAST_MATH", false, false),
+      FAST_RENDER("of.options.FAST_RENDER", false, false),
+      TRANSLUCENT_BLOCKS("of.options.TRANSLUCENT_BLOCKS", false, false),
+      DYNAMIC_FOV("of.options.DYNAMIC_FOV", false, false),
+      DYNAMIC_LIGHTS("of.options.DYNAMIC_LIGHTS", false, false),
+      ALTERNATE_BLOCKS("of.options.ALTERNATE_BLOCKS", false, false),
+      CUSTOM_ENTITY_MODELS("of.options.CUSTOM_ENTITY_MODELS", false, false),
+      ADVANCED_TOOLTIPS("of.options.ADVANCED_TOOLTIPS", false, false),
+      SCREENSHOT_SIZE("of.options.SCREENSHOT_SIZE", false, false),
+      CUSTOM_GUIS("of.options.CUSTOM_GUIS", false, false),
+      RENDER_REGIONS("of.options.RENDER_REGIONS", false, false),
+      SHOW_GL_ERRORS("of.options.SHOW_GL_ERRORS", false, false),
+      SMART_ANIMATIONS("of.options.SMART_ANIMATIONS", false, false);
 
       private final boolean isFloat;
       private final boolean isBoolean;
@@ -1097,27 +2876,27 @@ public static enum Options {
       private float valueMin;
       private float valueMax;
 
-      public static GameSettings.Options byOrdinal(int var0) {
-         for (GameSettings.Options ☃ : values()) {
-            if (☃.getOrdinal() == ☃) {
-               return ☃;
+      public static GameSettings.Options byOrdinal(int ordinal) {
+         for (GameSettings.Options gamesettings$options : values()) {
+            if (gamesettings$options.getOrdinal() == ordinal) {
+               return gamesettings$options;
             }
          }
 
          return null;
       }
 
-      private Options(String var3, boolean var4, boolean var5) {
-         this(☃, ☃, ☃, 0.0F, 1.0F, 0.0F);
+      private Options(String str, boolean isFloat, boolean isBoolean) {
+         this(str, isFloat, isBoolean, 0.0F, 1.0F, 0.0F);
       }
 
-      private Options(String var3, boolean var4, boolean var5, float var6, float var7, float var8) {
-         this.translation = ☃;
-         this.isFloat = ☃;
-         this.isBoolean = ☃;
-         this.valueMin = ☃;
-         this.valueMax = ☃;
-         this.valueStep = ☃;
+      private Options(String str, boolean isFloat, boolean isBoolean, float valMin, float valMax, float valStep) {
+         this.translation = str;
+         this.isFloat = isFloat;
+         this.isBoolean = isBoolean;
+         this.valueMin = valMin;
+         this.valueMax = valMax;
+         this.valueStep = valStep;
       }
 
       public boolean isFloat() {
@@ -1144,29 +2923,29 @@ public float getValueMax() {
          return this.valueMax;
       }
 
-      public void setValueMax(float var1) {
-         this.valueMax = ☃;
+      public void setValueMax(float value) {
+         this.valueMax = value;
       }
 
-      public float normalizeValue(float var1) {
-         return MathHelper.clamp((this.snapToStepClamp(☃) - this.valueMin) / (this.valueMax - this.valueMin), 0.0F, 1.0F);
+      public float normalizeValue(float value) {
+         return MathHelper.clamp((this.snapToStepClamp(value) - this.valueMin) / (this.valueMax - this.valueMin), 0.0F, 1.0F);
       }
 
-      public float denormalizeValue(float var1) {
-         return this.snapToStepClamp(this.valueMin + (this.valueMax - this.valueMin) * MathHelper.clamp(☃, 0.0F, 1.0F));
+      public float denormalizeValue(float value) {
+         return this.snapToStepClamp(this.valueMin + (this.valueMax - this.valueMin) * MathHelper.clamp(value, 0.0F, 1.0F));
       }
 
-      public float snapToStepClamp(float var1) {
-         ☃ = this.snapToStep(☃);
-         return MathHelper.clamp(☃, this.valueMin, this.valueMax);
+      public float snapToStepClamp(float value) {
+         value = this.snapToStep(value);
+         return MathHelper.clamp(value, this.valueMin, this.valueMax);
       }
 
-      private float snapToStep(float var1) {
+      private float snapToStep(float value) {
          if (this.valueStep > 0.0F) {
-            ☃ = this.valueStep * Math.round(☃ / this.valueStep);
+            value = this.valueStep * Math.round(value / this.valueStep);
          }
 
-         return ☃;
+         return value;
       }
    }
 }
diff --git a/patches/net/minecraft/crash/CrashReport.java b/patches/net/minecraft/crash/CrashReport.java
index 7403b9e..92496ac 100644
--- a/patches/net/minecraft/crash/CrashReport.java
+++ b/patches/net/minecraft/crash/CrashReport.java
@@ -15,6 +15,8 @@
 import java.util.List;
 import net.minecraft.util.ReportedException;
 import net.minecraft.world.gen.layer.IntCache;
+import net.optifine.CrashReporter;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -29,10 +31,11 @@ public class CrashReport {
    private File crashReportFile;
    private boolean firstCategoryInCrashReport = true;
    private StackTraceElement[] stacktrace = new StackTraceElement[0];
+   private boolean reported = false;
 
-   public CrashReport(String var1, Throwable var2) {
-      this.description = ☃;
-      this.cause = ☃;
+   public CrashReport(String descriptionIn, Throwable causeThrowable) {
+      this.description = descriptionIn;
+      this.cause = causeThrowable;
       this.populateEnvironment();
    }
 
@@ -59,34 +62,34 @@ public String call() {
       });
       this.systemDetailsCategory.addDetail("Memory", new ICrashReportDetail<String>() {
          public String call() {
-            Runtime ☃ = Runtime.getRuntime();
-            long ☃x = ☃.maxMemory();
-            long ☃xx = ☃.totalMemory();
-            long ☃xxx = ☃.freeMemory();
-            long ☃xxxx = ☃x / 1024L / 1024L;
-            long ☃xxxxx = ☃xx / 1024L / 1024L;
-            long ☃xxxxxx = ☃xxx / 1024L / 1024L;
-            return ☃xxx + " bytes (" + ☃xxxxxx + " MB) / " + ☃xx + " bytes (" + ☃xxxxx + " MB) up to " + ☃x + " bytes (" + ☃xxxx + " MB)";
+            Runtime runtime = Runtime.getRuntime();
+            long i = runtime.maxMemory();
+            long j = runtime.totalMemory();
+            long k = runtime.freeMemory();
+            long l = i / 1024L / 1024L;
+            long i1 = j / 1024L / 1024L;
+            long j1 = k / 1024L / 1024L;
+            return k + " bytes (" + j1 + " MB) / " + j + " bytes (" + i1 + " MB) up to " + i + " bytes (" + l + " MB)";
          }
       });
       this.systemDetailsCategory.addDetail("JVM Flags", new ICrashReportDetail<String>() {
          public String call() {
-            RuntimeMXBean ☃ = ManagementFactory.getRuntimeMXBean();
-            List<String> ☃x = ☃.getInputArguments();
-            int ☃xx = 0;
-            StringBuilder ☃xxx = new StringBuilder();
-
-            for (String ☃xxxx : ☃x) {
-               if (☃xxxx.startsWith("-X")) {
-                  if (☃xx++ > 0) {
-                     ☃xxx.append(" ");
+            RuntimeMXBean runtimemxbean = ManagementFactory.getRuntimeMXBean();
+            List<String> list = runtimemxbean.getInputArguments();
+            int i = 0;
+            StringBuilder stringbuilder = new StringBuilder();
+
+            for (String s : list) {
+               if (s.startsWith("-X")) {
+                  if (i++ > 0) {
+                     stringbuilder.append(" ");
                   }
 
-                  ☃xxx.append(☃xxxx);
+                  stringbuilder.append(s);
                }
             }
 
-            return String.format("%d total; %s", ☃xx, ☃xxx.toString());
+            return String.format("%d total; %s", i, stringbuilder.toString());
          }
       });
       this.systemDetailsCategory.addDetail("IntCache", new ICrashReportDetail<String>() {
@@ -94,6 +97,10 @@ public String call() throws Exception {
             return IntCache.getCacheSizes();
          }
       });
+      if (Reflector.FMLCommonHandler_enhanceCrashReport.exists()) {
+         Object instance = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         Reflector.callString(instance, Reflector.FMLCommonHandler_enhanceCrashReport, new Object[]{this, this.systemDetailsCategory});
+      }
    }
 
    public String getDescription() {
@@ -104,115 +111,121 @@ public Throwable getCrashCause() {
       return this.cause;
    }
 
-   public void getSectionsInStringBuilder(StringBuilder var1) {
+   public void getSectionsInStringBuilder(StringBuilder builder) {
       if ((this.stacktrace == null || this.stacktrace.length <= 0) && !this.crashReportSections.isEmpty()) {
          this.stacktrace = (StackTraceElement[])ArrayUtils.subarray(this.crashReportSections.get(0).getStackTrace(), 0, 1);
       }
 
       if (this.stacktrace != null && this.stacktrace.length > 0) {
-         ☃.append("-- Head --\n");
-         ☃.append("Thread: ").append(Thread.currentThread().getName()).append("\n");
-         ☃.append("Stacktrace:\n");
+         builder.append("-- Head --\n");
+         builder.append("Thread: ").append(Thread.currentThread().getName()).append("\n");
+         builder.append("Stacktrace:\n");
 
-         for (StackTraceElement ☃ : this.stacktrace) {
-            ☃.append("\t").append("at ").append(☃);
-            ☃.append("\n");
+         for (StackTraceElement stacktraceelement : this.stacktrace) {
+            builder.append("\t").append("at ").append(stacktraceelement);
+            builder.append("\n");
          }
 
-         ☃.append("\n");
+         builder.append("\n");
       }
 
-      for (CrashReportCategory ☃ : this.crashReportSections) {
-         ☃.appendToStringBuilder(☃);
-         ☃.append("\n\n");
+      for (CrashReportCategory crashreportcategory : this.crashReportSections) {
+         crashreportcategory.appendToStringBuilder(builder);
+         builder.append("\n\n");
       }
 
-      this.systemDetailsCategory.appendToStringBuilder(☃);
+      this.systemDetailsCategory.appendToStringBuilder(builder);
    }
 
    public String getCauseStackTraceOrString() {
-      StringWriter ☃ = null;
-      PrintWriter ☃x = null;
-      Throwable ☃xx = this.cause;
-      if (☃xx.getMessage() == null) {
-         if (☃xx instanceof NullPointerException) {
-            ☃xx = new NullPointerException(this.description);
-         } else if (☃xx instanceof StackOverflowError) {
-            ☃xx = new StackOverflowError(this.description);
-         } else if (☃xx instanceof OutOfMemoryError) {
-            ☃xx = new OutOfMemoryError(this.description);
+      StringWriter stringwriter = null;
+      PrintWriter printwriter = null;
+      Throwable throwable = this.cause;
+      if (throwable.getMessage() == null) {
+         if (throwable instanceof NullPointerException) {
+            throwable = new NullPointerException(this.description);
+         } else if (throwable instanceof StackOverflowError) {
+            throwable = new StackOverflowError(this.description);
+         } else if (throwable instanceof OutOfMemoryError) {
+            throwable = new OutOfMemoryError(this.description);
          }
 
-         ☃xx.setStackTrace(this.cause.getStackTrace());
+         throwable.setStackTrace(this.cause.getStackTrace());
       }
 
-      String ☃xxx = ☃xx.toString();
+      String s = throwable.toString();
 
       try {
-         ☃ = new StringWriter();
-         ☃x = new PrintWriter(☃);
-         ☃xx.printStackTrace(☃x);
-         ☃xxx = ☃.toString();
+         stringwriter = new StringWriter();
+         printwriter = new PrintWriter(stringwriter);
+         throwable.printStackTrace(printwriter);
+         s = stringwriter.toString();
       } finally {
-         IOUtils.closeQuietly(☃);
-         IOUtils.closeQuietly(☃x);
+         IOUtils.closeQuietly(stringwriter);
+         IOUtils.closeQuietly(printwriter);
       }
 
-      return ☃xxx;
+      return s;
    }
 
    public String getCompleteReport() {
-      StringBuilder ☃ = new StringBuilder();
-      ☃.append("---- Minecraft Crash Report ----\n");
-      ☃.append("// ");
-      ☃.append(getWittyComment());
-      ☃.append("\n\n");
-      ☃.append("Time: ");
-      ☃.append(new SimpleDateFormat().format(new Date()));
-      ☃.append("\n");
-      ☃.append("Description: ");
-      ☃.append(this.description);
-      ☃.append("\n\n");
-      ☃.append(this.getCauseStackTraceOrString());
-      ☃.append("\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n");
-
-      for (int ☃x = 0; ☃x < 87; ☃x++) {
-         ☃.append("-");
+      if (!this.reported) {
+         this.reported = true;
+         CrashReporter.onCrashReport(this, this.systemDetailsCategory);
+      }
+
+      StringBuilder stringbuilder = new StringBuilder();
+      stringbuilder.append("---- Minecraft Crash Report ----\n");
+      Reflector.call(Reflector.CoreModManager_onCrash, new Object[]{stringbuilder});
+      stringbuilder.append("// ");
+      stringbuilder.append(getWittyComment());
+      stringbuilder.append("\n\n");
+      stringbuilder.append("Time: ");
+      stringbuilder.append(new SimpleDateFormat().format(new Date()));
+      stringbuilder.append("\n");
+      stringbuilder.append("Description: ");
+      stringbuilder.append(this.description);
+      stringbuilder.append("\n\n");
+      stringbuilder.append(this.getCauseStackTraceOrString());
+      stringbuilder.append("\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n");
+
+      for (int i = 0; i < 87; i++) {
+         stringbuilder.append("-");
       }
 
-      ☃.append("\n\n");
-      this.getSectionsInStringBuilder(☃);
-      return ☃.toString();
+      stringbuilder.append("\n\n");
+      this.getSectionsInStringBuilder(stringbuilder);
+      return stringbuilder.toString();
    }
 
    public File getFile() {
       return this.crashReportFile;
    }
 
-   public boolean saveToFile(File var1) {
+   public boolean saveToFile(File toFile) {
       if (this.crashReportFile != null) {
          return false;
       } else {
-         if (☃.getParentFile() != null) {
-            ☃.getParentFile().mkdirs();
+         if (toFile.getParentFile() != null) {
+            toFile.getParentFile().mkdirs();
          }
 
-         Writer ☃ = null;
+         Writer writer = null;
 
-         boolean var4;
+         boolean flag1;
          try {
-            ☃ = new OutputStreamWriter(new FileOutputStream(☃), StandardCharsets.UTF_8);
-            ☃.write(this.getCompleteReport());
-            this.crashReportFile = ☃;
+            writer = new OutputStreamWriter(new FileOutputStream(toFile), StandardCharsets.UTF_8);
+            writer.write(this.getCompleteReport());
+            this.crashReportFile = toFile;
             return true;
-         } catch (Throwable var8) {
-            LOGGER.error("Could not save crash report to {}", ☃, var8);
-            var4 = false;
+         } catch (Throwable var9) {
+            LOGGER.error("Could not save crash report to {}", toFile, var9);
+            flag1 = false;
          } finally {
-            IOUtils.closeQuietly(☃);
+            IOUtils.closeQuietly(writer);
          }
 
-         return var4;
+         return flag1;
       }
    }
 
@@ -220,47 +233,47 @@ public CrashReportCategory getCategory() {
       return this.systemDetailsCategory;
    }
 
-   public CrashReportCategory makeCategory(String var1) {
-      return this.makeCategoryDepth(☃, 1);
+   public CrashReportCategory makeCategory(String name) {
+      return this.makeCategoryDepth(name, 1);
    }
 
-   public CrashReportCategory makeCategoryDepth(String var1, int var2) {
-      CrashReportCategory ☃ = new CrashReportCategory(this, ☃);
+   public CrashReportCategory makeCategoryDepth(String categoryName, int stacktraceLength) {
+      CrashReportCategory crashreportcategory = new CrashReportCategory(this, categoryName);
       if (this.firstCategoryInCrashReport) {
-         int ☃x = ☃.getPrunedStackTrace(☃);
-         StackTraceElement[] ☃xx = this.cause.getStackTrace();
-         StackTraceElement ☃xxx = null;
-         StackTraceElement ☃xxxx = null;
-         int ☃xxxxx = ☃xx.length - ☃x;
-         if (☃xxxxx < 0) {
-            System.out.println("Negative index in crash report handler (" + ☃xx.length + "/" + ☃x + ")");
+         int i = crashreportcategory.getPrunedStackTrace(stacktraceLength);
+         StackTraceElement[] astacktraceelement = this.cause.getStackTrace();
+         StackTraceElement stacktraceelement = null;
+         StackTraceElement stacktraceelement1 = null;
+         int j = astacktraceelement.length - i;
+         if (j < 0) {
+            System.out.println("Negative index in crash report handler (" + astacktraceelement.length + "/" + i + ")");
          }
 
-         if (☃xx != null && 0 <= ☃xxxxx && ☃xxxxx < ☃xx.length) {
-            ☃xxx = ☃xx[☃xxxxx];
-            if (☃xx.length + 1 - ☃x < ☃xx.length) {
-               ☃xxxx = ☃xx[☃xx.length + 1 - ☃x];
+         if (astacktraceelement != null && 0 <= j && j < astacktraceelement.length) {
+            stacktraceelement = astacktraceelement[j];
+            if (astacktraceelement.length + 1 - i < astacktraceelement.length) {
+               stacktraceelement1 = astacktraceelement[astacktraceelement.length + 1 - i];
             }
          }
 
-         this.firstCategoryInCrashReport = ☃.firstTwoElementsOfStackTraceMatch(☃xxx, ☃xxxx);
-         if (☃x > 0 && !this.crashReportSections.isEmpty()) {
-            CrashReportCategory ☃xxxxxx = this.crashReportSections.get(this.crashReportSections.size() - 1);
-            ☃xxxxxx.trimStackTraceEntriesFromBottom(☃x);
-         } else if (☃xx != null && ☃xx.length >= ☃x && 0 <= ☃xxxxx && ☃xxxxx < ☃xx.length) {
-            this.stacktrace = new StackTraceElement[☃xxxxx];
-            System.arraycopy(☃xx, 0, this.stacktrace, 0, this.stacktrace.length);
+         this.firstCategoryInCrashReport = crashreportcategory.firstTwoElementsOfStackTraceMatch(stacktraceelement, stacktraceelement1);
+         if (i > 0 && !this.crashReportSections.isEmpty()) {
+            CrashReportCategory crashreportcategory1 = this.crashReportSections.get(this.crashReportSections.size() - 1);
+            crashreportcategory1.trimStackTraceEntriesFromBottom(i);
+         } else if (astacktraceelement != null && astacktraceelement.length >= i && 0 <= j && j < astacktraceelement.length) {
+            this.stacktrace = new StackTraceElement[j];
+            System.arraycopy(astacktraceelement, 0, this.stacktrace, 0, this.stacktrace.length);
          } else {
             this.firstCategoryInCrashReport = false;
          }
       }
 
-      this.crashReportSections.add(☃);
-      return ☃;
+      this.crashReportSections.add(crashreportcategory);
+      return crashreportcategory;
    }
 
    private static String getWittyComment() {
-      String[] ☃ = new String[]{
+      String[] astring = new String[]{
          "Who set us up the TNT?",
          "Everything's going to plan. No, really, that was supposed to happen.",
          "Uh... Did I do that?",
@@ -298,20 +311,20 @@ private static String getWittyComment() {
       };
 
       try {
-         return ☃[(int)(System.nanoTime() % ☃.length)];
+         return astring[(int)(System.nanoTime() % astring.length)];
       } catch (Throwable var2) {
          return "Witty comment unavailable :(";
       }
    }
 
-   public static CrashReport makeCrashReport(Throwable var0, String var1) {
-      CrashReport ☃;
-      if (☃ instanceof ReportedException) {
-         ☃ = ((ReportedException)☃).getCrashReport();
+   public static CrashReport makeCrashReport(Throwable causeIn, String descriptionIn) {
+      CrashReport crashreport;
+      if (causeIn instanceof ReportedException) {
+         crashreport = ((ReportedException)causeIn).getCrashReport();
       } else {
-         ☃ = new CrashReport(☃, ☃);
+         crashreport = new CrashReport(descriptionIn, causeIn);
       }
 
-      return ☃;
+      return crashreport;
    }
 }
diff --git a/patches/net/minecraft/entity/EntityLiving.java b/patches/net/minecraft/entity/EntityLiving.java
index c3ea9fc..a697cc7 100644
--- a/patches/net/minecraft/entity/EntityLiving.java
+++ b/patches/net/minecraft/entity/EntityLiving.java
@@ -5,6 +5,7 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
+import java.util.function.BiPredicate;
 import javax.annotation.Nullable;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.enchantment.EnchantmentHelper;
@@ -17,11 +18,13 @@
 import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityMob;
 import net.minecraft.entity.monster.IMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.inventory.EntityEquipmentSlot.Type;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemArmor;
 import net.minecraft.item.ItemBow;
@@ -37,6 +40,7 @@
 import net.minecraft.pathfinding.PathNavigate;
 import net.minecraft.pathfinding.PathNavigateGround;
 import net.minecraft.pathfinding.PathNodeType;
+import net.minecraft.scoreboard.Team;
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.EnumHandSide;
@@ -51,10 +55,13 @@
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldEntitySpawner;
 import net.minecraft.world.WorldServer;
-import net.minecraft.world.storage.loot.LootContext;
 import net.minecraft.world.storage.loot.LootTable;
+import net.minecraft.world.storage.loot.LootContext.Builder;
+import net.optifine.reflect.Reflector;
 
 public abstract class EntityLiving extends EntityLivingBase {
    private static final DataParameter<Byte> AI_FLAGS = EntityDataManager.createKey(EntityLiving.class, DataSerializers.BYTE);
@@ -81,20 +88,22 @@ public abstract class EntityLiving extends EntityLivingBase {
    private boolean isLeashed;
    private Entity leashHolder;
    private NBTTagCompound leashNBTTag;
+   private UUID teamUuid = null;
+   private String teamUuidString = null;
 
-   public EntityLiving(World var1) {
-      super(☃);
-      this.tasks = new EntityAITasks(☃ != null && ☃.profiler != null ? ☃.profiler : null);
-      this.targetTasks = new EntityAITasks(☃ != null && ☃.profiler != null ? ☃.profiler : null);
+   public EntityLiving(World worldIn) {
+      super(worldIn);
+      this.tasks = new EntityAITasks(worldIn != null && worldIn.profiler != null ? worldIn.profiler : null);
+      this.targetTasks = new EntityAITasks(worldIn != null && worldIn.profiler != null ? worldIn.profiler : null);
       this.lookHelper = new EntityLookHelper(this);
       this.moveHelper = new EntityMoveHelper(this);
       this.jumpHelper = new EntityJumpHelper(this);
       this.bodyHelper = this.createBodyHelper();
-      this.navigator = this.createNavigator(☃);
+      this.navigator = this.createNavigator(worldIn);
       this.senses = new EntitySenses(this);
       Arrays.fill(this.inventoryArmorDropChances, 0.085F);
       Arrays.fill(this.inventoryHandsDropChances, 0.085F);
-      if (☃ != null && !☃.isRemote) {
+      if (worldIn != null && !worldIn.isRemote) {
          this.initEntityAI();
       }
    }
@@ -102,23 +111,22 @@ public EntityLiving(World var1) {
    protected void initEntityAI() {
    }
 
-   @Override
    protected void applyEntityAttributes() {
       super.applyEntityAttributes();
       this.getAttributeMap().registerAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(16.0);
    }
 
-   protected PathNavigate createNavigator(World var1) {
-      return new PathNavigateGround(this, ☃);
+   protected PathNavigate createNavigator(World worldIn) {
+      return new PathNavigateGround(this, worldIn);
    }
 
-   public float getPathPriority(PathNodeType var1) {
-      Float ☃ = this.mapPathPriority.get(☃);
-      return ☃ == null ? ☃.getPriority() : ☃;
+   public float getPathPriority(PathNodeType nodeType) {
+      Float f = this.mapPathPriority.get(nodeType);
+      return f == null ? nodeType.getPriority() : f;
    }
 
-   public void setPathPriority(PathNodeType var1, float var2) {
-      this.mapPathPriority.put(☃, ☃);
+   public void setPathPriority(PathNodeType nodeType, float priority) {
+      this.mapPathPriority.put(nodeType, priority);
    }
 
    protected EntityBodyHelper createBodyHelper() {
@@ -150,18 +158,18 @@ public EntityLivingBase getAttackTarget() {
       return this.attackTarget;
    }
 
-   public void setAttackTarget(@Nullable EntityLivingBase var1) {
-      this.attackTarget = ☃;
+   public void setAttackTarget(@Nullable EntityLivingBase entitylivingbaseIn) {
+      this.attackTarget = entitylivingbaseIn;
+      Reflector.callVoid(Reflector.ForgeHooks_onLivingSetAttackTarget, new Object[]{this, entitylivingbaseIn});
    }
 
-   public boolean canAttackClass(Class<? extends EntityLivingBase> var1) {
-      return ☃ != EntityGhast.class;
+   public boolean canAttackClass(Class<? extends EntityLivingBase> cls) {
+      return cls != EntityGhast.class;
    }
 
    public void eatGrassBonus() {
    }
 
-   @Override
    protected void entityInit() {
       super.entityInit();
       this.dataManager.register(AI_FLAGS, (byte)0);
@@ -172,13 +180,12 @@ public int getTalkInterval() {
    }
 
    public void playLivingSound() {
-      SoundEvent ☃ = this.getAmbientSound();
-      if (☃ != null) {
-         this.playSound(☃, this.getSoundVolume(), this.getSoundPitch());
+      SoundEvent soundevent = this.getAmbientSound();
+      if (soundevent != null) {
+         this.playSound(soundevent, this.getSoundVolume(), this.getSoundPitch());
       }
    }
 
-   @Override
    public void onEntityUpdate() {
       super.onEntityUpdate();
       this.world.profiler.startSection("mobBaseTick");
@@ -190,34 +197,32 @@ public void onEntityUpdate() {
       this.world.profiler.endSection();
    }
 
-   @Override
-   protected void playHurtSound(DamageSource var1) {
+   protected void playHurtSound(DamageSource source) {
       this.applyEntityAI();
-      super.playHurtSound(☃);
+      super.playHurtSound(source);
    }
 
    private void applyEntityAI() {
       this.livingSoundTime = -this.getTalkInterval();
    }
 
-   @Override
-   protected int getExperiencePoints(EntityPlayer var1) {
+   protected int getExperiencePoints(EntityPlayer player) {
       if (this.experienceValue > 0) {
-         int ☃ = this.experienceValue;
+         int i = this.experienceValue;
 
-         for (int ☃x = 0; ☃x < this.inventoryArmor.size(); ☃x++) {
-            if (!this.inventoryArmor.get(☃x).isEmpty() && this.inventoryArmorDropChances[☃x] <= 1.0F) {
-               ☃ += 1 + this.rand.nextInt(3);
+         for (int j = 0; j < this.inventoryArmor.size(); j++) {
+            if (!((ItemStack)this.inventoryArmor.get(j)).isEmpty() && this.inventoryArmorDropChances[j] <= 1.0F) {
+               i += 1 + this.rand.nextInt(3);
             }
          }
 
-         for (int ☃xx = 0; ☃xx < this.inventoryHands.size(); ☃xx++) {
-            if (!this.inventoryHands.get(☃xx).isEmpty() && this.inventoryHandsDropChances[☃xx] <= 1.0F) {
-               ☃ += 1 + this.rand.nextInt(3);
+         for (int k = 0; k < this.inventoryHands.size(); k++) {
+            if (!((ItemStack)this.inventoryHands.get(k)).isEmpty() && this.inventoryHandsDropChances[k] <= 1.0F) {
+               i += 1 + this.rand.nextInt(3);
             }
          }
 
-         return ☃;
+         return i;
       } else {
          return this.experienceValue;
       }
@@ -225,20 +230,21 @@ protected int getExperiencePoints(EntityPlayer var1) {
 
    public void spawnExplosionParticle() {
       if (this.world.isRemote) {
-         for (int ☃ = 0; ☃ < 20; ☃++) {
-            double ☃x = this.rand.nextGaussian() * 0.02;
-            double ☃xx = this.rand.nextGaussian() * 0.02;
-            double ☃xxx = this.rand.nextGaussian() * 0.02;
-            double ☃xxxx = 10.0;
+         for (int i = 0; i < 20; i++) {
+            double d0 = this.rand.nextGaussian() * 0.02;
+            double d1 = this.rand.nextGaussian() * 0.02;
+            double d2 = this.rand.nextGaussian() * 0.02;
+            double d3 = 10.0;
             this.world
                .spawnParticle(
                   EnumParticleTypes.EXPLOSION_NORMAL,
-                  this.posX + this.rand.nextFloat() * this.width * 2.0F - this.width - ☃x * 10.0,
-                  this.posY + this.rand.nextFloat() * this.height - ☃xx * 10.0,
-                  this.posZ + this.rand.nextFloat() * this.width * 2.0F - this.width - ☃xxx * 10.0,
-                  ☃x,
-                  ☃xx,
-                  ☃xxx
+                  this.posX + this.rand.nextFloat() * this.width * 2.0F - this.width - d0 * 10.0,
+                  this.posY + this.rand.nextFloat() * this.height - d1 * 10.0,
+                  this.posZ + this.rand.nextFloat() * this.width * 2.0F - this.width - d2 * 10.0,
+                  d0,
+                  d1,
+                  d2,
+                  new int[0]
                );
          }
       } else {
@@ -246,34 +252,35 @@ public void spawnExplosionParticle() {
       }
    }
 
-   @Override
-   public void handleStatusUpdate(byte var1) {
-      if (☃ == 20) {
+   public void handleStatusUpdate(byte id) {
+      if (id == 20) {
          this.spawnExplosionParticle();
       } else {
-         super.handleStatusUpdate(☃);
+         super.handleStatusUpdate(id);
       }
    }
 
-   @Override
    public void onUpdate() {
-      super.onUpdate();
-      if (!this.world.isRemote) {
-         this.updateLeashedState();
-         if (this.ticksExisted % 5 == 0) {
-            boolean ☃ = !(this.getControllingPassenger() instanceof EntityLiving);
-            boolean ☃x = !(this.getRidingEntity() instanceof EntityBoat);
-            this.tasks.setControlFlag(1, ☃);
-            this.tasks.setControlFlag(4, ☃ && ☃x);
-            this.tasks.setControlFlag(2, ☃);
+      if (Config.isSmoothWorld() && this.canSkipUpdate()) {
+         this.onUpdateMinimal();
+      } else {
+         super.onUpdate();
+         if (!this.world.isRemote) {
+            this.updateLeashedState();
+            if (this.ticksExisted % 5 == 0) {
+               boolean flag = !(this.getControllingPassenger() instanceof EntityLiving);
+               boolean flag1 = !(this.getRidingEntity() instanceof EntityBoat);
+               this.tasks.setControlFlag(1, flag);
+               this.tasks.setControlFlag(4, flag && flag1);
+               this.tasks.setControlFlag(2, flag);
+            }
          }
       }
    }
 
-   @Override
-   protected float updateDistance(float var1, float var2) {
+   protected float updateDistance(float p_110146_1_, float p_110146_2_) {
       this.bodyHelper.updateRenderAngles();
-      return ☃;
+      return p_110146_2_;
    }
 
    @Nullable
@@ -286,149 +293,146 @@ protected Item getDropItem() {
       return null;
    }
 
-   @Override
-   protected void dropFewItems(boolean var1, int var2) {
-      Item ☃ = this.getDropItem();
-      if (☃ != null) {
-         int ☃x = this.rand.nextInt(3);
-         if (☃ > 0) {
-            ☃x += this.rand.nextInt(☃ + 1);
+   protected void dropFewItems(boolean wasRecentlyHit, int lootingModifier) {
+      Item item = this.getDropItem();
+      if (item != null) {
+         int i = this.rand.nextInt(3);
+         if (lootingModifier > 0) {
+            i += this.rand.nextInt(lootingModifier + 1);
          }
 
-         for (int ☃xx = 0; ☃xx < ☃x; ☃xx++) {
-            this.dropItem(☃, 1);
+         for (int j = 0; j < i; j++) {
+            this.dropItem(item, 1);
          }
       }
    }
 
-   public static void registerFixesMob(DataFixer var0, Class<?> var1) {
-      ☃.registerWalker(FixTypes.ENTITY, new ItemStackDataLists(☃, "ArmorItems", "HandItems"));
+   public static void registerFixesMob(DataFixer fixer, Class<?> name) {
+      fixer.registerWalker(FixTypes.ENTITY, new ItemStackDataLists(name, new String[]{"ArmorItems", "HandItems"}));
    }
 
-   @Override
-   public void writeEntityToNBT(NBTTagCompound var1) {
-      super.writeEntityToNBT(☃);
-      ☃.setBoolean("CanPickUpLoot", this.canPickUpLoot());
-      ☃.setBoolean("PersistenceRequired", this.persistenceRequired);
-      NBTTagList ☃ = new NBTTagList();
+   public void writeEntityToNBT(NBTTagCompound compound) {
+      super.writeEntityToNBT(compound);
+      compound.setBoolean("CanPickUpLoot", this.canPickUpLoot());
+      compound.setBoolean("PersistenceRequired", this.persistenceRequired);
+      NBTTagList nbttaglist = new NBTTagList();
 
-      for (ItemStack ☃x : this.inventoryArmor) {
-         NBTTagCompound ☃xx = new NBTTagCompound();
-         if (!☃x.isEmpty()) {
-            ☃x.writeToNBT(☃xx);
+      for (ItemStack itemstack : this.inventoryArmor) {
+         NBTTagCompound nbttagcompound = new NBTTagCompound();
+         if (!itemstack.isEmpty()) {
+            itemstack.writeToNBT(nbttagcompound);
          }
 
-         ☃.appendTag(☃xx);
+         nbttaglist.appendTag(nbttagcompound);
       }
 
-      ☃.setTag("ArmorItems", ☃);
-      NBTTagList ☃x = new NBTTagList();
+      compound.setTag("ArmorItems", nbttaglist);
+      NBTTagList nbttaglist1 = new NBTTagList();
 
-      for (ItemStack ☃xx : this.inventoryHands) {
-         NBTTagCompound ☃xxx = new NBTTagCompound();
-         if (!☃xx.isEmpty()) {
-            ☃xx.writeToNBT(☃xxx);
+      for (ItemStack itemstack1 : this.inventoryHands) {
+         NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+         if (!itemstack1.isEmpty()) {
+            itemstack1.writeToNBT(nbttagcompound1);
          }
 
-         ☃x.appendTag(☃xxx);
+         nbttaglist1.appendTag(nbttagcompound1);
       }
 
-      ☃.setTag("HandItems", ☃x);
-      NBTTagList ☃xx = new NBTTagList();
+      compound.setTag("HandItems", nbttaglist1);
+      NBTTagList nbttaglist2 = new NBTTagList();
 
-      for (float ☃xxx : this.inventoryArmorDropChances) {
-         ☃xx.appendTag(new NBTTagFloat(☃xxx));
+      for (float f : this.inventoryArmorDropChances) {
+         nbttaglist2.appendTag(new NBTTagFloat(f));
       }
 
-      ☃.setTag("ArmorDropChances", ☃xx);
-      NBTTagList ☃xxx = new NBTTagList();
+      compound.setTag("ArmorDropChances", nbttaglist2);
+      NBTTagList nbttaglist3 = new NBTTagList();
 
-      for (float ☃xxxx : this.inventoryHandsDropChances) {
-         ☃xxx.appendTag(new NBTTagFloat(☃xxxx));
+      for (float f1 : this.inventoryHandsDropChances) {
+         nbttaglist3.appendTag(new NBTTagFloat(f1));
       }
 
-      ☃.setTag("HandDropChances", ☃xxx);
-      ☃.setBoolean("Leashed", this.isLeashed);
+      compound.setTag("HandDropChances", nbttaglist3);
+      compound.setBoolean("Leashed", this.isLeashed);
       if (this.leashHolder != null) {
-         NBTTagCompound ☃xxxx = new NBTTagCompound();
+         NBTTagCompound nbttagcompound2 = new NBTTagCompound();
          if (this.leashHolder instanceof EntityLivingBase) {
-            UUID ☃xxxxx = this.leashHolder.getUniqueID();
-            ☃xxxx.setUniqueId("UUID", ☃xxxxx);
+            UUID uuid = this.leashHolder.getUniqueID();
+            nbttagcompound2.setUniqueId("UUID", uuid);
          } else if (this.leashHolder instanceof EntityHanging) {
-            BlockPos ☃xxxxx = ((EntityHanging)this.leashHolder).getHangingPosition();
-            ☃xxxx.setInteger("X", ☃xxxxx.getX());
-            ☃xxxx.setInteger("Y", ☃xxxxx.getY());
-            ☃xxxx.setInteger("Z", ☃xxxxx.getZ());
+            BlockPos blockpos = ((EntityHanging)this.leashHolder).getHangingPosition();
+            nbttagcompound2.setInteger("X", blockpos.getX());
+            nbttagcompound2.setInteger("Y", blockpos.getY());
+            nbttagcompound2.setInteger("Z", blockpos.getZ());
          }
 
-         ☃.setTag("Leash", ☃xxxx);
+         compound.setTag("Leash", nbttagcompound2);
       }
 
-      ☃.setBoolean("LeftHanded", this.isLeftHanded());
+      compound.setBoolean("LeftHanded", this.isLeftHanded());
       if (this.deathLootTable != null) {
-         ☃.setString("DeathLootTable", this.deathLootTable.toString());
+         compound.setString("DeathLootTable", this.deathLootTable.toString());
          if (this.deathLootTableSeed != 0L) {
-            ☃.setLong("DeathLootTableSeed", this.deathLootTableSeed);
+            compound.setLong("DeathLootTableSeed", this.deathLootTableSeed);
          }
       }
 
       if (this.isAIDisabled()) {
-         ☃.setBoolean("NoAI", this.isAIDisabled());
+         compound.setBoolean("NoAI", this.isAIDisabled());
       }
    }
 
-   @Override
-   public void readEntityFromNBT(NBTTagCompound var1) {
-      super.readEntityFromNBT(☃);
-      if (☃.hasKey("CanPickUpLoot", 1)) {
-         this.setCanPickUpLoot(☃.getBoolean("CanPickUpLoot"));
+   public void readEntityFromNBT(NBTTagCompound compound) {
+      super.readEntityFromNBT(compound);
+      if (compound.hasKey("CanPickUpLoot", 1)) {
+         this.setCanPickUpLoot(compound.getBoolean("CanPickUpLoot"));
       }
 
-      this.persistenceRequired = ☃.getBoolean("PersistenceRequired");
-      if (☃.hasKey("ArmorItems", 9)) {
-         NBTTagList ☃ = ☃.getTagList("ArmorItems", 10);
+      this.persistenceRequired = compound.getBoolean("PersistenceRequired");
+      if (compound.hasKey("ArmorItems", 9)) {
+         NBTTagList nbttaglist = compound.getTagList("ArmorItems", 10);
 
-         for (int ☃x = 0; ☃x < this.inventoryArmor.size(); ☃x++) {
-            this.inventoryArmor.set(☃x, new ItemStack(☃.getCompoundTagAt(☃x)));
+         for (int i = 0; i < this.inventoryArmor.size(); i++) {
+            this.inventoryArmor.set(i, new ItemStack(nbttaglist.getCompoundTagAt(i)));
          }
       }
 
-      if (☃.hasKey("HandItems", 9)) {
-         NBTTagList ☃ = ☃.getTagList("HandItems", 10);
+      if (compound.hasKey("HandItems", 9)) {
+         NBTTagList nbttaglist1 = compound.getTagList("HandItems", 10);
 
-         for (int ☃x = 0; ☃x < this.inventoryHands.size(); ☃x++) {
-            this.inventoryHands.set(☃x, new ItemStack(☃.getCompoundTagAt(☃x)));
+         for (int j = 0; j < this.inventoryHands.size(); j++) {
+            this.inventoryHands.set(j, new ItemStack(nbttaglist1.getCompoundTagAt(j)));
          }
       }
 
-      if (☃.hasKey("ArmorDropChances", 9)) {
-         NBTTagList ☃ = ☃.getTagList("ArmorDropChances", 5);
+      if (compound.hasKey("ArmorDropChances", 9)) {
+         NBTTagList nbttaglist2 = compound.getTagList("ArmorDropChances", 5);
 
-         for (int ☃x = 0; ☃x < ☃.tagCount(); ☃x++) {
-            this.inventoryArmorDropChances[☃x] = ☃.getFloatAt(☃x);
+         for (int k = 0; k < nbttaglist2.tagCount(); k++) {
+            this.inventoryArmorDropChances[k] = nbttaglist2.getFloatAt(k);
          }
       }
 
-      if (☃.hasKey("HandDropChances", 9)) {
-         NBTTagList ☃ = ☃.getTagList("HandDropChances", 5);
+      if (compound.hasKey("HandDropChances", 9)) {
+         NBTTagList nbttaglist3 = compound.getTagList("HandDropChances", 5);
 
-         for (int ☃x = 0; ☃x < ☃.tagCount(); ☃x++) {
-            this.inventoryHandsDropChances[☃x] = ☃.getFloatAt(☃x);
+         for (int l = 0; l < nbttaglist3.tagCount(); l++) {
+            this.inventoryHandsDropChances[l] = nbttaglist3.getFloatAt(l);
          }
       }
 
-      this.isLeashed = ☃.getBoolean("Leashed");
-      if (this.isLeashed && ☃.hasKey("Leash", 10)) {
-         this.leashNBTTag = ☃.getCompoundTag("Leash");
+      this.isLeashed = compound.getBoolean("Leashed");
+      if (this.isLeashed && compound.hasKey("Leash", 10)) {
+         this.leashNBTTag = compound.getCompoundTag("Leash");
       }
 
-      this.setLeftHanded(☃.getBoolean("LeftHanded"));
-      if (☃.hasKey("DeathLootTable", 8)) {
-         this.deathLootTable = new ResourceLocation(☃.getString("DeathLootTable"));
-         this.deathLootTableSeed = ☃.getLong("DeathLootTableSeed");
+      this.setLeftHanded(compound.getBoolean("LeftHanded"));
+      if (compound.hasKey("DeathLootTable", 8)) {
+         this.deathLootTable = new ResourceLocation(compound.getString("DeathLootTable"));
+         this.deathLootTableSeed = compound.getLong("DeathLootTableSeed");
       }
 
-      this.setNoAI(☃.getBoolean("NoAI"));
+      this.setNoAI(compound.getBoolean("NoAI"));
    }
 
    @Nullable
@@ -436,57 +440,61 @@ protected ResourceLocation getLootTable() {
       return null;
    }
 
-   @Override
-   protected void dropLoot(boolean var1, int var2, DamageSource var3) {
-      ResourceLocation ☃ = this.deathLootTable;
-      if (☃ == null) {
-         ☃ = this.getLootTable();
+   protected void dropLoot(boolean wasRecentlyHit, int lootingModifier, DamageSource source) {
+      ResourceLocation resourcelocation = this.deathLootTable;
+      if (resourcelocation == null) {
+         resourcelocation = this.getLootTable();
       }
 
-      if (☃ != null) {
-         LootTable ☃x = this.world.getLootTableManager().getLootTableFromLocation(☃);
+      if (resourcelocation != null) {
+         LootTable loottable = this.world.getLootTableManager().getLootTableFromLocation(resourcelocation);
          this.deathLootTable = null;
-         LootContext.Builder ☃xx = new LootContext.Builder((WorldServer)this.world).withLootedEntity(this).withDamageSource(☃);
-         if (☃ && this.attackingPlayer != null) {
-            ☃xx = ☃xx.withPlayer(this.attackingPlayer).withLuck(this.attackingPlayer.getLuck());
+         Builder lootcontext$builder = new Builder((WorldServer)this.world).withLootedEntity(this).withDamageSource(source);
+         if (wasRecentlyHit && this.attackingPlayer != null) {
+            lootcontext$builder = lootcontext$builder.withPlayer(this.attackingPlayer).withLuck(this.attackingPlayer.getLuck());
          }
 
-         for (ItemStack ☃xxx : ☃x.generateLootForPools(this.deathLootTableSeed == 0L ? this.rand : new Random(this.deathLootTableSeed), ☃xx.build())) {
-            this.entityDropItem(☃xxx, 0.0F);
+         for (ItemStack itemstack : loottable.generateLootForPools(
+            this.deathLootTableSeed == 0L ? this.rand : new Random(this.deathLootTableSeed), lootcontext$builder.build()
+         )) {
+            this.entityDropItem(itemstack, 0.0F);
          }
 
-         this.dropEquipment(☃, ☃);
+         this.dropEquipment(wasRecentlyHit, lootingModifier);
       } else {
-         super.dropLoot(☃, ☃, ☃);
+         super.dropLoot(wasRecentlyHit, lootingModifier, source);
       }
    }
 
-   public void setMoveForward(float var1) {
-      this.moveForward = ☃;
+   public void setMoveForward(float p_191989_1_) {
+      this.moveForward = p_191989_1_;
    }
 
-   public void setMoveVertical(float var1) {
-      this.moveVertical = ☃;
+   public void setMoveVertical(float amount) {
+      this.moveVertical = amount;
    }
 
-   public void setMoveStrafing(float var1) {
-      this.moveStrafing = ☃;
+   public void setMoveStrafing(float amount) {
+      this.moveStrafing = amount;
    }
 
-   @Override
-   public void setAIMoveSpeed(float var1) {
-      super.setAIMoveSpeed(☃);
-      this.setMoveForward(☃);
+   public void setAIMoveSpeed(float speedIn) {
+      super.setAIMoveSpeed(speedIn);
+      this.setMoveForward(speedIn);
    }
 
-   @Override
    public void onLivingUpdate() {
       super.onLivingUpdate();
       this.world.profiler.startSection("looting");
-      if (!this.world.isRemote && this.canPickUpLoot() && !this.dead && this.world.getGameRules().getBoolean("mobGriefing")) {
-         for (EntityItem ☃ : this.world.getEntitiesWithinAABB(EntityItem.class, this.getEntityBoundingBox().grow(1.0, 0.0, 1.0))) {
-            if (!☃.isDead && !☃.getItem().isEmpty() && !☃.cannotPickup()) {
-               this.updateEquipmentIfNeeded(☃);
+      boolean mobGriefing = this.world.getGameRules().getBoolean("mobGriefing");
+      if (Reflector.ForgeEventFactory_getMobGriefingEvent.exists()) {
+         mobGriefing = Reflector.callBoolean(Reflector.ForgeEventFactory_getMobGriefingEvent, new Object[]{this.world, this});
+      }
+
+      if (!this.world.isRemote && this.canPickUpLoot() && !this.dead && mobGriefing) {
+         for (EntityItem entityitem : this.world.getEntitiesWithinAABB(EntityItem.class, this.getEntityBoundingBox().grow(1.0, 0.0, 1.0))) {
+            if (!entityitem.isDead && !entityitem.getItem().isEmpty() && !entityitem.cannotPickup()) {
+               this.updateEquipmentIfNeeded(entityitem);
             }
          }
       }
@@ -494,76 +502,76 @@ public void onLivingUpdate() {
       this.world.profiler.endSection();
    }
 
-   protected void updateEquipmentIfNeeded(EntityItem var1) {
-      ItemStack ☃ = ☃.getItem();
-      EntityEquipmentSlot ☃x = getSlotForItemStack(☃);
-      boolean ☃xx = true;
-      ItemStack ☃xxx = this.getItemStackFromSlot(☃x);
-      if (!☃xxx.isEmpty()) {
-         if (☃x.getSlotType() == EntityEquipmentSlot.Type.HAND) {
-            if (☃.getItem() instanceof ItemSword && !(☃xxx.getItem() instanceof ItemSword)) {
-               ☃xx = true;
-            } else if (☃.getItem() instanceof ItemSword && ☃xxx.getItem() instanceof ItemSword) {
-               ItemSword ☃xxxx = (ItemSword)☃.getItem();
-               ItemSword ☃xxxxx = (ItemSword)☃xxx.getItem();
-               if (☃xxxx.getAttackDamage() == ☃xxxxx.getAttackDamage()) {
-                  ☃xx = ☃.getMetadata() > ☃xxx.getMetadata() || ☃.hasTagCompound() && !☃xxx.hasTagCompound();
+   protected void updateEquipmentIfNeeded(EntityItem itemEntity) {
+      ItemStack itemstack = itemEntity.getItem();
+      EntityEquipmentSlot entityequipmentslot = getSlotForItemStack(itemstack);
+      boolean flag = true;
+      ItemStack itemstack1 = this.getItemStackFromSlot(entityequipmentslot);
+      if (!itemstack1.isEmpty()) {
+         if (entityequipmentslot.getSlotType() == Type.HAND) {
+            if (itemstack.getItem() instanceof ItemSword && !(itemstack1.getItem() instanceof ItemSword)) {
+               flag = true;
+            } else if (itemstack.getItem() instanceof ItemSword && itemstack1.getItem() instanceof ItemSword) {
+               ItemSword itemsword = (ItemSword)itemstack.getItem();
+               ItemSword itemsword1 = (ItemSword)itemstack1.getItem();
+               if (itemsword.getAttackDamage() == itemsword1.getAttackDamage()) {
+                  flag = itemstack.getMetadata() > itemstack1.getMetadata() || itemstack.hasTagCompound() && !itemstack1.hasTagCompound();
                } else {
-                  ☃xx = ☃xxxx.getAttackDamage() > ☃xxxxx.getAttackDamage();
+                  flag = itemsword.getAttackDamage() > itemsword1.getAttackDamage();
                }
-            } else if (☃.getItem() instanceof ItemBow && ☃xxx.getItem() instanceof ItemBow) {
-               ☃xx = ☃.hasTagCompound() && !☃xxx.hasTagCompound();
+            } else if (itemstack.getItem() instanceof ItemBow && itemstack1.getItem() instanceof ItemBow) {
+               flag = itemstack.hasTagCompound() && !itemstack1.hasTagCompound();
             } else {
-               ☃xx = false;
+               flag = false;
             }
-         } else if (☃.getItem() instanceof ItemArmor && !(☃xxx.getItem() instanceof ItemArmor)) {
-            ☃xx = true;
-         } else if (☃.getItem() instanceof ItemArmor && ☃xxx.getItem() instanceof ItemArmor && !EnchantmentHelper.hasBindingCurse(☃xxx)) {
-            ItemArmor ☃xxxx = (ItemArmor)☃.getItem();
-            ItemArmor ☃xxxxx = (ItemArmor)☃xxx.getItem();
-            if (☃xxxx.damageReduceAmount == ☃xxxxx.damageReduceAmount) {
-               ☃xx = ☃.getMetadata() > ☃xxx.getMetadata() || ☃.hasTagCompound() && !☃xxx.hasTagCompound();
+         } else if (itemstack.getItem() instanceof ItemArmor && !(itemstack1.getItem() instanceof ItemArmor)) {
+            flag = true;
+         } else if (itemstack.getItem() instanceof ItemArmor && itemstack1.getItem() instanceof ItemArmor && !EnchantmentHelper.hasBindingCurse(itemstack1)) {
+            ItemArmor itemarmor = (ItemArmor)itemstack.getItem();
+            ItemArmor itemarmor1 = (ItemArmor)itemstack1.getItem();
+            if (itemarmor.damageReduceAmount == itemarmor1.damageReduceAmount) {
+               flag = itemstack.getMetadata() > itemstack1.getMetadata() || itemstack.hasTagCompound() && !itemstack1.hasTagCompound();
             } else {
-               ☃xx = ☃xxxx.damageReduceAmount > ☃xxxxx.damageReduceAmount;
+               flag = itemarmor.damageReduceAmount > itemarmor1.damageReduceAmount;
             }
          } else {
-            ☃xx = false;
+            flag = false;
          }
       }
 
-      if (☃xx && this.canEquipItem(☃)) {
-         double ☃xxxx;
-         switch (☃x.getSlotType()) {
+      if (flag && this.canEquipItem(itemstack)) {
+         double d0;
+         switch (entityequipmentslot.getSlotType()) {
             case HAND:
-               ☃xxxx = this.inventoryHandsDropChances[☃x.getIndex()];
+               d0 = this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
                break;
             case ARMOR:
-               ☃xxxx = this.inventoryArmorDropChances[☃x.getIndex()];
+               d0 = this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
                break;
             default:
-               ☃xxxx = 0.0;
+               d0 = 0.0;
          }
 
-         if (!☃xxx.isEmpty() && this.rand.nextFloat() - 0.1F < ☃xxxx) {
-            this.entityDropItem(☃xxx, 0.0F);
+         if (!itemstack1.isEmpty() && this.rand.nextFloat() - 0.1F < d0) {
+            this.entityDropItem(itemstack1, 0.0F);
          }
 
-         this.setItemStackToSlot(☃x, ☃);
-         switch (☃x.getSlotType()) {
+         this.setItemStackToSlot(entityequipmentslot, itemstack);
+         switch (entityequipmentslot.getSlotType()) {
             case HAND:
-               this.inventoryHandsDropChances[☃x.getIndex()] = 2.0F;
+               this.inventoryHandsDropChances[entityequipmentslot.getIndex()] = 2.0F;
                break;
             case ARMOR:
-               this.inventoryArmorDropChances[☃x.getIndex()] = 2.0F;
+               this.inventoryArmorDropChances[entityequipmentslot.getIndex()] = 2.0F;
          }
 
          this.persistenceRequired = true;
-         this.onItemPickup(☃, ☃.getCount());
-         ☃.setDead();
+         this.onItemPickup(itemEntity, itemstack.getCount());
+         itemEntity.setDead();
       }
    }
 
-   protected boolean canEquipItem(ItemStack var1) {
+   protected boolean canEquipItem(ItemStack stack) {
       return true;
    }
 
@@ -572,29 +580,35 @@ protected boolean canDespawn() {
    }
 
    protected void despawnEntity() {
+      Object result = null;
+      Object Result_DEFAULT = Reflector.getFieldValue(Reflector.Event_Result_DEFAULT);
+      Object Result_DENY = Reflector.getFieldValue(Reflector.Event_Result_DENY);
       if (this.persistenceRequired) {
          this.idleTime = 0;
-      } else {
-         Entity ☃ = this.world.getClosestPlayerToEntity(this, -1.0);
-         if (☃ != null) {
-            double ☃x = ☃.posX - this.posX;
-            double ☃xx = ☃.posY - this.posY;
-            double ☃xxx = ☃.posZ - this.posZ;
-            double ☃xxxx = ☃x * ☃x + ☃xx * ☃xx + ☃xxx * ☃xxx;
-            if (this.canDespawn() && ☃xxxx > 16384.0) {
+      } else if ((this.idleTime & 31) != 31 || (result = Reflector.call(Reflector.ForgeEventFactory_canEntityDespawn, new Object[]{this})) == Result_DEFAULT) {
+         Entity entity = this.world.getClosestPlayerToEntity(this, -1.0);
+         if (entity != null) {
+            double d0 = entity.posX - this.posX;
+            double d1 = entity.posY - this.posY;
+            double d2 = entity.posZ - this.posZ;
+            double d3 = d0 * d0 + d1 * d1 + d2 * d2;
+            if (this.canDespawn() && d3 > 16384.0) {
                this.setDead();
             }
 
-            if (this.idleTime > 600 && this.rand.nextInt(800) == 0 && ☃xxxx > 1024.0 && this.canDespawn()) {
+            if (this.idleTime > 600 && this.rand.nextInt(800) == 0 && d3 > 1024.0 && this.canDespawn()) {
                this.setDead();
-            } else if (☃xxxx < 1024.0) {
+            } else if (d3 < 1024.0) {
                this.idleTime = 0;
             }
          }
+      } else if (result == Result_DENY) {
+         this.idleTime = 0;
+      } else {
+         this.setDead();
       }
    }
 
-   @Override
    protected final void updateEntityActionState() {
       this.idleTime++;
       this.world.profiler.startSection("checkDespawn");
@@ -616,9 +630,9 @@ protected final void updateEntityActionState() {
       this.updateAITasks();
       this.world.profiler.endSection();
       if (this.isRiding() && this.getRidingEntity() instanceof EntityLiving) {
-         EntityLiving ☃ = (EntityLiving)this.getRidingEntity();
-         ☃.getNavigator().setPath(this.getNavigator().getPath(), 1.5);
-         ☃.getMoveHelper().read(this.getMoveHelper());
+         EntityLiving entityliving = (EntityLiving)this.getRidingEntity();
+         entityliving.getNavigator().setPath(this.getNavigator().getPath(), 1.5);
+         entityliving.getMoveHelper().read(this.getMoveHelper());
       }
 
       this.world.profiler.startSection("controls");
@@ -643,40 +657,40 @@ public int getHorizontalFaceSpeed() {
       return 10;
    }
 
-   public void faceEntity(Entity var1, float var2, float var3) {
-      double ☃ = ☃.posX - this.posX;
-      double ☃x = ☃.posZ - this.posZ;
-      double ☃xx;
-      if (☃ instanceof EntityLivingBase) {
-         EntityLivingBase ☃xxx = (EntityLivingBase)☃;
-         ☃xx = ☃xxx.posY + ☃xxx.getEyeHeight() - (this.posY + this.getEyeHeight());
+   public void faceEntity(Entity entityIn, float maxYawIncrease, float maxPitchIncrease) {
+      double d0 = entityIn.posX - this.posX;
+      double d2 = entityIn.posZ - this.posZ;
+      double d1;
+      if (entityIn instanceof EntityLivingBase) {
+         EntityLivingBase entitylivingbase = (EntityLivingBase)entityIn;
+         d1 = entitylivingbase.posY + entitylivingbase.getEyeHeight() - (this.posY + this.getEyeHeight());
       } else {
-         ☃xx = (☃.getEntityBoundingBox().minY + ☃.getEntityBoundingBox().maxY) / 2.0 - (this.posY + this.getEyeHeight());
+         d1 = (entityIn.getEntityBoundingBox().minY + entityIn.getEntityBoundingBox().maxY) / 2.0 - (this.posY + this.getEyeHeight());
       }
 
-      double ☃xxx = MathHelper.sqrt(☃ * ☃ + ☃x * ☃x);
-      float ☃xxxx = (float)(MathHelper.atan2(☃x, ☃) * 180.0F / (float)Math.PI) - 90.0F;
-      float ☃xxxxx = (float)(-(MathHelper.atan2(☃xx, ☃xxx) * 180.0F / (float)Math.PI));
-      this.rotationPitch = this.updateRotation(this.rotationPitch, ☃xxxxx, ☃);
-      this.rotationYaw = this.updateRotation(this.rotationYaw, ☃xxxx, ☃);
+      double d3 = MathHelper.sqrt(d0 * d0 + d2 * d2);
+      float f = (float)(MathHelper.atan2(d2, d0) * (180.0 / Math.PI)) - 90.0F;
+      float f1 = (float)(-(MathHelper.atan2(d1, d3) * (180.0 / Math.PI)));
+      this.rotationPitch = this.updateRotation(this.rotationPitch, f1, maxPitchIncrease);
+      this.rotationYaw = this.updateRotation(this.rotationYaw, f, maxYawIncrease);
    }
 
-   private float updateRotation(float var1, float var2, float var3) {
-      float ☃ = MathHelper.wrapDegrees(☃ - ☃);
-      if (☃ > ☃) {
-         ☃ = ☃;
+   private float updateRotation(float angle, float targetAngle, float maxIncrease) {
+      float f = MathHelper.wrapDegrees(targetAngle - angle);
+      if (f > maxIncrease) {
+         f = maxIncrease;
       }
 
-      if (☃ < -☃) {
-         ☃ = -☃;
+      if (f < -maxIncrease) {
+         f = -maxIncrease;
       }
 
-      return ☃ + ☃;
+      return angle + f;
    }
 
    public boolean getCanSpawnHere() {
-      IBlockState ☃ = this.world.getBlockState(new BlockPos(this).down());
-      return ☃.canEntitySpawn(this);
+      IBlockState iblockstate = this.world.getBlockState(new BlockPos(this).down());
+      return iblockstate.a(this);
    }
 
    public boolean isNotColliding() {
@@ -693,111 +707,108 @@ public int getMaxSpawnedInChunk() {
       return 4;
    }
 
-   @Override
    public int getMaxFallHeight() {
       if (this.getAttackTarget() == null) {
          return 3;
       } else {
-         int ☃ = (int)(this.getHealth() - this.getMaxHealth() * 0.33F);
-         ☃ -= (3 - this.world.getDifficulty().getId()) * 4;
-         if (☃ < 0) {
-            ☃ = 0;
+         int i = (int)(this.getHealth() - this.getMaxHealth() * 0.33F);
+         i -= (3 - this.world.getDifficulty().getId()) * 4;
+         if (i < 0) {
+            i = 0;
          }
 
-         return ☃ + 3;
+         return i + 3;
       }
    }
 
-   @Override
    public Iterable<ItemStack> getHeldEquipment() {
       return this.inventoryHands;
    }
 
-   @Override
    public Iterable<ItemStack> getArmorInventoryList() {
       return this.inventoryArmor;
    }
 
-   @Override
-   public ItemStack getItemStackFromSlot(EntityEquipmentSlot var1) {
-      switch (☃.getSlotType()) {
+   public ItemStack getItemStackFromSlot(EntityEquipmentSlot slotIn) {
+      switch (slotIn.getSlotType()) {
          case HAND:
-            return this.inventoryHands.get(☃.getIndex());
+            return (ItemStack)this.inventoryHands.get(slotIn.getIndex());
          case ARMOR:
-            return this.inventoryArmor.get(☃.getIndex());
+            return (ItemStack)this.inventoryArmor.get(slotIn.getIndex());
          default:
             return ItemStack.EMPTY;
       }
    }
 
-   @Override
-   public void setItemStackToSlot(EntityEquipmentSlot var1, ItemStack var2) {
-      switch (☃.getSlotType()) {
+   public void setItemStackToSlot(EntityEquipmentSlot slotIn, ItemStack stack) {
+      switch (slotIn.getSlotType()) {
          case HAND:
-            this.inventoryHands.set(☃.getIndex(), ☃);
+            this.inventoryHands.set(slotIn.getIndex(), stack);
             break;
          case ARMOR:
-            this.inventoryArmor.set(☃.getIndex(), ☃);
+            this.inventoryArmor.set(slotIn.getIndex(), stack);
       }
    }
 
-   @Override
-   protected void dropEquipment(boolean var1, int var2) {
-      for (EntityEquipmentSlot ☃ : EntityEquipmentSlot.values()) {
-         ItemStack ☃x = this.getItemStackFromSlot(☃);
-         double ☃xx;
-         switch (☃.getSlotType()) {
+   protected void dropEquipment(boolean wasRecentlyHit, int lootingModifier) {
+      for (EntityEquipmentSlot entityequipmentslot : EntityEquipmentSlot.values()) {
+         ItemStack itemstack = this.getItemStackFromSlot(entityequipmentslot);
+         double d0;
+         switch (entityequipmentslot.getSlotType()) {
             case HAND:
-               ☃xx = this.inventoryHandsDropChances[☃.getIndex()];
+               d0 = this.inventoryHandsDropChances[entityequipmentslot.getIndex()];
                break;
             case ARMOR:
-               ☃xx = this.inventoryArmorDropChances[☃.getIndex()];
+               d0 = this.inventoryArmorDropChances[entityequipmentslot.getIndex()];
                break;
             default:
-               ☃xx = 0.0;
+               d0 = 0.0;
          }
 
-         boolean ☃x = ☃xx > 1.0;
-         if (!☃x.isEmpty() && !EnchantmentHelper.hasVanishingCurse(☃x) && (☃ || ☃x) && this.rand.nextFloat() - ☃ * 0.01F < ☃xx) {
-            if (!☃x && ☃x.isItemStackDamageable()) {
-               ☃x.setItemDamage(☃x.getMaxDamage() - this.rand.nextInt(1 + this.rand.nextInt(Math.max(☃x.getMaxDamage() - 3, 1))));
+         boolean flag = d0 > 1.0;
+         if (!itemstack.isEmpty()
+            && !EnchantmentHelper.hasVanishingCurse(itemstack)
+            && (wasRecentlyHit || flag)
+            && this.rand.nextFloat() - lootingModifier * 0.01F < d0) {
+            if (!flag && itemstack.isItemStackDamageable()) {
+               itemstack.setItemDamage(itemstack.getMaxDamage() - this.rand.nextInt(1 + this.rand.nextInt(Math.max(itemstack.getMaxDamage() - 3, 1))));
             }
 
-            this.entityDropItem(☃x, 0.0F);
+            this.entityDropItem(itemstack, 0.0F);
          }
       }
    }
 
-   protected void setEquipmentBasedOnDifficulty(DifficultyInstance var1) {
-      if (this.rand.nextFloat() < 0.15F * ☃.getClampedAdditionalDifficulty()) {
-         int ☃ = this.rand.nextInt(2);
-         float ☃x = this.world.getDifficulty() == EnumDifficulty.HARD ? 0.1F : 0.25F;
+   protected void setEquipmentBasedOnDifficulty(DifficultyInstance difficulty) {
+      if (this.rand.nextFloat() < 0.15F * difficulty.getClampedAdditionalDifficulty()) {
+         int i = this.rand.nextInt(2);
+         float f = this.world.getDifficulty() == EnumDifficulty.HARD ? 0.1F : 0.25F;
          if (this.rand.nextFloat() < 0.095F) {
-            ☃++;
+            i++;
          }
 
          if (this.rand.nextFloat() < 0.095F) {
-            ☃++;
+            i++;
          }
 
          if (this.rand.nextFloat() < 0.095F) {
-            ☃++;
+            i++;
          }
 
-         boolean ☃xx = true;
+         boolean flag = true;
 
-         for (EntityEquipmentSlot ☃xxx : EntityEquipmentSlot.values()) {
-            if (☃xxx.getSlotType() == EntityEquipmentSlot.Type.ARMOR) {
-               ItemStack ☃xxxx = this.getItemStackFromSlot(☃xxx);
-               if (!☃xx && this.rand.nextFloat() < ☃x) {
+         for (EntityEquipmentSlot entityequipmentslot : EntityEquipmentSlot.values()) {
+            if (entityequipmentslot.getSlotType() == Type.ARMOR) {
+               ItemStack itemstack = this.getItemStackFromSlot(entityequipmentslot);
+               if (!flag && this.rand.nextFloat() < f) {
                   break;
                }
 
-               ☃xx = false;
-               if (☃xxxx.isEmpty()) {
-                  Item ☃xxxxx = getArmorByChance(☃xxx, ☃);
-                  if (☃xxxxx != null) {
-                     this.setItemStackToSlot(☃xxx, new ItemStack(☃xxxxx));
+               flag = false;
+               if (itemstack.isEmpty()) {
+                  Item item = getArmorByChance(entityequipmentslot, i);
+                  if (item != null) {
+                     this.setItemStackToSlot(entityequipmentslot, new ItemStack(item));
                   }
                }
             }
@@ -805,67 +816,79 @@ protected void setEquipmentBasedOnDifficulty(DifficultyInstance var1) {
       }
    }
 
-   public static EntityEquipmentSlot getSlotForItemStack(ItemStack var0) {
-      if (☃.getItem() == Item.getItemFromBlock(Blocks.PUMPKIN) || ☃.getItem() == Items.SKULL) {
+   public static EntityEquipmentSlot getSlotForItemStack(ItemStack stack) {
+      if (Reflector.ForgeItem_getEquipmentSlot.exists()) {
+         EntityEquipmentSlot slot = (EntityEquipmentSlot)Reflector.call(stack.getItem(), Reflector.ForgeItem_getEquipmentSlot, new Object[]{stack});
+         if (slot != null) {
+            return slot;
+         }
+      }
+
+      if (stack.getItem() == Item.getItemFromBlock(Blocks.PUMPKIN) || stack.getItem() == Items.SKULL) {
          return EntityEquipmentSlot.HEAD;
-      } else if (☃.getItem() instanceof ItemArmor) {
-         return ((ItemArmor)☃.getItem()).armorType;
-      } else if (☃.getItem() == Items.ELYTRA) {
+      } else if (stack.getItem() instanceof ItemArmor) {
+         return ((ItemArmor)stack.getItem()).armorType;
+      } else if (stack.getItem() == Items.ELYTRA) {
          return EntityEquipmentSlot.CHEST;
       } else {
-         return ☃.getItem() == Items.SHIELD ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
+         boolean isShield = stack.getItem() == Items.SHIELD;
+         if (Reflector.ForgeItem_isShield.exists()) {
+            isShield = Reflector.callBoolean(stack.getItem(), Reflector.ForgeItem_isShield, new Object[]{stack, null});
+         }
+
+         return isShield ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
       }
    }
 
    @Nullable
-   public static Item getArmorByChance(EntityEquipmentSlot var0, int var1) {
-      switch (☃) {
+   public static Item getArmorByChance(EntityEquipmentSlot slotIn, int chance) {
+      switch (slotIn) {
          case HEAD:
-            if (☃ == 0) {
+            if (chance == 0) {
                return Items.LEATHER_HELMET;
-            } else if (☃ == 1) {
+            } else if (chance == 1) {
                return Items.GOLDEN_HELMET;
-            } else if (☃ == 2) {
+            } else if (chance == 2) {
                return Items.CHAINMAIL_HELMET;
-            } else if (☃ == 3) {
+            } else if (chance == 3) {
                return Items.IRON_HELMET;
-            } else if (☃ == 4) {
+            } else if (chance == 4) {
                return Items.DIAMOND_HELMET;
             }
          case CHEST:
-            if (☃ == 0) {
+            if (chance == 0) {
                return Items.LEATHER_CHESTPLATE;
-            } else if (☃ == 1) {
+            } else if (chance == 1) {
                return Items.GOLDEN_CHESTPLATE;
-            } else if (☃ == 2) {
+            } else if (chance == 2) {
                return Items.CHAINMAIL_CHESTPLATE;
-            } else if (☃ == 3) {
+            } else if (chance == 3) {
                return Items.IRON_CHESTPLATE;
-            } else if (☃ == 4) {
+            } else if (chance == 4) {
                return Items.DIAMOND_CHESTPLATE;
             }
          case LEGS:
-            if (☃ == 0) {
+            if (chance == 0) {
                return Items.LEATHER_LEGGINGS;
-            } else if (☃ == 1) {
+            } else if (chance == 1) {
                return Items.GOLDEN_LEGGINGS;
-            } else if (☃ == 2) {
+            } else if (chance == 2) {
                return Items.CHAINMAIL_LEGGINGS;
-            } else if (☃ == 3) {
+            } else if (chance == 3) {
                return Items.IRON_LEGGINGS;
-            } else if (☃ == 4) {
+            } else if (chance == 4) {
                return Items.DIAMOND_LEGGINGS;
             }
          case FEET:
-            if (☃ == 0) {
+            if (chance == 0) {
                return Items.LEATHER_BOOTS;
-            } else if (☃ == 1) {
+            } else if (chance == 1) {
                return Items.GOLDEN_BOOTS;
-            } else if (☃ == 2) {
+            } else if (chance == 2) {
                return Items.CHAINMAIL_BOOTS;
-            } else if (☃ == 3) {
+            } else if (chance == 3) {
                return Items.IRON_BOOTS;
-            } else if (☃ == 4) {
+            } else if (chance == 4) {
                return Items.DIAMOND_BOOTS;
             }
          default:
@@ -873,27 +896,29 @@ public static Item getArmorByChance(EntityEquipmentSlot var0, int var1) {
       }
    }
 
-   protected void setEnchantmentBasedOnDifficulty(DifficultyInstance var1) {
-      float ☃ = ☃.getClampedAdditionalDifficulty();
-      if (!this.getHeldItemMainhand().isEmpty() && this.rand.nextFloat() < 0.25F * ☃) {
+   protected void setEnchantmentBasedOnDifficulty(DifficultyInstance difficulty) {
+      float f = difficulty.getClampedAdditionalDifficulty();
+      if (!this.getHeldItemMainhand().isEmpty() && this.rand.nextFloat() < 0.25F * f) {
          this.setItemStackToSlot(
             EntityEquipmentSlot.MAINHAND,
-            EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItemMainhand(), (int)(5.0F + ☃ * this.rand.nextInt(18)), false)
+            EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItemMainhand(), (int)(5.0F + f * this.rand.nextInt(18)), false)
          );
       }
 
-      for (EntityEquipmentSlot ☃x : EntityEquipmentSlot.values()) {
-         if (☃x.getSlotType() == EntityEquipmentSlot.Type.ARMOR) {
-            ItemStack ☃xx = this.getItemStackFromSlot(☃x);
-            if (!☃xx.isEmpty() && this.rand.nextFloat() < 0.5F * ☃) {
-               this.setItemStackToSlot(☃x, EnchantmentHelper.addRandomEnchantment(this.rand, ☃xx, (int)(5.0F + ☃ * this.rand.nextInt(18)), false));
+      for (EntityEquipmentSlot entityequipmentslot : EntityEquipmentSlot.values()) {
+         if (entityequipmentslot.getSlotType() == Type.ARMOR) {
+            ItemStack itemstack = this.getItemStackFromSlot(entityequipmentslot);
+            if (!itemstack.isEmpty() && this.rand.nextFloat() < 0.5F * f) {
+               this.setItemStackToSlot(
+                  entityequipmentslot, EnchantmentHelper.addRandomEnchantment(this.rand, itemstack, (int)(5.0F + f * this.rand.nextInt(18)), false)
+               );
             }
          }
       }
    }
 
    @Nullable
-   public IEntityLivingData onInitialSpawn(DifficultyInstance var1, @Nullable IEntityLivingData var2) {
+   public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, @Nullable IEntityLivingData livingdata) {
       this.getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE)
          .applyModifier(new AttributeModifier("Random spawn bonus", this.rand.nextGaussian() * 0.05, 1));
       if (this.rand.nextFloat() < 0.05F) {
@@ -902,7 +927,7 @@ public IEntityLivingData onInitialSpawn(DifficultyInstance var1, @Nullable IEnti
          this.setLeftHanded(false);
       }
 
-      return ☃;
+      return livingdata;
    }
 
    public boolean canBeSteered() {
@@ -913,13 +938,13 @@ public void enablePersistence() {
       this.persistenceRequired = true;
    }
 
-   public void setDropChance(EntityEquipmentSlot var1, float var2) {
-      switch (☃.getSlotType()) {
+   public void setDropChance(EntityEquipmentSlot slotIn, float chance) {
+      switch (slotIn.getSlotType()) {
          case HAND:
-            this.inventoryHandsDropChances[☃.getIndex()] = ☃;
+            this.inventoryHandsDropChances[slotIn.getIndex()] = chance;
             break;
          case ARMOR:
-            this.inventoryArmorDropChances[☃.getIndex()] = ☃;
+            this.inventoryArmorDropChances[slotIn.getIndex()] = chance;
       }
    }
 
@@ -927,32 +952,31 @@ public boolean canPickUpLoot() {
       return this.canPickUpLoot;
    }
 
-   public void setCanPickUpLoot(boolean var1) {
-      this.canPickUpLoot = ☃;
+   public void setCanPickUpLoot(boolean canPickup) {
+      this.canPickUpLoot = canPickup;
    }
 
    public boolean isNoDespawnRequired() {
       return this.persistenceRequired;
    }
 
-   @Override
-   public final boolean processInitialInteract(EntityPlayer var1, EnumHand var2) {
-      if (this.getLeashed() && this.getLeashHolder() == ☃) {
-         this.clearLeashed(true, !☃.capabilities.isCreativeMode);
+   public final boolean processInitialInteract(EntityPlayer player, EnumHand hand) {
+      if (this.getLeashed() && this.getLeashHolder() == player) {
+         this.clearLeashed(true, !player.capabilities.isCreativeMode);
          return true;
       } else {
-         ItemStack ☃ = ☃.getHeldItem(☃);
-         if (☃.getItem() == Items.LEAD && this.canBeLeashedTo(☃)) {
-            this.setLeashHolder(☃, true);
-            ☃.shrink(1);
+         ItemStack itemstack = player.getHeldItem(hand);
+         if (itemstack.getItem() == Items.LEAD && this.canBeLeashedTo(player)) {
+            this.setLeashHolder(player, true);
+            itemstack.shrink(1);
             return true;
          } else {
-            return this.processInteract(☃, ☃) ? true : super.processInitialInteract(☃, ☃);
+            return this.processInteract(player, hand) ? true : super.processInitialInteract(player, hand);
          }
       }
    }
 
-   protected boolean processInteract(EntityPlayer var1, EnumHand var2) {
+   protected boolean processInteract(EntityPlayer player, EnumHand hand) {
       return false;
    }
 
@@ -972,21 +996,21 @@ protected void updateLeashedState() {
       }
    }
 
-   public void clearLeashed(boolean var1, boolean var2) {
+   public void clearLeashed(boolean sendPacket, boolean dropLead) {
       if (this.isLeashed) {
          this.isLeashed = false;
          this.leashHolder = null;
-         if (!this.world.isRemote && ☃) {
+         if (!this.world.isRemote && dropLead) {
             this.dropItem(Items.LEAD, 1);
          }
 
-         if (!this.world.isRemote && ☃ && this.world instanceof WorldServer) {
-            ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityAttach(this, null));
+         if (!this.world.isRemote && sendPacket && this.world instanceof WorldServer) {
+            ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityAttach(this, (Entity)null));
          }
       }
    }
 
-   public boolean canBeLeashedTo(EntityPlayer var1) {
+   public boolean canBeLeashedTo(EntityPlayer player) {
       return !this.getLeashed() && !(this instanceof IMob);
    }
 
@@ -998,10 +1022,10 @@ public Entity getLeashHolder() {
       return this.leashHolder;
    }
 
-   public void setLeashHolder(Entity var1, boolean var2) {
+   public void setLeashHolder(Entity entityIn, boolean sendAttachNotification) {
       this.isLeashed = true;
-      this.leashHolder = ☃;
-      if (!this.world.isRemote && ☃ && this.world instanceof WorldServer) {
+      this.leashHolder = entityIn;
+      if (!this.world.isRemote && sendAttachNotification && this.world instanceof WorldServer) {
          ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityAttach(this, this.leashHolder));
       }
 
@@ -1010,35 +1034,34 @@ public void setLeashHolder(Entity var1, boolean var2) {
       }
    }
 
-   @Override
-   public boolean startRiding(Entity var1, boolean var2) {
-      boolean ☃ = super.startRiding(☃, ☃);
-      if (☃ && this.getLeashed()) {
+   public boolean startRiding(Entity entityIn, boolean force) {
+      boolean flag = super.startRiding(entityIn, force);
+      if (flag && this.getLeashed()) {
          this.clearLeashed(true, true);
       }
 
-      return ☃;
+      return flag;
    }
 
    private void recreateLeash() {
       if (this.isLeashed && this.leashNBTTag != null) {
          if (this.leashNBTTag.hasUniqueId("UUID")) {
-            UUID ☃ = this.leashNBTTag.getUniqueId("UUID");
+            UUID uuid = this.leashNBTTag.getUniqueId("UUID");
 
-            for (EntityLivingBase ☃x : this.world.getEntitiesWithinAABB(EntityLivingBase.class, this.getEntityBoundingBox().grow(10.0))) {
-               if (☃x.getUniqueID().equals(☃)) {
-                  this.setLeashHolder(☃x, true);
+            for (EntityLivingBase entitylivingbase : this.world.getEntitiesWithinAABB(EntityLivingBase.class, this.getEntityBoundingBox().grow(10.0))) {
+               if (entitylivingbase.getUniqueID().equals(uuid)) {
+                  this.setLeashHolder(entitylivingbase, true);
                   break;
                }
             }
          } else if (this.leashNBTTag.hasKey("X", 99) && this.leashNBTTag.hasKey("Y", 99) && this.leashNBTTag.hasKey("Z", 99)) {
-            BlockPos ☃ = new BlockPos(this.leashNBTTag.getInteger("X"), this.leashNBTTag.getInteger("Y"), this.leashNBTTag.getInteger("Z"));
-            EntityLeashKnot ☃xx = EntityLeashKnot.getKnotForPosition(this.world, ☃);
-            if (☃xx == null) {
-               ☃xx = EntityLeashKnot.createKnot(this.world, ☃);
+            BlockPos blockpos = new BlockPos(this.leashNBTTag.getInteger("X"), this.leashNBTTag.getInteger("Y"), this.leashNBTTag.getInteger("Z"));
+            EntityLeashKnot entityleashknot = EntityLeashKnot.getKnotForPosition(this.world, blockpos);
+            if (entityleashknot == null) {
+               entityleashknot = EntityLeashKnot.createKnot(this.world, blockpos);
             }
 
-            this.setLeashHolder(☃xx, true);
+            this.setLeashHolder(entityleashknot, true);
          } else {
             this.clearLeashed(false, true);
          }
@@ -1047,78 +1070,133 @@ private void recreateLeash() {
       this.leashNBTTag = null;
    }
 
-   @Override
-   public boolean replaceItemInInventory(int var1, ItemStack var2) {
-      EntityEquipmentSlot ☃;
-      if (☃ == 98) {
-         ☃ = EntityEquipmentSlot.MAINHAND;
-      } else if (☃ == 99) {
-         ☃ = EntityEquipmentSlot.OFFHAND;
-      } else if (☃ == 100 + EntityEquipmentSlot.HEAD.getIndex()) {
-         ☃ = EntityEquipmentSlot.HEAD;
-      } else if (☃ == 100 + EntityEquipmentSlot.CHEST.getIndex()) {
-         ☃ = EntityEquipmentSlot.CHEST;
-      } else if (☃ == 100 + EntityEquipmentSlot.LEGS.getIndex()) {
-         ☃ = EntityEquipmentSlot.LEGS;
+   public boolean replaceItemInInventory(int inventorySlot, ItemStack itemStackIn) {
+      EntityEquipmentSlot entityequipmentslot;
+      if (inventorySlot == 98) {
+         entityequipmentslot = EntityEquipmentSlot.MAINHAND;
+      } else if (inventorySlot == 99) {
+         entityequipmentslot = EntityEquipmentSlot.OFFHAND;
+      } else if (inventorySlot == 100 + EntityEquipmentSlot.HEAD.getIndex()) {
+         entityequipmentslot = EntityEquipmentSlot.HEAD;
+      } else if (inventorySlot == 100 + EntityEquipmentSlot.CHEST.getIndex()) {
+         entityequipmentslot = EntityEquipmentSlot.CHEST;
+      } else if (inventorySlot == 100 + EntityEquipmentSlot.LEGS.getIndex()) {
+         entityequipmentslot = EntityEquipmentSlot.LEGS;
       } else {
-         if (☃ != 100 + EntityEquipmentSlot.FEET.getIndex()) {
+         if (inventorySlot != 100 + EntityEquipmentSlot.FEET.getIndex()) {
             return false;
          }
 
-         ☃ = EntityEquipmentSlot.FEET;
+         entityequipmentslot = EntityEquipmentSlot.FEET;
       }
 
-      if (!☃.isEmpty() && !isItemStackInSlot(☃, ☃) && ☃ != EntityEquipmentSlot.HEAD) {
+      if (!itemStackIn.isEmpty() && !isItemStackInSlot(entityequipmentslot, itemStackIn) && entityequipmentslot != EntityEquipmentSlot.HEAD) {
          return false;
       } else {
-         this.setItemStackToSlot(☃, ☃);
+         this.setItemStackToSlot(entityequipmentslot, itemStackIn);
          return true;
       }
    }
 
-   @Override
    public boolean canPassengerSteer() {
       return this.canBeSteered() && super.canPassengerSteer();
    }
 
-   public static boolean isItemStackInSlot(EntityEquipmentSlot var0, ItemStack var1) {
-      EntityEquipmentSlot ☃ = getSlotForItemStack(☃);
-      return ☃ == ☃
-         || ☃ == EntityEquipmentSlot.MAINHAND && ☃ == EntityEquipmentSlot.OFFHAND
-         || ☃ == EntityEquipmentSlot.OFFHAND && ☃ == EntityEquipmentSlot.MAINHAND;
+   public static boolean isItemStackInSlot(EntityEquipmentSlot slotIn, ItemStack stack) {
+      EntityEquipmentSlot entityequipmentslot = getSlotForItemStack(stack);
+      return entityequipmentslot == slotIn
+         || entityequipmentslot == EntityEquipmentSlot.MAINHAND && slotIn == EntityEquipmentSlot.OFFHAND
+         || entityequipmentslot == EntityEquipmentSlot.OFFHAND && slotIn == EntityEquipmentSlot.MAINHAND;
    }
 
-   @Override
    public boolean isServerWorld() {
       return super.isServerWorld() && !this.isAIDisabled();
    }
 
-   public void setNoAI(boolean var1) {
-      byte ☃ = this.dataManager.get(AI_FLAGS);
-      this.dataManager.set(AI_FLAGS, ☃ ? (byte)(☃ | 1) : (byte)(☃ & -2));
+   public void setNoAI(boolean disable) {
+      byte b0 = this.dataManager.<Byte>get(AI_FLAGS);
+      this.dataManager.set(AI_FLAGS, disable ? (byte)(b0 | 1) : (byte)(b0 & -2));
    }
 
-   public void setLeftHanded(boolean var1) {
-      byte ☃ = this.dataManager.get(AI_FLAGS);
-      this.dataManager.set(AI_FLAGS, ☃ ? (byte)(☃ | 2) : (byte)(☃ & -3));
+   public void setLeftHanded(boolean leftHanded) {
+      byte b0 = this.dataManager.<Byte>get(AI_FLAGS);
+      this.dataManager.set(AI_FLAGS, leftHanded ? (byte)(b0 | 2) : (byte)(b0 & -3));
    }
 
    public boolean isAIDisabled() {
-      return (this.dataManager.get(AI_FLAGS) & 1) != 0;
+      return (this.dataManager.<Byte>get(AI_FLAGS) & 1) != 0;
    }
 
    public boolean isLeftHanded() {
-      return (this.dataManager.get(AI_FLAGS) & 2) != 0;
+      return (this.dataManager.<Byte>get(AI_FLAGS) & 2) != 0;
    }
 
-   @Override
    public EnumHandSide getPrimaryHand() {
       return this.isLeftHanded() ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
    }
 
+   private boolean canSkipUpdate() {
+      if (this.isChild()) {
+         return false;
+      } else if (this.hurtTime > 0) {
+         return false;
+      } else if (this.ticksExisted < 20) {
+         return false;
+      } else {
+         World world = this.getEntityWorld();
+         if (world == null) {
+            return false;
+         } else if (world.playerEntities.size() != 1) {
+            return false;
+         } else {
+            Entity player = (Entity)world.playerEntities.get(0);
+            double dx = Math.max(Math.abs(this.posX - player.posX) - 16.0, 0.0);
+            double dz = Math.max(Math.abs(this.posZ - player.posZ) - 16.0, 0.0);
+            double distSq = dx * dx + dz * dz;
+            return !this.isInRangeToRenderDist(distSq);
+         }
+      }
+   }
+
+   private void onUpdateMinimal() {
+      this.idleTime++;
+      if (this instanceof EntityMob) {
+         float brightness = this.getBrightness();
+         if (brightness > 0.5F) {
+            this.idleTime += 2;
+         }
+      }
+
+      this.despawnEntity();
+   }
+
+   public Team getTeam() {
+      UUID uuid = this.getUniqueID();
+      if (this.teamUuid != uuid) {
+         this.teamUuid = uuid;
+         this.teamUuidString = uuid.toString();
+      }
+
+      return this.world.getScoreboard().getPlayersTeam(this.teamUuidString);
+   }
+
    public static enum SpawnPlacementType {
       ON_GROUND,
       IN_AIR,
       IN_WATER;
+
+      private final BiPredicate<IBlockAccess, BlockPos> spawnPredicate;
+
+      private SpawnPlacementType() {
+         this.spawnPredicate = null;
+      }
+
+      private SpawnPlacementType(BiPredicate<IBlockAccess, BlockPos> spawnPredicate) {
+         this.spawnPredicate = spawnPredicate;
+      }
+
+      public boolean canSpawnAt(World world, BlockPos pos) {
+         return this.spawnPredicate != null ? this.spawnPredicate.test(world, pos) : WorldEntitySpawner.canCreatureTypeSpawnBody(this, world, pos);
+      }
    }
 }
diff --git a/patches/net/minecraft/network/PacketThreadUtil.java b/patches/net/minecraft/network/PacketThreadUtil.java
index ab0059d..6e9c95a 100644
--- a/patches/net/minecraft/network/PacketThreadUtil.java
+++ b/patches/net/minecraft/network/PacketThreadUtil.java
@@ -1,17 +1,41 @@
 package net.minecraft.network;
 
+import net.minecraft.network.play.server.SPacketJoinGame;
+import net.minecraft.network.play.server.SPacketPlayerPosLook;
+import net.minecraft.network.play.server.SPacketRespawn;
 import net.minecraft.util.IThreadListener;
 
 public class PacketThreadUtil {
-   public static <T extends INetHandler> void checkThreadAndEnqueue(final Packet<T> var0, final T var1, IThreadListener var2) throws ThreadQuickExitException {
-      if (!☃.isCallingFromMinecraftThread()) {
-         ☃.addScheduledTask(new Runnable() {
+   public static int lastDimensionId = Integer.MIN_VALUE;
+
+   public static <T extends INetHandler> void checkThreadAndEnqueue(final Packet<T> packetIn, final T processor, IThreadListener scheduler) throws ThreadQuickExitException {
+      if (!scheduler.isCallingFromMinecraftThread()) {
+         scheduler.addScheduledTask(new Runnable() {
             @Override
             public void run() {
-               ☃.processPacket(☃);
+               PacketThreadUtil.clientPreProcessPacket(packetIn);
+               packetIn.processPacket(processor);
             }
          });
          throw ThreadQuickExitException.INSTANCE;
+      } else {
+         clientPreProcessPacket(packetIn);
+      }
+   }
+
+   protected static void clientPreProcessPacket(Packet packetIn) {
+      if (packetIn instanceof SPacketPlayerPosLook) {
+         Config.getRenderGlobal().onPlayerPositionSet();
+      }
+
+      if (packetIn instanceof SPacketRespawn) {
+         SPacketRespawn respawn = (SPacketRespawn)packetIn;
+         lastDimensionId = respawn.getDimensionID();
+      } else if (packetIn instanceof SPacketJoinGame) {
+         SPacketJoinGame joinGame = (SPacketJoinGame)packetIn;
+         lastDimensionId = joinGame.getDimension();
+      } else {
+         lastDimensionId = Integer.MIN_VALUE;
       }
    }
 }
diff --git a/patches/net/minecraft/network/datasync/EntityDataManager.java b/patches/net/minecraft/network/datasync/EntityDataManager.java
index d6a97c7..3601b21 100644
--- a/patches/net/minecraft/network/datasync/EntityDataManager.java
+++ b/patches/net/minecraft/network/datasync/EntityDataManager.java
@@ -13,8 +13,11 @@
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
+import net.minecraft.init.Biomes;
 import net.minecraft.network.PacketBuffer;
 import net.minecraft.util.ReportedException;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.biome.Biome;
 import org.apache.commons.lang3.ObjectUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -27,102 +30,104 @@ public class EntityDataManager {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private boolean empty = true;
    private boolean dirty;
+   public Biome spawnBiome = Biomes.PLAINS;
+   public BlockPos spawnPosition = BlockPos.ORIGIN;
 
-   public EntityDataManager(Entity var1) {
-      this.entity = ☃;
+   public EntityDataManager(Entity entityIn) {
+      this.entity = entityIn;
    }
 
-   public static <T> DataParameter<T> createKey(Class<? extends Entity> var0, DataSerializer<T> var1) {
+   public static <T> DataParameter<T> createKey(Class<? extends Entity> clazz, DataSerializer<T> serializer) {
       if (LOGGER.isDebugEnabled()) {
          try {
-            Class<?> ☃ = Class.forName(Thread.currentThread().getStackTrace()[2].getClassName());
-            if (!☃.equals(☃)) {
-               LOGGER.debug("defineId called for: {} from {}", ☃, ☃, new RuntimeException());
+            Class<?> oclass = Class.forName(Thread.currentThread().getStackTrace()[2].getClassName());
+            if (!oclass.equals(clazz)) {
+               LOGGER.debug("defineId called for: {} from {}", clazz, oclass, new RuntimeException());
             }
          } catch (ClassNotFoundException var5) {
          }
       }
 
-      int ☃;
-      if (NEXT_ID_MAP.containsKey(☃)) {
-         ☃ = NEXT_ID_MAP.get(☃) + 1;
+      int j;
+      if (NEXT_ID_MAP.containsKey(clazz)) {
+         j = NEXT_ID_MAP.get(clazz) + 1;
       } else {
-         int ☃x = 0;
-         Class<?> ☃xx = ☃;
+         int i = 0;
+         Class<?> oclass1 = clazz;
 
-         while (☃xx != Entity.class) {
-            ☃xx = ☃xx.getSuperclass();
-            if (NEXT_ID_MAP.containsKey(☃xx)) {
-               ☃x = NEXT_ID_MAP.get(☃xx) + 1;
+         while (oclass1 != Entity.class) {
+            oclass1 = oclass1.getSuperclass();
+            if (NEXT_ID_MAP.containsKey(oclass1)) {
+               i = NEXT_ID_MAP.get(oclass1) + 1;
                break;
             }
          }
 
-         ☃ = ☃x;
+         j = i;
       }
 
-      if (☃ > 254) {
-         throw new IllegalArgumentException("Data value id is too big with " + ☃ + "! (Max is " + 254 + ")");
+      if (j > 254) {
+         throw new IllegalArgumentException("Data value id is too big with " + j + "! (Max is " + 254 + ")");
       } else {
-         NEXT_ID_MAP.put(☃, ☃);
-         return ☃.createKey(☃);
+         NEXT_ID_MAP.put(clazz, j);
+         return serializer.createKey(j);
       }
    }
 
-   public <T> void register(DataParameter<T> var1, T var2) {
-      int ☃ = ☃.getId();
-      if (☃ > 254) {
-         throw new IllegalArgumentException("Data value id is too big with " + ☃ + "! (Max is " + 254 + ")");
-      } else if (this.entries.containsKey(☃)) {
-         throw new IllegalArgumentException("Duplicate id value for " + ☃ + "!");
-      } else if (DataSerializers.getSerializerId(☃.getSerializer()) < 0) {
-         throw new IllegalArgumentException("Unregistered serializer " + ☃.getSerializer() + " for " + ☃ + "!");
+   public <T> void register(DataParameter<T> key, T value) {
+      int i = key.getId();
+      if (i > 254) {
+         throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 254 + ")");
+      } else if (this.entries.containsKey(i)) {
+         throw new IllegalArgumentException("Duplicate id value for " + i + "!");
+      } else if (DataSerializers.getSerializerId(key.getSerializer()) < 0) {
+         throw new IllegalArgumentException("Unregistered serializer " + key.getSerializer() + " for " + i + "!");
       } else {
-         this.setEntry(☃, ☃);
+         this.setEntry(key, value);
       }
    }
 
-   private <T> void setEntry(DataParameter<T> var1, T var2) {
-      EntityDataManager.DataEntry<T> ☃ = new EntityDataManager.DataEntry<>(☃, ☃);
+   private <T> void setEntry(DataParameter<T> key, T value) {
+      EntityDataManager.DataEntry<T> dataentry = new EntityDataManager.DataEntry<>(key, value);
       this.lock.writeLock().lock();
-      this.entries.put(☃.getId(), ☃);
+      this.entries.put(key.getId(), dataentry);
       this.empty = false;
       this.lock.writeLock().unlock();
    }
 
-   private <T> EntityDataManager.DataEntry<T> getEntry(DataParameter<T> var1) {
+   private <T> EntityDataManager.DataEntry<T> getEntry(DataParameter<T> key) {
       this.lock.readLock().lock();
 
-      EntityDataManager.DataEntry<T> ☃;
+      EntityDataManager.DataEntry<T> dataentry;
       try {
-         ☃ = (EntityDataManager.DataEntry<T>)this.entries.get(☃.getId());
+         dataentry = (EntityDataManager.DataEntry<T>)this.entries.get(key.getId());
       } catch (Throwable var6) {
-         CrashReport ☃x = CrashReport.makeCrashReport(var6, "Getting synched entity data");
-         CrashReportCategory ☃xx = ☃x.makeCategory("Synched entity data");
-         ☃xx.addCrashSection("Data ID", ☃);
-         throw new ReportedException(☃x);
+         CrashReport crashreport = CrashReport.makeCrashReport(var6, "Getting synched entity data");
+         CrashReportCategory crashreportcategory = crashreport.makeCategory("Synched entity data");
+         crashreportcategory.addCrashSection("Data ID", key);
+         throw new ReportedException(crashreport);
       }
 
       this.lock.readLock().unlock();
-      return ☃;
+      return dataentry;
    }
 
-   public <T> T get(DataParameter<T> var1) {
-      return this.getEntry(☃).getValue();
+   public <T> T get(DataParameter<T> key) {
+      return this.<T>getEntry(key).getValue();
    }
 
-   public <T> void set(DataParameter<T> var1, T var2) {
-      EntityDataManager.DataEntry<T> ☃ = this.getEntry(☃);
-      if (ObjectUtils.notEqual(☃, ☃.getValue())) {
-         ☃.setValue(☃);
-         this.entity.notifyDataManagerChange(☃);
-         ☃.setDirty(true);
+   public <T> void set(DataParameter<T> key, T value) {
+      EntityDataManager.DataEntry<T> dataentry = this.getEntry(key);
+      if (ObjectUtils.notEqual(value, dataentry.getValue())) {
+         dataentry.setValue(value);
+         this.entity.notifyDataManagerChange(key);
+         dataentry.setDirty(true);
          this.dirty = true;
       }
    }
 
-   public <T> void setDirty(DataParameter<T> var1) {
-      this.getEntry(☃).dirty = true;
+   public <T> void setDirty(DataParameter<T> key) {
+      this.getEntry(key).dirty = true;
       this.dirty = true;
    }
 
@@ -130,33 +135,33 @@ public boolean isDirty() {
       return this.dirty;
    }
 
-   public static void writeEntries(List<EntityDataManager.DataEntry<?>> var0, PacketBuffer var1) throws IOException {
-      if (☃ != null) {
-         int ☃ = 0;
+   public static void writeEntries(List<EntityDataManager.DataEntry<?>> entriesIn, PacketBuffer buf) throws IOException {
+      if (entriesIn != null) {
+         int i = 0;
 
-         for (int ☃x = ☃.size(); ☃ < ☃x; ☃++) {
-            EntityDataManager.DataEntry<?> ☃xx = ☃.get(☃);
-            writeEntry(☃, ☃xx);
+         for (int j = entriesIn.size(); i < j; i++) {
+            EntityDataManager.DataEntry<?> dataentry = entriesIn.get(i);
+            writeEntry(buf, dataentry);
          }
       }
 
-      ☃.writeByte(255);
+      buf.writeByte(255);
    }
 
    @Nullable
    public List<EntityDataManager.DataEntry<?>> getDirty() {
-      List<EntityDataManager.DataEntry<?>> ☃ = null;
+      List<EntityDataManager.DataEntry<?>> list = null;
       if (this.dirty) {
          this.lock.readLock().lock();
 
-         for (EntityDataManager.DataEntry<?> ☃x : this.entries.values()) {
-            if (☃x.isDirty()) {
-               ☃x.setDirty(false);
-               if (☃ == null) {
-                  ☃ = Lists.newArrayList();
+         for (EntityDataManager.DataEntry<?> dataentry : this.entries.values()) {
+            if (dataentry.isDirty()) {
+               dataentry.setDirty(false);
+               if (list == null) {
+                  list = Lists.newArrayList();
                }
 
-               ☃.add(☃x.copy());
+               list.add(dataentry.copy());
             }
          }
 
@@ -164,79 +169,79 @@ public List<EntityDataManager.DataEntry<?>> getDirty() {
       }
 
       this.dirty = false;
-      return ☃;
+      return list;
    }
 
-   public void writeEntries(PacketBuffer var1) throws IOException {
+   public void writeEntries(PacketBuffer buf) throws IOException {
       this.lock.readLock().lock();
 
-      for (EntityDataManager.DataEntry<?> ☃ : this.entries.values()) {
-         writeEntry(☃, ☃);
+      for (EntityDataManager.DataEntry<?> dataentry : this.entries.values()) {
+         writeEntry(buf, dataentry);
       }
 
       this.lock.readLock().unlock();
-      ☃.writeByte(255);
+      buf.writeByte(255);
    }
 
    @Nullable
    public List<EntityDataManager.DataEntry<?>> getAll() {
-      List<EntityDataManager.DataEntry<?>> ☃ = null;
+      List<EntityDataManager.DataEntry<?>> list = null;
       this.lock.readLock().lock();
 
-      for (EntityDataManager.DataEntry<?> ☃x : this.entries.values()) {
-         if (☃ == null) {
-            ☃ = Lists.newArrayList();
+      for (EntityDataManager.DataEntry<?> dataentry : this.entries.values()) {
+         if (list == null) {
+            list = Lists.newArrayList();
          }
 
-         ☃.add(☃x.copy());
+         list.add(dataentry.copy());
       }
 
       this.lock.readLock().unlock();
-      return ☃;
+      return list;
    }
 
-   private static <T> void writeEntry(PacketBuffer var0, EntityDataManager.DataEntry<T> var1) throws IOException {
-      DataParameter<T> ☃ = ☃.getKey();
-      int ☃x = DataSerializers.getSerializerId(☃.getSerializer());
-      if (☃x < 0) {
-         throw new EncoderException("Unknown serializer type " + ☃.getSerializer());
+   private static <T> void writeEntry(PacketBuffer buf, EntityDataManager.DataEntry<T> entry) throws IOException {
+      DataParameter<T> dataparameter = entry.getKey();
+      int i = DataSerializers.getSerializerId(dataparameter.getSerializer());
+      if (i < 0) {
+         throw new EncoderException("Unknown serializer type " + dataparameter.getSerializer());
       } else {
-         ☃.writeByte(☃.getId());
-         ☃.writeVarInt(☃x);
-         ☃.getSerializer().write(☃, ☃.getValue());
+         buf.writeByte(dataparameter.getId());
+         buf.writeVarInt(i);
+         dataparameter.getSerializer().write(buf, entry.getValue());
       }
    }
 
    @Nullable
-   public static List<EntityDataManager.DataEntry<?>> readEntries(PacketBuffer var0) throws IOException {
-      List<EntityDataManager.DataEntry<?>> ☃ = null;
+   public static List<EntityDataManager.DataEntry<?>> readEntries(PacketBuffer buf) throws IOException {
+      List<EntityDataManager.DataEntry<?>> list = null;
 
-      int ☃x;
-      while ((☃x = ☃.readUnsignedByte()) != 255) {
-         if (☃ == null) {
-            ☃ = Lists.newArrayList();
+      int i;
+      while ((i = buf.readUnsignedByte()) != 255) {
+         if (list == null) {
+            list = Lists.newArrayList();
          }
 
-         int ☃xx = ☃.readVarInt();
-         DataSerializer<?> ☃xxx = DataSerializers.getSerializer(☃xx);
-         if (☃xxx == null) {
-            throw new DecoderException("Unknown serializer type " + ☃xx);
+         int j = buf.readVarInt();
+         DataSerializer<?> dataserializer = DataSerializers.getSerializer(j);
+         if (dataserializer == null) {
+            throw new DecoderException("Unknown serializer type " + j);
          }
 
-         ☃.add(new EntityDataManager.DataEntry<>(☃xxx.createKey(☃x), ☃xxx.read(☃)));
+         list.add(new EntityDataManager.DataEntry<>(dataserializer.createKey(i), dataserializer.read(buf)));
       }
 
-      return ☃;
+      return list;
    }
 
-   public void setEntryValues(List<EntityDataManager.DataEntry<?>> var1) {
+   public void setEntryValues(List<EntityDataManager.DataEntry<?>> entriesIn) {
       this.lock.writeLock().lock();
 
-      for (EntityDataManager.DataEntry<?> ☃ : ☃) {
-         EntityDataManager.DataEntry<?> ☃x = this.entries.get(☃.getKey().getId());
-         if (☃x != null) {
-            this.setEntryValue(☃x, ☃);
-            this.entity.notifyDataManagerChange(☃.getKey());
+      for (EntityDataManager.DataEntry<?> dataentry : entriesIn) {
+         EntityDataManager.DataEntry<?> dataentry1 = this.entries.get(dataentry.getKey().getId());
+         if (dataentry1 != null) {
+            this.setEntryValue(dataentry1, dataentry);
+            this.entity.notifyDataManagerChange(dataentry.getKey());
          }
       }
 
@@ -244,8 +249,8 @@ public void setEntryValues(List<EntityDataManager.DataEntry<?>> var1) {
       this.dirty = true;
    }
 
-   protected <T> void setEntryValue(EntityDataManager.DataEntry<T> var1, EntityDataManager.DataEntry<?> var2) {
-      ☃.setValue((T)☃.getValue());
+   protected <T> void setEntryValue(EntityDataManager.DataEntry<T> target, EntityDataManager.DataEntry<?> source) {
+      target.setValue((T)source.getValue());
    }
 
    public boolean isEmpty() {
@@ -256,8 +261,8 @@ public void setClean() {
       this.dirty = false;
       this.lock.readLock().lock();
 
-      for (EntityDataManager.DataEntry<?> ☃ : this.entries.values()) {
-         ☃.setDirty(false);
+      for (EntityDataManager.DataEntry<?> dataentry : this.entries.values()) {
+         dataentry.setDirty(false);
       }
 
       this.lock.readLock().unlock();
@@ -268,9 +273,9 @@ public static class DataEntry<T> {
       private T value;
       private boolean dirty;
 
-      public DataEntry(DataParameter<T> var1, T var2) {
-         this.key = ☃;
-         this.value = ☃;
+      public DataEntry(DataParameter<T> keyIn, T valueIn) {
+         this.key = keyIn;
+         this.value = valueIn;
          this.dirty = true;
       }
 
@@ -278,8 +283,8 @@ public DataParameter<T> getKey() {
          return this.key;
       }
 
-      public void setValue(T var1) {
-         this.value = ☃;
+      public void setValue(T valueIn) {
+         this.value = valueIn;
       }
 
       public T getValue() {
@@ -290,12 +295,12 @@ public boolean isDirty() {
          return this.dirty;
       }
 
-      public void setDirty(boolean var1) {
-         this.dirty = ☃;
+      public void setDirty(boolean dirtyIn) {
+         this.dirty = dirtyIn;
       }
 
       public EntityDataManager.DataEntry<T> copy() {
-         return new EntityDataManager.DataEntry<>(this.key, this.key.getSerializer().copyValue(this.value));
+         return new EntityDataManager.DataEntry<>(this.key, (T)this.key.getSerializer().copyValue(this.value));
       }
    }
 }
diff --git a/patches/net/minecraft/potion/PotionUtils.java b/patches/net/minecraft/potion/PotionUtils.java
index bd07466..546c205 100644
--- a/patches/net/minecraft/potion/PotionUtils.java
+++ b/patches/net/minecraft/potion/PotionUtils.java
@@ -17,207 +17,214 @@
 import net.minecraft.util.Tuple;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.util.text.translation.I18n;
+import net.optifine.CustomColors;
 
 public class PotionUtils {
-   public static List<PotionEffect> getEffectsFromStack(ItemStack var0) {
-      return getEffectsFromTag(☃.getTagCompound());
+   public static List<PotionEffect> getEffectsFromStack(ItemStack stack) {
+      return getEffectsFromTag(stack.getTagCompound());
    }
 
-   public static List<PotionEffect> mergeEffects(PotionType var0, Collection<PotionEffect> var1) {
-      List<PotionEffect> ☃ = Lists.newArrayList();
-      ☃.addAll(☃.getEffects());
-      ☃.addAll(☃);
-      return ☃;
+   public static List<PotionEffect> mergeEffects(PotionType potionIn, Collection<PotionEffect> effects) {
+      List<PotionEffect> list = Lists.newArrayList();
+      list.addAll(potionIn.getEffects());
+      list.addAll(effects);
+      return list;
    }
 
-   public static List<PotionEffect> getEffectsFromTag(@Nullable NBTTagCompound var0) {
-      List<PotionEffect> ☃ = Lists.newArrayList();
-      ☃.addAll(getPotionTypeFromNBT(☃).getEffects());
-      addCustomPotionEffectToList(☃, ☃);
-      return ☃;
+   public static List<PotionEffect> getEffectsFromTag(@Nullable NBTTagCompound tag) {
+      List<PotionEffect> list = Lists.newArrayList();
+      list.addAll(getPotionTypeFromNBT(tag).getEffects());
+      addCustomPotionEffectToList(tag, list);
+      return list;
    }
 
-   public static List<PotionEffect> getFullEffectsFromItem(ItemStack var0) {
-      return getFullEffectsFromTag(☃.getTagCompound());
+   public static List<PotionEffect> getFullEffectsFromItem(ItemStack itemIn) {
+      return getFullEffectsFromTag(itemIn.getTagCompound());
    }
 
-   public static List<PotionEffect> getFullEffectsFromTag(@Nullable NBTTagCompound var0) {
-      List<PotionEffect> ☃ = Lists.newArrayList();
-      addCustomPotionEffectToList(☃, ☃);
-      return ☃;
+   public static List<PotionEffect> getFullEffectsFromTag(@Nullable NBTTagCompound tag) {
+      List<PotionEffect> list = Lists.newArrayList();
+      addCustomPotionEffectToList(tag, list);
+      return list;
    }
 
-   public static void addCustomPotionEffectToList(@Nullable NBTTagCompound var0, List<PotionEffect> var1) {
-      if (☃ != null && ☃.hasKey("CustomPotionEffects", 9)) {
-         NBTTagList ☃ = ☃.getTagList("CustomPotionEffects", 10);
+   public static void addCustomPotionEffectToList(@Nullable NBTTagCompound tag, List<PotionEffect> effectList) {
+      if (tag != null && tag.hasKey("CustomPotionEffects", 9)) {
+         NBTTagList nbttaglist = tag.getTagList("CustomPotionEffects", 10);
 
-         for (int ☃x = 0; ☃x < ☃.tagCount(); ☃x++) {
-            NBTTagCompound ☃xx = ☃.getCompoundTagAt(☃x);
-            PotionEffect ☃xxx = PotionEffect.readCustomPotionEffectFromNBT(☃xx);
-            if (☃xxx != null) {
-               ☃.add(☃xxx);
+         for (int i = 0; i < nbttaglist.tagCount(); i++) {
+            NBTTagCompound nbttagcompound = nbttaglist.getCompoundTagAt(i);
+            PotionEffect potioneffect = PotionEffect.readCustomPotionEffectFromNBT(nbttagcompound);
+            if (potioneffect != null) {
+               effectList.add(potioneffect);
             }
          }
       }
    }
 
-   public static int getColor(ItemStack var0) {
-      NBTTagCompound ☃ = ☃.getTagCompound();
-      if (☃ != null && ☃.hasKey("CustomPotionColor", 99)) {
-         return ☃.getInteger("CustomPotionColor");
+   public static int getColor(ItemStack p_190932_0_) {
+      NBTTagCompound nbttagcompound = p_190932_0_.getTagCompound();
+      if (nbttagcompound != null && nbttagcompound.hasKey("CustomPotionColor", 99)) {
+         return nbttagcompound.getInteger("CustomPotionColor");
       } else {
-         return getPotionFromItem(☃) == PotionTypes.EMPTY ? 16253176 : getPotionColorFromEffectList(getEffectsFromStack(☃));
+         return getPotionFromItem(p_190932_0_) == PotionTypes.EMPTY ? 16253176 : getPotionColorFromEffectList(getEffectsFromStack(p_190932_0_));
       }
    }
 
-   public static int getPotionColor(PotionType var0) {
-      return ☃ == PotionTypes.EMPTY ? 16253176 : getPotionColorFromEffectList(☃.getEffects());
+   public static int getPotionColor(PotionType potionIn) {
+      return potionIn == PotionTypes.EMPTY ? 16253176 : getPotionColorFromEffectList(potionIn.getEffects());
    }
 
-   public static int getPotionColorFromEffectList(Collection<PotionEffect> var0) {
-      int ☃ = 3694022;
-      if (☃.isEmpty()) {
-         return 3694022;
+   public static int getPotionColorFromEffectList(Collection<PotionEffect> effects) {
+      int i = 3694022;
+      if (effects.isEmpty()) {
+         return Config.isCustomColors() ? CustomColors.getPotionColor(null, i) : 3694022;
       } else {
-         float ☃x = 0.0F;
-         float ☃xx = 0.0F;
-         float ☃xxx = 0.0F;
-         int ☃xxxx = 0;
-
-         for (PotionEffect ☃xxxxx : ☃) {
-            if (☃xxxxx.doesShowParticles()) {
-               int ☃xxxxxx = ☃xxxxx.getPotion().getLiquidColor();
-               int ☃xxxxxxx = ☃xxxxx.getAmplifier() + 1;
-               ☃x += ☃xxxxxxx * (☃xxxxxx >> 16 & 0xFF) / 255.0F;
-               ☃xx += ☃xxxxxxx * (☃xxxxxx >> 8 & 0xFF) / 255.0F;
-               ☃xxx += ☃xxxxxxx * (☃xxxxxx >> 0 & 0xFF) / 255.0F;
-               ☃xxxx += ☃xxxxxxx;
+         float f = 0.0F;
+         float f1 = 0.0F;
+         float f2 = 0.0F;
+         int j = 0;
+
+         for (PotionEffect potioneffect : effects) {
+            if (potioneffect.doesShowParticles()) {
+               int k = potioneffect.getPotion().getLiquidColor();
+               if (Config.isCustomColors()) {
+                  k = CustomColors.getPotionColor(potioneffect.getPotion(), k);
+               }
+
+               int l = potioneffect.getAmplifier() + 1;
+               f += l * (k >> 16 & 0xFF) / 255.0F;
+               f1 += l * (k >> 8 & 0xFF) / 255.0F;
+               f2 += l * (k >> 0 & 0xFF) / 255.0F;
+               j += l;
             }
          }
 
-         if (☃xxxx == 0) {
+         if (j == 0) {
             return 0;
          } else {
-            ☃x = ☃x / ☃xxxx * 255.0F;
-            ☃xx = ☃xx / ☃xxxx * 255.0F;
-            ☃xxx = ☃xxx / ☃xxxx * 255.0F;
-            return (int)☃x << 16 | (int)☃xx << 8 | (int)☃xxx;
+            f = f / j * 255.0F;
+            f1 = f1 / j * 255.0F;
+            f2 = f2 / j * 255.0F;
+            return (int)f << 16 | (int)f1 << 8 | (int)f2;
          }
       }
    }
 
-   public static PotionType getPotionFromItem(ItemStack var0) {
-      return getPotionTypeFromNBT(☃.getTagCompound());
+   public static PotionType getPotionFromItem(ItemStack itemIn) {
+      return getPotionTypeFromNBT(itemIn.getTagCompound());
    }
 
-   public static PotionType getPotionTypeFromNBT(@Nullable NBTTagCompound var0) {
-      return ☃ == null ? PotionTypes.EMPTY : PotionType.getPotionTypeForName(☃.getString("Potion"));
+   public static PotionType getPotionTypeFromNBT(@Nullable NBTTagCompound tag) {
+      return tag == null ? PotionTypes.EMPTY : PotionType.getPotionTypeForName(tag.getString("Potion"));
    }
 
-   public static ItemStack addPotionToItemStack(ItemStack var0, PotionType var1) {
-      ResourceLocation ☃ = PotionType.REGISTRY.getNameForObject(☃);
-      if (☃ == PotionTypes.EMPTY) {
-         if (☃.hasTagCompound()) {
-            NBTTagCompound ☃x = ☃.getTagCompound();
-            ☃x.removeTag("Potion");
-            if (☃x.isEmpty()) {
-               ☃.setTagCompound(null);
+   public static ItemStack addPotionToItemStack(ItemStack itemIn, PotionType potionIn) {
+      ResourceLocation resourcelocation = (ResourceLocation)PotionType.REGISTRY.getNameForObject(potionIn);
+      if (potionIn == PotionTypes.EMPTY) {
+         if (itemIn.hasTagCompound()) {
+            NBTTagCompound nbttagcompound = itemIn.getTagCompound();
+            nbttagcompound.removeTag("Potion");
+            if (nbttagcompound.isEmpty()) {
+               itemIn.setTagCompound((NBTTagCompound)null);
             }
          }
       } else {
-         NBTTagCompound ☃x = ☃.hasTagCompound() ? ☃.getTagCompound() : new NBTTagCompound();
-         ☃x.setString("Potion", ☃.toString());
-         ☃.setTagCompound(☃x);
+         NBTTagCompound nbttagcompound1 = itemIn.hasTagCompound() ? itemIn.getTagCompound() : new NBTTagCompound();
+         nbttagcompound1.setString("Potion", resourcelocation.toString());
+         itemIn.setTagCompound(nbttagcompound1);
       }
 
-      return ☃;
+      return itemIn;
    }
 
-   public static ItemStack appendEffects(ItemStack var0, Collection<PotionEffect> var1) {
-      if (☃.isEmpty()) {
-         return ☃;
+   public static ItemStack appendEffects(ItemStack itemIn, Collection<PotionEffect> effects) {
+      if (effects.isEmpty()) {
+         return itemIn;
       } else {
-         NBTTagCompound ☃ = (NBTTagCompound)MoreObjects.firstNonNull(☃.getTagCompound(), new NBTTagCompound());
-         NBTTagList ☃x = ☃.getTagList("CustomPotionEffects", 9);
+         NBTTagCompound nbttagcompound = (NBTTagCompound)MoreObjects.firstNonNull(itemIn.getTagCompound(), new NBTTagCompound());
+         NBTTagList nbttaglist = nbttagcompound.getTagList("CustomPotionEffects", 9);
 
-         for (PotionEffect ☃xx : ☃) {
-            ☃x.appendTag(☃xx.writeCustomPotionEffectToNBT(new NBTTagCompound()));
+         for (PotionEffect potioneffect : effects) {
+            nbttaglist.appendTag(potioneffect.writeCustomPotionEffectToNBT(new NBTTagCompound()));
          }
 
-         ☃.setTag("CustomPotionEffects", ☃x);
-         ☃.setTagCompound(☃);
-         return ☃;
+         nbttagcompound.setTag("CustomPotionEffects", nbttaglist);
+         itemIn.setTagCompound(nbttagcompound);
+         return itemIn;
       }
    }
 
-   public static void addPotionTooltip(ItemStack var0, List<String> var1, float var2) {
-      List<PotionEffect> ☃ = getEffectsFromStack(☃);
-      List<Tuple<String, AttributeModifier>> ☃x = Lists.newArrayList();
-      if (☃.isEmpty()) {
-         String ☃xx = I18n.translateToLocal("effect.none").trim();
-         ☃.add(TextFormatting.GRAY + ☃xx);
+   public static void addPotionTooltip(ItemStack itemIn, List<String> lores, float durationFactor) {
+      List<PotionEffect> list = getEffectsFromStack(itemIn);
+      List<Tuple<String, AttributeModifier>> list1 = Lists.newArrayList();
+      if (list.isEmpty()) {
+         String s = I18n.translateToLocal("effect.none").trim();
+         lores.add(TextFormatting.GRAY + s);
       } else {
-         for (PotionEffect ☃xx : ☃) {
-            String ☃xxx = I18n.translateToLocal(☃xx.getEffectName()).trim();
-            Potion ☃xxxx = ☃xx.getPotion();
-            Map<IAttribute, AttributeModifier> ☃xxxxx = ☃xxxx.getAttributeModifierMap();
-            if (!☃xxxxx.isEmpty()) {
-               for (Entry<IAttribute, AttributeModifier> ☃xxxxxx : ☃xxxxx.entrySet()) {
-                  AttributeModifier ☃xxxxxxx = ☃xxxxxx.getValue();
-                  AttributeModifier ☃xxxxxxxx = new AttributeModifier(
-                     ☃xxxxxxx.getName(), ☃xxxx.getAttributeModifierAmount(☃xx.getAmplifier(), ☃xxxxxxx), ☃xxxxxxx.getOperation()
+         for (PotionEffect potioneffect : list) {
+            String s1 = I18n.translateToLocal(potioneffect.getEffectName()).trim();
+            Potion potion = potioneffect.getPotion();
+            Map<IAttribute, AttributeModifier> map = potion.getAttributeModifierMap();
+            if (!map.isEmpty()) {
+               for (Entry<IAttribute, AttributeModifier> entry : map.entrySet()) {
+                  AttributeModifier attributemodifier = entry.getValue();
+                  AttributeModifier attributemodifier1 = new AttributeModifier(
+                     attributemodifier.getName(),
+                     potion.getAttributeModifierAmount(potioneffect.getAmplifier(), attributemodifier),
+                     attributemodifier.getOperation()
                   );
-                  ☃x.add(new Tuple<>(☃xxxxxx.getKey().getName(), ☃xxxxxxxx));
+                  list1.add(new Tuple(entry.getKey().getName(), attributemodifier1));
                }
             }
 
-            if (☃xx.getAmplifier() > 0) {
-               ☃xxx = ☃xxx + " " + I18n.translateToLocal("potion.potency." + ☃xx.getAmplifier()).trim();
+            if (potioneffect.getAmplifier() > 0) {
+               s1 = s1 + " " + I18n.translateToLocal("potion.potency." + potioneffect.getAmplifier()).trim();
             }
 
-            if (☃xx.getDuration() > 20) {
-               ☃xxx = ☃xxx + " (" + Potion.getPotionDurationString(☃xx, ☃) + ")";
+            if (potioneffect.getDuration() > 20) {
+               s1 = s1 + " (" + Potion.getPotionDurationString(potioneffect, durationFactor) + ")";
             }
 
-            if (☃xxxx.isBadEffect()) {
-               ☃.add(TextFormatting.RED + ☃xxx);
+            if (potion.isBadEffect()) {
+               lores.add(TextFormatting.RED + s1);
             } else {
-               ☃.add(TextFormatting.BLUE + ☃xxx);
+               lores.add(TextFormatting.BLUE + s1);
             }
          }
       }
 
-      if (!☃x.isEmpty()) {
-         ☃.add("");
-         ☃.add(TextFormatting.DARK_PURPLE + I18n.translateToLocal("potion.whenDrank"));
+      if (!list1.isEmpty()) {
+         lores.add("");
+         lores.add(TextFormatting.DARK_PURPLE + I18n.translateToLocal("potion.whenDrank"));
 
-         for (Tuple<String, AttributeModifier> ☃xx : ☃x) {
-            AttributeModifier ☃xxxxxx = ☃xx.getSecond();
-            double ☃xxxxxxx = ☃xxxxxx.getAmount();
-            double ☃xxxxxxxx;
-            if (☃xxxxxx.getOperation() != 1 && ☃xxxxxx.getOperation() != 2) {
-               ☃xxxxxxxx = ☃xxxxxx.getAmount();
+         for (Tuple<String, AttributeModifier> tuple : list1) {
+            AttributeModifier attributemodifier2 = (AttributeModifier)tuple.getSecond();
+            double d0 = attributemodifier2.getAmount();
+            double d1;
+            if (attributemodifier2.getOperation() != 1 && attributemodifier2.getOperation() != 2) {
+               d1 = attributemodifier2.getAmount();
             } else {
-               ☃xxxxxxxx = ☃xxxxxx.getAmount() * 100.0;
+               d1 = attributemodifier2.getAmount() * 100.0;
             }
 
-            if (☃xxxxxxx > 0.0) {
-               ☃.add(
+            if (d0 > 0.0) {
+               lores.add(
                   TextFormatting.BLUE
                      + I18n.translateToLocalFormatted(
-                        "attribute.modifier.plus." + ☃xxxxxx.getOperation(),
-                        ItemStack.DECIMALFORMAT.format(☃xxxxxxxx),
-                        I18n.translateToLocal("attribute.name." + ☃xx.getFirst())
+                        "attribute.modifier.plus." + attributemodifier2.getOperation(),
+                        ItemStack.DECIMALFORMAT.format(d1),
+                        I18n.translateToLocal("attribute.name." + (String)tuple.getFirst())
                      )
                );
-            } else if (☃xxxxxxx < 0.0) {
-               ☃xxxxxxxx *= -1.0;
-               ☃.add(
+            } else if (d0 < 0.0) {
+               d1 *= -1.0;
+               lores.add(
                   TextFormatting.RED
                      + I18n.translateToLocalFormatted(
-                        "attribute.modifier.take." + ☃xxxxxx.getOperation(),
-                        ItemStack.DECIMALFORMAT.format(☃xxxxxxxx),
-                        I18n.translateToLocal("attribute.name." + ☃xx.getFirst())
+                        "attribute.modifier.take." + attributemodifier2.getOperation(),
+                        ItemStack.DECIMALFORMAT.format(d1),
+                        I18n.translateToLocal("attribute.name." + (String)tuple.getFirst())
                      )
                );
             }
diff --git a/patches/net/minecraft/profiler/Profiler.java b/patches/net/minecraft/profiler/Profiler.java
index cf52040..2bdad0f 100644
--- a/patches/net/minecraft/profiler/Profiler.java
+++ b/patches/net/minecraft/profiler/Profiler.java
@@ -6,6 +6,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.function.Supplier;
+import net.minecraft.client.renderer.GlStateManager;
+import net.optifine.Lagometer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -16,134 +18,183 @@ public class Profiler {
    public boolean profilingEnabled;
    private String profilingSection = "";
    private final Map<String, Long> profilingMap = Maps.newHashMap();
+   public boolean profilerGlobalEnabled = true;
+   private boolean profilerLocalEnabled = this.profilerGlobalEnabled;
+   private static final String SCHEDULED_EXECUTABLES = "scheduledExecutables";
+   private static final String TICK = "tick";
+   private static final String PRE_RENDER_ERRORS = "preRenderErrors";
+   private static final String RENDER = "render";
+   private static final String DISPLAY = "display";
+   private static final int HASH_SCHEDULED_EXECUTABLES = "scheduledExecutables".hashCode();
+   private static final int HASH_TICK = "tick".hashCode();
+   private static final int HASH_PRE_RENDER_ERRORS = "preRenderErrors".hashCode();
+   private static final int HASH_RENDER = "render".hashCode();
+   private static final int HASH_DISPLAY = "display".hashCode();
 
    public void clearProfiling() {
       this.profilingMap.clear();
       this.profilingSection = "";
       this.sectionList.clear();
+      this.profilerLocalEnabled = this.profilerGlobalEnabled;
    }
 
-   public void startSection(String var1) {
-      if (this.profilingEnabled) {
-         if (!this.profilingSection.isEmpty()) {
-            this.profilingSection = this.profilingSection + ".";
+   public void startSection(String name) {
+      if (Lagometer.isActive()) {
+         int hashName = name.hashCode();
+         if (hashName == HASH_SCHEDULED_EXECUTABLES && name.equals("scheduledExecutables")) {
+            Lagometer.timerScheduledExecutables.start();
+         } else if (hashName == HASH_TICK && name.equals("tick") && Config.isMinecraftThread()) {
+            Lagometer.timerScheduledExecutables.end();
+            Lagometer.timerTick.start();
+         } else if (hashName == HASH_PRE_RENDER_ERRORS && name.equals("preRenderErrors")) {
+            Lagometer.timerTick.end();
+         }
+      }
+
+      if (Config.isFastRender()) {
+         int hashName = name.hashCode();
+         if (hashName == HASH_RENDER && name.equals("render")) {
+            GlStateManager.clearEnabled = false;
+         } else if (hashName == HASH_DISPLAY && name.equals("display")) {
+            GlStateManager.clearEnabled = true;
          }
+      }
+
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            if (!this.profilingSection.isEmpty()) {
+               this.profilingSection = this.profilingSection + ".";
+            }
 
-         this.profilingSection = this.profilingSection + ☃;
-         this.sectionList.add(this.profilingSection);
-         this.timestampList.add(System.nanoTime());
+            this.profilingSection = this.profilingSection + name;
+            this.sectionList.add(this.profilingSection);
+            this.timestampList.add(System.nanoTime());
+         }
       }
    }
 
-   public void func_194340_a(Supplier<String> var1) {
-      if (this.profilingEnabled) {
-         this.startSection(☃.get());
+   public void func_194340_a(Supplier<String> p_194340_1_) {
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            this.startSection(p_194340_1_.get());
+         }
       }
    }
 
    public void endSection() {
-      if (this.profilingEnabled) {
-         long ☃ = System.nanoTime();
-         long ☃x = this.timestampList.remove(this.timestampList.size() - 1);
-         this.sectionList.remove(this.sectionList.size() - 1);
-         long ☃xx = ☃ - ☃x;
-         if (this.profilingMap.containsKey(this.profilingSection)) {
-            this.profilingMap.put(this.profilingSection, this.profilingMap.get(this.profilingSection) + ☃xx);
-         } else {
-            this.profilingMap.put(this.profilingSection, ☃xx);
-         }
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            long i = System.nanoTime();
+            long j = this.timestampList.remove(this.timestampList.size() - 1);
+            this.sectionList.remove(this.sectionList.size() - 1);
+            long k = i - j;
+            if (this.profilingMap.containsKey(this.profilingSection)) {
+               this.profilingMap.put(this.profilingSection, this.profilingMap.get(this.profilingSection) + k);
+            } else {
+               this.profilingMap.put(this.profilingSection, k);
+            }
 
-         if (☃xx > 100000000L) {
-            LOGGER.warn("Something's taking too long! '{}' took aprox {} ms", this.profilingSection, ☃xx / 1000000.0);
-         }
+            if (k > 100000000L) {
+               LOGGER.warn("Something's taking too long! '{}' took aprox {} ms", this.profilingSection, k / 1000000.0);
+            }
 
-         this.profilingSection = this.sectionList.isEmpty() ? "" : this.sectionList.get(this.sectionList.size() - 1);
+            this.profilingSection = this.sectionList.isEmpty() ? "" : this.sectionList.get(this.sectionList.size() - 1);
+         }
       }
    }
 
-   public List<Profiler.Result> getProfilingData(String var1) {
+   public List<Profiler.Result> getProfilingData(String profilerName) {
       if (!this.profilingEnabled) {
          return Collections.emptyList();
       } else {
-         String ☃ = ☃;
-         long ☃x = this.profilingMap.containsKey("root") ? this.profilingMap.get("root") : 0L;
-         long ☃xx = this.profilingMap.containsKey(☃) ? this.profilingMap.get(☃) : -1L;
-         List<Profiler.Result> ☃xxx = Lists.newArrayList();
-         if (!☃.isEmpty()) {
-            ☃ = ☃ + ".";
+         long i = this.profilingMap.containsKey("root") ? this.profilingMap.get("root") : 0L;
+         long j = this.profilingMap.containsKey(profilerName) ? this.profilingMap.get(profilerName) : -1L;
+         List<Profiler.Result> list = Lists.newArrayList();
+         if (!profilerName.isEmpty()) {
+            profilerName = profilerName + ".";
          }
 
-         long ☃xxxx = 0L;
+         long k = 0L;
 
-         for (String ☃xxxxx : this.profilingMap.keySet()) {
-            if (☃xxxxx.length() > ☃.length() && ☃xxxxx.startsWith(☃) && ☃xxxxx.indexOf(".", ☃.length() + 1) < 0) {
-               ☃xxxx += this.profilingMap.get(☃xxxxx);
+         for (String s : this.profilingMap.keySet()) {
+            if (s.length() > profilerName.length() && s.startsWith(profilerName) && s.indexOf(".", profilerName.length() + 1) < 0) {
+               k += this.profilingMap.get(s);
             }
          }
 
-         float ☃xxxxxx = (float)☃xxxx;
-         if (☃xxxx < ☃xx) {
-            ☃xxxx = ☃xx;
+         float f = (float)k;
+         if (k < j) {
+            k = j;
          }
 
-         if (☃x < ☃xxxx) {
-            ☃x = ☃xxxx;
+         if (i < k) {
+            i = k;
          }
 
-         for (String ☃xxxxxxx : this.profilingMap.keySet()) {
-            if (☃xxxxxxx.length() > ☃.length() && ☃xxxxxxx.startsWith(☃) && ☃xxxxxxx.indexOf(".", ☃.length() + 1) < 0) {
-               long ☃xxxxxxxx = this.profilingMap.get(☃xxxxxxx);
-               double ☃xxxxxxxxx = ☃xxxxxxxx * 100.0 / ☃xxxx;
-               double ☃xxxxxxxxxx = ☃xxxxxxxx * 100.0 / ☃x;
-               String ☃xxxxxxxxxxx = ☃xxxxxxx.substring(☃.length());
-               ☃xxx.add(new Profiler.Result(☃xxxxxxxxxxx, ☃xxxxxxxxx, ☃xxxxxxxxxx));
+         for (String s1 : this.profilingMap.keySet()) {
+            if (s1.length() > profilerName.length() && s1.startsWith(profilerName) && s1.indexOf(".", profilerName.length() + 1) < 0) {
+               long l = this.profilingMap.get(s1);
+               double d0 = l * 100.0 / k;
+               double d1 = l * 100.0 / i;
+               String s2 = s1.substring(profilerName.length());
+               list.add(new Profiler.Result(s2, d0, d1));
             }
          }
 
-         for (String ☃xxxxxxxx : this.profilingMap.keySet()) {
-            this.profilingMap.put(☃xxxxxxxx, this.profilingMap.get(☃xxxxxxxx) * 999L / 1000L);
+         for (String s3 : this.profilingMap.keySet()) {
+            this.profilingMap.put(s3, this.profilingMap.get(s3) * 950L / 1000L);
          }
 
-         if ((float)☃xxxx > ☃xxxxxx) {
-            ☃xxx.add(new Profiler.Result("unspecified", ((float)☃xxxx - ☃xxxxxx) * 100.0 / ☃xxxx, ((float)☃xxxx - ☃xxxxxx) * 100.0 / ☃x));
+         if ((float)k > f) {
+            list.add(new Profiler.Result("unspecified", ((float)k - f) * 100.0 / k, ((float)k - f) * 100.0 / i));
          }
 
-         Collections.sort(☃xxx);
-         ☃xxx.add(0, new Profiler.Result(☃, 100.0, ☃xxxx * 100.0 / ☃x));
-         return ☃xxx;
+         Collections.sort(list);
+         list.add(0, new Profiler.Result(profilerName, 100.0, k * 100.0 / i));
+         return list;
       }
    }
 
-   public void endStartSection(String var1) {
-      this.endSection();
-      this.startSection(☃);
+   public void endStartSection(String name) {
+      if (this.profilerLocalEnabled) {
+         this.endSection();
+         this.startSection(name);
+      }
    }
 
-   public void func_194339_b(Supplier<String> var1) {
-      this.endSection();
-      this.func_194340_a(☃);
+   public void func_194339_b(Supplier<String> p_194339_1_) {
+      if (this.profilerLocalEnabled) {
+         this.endSection();
+         this.func_194340_a(p_194339_1_);
+      }
    }
 
    public String getNameOfLastSection() {
       return this.sectionList.isEmpty() ? "[UNKNOWN]" : this.sectionList.get(this.sectionList.size() - 1);
    }
 
+   public void startSection(Class<?> profiledClass) {
+      if (this.profilingEnabled) {
+         this.startSection(profiledClass.getSimpleName());
+      }
+   }
+
    public static final class Result implements Comparable<Profiler.Result> {
       public double usePercentage;
       public double totalUsePercentage;
       public String profilerName;
 
-      public Result(String var1, double var2, double var4) {
-         this.profilerName = ☃;
-         this.usePercentage = ☃;
-         this.totalUsePercentage = ☃;
+      public Result(String profilerName, double usePercentage, double totalUsePercentage) {
+         this.profilerName = profilerName;
+         this.usePercentage = usePercentage;
+         this.totalUsePercentage = totalUsePercentage;
       }
 
-      public int compareTo(Profiler.Result var1) {
-         if (☃.usePercentage < this.usePercentage) {
+      public int compareTo(Profiler.Result p_compareTo_1_) {
+         if (p_compareTo_1_.usePercentage < this.usePercentage) {
             return -1;
          } else {
-            return ☃.usePercentage > this.usePercentage ? 1 : ☃.profilerName.compareTo(this.profilerName);
+            return p_compareTo_1_.usePercentage > this.usePercentage ? 1 : p_compareTo_1_.profilerName.compareTo(this.profilerName);
          }
       }
 
diff --git a/patches/net/minecraft/server/integrated/IntegratedServer.java b/patches/net/minecraft/server/integrated/IntegratedServer.java
index 9de6e12..c2505e7 100644
--- a/patches/net/minecraft/server/integrated/IntegratedServer.java
+++ b/patches/net/minecraft/server/integrated/IntegratedServer.java
@@ -7,6 +7,9 @@
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import java.io.File;
 import java.io.IOException;
+import java.net.InetAddress;
+import java.util.Arrays;
+import java.util.concurrent.FutureTask;
 import net.minecraft.client.ClientBrandRetriever;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.multiplayer.ThreadLanServerPing;
@@ -14,15 +17,21 @@
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.PacketThreadUtil;
+import net.minecraft.network.play.server.SPacketChangeGameState;
 import net.minecraft.profiler.Snooper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerProfileCache;
 import net.minecraft.util.CryptManager;
 import net.minecraft.util.HttpUtil;
 import net.minecraft.util.Util;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.GameType;
 import net.minecraft.world.ServerWorldEventHandler;
+import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldServerDemo;
 import net.minecraft.world.WorldServerMulti;
@@ -30,6 +39,8 @@
 import net.minecraft.world.WorldType;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.ClearWater;
+import net.optifine.reflect.Reflector;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -40,83 +51,126 @@ public class IntegratedServer extends MinecraftServer {
    private boolean isGamePaused;
    private boolean isPublic;
    private ThreadLanServerPing lanServerPing;
+   private long ticksSaveLast = 0L;
+   public World difficultyUpdateWorld = null;
+   public BlockPos difficultyUpdatePos = null;
+   public DifficultyInstance difficultyLast = null;
 
    public IntegratedServer(
-      Minecraft var1,
-      String var2,
-      String var3,
-      WorldSettings var4,
-      YggdrasilAuthenticationService var5,
-      MinecraftSessionService var6,
-      GameProfileRepository var7,
-      PlayerProfileCache var8
+      Minecraft clientIn,
+      String folderNameIn,
+      String worldNameIn,
+      WorldSettings worldSettingsIn,
+      YggdrasilAuthenticationService authServiceIn,
+      MinecraftSessionService sessionServiceIn,
+      GameProfileRepository profileRepoIn,
+      PlayerProfileCache profileCacheIn
    ) {
-      super(new File(☃.gameDir, "saves"), ☃.getProxy(), ☃.getDataFixer(), ☃, ☃, ☃, ☃);
-      this.setServerOwner(☃.getSession().getUsername());
-      this.setFolderName(☃);
-      this.setWorldName(☃);
-      this.setDemo(☃.isDemo());
-      this.canCreateBonusChest(☃.isBonusChestEnabled());
+      super(new File(clientIn.gameDir, "saves"), clientIn.getProxy(), clientIn.getDataFixer(), authServiceIn, sessionServiceIn, profileRepoIn, profileCacheIn);
+      this.setServerOwner(clientIn.getSession().getUsername());
+      this.setFolderName(folderNameIn);
+      this.setWorldName(worldNameIn);
+      this.setDemo(clientIn.isDemo());
+      this.canCreateBonusChest(worldSettingsIn.isBonusChestEnabled());
       this.setBuildLimit(256);
       this.setPlayerList(new IntegratedPlayerList(this));
-      this.mc = ☃;
-      this.worldSettings = this.isDemo() ? WorldServerDemo.DEMO_WORLD_SETTINGS : ☃;
+      this.mc = clientIn;
+      this.worldSettings = this.isDemo() ? WorldServerDemo.DEMO_WORLD_SETTINGS : worldSettingsIn;
+      ISaveHandler isavehandler = this.getActiveAnvilConverter().getSaveLoader(folderNameIn, false);
+      WorldInfo worldinfo = isavehandler.loadWorldInfo();
+      if (worldinfo != null) {
+         NBTTagCompound nbt = worldinfo.getPlayerNBTTagCompound();
+         if (nbt != null && nbt.hasKey("Dimension")) {
+            int dim = nbt.getInteger("Dimension");
+            PacketThreadUtil.lastDimensionId = dim;
+            this.mc.loadingScreen.setLoadingProgress(-1);
+         }
+      }
    }
 
-   @Override
-   protected ServerCommandManager createCommandManager() {
+   public ServerCommandManager createCommandManager() {
       return new IntegratedServerCommandManager(this);
    }
 
-   @Override
-   protected void loadAllWorlds(String var1, String var2, long var3, WorldType var5, String var6) {
-      this.convertMapIfNeeded(☃);
-      this.worlds = new WorldServer[3];
-      this.timeOfLastDimensionTick = new long[this.worlds.length][100];
-      ISaveHandler ☃ = this.getActiveAnvilConverter().getSaveLoader(☃, true);
-      this.setResourcePackFromWorld(this.getFolderName(), ☃);
-      WorldInfo ☃x = ☃.loadWorldInfo();
-      if (☃x == null) {
-         ☃x = new WorldInfo(this.worldSettings, ☃);
+   public void loadAllWorlds(String saveName, String worldNameIn, long seed, WorldType type, String generatorOptions) {
+      this.convertMapIfNeeded(saveName);
+      boolean forge = Reflector.DimensionManager.exists();
+      if (!forge) {
+         this.worlds = new WorldServer[3];
+         this.timeOfLastDimensionTick = new long[this.worlds.length][100];
+      }
+
+      ISaveHandler isavehandler = this.getActiveAnvilConverter().getSaveLoader(saveName, true);
+      this.setResourcePackFromWorld(this.getFolderName(), isavehandler);
+      WorldInfo worldinfo = isavehandler.loadWorldInfo();
+      if (worldinfo == null) {
+         worldinfo = new WorldInfo(this.worldSettings, worldNameIn);
       } else {
-         ☃x.setWorldName(☃);
+         worldinfo.setWorldName(worldNameIn);
       }
 
-      for (int ☃xx = 0; ☃xx < this.worlds.length; ☃xx++) {
-         int ☃xxx = 0;
-         if (☃xx == 1) {
-            ☃xxx = -1;
+      if (forge) {
+         WorldServer overWorld = this.isDemo()
+            ? (WorldServer)new WorldServerDemo(this, isavehandler, worldinfo, 0, this.profiler).b()
+            : (WorldServer)new WorldServer(this, isavehandler, worldinfo, 0, this.profiler).init();
+         overWorld.initialize(this.worldSettings);
+         Integer[] dimIds = (Integer[])Reflector.call(Reflector.DimensionManager_getStaticDimensionIDs, new Object[0]);
+         Integer[] var12 = dimIds;
+         int var13 = dimIds.length;
+
+         for (int var14 = 0; var14 < var13; var14++) {
+            int dim = var12[var14];
+            WorldServer world = dim == 0 ? overWorld : (WorldServer)new WorldServerMulti(this, isavehandler, dim, overWorld, this.profiler).init();
+            world.addEventListener(new ServerWorldEventHandler(this, world));
+            if (!this.isSinglePlayer()) {
+               world.getWorldInfo().setGameType(this.getGameType());
+            }
+
+            if (Reflector.EventBus.exists()) {
+               Reflector.postForgeBusEvent(Reflector.WorldEvent_Load_Constructor, new Object[]{world});
+            }
          }
 
-         if (☃xx == 2) {
-            ☃xxx = 1;
+         this.getPlayerList().setPlayerManager(new WorldServer[]{overWorld});
+         if (overWorld.getWorldInfo().getDifficulty() == null) {
+            this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
          }
+      } else {
+         for (int i = 0; i < this.worlds.length; i++) {
+            int j = 0;
+            if (i == 1) {
+               j = -1;
+            }
+
+            if (i == 2) {
+               j = 1;
+            }
 
-         if (☃xx == 0) {
-            if (this.isDemo()) {
-               this.worlds[☃xx] = (WorldServer)new WorldServerDemo(this, ☃, ☃x, ☃xxx, this.profiler).init();
+            if (i == 0) {
+               if (this.isDemo()) {
+                  this.worlds[i] = (WorldServer)new WorldServerDemo(this, isavehandler, worldinfo, j, this.profiler).b();
+               } else {
+                  this.worlds[i] = (WorldServer)new WorldServer(this, isavehandler, worldinfo, j, this.profiler).init();
+               }
+
+               this.worlds[i].initialize(this.worldSettings);
             } else {
-               this.worlds[☃xx] = (WorldServer)new WorldServer(this, ☃, ☃x, ☃xxx, this.profiler).init();
+               this.worlds[i] = (WorldServer)new WorldServerMulti(this, isavehandler, j, this.worlds[0], this.profiler).init();
             }
 
-            this.worlds[☃xx].initialize(this.worldSettings);
-         } else {
-            this.worlds[☃xx] = (WorldServer)new WorldServerMulti(this, ☃, ☃xxx, this.worlds[0], this.profiler).init();
+            this.worlds[i].addEventListener(new ServerWorldEventHandler(this, this.worlds[i]));
          }
 
-         this.worlds[☃xx].addEventListener(new ServerWorldEventHandler(this, this.worlds[☃xx]));
-      }
-
-      this.getPlayerList().setPlayerManager(this.worlds);
-      if (this.worlds[0].getWorldInfo().getDifficulty() == null) {
-         this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
+         this.getPlayerList().setPlayerManager(this.worlds);
+         if (this.worlds[0].getWorldInfo().getDifficulty() == null) {
+            this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
+         }
       }
 
       this.initialWorldChunkLoad();
    }
 
-   @Override
-   protected boolean init() throws IOException {
+   public boolean init() throws IOException {
       LOGGER.info("Starting integrated minecraft server version 1.12.2");
       this.setOnlineMode(true);
       this.setCanSpawnAnimals(true);
@@ -125,18 +179,34 @@ protected boolean init() throws IOException {
       this.setAllowFlight(true);
       LOGGER.info("Generating keypair");
       this.setKeyPair(CryptManager.generateKeyPair());
+      if (Reflector.FMLCommonHandler_handleServerAboutToStart.exists()) {
+         Object inst = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         if (!Reflector.callBoolean(inst, Reflector.FMLCommonHandler_handleServerAboutToStart, new Object[]{this})) {
+            return false;
+         }
+      }
+
       this.loadAllWorlds(
          this.getFolderName(), this.getWorldName(), this.worldSettings.getSeed(), this.worldSettings.getTerrainType(), this.worldSettings.getGeneratorOptions()
       );
       this.setMOTD(this.getServerOwner() + " - " + this.worlds[0].getWorldInfo().getWorldName());
+      if (Reflector.FMLCommonHandler_handleServerStarting.exists()) {
+         Object inst = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         if (Reflector.FMLCommonHandler_handleServerStarting.getReturnType() == boolean.class) {
+            return Reflector.callBoolean(inst, Reflector.FMLCommonHandler_handleServerStarting, new Object[]{this});
+         }
+
+         Reflector.callVoid(inst, Reflector.FMLCommonHandler_handleServerStarting, new Object[]{this});
+      }
+
       return true;
    }
 
-   @Override
-   protected void tick() {
-      boolean ☃ = this.isGamePaused;
+   public void tick() {
+      this.onTick();
+      boolean flag = this.isGamePaused;
       this.isGamePaused = Minecraft.getMinecraft().getConnection() != null && Minecraft.getMinecraft().isGamePaused();
-      if (!☃ && this.isGamePaused) {
+      if (!flag && this.isGamePaused) {
          LOGGER.info("Saving and pausing game...");
          this.getPlayerList().saveAllPlayerData();
          this.saveAllWorlds(false);
@@ -145,7 +215,7 @@ protected void tick() {
       if (this.isGamePaused) {
          synchronized (this.futureTaskQueue) {
             while (!this.futureTaskQueue.isEmpty()) {
-               Util.runTask(this.futureTaskQueue.poll(), LOGGER);
+               Util.runTask((FutureTask)this.futureTaskQueue.poll(), LOGGER);
             }
          }
       } else {
@@ -156,17 +226,17 @@ protected void tick() {
          }
 
          if (this.mc.world != null) {
-            WorldInfo ☃x = this.worlds[0].getWorldInfo();
-            WorldInfo ☃xx = this.mc.world.getWorldInfo();
-            if (!☃x.isDifficultyLocked() && ☃xx.getDifficulty() != ☃x.getDifficulty()) {
-               LOGGER.info("Changing difficulty to {}, from {}", ☃xx.getDifficulty(), ☃x.getDifficulty());
-               this.setDifficultyForAllWorlds(☃xx.getDifficulty());
-            } else if (☃xx.isDifficultyLocked() && !☃x.isDifficultyLocked()) {
-               LOGGER.info("Locking difficulty to {}", ☃xx.getDifficulty());
-
-               for (WorldServer ☃xxx : this.worlds) {
-                  if (☃xxx != null) {
-                     ☃xxx.getWorldInfo().setDifficultyLocked(true);
+            WorldInfo worldinfo1 = this.worlds[0].getWorldInfo();
+            WorldInfo worldinfo = this.mc.world.getWorldInfo();
+            if (!worldinfo1.isDifficultyLocked() && worldinfo.getDifficulty() != worldinfo1.getDifficulty()) {
+               LOGGER.info("Changing difficulty to {}, from {}", worldinfo.getDifficulty(), worldinfo1.getDifficulty());
+               this.setDifficultyForAllWorlds(worldinfo.getDifficulty());
+            } else if (worldinfo.isDifficultyLocked() && !worldinfo1.isDifficultyLocked()) {
+               LOGGER.info("Locking difficulty to {}", worldinfo.getDifficulty());
+
+               for (WorldServer worldserver : this.worlds) {
+                  if (worldserver != null) {
+                     worldserver.getWorldInfo().setDifficultyLocked(true);
                   }
                }
             }
@@ -174,81 +244,79 @@ protected void tick() {
       }
    }
 
-   @Override
    public boolean canStructuresSpawn() {
       return false;
    }
 
-   @Override
    public GameType getGameType() {
       return this.worldSettings.getGameType();
    }
 
-   @Override
    public EnumDifficulty getDifficulty() {
-      return this.mc.world.getWorldInfo().getDifficulty();
+      return this.mc.world == null ? this.mc.gameSettings.difficulty : this.mc.world.getWorldInfo().getDifficulty();
    }
 
-   @Override
    public boolean isHardcore() {
       return this.worldSettings.getHardcoreEnabled();
    }
 
-   @Override
    public boolean shouldBroadcastRconToOps() {
       return true;
    }
 
-   @Override
    public boolean shouldBroadcastConsoleToOps() {
       return true;
    }
 
-   @Override
-   protected void saveAllWorlds(boolean var1) {
-      super.saveAllWorlds(☃);
+   public void saveAllWorlds(boolean isSilent) {
+      if (isSilent) {
+         int ticks = this.getTickCounter();
+         int ticksSaveInterval = this.mc.gameSettings.ofAutoSaveTicks;
+         if (ticks < this.ticksSaveLast + ticksSaveInterval) {
+            return;
+         }
+
+         this.ticksSaveLast = ticks;
+      }
+
+      super.saveAllWorlds(isSilent);
    }
 
-   @Override
    public File getDataDirectory() {
       return this.mc.gameDir;
    }
 
-   @Override
    public boolean isDedicatedServer() {
       return false;
    }
 
-   @Override
    public boolean shouldUseNativeTransport() {
       return false;
    }
 
-   @Override
-   protected void finalTick(CrashReport var1) {
-      this.mc.crashed(☃);
+   public void finalTick(CrashReport report) {
+      this.mc.crashed(report);
    }
 
-   @Override
-   public CrashReport addServerInfoToCrashReport(CrashReport var1) {
-      ☃ = super.addServerInfoToCrashReport(☃);
-      ☃.getCategory().addDetail("Type", new ICrashReportDetail<String>() {
+   public CrashReport addServerInfoToCrashReport(CrashReport report) {
+      report = super.addServerInfoToCrashReport(report);
+      report.getCategory().addDetail("Type", new ICrashReportDetail<String>() {
          public String call() throws Exception {
             return "Integrated Server (map_client.txt)";
          }
       });
-      ☃.getCategory()
+      report.getCategory()
          .addDetail(
             "Is Modded",
             new ICrashReportDetail<String>() {
                public String call() throws Exception {
-                  String ☃ = ClientBrandRetriever.getClientModName();
-                  if (!☃.equals("vanilla")) {
-                     return "Definitely; Client brand changed to '" + ☃ + "'";
+                  String s = ClientBrandRetriever.getClientModName();
+                  if (!s.equals("vanilla")) {
+                     return "Definitely; Client brand changed to '" + s + "'";
                   } else {
-                     ☃ = IntegratedServer.this.getServerModName();
-                     if (!"vanilla".equals(☃)) {
-                        return "Definitely; Server brand changed to '" + ☃ + "'";
+                     s = IntegratedServer.this.getServerModName();
+                     if (!"vanilla".equals(s)) {
+                        return "Definitely; Server brand changed to '" + s + "'";
                      } else {
                         return Minecraft.class.getSigners() == null
                            ? "Very likely; Jar signature invalidated"
@@ -258,57 +326,52 @@ public String call() throws Exception {
                }
             }
          );
-      return ☃;
+      return report;
    }
 
-   @Override
-   public void setDifficultyForAllWorlds(EnumDifficulty var1) {
-      super.setDifficultyForAllWorlds(☃);
+   public void setDifficultyForAllWorlds(EnumDifficulty difficulty) {
+      super.setDifficultyForAllWorlds(difficulty);
       if (this.mc.world != null) {
-         this.mc.world.getWorldInfo().setDifficulty(☃);
+         this.mc.world.getWorldInfo().setDifficulty(difficulty);
       }
    }
 
-   @Override
-   public void addServerStatsToSnooper(Snooper var1) {
-      super.addServerStatsToSnooper(☃);
-      ☃.addClientStat("snooper_partner", this.mc.getPlayerUsageSnooper().getUniqueID());
+   public void addServerStatsToSnooper(Snooper playerSnooper) {
+      super.addServerStatsToSnooper(playerSnooper);
+      playerSnooper.addClientStat("snooper_partner", this.mc.getPlayerUsageSnooper().getUniqueID());
    }
 
-   @Override
    public boolean isSnooperEnabled() {
       return Minecraft.getMinecraft().isSnooperEnabled();
    }
 
-   @Override
-   public String shareToLAN(GameType var1, boolean var2) {
+   public String shareToLAN(GameType type, boolean allowCheats) {
       try {
-         int ☃ = -1;
+         int i = -1;
 
          try {
-            ☃ = HttpUtil.getSuitableLanPort();
+            i = HttpUtil.getSuitableLanPort();
          } catch (IOException var5) {
          }
 
-         if (☃ <= 0) {
-            ☃ = 25564;
+         if (i <= 0) {
+            i = 25564;
          }
 
-         this.getNetworkSystem().addEndpoint(null, ☃);
-         LOGGER.info("Started on {}", ☃);
+         this.getNetworkSystem().addEndpoint((InetAddress)null, i);
+         LOGGER.info("Started on {}", i);
          this.isPublic = true;
-         this.lanServerPing = new ThreadLanServerPing(this.getMOTD(), ☃ + "");
+         this.lanServerPing = new ThreadLanServerPing(this.getMOTD(), i + "");
          this.lanServerPing.start();
-         this.getPlayerList().setGameType(☃);
-         this.getPlayerList().setCommandsAllowedForAll(☃);
-         this.mc.player.setPermissionLevel(☃ ? 4 : 0);
-         return ☃ + "";
-      } catch (IOException var6) {
+         this.getPlayerList().setGameType(type);
+         this.getPlayerList().setCommandsAllowedForAll(allowCheats);
+         this.mc.player.setPermissionLevel(allowCheats ? 4 : 0);
+         return i + "";
+      } catch (IOException var61) {
          return null;
       }
    }
 
-   @Override
    public void stopServer() {
       super.stopServer();
       if (this.lanServerPing != null) {
@@ -317,18 +380,20 @@ public void stopServer() {
       }
    }
 
-   @Override
    public void initiateShutdown() {
-      Futures.getUnchecked(this.addScheduledTask(new Runnable() {
-         @Override
-         public void run() {
-            for (EntityPlayerMP ☃ : Lists.newArrayList(IntegratedServer.this.getPlayerList().getPlayers())) {
-               if (!☃.getUniqueID().equals(IntegratedServer.this.mc.player.getUniqueID())) {
-                  IntegratedServer.this.getPlayerList().playerLoggedOut(☃);
+      if (!Reflector.MinecraftForge.exists() || this.isServerRunning()) {
+         Futures.getUnchecked(this.addScheduledTask(new Runnable() {
+            @Override
+            public void run() {
+               for (EntityPlayerMP entityplayermp : Lists.newArrayList(IntegratedServer.this.getPlayerList().getPlayers())) {
+                  if (!entityplayermp.getUniqueID().equals(IntegratedServer.this.mc.player.getUniqueID())) {
+                     IntegratedServer.this.getPlayerList().playerLoggedOut(entityplayermp);
+                  }
                }
             }
-         }
-      }));
+         }));
+      }
+
       super.initiateShutdown();
       if (this.lanServerPing != null) {
          this.lanServerPing.interrupt();
@@ -340,19 +405,91 @@ public boolean getPublic() {
       return this.isPublic;
    }
 
-   @Override
-   public void setGameType(GameType var1) {
-      super.setGameType(☃);
-      this.getPlayerList().setGameType(☃);
+   public void setGameType(GameType gameMode) {
+      super.setGameType(gameMode);
+      this.getPlayerList().setGameType(gameMode);
    }
 
-   @Override
    public boolean isCommandBlockEnabled() {
       return true;
    }
 
-   @Override
    public int getOpPermissionLevel() {
       return 4;
    }
+
+   private void onTick() {
+      for (WorldServer ws : Arrays.asList(this.worlds)) {
+         this.onTick(ws);
+      }
+   }
+
+   public DifficultyInstance getDifficultyAsync(World world, BlockPos blockPos) {
+      this.difficultyUpdateWorld = world;
+      this.difficultyUpdatePos = blockPos;
+      return this.difficultyLast;
+   }
+
+   private void onTick(WorldServer ws) {
+      if (!Config.isTimeDefault()) {
+         this.fixWorldTime(ws);
+      }
+
+      if (!Config.isWeatherEnabled()) {
+         this.fixWorldWeather(ws);
+      }
+
+      if (Config.waterOpacityChanged) {
+         Config.waterOpacityChanged = false;
+         ClearWater.updateWaterOpacity(Config.getGameSettings(), ws);
+      }
+
+      if (this.difficultyUpdateWorld == ws && this.difficultyUpdatePos != null) {
+         this.difficultyLast = ws.getDifficultyForLocation(this.difficultyUpdatePos);
+         this.difficultyUpdateWorld = null;
+         this.difficultyUpdatePos = null;
+      }
+   }
+
+   private void fixWorldWeather(WorldServer ws) {
+      WorldInfo worldInfo = ws.getWorldInfo();
+      if (worldInfo.isRaining() || worldInfo.isThundering()) {
+         worldInfo.setRainTime(0);
+         worldInfo.setRaining(false);
+         ws.setRainStrength(0.0F);
+         worldInfo.setThunderTime(0);
+         worldInfo.setThundering(false);
+         ws.setThunderStrength(0.0F);
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(2, 0.0F));
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(7, 0.0F));
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(8, 0.0F));
+      }
+   }
+
+   private void fixWorldTime(WorldServer ws) {
+      WorldInfo worldInfo = ws.getWorldInfo();
+      if (worldInfo.getGameType().getID() == 1) {
+         long time = ws.getWorldTime();
+         long timeOfDay = time % 24000L;
+         if (Config.isTimeDayOnly()) {
+            if (timeOfDay <= 1000L) {
+               ws.setWorldTime(time - timeOfDay + 1001L);
+            }
+
+            if (timeOfDay >= 11000L) {
+               ws.setWorldTime(time - timeOfDay + 24001L);
+            }
+         }
+
+         if (Config.isTimeNightOnly()) {
+            if (timeOfDay <= 14000L) {
+               ws.setWorldTime(time - timeOfDay + 14001L);
+            }
+
+            if (timeOfDay >= 22000L) {
+               ws.setWorldTime(time - timeOfDay + 24000L + 14001L);
+            }
+         }
+      }
+   }
 }
diff --git a/patches/net/minecraft/server/management/PlayerChunkMap.java b/patches/net/minecraft/server/management/PlayerChunkMap.java
index 01d6da6..aae864d 100644
--- a/patches/net/minecraft/server/management/PlayerChunkMap.java
+++ b/patches/net/minecraft/server/management/PlayerChunkMap.java
@@ -9,9 +9,14 @@
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.PriorityQueue;
 import java.util.Set;
+import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.math.BlockPos;
@@ -20,16 +25,17 @@
 import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.ChunkPosComparator;
 
 public class PlayerChunkMap {
    private static final Predicate<EntityPlayerMP> NOT_SPECTATOR = new Predicate<EntityPlayerMP>() {
-      public boolean apply(@Nullable EntityPlayerMP var1) {
-         return ☃ != null && !☃.isSpectator();
+      public boolean apply(@Nullable EntityPlayerMP p_apply_1_) {
+         return p_apply_1_ != null && !p_apply_1_.isSpectator();
       }
    };
    private static final Predicate<EntityPlayerMP> CAN_GENERATE_CHUNKS = new Predicate<EntityPlayerMP>() {
-      public boolean apply(@Nullable EntityPlayerMP var1) {
-         return ☃ != null && (!☃.isSpectator() || ☃.getServerWorld().getGameRules().getBoolean("spectatorsGenerateChunks"));
+      public boolean apply(@Nullable EntityPlayerMP p_apply_1_) {
+         return p_apply_1_ != null && (!p_apply_1_.isSpectator() || p_apply_1_.getServerWorld().getGameRules().getBoolean("spectatorsGenerateChunks"));
       }
    };
    private final WorldServer world;
@@ -43,10 +49,11 @@ public boolean apply(@Nullable EntityPlayerMP var1) {
    private long previousTotalWorldTime;
    private boolean sortMissingChunks = true;
    private boolean sortSendToPlayers = true;
+   private final Map<EntityPlayerMP, Set<ChunkPos>> mapPlayerPendingEntries = new HashMap<>();
 
-   public PlayerChunkMap(WorldServer var1) {
-      this.world = ☃;
-      this.setPlayerViewRadius(☃.getMinecraftServer().getPlayerList().getViewDistance());
+   public PlayerChunkMap(WorldServer serverWorld) {
+      this.world = serverWorld;
+      this.setPlayerViewRadius(serverWorld.getMinecraftServer().getPlayerList().getViewDistance());
    }
 
    public WorldServer getWorldServer() {
@@ -54,23 +61,23 @@ public WorldServer getWorldServer() {
    }
 
    public Iterator<Chunk> getChunkIterator() {
-      final Iterator<PlayerChunkMapEntry> ☃ = this.entries.iterator();
+      final Iterator<PlayerChunkMapEntry> iterator = this.entries.iterator();
       return new AbstractIterator<Chunk>() {
          protected Chunk computeNext() {
-            while (☃.hasNext()) {
-               PlayerChunkMapEntry ☃x = ☃.next();
-               Chunk ☃x = ☃x.getChunk();
-               if (☃x != null) {
-                  if (!☃x.isLightPopulated() && ☃x.isTerrainPopulated()) {
-                     return ☃x;
+            while (iterator.hasNext()) {
+               PlayerChunkMapEntry playerchunkmapentry = iterator.next();
+               Chunk chunk = playerchunkmapentry.getChunk();
+               if (chunk != null) {
+                  if (!chunk.isLightPopulated() && chunk.isTerrainPopulated()) {
+                     return chunk;
                   }
 
-                  if (!☃x.wasTicked()) {
-                     return ☃x;
+                  if (!chunk.wasTicked()) {
+                     return chunk;
                   }
 
-                  if (☃x.hasPlayerMatchingInRange(128.0, PlayerChunkMap.NOT_SPECTATOR)) {
-                     return ☃x;
+                  if (playerchunkmapentry.hasPlayerMatchingInRange(128.0, PlayerChunkMap.NOT_SPECTATOR)) {
+                     return chunk;
                   }
                }
             }
@@ -81,59 +88,87 @@ protected Chunk computeNext() {
    }
 
    public void tick() {
-      long ☃ = this.world.getTotalWorldTime();
-      if (☃ - this.previousTotalWorldTime > 8000L) {
-         this.previousTotalWorldTime = ☃;
-
-         for (int ☃x = 0; ☃x < this.entries.size(); ☃x++) {
-            PlayerChunkMapEntry ☃xx = this.entries.get(☃x);
-            ☃xx.update();
-            ☃xx.updateChunkInhabitedTime();
+      Set<Entry<EntityPlayerMP, Set<ChunkPos>>> pairs = this.mapPlayerPendingEntries.entrySet();
+      Iterator it = pairs.iterator();
+
+      while (it.hasNext()) {
+         Entry<EntityPlayerMP, Set<ChunkPos>> entry = (Entry<EntityPlayerMP, Set<ChunkPos>>)it.next();
+         Set<ChunkPos> setPending = entry.getValue();
+         if (!setPending.isEmpty()) {
+            EntityPlayerMP player = entry.getKey();
+            if (player.getServerWorld() != this.world) {
+               it.remove();
+            } else {
+               int countUpdates = this.playerViewRadius / 3 + 1;
+               if (!Config.isLazyChunkLoading()) {
+                  countUpdates = this.playerViewRadius * 2 + 1;
+               }
+
+               for (ChunkPos chunkPos : this.getNearest(setPending, player, countUpdates)) {
+                  PlayerChunkMapEntry pcmr = this.getOrCreateEntry(chunkPos.x, chunkPos.z);
+                  if (!pcmr.containsPlayer(player)) {
+                     pcmr.addPlayer(player);
+                  }
+
+                  setPending.remove(chunkPos);
+               }
+            }
+         }
+      }
+
+      long i = this.world.getTotalWorldTime();
+      if (i - this.previousTotalWorldTime > 8000L) {
+         this.previousTotalWorldTime = i;
+
+         for (int j = 0; j < this.entries.size(); j++) {
+            PlayerChunkMapEntry playerchunkmapentry = this.entries.get(j);
+            playerchunkmapentry.update();
+            playerchunkmapentry.updateChunkInhabitedTime();
          }
       }
 
       if (!this.dirtyEntries.isEmpty()) {
-         for (PlayerChunkMapEntry ☃x : this.dirtyEntries) {
-            ☃x.update();
+         for (PlayerChunkMapEntry playerchunkmapentry2 : this.dirtyEntries) {
+            playerchunkmapentry2.update();
          }
 
          this.dirtyEntries.clear();
       }
 
-      if (this.sortMissingChunks && ☃ % 4L == 0L) {
+      if (this.sortMissingChunks && i % 4L == 0L) {
          this.sortMissingChunks = false;
          Collections.sort(this.entriesWithoutChunks, new Comparator<PlayerChunkMapEntry>() {
-            public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
-               return ComparisonChain.start().compare(☃.getClosestPlayerDistance(), ☃.getClosestPlayerDistance()).result();
+            public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_) {
+               return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
             }
          });
       }
 
-      if (this.sortSendToPlayers && ☃ % 4L == 2L) {
+      if (this.sortSendToPlayers && i % 4L == 2L) {
          this.sortSendToPlayers = false;
          Collections.sort(this.pendingSendToPlayers, new Comparator<PlayerChunkMapEntry>() {
-            public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
-               return ComparisonChain.start().compare(☃.getClosestPlayerDistance(), ☃.getClosestPlayerDistance()).result();
+            public int compare(PlayerChunkMapEntry p_compare_1_, PlayerChunkMapEntry p_compare_2_) {
+               return ComparisonChain.start().compare(p_compare_1_.getClosestPlayerDistance(), p_compare_2_.getClosestPlayerDistance()).result();
             }
          });
       }
 
       if (!this.entriesWithoutChunks.isEmpty()) {
-         long ☃x = System.nanoTime() + 50000000L;
-         int ☃xx = 49;
-         Iterator<PlayerChunkMapEntry> ☃xxx = this.entriesWithoutChunks.iterator();
-
-         while (☃xxx.hasNext()) {
-            PlayerChunkMapEntry ☃xxxx = ☃xxx.next();
-            if (☃xxxx.getChunk() == null) {
-               boolean ☃xxxxx = ☃xxxx.hasPlayerMatching(CAN_GENERATE_CHUNKS);
-               if (☃xxxx.providePlayerChunk(☃xxxxx)) {
-                  ☃xxx.remove();
-                  if (☃xxxx.sendToPlayers()) {
-                     this.pendingSendToPlayers.remove(☃xxxx);
+         long l = System.nanoTime() + 50000000L;
+         int k = 49;
+         Iterator<PlayerChunkMapEntry> iterator = this.entriesWithoutChunks.iterator();
+
+         while (iterator.hasNext()) {
+            PlayerChunkMapEntry playerchunkmapentry1 = iterator.next();
+            if (playerchunkmapentry1.getChunk() == null) {
+               boolean flag = playerchunkmapentry1.hasPlayerMatching(CAN_GENERATE_CHUNKS);
+               if (playerchunkmapentry1.providePlayerChunk(flag)) {
+                  iterator.remove();
+                  if (playerchunkmapentry1.sendToPlayers()) {
+                     this.pendingSendToPlayers.remove(playerchunkmapentry1);
                   }
 
-                  if (--☃xx < 0 || System.nanoTime() > ☃x) {
+                  if (--k < 0 || System.nanoTime() > l) {
                      break;
                   }
                }
@@ -142,14 +177,14 @@ public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
       }
 
       if (!this.pendingSendToPlayers.isEmpty()) {
-         int ☃x = 81;
-         Iterator<PlayerChunkMapEntry> ☃xx = this.pendingSendToPlayers.iterator();
-
-         while (☃xx.hasNext()) {
-            PlayerChunkMapEntry ☃xxx = ☃xx.next();
-            if (☃xxx.sendToPlayers()) {
-               ☃xx.remove();
-               if (--☃x < 0) {
+         int i1 = 81;
+         Iterator<PlayerChunkMapEntry> iterator1 = this.pendingSendToPlayers.iterator();
+
+         while (iterator1.hasNext()) {
+            PlayerChunkMapEntry playerchunkmapentry3 = iterator1.next();
+            if (playerchunkmapentry3.sendToPlayers()) {
+               iterator1.remove();
+               if (--i1 < 0) {
                   break;
                }
             }
@@ -157,159 +192,186 @@ public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
       }
 
       if (this.players.isEmpty()) {
-         WorldProvider ☃x = this.world.provider;
-         if (!☃x.canRespawnHere()) {
+         WorldProvider worldprovider = this.world.provider;
+         if (!worldprovider.canRespawnHere()) {
             this.world.getChunkProvider().queueUnloadAll();
          }
       }
    }
 
-   public boolean contains(int var1, int var2) {
-      long ☃ = getIndex(☃, ☃);
-      return this.entryMap.get(☃) != null;
+   public boolean contains(int chunkX, int chunkZ) {
+      long i = getIndex(chunkX, chunkZ);
+      return this.entryMap.get(i) != null;
    }
 
    @Nullable
-   public PlayerChunkMapEntry getEntry(int var1, int var2) {
-      return (PlayerChunkMapEntry)this.entryMap.get(getIndex(☃, ☃));
+   public PlayerChunkMapEntry getEntry(int x, int z) {
+      return (PlayerChunkMapEntry)this.entryMap.get(getIndex(x, z));
    }
 
-   private PlayerChunkMapEntry getOrCreateEntry(int var1, int var2) {
-      long ☃ = getIndex(☃, ☃);
-      PlayerChunkMapEntry ☃x = (PlayerChunkMapEntry)this.entryMap.get(☃);
-      if (☃x == null) {
-         ☃x = new PlayerChunkMapEntry(this, ☃, ☃);
-         this.entryMap.put(☃, ☃x);
-         this.entries.add(☃x);
-         if (☃x.getChunk() == null) {
-            this.entriesWithoutChunks.add(☃x);
+   private PlayerChunkMapEntry getOrCreateEntry(int chunkX, int chunkZ) {
+      long i = getIndex(chunkX, chunkZ);
+      PlayerChunkMapEntry playerchunkmapentry = (PlayerChunkMapEntry)this.entryMap.get(i);
+      if (playerchunkmapentry == null) {
+         playerchunkmapentry = new PlayerChunkMapEntry(this, chunkX, chunkZ);
+         this.entryMap.put(i, playerchunkmapentry);
+         this.entries.add(playerchunkmapentry);
+         if (playerchunkmapentry.getChunk() == null) {
+            this.entriesWithoutChunks.add(playerchunkmapentry);
          }
 
-         if (!☃x.sendToPlayers()) {
-            this.pendingSendToPlayers.add(☃x);
+         if (!playerchunkmapentry.sendToPlayers()) {
+            this.pendingSendToPlayers.add(playerchunkmapentry);
          }
       }
 
-      return ☃x;
+      return playerchunkmapentry;
    }
 
-   public void markBlockForUpdate(BlockPos var1) {
-      int ☃ = ☃.getX() >> 4;
-      int ☃x = ☃.getZ() >> 4;
-      PlayerChunkMapEntry ☃xx = this.getEntry(☃, ☃x);
-      if (☃xx != null) {
-         ☃xx.blockChanged(☃.getX() & 15, ☃.getY(), ☃.getZ() & 15);
+   public void markBlockForUpdate(BlockPos pos) {
+      int i = pos.getX() >> 4;
+      int j = pos.getZ() >> 4;
+      PlayerChunkMapEntry playerchunkmapentry = this.getEntry(i, j);
+      if (playerchunkmapentry != null) {
+         playerchunkmapentry.blockChanged(pos.getX() & 15, pos.getY(), pos.getZ() & 15);
       }
    }
 
-   public void addPlayer(EntityPlayerMP var1) {
-      int ☃ = (int)☃.posX >> 4;
-      int ☃x = (int)☃.posZ >> 4;
-      ☃.managedPosX = ☃.posX;
-      ☃.managedPosZ = ☃.posZ;
-
-      for (int ☃xx = ☃ - this.playerViewRadius; ☃xx <= ☃ + this.playerViewRadius; ☃xx++) {
-         for (int ☃xxx = ☃x - this.playerViewRadius; ☃xxx <= ☃x + this.playerViewRadius; ☃xxx++) {
-            this.getOrCreateEntry(☃xx, ☃xxx).addPlayer(☃);
+   public void addPlayer(EntityPlayerMP player) {
+      int i = (int)player.posX >> 4;
+      int j = (int)player.posZ >> 4;
+      player.managedPosX = player.posX;
+      player.managedPosZ = player.posZ;
+      int loadRadius = Math.min(this.playerViewRadius, 8);
+      int kMin = i - loadRadius;
+      int kMax = i + loadRadius;
+      int lMin = j - loadRadius;
+      int lMax = j + loadRadius;
+      Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(player);
+
+      for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; k++) {
+         for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; l++) {
+            if (k >= kMin && k <= kMax && l >= lMin && l <= lMax) {
+               this.getOrCreateEntry(k, l).addPlayer(player);
+            } else {
+               setPendingEntries.add(new ChunkPos(k, l));
+            }
          }
       }
 
-      this.players.add(☃);
+      this.players.add(player);
       this.markSortPending();
    }
 
-   public void removePlayer(EntityPlayerMP var1) {
-      int ☃ = (int)☃.managedPosX >> 4;
-      int ☃x = (int)☃.managedPosZ >> 4;
+   public void removePlayer(EntityPlayerMP player) {
+      this.mapPlayerPendingEntries.remove(player);
+      int i = (int)player.managedPosX >> 4;
+      int j = (int)player.managedPosZ >> 4;
 
-      for (int ☃xx = ☃ - this.playerViewRadius; ☃xx <= ☃ + this.playerViewRadius; ☃xx++) {
-         for (int ☃xxx = ☃x - this.playerViewRadius; ☃xxx <= ☃x + this.playerViewRadius; ☃xxx++) {
-            PlayerChunkMapEntry ☃xxxx = this.getEntry(☃xx, ☃xxx);
-            if (☃xxxx != null) {
-               ☃xxxx.removePlayer(☃);
+      for (int k = i - this.playerViewRadius; k <= i + this.playerViewRadius; k++) {
+         for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; l++) {
+            PlayerChunkMapEntry playerchunkmapentry = this.getEntry(k, l);
+            if (playerchunkmapentry != null) {
+               playerchunkmapentry.removePlayer(player);
             }
          }
       }
 
-      this.players.remove(☃);
+      this.players.remove(player);
       this.markSortPending();
    }
 
-   private boolean overlaps(int var1, int var2, int var3, int var4, int var5) {
-      int ☃ = ☃ - ☃;
-      int ☃x = ☃ - ☃;
-      return ☃ < -☃ || ☃ > ☃ ? false : ☃x >= -☃ && ☃x <= ☃;
+   private boolean overlaps(int x1, int z1, int x2, int z2, int radius) {
+      int i = x1 - x2;
+      int j = z1 - z2;
+      return i >= -radius && i <= radius ? j >= -radius && j <= radius : false;
    }
 
-   public void updateMovingPlayer(EntityPlayerMP var1) {
-      int ☃ = (int)☃.posX >> 4;
-      int ☃x = (int)☃.posZ >> 4;
-      double ☃xx = ☃.managedPosX - ☃.posX;
-      double ☃xxx = ☃.managedPosZ - ☃.posZ;
-      double ☃xxxx = ☃xx * ☃xx + ☃xxx * ☃xxx;
-      if (!(☃xxxx < 64.0)) {
-         int ☃xxxxx = (int)☃.managedPosX >> 4;
-         int ☃xxxxxx = (int)☃.managedPosZ >> 4;
-         int ☃xxxxxxx = this.playerViewRadius;
-         int ☃xxxxxxxx = ☃ - ☃xxxxx;
-         int ☃xxxxxxxxx = ☃x - ☃xxxxxx;
-         if (☃xxxxxxxx != 0 || ☃xxxxxxxxx != 0) {
-            for (int ☃xxxxxxxxxx = ☃ - ☃xxxxxxx; ☃xxxxxxxxxx <= ☃ + ☃xxxxxxx; ☃xxxxxxxxxx++) {
-               for (int ☃xxxxxxxxxxx = ☃x - ☃xxxxxxx; ☃xxxxxxxxxxx <= ☃x + ☃xxxxxxx; ☃xxxxxxxxxxx++) {
-                  if (!this.overlaps(☃xxxxxxxxxx, ☃xxxxxxxxxxx, ☃xxxxx, ☃xxxxxx, ☃xxxxxxx)) {
-                     this.getOrCreateEntry(☃xxxxxxxxxx, ☃xxxxxxxxxxx).addPlayer(☃);
+   public void updateMovingPlayer(EntityPlayerMP player) {
+      int i = (int)player.posX >> 4;
+      int j = (int)player.posZ >> 4;
+      double d0 = player.managedPosX - player.posX;
+      double d1 = player.managedPosZ - player.posZ;
+      double d2 = d0 * d0 + d1 * d1;
+      if (d2 >= 64.0) {
+         int k = (int)player.managedPosX >> 4;
+         int l = (int)player.managedPosZ >> 4;
+         int i1 = this.playerViewRadius;
+         int j1 = i - k;
+         int k1 = j - l;
+         if (j1 != 0 || k1 != 0) {
+            Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(player);
+
+            for (int l1 = i - i1; l1 <= i + i1; l1++) {
+               for (int i2 = j - i1; i2 <= j + i1; i2++) {
+                  if (!this.overlaps(l1, i2, k, l, i1)) {
+                     if (Config.isLazyChunkLoading()) {
+                        setPendingEntries.add(new ChunkPos(l1, i2));
+                     } else {
+                        this.getOrCreateEntry(l1, i2).addPlayer(player);
+                     }
                   }
 
-                  if (!this.overlaps(☃xxxxxxxxxx - ☃xxxxxxxx, ☃xxxxxxxxxxx - ☃xxxxxxxxx, ☃, ☃x, ☃xxxxxxx)) {
-                     PlayerChunkMapEntry ☃xxxxxxxxxxxx = this.getEntry(☃xxxxxxxxxx - ☃xxxxxxxx, ☃xxxxxxxxxxx - ☃xxxxxxxxx);
-                     if (☃xxxxxxxxxxxx != null) {
-                        ☃xxxxxxxxxxxx.removePlayer(☃);
+                  if (!this.overlaps(l1 - j1, i2 - k1, i, j, i1)) {
+                     setPendingEntries.remove(new ChunkPos(l1 - j1, i2 - k1));
+                     PlayerChunkMapEntry playerchunkmapentry = this.getEntry(l1 - j1, i2 - k1);
+                     if (playerchunkmapentry != null) {
+                        playerchunkmapentry.removePlayer(player);
                      }
                   }
                }
             }
 
-            ☃.managedPosX = ☃.posX;
-            ☃.managedPosZ = ☃.posZ;
+            player.managedPosX = player.posX;
+            player.managedPosZ = player.posZ;
             this.markSortPending();
          }
       }
    }
 
-   public boolean isPlayerWatchingChunk(EntityPlayerMP var1, int var2, int var3) {
-      PlayerChunkMapEntry ☃ = this.getEntry(☃, ☃);
-      return ☃ != null && ☃.containsPlayer(☃) && ☃.isSentToPlayers();
+   public boolean isPlayerWatchingChunk(EntityPlayerMP player, int chunkX, int chunkZ) {
+      PlayerChunkMapEntry playerchunkmapentry = this.getEntry(chunkX, chunkZ);
+      return playerchunkmapentry != null && playerchunkmapentry.containsPlayer(player) && playerchunkmapentry.isSentToPlayers();
    }
 
-   public void setPlayerViewRadius(int var1) {
-      ☃ = MathHelper.clamp(☃, 3, 32);
-      if (☃ != this.playerViewRadius) {
-         int ☃ = ☃ - this.playerViewRadius;
-
-         for (EntityPlayerMP ☃x : Lists.newArrayList(this.players)) {
-            int ☃xx = (int)☃x.posX >> 4;
-            int ☃xxx = (int)☃x.posZ >> 4;
-            if (☃ > 0) {
-               for (int ☃xxxx = ☃xx - ☃; ☃xxxx <= ☃xx + ☃; ☃xxxx++) {
-                  for (int ☃xxxxx = ☃xxx - ☃; ☃xxxxx <= ☃xxx + ☃; ☃xxxxx++) {
-                     PlayerChunkMapEntry ☃xxxxxx = this.getOrCreateEntry(☃xxxx, ☃xxxxx);
-                     if (!☃xxxxxx.containsPlayer(☃x)) {
-                        ☃xxxxxx.addPlayer(☃x);
+   public void setPlayerViewRadius(int radius) {
+      radius = MathHelper.clamp(radius, 3, 64);
+      if (radius != this.playerViewRadius) {
+         int i = radius - this.playerViewRadius;
+
+         for (EntityPlayerMP entityplayermp : Lists.newArrayList(this.players)) {
+            int j = (int)entityplayermp.posX >> 4;
+            int k = (int)entityplayermp.posZ >> 4;
+            Set<ChunkPos> setPendingEntries = this.getPendingEntriesSafe(entityplayermp);
+            if (i > 0) {
+               for (int j1 = j - radius; j1 <= j + radius; j1++) {
+                  for (int k1 = k - radius; k1 <= k + radius; k1++) {
+                     if (Config.isLazyChunkLoading()) {
+                        setPendingEntries.add(new ChunkPos(j1, k1));
+                     } else {
+                        PlayerChunkMapEntry playerchunkmapentry = this.getOrCreateEntry(j1, k1);
+                        if (!playerchunkmapentry.containsPlayer(entityplayermp)) {
+                           playerchunkmapentry.addPlayer(entityplayermp);
+                        }
                      }
                   }
                }
             } else {
-               for (int ☃xxxx = ☃xx - this.playerViewRadius; ☃xxxx <= ☃xx + this.playerViewRadius; ☃xxxx++) {
-                  for (int ☃xxxxxx = ☃xxx - this.playerViewRadius; ☃xxxxxx <= ☃xxx + this.playerViewRadius; ☃xxxxxx++) {
-                     if (!this.overlaps(☃xxxx, ☃xxxxxx, ☃xx, ☃xxx, ☃)) {
-                        this.getOrCreateEntry(☃xxxx, ☃xxxxxx).removePlayer(☃x);
+               for (int l = j - this.playerViewRadius; l <= j + this.playerViewRadius; l++) {
+                  for (int i1 = k - this.playerViewRadius; i1 <= k + this.playerViewRadius; i1++) {
+                     if (!this.overlaps(l, i1, j, k, radius)) {
+                        setPendingEntries.remove(new ChunkPos(l, i1));
+                        PlayerChunkMapEntry entry = this.getEntry(l, i1);
+                        if (entry != null) {
+                           entry.removePlayer(entityplayermp);
+                        }
                      }
                   }
                }
             }
          }
 
-         this.playerViewRadius = ☃;
+         this.playerViewRadius = radius;
          this.markSortPending();
       }
    }
@@ -319,30 +381,79 @@ private void markSortPending() {
       this.sortSendToPlayers = true;
    }
 
-   public static int getFurthestViewableBlock(int var0) {
-      return ☃ * 16 - 16;
+   public static int getFurthestViewableBlock(int distance) {
+      return distance * 16 - 16;
    }
 
-   private static long getIndex(int var0, int var1) {
-      return ☃ + 2147483647L | ☃ + 2147483647L << 32;
+   private static long getIndex(int p_187307_0_, int p_187307_1_) {
+      return p_187307_0_ + 2147483647L | p_187307_1_ + 2147483647L << 32;
    }
 
-   public void entryChanged(PlayerChunkMapEntry var1) {
-      this.dirtyEntries.add(☃);
+   public void entryChanged(PlayerChunkMapEntry entry) {
+      this.dirtyEntries.add(entry);
+   }
+
+   public void removeEntry(PlayerChunkMapEntry entry) {
+      ChunkPos chunkpos = entry.getPos();
+      long i = getIndex(chunkpos.x, chunkpos.z);
+      entry.updateChunkInhabitedTime();
+      this.entryMap.remove(i);
+      this.entries.remove(entry);
+      this.dirtyEntries.remove(entry);
+      this.pendingSendToPlayers.remove(entry);
+      this.entriesWithoutChunks.remove(entry);
+      Chunk chunk = entry.getChunk();
+      if (chunk != null) {
+         this.getWorldServer().getChunkProvider().queueUnload(chunk);
+      }
+   }
+
+   private PriorityQueue<ChunkPos> getNearest(Set<ChunkPos> setPending, EntityPlayerMP player, int count) {
+      float playerYaw = player.rotationYaw + 90.0F;
+
+      while (playerYaw <= -180.0F) {
+         playerYaw += 360.0F;
+      }
+
+      while (playerYaw > 180.0F) {
+         playerYaw -= 360.0F;
+      }
+
+      double playerYawRad = playerYaw * (Math.PI / 180.0);
+      double playerPitch = player.rotationPitch;
+      double playerPitchRad = playerPitch * (Math.PI / 180.0);
+      ChunkPosComparator comp = new ChunkPosComparator(player.chunkCoordX, player.chunkCoordZ, playerYawRad, playerPitchRad);
+      Comparator<ChunkPos> compRev = Collections.reverseOrder(comp);
+      PriorityQueue<ChunkPos> queue = new PriorityQueue<>(compRev);
+
+      for (ChunkPos chunkPos : setPending) {
+         if (queue.size() < count) {
+            queue.add(chunkPos);
+         } else {
+            ChunkPos furthest = queue.peek();
+            if (comp.compare(chunkPos, furthest) < 0) {
+               queue.remove();
+               queue.add(chunkPos);
+            }
+         }
+      }
+
+      return queue;
    }
 
-   public void removeEntry(PlayerChunkMapEntry var1) {
-      ChunkPos ☃ = ☃.getPos();
-      long ☃x = getIndex(☃.x, ☃.z);
-      ☃.updateChunkInhabitedTime();
-      this.entryMap.remove(☃x);
-      this.entries.remove(☃);
-      this.dirtyEntries.remove(☃);
-      this.pendingSendToPlayers.remove(☃);
-      this.entriesWithoutChunks.remove(☃);
-      Chunk ☃xx = ☃.getChunk();
-      if (☃xx != null) {
-         this.getWorldServer().getChunkProvider().queueUnload(☃xx);
+   private Set<ChunkPos> getPendingEntriesSafe(EntityPlayerMP player) {
+      Set<ChunkPos> setPendingEntries = this.mapPlayerPendingEntries.get(player);
+      if (setPendingEntries != null) {
+         return setPendingEntries;
+      } else {
+         int loadRadius = Math.min(this.playerViewRadius, 8);
+         int playerWidth = this.playerViewRadius * 2 + 1;
+         int loadWidth = loadRadius * 2 + 1;
+         int countLazyChunks = playerWidth * playerWidth - loadWidth * loadWidth;
+         countLazyChunks = Math.max(countLazyChunks, 16);
+         Set<ChunkPos> var7 = new HashSet(countLazyChunks);
+         this.mapPlayerPendingEntries.put(player, var7);
+         return var7;
       }
    }
 }
diff --git a/patches/net/minecraft/util/ClassInheritanceMultiMap.java b/patches/net/minecraft/util/ClassInheritanceMultiMap.java
index 84047a8..a0eeaa4 100644
--- a/patches/net/minecraft/util/ClassInheritanceMultiMap.java
+++ b/patches/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -10,100 +10,111 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import net.optifine.util.IteratorCache;
 
 public class ClassInheritanceMultiMap<T> extends AbstractSet<T> {
-   private static final Set<Class<?>> ALL_KNOWN = Sets.newHashSet();
+   private static final Set<Class<?>> ALL_KNOWN = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Map<Class<?>, List<T>> map = Maps.newHashMap();
    private final Set<Class<?>> knownKeys = Sets.newIdentityHashSet();
    private final Class<T> baseClass;
    private final List<T> values = Lists.newArrayList();
+   public boolean empty;
 
-   public ClassInheritanceMultiMap(Class<T> var1) {
-      this.baseClass = ☃;
-      this.knownKeys.add(☃);
-      this.map.put(☃, this.values);
+   public ClassInheritanceMultiMap(Class<T> baseClassIn) {
+      this.baseClass = baseClassIn;
+      this.knownKeys.add(baseClassIn);
+      this.map.put(baseClassIn, this.values);
 
-      for (Class<?> ☃ : ALL_KNOWN) {
-         this.createLookup(☃);
+      for (Class<?> oclass : ALL_KNOWN) {
+         this.createLookup(oclass);
       }
+
+      this.empty = this.values.size() == 0;
    }
 
-   protected void createLookup(Class<?> var1) {
-      ALL_KNOWN.add(☃);
+   protected void createLookup(Class<?> clazz) {
+      ALL_KNOWN.add(clazz);
+      int count = this.values.size();
 
-      for (T ☃ : this.values) {
-         if (☃.isAssignableFrom(☃.getClass())) {
-            this.addForClass(☃, ☃);
+      for (int i = 0; i < count; i++) {
+         T t = this.values.get(i);
+         if (clazz.isAssignableFrom(t.getClass())) {
+            this.addForClass(t, clazz);
          }
       }
 
-      this.knownKeys.add(☃);
+      this.knownKeys.add(clazz);
    }
 
-   protected Class<?> initializeClassLookup(Class<?> var1) {
-      if (this.baseClass.isAssignableFrom(☃)) {
-         if (!this.knownKeys.contains(☃)) {
-            this.createLookup(☃);
+   protected Class<?> initializeClassLookup(Class<?> clazz) {
+      if (this.baseClass.isAssignableFrom(clazz)) {
+         if (!this.knownKeys.contains(clazz)) {
+            this.createLookup(clazz);
          }
 
-         return ☃;
+         return clazz;
       } else {
-         throw new IllegalArgumentException("Don't know how to search for " + ☃);
+         throw new IllegalArgumentException("Don't know how to search for " + clazz);
       }
    }
 
    @Override
-   public boolean add(T var1) {
-      for (Class<?> ☃ : this.knownKeys) {
-         if (☃.isAssignableFrom(☃.getClass())) {
-            this.addForClass(☃, ☃);
+   public boolean add(T p_add_1_) {
+      for (Class<?> oclass : this.knownKeys) {
+         if (oclass.isAssignableFrom(p_add_1_.getClass())) {
+            this.addForClass(p_add_1_, oclass);
          }
       }
 
+      this.empty = this.values.size() == 0;
       return true;
    }
 
-   private void addForClass(T var1, Class<?> var2) {
-      List<T> ☃ = this.map.get(☃);
-      if (☃ == null) {
-         this.map.put(☃, Lists.newArrayList(new Object[]{☃}));
+   private void addForClass(T value, Class<?> parentClass) {
+      List<T> list = this.map.get(parentClass);
+      if (list == null) {
+         this.map.put(parentClass, Lists.newArrayList(new Object[]{value}));
       } else {
-         ☃.add(☃);
+         list.add(value);
       }
+
+      this.empty = this.values.size() == 0;
    }
 
    @Override
-   public boolean remove(Object var1) {
-      T ☃ = (T)☃;
-      boolean ☃x = false;
-
-      for (Class<?> ☃xx : this.knownKeys) {
-         if (☃xx.isAssignableFrom(☃.getClass())) {
-            List<T> ☃xxx = this.map.get(☃xx);
-            if (☃xxx != null && ☃xxx.remove(☃)) {
-               ☃x = true;
+   public boolean remove(Object p_remove_1_) {
+      T t = (T)p_remove_1_;
+      boolean flag = false;
+
+      for (Class<?> oclass : this.knownKeys) {
+         if (oclass.isAssignableFrom(t.getClass())) {
+            List<T> list = this.map.get(oclass);
+            if (list != null && list.remove(t)) {
+               flag = true;
             }
          }
       }
 
-      return ☃x;
+      this.empty = this.values.size() == 0;
+      return flag;
    }
 
    @Override
-   public boolean contains(Object var1) {
-      return Iterators.contains(this.getByClass(☃.getClass()).iterator(), ☃);
+   public boolean contains(Object p_contains_1_) {
+      return Iterators.contains(this.getByClass(p_contains_1_.getClass()).iterator(), p_contains_1_);
    }
 
-   public <S> Iterable<S> getByClass(final Class<S> var1) {
+   public <S> Iterable<S> getByClass(final Class<S> clazz) {
       return new Iterable<S>() {
          @Override
          public Iterator<S> iterator() {
-            List<T> ☃ = ClassInheritanceMultiMap.this.map.get(ClassInheritanceMultiMap.this.initializeClassLookup(☃));
-            if (☃ == null) {
+            List<T> list = ClassInheritanceMultiMap.this.map.get(ClassInheritanceMultiMap.this.initializeClassLookup(clazz));
+            if (list == null) {
                return Collections.emptyIterator();
             } else {
-               Iterator<T> ☃x = ☃.iterator();
-               return Iterators.filter(☃x, ☃);
+               Iterator<T> iterator = list.iterator();
+               return Iterators.filter(iterator, clazz);
             }
          }
       };
@@ -111,11 +122,16 @@ public Iterator<S> iterator() {
 
    @Override
    public Iterator<T> iterator() {
-      return (Iterator<T>)(this.values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.values.iterator()));
+      return this.values.isEmpty() ? Collections.emptyIterator() : IteratorCache.getReadOnly(this.values);
    }
 
    @Override
    public int size() {
       return this.values.size();
    }
+
+   @Override
+   public boolean isEmpty() {
+      return this.empty;
+   }
 }
diff --git a/patches/net/minecraft/util/EnumFacing.java b/patches/net/minecraft/util/EnumFacing.java
index 17b2677..07d2b6c 100644
--- a/patches/net/minecraft/util/EnumFacing.java
+++ b/patches/net/minecraft/util/EnumFacing.java
@@ -28,18 +28,20 @@ public enum EnumFacing implements IStringSerializable {
    private final EnumFacing.Axis axis;
    private final EnumFacing.AxisDirection axisDirection;
    private final Vec3i directionVec;
-   private static final EnumFacing[] VALUES = new EnumFacing[6];
+   public static final EnumFacing[] VALUES = new EnumFacing[6];
    private static final EnumFacing[] HORIZONTALS = new EnumFacing[4];
    private static final Map<String, EnumFacing> NAME_LOOKUP = Maps.newHashMap();
 
-   private EnumFacing(int var3, int var4, int var5, String var6, EnumFacing.AxisDirection var7, EnumFacing.Axis var8, Vec3i var9) {
-      this.index = ☃;
-      this.horizontalIndex = ☃;
-      this.opposite = ☃;
-      this.name = ☃;
-      this.axis = ☃;
-      this.axisDirection = ☃;
-      this.directionVec = ☃;
+   private EnumFacing(
+      int indexIn, int oppositeIn, int horizontalIndexIn, String nameIn, EnumFacing.AxisDirection axisDirectionIn, EnumFacing.Axis axisIn, Vec3i directionVecIn
+   ) {
+      this.index = indexIn;
+      this.horizontalIndex = horizontalIndexIn;
+      this.opposite = oppositeIn;
+      this.name = nameIn;
+      this.axis = axisIn;
+      this.axisDirection = axisDirectionIn;
+      this.directionVec = directionVecIn;
    }
 
    public int getIndex() {
@@ -55,11 +57,11 @@ public EnumFacing.AxisDirection getAxisDirection() {
    }
 
    public EnumFacing getOpposite() {
-      return byIndex(this.opposite);
+      return VALUES[this.opposite];
    }
 
-   public EnumFacing rotateAround(EnumFacing.Axis var1) {
-      switch (☃) {
+   public EnumFacing rotateAround(EnumFacing.Axis axis) {
+      switch (axis) {
          case X:
             if (this != WEST && this != EAST) {
                return this.rotateX();
@@ -79,7 +81,7 @@ public EnumFacing rotateAround(EnumFacing.Axis var1) {
 
             return this;
          default:
-            throw new IllegalStateException("Unable to get CW facing for axis " + ☃);
+            throw new IllegalStateException("Unable to get CW facing for axis " + axis);
       }
    }
 
@@ -167,43 +169,43 @@ public EnumFacing.Axis getAxis() {
    }
 
    @Nullable
-   public static EnumFacing byName(String var0) {
-      return ☃ == null ? null : NAME_LOOKUP.get(☃.toLowerCase(Locale.ROOT));
+   public static EnumFacing byName(String name) {
+      return name == null ? null : NAME_LOOKUP.get(name.toLowerCase(Locale.ROOT));
    }
 
-   public static EnumFacing byIndex(int var0) {
-      return VALUES[MathHelper.abs(☃ % VALUES.length)];
+   public static EnumFacing byIndex(int index) {
+      return VALUES[MathHelper.abs(index % VALUES.length)];
    }
 
-   public static EnumFacing byHorizontalIndex(int var0) {
-      return HORIZONTALS[MathHelper.abs(☃ % HORIZONTALS.length)];
+   public static EnumFacing byHorizontalIndex(int horizontalIndexIn) {
+      return HORIZONTALS[MathHelper.abs(horizontalIndexIn % HORIZONTALS.length)];
    }
 
-   public static EnumFacing fromAngle(double var0) {
-      return byHorizontalIndex(MathHelper.floor(☃ / 90.0 + 0.5) & 3);
+   public static EnumFacing fromAngle(double angle) {
+      return byHorizontalIndex(MathHelper.floor(angle / 90.0 + 0.5) & 3);
    }
 
    public float getHorizontalAngle() {
       return (this.horizontalIndex & 3) * 90;
    }
 
-   public static EnumFacing random(Random var0) {
-      return values()[☃.nextInt(values().length)];
+   public static EnumFacing random(Random rand) {
+      return values()[rand.nextInt(values().length)];
    }
 
-   public static EnumFacing getFacingFromVector(float var0, float var1, float var2) {
-      EnumFacing ☃ = NORTH;
-      float ☃x = Float.MIN_VALUE;
+   public static EnumFacing getFacingFromVector(float x, float y, float z) {
+      EnumFacing enumfacing = NORTH;
+      float f = Float.MIN_VALUE;
 
-      for (EnumFacing ☃xx : values()) {
-         float ☃xxx = ☃ * ☃xx.directionVec.getX() + ☃ * ☃xx.directionVec.getY() + ☃ * ☃xx.directionVec.getZ();
-         if (☃xxx > ☃x) {
-            ☃x = ☃xxx;
-            ☃ = ☃xx;
+      for (EnumFacing enumfacing1 : values()) {
+         float f1 = x * enumfacing1.directionVec.getX() + y * enumfacing1.directionVec.getY() + z * enumfacing1.directionVec.getZ();
+         if (f1 > f) {
+            f = f1;
+            enumfacing = enumfacing1;
          }
       }
 
-      return ☃;
+      return enumfacing;
    }
 
    @Override
@@ -211,34 +213,33 @@ public String toString() {
       return this.name;
    }
 
-   @Override
    public String getName() {
       return this.name;
    }
 
-   public static EnumFacing getFacingFromAxis(EnumFacing.AxisDirection var0, EnumFacing.Axis var1) {
-      for (EnumFacing ☃ : values()) {
-         if (☃.getAxisDirection() == ☃ && ☃.getAxis() == ☃) {
-            return ☃;
+   public static EnumFacing getFacingFromAxis(EnumFacing.AxisDirection axisDirectionIn, EnumFacing.Axis axisIn) {
+      for (EnumFacing enumfacing : values()) {
+         if (enumfacing.getAxisDirection() == axisDirectionIn && enumfacing.getAxis() == axisIn) {
+            return enumfacing;
          }
       }
 
-      throw new IllegalArgumentException("No such direction: " + ☃ + " " + ☃);
+      throw new IllegalArgumentException("No such direction: " + axisDirectionIn + " " + axisIn);
    }
 
-   public static EnumFacing getDirectionFromEntityLiving(BlockPos var0, EntityLivingBase var1) {
-      if (Math.abs(☃.posX - (☃.getX() + 0.5F)) < 2.0 && Math.abs(☃.posZ - (☃.getZ() + 0.5F)) < 2.0) {
-         double ☃ = ☃.posY + ☃.getEyeHeight();
-         if (☃ - ☃.getY() > 2.0) {
+   public static EnumFacing getDirectionFromEntityLiving(BlockPos pos, EntityLivingBase placer) {
+      if (Math.abs(placer.posX - (pos.getX() + 0.5F)) < 2.0 && Math.abs(placer.posZ - (pos.getZ() + 0.5F)) < 2.0) {
+         double d0 = placer.posY + placer.getEyeHeight();
+         if (d0 - pos.getY() > 2.0) {
             return UP;
          }
 
-         if (☃.getY() - ☃ > 0.0) {
+         if (pos.getY() - d0 > 0.0) {
             return DOWN;
          }
       }
 
-      return ☃.getHorizontalFacing().getOpposite();
+      return placer.getHorizontalFacing().getOpposite();
    }
 
    public Vec3i getDirectionVec() {
@@ -246,13 +247,13 @@ public Vec3i getDirectionVec() {
    }
 
    static {
-      for (EnumFacing ☃ : values()) {
-         VALUES[☃.index] = ☃;
-         if (☃.getAxis().isHorizontal()) {
-            HORIZONTALS[☃.horizontalIndex] = ☃;
+      for (EnumFacing enumfacing : values()) {
+         VALUES[enumfacing.index] = enumfacing;
+         if (enumfacing.getAxis().isHorizontal()) {
+            HORIZONTALS[enumfacing.horizontalIndex] = enumfacing;
          }
 
-         NAME_LOOKUP.put(☃.getName2().toLowerCase(Locale.ROOT), ☃);
+         NAME_LOOKUP.put(enumfacing.getName2().toLowerCase(Locale.ROOT), enumfacing);
       }
    }
 
@@ -265,14 +266,14 @@ public static enum Axis implements Predicate<EnumFacing>, IStringSerializable {
       private final String name;
       private final EnumFacing.Plane plane;
 
-      private Axis(String var3, EnumFacing.Plane var4) {
-         this.name = ☃;
-         this.plane = ☃;
+      private Axis(String name, EnumFacing.Plane plane) {
+         this.name = name;
+         this.plane = plane;
       }
 
       @Nullable
-      public static EnumFacing.Axis byName(String var0) {
-         return ☃ == null ? null : NAME_LOOKUP.get(☃.toLowerCase(Locale.ROOT));
+      public static EnumFacing.Axis byName(String name) {
+         return name == null ? null : NAME_LOOKUP.get(name.toLowerCase(Locale.ROOT));
       }
 
       public String getName2() {
@@ -292,22 +293,21 @@ public String toString() {
          return this.name;
       }
 
-      public boolean apply(@Nullable EnumFacing var1) {
-         return ☃ != null && ☃.getAxis() == this;
+      public boolean apply(@Nullable EnumFacing p_apply_1_) {
+         return p_apply_1_ != null && p_apply_1_.getAxis() == this;
       }
 
       public EnumFacing.Plane getPlane() {
          return this.plane;
       }
 
-      @Override
       public String getName() {
          return this.name;
       }
 
       static {
-         for (EnumFacing.Axis ☃ : values()) {
-            NAME_LOOKUP.put(☃.getName2().toLowerCase(Locale.ROOT), ☃);
+         for (EnumFacing.Axis enumfacing$axis : values()) {
+            NAME_LOOKUP.put(enumfacing$axis.getName2().toLowerCase(Locale.ROOT), enumfacing$axis);
          }
       }
    }
@@ -319,9 +319,9 @@ public static enum AxisDirection {
       private final int offset;
       private final String description;
 
-      private AxisDirection(int var3, String var4) {
-         this.offset = ☃;
-         this.description = ☃;
+      private AxisDirection(int offset, String description) {
+         this.offset = offset;
+         this.description = description;
       }
 
       public int getOffset() {
@@ -349,13 +349,13 @@ public EnumFacing[] facings() {
          }
       }
 
-      public EnumFacing random(Random var1) {
-         EnumFacing[] ☃ = this.facings();
-         return ☃[☃.nextInt(☃.length)];
+      public EnumFacing random(Random rand) {
+         EnumFacing[] aenumfacing = this.facings();
+         return aenumfacing[rand.nextInt(aenumfacing.length)];
       }
 
-      public boolean apply(@Nullable EnumFacing var1) {
-         return ☃ != null && ☃.getAxis().getPlane() == this;
+      public boolean apply(@Nullable EnumFacing p_apply_1_) {
+         return p_apply_1_ != null && p_apply_1_.getAxis().getPlane() == this;
       }
 
       @Override
diff --git a/patches/net/minecraft/util/IntegerCache.java b/patches/net/minecraft/util/IntegerCache.java
index 08f6078..14fd6c8 100644
--- a/patches/net/minecraft/util/IntegerCache.java
+++ b/patches/net/minecraft/util/IntegerCache.java
@@ -3,15 +3,15 @@
 public class IntegerCache {
    private static final Integer[] CACHE = new Integer[65535];
 
-   public static Integer getInteger(int var0) {
-      return ☃ > 0 && ☃ < CACHE.length ? CACHE[☃] : ☃;
+   public static Integer getInteger(int value) {
+      return value >= 0 && value < CACHE.length ? CACHE[value] : new Integer(value);
    }
 
    static {
-      int ☃ = 0;
+      int i = 0;
 
-      for (int ☃x = CACHE.length; ☃ < ☃x; ☃++) {
-         CACHE[☃] = ☃;
+      for (int j = CACHE.length; i < j; i++) {
+         CACHE[i] = i;
       }
    }
 }
diff --git a/patches/net/minecraft/util/ScreenShotHelper.java b/patches/net/minecraft/util/ScreenShotHelper.java
index b33f3f9..0799ff1 100644
--- a/patches/net/minecraft/util/ScreenShotHelper.java
+++ b/patches/net/minecraft/util/ScreenShotHelper.java
@@ -9,6 +9,8 @@
 import java.util.Date;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.texture.TextureUtil;
@@ -17,6 +19,8 @@
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.util.text.TextComponentTranslation;
 import net.minecraft.util.text.event.ClickEvent;
+import net.minecraft.util.text.event.ClickEvent.Action;
+import net.optifine.reflect.Reflector;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.BufferUtils;
@@ -27,73 +31,133 @@ public class ScreenShotHelper {
    private static IntBuffer pixelBuffer;
    private static int[] pixelValues;
 
-   public static ITextComponent saveScreenshot(File var0, int var1, int var2, Framebuffer var3) {
-      return saveScreenshot(☃, null, ☃, ☃, ☃);
+   public static ITextComponent saveScreenshot(File gameDirectory, int width, int height, Framebuffer buffer) {
+      return saveScreenshot(gameDirectory, (String)null, width, height, buffer);
    }
 
-   public static ITextComponent saveScreenshot(File var0, @Nullable String var1, int var2, int var3, Framebuffer var4) {
+   public static ITextComponent saveScreenshot(File gameDirectory, @Nullable String screenshotName, int width, int height, Framebuffer buffer) {
       try {
-         File ☃ = new File(☃, "screenshots");
-         ☃.mkdir();
-         BufferedImage ☃x = createScreenshot(☃, ☃, ☃);
-         File ☃xx;
-         if (☃ == null) {
-            ☃xx = getTimestampedPNGFileForDirectory(☃);
+         File file1 = new File(gameDirectory, "screenshots");
+         file1.mkdir();
+         Minecraft mc = Minecraft.getMinecraft();
+         int guiScaleOld = Config.getGameSettings().guiScale;
+         ScaledResolution sr = new ScaledResolution(mc);
+         int guiScale = sr.getScaleFactor();
+         int mul = Config.getScreenshotSize();
+         boolean resize = OpenGlHelper.isFramebufferEnabled() && mul > 1;
+         if (resize) {
+            Config.getGameSettings().guiScale = guiScale * mul;
+            resize(width * mul, height * mul);
+            GlStateManager.pushMatrix();
+            GlStateManager.clear(16640);
+            mc.getFramebuffer().bindFramebuffer(true);
+            mc.entityRenderer.updateCameraAndRender(mc.getRenderPartialTicks(), System.nanoTime());
+         }
+
+         BufferedImage bufferedimage = createScreenshot(width, height, buffer);
+         if (resize) {
+            mc.getFramebuffer().unbindFramebuffer();
+            GlStateManager.popMatrix();
+            Config.getGameSettings().guiScale = guiScaleOld;
+            resize(width, height);
+         }
+
+         File file2;
+         if (screenshotName == null) {
+            file2 = getTimestampedPNGFileForDirectory(file1);
          } else {
-            ☃xx = new File(☃, ☃);
+            file2 = new File(file1, screenshotName);
+         }
+
+         file2 = file2.getCanonicalFile();
+         Object event = null;
+         if (Reflector.ForgeHooksClient_onScreenshot.exists()) {
+            event = Reflector.call(Reflector.ForgeHooksClient_onScreenshot, new Object[]{bufferedimage, file2});
+            if (Reflector.callBoolean(event, Reflector.Event_isCanceled, new Object[0])) {
+               return (ITextComponent)Reflector.call(event, Reflector.ScreenshotEvent_getCancelMessage, new Object[0]);
+            }
+
+            file2 = (File)Reflector.call(event, Reflector.ScreenshotEvent_getScreenshotFile, new Object[0]);
+         }
+
+         ImageIO.write(bufferedimage, "png", file2);
+         ITextComponent itextcomponent = new TextComponentString(file2.getName());
+         itextcomponent.getStyle().setClickEvent(new ClickEvent(Action.OPEN_FILE, file2.getAbsolutePath()));
+         itextcomponent.getStyle().setUnderlined(true);
+         if (event != null) {
+            ITextComponent resultMessage = (ITextComponent)Reflector.call(event, Reflector.ScreenshotEvent_getResultMessage, new Object[0]);
+            if (resultMessage != null) {
+               return resultMessage;
+            }
          }
 
-         ImageIO.write(☃x, "png", ☃xx);
-         ITextComponent ☃xxx = new TextComponentString(☃xx.getName());
-         ☃xxx.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_FILE, ☃xx.getAbsolutePath()));
-         ☃xxx.getStyle().setUnderlined(true);
-         return new TextComponentTranslation("screenshot.success", ☃xxx);
-      } catch (Exception var9) {
-         LOGGER.warn("Couldn't save screenshot", var9);
-         return new TextComponentTranslation("screenshot.failure", var9.getMessage());
+         return new TextComponentTranslation("screenshot.success", new Object[]{itextcomponent});
+      } catch (Exception var17) {
+         LOGGER.warn("Couldn't save screenshot", var17);
+         return new TextComponentTranslation("screenshot.failure", new Object[]{var17.getMessage()});
       }
    }
 
-   public static BufferedImage createScreenshot(int var0, int var1, Framebuffer var2) {
+   public static BufferedImage createScreenshot(int width, int height, Framebuffer framebufferIn) {
       if (OpenGlHelper.isFramebufferEnabled()) {
-         ☃ = ☃.framebufferTextureWidth;
-         ☃ = ☃.framebufferTextureHeight;
+         width = framebufferIn.framebufferTextureWidth;
+         height = framebufferIn.framebufferTextureHeight;
       }
 
-      int ☃ = ☃ * ☃;
-      if (pixelBuffer == null || pixelBuffer.capacity() < ☃) {
-         pixelBuffer = BufferUtils.createIntBuffer(☃);
-         pixelValues = new int[☃];
+      int i = width * height;
+      if (pixelBuffer == null || pixelBuffer.capacity() < i) {
+         pixelBuffer = BufferUtils.createIntBuffer(i);
+         pixelValues = new int[i];
       }
 
       GlStateManager.glPixelStorei(3333, 1);
       GlStateManager.glPixelStorei(3317, 1);
       ((Buffer)pixelBuffer).clear();
       if (OpenGlHelper.isFramebufferEnabled()) {
-         GlStateManager.bindTexture(☃.framebufferTexture);
+         GlStateManager.bindTexture(framebufferIn.framebufferTexture);
          GlStateManager.glGetTexImage(3553, 0, 32993, 33639, pixelBuffer);
       } else {
-         GlStateManager.glReadPixels(0, 0, ☃, ☃, 32993, 33639, pixelBuffer);
+         GlStateManager.glReadPixels(0, 0, width, height, 32993, 33639, pixelBuffer);
       }
 
       pixelBuffer.get(pixelValues);
-      TextureUtil.processPixelValues(pixelValues, ☃, ☃);
-      BufferedImage ☃x = new BufferedImage(☃, ☃, 1);
-      ☃x.setRGB(0, 0, ☃, ☃, pixelValues, 0, ☃);
-      return ☃x;
+      TextureUtil.processPixelValues(pixelValues, width, height);
+      BufferedImage bufferedimage = new BufferedImage(width, height, 1);
+      bufferedimage.setRGB(0, 0, width, height, pixelValues, 0, width);
+      return bufferedimage;
    }
 
-   private static File getTimestampedPNGFileForDirectory(File var0) {
-      String ☃ = DATE_FORMAT.format(new Date()).toString();
-      int ☃x = 1;
+   private static File getTimestampedPNGFileForDirectory(File gameDirectory) {
+      String s = DATE_FORMAT.format(new Date()).toString();
+      int i = 1;
 
       while (true) {
-         File ☃xx = new File(☃, ☃ + (☃x == 1 ? "" : "_" + ☃x) + ".png");
-         if (!☃xx.exists()) {
-            return ☃xx;
+         File file1 = new File(gameDirectory, s + (i == 1 ? "" : "_" + i) + ".png");
+         if (!file1.exists()) {
+            return file1;
          }
 
-         ☃x++;
+         i++;
+      }
+   }
+
+   private static void resize(int width, int height) {
+      Minecraft mc = Minecraft.getMinecraft();
+      mc.displayWidth = Math.max(1, width);
+      mc.displayHeight = Math.max(1, height);
+      if (mc.currentScreen != null) {
+         ScaledResolution sr = new ScaledResolution(mc);
+         mc.currentScreen.onResize(mc, sr.getScaledWidth(), sr.getScaledHeight());
+      }
+
+      updateFramebufferSize();
+   }
+
+   private static void updateFramebufferSize() {
+      Minecraft mc = Minecraft.getMinecraft();
+      mc.getFramebuffer().createBindFramebuffer(mc.displayWidth, mc.displayHeight);
+      if (mc.entityRenderer != null) {
+         mc.entityRenderer.updateShaderGroupSize(mc.displayWidth, mc.displayHeight);
       }
    }
 }
diff --git a/patches/net/minecraft/util/Util.java b/patches/net/minecraft/util/Util.java
index 80e2ec5..ae90af9 100644
--- a/patches/net/minecraft/util/Util.java
+++ b/patches/net/minecraft/util/Util.java
@@ -9,38 +9,42 @@
 
 public class Util {
    public static Util.EnumOS getOSType() {
-      String ☃ = System.getProperty("os.name").toLowerCase(Locale.ROOT);
-      if (☃.contains("win")) {
+      String s = System.getProperty("os.name").toLowerCase(Locale.ROOT);
+      if (s.contains("win")) {
          return Util.EnumOS.WINDOWS;
-      } else if (☃.contains("mac")) {
+      } else if (s.contains("mac")) {
          return Util.EnumOS.OSX;
-      } else if (☃.contains("solaris")) {
+      } else if (s.contains("solaris")) {
          return Util.EnumOS.SOLARIS;
-      } else if (☃.contains("sunos")) {
+      } else if (s.contains("sunos")) {
          return Util.EnumOS.SOLARIS;
-      } else if (☃.contains("linux")) {
+      } else if (s.contains("linux")) {
          return Util.EnumOS.LINUX;
       } else {
-         return ☃.contains("unix") ? Util.EnumOS.LINUX : Util.EnumOS.UNKNOWN;
+         return s.contains("unix") ? Util.EnumOS.LINUX : Util.EnumOS.UNKNOWN;
       }
    }
 
    @Nullable
-   public static <V> V runTask(FutureTask<V> var0, Logger var1) {
+   public static <V> V runTask(FutureTask<V> task, Logger logger) {
       try {
-         ☃.run();
-         return ☃.get();
-      } catch (ExecutionException var3) {
-         ☃.fatal("Error executing task", var3);
-      } catch (InterruptedException var4) {
-         ☃.fatal("Error executing task", var4);
+         task.run();
+         return task.get();
+      } catch (ExecutionException var4) {
+         logger.fatal("Error executing task", var4);
+         if (var4.getCause() instanceof OutOfMemoryError) {
+            OutOfMemoryError oome = (OutOfMemoryError)var4.getCause();
+            throw oome;
+         }
+      } catch (InterruptedException var5) {
+         logger.fatal("Error executing task", var5);
       }
 
       return null;
    }
 
-   public static <T> T getLastElement(List<T> var0) {
-      return ☃.get(☃.size() - 1);
+   public static <T> T getLastElement(List<T> list) {
+      return list.get(list.size() - 1);
    }
 
    public static enum EnumOS {
diff --git a/patches/net/minecraft/util/math/ChunkPos.java b/patches/net/minecraft/util/math/ChunkPos.java
index 5930dbe..eba810d 100644
--- a/patches/net/minecraft/util/math/ChunkPos.java
+++ b/patches/net/minecraft/util/math/ChunkPos.java
@@ -5,46 +5,52 @@
 public class ChunkPos {
    public final int x;
    public final int z;
+   private int cachedHashCode = 0;
 
-   public ChunkPos(int var1, int var2) {
-      this.x = ☃;
-      this.z = ☃;
+   public ChunkPos(int x, int z) {
+      this.x = x;
+      this.z = z;
    }
 
-   public ChunkPos(BlockPos var1) {
-      this.x = ☃.getX() >> 4;
-      this.z = ☃.getZ() >> 4;
+   public ChunkPos(BlockPos pos) {
+      this.x = pos.getX() >> 4;
+      this.z = pos.getZ() >> 4;
    }
 
-   public static long asLong(int var0, int var1) {
-      return ☃ & 4294967295L | (☃ & 4294967295L) << 32;
+   public static long asLong(int x, int z) {
+      return x & 4294967295L | (z & 4294967295L) << 32;
    }
 
    @Override
    public int hashCode() {
-      int ☃ = 1664525 * this.x + 1013904223;
-      int ☃x = 1664525 * (this.z ^ -559038737) + 1013904223;
-      return ☃ ^ ☃x;
+      if (this.cachedHashCode != 0) {
+         return this.cachedHashCode;
+      } else {
+         int i = 1664525 * this.x + 1013904223;
+         int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+         this.cachedHashCode = i ^ j;
+         return this.cachedHashCode;
+      }
    }
 
    @Override
-   public boolean equals(Object var1) {
-      if (this == ☃) {
+   public boolean equals(Object p_equals_1_) {
+      if (this == p_equals_1_) {
          return true;
-      } else if (!(☃ instanceof ChunkPos)) {
+      } else if (!(p_equals_1_ instanceof ChunkPos)) {
          return false;
       } else {
-         ChunkPos ☃ = (ChunkPos)☃;
-         return this.x == ☃.x && this.z == ☃.z;
+         ChunkPos chunkpos = (ChunkPos)p_equals_1_;
+         return this.x == chunkpos.x && this.z == chunkpos.z;
       }
    }
 
-   public double getDistanceSq(Entity var1) {
-      double ☃ = this.x * 16 + 8;
-      double ☃x = this.z * 16 + 8;
-      double ☃xx = ☃ - ☃.posX;
-      double ☃xxx = ☃x - ☃.posZ;
-      return ☃xx * ☃xx + ☃xxx * ☃xxx;
+   public double getDistanceSq(Entity entityIn) {
+      double d0 = this.x * 16 + 8;
+      double d1 = this.z * 16 + 8;
+      double d2 = d0 - entityIn.posX;
+      double d3 = d1 - entityIn.posZ;
+      return d2 * d2 + d3 * d3;
    }
 
    public int getXStart() {
@@ -63,8 +69,8 @@ public int getZEnd() {
       return (this.z << 4) + 15;
    }
 
-   public BlockPos getBlock(int var1, int var2, int var3) {
-      return new BlockPos((this.x << 4) + ☃, ☃, (this.z << 4) + ☃);
+   public BlockPos getBlock(int x, int y, int z) {
+      return new BlockPos((this.x << 4) + x, y, (this.z << 4) + z);
    }
 
    @Override
diff --git a/patches/net/minecraft/util/math/MathHelper.java b/patches/net/minecraft/util/math/MathHelper.java
index f1f893a..f6480eb 100644
--- a/patches/net/minecraft/util/math/MathHelper.java
+++ b/patches/net/minecraft/util/math/MathHelper.java
@@ -2,9 +2,21 @@
 
 import java.util.Random;
 import java.util.UUID;
+import net.optifine.util.MathUtils;
 
 public class MathHelper {
    public static final float SQRT_2 = sqrt(2.0F);
+   private static final int SIN_BITS = 12;
+   private static final int SIN_MASK = 4095;
+   private static final int SIN_COUNT = 4096;
+   private static final int SIN_COUNT_D4 = 1024;
+   public static final float PI = MathUtils.roundToFloat(Math.PI);
+   public static final float PI2 = MathUtils.roundToFloat(Math.PI * 2);
+   public static final float PId2 = MathUtils.roundToFloat(Math.PI / 2);
+   private static final float radToIndex = MathUtils.roundToFloat(651.8986469044033);
+   public static final float deg2Rad = MathUtils.roundToFloat(Math.PI / 180.0);
+   private static final float[] SIN_TABLE_FAST = new float[4096];
+   public static boolean fastMath = false;
    private static final float[] SIN_TABLE = new float[65536];
    private static final Random RANDOM = new Random();
    private static final int[] MULTIPLY_DE_BRUIJN_BIT_POSITION;
@@ -12,417 +24,421 @@ public class MathHelper {
    private static final double[] ASINE_TAB;
    private static final double[] COS_TAB;
 
-   public static float sin(float var0) {
-      return SIN_TABLE[(int)(☃ * 10430.378F) & 65535];
+   public static float sin(float value) {
+      return fastMath ? SIN_TABLE_FAST[(int)(value * radToIndex) & 4095] : SIN_TABLE[(int)(value * 10430.378F) & 65535];
    }
 
-   public static float cos(float var0) {
-      return SIN_TABLE[(int)(☃ * 10430.378F + 16384.0F) & 65535];
+   public static float cos(float value) {
+      return fastMath ? SIN_TABLE_FAST[(int)(value * radToIndex + 1024.0F) & 4095] : SIN_TABLE[(int)(value * 10430.378F + 16384.0F) & 65535];
    }
 
-   public static float sqrt(float var0) {
-      return (float)Math.sqrt(☃);
+   public static float sqrt(float value) {
+      return (float)Math.sqrt(value);
    }
 
-   public static float sqrt(double var0) {
-      return (float)Math.sqrt(☃);
+   public static float sqrt(double value) {
+      return (float)Math.sqrt(value);
    }
 
-   public static int floor(float var0) {
-      int ☃ = (int)☃;
-      return ☃ < ☃ ? ☃ - 1 : ☃;
+   public static int floor(float value) {
+      int i = (int)value;
+      return value < i ? i - 1 : i;
    }
 
-   public static int fastFloor(double var0) {
-      return (int)(☃ + 1024.0) - 1024;
+   public static int fastFloor(double value) {
+      return (int)(value + 1024.0) - 1024;
    }
 
-   public static int floor(double var0) {
-      int ☃ = (int)☃;
-      return ☃ < ☃ ? ☃ - 1 : ☃;
+   public static int floor(double value) {
+      int i = (int)value;
+      return value < i ? i - 1 : i;
    }
 
-   public static long lfloor(double var0) {
-      long ☃ = (long)☃;
-      return ☃ < ☃ ? ☃ - 1L : ☃;
+   public static long lfloor(double value) {
+      long i = (long)value;
+      return value < i ? i - 1L : i;
    }
 
-   public static int absFloor(double var0) {
-      return (int)(☃ >= 0.0 ? ☃ : -☃ + 1.0);
+   public static int absFloor(double value) {
+      return (int)(value >= 0.0 ? value : -value + 1.0);
    }
 
-   public static float abs(float var0) {
-      return ☃ >= 0.0F ? ☃ : -☃;
+   public static float abs(float value) {
+      return value >= 0.0F ? value : -value;
    }
 
-   public static int abs(int var0) {
-      return ☃ >= 0 ? ☃ : -☃;
+   public static int abs(int value) {
+      return value >= 0 ? value : -value;
    }
 
-   public static int ceil(float var0) {
-      int ☃ = (int)☃;
-      return ☃ > ☃ ? ☃ + 1 : ☃;
+   public static int ceil(float value) {
+      int i = (int)value;
+      return value > i ? i + 1 : i;
    }
 
-   public static int ceil(double var0) {
-      int ☃ = (int)☃;
-      return ☃ > ☃ ? ☃ + 1 : ☃;
+   public static int ceil(double value) {
+      int i = (int)value;
+      return value > i ? i + 1 : i;
    }
 
-   public static int clamp(int var0, int var1, int var2) {
-      if (☃ < ☃) {
-         return ☃;
+   public static int clamp(int num, int min, int max) {
+      if (num < min) {
+         return min;
       } else {
-         return ☃ > ☃ ? ☃ : ☃;
+         return num > max ? max : num;
       }
    }
 
-   public static float clamp(float var0, float var1, float var2) {
-      if (☃ < ☃) {
-         return ☃;
+   public static float clamp(float num, float min, float max) {
+      if (num < min) {
+         return min;
       } else {
-         return ☃ > ☃ ? ☃ : ☃;
+         return num > max ? max : num;
       }
    }
 
-   public static double clamp(double var0, double var2, double var4) {
-      if (☃ < ☃) {
-         return ☃;
+   public static double clamp(double num, double min, double max) {
+      if (num < min) {
+         return min;
       } else {
-         return ☃ > ☃ ? ☃ : ☃;
+         return num > max ? max : num;
       }
    }
 
-   public static double clampedLerp(double var0, double var2, double var4) {
-      if (☃ < 0.0) {
-         return ☃;
+   public static double clampedLerp(double lowerBnd, double upperBnd, double slide) {
+      if (slide < 0.0) {
+         return lowerBnd;
       } else {
-         return ☃ > 1.0 ? ☃ : ☃ + (☃ - ☃) * ☃;
+         return slide > 1.0 ? upperBnd : lowerBnd + (upperBnd - lowerBnd) * slide;
       }
    }
 
-   public static double absMax(double var0, double var2) {
-      if (☃ < 0.0) {
-         ☃ = -☃;
+   public static double absMax(double p_76132_0_, double p_76132_2_) {
+      if (p_76132_0_ < 0.0) {
+         p_76132_0_ = -p_76132_0_;
       }
 
-      if (☃ < 0.0) {
-         ☃ = -☃;
+      if (p_76132_2_ < 0.0) {
+         p_76132_2_ = -p_76132_2_;
       }
 
-      return ☃ > ☃ ? ☃ : ☃;
+      return p_76132_0_ > p_76132_2_ ? p_76132_0_ : p_76132_2_;
    }
 
-   public static int intFloorDiv(int var0, int var1) {
-      return ☃ < 0 ? -((-☃ - 1) / ☃) - 1 : ☃ / ☃;
+   public static int intFloorDiv(int p_76137_0_, int p_76137_1_) {
+      return p_76137_0_ < 0 ? -((-p_76137_0_ - 1) / p_76137_1_) - 1 : p_76137_0_ / p_76137_1_;
    }
 
-   public static int getInt(Random var0, int var1, int var2) {
-      return ☃ >= ☃ ? ☃ : ☃.nextInt(☃ - ☃ + 1) + ☃;
+   public static int getInt(Random random, int minimum, int maximum) {
+      return minimum >= maximum ? minimum : random.nextInt(maximum - minimum + 1) + minimum;
    }
 
-   public static float nextFloat(Random var0, float var1, float var2) {
-      return ☃ >= ☃ ? ☃ : ☃.nextFloat() * (☃ - ☃) + ☃;
+   public static float nextFloat(Random random, float minimum, float maximum) {
+      return minimum >= maximum ? minimum : random.nextFloat() * (maximum - minimum) + minimum;
    }
 
-   public static double nextDouble(Random var0, double var1, double var3) {
-      return ☃ >= ☃ ? ☃ : ☃.nextDouble() * (☃ - ☃) + ☃;
+   public static double nextDouble(Random random, double minimum, double maximum) {
+      return minimum >= maximum ? minimum : random.nextDouble() * (maximum - minimum) + minimum;
    }
 
-   public static double average(long[] var0) {
-      long ☃ = 0L;
+   public static double average(long[] values) {
+      long i = 0L;
 
-      for (long ☃x : ☃) {
-         ☃ += ☃x;
+      for (long j : values) {
+         i += j;
       }
 
-      return (double)☃ / ☃.length;
+      return (double)i / values.length;
    }
 
-   public static boolean epsilonEquals(float var0, float var1) {
-      return abs(☃ - ☃) < 1.0E-5F;
+   public static boolean epsilonEquals(float p_180185_0_, float p_180185_1_) {
+      return abs(p_180185_1_ - p_180185_0_) < 1.0E-5F;
    }
 
-   public static int normalizeAngle(int var0, int var1) {
-      return (☃ % ☃ + ☃) % ☃;
+   public static int normalizeAngle(int p_180184_0_, int p_180184_1_) {
+      return (p_180184_0_ % p_180184_1_ + p_180184_1_) % p_180184_1_;
    }
 
-   public static float positiveModulo(float var0, float var1) {
-      return (☃ % ☃ + ☃) % ☃;
+   public static float positiveModulo(float numerator, float denominator) {
+      return (numerator % denominator + denominator) % denominator;
    }
 
-   public static double positiveModulo(double var0, double var2) {
-      return (☃ % ☃ + ☃) % ☃;
+   public static double positiveModulo(double numerator, double denominator) {
+      return (numerator % denominator + denominator) % denominator;
    }
 
-   public static float wrapDegrees(float var0) {
-      ☃ %= 360.0F;
-      if (☃ >= 180.0F) {
-         ☃ -= 360.0F;
+   public static float wrapDegrees(float value) {
+      value %= 360.0F;
+      if (value >= 180.0F) {
+         value -= 360.0F;
       }
 
-      if (☃ < -180.0F) {
-         ☃ += 360.0F;
+      if (value < -180.0F) {
+         value += 360.0F;
       }
 
-      return ☃;
+      return value;
    }
 
-   public static double wrapDegrees(double var0) {
-      ☃ %= 360.0;
-      if (☃ >= 180.0) {
-         ☃ -= 360.0;
+   public static double wrapDegrees(double value) {
+      value %= 360.0;
+      if (value >= 180.0) {
+         value -= 360.0;
       }
 
-      if (☃ < -180.0) {
-         ☃ += 360.0;
+      if (value < -180.0) {
+         value += 360.0;
       }
 
-      return ☃;
+      return value;
    }
 
-   public static int wrapDegrees(int var0) {
-      ☃ %= 360;
-      if (☃ >= 180) {
-         ☃ -= 360;
+   public static int wrapDegrees(int angle) {
+      angle %= 360;
+      if (angle >= 180) {
+         angle -= 360;
       }
 
-      if (☃ < -180) {
-         ☃ += 360;
+      if (angle < -180) {
+         angle += 360;
       }
 
-      return ☃;
+      return angle;
    }
 
-   public static int getInt(String var0, int var1) {
+   public static int getInt(String value, int defaultValue) {
       try {
-         return Integer.parseInt(☃);
+         return Integer.parseInt(value);
       } catch (Throwable var3) {
-         return ☃;
+         return defaultValue;
       }
    }
 
-   public static int getInt(String var0, int var1, int var2) {
-      return Math.max(☃, getInt(☃, ☃));
+   public static int getInt(String value, int defaultValue, int max) {
+      return Math.max(max, getInt(value, defaultValue));
    }
 
-   public static double getDouble(String var0, double var1) {
+   public static double getDouble(String value, double defaultValue) {
       try {
-         return Double.parseDouble(☃);
+         return Double.parseDouble(value);
       } catch (Throwable var4) {
-         return ☃;
+         return defaultValue;
       }
    }
 
-   public static double getDouble(String var0, double var1, double var3) {
-      return Math.max(☃, getDouble(☃, ☃));
+   public static double getDouble(String value, double defaultValue, double max) {
+      return Math.max(max, getDouble(value, defaultValue));
    }
 
-   public static int smallestEncompassingPowerOfTwo(int var0) {
-      int ☃ = ☃ - 1;
-      ☃ |= ☃ >> 1;
-      ☃ |= ☃ >> 2;
-      ☃ |= ☃ >> 4;
-      ☃ |= ☃ >> 8;
-      ☃ |= ☃ >> 16;
-      return ☃ + 1;
+   public static int smallestEncompassingPowerOfTwo(int value) {
+      int i = value - 1;
+      i |= i >> 1;
+      i |= i >> 2;
+      i |= i >> 4;
+      i |= i >> 8;
+      i |= i >> 16;
+      return i + 1;
    }
 
-   private static boolean isPowerOfTwo(int var0) {
-      return ☃ != 0 && (☃ & ☃ - 1) == 0;
+   private static boolean isPowerOfTwo(int value) {
+      return value != 0 && (value & value - 1) == 0;
    }
 
-   public static int log2DeBruijn(int var0) {
-      ☃ = isPowerOfTwo(☃) ? ☃ : smallestEncompassingPowerOfTwo(☃);
-      return MULTIPLY_DE_BRUIJN_BIT_POSITION[(int)(☃ * 125613361L >> 27) & 31];
+   public static int log2DeBruijn(int value) {
+      value = isPowerOfTwo(value) ? value : smallestEncompassingPowerOfTwo(value);
+      return MULTIPLY_DE_BRUIJN_BIT_POSITION[(int)(value * 125613361L >> 27) & 31];
    }
 
-   public static int log2(int var0) {
-      return log2DeBruijn(☃) - (isPowerOfTwo(☃) ? 0 : 1);
+   public static int log2(int value) {
+      return log2DeBruijn(value) - (isPowerOfTwo(value) ? 0 : 1);
    }
 
-   public static int roundUp(int var0, int var1) {
-      if (☃ == 0) {
+   public static int roundUp(int number, int interval) {
+      if (interval == 0) {
          return 0;
-      } else if (☃ == 0) {
-         return ☃;
+      } else if (number == 0) {
+         return interval;
       } else {
-         if (☃ < 0) {
-            ☃ *= -1;
+         if (number < 0) {
+            interval *= -1;
          }
 
-         int ☃ = ☃ % ☃;
-         return ☃ == 0 ? ☃ : ☃ + ☃ - ☃;
+         int i = number % interval;
+         return i == 0 ? number : number + interval - i;
       }
    }
 
-   public static int rgb(float var0, float var1, float var2) {
-      return rgb(floor(☃ * 255.0F), floor(☃ * 255.0F), floor(☃ * 255.0F));
+   public static int rgb(float rIn, float gIn, float bIn) {
+      return rgb(floor(rIn * 255.0F), floor(gIn * 255.0F), floor(bIn * 255.0F));
    }
 
-   public static int rgb(int var0, int var1, int var2) {
-      int var3 = (☃ << 8) + ☃;
-      return (var3 << 8) + ☃;
+   public static int rgb(int rIn, int gIn, int bIn) {
+      int lvt_3_1_ = (rIn << 8) + gIn;
+      return (lvt_3_1_ << 8) + bIn;
    }
 
-   public static int multiplyColor(int var0, int var1) {
-      int ☃ = (☃ & 0xFF0000) >> 16;
-      int ☃x = (☃ & 0xFF0000) >> 16;
-      int ☃xx = (☃ & 0xFF00) >> 8;
-      int ☃xxx = (☃ & 0xFF00) >> 8;
-      int ☃xxxx = (☃ & 0xFF) >> 0;
-      int ☃xxxxx = (☃ & 0xFF) >> 0;
-      int ☃xxxxxx = (int)((float)☃ * ☃x / 255.0F);
-      int ☃xxxxxxx = (int)((float)☃xx * ☃xxx / 255.0F);
-      int ☃xxxxxxxx = (int)((float)☃xxxx * ☃xxxxx / 255.0F);
-      return ☃ & 0xFF000000 | ☃xxxxxx << 16 | ☃xxxxxxx << 8 | ☃xxxxxxxx;
+   public static int multiplyColor(int p_180188_0_, int p_180188_1_) {
+      int i = (p_180188_0_ & 0xFF0000) >> 16;
+      int j = (p_180188_1_ & 0xFF0000) >> 16;
+      int k = (p_180188_0_ & 0xFF00) >> 8;
+      int l = (p_180188_1_ & 0xFF00) >> 8;
+      int i1 = (p_180188_0_ & 0xFF) >> 0;
+      int j1 = (p_180188_1_ & 0xFF) >> 0;
+      int k1 = (int)((float)i * j / 255.0F);
+      int l1 = (int)((float)k * l / 255.0F);
+      int i2 = (int)((float)i1 * j1 / 255.0F);
+      return p_180188_0_ & 0xFF000000 | k1 << 16 | l1 << 8 | i2;
    }
 
-   public static double frac(double var0) {
-      return ☃ - Math.floor(☃);
+   public static double frac(double number) {
+      return number - Math.floor(number);
    }
 
-   public static long getPositionRandom(Vec3i var0) {
-      return getCoordinateRandom(☃.getX(), ☃.getY(), ☃.getZ());
+   public static long getPositionRandom(Vec3i pos) {
+      return getCoordinateRandom(pos.getX(), pos.getY(), pos.getZ());
    }
 
-   public static long getCoordinateRandom(int var0, int var1, int var2) {
-      long ☃ = ☃ * 3129871 ^ ☃ * 116129781L ^ ☃;
-      return ☃ * ☃ * 42317861L + ☃ * 11L;
+   public static long getCoordinateRandom(int x, int y, int z) {
+      long i = x * 3129871 ^ z * 116129781L ^ y;
+      return i * i * 42317861L + i * 11L;
    }
 
-   public static UUID getRandomUUID(Random var0) {
-      long ☃ = ☃.nextLong() & -61441L | 16384L;
-      long ☃x = ☃.nextLong() & 4611686018427387903L | Long.MIN_VALUE;
-      return new UUID(☃, ☃x);
+   public static UUID getRandomUUID(Random rand) {
+      long i = rand.nextLong() & -61441L | 16384L;
+      long j = rand.nextLong() & 4611686018427387903L | Long.MIN_VALUE;
+      return new UUID(i, j);
    }
 
    public static UUID getRandomUUID() {
       return getRandomUUID(RANDOM);
    }
 
-   public static double pct(double var0, double var2, double var4) {
-      return (☃ - ☃) / (☃ - ☃);
+   public static double pct(double p_181160_0_, double p_181160_2_, double p_181160_4_) {
+      return (p_181160_0_ - p_181160_2_) / (p_181160_4_ - p_181160_2_);
    }
 
-   public static double atan2(double var0, double var2) {
-      double ☃ = ☃ * ☃ + ☃ * ☃;
-      if (Double.isNaN(☃)) {
+   public static double atan2(double p_181159_0_, double p_181159_2_) {
+      double d0 = p_181159_2_ * p_181159_2_ + p_181159_0_ * p_181159_0_;
+      if (Double.isNaN(d0)) {
          return Double.NaN;
       } else {
-         boolean ☃x = ☃ < 0.0;
-         if (☃x) {
-            ☃ = -☃;
+         boolean flag = p_181159_0_ < 0.0;
+         if (flag) {
+            p_181159_0_ = -p_181159_0_;
          }
 
-         boolean ☃xx = ☃ < 0.0;
-         if (☃xx) {
-            ☃ = -☃;
+         boolean flag1 = p_181159_2_ < 0.0;
+         if (flag1) {
+            p_181159_2_ = -p_181159_2_;
          }
 
-         boolean ☃xxx = ☃ > ☃;
-         if (☃xxx) {
-            double ☃xxxx = ☃;
-            ☃ = ☃;
-            ☃ = ☃xxxx;
+         boolean flag2 = p_181159_0_ > p_181159_2_;
+         if (flag2) {
+            double d1 = p_181159_2_;
+            p_181159_2_ = p_181159_0_;
+            p_181159_0_ = d1;
          }
 
-         double ☃xxxx = fastInvSqrt(☃);
-         ☃ *= ☃xxxx;
-         ☃ *= ☃xxxx;
-         double ☃xxxxx = FRAC_BIAS + ☃;
-         int ☃xxxxxx = (int)Double.doubleToRawLongBits(☃xxxxx);
-         double ☃xxxxxxx = ASINE_TAB[☃xxxxxx];
-         double ☃xxxxxxxx = COS_TAB[☃xxxxxx];
-         double ☃xxxxxxxxx = ☃xxxxx - FRAC_BIAS;
-         double ☃xxxxxxxxxx = ☃ * ☃xxxxxxxx - ☃ * ☃xxxxxxxxx;
-         double ☃xxxxxxxxxxx = (6.0 + ☃xxxxxxxxxx * ☃xxxxxxxxxx) * ☃xxxxxxxxxx * 0.16666666666666666;
-         double ☃xxxxxxxxxxxx = ☃xxxxxxx + ☃xxxxxxxxxxx;
-         if (☃xxx) {
-            ☃xxxxxxxxxxxx = (Math.PI / 2) - ☃xxxxxxxxxxxx;
+         double d9 = fastInvSqrt(d0);
+         p_181159_2_ *= d9;
+         p_181159_0_ *= d9;
+         double d2 = FRAC_BIAS + p_181159_0_;
+         int i = (int)Double.doubleToRawLongBits(d2);
+         double d3 = ASINE_TAB[i];
+         double d4 = COS_TAB[i];
+         double d5 = d2 - FRAC_BIAS;
+         double d6 = p_181159_0_ * d4 - p_181159_2_ * d5;
+         double d7 = (6.0 + d6 * d6) * d6 * 0.16666666666666666;
+         double d8 = d3 + d7;
+         if (flag2) {
+            d8 = (Math.PI / 2) - d8;
          }
 
-         if (☃xx) {
-            ☃xxxxxxxxxxxx = Math.PI - ☃xxxxxxxxxxxx;
+         if (flag1) {
+            d8 = Math.PI - d8;
          }
 
-         if (☃x) {
-            ☃xxxxxxxxxxxx = -☃xxxxxxxxxxxx;
+         if (flag) {
+            d8 = -d8;
          }
 
-         return ☃xxxxxxxxxxxx;
+         return d8;
       }
    }
 
-   public static double fastInvSqrt(double var0) {
-      double ☃ = 0.5 * ☃;
-      long ☃x = Double.doubleToRawLongBits(☃);
-      ☃x = 6910469410427058090L - (☃x >> 1);
-      ☃ = Double.longBitsToDouble(☃x);
-      return ☃ * (1.5 - ☃ * ☃ * ☃);
-   }
-
-   public static int hsvToRGB(float var0, float var1, float var2) {
-      int ☃ = (int)(☃ * 6.0F) % 6;
-      float ☃x = ☃ * 6.0F - ☃;
-      float ☃xx = ☃ * (1.0F - ☃);
-      float ☃xxx = ☃ * (1.0F - ☃x * ☃);
-      float ☃xxxx = ☃ * (1.0F - (1.0F - ☃x) * ☃);
-      float ☃xxxxx;
-      float ☃xxxxxx;
-      float ☃xxxxxxx;
-      switch (☃) {
+   public static double fastInvSqrt(double p_181161_0_) {
+      double d0 = 0.5 * p_181161_0_;
+      long i = Double.doubleToRawLongBits(p_181161_0_);
+      i = 6910469410427058090L - (i >> 1);
+      p_181161_0_ = Double.longBitsToDouble(i);
+      return p_181161_0_ * (1.5 - d0 * p_181161_0_ * p_181161_0_);
+   }
+
+   public static int hsvToRGB(float hue, float saturation, float value) {
+      int i = (int)(hue * 6.0F) % 6;
+      float f = hue * 6.0F - i;
+      float f1 = value * (1.0F - saturation);
+      float f2 = value * (1.0F - f * saturation);
+      float f3 = value * (1.0F - (1.0F - f) * saturation);
+      float f4;
+      float f5;
+      float f6;
+      switch (i) {
          case 0:
-            ☃xxxxx = ☃;
-            ☃xxxxxx = ☃xxxx;
-            ☃xxxxxxx = ☃xx;
+            f4 = value;
+            f5 = f3;
+            f6 = f1;
             break;
          case 1:
-            ☃xxxxx = ☃xxx;
-            ☃xxxxxx = ☃;
-            ☃xxxxxxx = ☃xx;
+            f4 = f2;
+            f5 = value;
+            f6 = f1;
             break;
          case 2:
-            ☃xxxxx = ☃xx;
-            ☃xxxxxx = ☃;
-            ☃xxxxxxx = ☃xxxx;
+            f4 = f1;
+            f5 = value;
+            f6 = f3;
             break;
          case 3:
-            ☃xxxxx = ☃xx;
-            ☃xxxxxx = ☃xxx;
-            ☃xxxxxxx = ☃;
+            f4 = f1;
+            f5 = f2;
+            f6 = value;
             break;
          case 4:
-            ☃xxxxx = ☃xxxx;
-            ☃xxxxxx = ☃xx;
-            ☃xxxxxxx = ☃;
+            f4 = f3;
+            f5 = f1;
+            f6 = value;
             break;
          case 5:
-            ☃xxxxx = ☃;
-            ☃xxxxxx = ☃xx;
-            ☃xxxxxxx = ☃xxx;
+            f4 = value;
+            f5 = f1;
+            f6 = f2;
             break;
          default:
-            throw new RuntimeException("Something went wrong when converting from HSV to RGB. Input was " + ☃ + ", " + ☃ + ", " + ☃);
+            throw new RuntimeException("Something went wrong when converting from HSV to RGB. Input was " + hue + ", " + saturation + ", " + value);
       }
 
-      int ☃ = clamp((int)(☃xxxxx * 255.0F), 0, 255);
-      int ☃x = clamp((int)(☃xxxxxx * 255.0F), 0, 255);
-      int ☃xx = clamp((int)(☃xxxxxxx * 255.0F), 0, 255);
-      return ☃ << 16 | ☃x << 8 | ☃xx;
+      int j = clamp((int)(f4 * 255.0F), 0, 255);
+      int k = clamp((int)(f5 * 255.0F), 0, 255);
+      int l = clamp((int)(f6 * 255.0F), 0, 255);
+      return j << 16 | k << 8 | l;
    }
 
-   public static int hash(int var0) {
-      ☃ ^= ☃ >>> 16;
-      ☃ *= -2048144789;
-      ☃ ^= ☃ >>> 13;
-      ☃ *= -1028477387;
-      return ☃ ^ ☃ >>> 16;
+   public static int hash(int p_188208_0_) {
+      p_188208_0_ ^= p_188208_0_ >>> 16;
+      p_188208_0_ *= -2048144789;
+      p_188208_0_ ^= p_188208_0_ >>> 13;
+      p_188208_0_ *= -1028477387;
+      return p_188208_0_ ^ p_188208_0_ >>> 16;
    }
 
    static {
-      for (int ☃ = 0; ☃ < 65536; ☃++) {
-         SIN_TABLE[☃] = (float)Math.sin(☃ * Math.PI * 2.0 / 65536.0);
+      for (int i = 0; i < 65536; i++) {
+         SIN_TABLE[i] = (float)Math.sin(i * Math.PI * 2.0 / 65536.0);
+      }
+
+      for (int s = 0; s < SIN_TABLE_FAST.length; s++) {
+         SIN_TABLE_FAST[s] = MathUtils.roundToFloat(Math.sin(s * Math.PI * 2.0 / 4096.0));
       }
 
       MULTIPLY_DE_BRUIJN_BIT_POSITION = new int[]{
@@ -432,11 +448,11 @@ public static int hash(int var0) {
       ASINE_TAB = new double[257];
       COS_TAB = new double[257];
 
-      for (int ☃ = 0; ☃ < 257; ☃++) {
-         double ☃x = ☃ / 256.0;
-         double ☃xx = Math.asin(☃x);
-         COS_TAB[☃] = Math.cos(☃xx);
-         ASINE_TAB[☃] = ☃xx;
+      for (int j = 0; j < 257; j++) {
+         double d0 = j / 256.0;
+         double d1 = Math.asin(d0);
+         COS_TAB[j] = Math.cos(d1);
+         ASINE_TAB[j] = d1;
       }
    }
 }
diff --git a/patches/net/minecraft/util/text/translation/I18n.java b/patches/net/minecraft/util/text/translation/I18n.java
index fd84692..7ef4f80 100644
--- a/patches/net/minecraft/util/text/translation/I18n.java
+++ b/patches/net/minecraft/util/text/translation/I18n.java
@@ -6,23 +6,23 @@ public class I18n {
    private static final LanguageMap fallbackTranslator = new LanguageMap();
 
    @Deprecated
-   public static String translateToLocal(String var0) {
-      return localizedName.translateKey(☃);
+   public static String translateToLocal(String key) {
+      return localizedName.translateKey(key);
    }
 
    @Deprecated
-   public static String translateToLocalFormatted(String var0, Object... var1) {
-      return localizedName.translateKeyFormat(☃, ☃);
+   public static String translateToLocalFormatted(String key, Object... format) {
+      return localizedName.translateKeyFormat(key, format);
    }
 
    @Deprecated
-   public static String translateToFallback(String var0) {
-      return fallbackTranslator.translateKey(☃);
+   public static String translateToFallback(String key) {
+      return fallbackTranslator.translateKey(key);
    }
 
    @Deprecated
-   public static boolean canTranslate(String var0) {
-      return localizedName.isKeyTranslated(☃);
+   public static boolean canTranslate(String key) {
+      return localizedName.isKeyTranslated(key);
    }
 
    public static long getLastTranslationUpdateTimeInMilliseconds() {
diff --git a/patches/net/minecraft/world/GameRules.java b/patches/net/minecraft/world/GameRules.java
index f4bf39d..8db1080 100644
--- a/patches/net/minecraft/world/GameRules.java
+++ b/patches/net/minecraft/world/GameRules.java
@@ -34,63 +34,63 @@ public GameRules() {
       this.addGameRule("gameLoopFunction", "-", GameRules.ValueType.FUNCTION);
    }
 
-   public void addGameRule(String var1, String var2, GameRules.ValueType var3) {
-      this.rules.put(☃, new GameRules.Value(☃, ☃));
+   public void addGameRule(String key, String value, GameRules.ValueType type) {
+      this.rules.put(key, new GameRules.Value(value, type));
    }
 
-   public void setOrCreateGameRule(String var1, String var2) {
-      GameRules.Value ☃ = this.rules.get(☃);
-      if (☃ != null) {
-         ☃.setValue(☃);
+   public void setOrCreateGameRule(String key, String ruleValue) {
+      GameRules.Value gamerules$value = this.rules.get(key);
+      if (gamerules$value != null) {
+         gamerules$value.setValue(ruleValue);
       } else {
-         this.addGameRule(☃, ☃, GameRules.ValueType.ANY_VALUE);
+         this.addGameRule(key, ruleValue, GameRules.ValueType.ANY_VALUE);
       }
    }
 
-   public String getString(String var1) {
-      GameRules.Value ☃ = this.rules.get(☃);
-      return ☃ != null ? ☃.getString() : "";
+   public String getString(String name) {
+      GameRules.Value gamerules$value = this.rules.get(name);
+      return gamerules$value != null ? gamerules$value.getString() : "";
    }
 
-   public boolean getBoolean(String var1) {
-      GameRules.Value ☃ = this.rules.get(☃);
-      return ☃ != null ? ☃.getBoolean() : false;
+   public boolean getBoolean(String name) {
+      GameRules.Value gamerules$value = this.rules.get(name);
+      return gamerules$value != null ? gamerules$value.getBoolean() : false;
    }
 
-   public int getInt(String var1) {
-      GameRules.Value ☃ = this.rules.get(☃);
-      return ☃ != null ? ☃.getInt() : 0;
+   public int getInt(String name) {
+      GameRules.Value gamerules$value = this.rules.get(name);
+      return gamerules$value != null ? gamerules$value.getInt() : 0;
    }
 
    public NBTTagCompound writeToNBT() {
-      NBTTagCompound ☃ = new NBTTagCompound();
+      NBTTagCompound nbttagcompound = new NBTTagCompound();
 
-      for (String ☃x : this.rules.keySet()) {
-         GameRules.Value ☃xx = this.rules.get(☃x);
-         ☃.setString(☃x, ☃xx.getString());
+      for (String s : this.rules.keySet()) {
+         GameRules.Value gamerules$value = this.rules.get(s);
+         nbttagcompound.setString(s, gamerules$value.getString());
       }
 
-      return ☃;
+      return nbttagcompound;
    }
 
-   public void readFromNBT(NBTTagCompound var1) {
-      for (String ☃ : ☃.getKeySet()) {
-         this.setOrCreateGameRule(☃, ☃.getString(☃));
+   public void readFromNBT(NBTTagCompound nbt) {
+      for (String s : nbt.getKeySet()) {
+         this.setOrCreateGameRule(s, nbt.getString(s));
       }
    }
 
    public String[] getRules() {
-      Set<String> ☃ = this.rules.keySet();
-      return ☃.toArray(new String[☃.size()]);
+      Set<String> set = this.rules.keySet();
+      return set.toArray(new String[set.size()]);
    }
 
-   public boolean hasRule(String var1) {
-      return this.rules.containsKey(☃);
+   public boolean hasRule(String name) {
+      return this.rules.containsKey(name);
    }
 
-   public boolean areSameType(String var1, GameRules.ValueType var2) {
-      GameRules.Value ☃ = this.rules.get(☃);
-      return ☃ != null && (☃.getType() == ☃ || ☃ == GameRules.ValueType.ANY_VALUE);
+   public boolean areSameType(String key, GameRules.ValueType otherValue) {
+      GameRules.Value gamerules$value = this.rules.get(key);
+      return gamerules$value != null && (gamerules$value.getType() == otherValue || otherValue == GameRules.ValueType.ANY_VALUE);
    }
 
    static class Value {
@@ -100,23 +100,35 @@ static class Value {
       private double valueDouble;
       private final GameRules.ValueType type;
 
-      public Value(String var1, GameRules.ValueType var2) {
-         this.type = ☃;
-         this.setValue(☃);
+      public Value(String value, GameRules.ValueType type) {
+         this.type = type;
+         this.setValue(value);
       }
 
-      public void setValue(String var1) {
-         this.valueString = ☃;
-         this.valueBoolean = Boolean.parseBoolean(☃);
+      public void setValue(String value) {
+         this.valueString = value;
+         if (value != null) {
+            if (value.equals("false")) {
+               this.valueBoolean = false;
+               return;
+            }
+
+            if (value.equals("true")) {
+               this.valueBoolean = true;
+               return;
+            }
+         }
+
+         this.valueBoolean = Boolean.parseBoolean(value);
          this.valueInteger = this.valueBoolean ? 1 : 0;
 
          try {
-            this.valueInteger = Integer.parseInt(☃);
+            this.valueInteger = Integer.parseInt(value);
          } catch (NumberFormatException var4) {
          }
 
          try {
-            this.valueDouble = Double.parseDouble(☃);
+            this.valueDouble = Double.parseDouble(value);
          } catch (NumberFormatException var3) {
          }
       }
diff --git a/patches/net/minecraft/world/WorldEntitySpawner.java b/patches/net/minecraft/world/WorldEntitySpawner.java
index 86056dd..ec40a90 100644
--- a/patches/net/minecraft/world/WorldEntitySpawner.java
+++ b/patches/net/minecraft/world/WorldEntitySpawner.java
@@ -1,7 +1,13 @@
 package net.minecraft.world;
 
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import net.minecraft.block.Block;
@@ -19,121 +25,183 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.Biome.SpawnListEntry;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.BlockPosM;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
 
 public final class WorldEntitySpawner {
    private static final int MOB_COUNT_DIV = (int)Math.pow(17.0, 2.0);
    private final Set<ChunkPos> eligibleChunksForSpawning = Sets.newHashSet();
+   private Map<Class, EntityLiving> mapSampleEntitiesByClass = new HashMap<>();
+   private int lastPlayerChunkX = Integer.MAX_VALUE;
+   private int lastPlayerChunkZ = Integer.MAX_VALUE;
+   private int countChunkPos;
 
-   public int findChunksForSpawning(WorldServer var1, boolean var2, boolean var3, boolean var4) {
-      if (!☃ && !☃) {
+   public int findChunksForSpawning(WorldServer worldServerIn, boolean spawnHostileMobs, boolean spawnPeacefulMobs, boolean spawnOnSetTickRate) {
+      if (!spawnHostileMobs && !spawnPeacefulMobs) {
          return 0;
       } else {
-         this.eligibleChunksForSpawning.clear();
-         int ☃ = 0;
-
-         for (EntityPlayer ☃x : ☃.playerEntities) {
-            if (!☃x.isSpectator()) {
-               int ☃xx = MathHelper.floor(☃x.posX / 16.0);
-               int ☃xxx = MathHelper.floor(☃x.posZ / 16.0);
-               int ☃xxxx = 8;
-
-               for (int ☃xxxxx = -8; ☃xxxxx <= 8; ☃xxxxx++) {
-                  for (int ☃xxxxxx = -8; ☃xxxxxx <= 8; ☃xxxxxx++) {
-                     boolean ☃xxxxxxx = ☃xxxxx == -8 || ☃xxxxx == 8 || ☃xxxxxx == -8 || ☃xxxxxx == 8;
-                     ChunkPos ☃xxxxxxxx = new ChunkPos(☃xxxxx + ☃xx, ☃xxxxxx + ☃xxx);
-                     if (!this.eligibleChunksForSpawning.contains(☃xxxxxxxx)) {
-                        ☃++;
-                        if (!☃xxxxxxx && ☃.getWorldBorder().contains(☃xxxxxxxx)) {
-                           PlayerChunkMapEntry ☃xxxxxxxxx = ☃.getPlayerChunkMap().getEntry(☃xxxxxxxx.x, ☃xxxxxxxx.z);
-                           if (☃xxxxxxxxx != null && ☃xxxxxxxxx.isSentToPlayers()) {
-                              this.eligibleChunksForSpawning.add(☃xxxxxxxx);
+         boolean updateEligibleChunks = true;
+         EntityPlayer player = null;
+         if (worldServerIn.playerEntities.size() == 1) {
+            player = (EntityPlayer)worldServerIn.playerEntities.get(0);
+            if (this.eligibleChunksForSpawning.size() > 0
+               && player != null
+               && player.chunkCoordX == this.lastPlayerChunkX
+               && player.chunkCoordZ == this.lastPlayerChunkZ) {
+               updateEligibleChunks = false;
+            }
+         }
+
+         if (updateEligibleChunks) {
+            this.eligibleChunksForSpawning.clear();
+            int i = 0;
+
+            for (EntityPlayer entityplayer : worldServerIn.playerEntities) {
+               if (!entityplayer.isSpectator()) {
+                  int j = MathHelper.floor(entityplayer.posX / 16.0);
+                  int k = MathHelper.floor(entityplayer.posZ / 16.0);
+                  int l = 8;
+
+                  for (int i1 = -8; i1 <= 8; i1++) {
+                     for (int j1 = -8; j1 <= 8; j1++) {
+                        boolean flag = i1 == -8 || i1 == 8 || j1 == -8 || j1 == 8;
+                        ChunkPos chunkpos = new ChunkPos(i1 + j, j1 + k);
+                        if (!this.eligibleChunksForSpawning.contains(chunkpos)) {
+                           i++;
+                           if (!flag && worldServerIn.getWorldBorder().contains(chunkpos)) {
+                              PlayerChunkMapEntry playerchunkmapentry = worldServerIn.getPlayerChunkMap().getEntry(chunkpos.x, chunkpos.z);
+                              if (playerchunkmapentry != null && playerchunkmapentry.isSentToPlayers()) {
+                                 this.eligibleChunksForSpawning.add(chunkpos);
+                              }
                            }
                         }
                      }
                   }
                }
             }
+
+            this.countChunkPos = i;
+            if (player != null) {
+               this.lastPlayerChunkX = player.chunkCoordX;
+               this.lastPlayerChunkZ = player.chunkCoordZ;
+            }
          }
 
-         int ☃xx = 0;
-         BlockPos ☃xxx = ☃.getSpawnPoint();
-
-         for (EnumCreatureType ☃xxxx : EnumCreatureType.values()) {
-            if ((!☃xxxx.getPeacefulCreature() || ☃) && (☃xxxx.getPeacefulCreature() || ☃) && (!☃xxxx.getAnimal() || ☃)) {
-               int ☃xxxxx = ☃.countEntities(☃xxxx.getCreatureClass());
-               int ☃xxxxxxx = ☃xxxx.getMaxNumberOfCreature() * ☃ / MOB_COUNT_DIV;
-               if (☃xxxxx <= ☃xxxxxxx) {
-                  BlockPos.MutableBlockPos ☃xxxxxxxx = new BlockPos.MutableBlockPos();
-
-                  label134:
-                  for (ChunkPos ☃xxxxxxxxx : this.eligibleChunksForSpawning) {
-                     BlockPos ☃xxxxxxxxxx = getRandomChunkPosition(☃, ☃xxxxxxxxx.x, ☃xxxxxxxxx.z);
-                     int ☃xxxxxxxxxxx = ☃xxxxxxxxxx.getX();
-                     int ☃xxxxxxxxxxxx = ☃xxxxxxxxxx.getY();
-                     int ☃xxxxxxxxxxxxx = ☃xxxxxxxxxx.getZ();
-                     IBlockState ☃xxxxxxxxxxxxxx = ☃.getBlockState(☃xxxxxxxxxx);
-                     if (!☃xxxxxxxxxxxxxx.isNormalCube()) {
-                        int ☃xxxxxxxxxxxxxxx = 0;
-
-                        for (int ☃xxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxx < 3; ☃xxxxxxxxxxxxxxxx++) {
-                           int ☃xxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxx;
-                           int ☃xxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxx;
-                           int ☃xxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxx;
-                           int ☃xxxxxxxxxxxxxxxxxxxx = 6;
-                           Biome.SpawnListEntry ☃xxxxxxxxxxxxxxxxxxxxx = null;
-                           IEntityLivingData ☃xxxxxxxxxxxxxxxxxxxxxx = null;
-                           int ☃xxxxxxxxxxxxxxxxxxxxxxx = MathHelper.ceil(Math.random() * 4.0);
-
-                           for (int ☃xxxxxxxxxxxxxxxxxxxxxxxx = 0; ☃xxxxxxxxxxxxxxxxxxxxxxxx < ☃xxxxxxxxxxxxxxxxxxxxxxx; ☃xxxxxxxxxxxxxxxxxxxxxxxx++) {
-                              ☃xxxxxxxxxxxxxxxxx += ☃.rand.nextInt(6) - ☃.rand.nextInt(6);
-                              ☃xxxxxxxxxxxxxxxxxx += ☃.rand.nextInt(1) - ☃.rand.nextInt(1);
-                              ☃xxxxxxxxxxxxxxxxxxx += ☃.rand.nextInt(6) - ☃.rand.nextInt(6);
-                              ☃xxxxxxxx.setPos(☃xxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxx);
-                              float ☃xxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxx + 0.5F;
-                              float ☃xxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxx + 0.5F;
-                              if (!☃.isAnyPlayerWithinRangeAt(☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, 24.0)
-                                 && !(☃xxx.distanceSq(☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx) < 576.0)) {
-                                 if (☃xxxxxxxxxxxxxxxxxxxxx == null) {
-                                    ☃xxxxxxxxxxxxxxxxxxxxx = ☃.getSpawnListEntryForTypeAt(☃xxxx, ☃xxxxxxxx);
-                                    if (☃xxxxxxxxxxxxxxxxxxxxx == null) {
+         int j4 = 0;
+         BlockPos blockpos1 = worldServerIn.getSpawnPoint();
+         BlockPosM blockPosM = new BlockPosM(0, 0, 0);
+         MutableBlockPos blockpos$mutableblockpos = new MutableBlockPos();
+
+         for (EnumCreatureType enumcreaturetype : EnumCreatureType.values()) {
+            if ((!enumcreaturetype.getPeacefulCreature() || spawnPeacefulMobs)
+               && (enumcreaturetype.getPeacefulCreature() || spawnHostileMobs)
+               && (!enumcreaturetype.getAnimal() || spawnOnSetTickRate)) {
+               int k4 = Reflector.ForgeWorld_countEntities.exists()
+                  ? Reflector.callInt(worldServerIn, Reflector.ForgeWorld_countEntities, new Object[]{enumcreaturetype, true})
+                  : worldServerIn.countEntities(enumcreaturetype.getCreatureClass());
+               int l4 = enumcreaturetype.getMaxNumberOfCreature() * this.countChunkPos / MOB_COUNT_DIV;
+               if (k4 <= l4) {
+                  Collection<ChunkPos> chunksForSpawning = this.eligibleChunksForSpawning;
+                  if (Reflector.ForgeHooksClient.exists()) {
+                     ArrayList<ChunkPos> shuffled = Lists.newArrayList(chunksForSpawning);
+                     Collections.shuffle(shuffled);
+                     chunksForSpawning = shuffled;
+                  }
+
+                  label176:
+                  for (ChunkPos chunkpos1 : chunksForSpawning) {
+                     BlockPos blockpos = getRandomChunkPosition(worldServerIn, chunkpos1.x, chunkpos1.z, blockPosM);
+                     int k1 = blockpos.getX();
+                     int l1 = blockpos.getY();
+                     int i2 = blockpos.getZ();
+                     IBlockState iblockstate = worldServerIn.getBlockState(blockpos);
+                     if (!iblockstate.l()) {
+                        int j2 = 0;
+
+                        for (int k2 = 0; k2 < 3; k2++) {
+                           int l2 = k1;
+                           int i3 = l1;
+                           int j3 = i2;
+                           int k3 = 6;
+                           SpawnListEntry biome$spawnlistentry = null;
+                           IEntityLivingData ientitylivingdata = null;
+                           int l3 = MathHelper.ceil(Math.random() * 4.0);
+
+                           for (int i4 = 0; i4 < l3; i4++) {
+                              l2 += worldServerIn.rand.nextInt(6) - worldServerIn.rand.nextInt(6);
+                              i3 += worldServerIn.rand.nextInt(1) - worldServerIn.rand.nextInt(1);
+                              j3 += worldServerIn.rand.nextInt(6) - worldServerIn.rand.nextInt(6);
+                              blockpos$mutableblockpos.setPos(l2, i3, j3);
+                              float f = l2 + 0.5F;
+                              float f1 = j3 + 0.5F;
+                              if (!worldServerIn.isAnyPlayerWithinRangeAt(f, i3, f1, 24.0) && blockpos1.distanceSq(f, i3, f1) >= 576.0) {
+                                 if (biome$spawnlistentry == null) {
+                                    biome$spawnlistentry = worldServerIn.getSpawnListEntryForTypeAt(enumcreaturetype, blockpos$mutableblockpos);
+                                    if (biome$spawnlistentry == null) {
                                        break;
                                     }
                                  }
 
-                                 if (☃.canCreatureTypeSpawnHere(☃xxxx, ☃xxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxx)
+                                 if (worldServerIn.canCreatureTypeSpawnHere(enumcreaturetype, biome$spawnlistentry, blockpos$mutableblockpos)
                                     && canCreatureTypeSpawnAtLocation(
-                                       EntitySpawnPlacementRegistry.getPlacementForEntity(☃xxxxxxxxxxxxxxxxxxxxx.entityClass), ☃, ☃xxxxxxxx
+                                       EntitySpawnPlacementRegistry.getPlacementForEntity(biome$spawnlistentry.entityClass),
+                                       worldServerIn,
+                                       blockpos$mutableblockpos
                                     )) {
-                                    EntityLiving ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx;
+                                    EntityLiving entityliving;
                                     try {
-                                       ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxx.entityClass.getConstructor(World.class).newInstance(☃);
-                                    } catch (Exception var36) {
-                                       var36.printStackTrace();
-                                       return ☃xx;
+                                       entityliving = this.mapSampleEntitiesByClass.get(biome$spawnlistentry.entityClass);
+                                       if (entityliving == null) {
+                                          if (Reflector.ForgeBiomeSpawnListEntry_newInstance.exists()) {
+                                             entityliving = (EntityLiving)Reflector.call(
+                                                biome$spawnlistentry, Reflector.ForgeBiomeSpawnListEntry_newInstance, new Object[]{worldServerIn}
+                                             );
+                                          } else {
+                                             entityliving = (EntityLiving)biome$spawnlistentry.entityClass
+                                                .getConstructor(World.class)
+                                                .newInstance(worldServerIn);
+                                          }
+
+                                          this.mapSampleEntitiesByClass.put(biome$spawnlistentry.entityClass, entityliving);
+                                       }
+                                    } catch (Exception var40) {
+                                       var40.printStackTrace();
+                                       return j4;
                                     }
 
-                                    ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.setLocationAndAngles(
-                                       ☃xxxxxxxxxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxx, ☃xxxxxxxxxxxxxxxxxxxxxxxxxx, ☃.rand.nextFloat() * 360.0F, 0.0F
-                                    );
-                                    if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.getCanSpawnHere() && ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.isNotColliding()) {
-                                       ☃xxxxxxxxxxxxxxxxxxxxxx = ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.onInitialSpawn(
-                                          ☃.getDifficultyForLocation(new BlockPos(☃xxxxxxxxxxxxxxxxxxxxxxxxxxx)), ☃xxxxxxxxxxxxxxxxxxxxxx
-                                       );
-                                       if (☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.isNotColliding()) {
-                                          ☃xxxxxxxxxxxxxxx++;
-                                          ☃.spawnEntity(☃xxxxxxxxxxxxxxxxxxxxxxxxxxx);
+                                    entityliving.setLocationAndAngles(f, i3, f1, worldServerIn.rand.nextFloat() * 360.0F, 0.0F);
+                                    boolean canSpawn = Reflector.ForgeEventFactory_canEntitySpawn.exists()
+                                       ? ReflectorForge.canEntitySpawn(entityliving, worldServerIn, f, i3, f1)
+                                       : entityliving.getCanSpawnHere() && entityliving.isNotColliding();
+                                    if (canSpawn) {
+                                       this.mapSampleEntitiesByClass.remove(biome$spawnlistentry.entityClass);
+                                       if (!ReflectorForge.doSpecialSpawn(entityliving, worldServerIn, f, i3, f1)) {
+                                          ientitylivingdata = entityliving.onInitialSpawn(
+                                             worldServerIn.getDifficultyForLocation(new BlockPos(entityliving)), ientitylivingdata
+                                          );
+                                       }
+
+                                       if (entityliving.isNotColliding()) {
+                                          j2++;
+                                          worldServerIn.spawnEntity(entityliving);
                                        } else {
-                                          ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.setDead();
+                                          entityliving.setDead();
                                        }
 
-                                       if (☃xxxxxxxxxxxxxxx >= ☃xxxxxxxxxxxxxxxxxxxxxxxxxxx.getMaxSpawnedInChunk()) {
-                                          continue label134;
+                                       int maxSpawnedInChunk = Reflector.ForgeEventFactory_getMaxSpawnPackSize.exists()
+                                          ? Reflector.callInt(Reflector.ForgeEventFactory_getMaxSpawnPackSize, new Object[]{entityliving})
+                                          : entityliving.getMaxSpawnedInChunk();
+                                       if (j2 >= maxSpawnedInChunk) {
+                                          continue label176;
                                        }
                                     }
 
-                                    ☃xx += ☃xxxxxxxxxxxxxxx;
+                                    j4 += j2;
                                  }
                               }
                            }
@@ -144,88 +212,121 @@ && canCreatureTypeSpawnAtLocation(
             }
          }
 
-         return ☃xx;
+         return j4;
       }
    }
 
-   private static BlockPos getRandomChunkPosition(World var0, int var1, int var2) {
-      Chunk ☃ = ☃.getChunk(☃, ☃);
-      int ☃x = ☃ * 16 + ☃.rand.nextInt(16);
-      int ☃xx = ☃ * 16 + ☃.rand.nextInt(16);
-      int ☃xxx = MathHelper.roundUp(☃.getHeight(new BlockPos(☃x, 0, ☃xx)) + 1, 16);
-      int ☃xxxx = ☃.rand.nextInt(☃xxx > 0 ? ☃xxx : ☃.getTopFilledSegment() + 16 - 1);
-      return new BlockPos(☃x, ☃xxxx, ☃xx);
+   private static BlockPos getRandomChunkPosition(World worldIn, int x, int z) {
+      Chunk chunk = worldIn.getChunk(x, z);
+      int i = x * 16 + worldIn.rand.nextInt(16);
+      int j = z * 16 + worldIn.rand.nextInt(16);
+      int k = MathHelper.roundUp(chunk.getHeight(new BlockPos(i, 0, j)) + 1, 16);
+      int l = worldIn.rand.nextInt(k > 0 ? k : chunk.getTopFilledSegment() + 16 - 1);
+      return new BlockPos(i, l, j);
+   }
+
+   private static BlockPosM getRandomChunkPosition(World worldIn, int x, int z, BlockPosM blockPosM) {
+      Chunk chunk = worldIn.getChunk(x, z);
+      int px = x * 16 + worldIn.rand.nextInt(16);
+      int pz = z * 16 + worldIn.rand.nextInt(16);
+      int k = MathHelper.roundUp(chunk.getHeightValue(px & 15, pz & 15) + 1, 16);
+      int py = worldIn.rand.nextInt(k > 0 ? k : chunk.getTopFilledSegment() + 16 - 1);
+      blockPosM.setXyz(px, py, pz);
+      return blockPosM;
    }
 
-   public static boolean isValidEmptySpawnBlock(IBlockState var0) {
-      if (☃.isBlockNormalCube()) {
+   public static boolean isValidEmptySpawnBlock(IBlockState state) {
+      if (state.k()) {
          return false;
-      } else if (☃.canProvidePower()) {
+      } else if (state.m()) {
          return false;
       } else {
-         return ☃.getMaterial().isLiquid() ? false : !BlockRailBase.isRailBlock(☃);
+         return state.a().isLiquid() ? false : !BlockRailBase.isRailBlock(state);
       }
    }
 
-   public static boolean canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType var0, World var1, BlockPos var2) {
-      if (!☃.getWorldBorder().contains(☃)) {
+   public static boolean canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType spawnPlacementTypeIn, World worldIn, BlockPos pos) {
+      if (!worldIn.getWorldBorder().contains(pos)) {
          return false;
       } else {
-         IBlockState ☃ = ☃.getBlockState(☃);
-         if (☃ == EntityLiving.SpawnPlacementType.IN_WATER) {
-            return ☃.getMaterial() == Material.WATER && ☃.getBlockState(☃.down()).getMaterial() == Material.WATER && !☃.getBlockState(☃.up()).isNormalCube();
+         return spawnPlacementTypeIn == null ? false : spawnPlacementTypeIn.canSpawnAt(worldIn, pos);
+      }
+   }
+
+   public static boolean canCreatureTypeSpawnBody(EntityLiving.SpawnPlacementType spawnPlacementTypeIn, World worldIn, BlockPos pos) {
+      IBlockState iblockstate = worldIn.getBlockState(pos);
+      if (spawnPlacementTypeIn == EntityLiving.SpawnPlacementType.IN_WATER) {
+         return iblockstate.a() == Material.WATER && worldIn.getBlockState(pos.down()).a() == Material.WATER && !worldIn.getBlockState(pos.up()).l();
+      } else {
+         BlockPos blockpos = pos.down();
+         IBlockState state = worldIn.getBlockState(blockpos);
+         boolean canSpawn = Reflector.ForgeBlock_canCreatureSpawn.exists()
+            ? Reflector.callBoolean(state.getBlock(), Reflector.ForgeBlock_canCreatureSpawn, new Object[]{state, worldIn, blockpos, spawnPlacementTypeIn})
+            : state.q();
+         if (!canSpawn) {
+            return false;
          } else {
-            BlockPos ☃x = ☃.down();
-            if (!☃.getBlockState(☃x).isTopSolid()) {
-               return false;
-            } else {
-               Block ☃xx = ☃.getBlockState(☃x).getBlock();
-               boolean ☃xxx = ☃xx != Blocks.BEDROCK && ☃xx != Blocks.BARRIER;
-               return ☃xxx && isValidEmptySpawnBlock(☃) && isValidEmptySpawnBlock(☃.getBlockState(☃.up()));
-            }
+            Block block = worldIn.getBlockState(blockpos).getBlock();
+            boolean flag = block != Blocks.BEDROCK && block != Blocks.BARRIER;
+            return flag && isValidEmptySpawnBlock(iblockstate) && isValidEmptySpawnBlock(worldIn.getBlockState(pos.up()));
          }
       }
    }
 
-   public static void performWorldGenSpawning(World var0, Biome var1, int var2, int var3, int var4, int var5, Random var6) {
-      List<Biome.SpawnListEntry> ☃ = ☃.getSpawnableList(EnumCreatureType.CREATURE);
-      if (!☃.isEmpty()) {
-         while (☃.nextFloat() < ☃.getSpawningChance()) {
-            Biome.SpawnListEntry ☃x = WeightedRandom.getRandomItem(☃.rand, ☃);
-            int ☃xx = ☃x.minGroupCount + ☃.nextInt(1 + ☃x.maxGroupCount - ☃x.minGroupCount);
-            IEntityLivingData ☃xxx = null;
-            int ☃xxxx = ☃ + ☃.nextInt(☃);
-            int ☃xxxxx = ☃ + ☃.nextInt(☃);
-            int ☃xxxxxx = ☃xxxx;
-            int ☃xxxxxxx = ☃xxxxx;
-
-            for (int ☃xxxxxxxx = 0; ☃xxxxxxxx < ☃xx; ☃xxxxxxxx++) {
-               boolean ☃xxxxxxxxx = false;
-
-               for (int ☃xxxxxxxxxx = 0; !☃xxxxxxxxx && ☃xxxxxxxxxx < 4; ☃xxxxxxxxxx++) {
-                  BlockPos ☃xxxxxxxxxxx = ☃.getTopSolidOrLiquidBlock(new BlockPos(☃xxxx, 0, ☃xxxxx));
-                  if (canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType.ON_GROUND, ☃, ☃xxxxxxxxxxx)) {
-                     EntityLiving ☃xxxxxxxxxxxx;
+   public static void performWorldGenSpawning(World worldIn, Biome biomeIn, int p_77191_2_, int p_77191_3_, int p_77191_4_, int p_77191_5_, Random randomIn) {
+      List<SpawnListEntry> list = biomeIn.getSpawnableList(EnumCreatureType.CREATURE);
+      if (!list.isEmpty()) {
+         while (randomIn.nextFloat() < biomeIn.getSpawningChance()) {
+            SpawnListEntry biome$spawnlistentry = (SpawnListEntry)WeightedRandom.getRandomItem(worldIn.rand, list);
+            int i = biome$spawnlistentry.minGroupCount + randomIn.nextInt(1 + biome$spawnlistentry.maxGroupCount - biome$spawnlistentry.minGroupCount);
+            IEntityLivingData ientitylivingdata = null;
+            int j = p_77191_2_ + randomIn.nextInt(p_77191_4_);
+            int k = p_77191_3_ + randomIn.nextInt(p_77191_5_);
+            int l = j;
+            int i1 = k;
+
+            for (int j1 = 0; j1 < i; j1++) {
+               boolean flag = false;
+
+               for (int k1 = 0; !flag && k1 < 4; k1++) {
+                  BlockPos blockpos = worldIn.getTopSolidOrLiquidBlock(new BlockPos(j, 0, k));
+                  if (canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType.ON_GROUND, worldIn, blockpos)) {
+                     EntityLiving entityliving;
                      try {
-                        ☃xxxxxxxxxxxx = ☃x.entityClass.getConstructor(World.class).newInstance(☃);
+                        if (Reflector.ForgeBiomeSpawnListEntry_newInstance.exists()) {
+                           entityliving = (EntityLiving)Reflector.call(
+                              biome$spawnlistentry, Reflector.ForgeBiomeSpawnListEntry_newInstance, new Object[]{worldIn}
+                           );
+                        } else {
+                           entityliving = (EntityLiving)biome$spawnlistentry.entityClass.getConstructor(World.class).newInstance(worldIn);
+                        }
                      } catch (Exception var21) {
                         var21.printStackTrace();
                         continue;
                      }
 
-                     ☃xxxxxxxxxxxx.setLocationAndAngles(☃xxxx + 0.5F, ☃xxxxxxxxxxx.getY(), ☃xxxxx + 0.5F, ☃.nextFloat() * 360.0F, 0.0F);
-                     ☃.spawnEntity(☃xxxxxxxxxxxx);
-                     ☃xxx = ☃xxxxxxxxxxxx.onInitialSpawn(☃.getDifficultyForLocation(new BlockPos(☃xxxxxxxxxxxx)), ☃xxx);
-                     ☃xxxxxxxxx = true;
+                     if (Reflector.ForgeEventFactory_canEntitySpawn.exists()) {
+                        Object canSpawn = Reflector.call(
+                           Reflector.ForgeEventFactory_canEntitySpawn, new Object[]{entityliving, worldIn, j + 0.5F, blockpos.getY(), k + 0.5F, false}
+                        );
+                        if (canSpawn == ReflectorForge.EVENT_RESULT_DENY) {
+                           continue;
+                        }
+                     }
+
+                     entityliving.setLocationAndAngles(j + 0.5F, blockpos.getY(), k + 0.5F, randomIn.nextFloat() * 360.0F, 0.0F);
+                     worldIn.spawnEntity(entityliving);
+                     ientitylivingdata = entityliving.onInitialSpawn(worldIn.getDifficultyForLocation(new BlockPos(entityliving)), ientitylivingdata);
+                     flag = true;
                   }
 
-                  ☃xxxx += ☃.nextInt(5) - ☃.nextInt(5);
+                  j += randomIn.nextInt(5) - randomIn.nextInt(5);
 
-                  for (☃xxxxx += ☃.nextInt(5) - ☃.nextInt(5);
-                     ☃xxxx < ☃ || ☃xxxx >= ☃ + ☃ || ☃xxxxx < ☃ || ☃xxxxx >= ☃ + ☃;
-                     ☃xxxxx = ☃xxxxxxx + ☃.nextInt(5) - ☃.nextInt(5)
+                  for (k += randomIn.nextInt(5) - randomIn.nextInt(5);
+                     j < p_77191_2_ || j >= p_77191_2_ + p_77191_4_ || k < p_77191_3_ || k >= p_77191_3_ + p_77191_4_;
+                     k = i1 + randomIn.nextInt(5) - randomIn.nextInt(5)
                   ) {
-                     ☃xxxx = ☃xxxxxx + ☃.nextInt(5) - ☃.nextInt(5);
+                     j = l + randomIn.nextInt(5) - randomIn.nextInt(5);
                   }
                }
             }
diff --git a/patches/net/minecraft/world/chunk/BlockStateContainer.java b/patches/net/minecraft/world/chunk/BlockStateContainer.java
index ac75287..93a81d9 100644
--- a/patches/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/patches/net/minecraft/world/chunk/BlockStateContainer.java
@@ -19,13 +19,13 @@ public BlockStateContainer() {
       this.setBits(4);
    }
 
-   private static int getIndex(int var0, int var1, int var2) {
-      return ☃ << 8 | ☃ << 4 | ☃;
+   private static int getIndex(int x, int y, int z) {
+      return y << 8 | z << 4 | x;
    }
 
-   private void setBits(int var1) {
-      if (☃ != this.bits) {
-         this.bits = ☃;
+   private void setBits(int bitsIn) {
+      if (bitsIn != this.bits) {
+         this.bits = bitsIn;
          if (this.bits <= 4) {
             this.bits = 4;
             this.palette = new BlockStatePaletteLinear(this.bits, this);
@@ -41,88 +41,87 @@ private void setBits(int var1) {
       }
    }
 
-   @Override
-   public int onResize(int var1, IBlockState var2) {
-      BitArray ☃ = this.storage;
-      IBlockStatePalette ☃x = this.palette;
-      this.setBits(☃);
+   public int onResize(int bits, IBlockState state) {
+      BitArray bitarray = this.storage;
+      IBlockStatePalette iblockstatepalette = this.palette;
+      this.setBits(bits);
 
-      for (int ☃xx = 0; ☃xx < ☃.size(); ☃xx++) {
-         IBlockState ☃xxx = ☃x.getBlockState(☃.getAt(☃xx));
-         if (☃xxx != null) {
-            this.set(☃xx, ☃xxx);
+      for (int i = 0; i < bitarray.size(); i++) {
+         IBlockState iblockstate = iblockstatepalette.getBlockState(bitarray.getAt(i));
+         if (iblockstate != null) {
+            this.set(i, iblockstate);
          }
       }
 
-      return this.palette.idFor(☃);
+      return this.palette.idFor(state);
    }
 
-   public void set(int var1, int var2, int var3, IBlockState var4) {
-      this.set(getIndex(☃, ☃, ☃), ☃);
+   public void set(int x, int y, int z, IBlockState state) {
+      this.set(getIndex(x, y, z), state);
    }
 
-   protected void set(int var1, IBlockState var2) {
-      int ☃ = this.palette.idFor(☃);
-      this.storage.setAt(☃, ☃);
+   protected void set(int index, IBlockState state) {
+      int i = this.palette.idFor(state);
+      this.storage.setAt(index, i);
    }
 
-   public IBlockState get(int var1, int var2, int var3) {
-      return this.get(getIndex(☃, ☃, ☃));
+   public IBlockState get(int x, int y, int z) {
+      return this.get(getIndex(x, y, z));
    }
 
-   protected IBlockState get(int var1) {
-      IBlockState ☃ = this.palette.getBlockState(this.storage.getAt(☃));
-      return ☃ == null ? AIR_BLOCK_STATE : ☃;
+   protected IBlockState get(int index) {
+      IBlockState iblockstate = this.palette.getBlockState(this.storage.getAt(index));
+      return iblockstate == null ? AIR_BLOCK_STATE : iblockstate;
    }
 
-   public void read(PacketBuffer var1) {
-      int ☃ = ☃.readByte();
-      if (this.bits != ☃) {
-         this.setBits(☃);
+   public void read(PacketBuffer buf) {
+      int i = buf.readByte();
+      if (this.bits != i) {
+         this.setBits(i);
       }
 
-      this.palette.read(☃);
-      ☃.readLongArray(this.storage.getBackingLongArray());
+      this.palette.read(buf);
+      buf.readLongArray(this.storage.getBackingLongArray());
    }
 
-   public void write(PacketBuffer var1) {
-      ☃.writeByte(this.bits);
-      this.palette.write(☃);
-      ☃.writeLongArray(this.storage.getBackingLongArray());
+   public void write(PacketBuffer buf) {
+      buf.writeByte(this.bits);
+      this.palette.write(buf);
+      buf.writeLongArray(this.storage.getBackingLongArray());
    }
 
    @Nullable
-   public NibbleArray getDataForNBT(byte[] var1, NibbleArray var2) {
-      NibbleArray ☃ = null;
-
-      for (int ☃x = 0; ☃x < 4096; ☃x++) {
-         int ☃xx = Block.BLOCK_STATE_IDS.get(this.get(☃x));
-         int ☃xxx = ☃x & 15;
-         int ☃xxxx = ☃x >> 8 & 15;
-         int ☃xxxxx = ☃x >> 4 & 15;
-         if ((☃xx >> 12 & 15) != 0) {
-            if (☃ == null) {
-               ☃ = new NibbleArray();
+   public NibbleArray getDataForNBT(byte[] blockIds, NibbleArray data) {
+      NibbleArray nibblearray = null;
+
+      for (int i = 0; i < 4096; i++) {
+         int j = Block.BLOCK_STATE_IDS.get(this.get(i));
+         int k = i & 15;
+         int l = i >> 8 & 15;
+         int i1 = i >> 4 & 15;
+         if ((j >> 12 & 15) != 0) {
+            if (nibblearray == null) {
+               nibblearray = new NibbleArray();
             }
 
-            ☃.set(☃xxx, ☃xxxx, ☃xxxxx, ☃xx >> 12 & 15);
+            nibblearray.set(k, l, i1, j >> 12 & 15);
          }
 
-         ☃[☃x] = (byte)(☃xx >> 4 & 0xFF);
-         ☃.set(☃xxx, ☃xxxx, ☃xxxxx, ☃xx & 15);
+         blockIds[i] = (byte)(j >> 4 & 0xFF);
+         data.set(k, l, i1, j & 15);
       }
 
-      return ☃;
+      return nibblearray;
    }
 
-   public void setDataFromNBT(byte[] var1, NibbleArray var2, @Nullable NibbleArray var3) {
-      for (int ☃ = 0; ☃ < 4096; ☃++) {
-         int ☃x = ☃ & 15;
-         int ☃xx = ☃ >> 8 & 15;
-         int ☃xxx = ☃ >> 4 & 15;
-         int ☃xxxx = ☃ == null ? 0 : ☃.get(☃x, ☃xx, ☃xxx);
-         int ☃xxxxx = ☃xxxx << 12 | (☃[☃] & 255) << 4 | ☃.get(☃x, ☃xx, ☃xxx);
-         this.set(☃, Block.BLOCK_STATE_IDS.getByValue(☃xxxxx));
+   public void setDataFromNBT(byte[] blockIds, NibbleArray data, @Nullable NibbleArray blockIdExtension) {
+      for (int i = 0; i < 4096; i++) {
+         int j = i & 15;
+         int k = i >> 8 & 15;
+         int l = i >> 4 & 15;
+         int i1 = blockIdExtension == null ? 0 : blockIdExtension.get(j, k, l);
+         int j1 = i1 << 12 | (blockIds[i] & 255) << 4 | data.get(j, k, l);
+         this.set(i, (IBlockState)Block.BLOCK_STATE_IDS.getByValue(j1));
       }
    }
 
diff --git a/patches/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java b/patches/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
index 4707c8f..b6e6888 100644
--- a/patches/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
+++ b/patches/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
@@ -5,6 +5,7 @@
 import net.minecraft.init.Blocks;
 import net.minecraft.world.chunk.BlockStateContainer;
 import net.minecraft.world.chunk.NibbleArray;
+import net.optifine.reflect.Reflector;
 
 public class ExtendedBlockStorage {
    private final int yBase;
@@ -14,38 +15,42 @@ public class ExtendedBlockStorage {
    private NibbleArray blockLight;
    private NibbleArray skyLight;
 
-   public ExtendedBlockStorage(int var1, boolean var2) {
-      this.yBase = ☃;
+   public ExtendedBlockStorage(int y, boolean storeSkylight) {
+      this.yBase = y;
       this.data = new BlockStateContainer();
       this.blockLight = new NibbleArray();
-      if (☃) {
+      if (storeSkylight) {
          this.skyLight = new NibbleArray();
       }
    }
 
-   public IBlockState get(int var1, int var2, int var3) {
-      return this.data.get(☃, ☃, ☃);
+   public IBlockState get(int x, int y, int z) {
+      return this.data.get(x, y, z);
    }
 
-   public void set(int var1, int var2, int var3, IBlockState var4) {
-      IBlockState ☃ = this.get(☃, ☃, ☃);
-      Block ☃x = ☃.getBlock();
-      Block ☃xx = ☃.getBlock();
-      if (☃x != Blocks.AIR) {
+   public void set(int x, int y, int z, IBlockState state) {
+      if (Reflector.IExtendedBlockState.isInstance(state)) {
+         state = (IBlockState)Reflector.call(state, Reflector.IExtendedBlockState_getClean, new Object[0]);
+      }
+
+      IBlockState iblockstate = this.get(x, y, z);
+      Block block = iblockstate.getBlock();
+      Block block1 = state.getBlock();
+      if (block != Blocks.AIR) {
          this.blockRefCount--;
-         if (☃x.getTickRandomly()) {
+         if (block.getTickRandomly()) {
             this.tickRefCount--;
          }
       }
 
-      if (☃xx != Blocks.AIR) {
+      if (block1 != Blocks.AIR) {
          this.blockRefCount++;
-         if (☃xx.getTickRandomly()) {
+         if (block1.getTickRandomly()) {
             this.tickRefCount++;
          }
       }
 
-      this.data.set(☃, ☃, ☃, ☃);
+      this.data.set(x, y, z, state);
    }
 
    public boolean isEmpty() {
@@ -60,39 +65,44 @@ public int getYLocation() {
       return this.yBase;
    }
 
-   public void setSkyLight(int var1, int var2, int var3, int var4) {
-      this.skyLight.set(☃, ☃, ☃, ☃);
+   public void setSkyLight(int x, int y, int z, int value) {
+      this.skyLight.set(x, y, z, value);
    }
 
-   public int getSkyLight(int var1, int var2, int var3) {
-      return this.skyLight.get(☃, ☃, ☃);
+   public int getSkyLight(int x, int y, int z) {
+      return this.skyLight.get(x, y, z);
    }
 
-   public void setBlockLight(int var1, int var2, int var3, int var4) {
-      this.blockLight.set(☃, ☃, ☃, ☃);
+   public void setBlockLight(int x, int y, int z, int value) {
+      this.blockLight.set(x, y, z, value);
    }
 
-   public int getBlockLight(int var1, int var2, int var3) {
-      return this.blockLight.get(☃, ☃, ☃);
+   public int getBlockLight(int x, int y, int z) {
+      return this.blockLight.get(x, y, z);
    }
 
    public void recalculateRefCounts() {
-      this.blockRefCount = 0;
-      this.tickRefCount = 0;
-
-      for (int ☃ = 0; ☃ < 16; ☃++) {
-         for (int ☃x = 0; ☃x < 16; ☃x++) {
-            for (int ☃xx = 0; ☃xx < 16; ☃xx++) {
-               Block ☃xxx = this.get(☃, ☃x, ☃xx).getBlock();
-               if (☃xxx != Blocks.AIR) {
-                  this.blockRefCount++;
-                  if (☃xxx.getTickRandomly()) {
-                     this.tickRefCount++;
+      IBlockState STATE_AIR = Blocks.AIR.getDefaultState();
+      int localBlockRefCount = 0;
+      int localTickRefCount = 0;
+
+      for (int y = 0; y < 16; y++) {
+         for (int z = 0; z < 16; z++) {
+            for (int x = 0; x < 16; x++) {
+               IBlockState bs = this.data.get(x, y, z);
+               if (bs != STATE_AIR) {
+                  localBlockRefCount++;
+                  Block block = bs.getBlock();
+                  if (block.getTickRandomly()) {
+                     localTickRefCount++;
                   }
                }
             }
          }
       }
+
+      this.blockRefCount = localBlockRefCount;
+      this.tickRefCount = localTickRefCount;
    }
 
    public BlockStateContainer getData() {
@@ -107,11 +117,15 @@ public NibbleArray getSkyLight() {
       return this.skyLight;
    }
 
-   public void setBlockLight(NibbleArray var1) {
-      this.blockLight = ☃;
+   public void setBlockLight(NibbleArray newBlocklightArray) {
+      this.blockLight = newBlocklightArray;
+   }
+
+   public void setSkyLight(NibbleArray newSkylightArray) {
+      this.skyLight = newSkylightArray;
    }
 
-   public void setSkyLight(NibbleArray var1) {
-      this.skyLight = ☃;
+   public int getBlockRefCount() {
+      return this.blockRefCount;
    }
 }
diff --git a/patches/net/minecraft/world/gen/layer/GenLayerZoom.java b/patches/net/minecraft/world/gen/layer/GenLayerZoom.java
index 10b5a4e..003896b 100644
--- a/patches/net/minecraft/world/gen/layer/GenLayerZoom.java
+++ b/patches/net/minecraft/world/gen/layer/GenLayerZoom.java
@@ -1,56 +1,60 @@
 package net.minecraft.world.gen.layer;
 
 public class GenLayerZoom extends GenLayer {
-   public GenLayerZoom(long var1, GenLayer var3) {
-      super(☃);
-      super.parent = ☃;
+   public GenLayerZoom(long p_i2134_1_, GenLayer p_i2134_3_) {
+      super(p_i2134_1_);
+      super.parent = p_i2134_3_;
    }
 
-   @Override
-   public int[] getInts(int var1, int var2, int var3, int var4) {
-      int ☃ = ☃ >> 1;
-      int ☃x = ☃ >> 1;
-      int ☃xx = (☃ >> 1) + 2;
-      int ☃xxx = (☃ >> 1) + 2;
-      int[] ☃xxxx = this.parent.getInts(☃, ☃x, ☃xx, ☃xxx);
-      int ☃xxxxx = ☃xx - 1 << 1;
-      int ☃xxxxxx = ☃xxx - 1 << 1;
-      int[] ☃xxxxxxx = IntCache.getIntCache(☃xxxxx * ☃xxxxxx);
-
-      for (int ☃xxxxxxxx = 0; ☃xxxxxxxx < ☃xxx - 1; ☃xxxxxxxx++) {
-         int ☃xxxxxxxxx = (☃xxxxxxxx << 1) * ☃xxxxx;
-         int ☃xxxxxxxxxx = 0;
-         int ☃xxxxxxxxxxx = ☃xxxx[☃xxxxxxxxxx + 0 + (☃xxxxxxxx + 0) * ☃xx];
-
-         for (int ☃xxxxxxxxxxxx = ☃xxxx[☃xxxxxxxxxx + 0 + (☃xxxxxxxx + 1) * ☃xx]; ☃xxxxxxxxxx < ☃xx - 1; ☃xxxxxxxxxx++) {
-            this.initChunkSeed(☃xxxxxxxxxx + ☃ << 1, ☃xxxxxxxx + ☃x << 1);
-            int ☃xxxxxxxxxxxxx = ☃xxxx[☃xxxxxxxxxx + 1 + (☃xxxxxxxx + 0) * ☃xx];
-            int ☃xxxxxxxxxxxxxx = ☃xxxx[☃xxxxxxxxxx + 1 + (☃xxxxxxxx + 1) * ☃xx];
-            ☃xxxxxxx[☃xxxxxxxxx] = ☃xxxxxxxxxxx;
-            ☃xxxxxxx[☃xxxxxxxxx++ + ☃xxxxx] = this.selectRandom(new int[]{☃xxxxxxxxxxx, ☃xxxxxxxxxxxx});
-            ☃xxxxxxx[☃xxxxxxxxx] = this.selectRandom(new int[]{☃xxxxxxxxxxx, ☃xxxxxxxxxxxxx});
-            ☃xxxxxxx[☃xxxxxxxxx++ + ☃xxxxx] = this.selectModeOrRandom(☃xxxxxxxxxxx, ☃xxxxxxxxxxxxx, ☃xxxxxxxxxxxx, ☃xxxxxxxxxxxxxx);
-            ☃xxxxxxxxxxx = ☃xxxxxxxxxxxxx;
-            ☃xxxxxxxxxxxx = ☃xxxxxxxxxxxxxx;
+   public int[] getInts(int areaX, int areaY, int areaWidth, int areaHeight) {
+      int i = areaX >> 1;
+      int j = areaY >> 1;
+      int k = (areaWidth >> 1) + 2;
+      int l = (areaHeight >> 1) + 2;
+      int[] aint = this.parent.getInts(i, j, k, l);
+      int i1 = k - 1 << 1;
+      int j1 = l - 1 << 1;
+      int[] aint1 = IntCache.getIntCache(i1 * j1);
+
+      for (int k1 = 0; k1 < l - 1; k1++) {
+         int l1 = (k1 << 1) * i1;
+         int i2 = 0;
+         int j2 = aint[i2 + 0 + (k1 + 0) * k];
+
+         for (int k2 = aint[i2 + 0 + (k1 + 1) * k]; i2 < k - 1; i2++) {
+            this.initChunkSeed(i2 + i << 1, k1 + j << 1);
+            int l2 = aint[i2 + 1 + (k1 + 0) * k];
+            int i3 = aint[i2 + 1 + (k1 + 1) * k];
+            aint1[l1] = j2;
+            aint1[l1++ + i1] = this.selectRandom2(j2, k2);
+            aint1[l1] = this.selectRandom2(j2, l2);
+            aint1[l1++ + i1] = this.selectModeOrRandom(j2, l2, k2, i3);
+            j2 = l2;
+            k2 = i3;
          }
       }
 
-      int[] ☃xxxxxxxx = IntCache.getIntCache(☃ * ☃);
+      int[] aint2 = IntCache.getIntCache(areaWidth * areaHeight);
 
-      for (int ☃xxxxxxxxx = 0; ☃xxxxxxxxx < ☃; ☃xxxxxxxxx++) {
-         System.arraycopy(☃xxxxxxx, (☃xxxxxxxxx + (☃ & 1)) * ☃xxxxx + (☃ & 1), ☃xxxxxxxx, ☃xxxxxxxxx * ☃, ☃);
+      for (int j3 = 0; j3 < areaHeight; j3++) {
+         System.arraycopy(aint1, (j3 + (areaY & 1)) * i1 + (areaX & 1), aint2, j3 * areaWidth, areaWidth);
       }
 
-      return ☃xxxxxxxx;
+      return aint2;
    }
 
-   public static GenLayer magnify(long var0, GenLayer var2, int var3) {
-      GenLayer ☃ = ☃;
+   public static GenLayer magnify(long p_75915_0_, GenLayer p_75915_2_, int p_75915_3_) {
+      GenLayer genlayer = p_75915_2_;
 
-      for (int ☃x = 0; ☃x < ☃; ☃x++) {
-         ☃ = new GenLayerZoom(☃ + ☃x, ☃);
+      for (int i = 0; i < p_75915_3_; i++) {
+         genlayer = new GenLayerZoom(p_75915_0_ + i, genlayer);
       }
 
-      return ☃;
+      return genlayer;
+   }
+
+   protected int selectRandom2(int i0, int i1) {
+      int index = this.nextInt(2);
+      return index == 0 ? i0 : i1;
    }
 }
