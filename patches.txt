--- net/minecraft/advancements/critereon/AbstractCriterionInstance.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/AbstractCriterionInstance.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/BredAnimalsTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/BredAnimalsTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/BrewedPotionTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/BrewedPotionTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ChangeDimensionTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ChangeDimensionTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ConstructBeaconTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ConstructBeaconTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ConsumeItemTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ConsumeItemTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/CuredZombieVillagerTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/CuredZombieVillagerTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/DamagePredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/DamagePredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/DamageSourcePredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/DamageSourcePredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/DistancePredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/DistancePredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EffectsChangedTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EffectsChangedTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EnchantedItemTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EnchantedItemTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EnchantmentPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EnchantmentPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EnterBlockTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EnterBlockTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EntityHurtPlayerTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EntityHurtPlayerTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/EntityPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/EntityPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ImpossibleTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ImpossibleTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/InventoryChangeTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/InventoryChangeTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ItemDurabilityTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ItemDurabilityTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/ItemPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/ItemPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/KilledTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/KilledTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/LevitationTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/LevitationTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/LocationPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/LocationPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/MinMaxBounds.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/MinMaxBounds.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/MobEffectsPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/MobEffectsPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/NBTPredicate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/NBTPredicate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/NetherTravelTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/NetherTravelTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/PlacedBlockTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/PlacedBlockTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/PlayerHurtEntityTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/PlayerHurtEntityTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/PositionTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/PositionTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/RecipeUnlockedTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/RecipeUnlockedTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/SummonedEntityTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/SummonedEntityTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/TameAnimalTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/TameAnimalTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/TickTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/TickTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/UsedEnderEyeTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/UsedEnderEyeTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/UsedTotemTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/UsedTotemTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/critereon/VillagerTradeTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/critereon/VillagerTradeTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/Advancement.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/Advancement.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/AdvancementList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/AdvancementList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/AdvancementManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/AdvancementManager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/AdvancementProgress.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/AdvancementProgress.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/AdvancementRewards.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/AdvancementRewards.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/AdvancementTreeNode.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/AdvancementTreeNode.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/CriteriaTriggers.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/CriteriaTriggers.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/Criterion.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/Criterion.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/CriterionProgress.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/CriterionProgress.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/DisplayInfo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/DisplayInfo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/FrameType.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/FrameType.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/FunctionManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/FunctionManager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/ICriterionInstance.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/ICriterionInstance.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/ICriterionTrigger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/ICriterionTrigger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/advancements/PlayerAdvancements.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/advancements/PlayerAdvancements.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/EnumPushReaction.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/EnumPushReaction.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/MapColor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/MapColor.java	Mon Aug 18 09:39:52 2025
@@ -54,13 +54,13 @@
    public static final MapColor PURPLE_STAINED_HARDENED_CLAY = new MapColor(46, 8014168);
    public static final MapColor BLUE_STAINED_HARDENED_CLAY = new MapColor(47, 4996700);
    public static final MapColor BROWN_STAINED_HARDENED_CLAY = new MapColor(48, 4993571);
    public static final MapColor GREEN_STAINED_HARDENED_CLAY = new MapColor(49, 5001770);
    public static final MapColor RED_STAINED_HARDENED_CLAY = new MapColor(50, 9321518);
    public static final MapColor BLACK_STAINED_HARDENED_CLAY = new MapColor(51, 2430480);
-   public final int colorValue;
+   public int colorValue;
    public final int colorIndex;
 
    private MapColor(int var1, int var2) {
       if (var1 >= 0 && var1 <= 63) {
          this.colorIndex = var1;
          this.colorValue = var2;
--- net/minecraft/block/material/Material.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/Material.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/MaterialLiquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/MaterialLiquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/MaterialLogic.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/MaterialLogic.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/MaterialPortal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/MaterialPortal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/material/MaterialTransparent.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/material/MaterialTransparent.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/IProperty.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/IProperty.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/PropertyBool.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/PropertyBool.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/PropertyDirection.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/PropertyDirection.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/PropertyEnum.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/PropertyEnum.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/PropertyHelper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/PropertyHelper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/properties/PropertyInteger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/properties/PropertyInteger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/pattern/BlockMatcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/pattern/BlockMatcher.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/pattern/BlockMaterialMatcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/pattern/BlockMaterialMatcher.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/pattern/BlockPattern.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/pattern/BlockPattern.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/pattern/BlockStateMatcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/pattern/BlockStateMatcher.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/pattern/FactoryBlockPattern.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/pattern/FactoryBlockPattern.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/BlockFaceShape.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/BlockFaceShape.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/BlockPistonStructureHelper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/BlockPistonStructureHelper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/BlockStateBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/BlockStateBase.java	Mon Aug 18 09:39:52 2025
@@ -1,17 +1,19 @@
 package net.minecraft.block.state;
 
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableTable;
 import com.google.common.collect.Iterables;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.block.properties.IProperty;
+import net.minecraft.util.ResourceLocation;
 
 public abstract class BlockStateBase implements IBlockState {
    private static final Joiner COMMA_JOINER = Joiner.on(',');
    private static final Function<Entry<IProperty<?>, Comparable<?>>, String> MAP_ENTRY_TO_STRING = new Function<Entry<IProperty<?>, Comparable<?>>, String>() {
       @Nullable
       public String apply(@Nullable Entry<IProperty<?>, Comparable<?>> var1) {
@@ -21,17 +23,56 @@
             IProperty var2 = (IProperty)var1.getKey();
             return var2.getName() + "=" + this.getPropertyName(var2, (Comparable<?>)var1.getValue());
          }
       }
 
       private <T extends Comparable<T>> String getPropertyName(IProperty<T> var1, Comparable<?> var2) {
-         return var1.getName((T)var2);
+         return var1.getName(var2);
       }
    };
+   private int blockId = -1;
+   private int blockStateId = -1;
+   private int metadata = -1;
+   private ResourceLocation blockLocation = null;
+
+   public int getBlockId() {
+      if (this.blockId < 0) {
+         this.blockId = Block.getIdFromBlock(this.getBlock());
+      }
+
+      return this.blockId;
+   }
+
+   public int getBlockStateId() {
+      if (this.blockStateId < 0) {
+         this.blockStateId = Block.getStateId(this);
+      }
+
+      return this.blockStateId;
+   }
+
+   public int getMetadata() {
+      if (this.metadata < 0) {
+         this.metadata = this.getBlock().getMetaFromState(this);
+      }
+
+      return this.metadata;
+   }
+
+   public ResourceLocation getBlockLocation() {
+      if (this.blockLocation == null) {
+         this.blockLocation = (ResourceLocation)Block.REGISTRY.getNameForObject(this.getBlock());
+      }
+
+      return this.blockLocation;
+   }
+
+   public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
+      return null;
+   }
 
-   @Override
    public <T extends Comparable<T>> IBlockState cycleProperty(IProperty<T> var1) {
       return this.withProperty(var1, cyclePropertyValue(var1.getAllowedValues(), this.getValue(var1)));
    }
 
    protected static <T> T cyclePropertyValue(Collection<T> var0, T var1) {
       Iterator var2 = var0.iterator();
--- net/minecraft/block/state/BlockStateContainer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/BlockStateContainer.java	Mon Aug 18 09:39:52 2025
@@ -16,16 +16,19 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Map.Entry;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockFlower;
+import net.minecraft.block.Block.EnumOffsetType;
 import net.minecraft.block.material.EnumPushReaction;
 import net.minecraft.block.material.MapColor;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.properties.IProperty;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayer;
@@ -38,12 +41,15 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.Cartesian;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
+import net.minecraftforge.common.property.IUnlistedProperty;
+import net.optifine.model.BlockModelUtils;
+import net.optifine.reflect.Reflector;
 
 public class BlockStateContainer {
    private static final Pattern NAME_PATTERN = Pattern.compile("^[a-z0-9_]+$");
    private static final Function<IProperty<?>, String> GET_NAME_FUNC = new Function<IProperty<?>, String>() {
       @Nullable
       public String apply(@Nullable IProperty<?> var1) {
@@ -52,27 +58,37 @@
    };
    private final Block block;
    private final ImmutableSortedMap<String, IProperty<?>> properties;
    private final ImmutableList<IBlockState> validStates;
 
    public BlockStateContainer(Block var1, IProperty<?>... var2) {
+      this(var1, var2, null);
+   }
+
+   protected BlockStateContainer.StateImplementation createState(
+      Block var1, ImmutableMap<IProperty<?>, Comparable<?>> var2, @Nullable ImmutableMap<IUnlistedProperty<?>, Optional<?>> var3
+   ) {
+      return new BlockStateContainer.StateImplementation(var1, var2);
+   }
+
+   protected BlockStateContainer(Block var1, IProperty<?>[] var2, ImmutableMap<IUnlistedProperty<?>, Optional<?>> var3) {
       this.block = var1;
-      HashMap var3 = Maps.newHashMap();
+      HashMap var4 = Maps.newHashMap();
 
-      for (IProperty var7 : var2) {
-         validateProperty(var1, var7);
-         var3.put(var7.getName(), var7);
+      for (IProperty var8 : var2) {
+         validateProperty(var1, var8);
+         var4.put(var8.getName(), var8);
       }
 
-      this.properties = ImmutableSortedMap.copyOf(var3);
+      this.properties = ImmutableSortedMap.copyOf(var4);
       LinkedHashMap var11 = Maps.newLinkedHashMap();
       ArrayList var12 = Lists.newArrayList();
 
-      for (List var8 : Cartesian.cartesianProduct(this.getAllowedValues())) {
-         Map var9 = MapPopulator.createMap(this.properties.values(), var8);
-         BlockStateContainer.StateImplementation var10 = new BlockStateContainer.StateImplementation(var1, ImmutableMap.copyOf(var9));
+      for (List var15 : Cartesian.cartesianProduct(this.getAllowedValues())) {
+         Map var9 = MapPopulator.createMap(this.properties.values(), var15);
+         BlockStateContainer.StateImplementation var10 = this.createState(var1, ImmutableMap.copyOf(var9), var3);
          var11.put(var9, var10);
          var12.add(var10);
       }
 
       for (BlockStateContainer.StateImplementation var16 : var12) {
          var16.buildPropertyValueTable(var11);
@@ -84,13 +100,13 @@
    public static <T extends Comparable<T>> String validateProperty(Block var0, IProperty<T> var1) {
       String var2 = var1.getName();
       if (!NAME_PATTERN.matcher(var2).matches()) {
          throw new IllegalArgumentException("Block: " + var0.getClass() + " has invalidly named property: " + var2);
       } else {
          for (Comparable var4 : var1.getAllowedValues()) {
-            String var5 = var1.getName((T)var4);
+            String var5 = var1.getName(var4);
             if (!NAME_PATTERN.matcher(var5).matches()) {
                throw new IllegalArgumentException("Block: " + var0.getClass() + " has property: " + var2 + " with invalidly named value: " + var5);
             }
          }
 
          return var2;
@@ -136,38 +152,79 @@
 
    @Nullable
    public IProperty<?> getProperty(String var1) {
       return (IProperty<?>)this.properties.get(var1);
    }
 
+   public static class Builder {
+      private final Block block;
+      private final List<IProperty<?>> listed = Lists.newArrayList();
+      private final List<IUnlistedProperty<?>> unlisted = Lists.newArrayList();
+
+      public Builder(Block var1) {
+         this.block = var1;
+      }
+
+      public BlockStateContainer.Builder add(IProperty<?>... var1) {
+         for (IProperty var5 : var1) {
+            this.listed.add(var5);
+         }
+
+         return this;
+      }
+
+      public BlockStateContainer.Builder add(IUnlistedProperty<?>... var1) {
+         for (IUnlistedProperty var5 : var1) {
+            this.unlisted.add(var5);
+         }
+
+         return this;
+      }
+
+      public BlockStateContainer build() {
+         IProperty[] var1 = new IProperty[this.listed.size()];
+         var1 = this.listed.toArray(var1);
+         if (this.unlisted.size() == 0) {
+            return new BlockStateContainer(this.block, var1);
+         } else {
+            IUnlistedProperty[] var2 = new IUnlistedProperty[this.unlisted.size()];
+            var2 = this.unlisted.toArray(var2);
+            return (BlockStateContainer)Reflector.newInstance(Reflector.ExtendedBlockState_Constructor, new Object[]{this.block, var1, var2});
+         }
+      }
+   }
+
    static class StateImplementation extends BlockStateBase {
       private final Block block;
       private final ImmutableMap<IProperty<?>, Comparable<?>> properties;
       private ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> propertyValueTable;
 
       private StateImplementation(Block var1, ImmutableMap<IProperty<?>, Comparable<?>> var2) {
          this.block = var1;
          this.properties = var2;
       }
 
-      @Override
+      protected StateImplementation(Block var1, ImmutableMap<IProperty<?>, Comparable<?>> var2, ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> var3) {
+         this.block = var1;
+         this.properties = var2;
+         this.propertyValueTable = var3;
+      }
+
       public Collection<IProperty<?>> getPropertyKeys() {
          return Collections.unmodifiableCollection(this.properties.keySet());
       }
 
-      @Override
       public <T extends Comparable<T>> T getValue(IProperty<T> var1) {
          Comparable var2 = (Comparable)this.properties.get(var1);
          if (var2 == null) {
             throw new IllegalArgumentException("Cannot get property " + var1 + " as it does not exist in " + this.block.getBlockState());
          } else {
             return (T)var1.getValueClass().cast(var2);
          }
       }
 
-      @Override
       public <T extends Comparable<T>, V extends T> IBlockState withProperty(IProperty<T> var1, V var2) {
          Comparable var3 = (Comparable)this.properties.get(var1);
          if (var3 == null) {
             throw new IllegalArgumentException("Cannot set property " + var1 + " as it does not exist in " + this.block.getBlockState());
          } else if (var3 == var2) {
             return this;
@@ -180,18 +237,16 @@
             } else {
                return var4;
             }
          }
       }
 
-      @Override
       public ImmutableMap<IProperty<?>, Comparable<?>> getProperties() {
          return this.properties;
       }
 
-      @Override
       public Block getBlock() {
          return this.block;
       }
 
       @Override
       public boolean equals(Object var1) {
@@ -228,203 +283,195 @@
       private Map<IProperty<?>, Comparable<?>> getPropertiesWithValue(IProperty<?> var1, Comparable<?> var2) {
          HashMap var3 = Maps.newHashMap(this.properties);
          var3.put(var1, var2);
          return var3;
       }
 
-      @Override
       public Material getMaterial() {
          return this.block.getMaterial(this);
       }
 
-      @Override
       public boolean isFullBlock() {
          return this.block.isFullBlock(this);
       }
 
-      @Override
       public boolean canEntitySpawn(Entity var1) {
          return this.block.canEntitySpawn(this, var1);
       }
 
-      @Override
       public int getLightOpacity() {
          return this.block.getLightOpacity(this);
       }
 
-      @Override
       public int getLightValue() {
          return this.block.getLightValue(this);
       }
 
-      @Override
       public boolean isTranslucent() {
          return this.block.isTranslucent(this);
       }
 
-      @Override
       public boolean useNeighborBrightness() {
          return this.block.getUseNeighborBrightness(this);
       }
 
-      @Override
       public MapColor getMapColor(IBlockAccess var1, BlockPos var2) {
          return this.block.getMapColor(this, var1, var2);
       }
 
-      @Override
       public IBlockState withRotation(Rotation var1) {
          return this.block.withRotation(this, var1);
       }
 
-      @Override
       public IBlockState withMirror(Mirror var1) {
          return this.block.withMirror(this, var1);
       }
 
-      @Override
       public boolean isFullCube() {
          return this.block.isFullCube(this);
       }
 
-      @Override
       public boolean hasCustomBreakingProgress() {
          return this.block.hasCustomBreakingProgress(this);
       }
 
-      @Override
       public EnumBlockRenderType getRenderType() {
          return this.block.getRenderType(this);
       }
 
-      @Override
       public int getPackedLightmapCoords(IBlockAccess var1, BlockPos var2) {
          return this.block.getPackedLightmapCoords(this, var1, var2);
       }
 
-      @Override
       public float getAmbientOcclusionLightValue() {
          return this.block.getAmbientOcclusionLightValue(this);
       }
 
-      @Override
       public boolean isBlockNormalCube() {
          return this.block.isBlockNormalCube(this);
       }
 
-      @Override
       public boolean isNormalCube() {
          return this.block.isNormalCube(this);
       }
 
-      @Override
       public boolean canProvidePower() {
          return this.block.canProvidePower(this);
       }
 
-      @Override
       public int getWeakPower(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
          return this.block.getWeakPower(this, var1, var2, var3);
       }
 
-      @Override
       public boolean hasComparatorInputOverride() {
          return this.block.hasComparatorInputOverride(this);
       }
 
-      @Override
       public int getComparatorInputOverride(World var1, BlockPos var2) {
          return this.block.getComparatorInputOverride(this, var1, var2);
       }
 
-      @Override
       public float getBlockHardness(World var1, BlockPos var2) {
          return this.block.getBlockHardness(this, var1, var2);
       }
 
-      @Override
       public float getPlayerRelativeBlockHardness(EntityPlayer var1, World var2, BlockPos var3) {
          return this.block.getPlayerRelativeBlockHardness(this, var1, var2, var3);
       }
 
-      @Override
       public int getStrongPower(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
          return this.block.getStrongPower(this, var1, var2, var3);
       }
 
-      @Override
       public EnumPushReaction getPushReaction() {
          return this.block.getPushReaction(this);
       }
 
-      @Override
       public IBlockState getActualState(IBlockAccess var1, BlockPos var2) {
          return this.block.getActualState(this, var1, var2);
       }
 
-      @Override
       public AxisAlignedBB getSelectedBoundingBox(World var1, BlockPos var2) {
          return this.block.getSelectedBoundingBox(this, var1, var2);
       }
 
-      @Override
       public boolean shouldSideBeRendered(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
          return this.block.shouldSideBeRendered(this, var1, var2, var3);
       }
 
-      @Override
       public boolean isOpaqueCube() {
          return this.block.isOpaqueCube(this);
       }
 
       @Nullable
-      @Override
       public AxisAlignedBB getCollisionBoundingBox(IBlockAccess var1, BlockPos var2) {
          return this.block.getCollisionBoundingBox(this, var1, var2);
       }
 
-      @Override
       public void addCollisionBoxToList(World var1, BlockPos var2, AxisAlignedBB var3, List<AxisAlignedBB> var4, @Nullable Entity var5, boolean var6) {
          this.block.addCollisionBoxToList(this, var1, var2, var3, var4, var5, var6);
       }
 
-      @Override
       public AxisAlignedBB getBoundingBox(IBlockAccess var1, BlockPos var2) {
-         return this.block.getBoundingBox(this, var1, var2);
+         EnumOffsetType var3 = this.block.getOffsetType();
+         if (var3 != EnumOffsetType.NONE && !(this.block instanceof BlockFlower)) {
+            AxisAlignedBB var4 = this.block.getBoundingBox(this, var1, var2);
+            return BlockModelUtils.getOffsetBoundingBox(var4, var3, var2);
+         } else {
+            return this.block.getBoundingBox(this, var1, var2);
+         }
       }
 
-      @Override
       public RayTraceResult collisionRayTrace(World var1, BlockPos var2, Vec3d var3, Vec3d var4) {
          return this.block.collisionRayTrace(this, var1, var2, var3, var4);
       }
 
-      @Override
       public boolean isTopSolid() {
          return this.block.isTopSolid(this);
       }
 
-      @Override
       public Vec3d getOffset(IBlockAccess var1, BlockPos var2) {
          return this.block.getOffset(this, var1, var2);
       }
 
-      @Override
       public boolean onBlockEventReceived(World var1, BlockPos var2, int var3, int var4) {
          return this.block.eventReceived(this, var1, var2, var3, var4);
       }
 
-      @Override
       public void neighborChanged(World var1, BlockPos var2, Block var3, BlockPos var4) {
          this.block.neighborChanged(this, var1, var2, var3, var4);
       }
 
-      @Override
       public boolean causesSuffocation() {
          return this.block.causesSuffocation(this);
       }
 
       @Override
+      public ImmutableTable<IProperty<?>, Comparable<?>, IBlockState> getPropertyValueTable() {
+         return this.propertyValueTable;
+      }
+
+      public int getLightOpacity(IBlockAccess var1, BlockPos var2) {
+         return Reflector.callInt(this.block, Reflector.ForgeBlock_getLightOpacity, new Object[]{this, var1, var2});
+      }
+
+      public int getLightValue(IBlockAccess var1, BlockPos var2) {
+         return Reflector.callInt(this.block, Reflector.ForgeBlock_getLightValue, new Object[]{this, var1, var2});
+      }
+
+      public boolean isSideSolid(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_isSideSolid, new Object[]{this, var1, var2, var3});
+      }
+
+      public boolean doesSideBlockChestOpening(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_doesSideBlockChestOpening, new Object[]{this, var1, var2, var3});
+      }
+
+      public boolean doesSideBlockRendering(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
+         return Reflector.callBoolean(this.block, Reflector.ForgeBlock_doesSideBlockRendering, new Object[]{this, var1, var2, var3});
+      }
+
       public BlockFaceShape getBlockFaceShape(IBlockAccess var1, BlockPos var2, EnumFacing var3) {
          return this.block.getBlockFaceShape(var1, this, var2, var3);
       }
    }
 }
--- net/minecraft/block/state/BlockWorldState.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/BlockWorldState.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/IBlockBehaviors.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/IBlockBehaviors.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/IBlockProperties.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/IBlockProperties.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/state/IBlockState.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/state/IBlockState.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/Block.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/Block.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockAir.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockAir.java	Mon Aug 18 09:39:52 2025
@@ -1,58 +1,69 @@
 package net.minecraft.block;
 
+import java.util.IdentityHashMap;
+import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.BlockFaceShape;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.util.EnumBlockRenderType;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 
 public class BlockAir extends Block {
+   private static Map mapOriginalOpacity = new IdentityHashMap();
+
    protected BlockAir() {
       super(Material.AIR);
    }
 
-   @Override
    public EnumBlockRenderType getRenderType(IBlockState var1) {
       return EnumBlockRenderType.INVISIBLE;
    }
 
    @Nullable
-   @Override
    public AxisAlignedBB getCollisionBoundingBox(IBlockState var1, IBlockAccess var2, BlockPos var3) {
       return NULL_AABB;
    }
 
-   @Override
    public boolean isOpaqueCube(IBlockState var1) {
       return false;
    }
 
-   @Override
    public boolean canCollideCheck(IBlockState var1, boolean var2) {
       return false;
    }
 
-   @Override
    public void dropBlockAsItemWithChance(World var1, BlockPos var2, IBlockState var3, float var4, int var5) {
    }
 
-   @Override
    public boolean isReplaceable(IBlockAccess var1, BlockPos var2) {
       return true;
    }
 
-   @Override
    public boolean isFullCube(IBlockState var1) {
       return false;
    }
 
-   @Override
+   public static void setLightOpacity(Block var0, int var1) {
+      if (!mapOriginalOpacity.containsKey(var0)) {
+         mapOriginalOpacity.put(var0, var0.lightOpacity);
+      }
+
+      var0.lightOpacity = var1;
+   }
+
+   public static void restoreLightOpacity(Block var0) {
+      if (mapOriginalOpacity.containsKey(var0)) {
+         int var1 = (Integer)mapOriginalOpacity.get(var0);
+         setLightOpacity(var0, var1);
+      }
+   }
+
    public BlockFaceShape getBlockFaceShape(IBlockAccess var1, IBlockState var2, BlockPos var3, EnumFacing var4) {
       return BlockFaceShape.UNDEFINED;
    }
 }
--- net/minecraft/block/BlockAnvil.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockAnvil.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBanner.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBanner.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBarrier.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBarrier.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBasePressurePlate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBasePressurePlate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBeacon.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBeacon.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBed.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBed.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBeetroot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBeetroot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBookshelf.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBookshelf.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBreakable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBreakable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBrewingStand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBrewingStand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockBush.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockBush.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockButton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockButton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockButtonStone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockButtonStone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockButtonWood.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockButtonWood.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCactus.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCactus.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCake.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCake.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCarpet.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCarpet.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCarrot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCarrot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCauldron.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCauldron.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockChest.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockChest.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockChorusFlower.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockChorusFlower.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockChorusPlant.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockChorusPlant.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockClay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockClay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCocoa.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCocoa.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockColored.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockColored.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCommandBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCommandBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCompressedPowered.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCompressedPowered.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockConcretePowder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockConcretePowder.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockContainer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockContainer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockCrops.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockCrops.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDaylightDetector.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDaylightDetector.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDeadBush.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDeadBush.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDirectional.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDirectional.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDirt.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDirt.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDispenser.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDispenser.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDoor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDoor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDoublePlant.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDoublePlant.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDoubleStoneSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDoubleStoneSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDoubleStoneSlabNew.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDoubleStoneSlabNew.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDoubleWoodSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDoubleWoodSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDragonEgg.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDragonEgg.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDropper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDropper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockDynamicLiquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockDynamicLiquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEmptyDrops.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEmptyDrops.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEnchantmentTable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEnchantmentTable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEnderChest.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEnderChest.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEndGateway.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEndGateway.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEndPortal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEndPortal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEndPortalFrame.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEndPortalFrame.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEndRod.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEndRod.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockEventData.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockEventData.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFalling.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFalling.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFarmland.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFarmland.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFence.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFence.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFenceGate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFenceGate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFire.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFire.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFlower.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFlower.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFlowerPot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFlowerPot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFrostedIce.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFrostedIce.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockFurnace.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockFurnace.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGlass.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGlass.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGlazedTerracotta.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGlazedTerracotta.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGlowstone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGlowstone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGrass.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGrass.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGrassPath.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGrassPath.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockGravel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockGravel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHalfStoneSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHalfStoneSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHalfStoneSlabNew.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHalfStoneSlabNew.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHalfWoodSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHalfWoodSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHardenedClay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHardenedClay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHopper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHopper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHorizontal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHorizontal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockHugeMushroom.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockHugeMushroom.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockIce.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockIce.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockJukebox.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockJukebox.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLadder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLadder.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLeaves.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLeaves.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLever.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLever.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLilyPad.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLilyPad.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLiquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLiquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockLog.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockLog.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockMagma.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockMagma.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockMelon.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockMelon.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockMobSpawner.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockMobSpawner.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockMushroom.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockMushroom.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockMycelium.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockMycelium.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNetherBrick.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNetherBrick.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNetherrack.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNetherrack.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNetherWart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNetherWart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNewLeaf.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNewLeaf.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNewLog.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNewLog.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockNote.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockNote.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockObserver.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockObserver.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockObsidian.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockObsidian.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockOldLeaf.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockOldLeaf.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockOldLog.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockOldLog.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockOre.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockOre.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPackedIce.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPackedIce.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPane.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPane.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPistonBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPistonBase.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPistonExtension.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPistonExtension.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPistonMoving.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPistonMoving.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPlanks.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPlanks.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPortal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPortal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPotato.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPotato.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPressurePlate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPressurePlate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPressurePlateWeighted.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPressurePlateWeighted.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPrismarine.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPrismarine.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPumpkin.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPumpkin.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockPurpurSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockPurpurSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockQuartz.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockQuartz.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRail.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRail.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRailBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRailBase.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRailDetector.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRailDetector.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRailPowered.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRailPowered.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedFlower.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedFlower.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedSandstone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedSandstone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneComparator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneComparator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneDiode.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneDiode.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneLight.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneLight.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneOre.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneOre.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneRepeater.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneRepeater.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneTorch.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneTorch.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRedstoneWire.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRedstoneWire.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockReed.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockReed.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockRotatedPillar.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockRotatedPillar.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSandStone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSandStone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSapling.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSapling.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSeaLantern.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSeaLantern.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockShulkerBox.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockShulkerBox.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSign.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSign.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSilverfish.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSilverfish.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSkull.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSkull.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSlime.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSlime.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSnow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSnow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSnowBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSnowBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSoulSand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSoulSand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSourceImpl.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSourceImpl.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockSponge.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockSponge.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStainedGlass.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStainedGlass.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStainedGlassPane.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStainedGlassPane.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStainedHardenedClay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStainedHardenedClay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStairs.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStairs.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStandingSign.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStandingSign.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStaticLiquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStaticLiquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStoneBrick.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStoneBrick.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStoneSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStoneSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStoneSlabNew.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStoneSlabNew.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStructure.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStructure.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockStructureVoid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockStructureVoid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTallGrass.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTallGrass.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTNT.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTNT.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTorch.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTorch.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTrapDoor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTrapDoor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTripWire.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTripWire.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockTripWireHook.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockTripWireHook.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockVine.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockVine.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockWall.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockWall.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockWallSign.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockWallSign.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockWeb.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockWeb.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockWoodSlab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockWoodSlab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockWorkbench.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockWorkbench.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/BlockYellowFlower.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/BlockYellowFlower.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/IGrowable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/IGrowable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/ITileEntityProvider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/ITileEntityProvider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/block/SoundType.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/block/SoundType.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/ElytraSound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/ElytraSound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/GuardianSound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/GuardianSound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/ISound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/ISound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/ISoundEventAccessor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/ISoundEventAccessor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/ISoundEventListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/ISoundEventListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/ITickableSound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/ITickableSound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/MovingSound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/MovingSound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/MovingSoundMinecart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/MovingSoundMinecart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/MovingSoundMinecartRiding.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/MovingSoundMinecartRiding.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/MusicTicker.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/MusicTicker.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/PositionedSound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/PositionedSound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/PositionedSoundRecord.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/PositionedSoundRecord.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/Sound.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/Sound.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundEventAccessor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundEventAccessor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundHandler.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundHandler.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundListSerializer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundListSerializer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundManager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/audio/SoundRegistry.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/audio/SoundRegistry.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/entity/AbstractClientPlayer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/entity/AbstractClientPlayer.java	Mon Aug 18 09:39:52 2025
@@ -1,43 +1,60 @@
 package net.minecraft.client.entity;
 
 import com.mojang.authlib.GameProfile;
+import java.io.File;
 import javax.annotation.Nullable;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.network.NetworkPlayerInfo;
 import net.minecraft.client.renderer.ImageBufferDownload;
 import net.minecraft.client.renderer.ThreadDownloadImageData;
 import net.minecraft.client.renderer.texture.ITextureObject;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.resources.DefaultPlayerSkin;
 import net.minecraft.entity.SharedMonsterAttributes;
 import net.minecraft.entity.ai.attributes.IAttributeInstance;
+import net.minecraft.entity.passive.EntityShoulderRiding;
 import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.init.Items;
+import net.minecraft.item.ItemBow;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.StringUtils;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
+import net.optifine.player.CapeUtils;
+import net.optifine.player.PlayerConfigurations;
+import net.optifine.reflect.Reflector;
 
 public abstract class AbstractClientPlayer extends EntityPlayer {
    private NetworkPlayerInfo playerInfo;
    public float rotateElytraX;
    public float rotateElytraY;
    public float rotateElytraZ;
+   private ResourceLocation locationOfCape = null;
+   private long reloadCapeTimeMs = 0L;
+   private boolean elytraOfCape = false;
+   private String nameClear = null;
+   public EntityShoulderRiding entityShoulderLeft;
+   public EntityShoulderRiding entityShoulderRight;
+   private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");
 
    public AbstractClientPlayer(World var1, GameProfile var2) {
       super(var1, var2);
+      this.nameClear = var2.getName();
+      if (this.nameClear != null && !this.nameClear.isEmpty()) {
+         this.nameClear = StringUtils.stripControlCodes(this.nameClear);
+      }
+
+      CapeUtils.downloadCape(this);
+      PlayerConfigurations.getPlayerConfiguration(this);
    }
 
-   @Override
    public boolean isSpectator() {
       NetworkPlayerInfo var1 = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
       return var1 != null && var1.getGameType() == GameType.SPECTATOR;
    }
 
-   @Override
    public boolean isCreative() {
       NetworkPlayerInfo var1 = Minecraft.getMinecraft().getConnection().getPlayerInfo(this.getGameProfile().getId());
       return var1 != null && var1.getGameType() == GameType.CREATIVE;
    }
 
    public boolean hasPlayerInfo() {
@@ -62,14 +79,27 @@
       NetworkPlayerInfo var1 = this.getPlayerInfo();
       return var1 == null ? DefaultPlayerSkin.getDefaultSkin(this.getUniqueID()) : var1.getLocationSkin();
    }
 
    @Nullable
    public ResourceLocation getLocationCape() {
-      NetworkPlayerInfo var1 = this.getPlayerInfo();
-      return var1 == null ? null : var1.getLocationCape();
+      if (!Config.isShowCapes()) {
+         return null;
+      } else {
+         if (this.reloadCapeTimeMs != 0L && System.currentTimeMillis() > this.reloadCapeTimeMs) {
+            CapeUtils.reloadCape(this);
+            this.reloadCapeTimeMs = 0L;
+         }
+
+         if (this.locationOfCape != null) {
+            return this.locationOfCape;
+         } else {
+            NetworkPlayerInfo var1 = this.getPlayerInfo();
+            return var1 == null ? null : var1.getLocationCape();
+         }
+      }
    }
 
    public boolean isPlayerInfoSet() {
       return this.getPlayerInfo() != null;
    }
 
@@ -81,13 +111,13 @@
 
    public static ThreadDownloadImageData getDownloadImageSkin(ResourceLocation var0, String var1) {
       TextureManager var2 = Minecraft.getMinecraft().getTextureManager();
       Object var3 = var2.getTexture(var0);
       if (var3 == null) {
          var3 = new ThreadDownloadImageData(
-            null,
+            (File)null,
             String.format("http://skins.minecraft.net/MinecraftSkins/%s.png", StringUtils.stripControlCodes(var1)),
             DefaultPlayerSkin.getDefaultSkin(getOfflineUUID(var1)),
             new ImageBufferDownload()
          );
          var2.loadTexture(var0, (ITextureObject)var3);
       }
@@ -113,21 +143,58 @@
       IAttributeInstance var2 = this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);
       var1 = (float)(var1 * ((var2.getAttributeValue() / this.capabilities.getWalkSpeed() + 1.0) / 2.0));
       if (this.capabilities.getWalkSpeed() == 0.0F || Float.isNaN(var1) || Float.isInfinite(var1)) {
          var1 = 1.0F;
       }
 
-      if (this.isHandActive() && this.getActiveItemStack().getItem() == Items.BOW) {
+      if (this.isHandActive() && this.getActiveItemStack().getItem() instanceof ItemBow) {
          int var3 = this.getItemInUseMaxCount();
          float var4 = var3 / 20.0F;
          if (var4 > 1.0F) {
             var4 = 1.0F;
          } else {
             var4 *= var4;
          }
 
          var1 *= 1.0F - var4 * 0.15F;
       }
 
-      return var1;
+      return Reflector.ForgeHooksClient_getOffsetFOV.exists() ? Reflector.callFloat(Reflector.ForgeHooksClient_getOffsetFOV, new Object[]{this, var1}) : var1;
+   }
+
+   public String getNameClear() {
+      return this.nameClear;
+   }
+
+   public ResourceLocation getLocationOfCape() {
+      return this.locationOfCape;
+   }
+
+   public void setLocationOfCape(ResourceLocation var1) {
+      this.locationOfCape = var1;
+   }
+
+   public boolean hasElytraCape() {
+      ResourceLocation var1 = this.getLocationCape();
+      if (var1 == null) {
+         return false;
+      } else {
+         return var1 == this.locationOfCape ? this.elytraOfCape : true;
+      }
+   }
+
+   public void setElytraOfCape(boolean var1) {
+      this.elytraOfCape = var1;
+   }
+
+   public boolean isElytraOfCape() {
+      return this.elytraOfCape;
+   }
+
+   public long getReloadCapeTimeMs() {
+      return this.reloadCapeTimeMs;
+   }
+
+   public void setReloadCapeTimeMs(long var1) {
+      this.reloadCapeTimeMs = var1;
    }
 }
--- net/minecraft/client/entity/EntityOtherPlayerMP.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/entity/EntityOtherPlayerMP.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/entity/EntityPlayerSP.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/entity/EntityPlayerSP.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/achievement/GuiStats.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/achievement/GuiStats.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/advancements/AdvancementState.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/advancements/AdvancementState.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/advancements/AdvancementTabType.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/advancements/AdvancementTabType.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/advancements/GuiAdvancement.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/advancements/GuiAdvancement.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/advancements/GuiAdvancementTab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/advancements/GuiAdvancementTab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/advancements/GuiScreenAdvancements.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/advancements/GuiScreenAdvancements.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/chat/IChatListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/chat/IChatListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/chat/NarratorChatListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/chat/NarratorChatListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/chat/NormalChatListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/chat/NormalChatListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/chat/OverlayChatListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/chat/OverlayChatListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/CreativeCrafting.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/CreativeCrafting.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiBeacon.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiBeacon.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiBrewingStand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiBrewingStand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiChest.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiChest.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiContainer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiContainer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiContainerCreative.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiContainerCreative.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiCrafting.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiCrafting.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiDispenser.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiDispenser.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiEditCommandBlockMinecart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiEditCommandBlockMinecart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiEditSign.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiEditSign.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiEditStructure.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiEditStructure.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiFurnace.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiFurnace.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiInventory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiInventory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiScreenHorseInventory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiScreenHorseInventory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/inventory/GuiShulkerBox.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/inventory/GuiShulkerBox.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/GhostRecipe.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/GhostRecipe.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/GuiButtonRecipe.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/GuiButtonRecipe.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/GuiButtonRecipeTab.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/GuiButtonRecipeTab.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/GuiRecipeBook.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/GuiRecipeBook.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/GuiRecipeOverlay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/GuiRecipeOverlay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/IRecipeShownListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/IRecipeShownListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/IRecipeUpdateListener.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/IRecipeUpdateListener.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/RecipeBookPage.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/RecipeBookPage.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/recipebook/RecipeList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/recipebook/RecipeList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/categories/SpectatorDetails.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/categories/SpectatorDetails.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/categories/TeleportToPlayer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/categories/TeleportToPlayer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/categories/TeleportToTeam.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/categories/TeleportToTeam.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/BaseSpectatorGroup.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/BaseSpectatorGroup.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/ISpectatorMenuObject.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/ISpectatorMenuObject.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/ISpectatorMenuRecipient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/ISpectatorMenuRecipient.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/ISpectatorMenuView.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/ISpectatorMenuView.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/PlayerMenuObject.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/PlayerMenuObject.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/spectator/SpectatorMenu.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/spectator/SpectatorMenu.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/AdvancementToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/AdvancementToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/GuiToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/GuiToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/IToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/IToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/RecipeToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/RecipeToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/SystemToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/SystemToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/toasts/TutorialToast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/toasts/TutorialToast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/BossInfoClient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/BossInfoClient.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ChatLine.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ChatLine.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/FontRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/FontRenderer.java	Mon Aug 18 09:39:52 2025
@@ -5,12 +5,13 @@
 import com.ibm.icu.text.Bidi;
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.Properties;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureManager;
@@ -18,22 +19,25 @@
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
+import net.optifine.render.GlBlendState;
+import net.optifine.util.FontUtils;
 import org.apache.commons.io.IOUtils;
 
 public class FontRenderer implements IResourceManagerReloadListener {
    private static final ResourceLocation[] UNICODE_PAGE_LOCATIONS = new ResourceLocation[256];
    private final int[] charWidth = new int[256];
    public int FONT_HEIGHT = 9;
    public Random fontRandom = new Random();
    private final byte[] glyphWidth = new byte[65536];
    private final int[] colorCode = new int[32];
-   private final ResourceLocation locationFontTexture;
+   private ResourceLocation locationFontTexture;
    private final TextureManager renderEngine;
    private float posX;
    private float posY;
    private boolean unicodeFlag;
    private boolean bidiFlag;
    private float red;
@@ -43,18 +47,27 @@
    private int textColor;
    private boolean randomStyle;
    private boolean boldStyle;
    private boolean italicStyle;
    private boolean underlineStyle;
    private boolean strikethroughStyle;
+   public GameSettings gameSettings;
+   public ResourceLocation locationFontTextureBase;
+   public float offsetBold = 1.0F;
+   private float[] charWidthFloat = new float[256];
+   private boolean blend = false;
+   private GlBlendState oldBlendState = new GlBlendState();
 
    public FontRenderer(GameSettings var1, ResourceLocation var2, TextureManager var3, boolean var4) {
+      this.gameSettings = var1;
+      this.locationFontTextureBase = var2;
       this.locationFontTexture = var2;
       this.renderEngine = var3;
       this.unicodeFlag = var4;
-      var3.bindTexture(this.locationFontTexture);
+      this.locationFontTexture = FontUtils.getHdFontLocation(this.locationFontTextureBase);
+      this.bindTexture(this.locationFontTexture);
 
       for (int var5 = 0; var5 < 32; var5++) {
          int var6 = (var5 >> 3 & 1) * 85;
          int var7 = (var5 >> 2 & 1) * 170 + var6;
          int var8 = (var5 >> 1 & 1) * 170 + var6;
          int var9 = (var5 >> 0 & 1) * 170 + var6;
@@ -80,98 +93,128 @@
          this.colorCode[var5] = (var7 & 0xFF) << 16 | (var8 & 0xFF) << 8 | var9 & 0xFF;
       }
 
       this.readGlyphSizes();
    }
 
-   @Override
    public void onResourceManagerReload(IResourceManager var1) {
+      this.locationFontTexture = FontUtils.getHdFontLocation(this.locationFontTextureBase);
+
+      for (int var2 = 0; var2 < UNICODE_PAGE_LOCATIONS.length; var2++) {
+         UNICODE_PAGE_LOCATIONS[var2] = null;
+      }
+
       this.readFontTexture();
       this.readGlyphSizes();
    }
 
    private void readFontTexture() {
-      IResource var2 = null;
+      IResource var1 = null;
 
-      BufferedImage var1;
+      BufferedImage var2;
       try {
-         var2 = Minecraft.getMinecraft().getResourceManager().getResource(this.locationFontTexture);
-         var1 = TextureUtil.readBufferedImage(var2.getInputStream());
-      } catch (IOException var20) {
-         throw new RuntimeException(var20);
+         var1 = this.getResource(this.locationFontTexture);
+         var2 = TextureUtil.readBufferedImage(var1.getInputStream());
+      } catch (IOException var24) {
+         throw new RuntimeException(var24);
       } finally {
-         IOUtils.closeQuietly(var2);
+         IOUtils.closeQuietly(var1);
       }
 
-      int var3 = var1.getWidth();
-      int var4 = var1.getHeight();
-      int[] var5 = new int[var3 * var4];
-      var1.getRGB(0, 0, var3, var4, var5, 0, var3);
+      Properties var3 = FontUtils.readFontProperties(this.locationFontTexture);
+      this.blend = FontUtils.readBoolean(var3, "blend", false);
+      int var4 = var2.getWidth();
+      int var5 = var2.getHeight();
       int var6 = var4 / 16;
-      int var7 = var3 / 16;
-      boolean var8 = true;
-      float var9 = 8.0F / var7;
-
-      for (int var10 = 0; var10 < 256; var10++) {
-         int var11 = var10 % 16;
-         int var12 = var10 / 16;
-         if (var10 == 32) {
-            this.charWidth[var10] = 4;
-         }
-
-         int var13;
-         for (var13 = var7 - 1; var13 >= 0; var13--) {
-            int var14 = var11 * var7 + var13;
-            boolean var15 = true;
-
-            for (int var16 = 0; var16 < var6 && var15; var16++) {
-               int var17 = (var12 * var7 + var16) * var3;
-               if ((var5[var14 + var17] >> 24 & 0xFF) != 0) {
-                  var15 = false;
+      int var7 = var5 / 16;
+      float var8 = var4 / 128.0F;
+      float var9 = Config.limit(var8, 1.0F, 2.0F);
+      this.offsetBold = 1.0F / var9;
+      float var10 = FontUtils.readFloat(var3, "offsetBold", -1.0F);
+      if (var10 >= 0.0F) {
+         this.offsetBold = var10;
+      }
+
+      int[] var11 = new int[var4 * var5];
+      var2.getRGB(0, 0, var4, var5, var11, 0, var4);
+
+      for (int var12 = 0; var12 < 256; var12++) {
+         int var13 = var12 % 16;
+         int var14 = var12 / 16;
+         int var15 = 0;
+
+         for (var15 = var6 - 1; var15 >= 0; var15--) {
+            int var16 = var13 * var6 + var15;
+            boolean var17 = true;
+
+            for (int var18 = 0; var18 < var7 && var17; var18++) {
+               int var19 = (var14 * var7 + var18) * var4;
+               int var20 = var11[var16 + var19];
+               int var21 = var20 >> 24 & 0xFF;
+               if (var21 > 16) {
+                  var17 = false;
                }
             }
 
-            if (!var15) {
+            if (!var17) {
                break;
             }
          }
 
-         this.charWidth[var10] = (int)(0.5 + ++var13 * var9) + 1;
+         if (var12 == 65) {
+            var12 = var12;
+         }
+
+         if (var12 == 32) {
+            if (var6 <= 8) {
+               var15 = (int)(2.0F * var8);
+            } else {
+               var15 = (int)(1.5F * var8);
+            }
+         }
+
+         this.charWidthFloat[var12] = (var15 + 1) / var8 + 1.0F;
+      }
+
+      FontUtils.readCustomCharWidths(var3, this.charWidthFloat);
+
+      for (int var26 = 0; var26 < this.charWidth.length; var26++) {
+         this.charWidth[var26] = Math.round(this.charWidthFloat[var26]);
       }
    }
 
    private void readGlyphSizes() {
       IResource var1 = null;
 
       try {
-         var1 = Minecraft.getMinecraft().getResourceManager().getResource(new ResourceLocation("font/glyph_sizes.bin"));
+         var1 = this.getResource(new ResourceLocation("font/glyph_sizes.bin"));
          var1.getInputStream().read(this.glyphWidth);
       } catch (IOException var6) {
          throw new RuntimeException(var6);
       } finally {
          IOUtils.closeQuietly(var1);
       }
    }
 
    private float renderChar(char var1, boolean var2) {
-      if (var1 == ' ') {
-         return 4.0F;
-      } else {
+      if (var1 != ' ' && var1 != 160) {
          int var3 = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
             .indexOf(var1);
          return var3 != -1 && !this.unicodeFlag ? this.renderDefaultChar(var3, var2) : this.renderUnicodeChar(var1, var2);
+      } else {
+         return !this.unicodeFlag ? this.charWidthFloat[var1] : 4.0F;
       }
    }
 
    private float renderDefaultChar(int var1, boolean var2) {
       int var3 = var1 % 16 * 8;
       int var4 = var1 / 16 * 8;
       int var5 = var2 ? 1 : 0;
-      this.renderEngine.bindTexture(this.locationFontTexture);
-      int var6 = this.charWidth[var1];
-      float var7 = var6 - 0.01F;
+      this.bindTexture(this.locationFontTexture);
+      float var6 = this.charWidthFloat[var1];
+      float var7 = 7.99F;
       GlStateManager.glBegin(5);
       GlStateManager.glTexCoord2f(var3 / 128.0F, var4 / 128.0F);
       GlStateManager.glVertex3f(this.posX + var5, this.posY, 0.0F);
       GlStateManager.glTexCoord2f(var3 / 128.0F, (var4 + 7.99F) / 128.0F);
       GlStateManager.glVertex3f(this.posX - var5, this.posY + 7.99F, 0.0F);
       GlStateManager.glTexCoord2f((var3 + var7 - 1.0F) / 128.0F, var4 / 128.0F);
@@ -182,19 +225,20 @@
       return var6;
    }
 
    private ResourceLocation getUnicodePageLocation(int var1) {
       if (UNICODE_PAGE_LOCATIONS[var1] == null) {
          UNICODE_PAGE_LOCATIONS[var1] = new ResourceLocation(String.format("textures/font/unicode_page_%02x.png", var1));
+         UNICODE_PAGE_LOCATIONS[var1] = FontUtils.getHdFontLocation(UNICODE_PAGE_LOCATIONS[var1]);
       }
 
       return UNICODE_PAGE_LOCATIONS[var1];
    }
 
    private void loadGlyphTexture(int var1) {
-      this.renderEngine.bindTexture(this.getUnicodePageLocation(var1));
+      this.bindTexture(this.getUnicodePageLocation(var1));
    }
 
    private float renderUnicodeChar(char var1, boolean var2) {
       int var3 = this.glyphWidth[var1] & 255;
       if (var3 == 0) {
          return 0.0F;
@@ -229,22 +273,32 @@
 
    public int drawString(String var1, int var2, int var3, int var4) {
       return this.drawString(var1, var2, var3, var4, false);
    }
 
    public int drawString(String var1, float var2, float var3, int var4, boolean var5) {
-      GlStateManager.enableAlpha();
+      this.enableAlpha();
+      if (this.blend) {
+         GlStateManager.getBlendState(this.oldBlendState);
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+      }
+
       this.resetStyles();
       int var7;
       if (var5) {
          var7 = this.renderString(var1, var2 + 1.0F, var3 + 1.0F, var4, true);
          var7 = Math.max(var7, this.renderString(var1, var2, var3, var4, false));
       } else {
          var7 = this.renderString(var1, var2, var3, var4, false);
       }
 
+      if (this.blend) {
+         GlStateManager.setBlendState(this.oldBlendState);
+      }
+
       return var7;
    }
 
    private String bidiReorder(String var1) {
       try {
          Bidi var2 = new Bidi(new ArabicShaping(8).shape(var1), 127);
@@ -264,47 +318,51 @@
    }
 
    private void renderStringAtPos(String var1, boolean var2) {
       for (int var3 = 0; var3 < var1.length(); var3++) {
          char var4 = var1.charAt(var3);
          if (var4 == 167 && var3 + 1 < var1.length()) {
-            int var12 = "0123456789abcdefklmnor".indexOf(String.valueOf(var1.charAt(var3 + 1)).toLowerCase(Locale.ROOT).charAt(0));
-            if (var12 < 16) {
+            int var9 = "0123456789abcdefklmnor".indexOf(String.valueOf(var1.charAt(var3 + 1)).toLowerCase(Locale.ROOT).charAt(0));
+            if (var9 < 16) {
                this.randomStyle = false;
                this.boldStyle = false;
                this.strikethroughStyle = false;
                this.underlineStyle = false;
                this.italicStyle = false;
-               if (var12 < 0 || var12 > 15) {
-                  var12 = 15;
+               if (var9 < 0 || var9 > 15) {
+                  var9 = 15;
                }
 
                if (var2) {
-                  var12 += 16;
+                  var9 += 16;
                }
 
-               int var14 = this.colorCode[var12];
-               this.textColor = var14;
-               GlStateManager.color((var14 >> 16) / 255.0F, (var14 >> 8 & 0xFF) / 255.0F, (var14 & 0xFF) / 255.0F, this.alpha);
-            } else if (var12 == 16) {
+               int var11 = this.colorCode[var9];
+               if (Config.isCustomColors()) {
+                  var11 = CustomColors.getTextColor(var9, var11);
+               }
+
+               this.textColor = var11;
+               this.setColor((var11 >> 16) / 255.0F, (var11 >> 8 & 0xFF) / 255.0F, (var11 & 0xFF) / 255.0F, this.alpha);
+            } else if (var9 == 16) {
                this.randomStyle = true;
-            } else if (var12 == 17) {
+            } else if (var9 == 17) {
                this.boldStyle = true;
-            } else if (var12 == 18) {
+            } else if (var9 == 18) {
                this.strikethroughStyle = true;
-            } else if (var12 == 19) {
+            } else if (var9 == 19) {
                this.underlineStyle = true;
-            } else if (var12 == 20) {
+            } else if (var9 == 20) {
                this.italicStyle = true;
-            } else if (var12 == 21) {
+            } else if (var9 == 21) {
                this.randomStyle = false;
                this.boldStyle = false;
                this.strikethroughStyle = false;
                this.underlineStyle = false;
                this.italicStyle = false;
-               GlStateManager.color(this.red, this.blue, this.green, this.alpha);
+               this.setColor(this.red, this.blue, this.green, this.alpha);
             }
 
             var3++;
          } else {
             int var5 = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
                .indexOf(var4);
@@ -322,74 +380,78 @@
                      .charAt(var5);
                } while (var6 != this.getCharWidth(var7));
 
                var4 = var7;
             }
 
-            float var13 = this.unicodeFlag ? 0.5F : 1.0F;
-            boolean var15 = (var4 == 0 || var5 == -1 || this.unicodeFlag) && var2;
-            if (var15) {
-               this.posX -= var13;
-               this.posY -= var13;
+            float var10 = var5 != -1 && !this.unicodeFlag ? this.offsetBold : 0.5F;
+            boolean var12 = (var4 == 0 || var5 == -1 || this.unicodeFlag) && var2;
+            if (var12) {
+               this.posX -= var10;
+               this.posY -= var10;
             }
 
             float var8 = this.renderChar(var4, this.italicStyle);
-            if (var15) {
-               this.posX += var13;
-               this.posY += var13;
+            if (var12) {
+               this.posX += var10;
+               this.posY += var10;
             }
 
             if (this.boldStyle) {
-               this.posX += var13;
-               if (var15) {
-                  this.posX -= var13;
-                  this.posY -= var13;
+               this.posX += var10;
+               if (var12) {
+                  this.posX -= var10;
+                  this.posY -= var10;
                }
 
                this.renderChar(var4, this.italicStyle);
-               this.posX -= var13;
-               if (var15) {
-                  this.posX += var13;
-                  this.posY += var13;
+               this.posX -= var10;
+               if (var12) {
+                  this.posX += var10;
+                  this.posY += var10;
                }
 
-               var8++;
-            }
-
-            if (this.strikethroughStyle) {
-               Tessellator var9 = Tessellator.getInstance();
-               BufferBuilder var10 = var9.getBuffer();
-               GlStateManager.disableTexture2D();
-               var10.begin(7, DefaultVertexFormats.POSITION);
-               var10.pos(this.posX, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
-               var10.pos(this.posX + var8, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
-               var10.pos(this.posX + var8, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
-               var10.pos(this.posX, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
-               var9.draw();
-               GlStateManager.enableTexture2D();
-            }
-
-            if (this.underlineStyle) {
-               Tessellator var16 = Tessellator.getInstance();
-               BufferBuilder var17 = var16.getBuffer();
-               GlStateManager.disableTexture2D();
-               var17.begin(7, DefaultVertexFormats.POSITION);
-               int var11 = this.underlineStyle ? -1 : 0;
-               var17.pos(this.posX + var11, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
-               var17.pos(this.posX + var8, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
-               var17.pos(this.posX + var8, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
-               var17.pos(this.posX + var11, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
-               var16.draw();
-               GlStateManager.enableTexture2D();
+               var8 += var10;
             }
 
-            this.posX += (int)var8;
+            this.doDraw(var8);
          }
       }
    }
 
+   protected void doDraw(float var1) {
+      if (this.strikethroughStyle) {
+         Tessellator var2 = Tessellator.getInstance();
+         BufferBuilder var3 = var2.getBuffer();
+         GlStateManager.disableTexture2D();
+         var3.begin(7, DefaultVertexFormats.POSITION);
+         var3.pos(this.posX, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
+         var3.pos(this.posX + var1, this.posY + this.FONT_HEIGHT / 2, 0.0).endVertex();
+         var3.pos(this.posX + var1, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
+         var3.pos(this.posX, this.posY + this.FONT_HEIGHT / 2 - 1.0F, 0.0).endVertex();
+         var2.draw();
+         GlStateManager.enableTexture2D();
+      }
+
+      if (this.underlineStyle) {
+         Tessellator var5 = Tessellator.getInstance();
+         BufferBuilder var6 = var5.getBuffer();
+         GlStateManager.disableTexture2D();
+         var6.begin(7, DefaultVertexFormats.POSITION);
+         int var4 = this.underlineStyle ? -1 : 0;
+         var6.pos(this.posX + var4, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
+         var6.pos(this.posX + var1, this.posY + this.FONT_HEIGHT, 0.0).endVertex();
+         var6.pos(this.posX + var1, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
+         var6.pos(this.posX + var4, this.posY + this.FONT_HEIGHT - 1.0F, 0.0).endVertex();
+         var5.draw();
+         GlStateManager.enableTexture2D();
+      }
+
+      this.posX += var1;
+   }
+
    private int renderStringAligned(String var1, int var2, int var3, int var4, int var5, boolean var6) {
       if (this.bidiFlag) {
          int var7 = this.getStringWidth(this.bidiReorder(var1));
          var2 = var2 + var4 - var7;
       }
 
@@ -413,96 +475,100 @@
          }
 
          this.red = (var4 >> 16 & 0xFF) / 255.0F;
          this.blue = (var4 >> 8 & 0xFF) / 255.0F;
          this.green = (var4 & 0xFF) / 255.0F;
          this.alpha = (var4 >> 24 & 0xFF) / 255.0F;
-         GlStateManager.color(this.red, this.blue, this.green, this.alpha);
+         this.setColor(this.red, this.blue, this.green, this.alpha);
          this.posX = var2;
          this.posY = var3;
          this.renderStringAtPos(var1, var5);
          return (int)this.posX;
       }
    }
 
    public int getStringWidth(String var1) {
       if (var1 == null) {
          return 0;
       } else {
-         int var2 = 0;
+         float var2 = 0.0F;
          boolean var3 = false;
 
          for (int var4 = 0; var4 < var1.length(); var4++) {
             char var5 = var1.charAt(var4);
-            int var6 = this.getCharWidth(var5);
-            if (var6 < 0 && var4 < var1.length() - 1) {
+            float var6 = this.getCharWidthFloat(var5);
+            if (var6 < 0.0F && var4 < var1.length() - 1) {
                var5 = var1.charAt(++var4);
                if (var5 == 'l' || var5 == 'L') {
                   var3 = true;
                } else if (var5 == 'r' || var5 == 'R') {
                   var3 = false;
                }
 
-               var6 = 0;
+               var6 = 0.0F;
             }
 
             var2 += var6;
-            if (var3 && var6 > 0) {
-               var2++;
+            if (var3 && var6 > 0.0F) {
+               var2 += this.unicodeFlag ? 1.0F : this.offsetBold;
             }
          }
 
-         return var2;
+         return Math.round(var2);
       }
    }
 
    public int getCharWidth(char var1) {
+      return Math.round(this.getCharWidthFloat(var1));
+   }
+
+   private float getCharWidthFloat(char var1) {
       if (var1 == 167) {
-         return -1;
-      } else if (var1 == ' ') {
-         return 4;
-      } else {
+         return -1.0F;
+      } else if (var1 != ' ' && var1 != 160) {
          int var2 = "ÀÁÂÈÊËÍÓÔÕÚßãõğİıŒœŞşŴŵžȇ\u0000\u0000\u0000\u0000\u0000\u0000\u0000 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0000ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αβΓπΣσμτΦΘΩδ∞∅∈∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■\u0000"
             .indexOf(var1);
          if (var1 > 0 && var2 != -1 && !this.unicodeFlag) {
-            return this.charWidth[var2];
+            return this.charWidthFloat[var2];
          } else if (this.glyphWidth[var1] != 0) {
             int var3 = this.glyphWidth[var1] & 255;
             int var4 = var3 >>> 4;
             int var5 = var3 & 15;
             var5++;
             return (var5 - var4) / 2 + 1;
          } else {
-            return 0;
+            return 0.0F;
          }
+      } else {
+         return this.charWidthFloat[32];
       }
    }
 
    public String trimStringToWidth(String var1, int var2) {
       return this.trimStringToWidth(var1, var2, false);
    }
 
    public String trimStringToWidth(String var1, int var2, boolean var3) {
       StringBuilder var4 = new StringBuilder();
-      int var5 = 0;
+      float var5 = 0.0F;
       int var6 = var3 ? var1.length() - 1 : 0;
       int var7 = var3 ? -1 : 1;
       boolean var8 = false;
       boolean var9 = false;
 
       for (int var10 = var6; var10 >= 0 && var10 < var1.length() && var5 < var2; var10 += var7) {
          char var11 = var1.charAt(var10);
-         int var12 = this.getCharWidth(var11);
+         float var12 = this.getCharWidthFloat(var11);
          if (var8) {
             var8 = false;
             if (var11 == 'l' || var11 == 'L') {
                var9 = true;
             } else if (var11 == 'r' || var11 == 'R') {
                var9 = false;
             }
-         } else if (var12 < 0) {
+         } else if (var12 < 0.0F) {
             var8 = true;
          } else {
             var5 += var12;
             if (var9) {
                var5++;
             }
@@ -528,21 +594,30 @@
       }
 
       return var1;
    }
 
    public void drawSplitString(String var1, int var2, int var3, int var4, int var5) {
+      if (this.blend) {
+         GlStateManager.getBlendState(this.oldBlendState);
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+      }
+
       this.resetStyles();
       this.textColor = var5;
       var1 = this.trimStringNewline(var1);
       this.renderSplitString(var1, var2, var3, var4, false);
+      if (this.blend) {
+         GlStateManager.setBlendState(this.oldBlendState);
+      }
    }
 
    private void renderSplitString(String var1, int var2, int var3, int var4, boolean var5) {
-      for (String var8 : this.listFormattedStringToWidth(var1, var4)) {
-         this.renderStringAligned(var8, var2, var3, var4, this.textColor, var5);
+      for (String var7 : this.listFormattedStringToWidth(var1, var4)) {
+         this.renderStringAligned(var7, var2, var3, var4, this.textColor, var5);
          var3 += this.FONT_HEIGHT;
       }
    }
 
    public int getWordWrappedHeight(String var1, int var2) {
       return this.FONT_HEIGHT * this.listFormattedStringToWidth(var1, var2).size();
@@ -562,40 +637,44 @@
 
    public List<String> listFormattedStringToWidth(String var1, int var2) {
       return Arrays.asList(this.wrapFormattedStringToWidth(var1, var2).split("\n"));
    }
 
    String wrapFormattedStringToWidth(String var1, int var2) {
-      int var3 = this.sizeStringToWidth(var1, var2);
-      if (var1.length() <= var3) {
+      if (var1.length() <= 1) {
          return var1;
       } else {
-         String var4 = var1.substring(0, var3);
-         char var5 = var1.charAt(var3);
-         boolean var6 = var5 == ' ' || var5 == '\n';
-         String var7 = getFormatFromString(var4) + var1.substring(var3 + (var6 ? 1 : 0));
-         return var4 + "\n" + this.wrapFormattedStringToWidth(var7, var2);
+         int var3 = this.sizeStringToWidth(var1, var2);
+         if (var1.length() <= var3) {
+            return var1;
+         } else {
+            String var4 = var1.substring(0, var3);
+            char var5 = var1.charAt(var3);
+            boolean var6 = var5 == ' ' || var5 == '\n';
+            String var7 = getFormatFromString(var4) + var1.substring(var3 + (var6 ? 1 : 0));
+            return var4 + "\n" + this.wrapFormattedStringToWidth(var7, var2);
+         }
       }
    }
 
    private int sizeStringToWidth(String var1, int var2) {
       int var3 = var1.length();
-      int var4 = 0;
+      float var4 = 0.0F;
       int var5 = 0;
       int var6 = -1;
 
       for (boolean var7 = false; var5 < var3; var5++) {
          char var8 = var1.charAt(var5);
          switch (var8) {
             case '\n':
                var5--;
                break;
             case ' ':
                var6 = var5;
             default:
-               var4 += this.getCharWidth(var8);
+               var4 += this.getCharWidthFloat(var8);
                if (var7) {
                   var4++;
                }
                break;
             case '§':
                if (var5 < var3 - 1) {
@@ -610,13 +689,13 @@
 
          if (var8 == '\n') {
             var6 = ++var5;
             break;
          }
 
-         if (var4 > var2) {
+         if (Math.round(var4) > var2) {
             break;
          }
       }
 
       return var5 != var3 && var6 != -1 && var6 < var5 ? var6 : var5;
    }
@@ -651,9 +730,34 @@
    public boolean getBidiFlag() {
       return this.bidiFlag;
    }
 
    public int getColorCode(char var1) {
       int var2 = "0123456789abcdef".indexOf(var1);
-      return var2 >= 0 && var2 < this.colorCode.length ? this.colorCode[var2] : -1;
+      if (var2 >= 0 && var2 < this.colorCode.length) {
+         int var3 = this.colorCode[var2];
+         if (Config.isCustomColors()) {
+            var3 = CustomColors.getTextColor(var2, var3);
+         }
+
+         return var3;
+      } else {
+         return 16777215;
+      }
+   }
+
+   protected void setColor(float var1, float var2, float var3, float var4) {
+      GlStateManager.color(var1, var2, var3, var4);
+   }
+
+   protected void enableAlpha() {
+      GlStateManager.enableAlpha();
+   }
+
+   protected void bindTexture(ResourceLocation var1) {
+      this.renderEngine.bindTexture(var1);
+   }
+
+   protected IResource getResource(ResourceLocation var1) throws IOException {
+      return Minecraft.getMinecraft().getResourceManager().getResource(var1);
    }
 }
--- net/minecraft/client/gui/Gui.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/Gui.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiBossOverlay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiBossOverlay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiButton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiButton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiButtonImage.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiButtonImage.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiButtonLanguage.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiButtonLanguage.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiButtonRealmsProxy.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiButtonRealmsProxy.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiButtonToggle.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiButtonToggle.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiChat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiChat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiClickableScrolledSelectionListProxy.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiClickableScrolledSelectionListProxy.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiCommandBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiCommandBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiConfirmOpenLink.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiConfirmOpenLink.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiControls.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiControls.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiCreateFlatWorld.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiCreateFlatWorld.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiCreateWorld.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiCreateWorld.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiCustomizeSkin.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiCustomizeSkin.java	Mon Aug 18 09:39:52 2025
@@ -1,21 +1,23 @@
 package net.minecraft.client.gui;
 
+import java.io.IOException;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.entity.player.EnumPlayerModelParts;
+import net.optifine.gui.GuiButtonOF;
+import net.optifine.gui.GuiScreenCapeOF;
 
 public class GuiCustomizeSkin extends GuiScreen {
    private final GuiScreen parentScreen;
    private String title;
 
    public GuiCustomizeSkin(GuiScreen var1) {
       this.parentScreen = var1;
    }
 
-   @Override
    public void initGui() {
       int var1 = 0;
       this.title = I18n.format("options.skinCustomisation.title");
 
       for (EnumPlayerModelParts var5 : EnumPlayerModelParts.values()) {
          this.buttonList
@@ -34,27 +36,31 @@
             )
          );
       if (++var1 % 2 == 1) {
          var1++;
       }
 
+      this.buttonList.add(new GuiButtonOF(210, this.width / 2 - 100, this.height / 6 + 24 * (var1 >> 1), I18n.format("of.options.skinCustomisation.ofCape")));
+      var1 += 2;
       this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 24 * (var1 >> 1), I18n.format("gui.done")));
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
+   protected void keyTyped(char var1, int var2) throws IOException {
       if (var2 == 1) {
          this.mc.gameSettings.saveOptions();
       }
 
       super.keyTyped(var1, var2);
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
+   protected void actionPerformed(GuiButton var1) throws IOException {
       if (var1.enabled) {
+         if (var1.id == 210) {
+            this.mc.displayGuiScreen(new GuiScreenCapeOF(this));
+         }
+
          if (var1.id == 200) {
             this.mc.gameSettings.saveOptions();
             this.mc.displayGuiScreen(this.parentScreen);
          } else if (var1.id == 199) {
             this.mc.gameSettings.setOptionValue(GameSettings.Options.MAIN_HAND, 1);
             var1.displayString = this.mc.gameSettings.getKeyBinding(GameSettings.Options.MAIN_HAND);
@@ -64,16 +70,15 @@
             this.mc.gameSettings.switchModelPartEnabled(var2);
             var1.displayString = this.getMessage(var2);
          }
       }
    }
 
-   @Override
    public void drawScreen(int var1, int var2, float var3) {
       this.drawDefaultBackground();
-      this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 20, 16777215);
+      this.a(this.fontRenderer, this.title, this.width / 2, 20, 16777215);
       super.drawScreen(var1, var2, var3);
    }
 
    private String getMessage(EnumPlayerModelParts var1) {
       String var2;
       if (this.mc.gameSettings.getModelParts().contains(var1)) {
--- net/minecraft/client/gui/GuiCustomizeWorldScreen.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiCustomizeWorldScreen.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiDisconnected.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiDisconnected.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiDownloadTerrain.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiDownloadTerrain.java	Mon Aug 18 09:39:52 2025
@@ -1,22 +1,28 @@
 package net.minecraft.client.gui;
 
 import net.minecraft.client.resources.I18n;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
 
 public class GuiDownloadTerrain extends GuiScreen {
-   @Override
+   private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
+
    public void initGui() {
       this.buttonList.clear();
    }
 
-   @Override
    public void drawScreen(int var1, int var2, float var3) {
-      this.drawBackground(0);
-      this.drawCenteredString(this.fontRenderer, I18n.format("multiplayer.downloadingTerrain"), this.width / 2, this.height / 2 - 50, 16777215);
+      if (this.customLoadingScreen != null) {
+         this.customLoadingScreen.drawBackground(this.width, this.height);
+      } else {
+         this.drawBackground(0);
+      }
+
+      this.a(this.fontRenderer, I18n.format("multiplayer.downloadingTerrain"), this.width / 2, this.height / 2 - 50, 16777215);
       super.drawScreen(var1, var2, var3);
    }
 
-   @Override
    public boolean doesGuiPauseGame() {
       return false;
    }
 }
--- net/minecraft/client/gui/GuiEnchantment.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiEnchantment.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiErrorScreen.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiErrorScreen.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiFlatPresets.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiFlatPresets.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiGameOver.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiGameOver.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiHopper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiHopper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiIngame.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiIngame.java	Mon Aug 18 09:39:52 2025
@@ -9,12 +9,13 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.block.material.Material;
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.chat.IChatListener;
 import net.minecraft.client.gui.chat.NarratorChatListener;
 import net.minecraft.client.gui.chat.NormalChatListener;
 import net.minecraft.client.gui.chat.OverlayChatListener;
 import net.minecraft.client.gui.inventory.GuiContainer;
@@ -49,16 +50,22 @@
 import net.minecraft.util.FoodStats;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.StringUtils;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.text.ChatType;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.world.border.WorldBorder;
+import net.optifine.CustomColors;
+import net.optifine.CustomItems;
+import net.optifine.TextureAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
 
 public class GuiIngame extends Gui {
    private static final ResourceLocation VIGNETTE_TEX_PATH = new ResourceLocation("textures/misc/vignette.png");
    private static final ResourceLocation WIDGETS_TEX_PATH = new ResourceLocation("textures/gui/widgets.png");
    private static final ResourceLocation PUMPKIN_BLUR_TEX_PATH = new ResourceLocation("textures/misc/pumpkinblur.png");
    private final Random rand = new Random();
@@ -121,13 +128,13 @@
    public void renderGameOverlay(float var1) {
       ScaledResolution var2 = new ScaledResolution(this.mc);
       int var3 = var2.getScaledWidth();
       int var4 = var2.getScaledHeight();
       FontRenderer var5 = this.getFontRenderer();
       GlStateManager.enableBlend();
-      if (Minecraft.isFancyGraphicsEnabled()) {
+      if (Config.isVignetteEnabled()) {
          this.renderVignette(this.mc.player.getBrightness(), var2);
       } else {
          GlStateManager.enableDepth();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
@@ -155,12 +162,13 @@
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       this.mc.getTextureManager().bindTexture(ICONS);
       GlStateManager.enableBlend();
       this.renderAttackIndicator(var1, var2);
+      GlStateManager.enableAlpha();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       this.mc.profiler.startSection("bossHealth");
       this.overlayBoss.renderBossHealth();
       this.mc.profiler.endSection();
@@ -308,48 +316,49 @@
       GlStateManager.translate(0.0F, (float)(var4 - 48), 0.0F);
       this.mc.profiler.startSection("chat");
       this.persistantChatGUI.drawChat(this.updateCounter);
       this.mc.profiler.endSection();
       GlStateManager.popMatrix();
       var24 = var16.getObjectiveInDisplaySlot(0);
-      if (!this.mc.gameSettings.keyBindPlayerList.isKeyDown()
-         || this.mc.isIntegratedServerRunning() && this.mc.player.connection.getPlayerInfoMap().size() <= 1 && var24 == null) {
-         this.overlayPlayerList.updatePlayerList(false);
-      } else {
+      if (this.mc.gameSettings.keyBindPlayerList.isKeyDown()
+         && (!this.mc.isIntegratedServerRunning() || this.mc.player.connection.getPlayerInfoMap().size() > 1 || var24 != null)) {
          this.overlayPlayerList.updatePlayerList(true);
          this.overlayPlayerList.renderPlayerlist(var3, var16, var24);
+      } else {
+         this.overlayPlayerList.updatePlayerList(false);
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.disableLighting();
       GlStateManager.enableAlpha();
    }
 
    private void renderAttackIndicator(float var1, ScaledResolution var2) {
       GameSettings var3 = this.mc.gameSettings;
       if (var3.thirdPersonView == 0) {
          if (this.mc.playerController.isSpectator() && this.mc.pointedEntity == null) {
             RayTraceResult var4 = this.mc.objectMouseOver;
-            if (var4 == null || var4.typeOfHit != RayTraceResult.Type.BLOCK) {
+            if (var4 == null || var4.typeOfHit != Type.BLOCK) {
                return;
             }
 
             BlockPos var5 = var4.getBlockPos();
-            if (!this.mc.world.getBlockState(var5).getBlock().hasTileEntity() || !(this.mc.world.getTileEntity(var5) instanceof IInventory)) {
+            IBlockState var6 = this.mc.world.getBlockState(var5);
+            if (!ReflectorForge.blockHasTileEntity(var6) || !(this.mc.world.getTileEntity(var5) instanceof IInventory)) {
                return;
             }
          }
 
          int var11 = var2.getScaledWidth();
          int var12 = var2.getScaledHeight();
          if (var3.showDebugInfo && !var3.hideGUI && !this.mc.player.hasReducedDebug() && !var3.reducedDebugInfo) {
             GlStateManager.pushMatrix();
             GlStateManager.translate((float)(var11 / 2), (float)(var12 / 2), this.zLevel);
-            Entity var13 = this.mc.getRenderViewEntity();
-            GlStateManager.rotate(var13.prevRotationPitch + (var13.rotationPitch - var13.prevRotationPitch) * var1, -1.0F, 0.0F, 0.0F);
-            GlStateManager.rotate(var13.prevRotationYaw + (var13.rotationYaw - var13.prevRotationYaw) * var1, 0.0F, 1.0F, 0.0F);
+            Entity var14 = this.mc.getRenderViewEntity();
+            GlStateManager.rotate(var14.prevRotationPitch + (var14.rotationPitch - var14.prevRotationPitch) * var1, -1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(var14.prevRotationYaw + (var14.rotationYaw - var14.prevRotationYaw) * var1, 0.0F, 1.0F, 0.0F);
             GlStateManager.scale(-1.0F, -1.0F, -1.0F);
             OpenGlHelper.renderDirections(10);
             GlStateManager.popMatrix();
          } else {
             GlStateManager.tryBlendFuncSeparate(
                GlStateManager.SourceFactor.ONE_MINUS_DST_COLOR,
@@ -357,25 +366,25 @@
                GlStateManager.SourceFactor.ONE,
                GlStateManager.DestFactor.ZERO
             );
             GlStateManager.enableAlpha();
             this.drawTexturedModalRect(var11 / 2 - 7, var12 / 2 - 7, 0, 0, 16, 16);
             if (this.mc.gameSettings.attackIndicator == 1) {
-               float var6 = this.mc.player.getCooledAttackStrength(0.0F);
+               float var13 = this.mc.player.getCooledAttackStrength(0.0F);
                boolean var7 = false;
-               if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && var6 >= 1.0F) {
+               if (this.mc.pointedEntity != null && this.mc.pointedEntity instanceof EntityLivingBase && var13 >= 1.0F) {
                   var7 = this.mc.player.getCooldownPeriod() > 5.0F;
                   var7 &= ((EntityLivingBase)this.mc.pointedEntity).isEntityAlive();
                }
 
                int var8 = var12 / 2 - 7 + 16;
                int var9 = var11 / 2 - 8;
                if (var7) {
                   this.drawTexturedModalRect(var9, var8, 68, 94, 16, 16);
-               } else if (var6 < 1.0F) {
-                  int var10 = (int)(var6 * 17.0F);
+               } else if (var13 < 1.0F) {
+                  int var10 = (int)(var13 * 17.0F);
                   this.drawTexturedModalRect(var9, var8, 36, 94, 16, 4);
                   this.drawTexturedModalRect(var9, var8, 52, 94, var10, 4);
                }
             }
          }
       }
@@ -388,44 +397,62 @@
          GlStateManager.enableBlend();
          int var3 = 0;
          int var4 = 0;
 
          for (PotionEffect var6 : Ordering.natural().reverse().sortedCopy(var2)) {
             Potion var7 = var6.getPotion();
-            if (var7.hasStatusIcon() && var6.doesShowParticles()) {
-               int var8 = var1.getScaledWidth();
-               byte var9 = 1;
+            boolean var8 = var7.hasStatusIcon();
+            if (Reflector.ForgePotion_shouldRenderHUD.exists()) {
+               if (!Reflector.callBoolean(var7, Reflector.ForgePotion_shouldRenderHUD, new Object[]{var6})) {
+                  continue;
+               }
+
+               this.mc.getTextureManager().bindTexture(GuiContainer.INVENTORY_BACKGROUND);
+               var8 = true;
+            }
+
+            if (var8 && var6.doesShowParticles()) {
+               int var9 = var1.getScaledWidth();
+               byte var10 = 1;
                if (this.mc.isDemo()) {
-                  var9 += 15;
+                  var10 += 15;
                }
 
-               int var10 = var7.getStatusIconIndex();
+               int var11 = var7.getStatusIconIndex();
                if (var7.isBeneficial()) {
                   var3++;
-                  var8 -= 25 * var3;
+                  var9 -= 25 * var3;
                } else {
                   var4++;
-                  var8 -= 25 * var4;
-                  var9 += 26;
+                  var9 -= 25 * var4;
+                  var10 += 26;
                }
 
                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-               float var11 = 1.0F;
+               float var12 = 1.0F;
                if (var6.getIsAmbient()) {
-                  this.drawTexturedModalRect(var8, var9, 165, 166, 24, 24);
+                  this.drawTexturedModalRect(var9, var10, 165, 166, 24, 24);
                } else {
-                  this.drawTexturedModalRect(var8, var9, 141, 166, 24, 24);
+                  this.drawTexturedModalRect(var9, var10, 141, 166, 24, 24);
                   if (var6.getDuration() <= 200) {
-                     int var12 = 10 - var6.getDuration() / 20;
-                     var11 = MathHelper.clamp(var6.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F)
-                        + MathHelper.cos(var6.getDuration() * (float) Math.PI / 5.0F) * MathHelper.clamp(var12 / 10.0F * 0.25F, 0.0F, 0.25F);
+                     int var13 = 10 - var6.getDuration() / 20;
+                     var12 = MathHelper.clamp(var6.getDuration() / 10.0F / 5.0F * 0.5F, 0.0F, 0.5F)
+                        + MathHelper.cos(var6.getDuration() * (float) Math.PI / 5.0F) * MathHelper.clamp(var13 / 10.0F * 0.25F, 0.0F, 0.25F);
                   }
                }
 
-               GlStateManager.color(1.0F, 1.0F, 1.0F, var11);
-               this.drawTexturedModalRect(var8 + 3, var9 + 3, var10 % 8 * 18, 198 + var10 / 8 * 18, 18, 18);
+               GlStateManager.color(1.0F, 1.0F, 1.0F, var12);
+               if (Reflector.ForgePotion_renderHUDEffect.exists()) {
+                  if (var7.hasStatusIcon()) {
+                     this.drawTexturedModalRect(var9 + 3, var10 + 3, var11 % 8 * 18, 198 + var11 / 8 * 18, 18, 18);
+                  }
+
+                  Reflector.call(var7, Reflector.ForgePotion_renderHUDEffect, new Object[]{var6, this, var9, Integer.valueOf(var10), this.zLevel, var12});
+               } else {
+                  this.drawTexturedModalRect(var9 + 3, var10 + 3, var11 % 8 * 18, 198 + var11 / 8 * 18, 18, 18);
+               }
             }
          }
       }
    }
 
    protected void renderHotbar(ScaledResolution var1, float var2) {
@@ -457,26 +484,30 @@
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
             GlStateManager.SourceFactor.ONE,
             GlStateManager.DestFactor.ZERO
          );
          RenderHelper.enableGUIStandardItemLighting();
+         CustomItems.setRenderOffHand(false);
 
          for (int var10 = 0; var10 < 9; var10++) {
             int var11 = var6 - 90 + var10 * 20 + 2;
             int var12 = var1.getScaledHeight() - 16 - 3;
-            this.renderHotbarItem(var11, var12, var2, var3, var3.inventory.mainInventory.get(var10));
+            this.renderHotbarItem(var11, var12, var2, var3, (ItemStack)var3.inventory.mainInventory.get(var10));
          }
 
          if (!var4.isEmpty()) {
+            CustomItems.setRenderOffHand(true);
             int var14 = var1.getScaledHeight() - 16 - 3;
             if (var5 == EnumHandSide.LEFT) {
                this.renderHotbarItem(var6 - 91 - 26, var14, var2, var3, var4);
             } else {
                this.renderHotbarItem(var6 + 91 + 10, var14, var2, var3, var4);
             }
+
+            CustomItems.setRenderOffHand(false);
          }
 
          if (this.mc.gameSettings.attackIndicator == 2) {
             float var15 = this.mc.player.getCooledAttackStrength(0.0F);
             if (var15 < 1.0F) {
                int var16 = var1.getScaledHeight() - 20;
@@ -528,20 +559,25 @@
          }
       }
 
       this.mc.profiler.endSection();
       if (this.mc.player.experienceLevel > 0) {
          this.mc.profiler.startSection("expLevel");
-         String var7 = "" + this.mc.player.experienceLevel;
-         int var8 = (var1.getScaledWidth() - this.getFontRenderer().getStringWidth(var7)) / 2;
-         int var9 = var1.getScaledHeight() - 31 - 4;
-         this.getFontRenderer().drawString(var7, var8 + 1, var9, 0);
-         this.getFontRenderer().drawString(var7, var8 - 1, var9, 0);
-         this.getFontRenderer().drawString(var7, var8, var9 + 1, 0);
-         this.getFontRenderer().drawString(var7, var8, var9 - 1, 0);
-         this.getFontRenderer().drawString(var7, var8, var9, 8453920);
+         int var8 = 8453920;
+         if (Config.isCustomColors()) {
+            var8 = CustomColors.getExpBarTextColor(var8);
+         }
+
+         String var9 = "" + this.mc.player.experienceLevel;
+         int var10 = (var1.getScaledWidth() - this.getFontRenderer().getStringWidth(var9)) / 2;
+         int var7 = var1.getScaledHeight() - 31 - 4;
+         this.getFontRenderer().drawString(var9, var10 + 1, var7, 0);
+         this.getFontRenderer().drawString(var9, var10 - 1, var7, 0);
+         this.getFontRenderer().drawString(var9, var10, var7 + 1, 0);
+         this.getFontRenderer().drawString(var9, var10, var7 - 1, 0);
+         this.getFontRenderer().drawString(var9, var10, var7, var8);
          this.mc.profiler.endSection();
       }
    }
 
    public void renderSelectedItem(ScaledResolution var1) {
       this.mc.profiler.startSection("selectedItemName");
@@ -599,49 +635,49 @@
       Collection var4 = var3.getSortedScores(var1);
       ArrayList var5 = Lists.newArrayList(Iterables.filter(var4, new Predicate<Score>() {
          public boolean apply(@Nullable Score var1) {
             return var1.getPlayerName() != null && !var1.getPlayerName().startsWith("#");
          }
       }));
-      ArrayList var21;
+      ArrayList var20;
       if (var5.size() > 15) {
-         var21 = Lists.newArrayList(Iterables.skip(var5, var4.size() - 15));
+         var20 = Lists.newArrayList(Iterables.skip(var5, var4.size() - 15));
       } else {
-         var21 = var5;
+         var20 = var5;
       }
 
       int var6 = this.getFontRenderer().getStringWidth(var1.getDisplayName());
 
-      for (Score var8 : var21) {
+      for (Score var8 : var20) {
          ScorePlayerTeam var9 = var3.getPlayersTeam(var8.getPlayerName());
          String var10 = ScorePlayerTeam.formatPlayerName(var9, var8.getPlayerName()) + ": " + TextFormatting.RED + var8.getScorePoints();
          var6 = Math.max(var6, this.getFontRenderer().getStringWidth(var10));
       }
 
-      int var22 = var21.size() * this.getFontRenderer().FONT_HEIGHT;
-      int var23 = var2.getScaledHeight() / 2 + var22 / 3;
-      byte var24 = 3;
-      int var25 = var2.getScaledWidth() - var6 - 3;
+      int var21 = var20.size() * this.getFontRenderer().FONT_HEIGHT;
+      int var22 = var2.getScaledHeight() / 2 + var21 / 3;
+      byte var23 = 3;
+      int var24 = var2.getScaledWidth() - var6 - 3;
       int var11 = 0;
 
-      for (Score var13 : var21) {
+      for (Score var13 : var20) {
          var11++;
          ScorePlayerTeam var14 = var3.getPlayersTeam(var13.getPlayerName());
          String var15 = ScorePlayerTeam.formatPlayerName(var14, var13.getPlayerName());
          String var16 = TextFormatting.RED + "" + var13.getScorePoints();
-         int var18 = var23 - var11 * this.getFontRenderer().FONT_HEIGHT;
-         int var19 = var2.getScaledWidth() - 3 + 2;
-         drawRect(var25 - 2, var18, var19, var18 + this.getFontRenderer().FONT_HEIGHT, 1342177280);
-         this.getFontRenderer().drawString(var15, var25, var18, 553648127);
-         this.getFontRenderer().drawString(var16, var19 - this.getFontRenderer().getStringWidth(var16), var18, 553648127);
-         if (var11 == var21.size()) {
-            String var20 = var1.getDisplayName();
-            drawRect(var25 - 2, var18 - this.getFontRenderer().FONT_HEIGHT - 1, var19, var18 - 1, 1610612736);
-            drawRect(var25 - 2, var18 - 1, var19, var18, 1342177280);
+         int var17 = var22 - var11 * this.getFontRenderer().FONT_HEIGHT;
+         int var18 = var2.getScaledWidth() - 3 + 2;
+         drawRect(var24 - 2, var17, var18, var17 + this.getFontRenderer().FONT_HEIGHT, 1342177280);
+         this.getFontRenderer().drawString(var15, var24, var17, 553648127);
+         this.getFontRenderer().drawString(var16, var18 - this.getFontRenderer().getStringWidth(var16), var17, 553648127);
+         if (var11 == var20.size()) {
+            String var19 = var1.getDisplayName();
+            drawRect(var24 - 2, var17 - this.getFontRenderer().FONT_HEIGHT - 1, var18, var17 - 1, 1610612736);
+            drawRect(var24 - 2, var17 - 1, var18, var17, 1342177280);
             this.getFontRenderer()
-               .drawString(var20, var25 + var6 / 2 - this.getFontRenderer().getStringWidth(var20) / 2, var18 - this.getFontRenderer().FONT_HEIGHT, 553648127);
+               .drawString(var19, var24 + var6 / 2 - this.getFontRenderer().getStringWidth(var19) / 2, var17 - this.getFontRenderer().FONT_HEIGHT, 553648127);
          }
       }
    }
 
    private void renderPlayerStats(ScaledResolution var1) {
       if (this.mc.getRenderViewEntity() instanceof EntityPlayer) {
@@ -876,51 +912,64 @@
       GlStateManager.enableDepth();
       GlStateManager.enableAlpha();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
 
    private void renderVignette(float var1, ScaledResolution var2) {
-      var1 = 1.0F - var1;
-      var1 = MathHelper.clamp(var1, 0.0F, 1.0F);
-      WorldBorder var3 = this.mc.world.getWorldBorder();
-      float var4 = (float)var3.getClosestDistance(this.mc.player);
-      double var5 = Math.min(var3.getResizeSpeed() * var3.getWarningTime() * 1000.0, Math.abs(var3.getTargetSize() - var3.getDiameter()));
-      double var7 = Math.max((double)var3.getWarningDistance(), var5);
-      if (var4 < var7) {
-         var4 = 1.0F - (float)(var4 / var7);
+      if (!Config.isVignetteEnabled()) {
+         GlStateManager.enableDepth();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
       } else {
-         var4 = 0.0F;
-      }
+         var1 = 1.0F - var1;
+         var1 = MathHelper.clamp(var1, 0.0F, 1.0F);
+         WorldBorder var3 = this.mc.world.getWorldBorder();
+         float var4 = (float)var3.getClosestDistance(this.mc.player);
+         double var5 = Math.min(var3.getResizeSpeed() * var3.getWarningTime() * 1000.0, Math.abs(var3.getTargetSize() - var3.getDiameter()));
+         double var7 = Math.max((double)var3.getWarningDistance(), var5);
+         if (var4 < var7) {
+            var4 = 1.0F - (float)(var4 / var7);
+         } else {
+            var4 = 0.0F;
+         }
 
-      this.prevVignetteBrightness = (float)(this.prevVignetteBrightness + (var1 - this.prevVignetteBrightness) * 0.01);
-      GlStateManager.disableDepth();
-      GlStateManager.depthMask(false);
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      if (var4 > 0.0F) {
-         GlStateManager.color(0.0F, var4, var4, 1.0F);
-      } else {
-         GlStateManager.color(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
-      }
+         this.prevVignetteBrightness = (float)(this.prevVignetteBrightness + (var1 - this.prevVignetteBrightness) * 0.01);
+         GlStateManager.disableDepth();
+         GlStateManager.depthMask(false);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.ZERO, GlStateManager.DestFactor.ONE_MINUS_SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
+         );
+         if (var4 > 0.0F) {
+            GlStateManager.color(0.0F, var4, var4, 1.0F);
+         } else {
+            GlStateManager.color(this.prevVignetteBrightness, this.prevVignetteBrightness, this.prevVignetteBrightness, 1.0F);
+         }
 
-      this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
-      Tessellator var9 = Tessellator.getInstance();
-      BufferBuilder var10 = var9.getBuffer();
-      var10.begin(7, DefaultVertexFormats.POSITION_TEX);
-      var10.pos(0.0, var2.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
-      var10.pos(var2.getScaledWidth(), var2.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
-      var10.pos(var2.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
-      var10.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
-      var9.draw();
-      GlStateManager.depthMask(true);
-      GlStateManager.enableDepth();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
+         this.mc.getTextureManager().bindTexture(VIGNETTE_TEX_PATH);
+         Tessellator var9 = Tessellator.getInstance();
+         BufferBuilder var10 = var9.getBuffer();
+         var10.begin(7, DefaultVertexFormats.POSITION_TEX);
+         var10.pos(0.0, var2.getScaledHeight(), -90.0).tex(0.0, 1.0).endVertex();
+         var10.pos(var2.getScaledWidth(), var2.getScaledHeight(), -90.0).tex(1.0, 1.0).endVertex();
+         var10.pos(var2.getScaledWidth(), 0.0, -90.0).tex(1.0, 0.0).endVertex();
+         var10.pos(0.0, 0.0, -90.0).tex(0.0, 0.0).endVertex();
+         var9.draw();
+         GlStateManager.depthMask(true);
+         GlStateManager.enableDepth();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+      }
    }
 
    private void renderPortal(float var1, ScaledResolution var2) {
       if (var1 < 1.0F) {
          var1 *= var1;
          var1 *= var1;
@@ -932,13 +981,13 @@
       GlStateManager.depthMask(false);
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.color(1.0F, 1.0F, 1.0F, var1);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-      TextureAtlasSprite var3 = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.getDefaultState());
+      TextureAtlasSprite var3 = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.t());
       float var4 = var3.getMinU();
       float var5 = var3.getMinV();
       float var6 = var3.getMaxU();
       float var7 = var3.getMaxV();
       Tessellator var8 = Tessellator.getInstance();
       BufferBuilder var9 = var8.getBuffer();
@@ -972,12 +1021,16 @@
 
          this.itemRenderer.renderItemOverlays(this.mc.fontRenderer, var5, var1, var2);
       }
    }
 
    public void updateTick() {
+      if (this.mc.world == null) {
+         TextureAnimations.updateAnimations();
+      }
+
       if (this.overlayMessageTime > 0) {
          this.overlayMessageTime--;
       }
 
       if (this.titlesTimer > 0) {
          this.titlesTimer--;
--- net/minecraft/client/gui/GuiIngameMenu.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiIngameMenu.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiKeyBindingList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiKeyBindingList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiLabel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiLabel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiLanguage.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiLanguage.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiListButton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiListButton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiListExtended.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiListExtended.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiListWorldSelection.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiListWorldSelection.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiListWorldSelectionEntry.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiListWorldSelectionEntry.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiLockIconButton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiLockIconButton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiMainMenu.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiMainMenu.java	Mon Aug 18 09:39:52 2025
@@ -1,18 +1,20 @@
 package net.minecraft.client.gui;
 
+import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.Runnables;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
+import java.util.List;
 import java.util.Random;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.Tessellator;
@@ -26,12 +28,15 @@
 import net.minecraft.util.StringUtils;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.world.WorldServerDemo;
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.CustomPanorama;
+import net.optifine.CustomPanoramaProperties;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.Project;
@@ -69,12 +74,14 @@
    private ResourceLocation backgroundTexture;
    private GuiButton realmsButton;
    private boolean hasCheckedForRealmsNotification;
    private GuiScreen realmsNotification;
    private int widthCopyright;
    private int widthCopyrightRest;
+   private GuiButton modButton;
+   private GuiScreen modUpdateNotification;
 
    public GuiMainMenu() {
       this.splashText = "missingno";
       IResource var1 = null;
 
       try {
@@ -110,29 +117,25 @@
    }
 
    private boolean areRealmsNotificationsEnabled() {
       return Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && this.realmsNotification != null;
    }
 
-   @Override
    public void updateScreen() {
       if (this.areRealmsNotificationsEnabled()) {
          this.realmsNotification.updateScreen();
       }
    }
 
-   @Override
    public boolean doesGuiPauseGame() {
       return false;
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
+   protected void keyTyped(char var1, int var2) throws IOException {
    }
 
-   @Override
    public void initGui() {
       this.viewportTexture = new DynamicTexture(256, 256);
       this.backgroundTexture = this.mc.getTextureManager().getDynamicTextureLocation("background", this.viewportTexture);
       this.widthCopyright = this.fontRenderer.getStringWidth("Copyright Mojang AB. Do not distribute!");
       this.widthCopyrightRest = this.width - this.widthCopyright - 2;
       Calendar var1 = Calendar.getInstance();
@@ -158,13 +161,13 @@
       this.buttonList.add(new GuiButtonLanguage(5, this.width / 2 - 124, var3 + 72 + 12));
       synchronized (this.threadLock) {
          this.openGLWarning1Width = this.fontRenderer.getStringWidth(this.openGLWarning1);
          this.openGLWarning2Width = this.fontRenderer.getStringWidth(this.openGLWarning2);
          int var5 = Math.max(this.openGLWarning1Width, this.openGLWarning2Width);
          this.openGLWarningX1 = (this.width - var5) / 2;
-         this.openGLWarningY1 = this.buttonList.get(0).y - 24;
+         this.openGLWarningY1 = ((GuiButton)this.buttonList.get(0)).y - 24;
          this.openGLWarningX2 = this.openGLWarningX1 + var5;
          this.openGLWarningY2 = this.openGLWarningY1 + 24;
       }
 
       this.mc.setConnectedToRealms(false);
       if (Minecraft.getMinecraft().gameSettings.getOptionOrdinalValue(GameSettings.Options.REALMS_NOTIFICATIONS) && !this.hasCheckedForRealmsNotification) {
@@ -174,32 +177,42 @@
       }
 
       if (this.areRealmsNotificationsEnabled()) {
          this.realmsNotification.setGuiSize(this.width, this.height);
          this.realmsNotification.initGui();
       }
+
+      if (Reflector.NotificationModUpdateScreen_init.exists()) {
+         this.modUpdateNotification = (GuiScreen)Reflector.call(Reflector.NotificationModUpdateScreen_init, new Object[]{this, this.modButton});
+      }
    }
 
    private void addSingleplayerMultiplayerButtons(int var1, int var2) {
       this.buttonList.add(new GuiButton(1, this.width / 2 - 100, var1, I18n.format("menu.singleplayer")));
       this.buttonList.add(new GuiButton(2, this.width / 2 - 100, var1 + var2 * 1, I18n.format("menu.multiplayer")));
-      this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 - 100, var1 + var2 * 2, I18n.format("menu.online")));
+      if (Reflector.GuiModList_Constructor.exists()) {
+         this.realmsButton = this.addButton(
+            new GuiButton(14, this.width / 2 + 2, var1 + var2 * 2, 98, 20, I18n.format("menu.online").replace("Minecraft", "").trim())
+         );
+         this.buttonList.add(this.modButton = new GuiButton(6, this.width / 2 - 100, var1 + var2 * 2, 98, 20, I18n.format("fml.menu.mods")));
+      } else {
+         this.realmsButton = this.addButton(new GuiButton(14, this.width / 2 - 100, var1 + var2 * 2, I18n.format("menu.online")));
+      }
    }
 
    private void addDemoButtons(int var1, int var2) {
       this.buttonList.add(new GuiButton(11, this.width / 2 - 100, var1, I18n.format("menu.playdemo")));
       this.buttonResetDemo = this.addButton(new GuiButton(12, this.width / 2 - 100, var1 + var2 * 1, I18n.format("menu.resetdemo")));
       ISaveFormat var3 = this.mc.getSaveLoader();
       WorldInfo var4 = var3.getWorldInfo("Demo_World");
       if (var4 == null) {
          this.buttonResetDemo.enabled = false;
       }
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
+   protected void actionPerformed(GuiButton var1) throws IOException {
       if (var1.id == 0) {
          this.mc.displayGuiScreen(new GuiOptions(this, this.mc.gameSettings));
       }
 
       if (var1.id == 5) {
          this.mc.displayGuiScreen(new GuiLanguage(this, this.mc.gameSettings, this.mc.getLanguageManager()));
@@ -218,12 +231,16 @@
       }
 
       if (var1.id == 4) {
          this.mc.shutdown();
       }
 
+      if (var1.id == 6 && Reflector.GuiModList_Constructor.exists()) {
+         this.mc.displayGuiScreen((GuiScreen)Reflector.newInstance(Reflector.GuiModList_Constructor, new Object[]{this}));
+      }
+
       if (var1.id == 11) {
          this.mc.launchIntegratedServer("Demo_World", "Demo_World", WorldServerDemo.DEMO_WORLD_SETTINGS);
       }
 
       if (var1.id == 12) {
          ISaveFormat var2 = this.mc.getSaveLoader();
@@ -246,13 +263,12 @@
 
    private void switchToRealms() {
       RealmsBridge var1 = new RealmsBridge();
       var1.switchToRealms(this);
    }
 
-   @Override
    public void confirmClicked(boolean var1, int var2) {
       if (var1 && var2 == 12) {
          ISaveFormat var6 = this.mc.getSaveLoader();
          var6.flushCache();
          var6.deleteWorldDirectory("Demo_World");
          this.mc.displayGuiScreen(this);
@@ -291,52 +307,62 @@
       GlStateManager.disableCull();
       GlStateManager.depthMask(false);
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       byte var6 = 8;
+      int var7 = 64;
+      CustomPanoramaProperties var8 = CustomPanorama.getCustomPanoramaProperties();
+      if (var8 != null) {
+         var7 = var8.getBlur1();
+      }
 
-      for (int var7 = 0; var7 < 64; var7++) {
+      for (int var9 = 0; var9 < var7; var9++) {
          GlStateManager.pushMatrix();
-         float var8 = (var7 % 8 / 8.0F - 0.5F) / 64.0F;
-         float var9 = (var7 / 8 / 8.0F - 0.5F) / 64.0F;
-         float var10 = 0.0F;
-         GlStateManager.translate(var8, var9, 0.0F);
+         float var10 = (var9 % 8 / 8.0F - 0.5F) / 64.0F;
+         float var11 = (var9 / 8 / 8.0F - 0.5F) / 64.0F;
+         float var12 = 0.0F;
+         GlStateManager.translate(var10, var11, 0.0F);
          GlStateManager.rotate(MathHelper.sin(this.panoramaTimer / 400.0F) * 25.0F + 20.0F, 1.0F, 0.0F, 0.0F);
          GlStateManager.rotate(-this.panoramaTimer * 0.1F, 0.0F, 1.0F, 0.0F);
 
-         for (int var11 = 0; var11 < 6; var11++) {
+         for (int var13 = 0; var13 < 6; var13++) {
             GlStateManager.pushMatrix();
-            if (var11 == 1) {
+            if (var13 == 1) {
                GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (var11 == 2) {
+            if (var13 == 2) {
                GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (var11 == 3) {
+            if (var13 == 3) {
                GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
             }
 
-            if (var11 == 4) {
+            if (var13 == 4) {
                GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
             }
 
-            if (var11 == 5) {
+            if (var13 == 5) {
                GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
             }
 
-            this.mc.getTextureManager().bindTexture(TITLE_PANORAMA_PATHS[var11]);
+            ResourceLocation[] var14 = TITLE_PANORAMA_PATHS;
+            if (var8 != null) {
+               var14 = var8.getPanoramaLocations();
+            }
+
+            this.mc.getTextureManager().bindTexture(var14[var13]);
             var5.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            int var12 = 255 / (var7 + 1);
-            float var13 = 0.0F;
-            var5.pos(-1.0, -1.0, 1.0).tex(0.0, 0.0).color(255, 255, 255, var12).endVertex();
-            var5.pos(1.0, -1.0, 1.0).tex(1.0, 0.0).color(255, 255, 255, var12).endVertex();
-            var5.pos(1.0, 1.0, 1.0).tex(1.0, 1.0).color(255, 255, 255, var12).endVertex();
-            var5.pos(-1.0, 1.0, 1.0).tex(0.0, 1.0).color(255, 255, 255, var12).endVertex();
+            int var15 = 255 / (var9 + 1);
+            float var16 = 0.0F;
+            var5.pos(-1.0, -1.0, 1.0).tex(0.0, 0.0).color(255, 255, 255, var15).endVertex();
+            var5.pos(1.0, -1.0, 1.0).tex(1.0, 0.0).color(255, 255, 255, var15).endVertex();
+            var5.pos(1.0, 1.0, 1.0).tex(1.0, 1.0).color(255, 255, 255, var15).endVertex();
+            var5.pos(-1.0, 1.0, 1.0).tex(0.0, 1.0).color(255, 255, 255, var15).endVertex();
             var4.draw();
             GlStateManager.popMatrix();
          }
 
          GlStateManager.popMatrix();
          GlStateManager.colorMask(true, true, true, false);
@@ -365,122 +391,171 @@
       GlStateManager.colorMask(true, true, true, false);
       Tessellator var1 = Tessellator.getInstance();
       BufferBuilder var2 = var1.getBuffer();
       var2.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
       GlStateManager.disableAlpha();
       byte var3 = 3;
+      int var4 = 3;
+      CustomPanoramaProperties var5 = CustomPanorama.getCustomPanoramaProperties();
+      if (var5 != null) {
+         var4 = var5.getBlur2();
+      }
 
-      for (int var4 = 0; var4 < 3; var4++) {
-         float var5 = 1.0F / (var4 + 1);
-         int var6 = this.width;
-         int var7 = this.height;
-         float var8 = (var4 - 1) / 256.0F;
-         var2.pos(var6, var7, this.zLevel).tex(0.0F + var8, 1.0).color(1.0F, 1.0F, 1.0F, var5).endVertex();
-         var2.pos(var6, 0.0, this.zLevel).tex(1.0F + var8, 1.0).color(1.0F, 1.0F, 1.0F, var5).endVertex();
-         var2.pos(0.0, 0.0, this.zLevel).tex(1.0F + var8, 0.0).color(1.0F, 1.0F, 1.0F, var5).endVertex();
-         var2.pos(0.0, var7, this.zLevel).tex(0.0F + var8, 0.0).color(1.0F, 1.0F, 1.0F, var5).endVertex();
+      for (int var6 = 0; var6 < var4; var6++) {
+         float var7 = 1.0F / (var6 + 1);
+         int var8 = this.width;
+         int var9 = this.height;
+         float var10 = (var6 - 1) / 256.0F;
+         var2.pos(var8, var9, this.e).tex(0.0F + var10, 1.0).color(1.0F, 1.0F, 1.0F, var7).endVertex();
+         var2.pos(var8, 0.0, this.e).tex(1.0F + var10, 1.0).color(1.0F, 1.0F, 1.0F, var7).endVertex();
+         var2.pos(0.0, 0.0, this.e).tex(1.0F + var10, 0.0).color(1.0F, 1.0F, 1.0F, var7).endVertex();
+         var2.pos(0.0, var9, this.e).tex(0.0F + var10, 0.0).color(1.0F, 1.0F, 1.0F, var7).endVertex();
       }
 
       var1.draw();
       GlStateManager.enableAlpha();
       GlStateManager.colorMask(true, true, true, true);
    }
 
    private void renderSkybox(int var1, int var2, float var3) {
       this.mc.getFramebuffer().unbindFramebuffer();
       GlStateManager.viewport(0, 0, 256, 256);
       this.drawPanorama(var1, var2, var3);
       this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
-      this.rotateAndBlurSkybox();
+      int var4 = 3;
+      CustomPanoramaProperties var5 = CustomPanorama.getCustomPanoramaProperties();
+      if (var5 != null) {
+         var4 = var5.getBlur3();
+      }
+
+      for (int var6 = 0; var6 < var4; var6++) {
+         this.rotateAndBlurSkybox();
+         this.rotateAndBlurSkybox();
+      }
+
       this.mc.getFramebuffer().bindFramebuffer(true);
       GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-      float var4 = 120.0F / (this.width > this.height ? this.width : this.height);
-      float var5 = this.height * var4 / 256.0F;
-      float var6 = this.width * var4 / 256.0F;
-      int var7 = this.width;
-      int var8 = this.height;
-      Tessellator var9 = Tessellator.getInstance();
-      BufferBuilder var10 = var9.getBuffer();
-      var10.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-      var10.pos(0.0, var8, this.zLevel).tex(0.5F - var5, 0.5F + var6).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      var10.pos(var7, var8, this.zLevel).tex(0.5F - var5, 0.5F - var6).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      var10.pos(var7, 0.0, this.zLevel).tex(0.5F + var5, 0.5F - var6).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      var10.pos(0.0, 0.0, this.zLevel).tex(0.5F + var5, 0.5F + var6).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
-      var9.draw();
+      float var13 = 120.0F / (this.width > this.height ? this.width : this.height);
+      float var7 = this.height * var13 / 256.0F;
+      float var8 = this.width * var13 / 256.0F;
+      int var9 = this.width;
+      int var10 = this.height;
+      Tessellator var11 = Tessellator.getInstance();
+      BufferBuilder var12 = var11.getBuffer();
+      var12.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      var12.pos(0.0, var10, this.e).tex(0.5F - var7, 0.5F + var8).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      var12.pos(var9, var10, this.e).tex(0.5F - var7, 0.5F - var8).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      var12.pos(var9, 0.0, this.e).tex(0.5F + var7, 0.5F - var8).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      var12.pos(0.0, 0.0, this.e).tex(0.5F + var7, 0.5F + var8).color(1.0F, 1.0F, 1.0F, 1.0F).endVertex();
+      var11.draw();
    }
 
-   @Override
    public void drawScreen(int var1, int var2, float var3) {
       this.panoramaTimer += var3;
       GlStateManager.disableAlpha();
       this.renderSkybox(var1, var2, var3);
       GlStateManager.enableAlpha();
       short var4 = 274;
       int var5 = this.width / 2 - 137;
       byte var6 = 30;
-      this.drawGradientRect(0, 0, this.width, this.height, -2130706433, 16777215);
-      this.drawGradientRect(0, 0, this.width, this.height, 0, Integer.MIN_VALUE);
+      int var7 = -2130706433;
+      int var8 = 16777215;
+      int var9 = 0;
+      int var10 = Integer.MIN_VALUE;
+      CustomPanoramaProperties var11 = CustomPanorama.getCustomPanoramaProperties();
+      if (var11 != null) {
+         var7 = var11.getOverlay1Top();
+         var8 = var11.getOverlay1Bottom();
+         var9 = var11.getOverlay2Top();
+         var10 = var11.getOverlay2Bottom();
+      }
+
+      if (var7 != 0 || var8 != 0) {
+         this.a(0, 0, this.width, this.height, var7, var8);
+      }
+
+      if (var9 != 0 || var10 != 0) {
+         this.a(0, 0, this.width, this.height, var9, var10);
+      }
+
       this.mc.getTextureManager().bindTexture(MINECRAFT_TITLE_TEXTURES);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       if (this.minceraftRoll < 1.0E-4) {
-         this.drawTexturedModalRect(var5 + 0, 30, 0, 0, 99, 44);
-         this.drawTexturedModalRect(var5 + 99, 30, 129, 0, 27, 44);
-         this.drawTexturedModalRect(var5 + 99 + 26, 30, 126, 0, 3, 44);
-         this.drawTexturedModalRect(var5 + 99 + 26 + 3, 30, 99, 0, 26, 44);
-         this.drawTexturedModalRect(var5 + 155, 30, 0, 45, 155, 44);
+         this.b(var5 + 0, 30, 0, 0, 99, 44);
+         this.b(var5 + 99, 30, 129, 0, 27, 44);
+         this.b(var5 + 99 + 26, 30, 126, 0, 3, 44);
+         this.b(var5 + 99 + 26 + 3, 30, 99, 0, 26, 44);
+         this.b(var5 + 155, 30, 0, 45, 155, 44);
       } else {
-         this.drawTexturedModalRect(var5 + 0, 30, 0, 0, 155, 44);
-         this.drawTexturedModalRect(var5 + 155, 30, 0, 45, 155, 44);
+         this.b(var5 + 0, 30, 0, 0, 155, 44);
+         this.b(var5 + 155, 30, 0, 45, 155, 44);
       }
 
       this.mc.getTextureManager().bindTexture(field_194400_H);
-      drawModalRectWithCustomSizedTexture(var5 + 88, 67, 0.0F, 0.0F, 98, 14, 128.0F, 16.0F);
+      a(var5 + 88, 67, 0.0F, 0.0F, 98, 14, 128.0F, 16.0F);
+      if (Reflector.ForgeHooksClient_renderMainMenu.exists()) {
+         this.splashText = Reflector.callString(
+            Reflector.ForgeHooksClient_renderMainMenu, new Object[]{this, this.fontRenderer, this.width, this.height, this.splashText}
+         );
+      }
+
       GlStateManager.pushMatrix();
       GlStateManager.translate((float)(this.width / 2 + 90), 70.0F, 0.0F);
       GlStateManager.rotate(-20.0F, 0.0F, 0.0F, 1.0F);
-      float var7 = 1.8F - MathHelper.abs(MathHelper.sin((float)(Minecraft.getSystemTime() % 1000L) / 1000.0F * (float) (Math.PI * 2)) * 0.1F);
-      var7 = var7 * 100.0F / (this.fontRenderer.getStringWidth(this.splashText) + 32);
-      GlStateManager.scale(var7, var7, var7);
-      this.drawCenteredString(this.fontRenderer, this.splashText, 0, -8, -256);
+      float var12 = 1.8F - MathHelper.abs(MathHelper.sin((float)(Minecraft.getSystemTime() % 1000L) / 1000.0F * (float) (Math.PI * 2)) * 0.1F);
+      var12 = var12 * 100.0F / (this.fontRenderer.getStringWidth(this.splashText) + 32);
+      GlStateManager.scale(var12, var12, var12);
+      this.a(this.fontRenderer, this.splashText, 0, -8, -256);
       GlStateManager.popMatrix();
-      String var8 = "Minecraft 1.12.2";
+      String var13 = "Minecraft 1.12.2";
       if (this.mc.isDemo()) {
-         var8 = var8 + " Demo";
+         var13 = var13 + " Demo";
       } else {
-         var8 = var8 + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType());
+         var13 = var13 + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType());
       }
 
-      this.drawString(this.fontRenderer, var8, 2, this.height - 10, -1);
-      this.drawString(this.fontRenderer, "Copyright Mojang AB. Do not distribute!", this.widthCopyrightRest, this.height - 10, -1);
+      if (Reflector.FMLCommonHandler_getBrandings.exists()) {
+         Object var14 = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         List var15 = Lists.reverse((List)Reflector.call(var14, Reflector.FMLCommonHandler_getBrandings, new Object[]{true}));
+
+         for (int var16 = 0; var16 < var15.size(); var16++) {
+            String var17 = (String)var15.get(var16);
+            if (!Strings.isNullOrEmpty(var17)) {
+               this.c(this.fontRenderer, var17, 2, this.height - (10 + var16 * (this.fontRenderer.FONT_HEIGHT + 1)), 16777215);
+            }
+         }
+      } else {
+         this.c(this.fontRenderer, var13, 2, this.height - 10, -1);
+      }
+
+      this.c(this.fontRenderer, "Copyright Mojang AB. Do not distribute!", this.widthCopyrightRest, this.height - 10, -1);
       if (var1 > this.widthCopyrightRest
          && var1 < this.widthCopyrightRest + this.widthCopyright
          && var2 > this.height - 10
          && var2 < this.height
          && Mouse.isInsideWindow()) {
-         drawRect(this.widthCopyrightRest, this.height - 1, this.widthCopyrightRest + this.widthCopyright, this.height, -1);
+         a(this.widthCopyrightRest, this.height - 1, this.widthCopyrightRest + this.widthCopyright, this.height, -1);
       }
 
       if (this.openGLWarning1 != null && !this.openGLWarning1.isEmpty()) {
-         drawRect(this.openGLWarningX1 - 2, this.openGLWarningY1 - 2, this.openGLWarningX2 + 2, this.openGLWarningY2 - 1, 1428160512);
-         this.drawString(this.fontRenderer, this.openGLWarning1, this.openGLWarningX1, this.openGLWarningY1, -1);
-         this.drawString(this.fontRenderer, this.openGLWarning2, (this.width - this.openGLWarning2Width) / 2, this.buttonList.get(0).y - 12, -1);
+         a(this.openGLWarningX1 - 2, this.openGLWarningY1 - 2, this.openGLWarningX2 + 2, this.openGLWarningY2 - 1, 1428160512);
+         this.c(this.fontRenderer, this.openGLWarning1, this.openGLWarningX1, this.openGLWarningY1, -1);
+         this.c(this.fontRenderer, this.openGLWarning2, (this.width - this.openGLWarning2Width) / 2, ((GuiButton)this.buttonList.get(0)).y - 12, -1);
       }
 
       super.drawScreen(var1, var2, var3);
       if (this.areRealmsNotificationsEnabled()) {
          this.realmsNotification.drawScreen(var1, var2, var3);
       }
+
+      if (this.modUpdateNotification != null) {
+         this.modUpdateNotification.drawScreen(var1, var2, var3);
+      }
    }
 
-   @Override
-   protected void mouseClicked(int var1, int var2, int var3) {
+   protected void mouseClicked(int var1, int var2, int var3) throws IOException {
       super.mouseClicked(var1, var2, var3);
       synchronized (this.threadLock) {
          if (!this.openGLWarning1.isEmpty()
             && !StringUtils.isNullOrEmpty(this.openGLWarningLink)
             && var1 >= this.openGLWarningX1
             && var1 <= this.openGLWarningX2
@@ -498,13 +573,12 @@
 
       if (var1 > this.widthCopyrightRest && var1 < this.widthCopyrightRest + this.widthCopyright && var2 > this.height - 10 && var2 < this.height) {
          this.mc.displayGuiScreen(new GuiWinGame(false, Runnables.doNothing()));
       }
    }
 
-   @Override
    public void onGuiClosed() {
       if (this.realmsNotification != null) {
          this.realmsNotification.onGuiClosed();
       }
    }
 }
--- net/minecraft/client/gui/GuiMemoryErrorScreen.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiMemoryErrorScreen.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiMerchant.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiMerchant.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiMultiplayer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiMultiplayer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiNewChat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiNewChat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiOptionButton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiOptionButton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiOptions.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiOptions.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiOptionSlider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiOptionSlider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiOptionsRowList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiOptionsRowList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiOverlayDebug.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiOverlayDebug.java	Mon Aug 18 09:39:52 2025
@@ -1,38 +1,49 @@
 package net.minecraft.client.gui;
 
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
 import com.google.common.collect.UnmodifiableIterator;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
 import net.minecraft.block.Block;
 import net.minecraft.block.properties.IProperty;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.ClientBrandRetriever;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.EnumFacing;
-import net.minecraft.util.FrameTimer;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.RayTraceResult.Type;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumSkyBlock;
 import net.minecraft.world.WorldType;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.SmartAnimations;
+import net.optifine.TextureAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.util.MemoryMonitor;
+import net.optifine.util.NativeMemory;
 import org.lwjgl.opengl.Display;
 
 public class GuiOverlayDebug extends Gui {
    private final Minecraft mc;
    private final FontRenderer fontRenderer;
+   private String debugOF = null;
+   private List<String> debugInfoLeft = null;
+   private List<String> debugInfoRight = null;
+   private long updateInfoLeftTimeMs = 0L;
+   private long updateInfoRightTimeMs = 0L;
 
    public GuiOverlayDebug(Minecraft var1) {
       this.mc = var1;
       this.fontRenderer = var1.fontRenderer;
    }
 
@@ -47,21 +58,26 @@
       }
 
       this.mc.profiler.endSection();
    }
 
    protected void renderDebugInfoLeft() {
-      List var1 = this.call();
-      var1.add("");
-      var1.add(
-         "Debug: Pie [shift]: "
-            + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden")
-            + " FPS [alt]: "
-            + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")
-      );
-      var1.add("For help: press F3 + Q");
+      List var1 = this.debugInfoLeft;
+      if (var1 == null || System.currentTimeMillis() > this.updateInfoLeftTimeMs) {
+         var1 = this.call();
+         var1.add("");
+         var1.add(
+            "Debug: Pie [shift]: "
+               + (this.mc.gameSettings.showDebugProfilerChart ? "visible" : "hidden")
+               + " FPS [alt]: "
+               + (this.mc.gameSettings.showLagometer ? "visible" : "hidden")
+         );
+         var1.add("For help: press F3 + Q");
+         this.debugInfoLeft = var1;
+         this.updateInfoLeftTimeMs = System.currentTimeMillis() + 100L;
+      }
 
       for (int var2 = 0; var2 < var1.size(); var2++) {
          String var3 = (String)var1.get(var2);
          if (!Strings.isNullOrEmpty(var3)) {
             int var4 = this.fontRenderer.FONT_HEIGHT;
             int var5 = this.fontRenderer.getStringWidth(var3);
@@ -71,13 +87,18 @@
             this.fontRenderer.drawString(var3, 2, var7, 14737632);
          }
       }
    }
 
    protected void renderDebugInfoRight(ScaledResolution var1) {
-      List var2 = this.getDebugInfoRight();
+      List var2 = this.debugInfoRight;
+      if (var2 == null || System.currentTimeMillis() > this.updateInfoRightTimeMs) {
+         var2 = this.getDebugInfoRight();
+         this.debugInfoRight = var2;
+         this.updateInfoRightTimeMs = System.currentTimeMillis() + 100L;
+      }
 
       for (int var3 = 0; var3 < var2.size(); var3++) {
          String var4 = (String)var2.get(var3);
          if (!Strings.isNullOrEmpty(var4)) {
             int var5 = this.fontRenderer.FONT_HEIGHT;
             int var6 = this.fontRenderer.getStringWidth(var4);
@@ -90,118 +111,165 @@
    }
 
    protected List<String> call() {
       BlockPos var1 = new BlockPos(
          this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().getEntityBoundingBox().minY, this.mc.getRenderViewEntity().posZ
       );
+      if (this.mc.debug != this.debugOF) {
+         StringBuffer var2 = new StringBuffer(this.mc.debug);
+         int var3 = Config.getFpsMin();
+         int var4 = this.mc.debug.indexOf(" fps ");
+         if (var4 >= 0) {
+            var2.insert(var4, "/" + var3);
+         }
+
+         if (Config.isSmoothFps()) {
+            var2.append(" sf");
+         }
+
+         if (Config.isFastRender()) {
+            var2.append(" fr");
+         }
+
+         if (Config.isAnisotropicFiltering()) {
+            var2.append(" af");
+         }
+
+         if (Config.isAntialiasing()) {
+            var2.append(" aa");
+         }
+
+         if (Config.isRenderRegions()) {
+            var2.append(" reg");
+         }
+
+         if (Config.isShaders()) {
+            var2.append(" sh");
+         }
+
+         this.mc.debug = var2.toString();
+         this.debugOF = this.mc.debug;
+      }
+
+      StringBuilder var13 = new StringBuilder();
+      TextureMap var14 = Config.getTextureMap();
+      var13.append(", A: ");
+      if (SmartAnimations.isActive()) {
+         var13.append(var14.getCountAnimationsActive() + TextureAnimations.getCountAnimationsActive());
+         var13.append("/");
+      }
+
+      var13.append(var14.getCountAnimations() + TextureAnimations.getCountAnimations());
+      String var15 = var13.toString();
       if (this.mc.isReducedDebug()) {
          return Lists.newArrayList(
             new String[]{
                "Minecraft 1.12.2 (" + this.mc.getVersion() + "/" + ClientBrandRetriever.getClientModName() + ")",
                this.mc.debug,
                this.mc.renderGlobal.getDebugInfoRenders(),
                this.mc.renderGlobal.getDebugInfoEntities(),
-               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(),
+               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + var15,
                this.mc.world.getProviderName(),
                "",
                String.format("Chunk-relative: %d %d %d", var1.getX() & 15, var1.getY() & 15, var1.getZ() & 15)
             }
          );
       } else {
-         Entity var2 = this.mc.getRenderViewEntity();
-         EnumFacing var3 = var2.getHorizontalFacing();
-         String var4 = "Invalid";
-         switch (var3) {
+         Entity var5 = this.mc.getRenderViewEntity();
+         EnumFacing var6 = var5.getHorizontalFacing();
+         String var7 = "Invalid";
+         switch (var6) {
             case NORTH:
-               var4 = "Towards negative Z";
+               var7 = "Towards negative Z";
                break;
             case SOUTH:
-               var4 = "Towards positive Z";
+               var7 = "Towards positive Z";
                break;
             case WEST:
-               var4 = "Towards negative X";
+               var7 = "Towards negative X";
                break;
             case EAST:
-               var4 = "Towards positive X";
+               var7 = "Towards positive X";
          }
 
-         ArrayList var5 = Lists.newArrayList(
+         ArrayList var8 = Lists.newArrayList(
             new String[]{
                "Minecraft 1.12.2 ("
                   + this.mc.getVersion()
                   + "/"
                   + ClientBrandRetriever.getClientModName()
                   + ("release".equalsIgnoreCase(this.mc.getVersionType()) ? "" : "/" + this.mc.getVersionType())
                   + ")",
                this.mc.debug,
                this.mc.renderGlobal.getDebugInfoRenders(),
                this.mc.renderGlobal.getDebugInfoEntities(),
-               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities(),
+               "P: " + this.mc.effectRenderer.getStatistics() + ". T: " + this.mc.world.getDebugLoadedEntities() + var15,
                this.mc.world.getProviderName(),
                "",
                String.format(
                   "XYZ: %.3f / %.5f / %.3f",
                   this.mc.getRenderViewEntity().posX,
                   this.mc.getRenderViewEntity().getEntityBoundingBox().minY,
                   this.mc.getRenderViewEntity().posZ
                ),
                String.format("Block: %d %d %d", var1.getX(), var1.getY(), var1.getZ()),
                String.format(
                   "Chunk: %d %d %d in %d %d %d", var1.getX() & 15, var1.getY() & 15, var1.getZ() & 15, var1.getX() >> 4, var1.getY() >> 4, var1.getZ() >> 4
                ),
-               String.format("Facing: %s (%s) (%.1f / %.1f)", var3, var4, MathHelper.wrapDegrees(var2.rotationYaw), MathHelper.wrapDegrees(var2.rotationPitch))
+               String.format("Facing: %s (%s) (%.1f / %.1f)", var6, var7, MathHelper.wrapDegrees(var5.rotationYaw), MathHelper.wrapDegrees(var5.rotationPitch))
             }
          );
          if (this.mc.world != null) {
-            Chunk var6 = this.mc.world.getChunk(var1);
+            Chunk var9 = this.mc.world.getChunk(var1);
             if (!this.mc.world.isBlockLoaded(var1) || var1.getY() < 0 || var1.getY() >= 256) {
-               var5.add("Outside of world...");
-            } else if (!var6.isEmpty()) {
-               var5.add("Biome: " + var6.getBiome(var1, this.mc.world.getBiomeProvider()).getBiomeName());
-               var5.add(
+               var8.add("Outside of world...");
+            } else if (!var9.isEmpty()) {
+               var8.add("Biome: " + var9.getBiome(var1, this.mc.world.getBiomeProvider()).getBiomeName());
+               var8.add(
                   "Light: "
-                     + var6.getLightSubtracted(var1, 0)
+                     + var9.getLightSubtracted(var1, 0)
                      + " ("
-                     + var6.getLightFor(EnumSkyBlock.SKY, var1)
+                     + var9.getLightFor(EnumSkyBlock.SKY, var1)
                      + " sky, "
-                     + var6.getLightFor(EnumSkyBlock.BLOCK, var1)
+                     + var9.getLightFor(EnumSkyBlock.BLOCK, var1)
                      + " block)"
                );
-               DifficultyInstance var7 = this.mc.world.getDifficultyForLocation(var1);
+               DifficultyInstance var10 = this.mc.world.getDifficultyForLocation(var1);
                if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null) {
-                  EntityPlayerMP var8 = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.getUniqueID());
-                  if (var8 != null) {
-                     var7 = var8.world.getDifficultyForLocation(new BlockPos(var8));
+                  EntityPlayerMP var11 = this.mc.getIntegratedServer().getPlayerList().getPlayerByUUID(this.mc.player.getUniqueID());
+                  if (var11 != null) {
+                     DifficultyInstance var12 = this.mc.getIntegratedServer().getDifficultyAsync(var11.world, new BlockPos(var11));
+                     if (var12 != null) {
+                        var10 = var12;
+                     }
                   }
                }
 
-               var5.add(
+               var8.add(
                   String.format(
                      "Local Difficulty: %.2f // %.2f (Day %d)",
-                     var7.getAdditionalDifficulty(),
-                     var7.getClampedAdditionalDifficulty(),
+                     var10.getAdditionalDifficulty(),
+                     var10.getClampedAdditionalDifficulty(),
                      this.mc.world.getWorldTime() / 24000L
                   )
                );
             } else {
-               var5.add("Waiting for chunk...");
+               var8.add("Waiting for chunk...");
             }
          }
 
          if (this.mc.entityRenderer != null && this.mc.entityRenderer.isShaderActive()) {
-            var5.add("Shader: " + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
+            var8.add("Shader: " + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
          }
 
-         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null
-            )
-          {
-            BlockPos var9 = this.mc.objectMouseOver.getBlockPos();
-            var5.add(String.format("Looking at: %d %d %d", var9.getX(), var9.getY(), var9.getZ()));
+         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
+            BlockPos var16 = this.mc.objectMouseOver.getBlockPos();
+            var8.add(String.format("Looking at: %d %d %d", var16.getX(), var16.getY(), var16.getZ()));
          }
 
-         return var5;
+         return var8;
       }
    }
 
    protected <T extends Comparable<T>> List<String> getDebugInfoRight() {
       long var1 = Runtime.getRuntime().maxMemory();
       long var3 = Runtime.getRuntime().totalMemory();
@@ -217,80 +285,57 @@
             "",
             String.format("Display: %dx%d (%s)", Display.getWidth(), Display.getHeight(), GlStateManager.glGetString(7936)),
             GlStateManager.glGetString(7937),
             GlStateManager.glGetString(7938)
          }
       );
+      long var10 = NativeMemory.getBufferAllocated();
+      long var12 = NativeMemory.getBufferMaximum();
+      String var14 = "Native: " + bytesToMb(var10) + "/" + bytesToMb(var12) + "MB";
+      var9.add(4, var14);
+      var9.set(5, "GC: " + MemoryMonitor.getAllocationRateMb() + "MB/s");
+      if (Reflector.FMLCommonHandler_getBrandings.exists()) {
+         Object var15 = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         var9.add("");
+         var9.addAll((Collection)Reflector.call(var15, Reflector.FMLCommonHandler_getBrandings, new Object[]{false}));
+      }
+
       if (this.mc.isReducedDebug()) {
          return var9;
       } else {
-         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null
-            )
-          {
-            BlockPos var10 = this.mc.objectMouseOver.getBlockPos();
-            IBlockState var11 = this.mc.world.getBlockState(var10);
+         if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
+            BlockPos var22 = this.mc.objectMouseOver.getBlockPos();
+            IBlockState var16 = this.mc.world.getBlockState(var22);
             if (this.mc.world.getWorldType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
-               var11 = var11.getActualState(this.mc.world, var10);
+               var16 = var16.c(this.mc.world, var22);
             }
 
             var9.add("");
-            var9.add(String.valueOf(Block.REGISTRY.getNameForObject(var11.getBlock())));
-            UnmodifiableIterator var12 = var11.getProperties().entrySet().iterator();
+            var9.add(String.valueOf(Block.REGISTRY.getNameForObject(var16.getBlock())));
+            UnmodifiableIterator var19 = var16.getProperties().entrySet().iterator();
 
-            while (var12.hasNext()) {
-               Entry var13 = (Entry)var12.next();
-               IProperty var14 = (IProperty)var13.getKey();
-               Comparable var15 = (Comparable)var13.getValue();
-               Object var16 = var14.getName((T)var15);
-               if (Boolean.TRUE.equals(var15)) {
-                  var16 = TextFormatting.GREEN + var16;
-               } else if (Boolean.FALSE.equals(var15)) {
-                  var16 = TextFormatting.RED + var16;
+            while (var19.hasNext()) {
+               Entry var20 = (Entry)var19.next();
+               IProperty var17 = (IProperty)var20.getKey();
+               Comparable var21 = (Comparable)var20.getValue();
+               Object var18 = var17.getName(var21);
+               if (Boolean.TRUE.equals(var21)) {
+                  var18 = TextFormatting.GREEN + var18;
+               } else if (Boolean.FALSE.equals(var21)) {
+                  var18 = TextFormatting.RED + var18;
                }
 
-               var9.add(var14.getName() + ": " + var16);
+               var9.add(var17.getName() + ": " + var18);
             }
          }
 
          return var9;
       }
    }
 
    private void renderLagometer() {
-      GlStateManager.disableDepth();
-      FrameTimer var1 = this.mc.getFrameTimer();
-      int var2 = var1.getLastIndex();
-      int var3 = var1.getIndex();
-      long[] var4 = var1.getFrames();
-      ScaledResolution var5 = new ScaledResolution(this.mc);
-      int var6 = var2;
-      int var7 = 0;
-      drawRect(0, var5.getScaledHeight() - 60, 240, var5.getScaledHeight(), -1873784752);
-
-      while (var6 != var3) {
-         int var8 = var1.getLagometerValue(var4[var6], 30);
-         int var9 = this.getFrameColor(MathHelper.clamp(var8, 0, 60), 0, 30, 60);
-         this.drawVerticalLine(var7, var5.getScaledHeight(), var5.getScaledHeight() - var8, var9);
-         var7++;
-         var6 = var1.parseIndex(var6 + 1);
-      }
-
-      drawRect(1, var5.getScaledHeight() - 30 + 1, 14, var5.getScaledHeight() - 30 + 10, -1873784752);
-      this.fontRenderer.drawString("60", 2, var5.getScaledHeight() - 30 + 2, 14737632);
-      this.drawHorizontalLine(0, 239, var5.getScaledHeight() - 30, -1);
-      drawRect(1, var5.getScaledHeight() - 60 + 1, 14, var5.getScaledHeight() - 60 + 10, -1873784752);
-      this.fontRenderer.drawString("30", 2, var5.getScaledHeight() - 60 + 2, 14737632);
-      this.drawHorizontalLine(0, 239, var5.getScaledHeight() - 60, -1);
-      this.drawHorizontalLine(0, 239, var5.getScaledHeight() - 1, -1);
-      this.drawVerticalLine(0, var5.getScaledHeight() - 60, var5.getScaledHeight(), -1);
-      this.drawVerticalLine(239, var5.getScaledHeight() - 60, var5.getScaledHeight(), -1);
-      if (this.mc.gameSettings.limitFramerate <= 120) {
-         this.drawHorizontalLine(0, 239, var5.getScaledHeight() - 60 + this.mc.gameSettings.limitFramerate / 2, -16711681);
-      }
-
-      GlStateManager.enableDepth();
    }
 
    private int getFrameColor(int var1, int var2, int var3, int var4) {
       return var1 < var3 ? this.blendColors(-16711936, -256, (float)var1 / var3) : this.blendColors(-256, -65536, (float)(var1 - var3) / (var4 - var3));
    }
 
--- net/minecraft/client/gui/GuiPageButtonList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiPageButtonList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiPlayerTabOverlay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiPlayerTabOverlay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiRepair.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiRepair.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiResourcePackAvailable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiResourcePackAvailable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiResourcePackList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiResourcePackList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiResourcePackSelected.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiResourcePackSelected.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreen.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreen.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenAddServer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenAddServer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenBook.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenBook.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenCustomizePresets.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenCustomizePresets.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenDemo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenDemo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenOptionsSounds.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenOptionsSounds.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenRealmsProxy.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenRealmsProxy.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenResourcePacks.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenResourcePacks.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenServerList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenServerList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiScreenWorking.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiScreenWorking.java	Mon Aug 18 09:39:52 2025
@@ -1,51 +1,56 @@
 package net.minecraft.client.gui;
 
 import net.minecraft.util.IProgressUpdate;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
 
 public class GuiScreenWorking extends GuiScreen implements IProgressUpdate {
    private String title = "";
    private String stage = "";
    private int progress;
    private boolean doneWorking;
+   private CustomLoadingScreen customLoadingScreen = CustomLoadingScreens.getCustomLoadingScreen();
 
-   @Override
    public void displaySavingString(String var1) {
       this.resetProgressAndMessage(var1);
    }
 
-   @Override
    public void resetProgressAndMessage(String var1) {
       this.title = var1;
       this.displayLoadingString("Working...");
    }
 
-   @Override
    public void displayLoadingString(String var1) {
       this.stage = var1;
       this.setLoadingProgress(0);
    }
 
-   @Override
    public void setLoadingProgress(int var1) {
       this.progress = var1;
    }
 
-   @Override
    public void setDoneWorking() {
       this.doneWorking = true;
    }
 
-   @Override
    public void drawScreen(int var1, int var2, float var3) {
       if (this.doneWorking) {
          if (!this.mc.isConnectedToRealms()) {
-            this.mc.displayGuiScreen(null);
+            this.mc.displayGuiScreen((GuiScreen)null);
          }
       } else {
-         this.drawDefaultBackground();
-         this.drawCenteredString(this.fontRenderer, this.title, this.width / 2, 70, 16777215);
-         this.drawCenteredString(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 16777215);
+         if (this.customLoadingScreen != null && this.mc.world == null) {
+            this.customLoadingScreen.drawBackground(this.width, this.height);
+         } else {
+            this.drawDefaultBackground();
+         }
+
+         if (this.progress > 0) {
+            this.a(this.fontRenderer, this.title, this.width / 2, 70, 16777215);
+            this.a(this.fontRenderer, this.stage + " " + this.progress + "%", this.width / 2, 90, 16777215);
+         }
+
          super.drawScreen(var1, var2, var3);
       }
    }
 }
--- net/minecraft/client/gui/GuiShareToLan.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiShareToLan.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSimpleScrolledSelectionListProxy.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSimpleScrolledSelectionListProxy.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSleepMP.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSleepMP.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSlider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSlider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSlot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSlot.java	Mon Aug 18 09:39:52 2025
@@ -149,28 +149,20 @@
          int var5 = var4 + 6;
          this.bindAmountScrolled();
          GlStateManager.disableLighting();
          GlStateManager.disableFog();
          Tessellator var6 = Tessellator.getInstance();
          BufferBuilder var7 = var6.getBuffer();
-         this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         float var8 = 32.0F;
-         var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         var7.pos(this.left, this.bottom, 0.0).tex(this.left / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         var7.pos(this.right, this.bottom, 0.0).tex(this.right / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         var7.pos(this.right, this.top, 0.0).tex(this.right / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         var7.pos(this.left, this.top, 0.0).tex(this.left / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
-         var6.draw();
-         int var9 = this.left + this.width / 2 - this.getListWidth() / 2 + 2;
-         int var10 = this.top + 4 - (int)this.amountScrolled;
+         this.drawContainerBackground(var6);
+         int var8 = this.left + this.width / 2 - this.getListWidth() / 2 + 2;
+         int var9 = this.top + 4 - (int)this.amountScrolled;
          if (this.hasListHeader) {
-            this.drawListHeader(var9, var10, var6);
+            this.drawListHeader(var8, var9, var6);
          }
 
-         this.drawSelectionBox(var9, var10, var1, var2, var3);
+         this.drawSelectionBox(var8, var9, var1, var2, var3);
          GlStateManager.disableDepth();
          this.overlayBackground(0, this.top, 255, 255);
          this.overlayBackground(this.bottom, this.height, 255, 255);
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
@@ -178,51 +170,51 @@
             GlStateManager.SourceFactor.ZERO,
             GlStateManager.DestFactor.ONE
          );
          GlStateManager.disableAlpha();
          GlStateManager.shadeModel(7425);
          GlStateManager.disableTexture2D();
-         byte var11 = 4;
+         byte var10 = 4;
          var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
          var7.pos(this.left, this.top + 4, 0.0).tex(0.0, 1.0).color(0, 0, 0, 0).endVertex();
          var7.pos(this.right, this.top + 4, 0.0).tex(1.0, 1.0).color(0, 0, 0, 0).endVertex();
          var7.pos(this.right, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
          var7.pos(this.left, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
          var6.draw();
          var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
          var7.pos(this.left, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
          var7.pos(this.right, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
          var7.pos(this.right, this.bottom - 4, 0.0).tex(1.0, 0.0).color(0, 0, 0, 0).endVertex();
          var7.pos(this.left, this.bottom - 4, 0.0).tex(0.0, 0.0).color(0, 0, 0, 0).endVertex();
          var6.draw();
-         int var12 = this.getMaxScroll();
-         if (var12 > 0) {
-            int var13 = (this.bottom - this.top) * (this.bottom - this.top) / this.getContentHeight();
-            var13 = MathHelper.clamp(var13, 32, this.bottom - this.top - 8);
-            int var14 = (int)this.amountScrolled * (this.bottom - this.top - var13) / var12 + this.top;
-            if (var14 < this.top) {
-               var14 = this.top;
+         int var11 = this.getMaxScroll();
+         if (var11 > 0) {
+            int var12 = (this.bottom - this.top) * (this.bottom - this.top) / this.getContentHeight();
+            var12 = MathHelper.clamp(var12, 32, this.bottom - this.top - 8);
+            int var13 = (int)this.amountScrolled * (this.bottom - this.top - var12) / var11 + this.top;
+            if (var13 < this.top) {
+               var13 = this.top;
             }
 
             var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
             var7.pos(var4, this.bottom, 0.0).tex(0.0, 1.0).color(0, 0, 0, 255).endVertex();
             var7.pos(var5, this.bottom, 0.0).tex(1.0, 1.0).color(0, 0, 0, 255).endVertex();
             var7.pos(var5, this.top, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
             var7.pos(var4, this.top, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
             var6.draw();
             var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            var7.pos(var4, var14 + var13, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
-            var7.pos(var5, var14 + var13, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
-            var7.pos(var5, var14, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
-            var7.pos(var4, var14, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
+            var7.pos(var4, var13 + var12, 0.0).tex(0.0, 1.0).color(128, 128, 128, 255).endVertex();
+            var7.pos(var5, var13 + var12, 0.0).tex(1.0, 1.0).color(128, 128, 128, 255).endVertex();
+            var7.pos(var5, var13, 0.0).tex(1.0, 0.0).color(128, 128, 128, 255).endVertex();
+            var7.pos(var4, var13, 0.0).tex(0.0, 0.0).color(128, 128, 128, 255).endVertex();
             var6.draw();
             var7.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            var7.pos(var4, var14 + var13 - 1, 0.0).tex(0.0, 1.0).color(192, 192, 192, 255).endVertex();
-            var7.pos(var5 - 1, var14 + var13 - 1, 0.0).tex(1.0, 1.0).color(192, 192, 192, 255).endVertex();
-            var7.pos(var5 - 1, var14, 0.0).tex(1.0, 0.0).color(192, 192, 192, 255).endVertex();
-            var7.pos(var4, var14, 0.0).tex(0.0, 0.0).color(192, 192, 192, 255).endVertex();
+            var7.pos(var4, var13 + var12 - 1, 0.0).tex(0.0, 1.0).color(192, 192, 192, 255).endVertex();
+            var7.pos(var5 - 1, var13 + var12 - 1, 0.0).tex(1.0, 1.0).color(192, 192, 192, 255).endVertex();
+            var7.pos(var5 - 1, var13, 0.0).tex(1.0, 0.0).color(192, 192, 192, 255).endVertex();
+            var7.pos(var4, var13, 0.0).tex(0.0, 0.0).color(192, 192, 192, 255).endVertex();
             var6.draw();
          }
 
          this.renderDecorations(var1, var2);
          GlStateManager.enableTexture2D();
          GlStateManager.shadeModel(7424);
@@ -346,13 +338,15 @@
             var8.pos(var13 - 1, var10 - 1, 0.0).tex(1.0, 0.0).color(0, 0, 0, 255).endVertex();
             var8.pos(var12 + 1, var10 - 1, 0.0).tex(0.0, 0.0).color(0, 0, 0, 255).endVertex();
             var7.draw();
             GlStateManager.enableTexture2D();
          }
 
-         this.drawSlot(var9, var1, var10, var11, var3, var4, var5);
+         if (!(this instanceof GuiResourcePackList) || var10 >= this.top - this.slotHeight && var10 <= this.bottom) {
+            this.drawSlot(var9, var1, var10, var11, var3, var4, var5);
+         }
       }
    }
 
    protected int getScrollBarX() {
       return this.width / 2 + 124;
    }
@@ -375,8 +369,21 @@
       this.left = var1;
       this.right = var1 + this.width;
    }
 
    public int getSlotHeight() {
       return this.slotHeight;
+   }
+
+   protected void drawContainerBackground(Tessellator var1) {
+      BufferBuilder var2 = var1.getBuffer();
+      this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
+      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+      float var3 = 32.0F;
+      var2.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+      var2.pos(this.left, this.bottom, 0.0).tex(this.left / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      var2.pos(this.right, this.bottom, 0.0).tex(this.right / 32.0F, (this.bottom + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      var2.pos(this.right, this.top, 0.0).tex(this.right / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      var2.pos(this.left, this.top, 0.0).tex(this.left / 32.0F, (this.top + (int)this.amountScrolled) / 32.0F).color(32, 32, 32, 255).endVertex();
+      var1.draw();
    }
 }
--- net/minecraft/client/gui/GuiSlotRealmsProxy.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSlotRealmsProxy.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSnooper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSnooper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSpectator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSpectator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiSubtitleOverlay.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiSubtitleOverlay.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiTextField.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiTextField.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiUtilRenderComponents.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiUtilRenderComponents.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiVideoSettings.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiVideoSettings.java	Mon Aug 18 09:39:52 2025
@@ -1,118 +1,209 @@
 package net.minecraft.client.gui;
 
-import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.settings.GameSettings;
+import net.optifine.Lang;
+import net.optifine.gui.GuiAnimationSettingsOF;
+import net.optifine.gui.GuiDetailSettingsOF;
+import net.optifine.gui.GuiOptionButtonOF;
+import net.optifine.gui.GuiOptionSliderOF;
+import net.optifine.gui.GuiOtherSettingsOF;
+import net.optifine.gui.GuiPerformanceSettingsOF;
+import net.optifine.gui.GuiQualitySettingsOF;
+import net.optifine.gui.GuiScreenOF;
+import net.optifine.gui.TooltipManager;
+import net.optifine.gui.TooltipProviderOptions;
+import net.optifine.shaders.gui.GuiShaders;
 
-public class GuiVideoSettings extends GuiScreen {
-   private final GuiScreen parentGuiScreen;
+public class GuiVideoSettings extends GuiScreenOF {
+   private GuiScreen parentGuiScreen;
    protected String screenTitle = "Video Settings";
-   private final GameSettings guiGameSettings;
-   private GuiListExtended optionsRowList;
-   private static final GameSettings.Options[] VIDEO_OPTIONS = new GameSettings.Options[]{
+   private GameSettings guiGameSettings;
+   private static GameSettings.Options[] videoOptions = new GameSettings.Options[]{
       GameSettings.Options.GRAPHICS,
       GameSettings.Options.RENDER_DISTANCE,
       GameSettings.Options.AMBIENT_OCCLUSION,
       GameSettings.Options.FRAMERATE_LIMIT,
-      GameSettings.Options.ANAGLYPH,
+      GameSettings.Options.AO_LEVEL,
       GameSettings.Options.VIEW_BOBBING,
       GameSettings.Options.GUI_SCALE,
-      GameSettings.Options.ATTACK_INDICATOR,
-      GameSettings.Options.GAMMA,
-      GameSettings.Options.RENDER_CLOUDS,
-      GameSettings.Options.PARTICLES,
-      GameSettings.Options.USE_FULLSCREEN,
-      GameSettings.Options.ENABLE_VSYNC,
-      GameSettings.Options.MIPMAP_LEVELS,
       GameSettings.Options.USE_VBO,
-      GameSettings.Options.ENTITY_SHADOWS
+      GameSettings.Options.GAMMA,
+      GameSettings.Options.ATTACK_INDICATOR,
+      GameSettings.Options.DYNAMIC_LIGHTS,
+      GameSettings.Options.DYNAMIC_FOV
    };
+   private static final String __OBFID = "CL_00000718";
+   private TooltipManager tooltipManager = new TooltipManager(this, new TooltipProviderOptions());
 
    public GuiVideoSettings(GuiScreen var1, GameSettings var2) {
       this.parentGuiScreen = var1;
       this.guiGameSettings = var2;
    }
 
-   @Override
    public void initGui() {
       this.screenTitle = I18n.format("options.videoTitle");
       this.buttonList.clear();
-      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height - 27, I18n.format("gui.done")));
-      if (OpenGlHelper.vboSupported) {
-         this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, VIDEO_OPTIONS);
-      } else {
-         GameSettings.Options[] var1 = new GameSettings.Options[VIDEO_OPTIONS.length - 1];
-         int var2 = 0;
-
-         for (GameSettings.Options var6 : VIDEO_OPTIONS) {
-            if (var6 == GameSettings.Options.USE_VBO) {
-               break;
-            }
 
-            var1[var2] = var6;
-            var2++;
+      for (int var1 = 0; var1 < videoOptions.length; var1++) {
+         GameSettings.Options var2 = videoOptions[var1];
+         if (var2 != null) {
+            int var3 = this.width / 2 - 155 + var1 % 2 * 160;
+            int var4 = this.height / 6 + 21 * (var1 / 2) - 12;
+            if (var2.isFloat()) {
+               this.buttonList.add(new GuiOptionSliderOF(var2.getOrdinal(), var3, var4, var2));
+            } else {
+               this.buttonList.add(new GuiOptionButtonOF(var2.getOrdinal(), var3, var4, var2, this.guiGameSettings.getKeyBinding(var2)));
+            }
          }
-
-         this.optionsRowList = new GuiOptionsRowList(this.mc, this.width, this.height, 32, this.height - 32, 25, var1);
       }
+
+      int var5 = this.height / 6 + 21 * (videoOptions.length / 2) - 12;
+      int var9 = 0;
+      var9 = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(231, var9, var5, Lang.get("of.options.shaders")));
+      var9 = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(202, var9, var5, Lang.get("of.options.quality")));
+      var5 += 21;
+      var9 = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(201, var9, var5, Lang.get("of.options.details")));
+      var9 = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(212, var9, var5, Lang.get("of.options.performance")));
+      var5 += 21;
+      var9 = this.width / 2 - 155 + 0;
+      this.buttonList.add(new GuiOptionButton(211, var9, var5, Lang.get("of.options.animations")));
+      var9 = this.width / 2 - 155 + 160;
+      this.buttonList.add(new GuiOptionButton(222, var9, var5, Lang.get("of.options.other")));
+      var5 += 21;
+      this.buttonList.add(new GuiButton(200, this.width / 2 - 100, this.height / 6 + 168 + 11, I18n.format("gui.done")));
    }
 
-   @Override
-   public void handleMouseInput() {
-      super.handleMouseInput();
-      this.optionsRowList.handleMouseInput();
+   protected void actionPerformed(GuiButton var1) {
+      this.actionPerformed(var1, 1);
    }
 
-   @Override
-   protected void keyTyped(char var1, int var2) {
-      if (var2 == 1) {
-         this.mc.gameSettings.saveOptions();
+   protected void actionPerformedRightClick(GuiButton var1) {
+      if (var1.id == GameSettings.Options.GUI_SCALE.ordinal()) {
+         this.actionPerformed(var1, -1);
       }
-
-      super.keyTyped(var1, var2);
    }
 
-   @Override
-   protected void actionPerformed(GuiButton var1) {
+   private void actionPerformed(GuiButton var1, int var2) {
       if (var1.enabled) {
+         int var3 = this.guiGameSettings.guiScale;
+         if (var1.id < 200 && var1 instanceof GuiOptionButton) {
+            this.guiGameSettings.setOptionValue(((GuiOptionButton)var1).getOption(), var2);
+            var1.displayString = this.guiGameSettings.getKeyBinding(GameSettings.Options.byOrdinal(var1.id));
+         }
+
          if (var1.id == 200) {
             this.mc.gameSettings.saveOptions();
             this.mc.displayGuiScreen(this.parentGuiScreen);
          }
-      }
-   }
 
-   @Override
-   protected void mouseClicked(int var1, int var2, int var3) {
-      int var4 = this.guiGameSettings.guiScale;
-      super.mouseClicked(var1, var2, var3);
-      this.optionsRowList.mouseClicked(var1, var2, var3);
-      if (this.guiGameSettings.guiScale != var4) {
-         ScaledResolution var5 = new ScaledResolution(this.mc);
-         int var6 = var5.getScaledWidth();
-         int var7 = var5.getScaledHeight();
-         this.setWorldAndResolution(this.mc, var6, var7);
-      }
-   }
+         if (this.guiGameSettings.guiScale != var3) {
+            ScaledResolution var4 = new ScaledResolution(this.mc);
+            int var5 = var4.getScaledWidth();
+            int var6 = var4.getScaledHeight();
+            this.setWorldAndResolution(this.mc, var5, var6);
+         }
+
+         if (var1.id == 201) {
+            this.mc.gameSettings.saveOptions();
+            GuiDetailSettingsOF var7 = new GuiDetailSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var7);
+         }
+
+         if (var1.id == 202) {
+            this.mc.gameSettings.saveOptions();
+            GuiQualitySettingsOF var8 = new GuiQualitySettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var8);
+         }
 
-   @Override
-   protected void mouseReleased(int var1, int var2, int var3) {
-      int var4 = this.guiGameSettings.guiScale;
-      super.mouseReleased(var1, var2, var3);
-      this.optionsRowList.mouseReleased(var1, var2, var3);
-      if (this.guiGameSettings.guiScale != var4) {
-         ScaledResolution var5 = new ScaledResolution(this.mc);
-         int var6 = var5.getScaledWidth();
-         int var7 = var5.getScaledHeight();
-         this.setWorldAndResolution(this.mc, var6, var7);
+         if (var1.id == 211) {
+            this.mc.gameSettings.saveOptions();
+            GuiAnimationSettingsOF var9 = new GuiAnimationSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var9);
+         }
+
+         if (var1.id == 212) {
+            this.mc.gameSettings.saveOptions();
+            GuiPerformanceSettingsOF var10 = new GuiPerformanceSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var10);
+         }
+
+         if (var1.id == 222) {
+            this.mc.gameSettings.saveOptions();
+            GuiOtherSettingsOF var11 = new GuiOtherSettingsOF(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var11);
+         }
+
+         if (var1.id == 231) {
+            if (Config.isAntialiasing() || Config.isAntialiasingConfigured()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.aa1"), Lang.get("of.message.shaders.aa2"));
+               return;
+            }
+
+            if (Config.isAnisotropicFiltering()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.af1"), Lang.get("of.message.shaders.af2"));
+               return;
+            }
+
+            if (Config.isFastRender()) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.fr1"), Lang.get("of.message.shaders.fr2"));
+               return;
+            }
+
+            if (Config.getGameSettings().anaglyph) {
+               Config.showGuiMessage(Lang.get("of.message.shaders.an1"), Lang.get("of.message.shaders.an2"));
+               return;
+            }
+
+            this.mc.gameSettings.saveOptions();
+            GuiShaders var12 = new GuiShaders(this, this.guiGameSettings);
+            this.mc.displayGuiScreen(var12);
+         }
       }
    }
 
-   @Override
    public void drawScreen(int var1, int var2, float var3) {
       this.drawDefaultBackground();
-      this.optionsRowList.drawScreen(var1, var2, var3);
-      this.drawCenteredString(this.fontRenderer, this.screenTitle, this.width / 2, 5, 16777215);
+      this.a(this.fontRenderer, this.screenTitle, this.width / 2, 15, 16777215);
+      String var4 = Config.getVersion();
+      String var5 = "HD_U";
+      if (var5.equals("HD")) {
+         var4 = "OptiFine HD G5";
+      }
+
+      if (var5.equals("HD_U")) {
+         var4 = "OptiFine HD G5 Ultra";
+      }
+
+      if (var5.equals("L")) {
+         var4 = "OptiFine G5 Light";
+      }
+
+      this.c(this.fontRenderer, var4, 2, this.height - 10, 8421504);
+      String var6 = "Minecraft 1.12.2";
+      int var7 = this.fontRenderer.getStringWidth(var6);
+      this.c(this.fontRenderer, var6, this.width - var7 - 2, this.height - 10, 8421504);
       super.drawScreen(var1, var2, var3);
+      this.tooltipManager.drawTooltips(var1, var2, this.buttonList);
+   }
+
+   public static int getButtonWidth(GuiButton var0) {
+      return var0.width;
+   }
+
+   public static int getButtonHeight(GuiButton var0) {
+      return var0.height;
+   }
+
+   public static void drawGradientRect(GuiScreen var0, int var1, int var2, int var3, int var4, int var5, int var6) {
+      var0.a(var1, var2, var3, var4, var5, var6);
+   }
+
+   public static String getGuiChatText(GuiChat var0) {
+      return var0.inputField.getText();
    }
 }
--- net/minecraft/client/gui/GuiWinGame.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiWinGame.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiWorldEdit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiWorldEdit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiWorldSelection.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiWorldSelection.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiYesNo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiYesNo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/GuiYesNoCallback.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/GuiYesNoCallback.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/IProgressMeter.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/IProgressMeter.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/MapItemRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/MapItemRenderer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ScaledResolution.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ScaledResolution.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ScreenChatOptions.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ScreenChatOptions.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ServerListEntryLanDetected.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ServerListEntryLanDetected.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ServerListEntryLanScan.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ServerListEntryLanScan.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ServerListEntryNormal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ServerListEntryNormal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/gui/ServerSelectionList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/gui/ServerSelectionList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/main/GameConfiguration.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/main/GameConfiguration.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/main/Main.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/main/Main.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/IMultipassModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/IMultipassModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelArmorStand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelArmorStand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelArmorStandArmor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelArmorStandArmor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBanner.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBanner.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBase.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBed.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBed.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBiped.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBiped.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBlaze.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBlaze.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBoat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBoat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBook.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBook.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelBox.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelBox.java	Mon Aug 18 09:39:52 2025
@@ -14,12 +14,75 @@
    public String boxName;
 
    public ModelBox(ModelRenderer var1, int var2, int var3, float var4, float var5, float var6, int var7, int var8, int var9, float var10) {
       this(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var1.mirror);
    }
 
+   public ModelBox(ModelRenderer var1, int[][] var2, float var3, float var4, float var5, float var6, float var7, float var8, float var9, boolean var10) {
+      this.posX1 = var3;
+      this.posY1 = var4;
+      this.posZ1 = var5;
+      this.posX2 = var3 + var6;
+      this.posY2 = var4 + var7;
+      this.posZ2 = var5 + var8;
+      this.vertexPositions = new PositionTextureVertex[8];
+      this.quadList = new TexturedQuad[6];
+      float var11 = var3 + var6;
+      float var12 = var4 + var7;
+      float var13 = var5 + var8;
+      var3 -= var9;
+      var4 -= var9;
+      var5 -= var9;
+      var11 += var9;
+      var12 += var9;
+      var13 += var9;
+      if (var10) {
+         float var14 = var11;
+         var11 = var3;
+         var3 = var14;
+      }
+
+      PositionTextureVertex var32 = new PositionTextureVertex(var3, var4, var5, 0.0F, 0.0F);
+      PositionTextureVertex var15 = new PositionTextureVertex(var11, var4, var5, 0.0F, 8.0F);
+      PositionTextureVertex var16 = new PositionTextureVertex(var11, var12, var5, 8.0F, 8.0F);
+      PositionTextureVertex var17 = new PositionTextureVertex(var3, var12, var5, 8.0F, 0.0F);
+      PositionTextureVertex var18 = new PositionTextureVertex(var3, var4, var13, 0.0F, 0.0F);
+      PositionTextureVertex var19 = new PositionTextureVertex(var11, var4, var13, 0.0F, 8.0F);
+      PositionTextureVertex var20 = new PositionTextureVertex(var11, var12, var13, 8.0F, 8.0F);
+      PositionTextureVertex var21 = new PositionTextureVertex(var3, var12, var13, 8.0F, 0.0F);
+      this.vertexPositions[0] = var32;
+      this.vertexPositions[1] = var15;
+      this.vertexPositions[2] = var16;
+      this.vertexPositions[3] = var17;
+      this.vertexPositions[4] = var18;
+      this.vertexPositions[5] = var19;
+      this.vertexPositions[6] = var20;
+      this.vertexPositions[7] = var21;
+      this.quadList[0] = this.makeTexturedQuad(new PositionTextureVertex[]{var19, var15, var16, var20}, var2[4], false, var1.textureWidth, var1.textureHeight);
+      this.quadList[1] = this.makeTexturedQuad(new PositionTextureVertex[]{var32, var18, var21, var17}, var2[5], false, var1.textureWidth, var1.textureHeight);
+      this.quadList[2] = this.makeTexturedQuad(new PositionTextureVertex[]{var19, var18, var32, var15}, var2[1], true, var1.textureWidth, var1.textureHeight);
+      this.quadList[3] = this.makeTexturedQuad(new PositionTextureVertex[]{var16, var17, var21, var20}, var2[0], true, var1.textureWidth, var1.textureHeight);
+      this.quadList[4] = this.makeTexturedQuad(new PositionTextureVertex[]{var15, var32, var17, var16}, var2[2], false, var1.textureWidth, var1.textureHeight);
+      this.quadList[5] = this.makeTexturedQuad(new PositionTextureVertex[]{var18, var19, var20, var21}, var2[3], false, var1.textureWidth, var1.textureHeight);
+      if (var10) {
+         for (TexturedQuad var25 : this.quadList) {
+            var25.flipFace();
+         }
+      }
+   }
+
+   private TexturedQuad makeTexturedQuad(PositionTextureVertex[] var1, int[] var2, boolean var3, float var4, float var5) {
+      if (var2 == null) {
+         return null;
+      } else {
+         return var3
+            ? new TexturedQuad(var1, var2[2], var2[3], var2[0], var2[1], var4, var5)
+            : new TexturedQuad(var1, var2[0], var2[1], var2[2], var2[3], var4, var5);
+      }
+   }
+
    public ModelBox(ModelRenderer var1, int var2, int var3, float var4, float var5, float var6, int var7, int var8, int var9, float var10, boolean var11) {
       this.posX1 = var4;
       this.posY1 = var5;
       this.posZ1 = var6;
       this.posX2 = var4 + var7;
       this.posY2 = var5 + var8;
@@ -105,13 +168,15 @@
          }
       }
    }
 
    public void render(BufferBuilder var1, float var2) {
       for (TexturedQuad var6 : this.quadList) {
-         var6.draw(var1, var2);
+         if (var6 != null) {
+            var6.draw(var1, var2);
+         }
       }
    }
 
    public ModelBox setBoxName(String var1) {
       this.boxName = var1;
       return this;
--- net/minecraft/client/model/ModelChest.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelChest.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelChicken.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelChicken.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelCow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelCow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelCreeper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelCreeper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelDragon.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelDragon.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelDragonHead.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelDragonHead.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelElytra.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelElytra.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelEnderCrystal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelEnderCrystal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelEnderman.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelEnderman.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelEnderMite.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelEnderMite.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelEvokerFangs.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelEvokerFangs.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelGhast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelGhast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelGuardian.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelGuardian.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelHorse.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelHorse.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelHumanoidHead.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelHumanoidHead.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelIllager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelIllager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelIronGolem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelIronGolem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelLargeChest.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelLargeChest.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelLeashKnot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelLeashKnot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelLlama.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelLlama.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelLlamaSpit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelLlamaSpit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelMagmaCube.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelMagmaCube.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelMinecart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelMinecart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelOcelot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelOcelot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelParrot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelParrot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelPig.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelPig.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelPlayer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelPlayer.java	Mon Aug 18 09:39:52 2025
@@ -58,13 +58,12 @@
       this.bipedRightLegwear.setRotationPoint(-1.9F, 12.0F, 0.0F);
       this.bipedBodyWear = new ModelRenderer(this, 16, 32);
       this.bipedBodyWear.addBox(-4.0F, 0.0F, -2.0F, 8, 12, 4, var1 + 0.25F);
       this.bipedBodyWear.setRotationPoint(0.0F, 0.0F, 0.0F);
    }
 
-   @Override
    public void render(Entity var1, float var2, float var3, float var4, float var5, float var6, float var7) {
       super.render(var1, var2, var3, var4, var5, var6, var7);
       GlStateManager.pushMatrix();
       if (this.isChild) {
          float var8 = 2.0F;
          GlStateManager.scale(0.5F, 0.5F, 0.5F);
@@ -97,40 +96,32 @@
    }
 
    public void renderCape(float var1) {
       this.bipedCape.render(var1);
    }
 
-   @Override
    public void setRotationAngles(float var1, float var2, float var3, float var4, float var5, float var6, Entity var7) {
       super.setRotationAngles(var1, var2, var3, var4, var5, var6, var7);
       copyModelAngles(this.bipedLeftLeg, this.bipedLeftLegwear);
       copyModelAngles(this.bipedRightLeg, this.bipedRightLegwear);
       copyModelAngles(this.bipedLeftArm, this.bipedLeftArmwear);
       copyModelAngles(this.bipedRightArm, this.bipedRightArmwear);
       copyModelAngles(this.bipedBody, this.bipedBodyWear);
-      if (var7.isSneaking()) {
-         this.bipedCape.rotationPointY = 2.0F;
-      } else {
-         this.bipedCape.rotationPointY = 0.0F;
-      }
    }
 
-   @Override
    public void setVisible(boolean var1) {
       super.setVisible(var1);
       this.bipedLeftArmwear.showModel = var1;
       this.bipedRightArmwear.showModel = var1;
       this.bipedLeftLegwear.showModel = var1;
       this.bipedRightLegwear.showModel = var1;
       this.bipedBodyWear.showModel = var1;
       this.bipedCape.showModel = var1;
       this.bipedDeadmau5Head.showModel = var1;
    }
 
-   @Override
    public void postRenderArm(float var1, EnumHandSide var2) {
       ModelRenderer var3 = this.getArmForSide(var2);
       if (this.smallArms) {
          float var4 = 0.5F * (var2 == EnumHandSide.RIGHT ? 1 : -1);
          var3.rotationPointX += var4;
          var3.postRender(var1);
--- net/minecraft/client/model/ModelPolarBear.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelPolarBear.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelQuadruped.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelQuadruped.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelRabbit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelRabbit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelRenderer.java	Mon Aug 18 09:39:52 2025
@@ -1,48 +1,68 @@
 package net.minecraft.client.model;
 
 import com.google.common.collect.Lists;
+import java.util.ArrayList;
 import java.util.List;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.client.renderer.RenderGlobal;
 import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.util.ResourceLocation;
+import net.optifine.entity.model.anim.ModelUpdater;
+import net.optifine.model.ModelSprite;
+import net.optifine.shaders.Shaders;
 
 public class ModelRenderer {
-   public float textureWidth = 64.0F;
-   public float textureHeight = 32.0F;
+   public float textureWidth;
+   public float textureHeight;
    private int textureOffsetX;
    private int textureOffsetY;
    public float rotationPointX;
    public float rotationPointY;
    public float rotationPointZ;
    public float rotateAngleX;
    public float rotateAngleY;
    public float rotateAngleZ;
    private boolean compiled;
    private int displayList;
    public boolean mirror;
-   public boolean showModel = true;
+   public boolean showModel;
    public boolean isHidden;
-   public List<ModelBox> cubeList = Lists.newArrayList();
+   public List<ModelBox> cubeList;
    public List<ModelRenderer> childModels;
    public final String boxName;
    private final ModelBase baseModel;
    public float offsetX;
    public float offsetY;
    public float offsetZ;
+   public List spriteList = new ArrayList();
+   public boolean mirrorV = false;
+   public float scaleX = 1.0F;
+   public float scaleY = 1.0F;
+   public float scaleZ = 1.0F;
+   private int countResetDisplayList;
+   private ResourceLocation textureLocation = null;
+   private String id = null;
+   private ModelUpdater modelUpdater;
+   private RenderGlobal renderGlobal = Config.getRenderGlobal();
 
    public ModelRenderer(ModelBase var1, String var2) {
+      this.textureWidth = 64.0F;
+      this.textureHeight = 32.0F;
+      this.showModel = true;
+      this.cubeList = Lists.newArrayList();
       this.baseModel = var1;
       var1.boxList.add(this);
       this.boxName = var2;
       this.setTextureSize(var1.textureWidth, var1.textureHeight);
    }
 
    public ModelRenderer(ModelBase var1) {
-      this(var1, null);
+      this(var1, (String)null);
    }
 
    public ModelRenderer(ModelBase var1, int var2, int var3) {
       this(var1);
       this.setTextureOffset(var2, var3);
    }
@@ -87,133 +107,301 @@
       this.rotationPointX = var1;
       this.rotationPointY = var2;
       this.rotationPointZ = var3;
    }
 
    public void render(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(var1);
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(var1);
+         }
+
+         int var2 = 0;
+         if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
+            if (this.renderGlobal.renderOverlayEyes) {
+               return;
             }
 
-            GlStateManager.translate(this.offsetX, this.offsetY, this.offsetZ);
-            if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
-               GlStateManager.pushMatrix();
-               GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
-               if (this.rotateAngleZ != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
-               }
+            var2 = GlStateManager.getBoundTexture();
+            Config.getTextureManager().bindTexture(this.textureLocation);
+         }
 
-               if (this.rotateAngleY != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
-               }
+         if (this.modelUpdater != null) {
+            this.modelUpdater.update();
+         }
 
-               if (this.rotateAngleX != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
-               }
+         boolean var3 = this.scaleX != 1.0F || this.scaleY != 1.0F || this.scaleZ != 1.0F;
+         GlStateManager.translate(this.offsetX, this.offsetY, this.offsetZ);
+         if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
+            GlStateManager.pushMatrix();
+            GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
+            if (this.rotateAngleZ != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+            }
 
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int var4 = 0; var4 < this.childModels.size(); var4++) {
-                     this.childModels.get(var4).render(var1);
-                  }
+            if (this.rotateAngleY != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+            }
+
+            if (this.rotateAngleX != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+            }
+
+            if (var3) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int var6 = 0; var6 < this.childModels.size(); var6++) {
+                  this.childModels.get(var6).render(var1);
                }
+            }
 
-               GlStateManager.popMatrix();
-            } else if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F) {
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int var3 = 0; var3 < this.childModels.size(); var3++) {
-                     this.childModels.get(var3).render(var1);
-                  }
+            GlStateManager.popMatrix();
+         } else if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F) {
+            if (var3) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int var5 = 0; var5 < this.childModels.size(); var5++) {
+                  this.childModels.get(var5).render(var1);
                }
-            } else {
-               GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
-               GlStateManager.callList(this.displayList);
-               if (this.childModels != null) {
-                  for (int var2 = 0; var2 < this.childModels.size(); var2++) {
-                     this.childModels.get(var2).render(var1);
-                  }
+            }
+
+            if (var3) {
+               GlStateManager.scale(1.0F / this.scaleX, 1.0F / this.scaleY, 1.0F / this.scaleZ);
+            }
+         } else {
+            GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
+            if (var3) {
+               GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+            }
+
+            GlStateManager.callList(this.displayList);
+            if (this.childModels != null) {
+               for (int var4 = 0; var4 < this.childModels.size(); var4++) {
+                  this.childModels.get(var4).render(var1);
                }
+            }
 
-               GlStateManager.translate(-this.rotationPointX * var1, -this.rotationPointY * var1, -this.rotationPointZ * var1);
+            if (var3) {
+               GlStateManager.scale(1.0F / this.scaleX, 1.0F / this.scaleY, 1.0F / this.scaleZ);
             }
 
-            GlStateManager.translate(-this.offsetX, -this.offsetY, -this.offsetZ);
+            GlStateManager.translate(-this.rotationPointX * var1, -this.rotationPointY * var1, -this.rotationPointZ * var1);
+         }
+
+         GlStateManager.translate(-this.offsetX, -this.offsetY, -this.offsetZ);
+         if (var2 != 0) {
+            GlStateManager.bindTexture(var2);
          }
       }
    }
 
    public void renderWithRotation(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(var1);
-            }
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(var1);
+         }
 
-            GlStateManager.pushMatrix();
-            GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
-            if (this.rotateAngleY != 0.0F) {
-               GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+         int var2 = 0;
+         if (this.textureLocation != null && !this.renderGlobal.renderOverlayDamaged) {
+            if (this.renderGlobal.renderOverlayEyes) {
+               return;
             }
 
-            if (this.rotateAngleX != 0.0F) {
-               GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
-            }
+            var2 = GlStateManager.getBoundTexture();
+            Config.getTextureManager().bindTexture(this.textureLocation);
+         }
 
-            if (this.rotateAngleZ != 0.0F) {
-               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+         if (this.modelUpdater != null) {
+            this.modelUpdater.update();
+         }
+
+         boolean var3 = this.scaleX != 1.0F || this.scaleY != 1.0F || this.scaleZ != 1.0F;
+         GlStateManager.pushMatrix();
+         GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
+         if (this.rotateAngleY != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+         }
+
+         if (this.rotateAngleX != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
+         }
+
+         if (this.rotateAngleZ != 0.0F) {
+            GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+         }
+
+         if (var3) {
+            GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
+         }
+
+         GlStateManager.callList(this.displayList);
+         if (this.childModels != null) {
+            for (int var4 = 0; var4 < this.childModels.size(); var4++) {
+               this.childModels.get(var4).render(var1);
             }
+         }
 
-            GlStateManager.callList(this.displayList);
-            GlStateManager.popMatrix();
+         GlStateManager.popMatrix();
+         if (var2 != 0) {
+            GlStateManager.bindTexture(var2);
          }
       }
    }
 
    public void postRender(float var1) {
-      if (!this.isHidden) {
-         if (this.showModel) {
-            if (!this.compiled) {
-               this.compileDisplayList(var1);
-            }
+      if (!this.isHidden && this.showModel) {
+         this.checkResetDisplayList();
+         if (!this.compiled) {
+            this.compileDisplayList(var1);
+         }
 
-            if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
-               GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
-               if (this.rotateAngleZ != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
-               }
+         if (this.rotateAngleX != 0.0F || this.rotateAngleY != 0.0F || this.rotateAngleZ != 0.0F) {
+            GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
+            if (this.rotateAngleZ != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleZ * (180.0F / (float)Math.PI), 0.0F, 0.0F, 1.0F);
+            }
 
-               if (this.rotateAngleY != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
-               }
+            if (this.rotateAngleY != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleY * (180.0F / (float)Math.PI), 0.0F, 1.0F, 0.0F);
+            }
 
-               if (this.rotateAngleX != 0.0F) {
-                  GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
-               }
-            } else if (this.rotationPointX != 0.0F || this.rotationPointY != 0.0F || this.rotationPointZ != 0.0F) {
-               GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
+            if (this.rotateAngleX != 0.0F) {
+               GlStateManager.rotate(this.rotateAngleX * (180.0F / (float)Math.PI), 1.0F, 0.0F, 0.0F);
             }
+         } else if (this.rotationPointX != 0.0F || this.rotationPointY != 0.0F || this.rotationPointZ != 0.0F) {
+            GlStateManager.translate(this.rotationPointX * var1, this.rotationPointY * var1, this.rotationPointZ * var1);
          }
       }
    }
 
    private void compileDisplayList(float var1) {
-      this.displayList = GLAllocation.generateDisplayLists(1);
+      if (this.displayList == 0) {
+         this.displayList = GLAllocation.generateDisplayLists(1);
+      }
+
       GlStateManager.glNewList(this.displayList, 4864);
       BufferBuilder var2 = Tessellator.getInstance().getBuffer();
 
       for (int var3 = 0; var3 < this.cubeList.size(); var3++) {
          this.cubeList.get(var3).render(var2, var1);
       }
 
+      for (int var5 = 0; var5 < this.spriteList.size(); var5++) {
+         ModelSprite var4 = (ModelSprite)this.spriteList.get(var5);
+         var4.render(Tessellator.getInstance(), var1);
+      }
+
       GlStateManager.glEndList();
       this.compiled = true;
    }
 
    public ModelRenderer setTextureSize(int var1, int var2) {
       this.textureWidth = var1;
       this.textureHeight = var2;
       return this;
+   }
+
+   public void addSprite(float var1, float var2, float var3, int var4, int var5, int var6, float var7) {
+      this.spriteList.add(new ModelSprite(this, this.textureOffsetX, this.textureOffsetY, var1, var2, var3, var4, var5, var6, var7));
+   }
+
+   public boolean getCompiled() {
+      return this.compiled;
+   }
+
+   public int getDisplayList() {
+      return this.displayList;
+   }
+
+   private void checkResetDisplayList() {
+      if (this.countResetDisplayList != Shaders.countResetDisplayLists) {
+         this.compiled = false;
+         this.countResetDisplayList = Shaders.countResetDisplayLists;
+      }
+   }
+
+   public ResourceLocation getTextureLocation() {
+      return this.textureLocation;
+   }
+
+   public void setTextureLocation(ResourceLocation var1) {
+      this.textureLocation = var1;
+   }
+
+   public String getId() {
+      return this.id;
+   }
+
+   public void setId(String var1) {
+      this.id = var1;
+   }
+
+   public void addBox(int[][] var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
+      this.cubeList.add(new ModelBox(this, var1, var2, var3, var4, var5, var6, var7, var8, this.mirror));
+   }
+
+   public ModelRenderer getChild(String var1) {
+      if (var1 == null) {
+         return null;
+      } else {
+         if (this.childModels != null) {
+            for (int var2 = 0; var2 < this.childModels.size(); var2++) {
+               ModelRenderer var3 = this.childModels.get(var2);
+               if (var1.equals(var3.getId())) {
+                  return var3;
+               }
+            }
+         }
+
+         return null;
+      }
+   }
+
+   public ModelRenderer getChildDeep(String var1) {
+      if (var1 == null) {
+         return null;
+      } else {
+         ModelRenderer var2 = this.getChild(var1);
+         if (var2 != null) {
+            return var2;
+         } else {
+            if (this.childModels != null) {
+               for (int var3 = 0; var3 < this.childModels.size(); var3++) {
+                  ModelRenderer var4 = this.childModels.get(var3);
+                  ModelRenderer var5 = var4.getChildDeep(var1);
+                  if (var5 != null) {
+                     return var5;
+                  }
+               }
+            }
+
+            return null;
+         }
+      }
+   }
+
+   public void setModelUpdater(ModelUpdater var1) {
+      this.modelUpdater = var1;
+   }
+
+   @Override
+   public String toString() {
+      StringBuffer var1 = new StringBuffer();
+      var1.append(
+         "id: "
+            + this.id
+            + ", boxes: "
+            + (this.cubeList != null ? this.cubeList.size() : null)
+            + ", submodels: "
+            + (this.childModels != null ? this.childModels.size() : null)
+      );
+      return var1.toString();
    }
 }
--- net/minecraft/client/model/ModelSheep1.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSheep1.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSheep2.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSheep2.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelShield.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelShield.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelShulker.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelShulker.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelShulkerBullet.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelShulkerBullet.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSign.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSign.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSilverfish.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSilverfish.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSkeleton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSkeleton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSkeletonHead.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSkeletonHead.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSlime.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSlime.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSnowMan.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSnowMan.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSpider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSpider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelSquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelSquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelVex.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelVex.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelVillager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelVillager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelWitch.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelWitch.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelWither.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelWither.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelWolf.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelWolf.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelZombie.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelZombie.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/ModelZombieVillager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/ModelZombieVillager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/PositionTextureVertex.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/PositionTextureVertex.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/model/TexturedQuad.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/TexturedQuad.java	Mon Aug 18 09:39:52 2025
@@ -1,12 +1,13 @@
 package net.minecraft.client.model;
 
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.util.math.Vec3d;
+import net.optifine.shaders.SVertexFormat;
 
 public class TexturedQuad {
    public PositionTextureVertex[] vertexPositions;
    public int nVertices;
    private boolean invertNormal;
 
@@ -45,13 +46,17 @@
       if (this.invertNormal) {
          var6 = -var6;
          var7 = -var7;
          var8 = -var8;
       }
 
-      var1.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
+      if (Config.isShaders()) {
+         var1.begin(7, SVertexFormat.defVertexFormatTextured);
+      } else {
+         var1.begin(7, DefaultVertexFormats.OLDMODEL_POSITION_TEX_NORMAL);
+      }
 
       for (int var9 = 0; var9 < 4; var9++) {
          PositionTextureVertex var10 = this.vertexPositions[var9];
          var1.pos(var10.vector3D.x * var2, var10.vector3D.y * var2, var10.vector3D.z * var2)
             .tex(var10.texturePositionX, var10.texturePositionY)
             .normal(var6, var7, var8)
--- net/minecraft/client/model/TextureOffset.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/model/TextureOffset.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ChunkProviderClient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ChunkProviderClient.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ClientAdvancementManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ClientAdvancementManager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/GuiConnecting.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/GuiConnecting.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/PlayerControllerMP.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/PlayerControllerMP.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ServerAddress.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ServerAddress.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ServerData.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ServerData.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ServerList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ServerList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/ThreadLanServerPing.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/ThreadLanServerPing.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/multiplayer/WorldClient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/multiplayer/WorldClient.java	Mon Aug 18 09:39:52 2025
@@ -1,19 +1,21 @@
 package net.minecraft.client.multiplayer;
 
 import com.google.common.collect.Sets;
 import java.util.Random;
 import java.util.Set;
 import javax.annotation.Nullable;
+import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.audio.MovingSoundMinecart;
 import net.minecraft.client.audio.PositionedSoundRecord;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.network.NetHandlerPlayClient;
-import net.minecraft.client.particle.ParticleFirework;
+import net.minecraft.client.particle.ParticleFirework.Starter;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.item.EntityMinecart;
 import net.minecraft.entity.player.EntityPlayer;
@@ -28,48 +30,70 @@
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.SoundCategory;
 import net.minecraft.util.SoundEvent;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.world.DimensionType;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.EnumSkyBlock;
 import net.minecraft.world.GameType;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
 import net.minecraft.world.storage.SaveDataMemoryStorage;
 import net.minecraft.world.storage.SaveHandlerMP;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.CustomGuis;
+import net.optifine.DynamicLights;
+import net.optifine.override.PlayerControllerOF;
+import net.optifine.reflect.Reflector;
 
 public class WorldClient extends World {
    private final NetHandlerPlayClient connection;
    private ChunkProviderClient clientChunkProvider;
    private final Set<Entity> entityList = Sets.newHashSet();
    private final Set<Entity> entitySpawnQueue = Sets.newHashSet();
    private final Minecraft mc = Minecraft.getMinecraft();
    private final Set<ChunkPos> previousActiveChunkSet = Sets.newHashSet();
-   private int ambienceTicks = this.rand.nextInt(12000);
-   protected Set<ChunkPos> visibleChunks = Sets.newHashSet();
+   private int ambienceTicks;
+   protected Set<ChunkPos> visibleChunks;
+   private int playerChunkX = Integer.MIN_VALUE;
+   private int playerChunkY = Integer.MIN_VALUE;
+   private boolean playerUpdate = false;
 
    public WorldClient(NetHandlerPlayClient var1, WorldSettings var2, int var3, EnumDifficulty var4, Profiler var5) {
-      super(new SaveHandlerMP(), new WorldInfo(var2, "MpServer"), DimensionType.getById(var3).createDimension(), var5, true);
+      super(new SaveHandlerMP(), new WorldInfo(var2, "MpServer"), makeWorldProvider(var3), var5, true);
+      this.ambienceTicks = this.rand.nextInt(12000);
+      this.visibleChunks = Sets.newHashSet();
       this.connection = var1;
       this.getWorldInfo().setDifficulty(var4);
-      this.setSpawnPoint(new BlockPos(8, 64, 8));
       this.provider.setWorld(this);
+      this.setSpawnPoint(new BlockPos(8, 64, 8));
       this.chunkProvider = this.createChunkProvider();
       this.mapStorage = new SaveDataMemoryStorage();
       this.calculateInitialSkylight();
       this.calculateInitialWeather();
+      Reflector.call(this, Reflector.ForgeWorld_initCapabilities, new Object[0]);
+      Reflector.postForgeBusEvent(Reflector.WorldEvent_Load_Constructor, new Object[]{this});
+      if (this.mc.playerController != null && this.mc.playerController.getClass() == PlayerControllerMP.class) {
+         this.mc.playerController = new PlayerControllerOF(this.mc, var1);
+         CustomGuis.setPlayerControllerOF((PlayerControllerOF)this.mc.playerController);
+      }
+   }
+
+   private static WorldProvider makeWorldProvider(int var0) {
+      return Reflector.DimensionManager_createProviderFor.exists()
+         ? (WorldProvider)Reflector.call(Reflector.DimensionManager_createProviderFor, new Object[]{var0})
+         : DimensionType.getById(var0).createDimension();
    }
 
-   @Override
    public void tick() {
       super.tick();
       this.setTotalWorldTime(this.getTotalWorldTime() + 1L);
       if (this.getGameRules().getBoolean("doDaylightCycle")) {
          this.setWorldTime(this.getWorldTime() + 1L);
       }
@@ -91,40 +115,43 @@
       this.profiler.endSection();
    }
 
    public void invalidateBlockReceiveRegion(int var1, int var2, int var3, int var4, int var5, int var6) {
    }
 
-   @Override
    protected IChunkProvider createChunkProvider() {
       this.clientChunkProvider = new ChunkProviderClient(this);
       return this.clientChunkProvider;
    }
 
-   @Override
    protected boolean isChunkLoaded(int var1, int var2, boolean var3) {
       return var3 || !this.getChunkProvider().provideChunk(var1, var2).isEmpty();
    }
 
    protected void refreshVisibleChunks() {
-      this.visibleChunks.clear();
-      int var1 = this.mc.gameSettings.renderDistanceChunks;
-      this.profiler.startSection("buildList");
-      int var2 = MathHelper.floor(this.mc.player.posX / 16.0);
-      int var3 = MathHelper.floor(this.mc.player.posZ / 16.0);
-
-      for (int var4 = -var1; var4 <= var1; var4++) {
-         for (int var5 = -var1; var5 <= var1; var5++) {
-            this.visibleChunks.add(new ChunkPos(var4 + var2, var5 + var3));
+      int var1 = MathHelper.floor(this.mc.player.posX / 16.0);
+      int var2 = MathHelper.floor(this.mc.player.posZ / 16.0);
+      if (var1 != this.playerChunkX || var2 != this.playerChunkY) {
+         this.playerChunkX = var1;
+         this.playerChunkY = var2;
+         this.visibleChunks.clear();
+         int var3 = this.mc.gameSettings.renderDistanceChunks;
+         this.profiler.startSection("buildList");
+         int var4 = MathHelper.floor(this.mc.player.posX / 16.0);
+         int var5 = MathHelper.floor(this.mc.player.posZ / 16.0);
+
+         for (int var6 = -var3; var6 <= var3; var6++) {
+            for (int var7 = -var3; var7 <= var3; var7++) {
+               this.visibleChunks.add(new ChunkPos(var6 + var4, var7 + var5));
+            }
          }
-      }
 
-      this.profiler.endSection();
+         this.profiler.endSection();
+      }
    }
 
-   @Override
    protected void updateBlocks() {
       this.refreshVisibleChunks();
       if (this.ambienceTicks > 0) {
          this.ambienceTicks--;
       }
 
@@ -157,13 +184,12 @@
       } else {
          this.clientChunkProvider.unloadChunk(var1, var2);
          this.markBlockRangeForRenderUpdate(var1 * 16, 0, var2 * 16, var1 * 16 + 15, 256, var2 * 16 + 15);
       }
    }
 
-   @Override
    public boolean spawnEntity(Entity var1) {
       boolean var2 = super.spawnEntity(var1);
       this.entityList.add(var1);
       if (var2) {
          if (var1 instanceof EntityMinecart) {
             this.mc.getSoundHandler().playSound(new MovingSoundMinecart((EntityMinecart)var1));
@@ -172,27 +198,24 @@
          this.entitySpawnQueue.add(var1);
       }
 
       return var2;
    }
 
-   @Override
    public void removeEntity(Entity var1) {
       super.removeEntity(var1);
       this.entityList.remove(var1);
    }
 
-   @Override
    protected void onEntityAdded(Entity var1) {
       super.onEntityAdded(var1);
       if (this.entitySpawnQueue.contains(var1)) {
          this.entitySpawnQueue.remove(var1);
       }
    }
 
-   @Override
    protected void onEntityRemoved(Entity var1) {
       super.onEntityRemoved(var1);
       if (this.entityList.contains(var1)) {
          if (var1.isEntityAlive()) {
             this.entitySpawnQueue.add(var1);
          } else {
@@ -214,19 +237,18 @@
       }
 
       this.entitiesById.addKey(var1, var2);
    }
 
    @Nullable
-   @Override
    public Entity getEntityByID(int var1) {
       return (Entity)(var1 == this.mc.player.getEntityId() ? this.mc.player : super.getEntityByID(var1));
    }
 
    public Entity removeEntityFromWorld(int var1) {
-      Entity var2 = this.entitiesById.removeObject(var1);
+      Entity var2 = (Entity)this.entitiesById.removeObject(var1);
       if (var2 != null) {
          this.entityList.remove(var2);
          this.removeEntity(var2);
       }
 
       return var2;
@@ -238,62 +260,85 @@
       int var4 = var1.getY();
       int var5 = var1.getZ();
       this.invalidateBlockReceiveRegion(var3, var4, var5, var3, var4, var5);
       return super.setBlockState(var1, var2, 3);
    }
 
-   @Override
    public void sendQuittingDisconnectingPacket() {
       this.connection.getNetworkManager().closeChannel(new TextComponentString("Quitting"));
    }
 
-   @Override
    protected void updateWeather() {
    }
 
-   @Override
    protected void playMoodSoundAndCheckLight(int var1, int var2, Chunk var3) {
       super.playMoodSoundAndCheckLight(var1, var2, var3);
       if (this.ambienceTicks == 0) {
+         EntityPlayerSP var4 = this.mc.player;
+         if (var4 == null) {
+            return;
+         }
+
+         if (Math.abs(var4.chunkCoordX - var3.x) > 1 || Math.abs(var4.chunkCoordZ - var3.z) > 1) {
+            return;
+         }
+
          this.updateLCG = this.updateLCG * 3 + 1013904223;
-         int var4 = this.updateLCG >> 2;
-         int var5 = var4 & 15;
-         int var6 = var4 >> 8 & 15;
-         int var7 = var4 >> 16 & 0xFF;
-         BlockPos var8 = new BlockPos(var5 + var1, var7, var6 + var2);
-         IBlockState var9 = var3.getBlockState(var8);
-         var5 += var1;
-         var6 += var2;
-         if (var9.getMaterial() == Material.AIR && this.getLight(var8) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, var8) <= 0) {
-            double var10 = this.mc.player.getDistanceSq(var5 + 0.5, var7 + 0.5, var6 + 0.5);
-            if (this.mc.player != null && var10 > 4.0 && var10 < 256.0) {
-               this.playSound(
-                  var5 + 0.5, var7 + 0.5, var6 + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7F, 0.8F + this.rand.nextFloat() * 0.2F, false
-               );
-               this.ambienceTicks = this.rand.nextInt(12000) + 6000;
-            }
+         int var5 = this.updateLCG >> 2;
+         int var6 = var5 & 15;
+         int var7 = var5 >> 8 & 15;
+         int var8 = var5 >> 16 & 0xFF;
+         var8 /= 2;
+         if (var4.posY > 160.0) {
+            var8 += 128;
+         } else if (var4.posY > 96.0) {
+            var8 += 64;
+         }
+
+         BlockPos var9 = new BlockPos(var6 + var1, var8, var7 + var2);
+         IBlockState var10 = var3.getBlockState(var9);
+         var6 += var1;
+         var7 += var2;
+         double var11 = this.mc.player.getDistanceSq(var6 + 0.5, var8 + 0.5, var7 + 0.5);
+         if (var11 < 4.0) {
+            return;
+         }
+
+         if (var11 > 255.0) {
+            return;
+         }
+
+         if (var10.a() == Material.AIR && this.getLight(var9) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, var9) <= 0) {
+            this.playSound(
+               var6 + 0.5, var8 + 0.5, var7 + 0.5, SoundEvents.AMBIENT_CAVE, SoundCategory.AMBIENT, 0.7F, 0.8F + this.rand.nextFloat() * 0.2F, false
+            );
+            this.ambienceTicks = this.rand.nextInt(12000) + 6000;
          }
       }
    }
 
    public void doVoidFogParticles(int var1, int var2, int var3) {
       byte var4 = 32;
       Random var5 = new Random();
       ItemStack var6 = this.mc.player.getHeldItemMainhand();
+      if (var6 == null || Block.getBlockFromItem(var6.getItem()) != Blocks.BARRIER) {
+         var6 = this.mc.player.getHeldItemOffhand();
+      }
+
       boolean var7 = this.mc.playerController.getCurrentGameType() == GameType.CREATIVE
          && !var6.isEmpty()
          && var6.getItem() == Item.getItemFromBlock(Blocks.BARRIER);
-      BlockPos.MutableBlockPos var8 = new BlockPos.MutableBlockPos();
+      MutableBlockPos var8 = new MutableBlockPos();
 
       for (int var9 = 0; var9 < 667; var9++) {
          this.showBarrierParticles(var1, var2, var3, 16, var5, var7, var8);
          this.showBarrierParticles(var1, var2, var3, 32, var5, var7, var8);
       }
    }
 
-   public void showBarrierParticles(int var1, int var2, int var3, int var4, Random var5, boolean var6, BlockPos.MutableBlockPos var7) {
+   public void showBarrierParticles(int var1, int var2, int var3, int var4, Random var5, boolean var6, MutableBlockPos var7) {
       int var8 = var1 + this.rand.nextInt(var4) - this.rand.nextInt(var4);
       int var9 = var2 + this.rand.nextInt(var4) - this.rand.nextInt(var4);
       int var10 = var3 + this.rand.nextInt(var4) - this.rand.nextInt(var4);
       var7.setPos(var8, var9, var10);
       IBlockState var11 = this.getBlockState(var7);
       var11.getBlock().randomDisplayTick(var11, this, var7, var5);
@@ -303,28 +348,28 @@
    }
 
    public void removeAllEntities() {
       this.loadedEntityList.removeAll(this.unloadedEntityList);
 
       for (int var1 = 0; var1 < this.unloadedEntityList.size(); var1++) {
-         Entity var2 = this.unloadedEntityList.get(var1);
+         Entity var2 = (Entity)this.unloadedEntityList.get(var1);
          int var3 = var2.chunkCoordX;
          int var4 = var2.chunkCoordZ;
          if (var2.addedToChunk && this.isChunkLoaded(var3, var4, true)) {
             this.getChunk(var3, var4).removeEntity(var2);
          }
       }
 
       for (int var6 = 0; var6 < this.unloadedEntityList.size(); var6++) {
-         this.onEntityRemoved(this.unloadedEntityList.get(var6));
+         this.onEntityRemoved((Entity)this.unloadedEntityList.get(var6));
       }
 
       this.unloadedEntityList.clear();
 
       for (int var7 = 0; var7 < this.loadedEntityList.size(); var7++) {
-         Entity var8 = this.loadedEntityList.get(var7);
+         Entity var8 = (Entity)this.loadedEntityList.get(var7);
          Entity var9 = var8.getRidingEntity();
          if (var9 != null) {
             if (!var9.isDead && var9.isPassenger(var8)) {
                continue;
             }
 
@@ -341,13 +386,12 @@
             this.loadedEntityList.remove(var7--);
             this.onEntityRemoved(var8);
          }
       }
    }
 
-   @Override
    public CrashReportCategory addWorldInfoToCrashReport(CrashReport var1) {
       CrashReportCategory var2 = super.addWorldInfoToCrashReport(var1);
       var2.addDetail("Forced entities", new ICrashReportDetail<String>() {
          public String call() {
             return WorldClient.this.entityList.size() + " total; " + WorldClient.this.entityList;
          }
@@ -367,50 +411,45 @@
             return WorldClient.this.mc.getIntegratedServer() == null ? "Non-integrated multiplayer server" : "Integrated singleplayer server";
          }
       });
       return var2;
    }
 
-   @Override
    public void playSound(@Nullable EntityPlayer var1, double var2, double var4, double var6, SoundEvent var8, SoundCategory var9, float var10, float var11) {
       if (var1 == this.mc.player) {
          this.playSound(var2, var4, var6, var8, var9, var10, var11, false);
       }
    }
 
    public void playSound(BlockPos var1, SoundEvent var2, SoundCategory var3, float var4, float var5, boolean var6) {
       this.playSound(var1.getX() + 0.5, var1.getY() + 0.5, var1.getZ() + 0.5, var2, var3, var4, var5, var6);
    }
 
-   @Override
    public void playSound(double var1, double var3, double var5, SoundEvent var7, SoundCategory var8, float var9, float var10, boolean var11) {
       double var12 = this.mc.getRenderViewEntity().getDistanceSq(var1, var3, var5);
       PositionedSoundRecord var14 = new PositionedSoundRecord(var7, var8, var9, var10, (float)var1, (float)var3, (float)var5);
       if (var11 && var12 > 100.0) {
          double var15 = Math.sqrt(var12) / 40.0;
          this.mc.getSoundHandler().playDelayedSound(var14, (int)(var15 * 20.0));
       } else {
          this.mc.getSoundHandler().playSound(var14);
       }
    }
 
-   @Override
    public void makeFireworks(double var1, double var3, double var5, double var7, double var9, double var11, @Nullable NBTTagCompound var13) {
-      this.mc.effectRenderer.addEffect(new ParticleFirework.Starter(this, var1, var3, var5, var7, var9, var11, this.mc.effectRenderer, var13));
+      this.mc.effectRenderer.addEffect(new Starter(this, var1, var3, var5, var7, var9, var11, this.mc.effectRenderer, var13));
    }
 
-   @Override
    public void sendPacketToServer(Packet<?> var1) {
       this.connection.sendPacket(var1);
    }
 
    public void setWorldScoreboard(Scoreboard var1) {
       this.worldScoreboard = var1;
    }
 
-   @Override
    public void setWorldTime(long var1) {
       if (var1 < 0L) {
          var1 = -var1;
          this.getGameRules().setOrCreateGameRule("doDaylightCycle", "false");
       } else {
          this.getGameRules().setOrCreateGameRule("doDaylightCycle", "true");
@@ -418,8 +457,37 @@
 
       super.setWorldTime(var1);
    }
 
    public ChunkProviderClient getChunkProvider() {
       return (ChunkProviderClient)super.getChunkProvider();
+   }
+
+   public int getCombinedLight(BlockPos var1, int var2) {
+      int var3 = super.getCombinedLight(var1, var2);
+      if (Config.isDynamicLights()) {
+         var3 = DynamicLights.getCombinedLight(var1, var3);
+      }
+
+      return var3;
+   }
+
+   public boolean setBlockState(BlockPos var1, IBlockState var2, int var3) {
+      this.playerUpdate = this.isPlayerActing();
+      boolean var4 = super.setBlockState(var1, var2, var3);
+      this.playerUpdate = false;
+      return var4;
+   }
+
+   private boolean isPlayerActing() {
+      if (this.mc.playerController instanceof PlayerControllerOF) {
+         PlayerControllerOF var1 = (PlayerControllerOF)this.mc.playerController;
+         return var1.isActing();
+      } else {
+         return false;
+      }
+   }
+
+   public boolean isPlayerUpdate() {
+      return this.playerUpdate;
    }
 }
--- net/minecraft/client/network/LanServerDetector.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/LanServerDetector.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/LanServerInfo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/LanServerInfo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/NetHandlerHandshakeMemory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/NetHandlerHandshakeMemory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/NetHandlerLoginClient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/NetHandlerLoginClient.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/NetHandlerPlayClient.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/NetHandlerPlayClient.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/NetworkPlayerInfo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/NetworkPlayerInfo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/network/ServerPinger.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/network/ServerPinger.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/Barrier.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/Barrier.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/IParticleFactory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/IParticleFactory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/Particle.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/Particle.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleBlockDust.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleBlockDust.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleBreaking.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleBreaking.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleBubble.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleBubble.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleCloud.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleCloud.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleCrit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleCrit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleDigging.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleDigging.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleDragonBreath.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleDragonBreath.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleDrip.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleDrip.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleEmitter.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleEmitter.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleEnchantmentTable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleEnchantmentTable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleEndRod.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleEndRod.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleExplosion.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleExplosion.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleExplosionHuge.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleExplosionHuge.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleExplosionLarge.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleExplosionLarge.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleFallingDust.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleFallingDust.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleFirework.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleFirework.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleFlame.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleFlame.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleFootStep.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleFootStep.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleHeart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleHeart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleItemPickup.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleItemPickup.java	Mon Aug 18 09:39:52 2025
@@ -4,12 +4,14 @@
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.entity.Entity;
 import net.minecraft.world.World;
+import net.optifine.shaders.Program;
+import net.optifine.shaders.Shaders;
 
 public class ParticleItemPickup extends Particle {
    private final Entity item;
    private final Entity target;
    private int age;
    private final int maxAge;
@@ -21,44 +23,51 @@
       this.item = var2;
       this.target = var3;
       this.maxAge = 3;
       this.yOffset = var4;
    }
 
-   @Override
    public void renderParticle(BufferBuilder var1, Entity var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      float var9 = (this.age + var3) / this.maxAge;
-      var9 *= var9;
-      double var10 = this.item.posX;
-      double var12 = this.item.posY;
-      double var14 = this.item.posZ;
-      double var16 = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * var3;
-      double var18 = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * var3 + this.yOffset;
-      double var20 = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * var3;
-      double var22 = var10 + (var16 - var10) * var9;
-      double var24 = var12 + (var18 - var12) * var9;
-      double var26 = var14 + (var20 - var14) * var9;
-      int var28 = this.getBrightnessForRender(var3);
-      int var29 = var28 % 65536;
-      int var30 = var28 / 65536;
-      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var29, var30);
+      Program var9 = null;
+      if (Config.isShaders()) {
+         var9 = Shaders.activeProgram;
+         Shaders.nextEntity(this.item);
+      }
+
+      float var10 = (this.age + var3) / this.maxAge;
+      var10 *= var10;
+      double var11 = this.item.posX;
+      double var13 = this.item.posY;
+      double var15 = this.item.posZ;
+      double var17 = this.target.lastTickPosX + (this.target.posX - this.target.lastTickPosX) * var3;
+      double var19 = this.target.lastTickPosY + (this.target.posY - this.target.lastTickPosY) * var3 + this.yOffset;
+      double var21 = this.target.lastTickPosZ + (this.target.posZ - this.target.lastTickPosZ) * var3;
+      double var23 = var11 + (var17 - var11) * var10;
+      double var25 = var13 + (var19 - var13) * var10;
+      double var27 = var15 + (var21 - var15) * var10;
+      int var29 = this.getBrightnessForRender(var3);
+      int var30 = var29 % 65536;
+      int var31 = var29 / 65536;
+      OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var30, var31);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      var22 -= interpPosX;
-      var24 -= interpPosY;
-      var26 -= interpPosZ;
+      var23 -= interpPosX;
+      var25 -= interpPosY;
+      var27 -= interpPosZ;
       GlStateManager.enableLighting();
-      this.renderManager.renderEntity(this.item, var22, var24, var26, this.item.rotationYaw, var3, false);
+      this.renderManager.renderEntity(this.item, var23, var25, var27, this.item.rotationYaw, var3, false);
+      if (Config.isShaders()) {
+         Shaders.setEntityId(null);
+         Shaders.useProgram(var9);
+      }
    }
 
-   @Override
    public void onUpdate() {
       this.age++;
       if (this.age == this.maxAge) {
          this.setExpired();
       }
    }
 
-   @Override
    public int getFXLayer() {
       return 3;
    }
 }
--- net/minecraft/client/particle/ParticleLava.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleLava.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleManager.java	Mon Aug 18 09:39:52 2025
@@ -7,14 +7,30 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
+import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.particle.ParticleBreaking.SlimeFactory;
+import net.minecraft.client.particle.ParticleBreaking.SnowballFactory;
+import net.minecraft.client.particle.ParticleCrit.DamageIndicatorFactory;
+import net.minecraft.client.particle.ParticleCrit.MagicFactory;
+import net.minecraft.client.particle.ParticleDrip.LavaFactory;
+import net.minecraft.client.particle.ParticleDrip.WaterFactory;
+import net.minecraft.client.particle.ParticleEnchantmentTable.EnchantmentTable;
+import net.minecraft.client.particle.ParticleExplosion.Factory;
+import net.minecraft.client.particle.ParticleFirework.Spark;
+import net.minecraft.client.particle.ParticleHeart.AngryVillagerFactory;
+import net.minecraft.client.particle.ParticleSpell.AmbientMobFactory;
+import net.minecraft.client.particle.ParticleSpell.InstantFactory;
+import net.minecraft.client.particle.ParticleSpell.MobFactory;
+import net.minecraft.client.particle.ParticleSpell.WitchFactory;
+import net.minecraft.client.particle.ParticleSuspendedTown.HappyVillagerFactory;
 import net.minecraft.client.renderer.ActiveRenderInfo;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.texture.TextureMap;
@@ -28,13 +44,15 @@
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.world.World;
+import net.optifine.reflect.Reflector;
 
 public class ParticleManager {
    private static final ResourceLocation PARTICLE_TEXTURES = new ResourceLocation("textures/particle/particles.png");
    protected World world;
    private final ArrayDeque<Particle>[][] fxLayers = new ArrayDeque[4][];
    private final Queue<ParticleEmitter> particleEmitters = Queues.newArrayDeque();
@@ -56,60 +74,60 @@
       }
 
       this.registerVanillaParticles();
    }
 
    private void registerVanillaParticles() {
-      this.registerParticle(EnumParticleTypes.EXPLOSION_NORMAL.getParticleID(), new ParticleExplosion.Factory());
-      this.registerParticle(EnumParticleTypes.SPIT.getParticleID(), new ParticleSpit.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_BUBBLE.getParticleID(), new ParticleBubble.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_SPLASH.getParticleID(), new ParticleSplash.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_WAKE.getParticleID(), new ParticleWaterWake.Factory());
-      this.registerParticle(EnumParticleTypes.WATER_DROP.getParticleID(), new ParticleRain.Factory());
-      this.registerParticle(EnumParticleTypes.SUSPENDED.getParticleID(), new ParticleSuspend.Factory());
-      this.registerParticle(EnumParticleTypes.SUSPENDED_DEPTH.getParticleID(), new ParticleSuspendedTown.Factory());
-      this.registerParticle(EnumParticleTypes.CRIT.getParticleID(), new ParticleCrit.Factory());
-      this.registerParticle(EnumParticleTypes.CRIT_MAGIC.getParticleID(), new ParticleCrit.MagicFactory());
-      this.registerParticle(EnumParticleTypes.SMOKE_NORMAL.getParticleID(), new ParticleSmokeNormal.Factory());
-      this.registerParticle(EnumParticleTypes.SMOKE_LARGE.getParticleID(), new ParticleSmokeLarge.Factory());
-      this.registerParticle(EnumParticleTypes.SPELL.getParticleID(), new ParticleSpell.Factory());
-      this.registerParticle(EnumParticleTypes.SPELL_INSTANT.getParticleID(), new ParticleSpell.InstantFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_MOB.getParticleID(), new ParticleSpell.MobFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID(), new ParticleSpell.AmbientMobFactory());
-      this.registerParticle(EnumParticleTypes.SPELL_WITCH.getParticleID(), new ParticleSpell.WitchFactory());
-      this.registerParticle(EnumParticleTypes.DRIP_WATER.getParticleID(), new ParticleDrip.WaterFactory());
-      this.registerParticle(EnumParticleTypes.DRIP_LAVA.getParticleID(), new ParticleDrip.LavaFactory());
-      this.registerParticle(EnumParticleTypes.VILLAGER_ANGRY.getParticleID(), new ParticleHeart.AngryVillagerFactory());
-      this.registerParticle(EnumParticleTypes.VILLAGER_HAPPY.getParticleID(), new ParticleSuspendedTown.HappyVillagerFactory());
-      this.registerParticle(EnumParticleTypes.TOWN_AURA.getParticleID(), new ParticleSuspendedTown.Factory());
-      this.registerParticle(EnumParticleTypes.NOTE.getParticleID(), new ParticleNote.Factory());
-      this.registerParticle(EnumParticleTypes.PORTAL.getParticleID(), new ParticlePortal.Factory());
-      this.registerParticle(EnumParticleTypes.ENCHANTMENT_TABLE.getParticleID(), new ParticleEnchantmentTable.EnchantmentTable());
-      this.registerParticle(EnumParticleTypes.FLAME.getParticleID(), new ParticleFlame.Factory());
-      this.registerParticle(EnumParticleTypes.LAVA.getParticleID(), new ParticleLava.Factory());
-      this.registerParticle(EnumParticleTypes.FOOTSTEP.getParticleID(), new ParticleFootStep.Factory());
-      this.registerParticle(EnumParticleTypes.CLOUD.getParticleID(), new ParticleCloud.Factory());
-      this.registerParticle(EnumParticleTypes.REDSTONE.getParticleID(), new ParticleRedstone.Factory());
-      this.registerParticle(EnumParticleTypes.FALLING_DUST.getParticleID(), new ParticleFallingDust.Factory());
-      this.registerParticle(EnumParticleTypes.SNOWBALL.getParticleID(), new ParticleBreaking.SnowballFactory());
-      this.registerParticle(EnumParticleTypes.SNOW_SHOVEL.getParticleID(), new ParticleSnowShovel.Factory());
-      this.registerParticle(EnumParticleTypes.SLIME.getParticleID(), new ParticleBreaking.SlimeFactory());
-      this.registerParticle(EnumParticleTypes.HEART.getParticleID(), new ParticleHeart.Factory());
-      this.registerParticle(EnumParticleTypes.BARRIER.getParticleID(), new Barrier.Factory());
-      this.registerParticle(EnumParticleTypes.ITEM_CRACK.getParticleID(), new ParticleBreaking.Factory());
-      this.registerParticle(EnumParticleTypes.BLOCK_CRACK.getParticleID(), new ParticleDigging.Factory());
-      this.registerParticle(EnumParticleTypes.BLOCK_DUST.getParticleID(), new ParticleBlockDust.Factory());
-      this.registerParticle(EnumParticleTypes.EXPLOSION_HUGE.getParticleID(), new ParticleExplosionHuge.Factory());
-      this.registerParticle(EnumParticleTypes.EXPLOSION_LARGE.getParticleID(), new ParticleExplosionLarge.Factory());
-      this.registerParticle(EnumParticleTypes.FIREWORKS_SPARK.getParticleID(), new ParticleFirework.Factory());
-      this.registerParticle(EnumParticleTypes.MOB_APPEARANCE.getParticleID(), new ParticleMobAppearance.Factory());
-      this.registerParticle(EnumParticleTypes.DRAGON_BREATH.getParticleID(), new ParticleDragonBreath.Factory());
-      this.registerParticle(EnumParticleTypes.END_ROD.getParticleID(), new ParticleEndRod.Factory());
-      this.registerParticle(EnumParticleTypes.DAMAGE_INDICATOR.getParticleID(), new ParticleCrit.DamageIndicatorFactory());
-      this.registerParticle(EnumParticleTypes.SWEEP_ATTACK.getParticleID(), new ParticleSweepAttack.Factory());
-      this.registerParticle(EnumParticleTypes.TOTEM.getParticleID(), new ParticleTotem.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_NORMAL.getParticleID(), new Factory());
+      this.registerParticle(EnumParticleTypes.SPIT.getParticleID(), new net.minecraft.client.particle.ParticleSpit.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_BUBBLE.getParticleID(), new net.minecraft.client.particle.ParticleBubble.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_SPLASH.getParticleID(), new net.minecraft.client.particle.ParticleSplash.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_WAKE.getParticleID(), new net.minecraft.client.particle.ParticleWaterWake.Factory());
+      this.registerParticle(EnumParticleTypes.WATER_DROP.getParticleID(), new net.minecraft.client.particle.ParticleRain.Factory());
+      this.registerParticle(EnumParticleTypes.SUSPENDED.getParticleID(), new net.minecraft.client.particle.ParticleSuspend.Factory());
+      this.registerParticle(EnumParticleTypes.SUSPENDED_DEPTH.getParticleID(), new net.minecraft.client.particle.ParticleSuspendedTown.Factory());
+      this.registerParticle(EnumParticleTypes.CRIT.getParticleID(), new net.minecraft.client.particle.ParticleCrit.Factory());
+      this.registerParticle(EnumParticleTypes.CRIT_MAGIC.getParticleID(), new MagicFactory());
+      this.registerParticle(EnumParticleTypes.SMOKE_NORMAL.getParticleID(), new net.minecraft.client.particle.ParticleSmokeNormal.Factory());
+      this.registerParticle(EnumParticleTypes.SMOKE_LARGE.getParticleID(), new net.minecraft.client.particle.ParticleSmokeLarge.Factory());
+      this.registerParticle(EnumParticleTypes.SPELL.getParticleID(), new net.minecraft.client.particle.ParticleSpell.Factory());
+      this.registerParticle(EnumParticleTypes.SPELL_INSTANT.getParticleID(), new InstantFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_MOB.getParticleID(), new MobFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID(), new AmbientMobFactory());
+      this.registerParticle(EnumParticleTypes.SPELL_WITCH.getParticleID(), new WitchFactory());
+      this.registerParticle(EnumParticleTypes.DRIP_WATER.getParticleID(), new WaterFactory());
+      this.registerParticle(EnumParticleTypes.DRIP_LAVA.getParticleID(), new LavaFactory());
+      this.registerParticle(EnumParticleTypes.VILLAGER_ANGRY.getParticleID(), new AngryVillagerFactory());
+      this.registerParticle(EnumParticleTypes.VILLAGER_HAPPY.getParticleID(), new HappyVillagerFactory());
+      this.registerParticle(EnumParticleTypes.TOWN_AURA.getParticleID(), new net.minecraft.client.particle.ParticleSuspendedTown.Factory());
+      this.registerParticle(EnumParticleTypes.NOTE.getParticleID(), new net.minecraft.client.particle.ParticleNote.Factory());
+      this.registerParticle(EnumParticleTypes.PORTAL.getParticleID(), new net.minecraft.client.particle.ParticlePortal.Factory());
+      this.registerParticle(EnumParticleTypes.ENCHANTMENT_TABLE.getParticleID(), new EnchantmentTable());
+      this.registerParticle(EnumParticleTypes.FLAME.getParticleID(), new net.minecraft.client.particle.ParticleFlame.Factory());
+      this.registerParticle(EnumParticleTypes.LAVA.getParticleID(), new net.minecraft.client.particle.ParticleLava.Factory());
+      this.registerParticle(EnumParticleTypes.FOOTSTEP.getParticleID(), new net.minecraft.client.particle.ParticleFootStep.Factory());
+      this.registerParticle(EnumParticleTypes.CLOUD.getParticleID(), new net.minecraft.client.particle.ParticleCloud.Factory());
+      this.registerParticle(EnumParticleTypes.REDSTONE.getParticleID(), new net.minecraft.client.particle.ParticleRedstone.Factory());
+      this.registerParticle(EnumParticleTypes.FALLING_DUST.getParticleID(), new net.minecraft.client.particle.ParticleFallingDust.Factory());
+      this.registerParticle(EnumParticleTypes.SNOWBALL.getParticleID(), new SnowballFactory());
+      this.registerParticle(EnumParticleTypes.SNOW_SHOVEL.getParticleID(), new net.minecraft.client.particle.ParticleSnowShovel.Factory());
+      this.registerParticle(EnumParticleTypes.SLIME.getParticleID(), new SlimeFactory());
+      this.registerParticle(EnumParticleTypes.HEART.getParticleID(), new net.minecraft.client.particle.ParticleHeart.Factory());
+      this.registerParticle(EnumParticleTypes.BARRIER.getParticleID(), new net.minecraft.client.particle.Barrier.Factory());
+      this.registerParticle(EnumParticleTypes.ITEM_CRACK.getParticleID(), new net.minecraft.client.particle.ParticleBreaking.Factory());
+      this.registerParticle(EnumParticleTypes.BLOCK_CRACK.getParticleID(), new net.minecraft.client.particle.ParticleDigging.Factory());
+      this.registerParticle(EnumParticleTypes.BLOCK_DUST.getParticleID(), new net.minecraft.client.particle.ParticleBlockDust.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_HUGE.getParticleID(), new net.minecraft.client.particle.ParticleExplosionHuge.Factory());
+      this.registerParticle(EnumParticleTypes.EXPLOSION_LARGE.getParticleID(), new net.minecraft.client.particle.ParticleExplosionLarge.Factory());
+      this.registerParticle(EnumParticleTypes.FIREWORKS_SPARK.getParticleID(), new net.minecraft.client.particle.ParticleFirework.Factory());
+      this.registerParticle(EnumParticleTypes.MOB_APPEARANCE.getParticleID(), new net.minecraft.client.particle.ParticleMobAppearance.Factory());
+      this.registerParticle(EnumParticleTypes.DRAGON_BREATH.getParticleID(), new net.minecraft.client.particle.ParticleDragonBreath.Factory());
+      this.registerParticle(EnumParticleTypes.END_ROD.getParticleID(), new net.minecraft.client.particle.ParticleEndRod.Factory());
+      this.registerParticle(EnumParticleTypes.DAMAGE_INDICATOR.getParticleID(), new DamageIndicatorFactory());
+      this.registerParticle(EnumParticleTypes.SWEEP_ATTACK.getParticleID(), new net.minecraft.client.particle.ParticleSweepAttack.Factory());
+      this.registerParticle(EnumParticleTypes.TOTEM.getParticleID(), new net.minecraft.client.particle.ParticleTotem.Factory());
    }
 
    public void registerParticle(int var1, IParticleFactory var2) {
       this.particleTypes.put(var1, var2);
    }
 
@@ -133,26 +151,30 @@
       }
 
       return null;
    }
 
    public void addEffect(Particle var1) {
-      this.queue.add(var1);
+      if (var1 != null) {
+         if (!(var1 instanceof Spark) || Config.isFireworkParticles()) {
+            this.queue.add(var1);
+         }
+      }
    }
 
    public void updateEffects() {
       for (int var1 = 0; var1 < 4; var1++) {
          this.updateEffectLayer(var1);
       }
 
       if (!this.particleEmitters.isEmpty()) {
          ArrayList var4 = Lists.newArrayList();
 
          for (ParticleEmitter var3 : this.particleEmitters) {
             var3.onUpdate();
-            if (!var3.isAlive()) {
+            if (!var3.k()) {
                var4.add(var3);
             }
          }
 
          this.particleEmitters.removeAll(var4);
       }
@@ -162,13 +184,15 @@
             int var6 = var5.getFXLayer();
             int var7 = var5.shouldDisableDepth() ? 0 : 1;
             if (this.fxLayers[var6][var7].size() >= 16384) {
                this.fxLayers[var6][var7].removeFirst();
             }
 
-            this.fxLayers[var6][var7].add(var5);
+            if (!(var5 instanceof Barrier) || !this.reuseBarrierParticle(var5, this.fxLayers[var6][var7])) {
+               this.fxLayers[var6][var7].add(var5);
+            }
          }
       }
    }
 
    private void updateEffectLayer(int var1) {
       this.world.profiler.startSection(String.valueOf(var1));
@@ -181,19 +205,36 @@
 
       this.world.profiler.endSection();
    }
 
    private void tickParticleList(Queue<Particle> var1) {
       if (!var1.isEmpty()) {
-         Iterator var2 = var1.iterator();
+         long var3 = System.currentTimeMillis();
+         int var5 = var1.size();
+         Iterator var6 = var1.iterator();
+
+         while (var6.hasNext()) {
+            Particle var7 = (Particle)var6.next();
+            this.tickParticle(var7);
+            if (!var7.isAlive()) {
+               var6.remove();
+            }
+
+            var5--;
+            if (System.currentTimeMillis() > var3 + 20L) {
+               break;
+            }
+         }
+
+         if (var5 > 0) {
+            int var10 = var5;
 
-         while (var2.hasNext()) {
-            Particle var3 = (Particle)var2.next();
-            this.tickParticle(var3);
-            if (!var3.isAlive()) {
-               var2.remove();
+            for (Iterator var8 = var1.iterator(); var8.hasNext() && var10 > 0; var10--) {
+               Particle var9 = (Particle)var8.next();
+               var9.setExpired();
+               var8.remove();
             }
          }
       }
    }
 
    private void tickParticle(final Particle var1) {
@@ -233,65 +274,71 @@
       Particle.interpPosY = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var2;
       Particle.interpPosZ = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var2;
       Particle.cameraViewDir = var1.getLook(var2);
       GlStateManager.enableBlend();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
       GlStateManager.alphaFunc(516, 0.003921569F);
+      IBlockState var8 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.world, var1, var2);
+      boolean var9 = var8.a() == Material.WATER;
 
-      for (final int var8 = 0; var8 < 3; var8++) {
-         for (int var9 = 0; var9 < 2; var9++) {
-            if (!this.fxLayers[var8][var9].isEmpty()) {
-               switch (var9) {
+      for (int var10 = 0; var10 < 3; var10++) {
+         final int var11 = var10;
+
+         for (int var12 = 0; var12 < 2; var12++) {
+            if (!this.fxLayers[var11][var12].isEmpty()) {
+               switch (var12) {
                   case 0:
                      GlStateManager.depthMask(false);
                      break;
                   case 1:
                      GlStateManager.depthMask(true);
                }
 
-               switch (var8) {
+               switch (var11) {
                   case 0:
                   default:
                      this.renderer.bindTexture(PARTICLE_TEXTURES);
                      break;
                   case 1:
                      this.renderer.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
                }
 
                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-               Tessellator var10 = Tessellator.getInstance();
-               BufferBuilder var11 = var10.getBuffer();
-               var11.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
+               Tessellator var13 = Tessellator.getInstance();
+               BufferBuilder var14 = var13.getBuffer();
+               var14.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
 
-               for (final Particle var13 : this.fxLayers[var8][var9]) {
+               for (final Particle var16 : this.fxLayers[var11][var12]) {
                   try {
-                     var13.renderParticle(var11, var1, var2, var3, var7, var4, var5, var6);
-                  } catch (Throwable var18) {
-                     CrashReport var15 = CrashReport.makeCrashReport(var18, "Rendering Particle");
-                     CrashReportCategory var16 = var15.makeCategory("Particle being rendered");
-                     var16.addDetail("Particle", new ICrashReportDetail<String>() {
+                     if (var9 || !(var16 instanceof ParticleSuspend)) {
+                        var16.renderParticle(var14, var1, var2, var3, var7, var4, var5, var6);
+                     }
+                  } catch (Throwable var20) {
+                     CrashReport var18 = CrashReport.makeCrashReport(var20, "Rendering Particle");
+                     CrashReportCategory var19 = var18.makeCategory("Particle being rendered");
+                     var19.addDetail("Particle", new ICrashReportDetail<String>() {
                         public String call() throws Exception {
-                           return var13.toString();
+                           return var16.toString();
                         }
                      });
-                     var16.addDetail("Particle Type", new ICrashReportDetail<String>() {
+                     var19.addDetail("Particle Type", new ICrashReportDetail<String>() {
                         public String call() throws Exception {
-                           if (var8 == 0) {
+                           if (var11 == 0) {
                               return "MISC_TEXTURE";
-                           } else if (var8 == 1) {
+                           } else if (var11 == 1) {
                               return "TERRAIN_TEXTURE";
                            } else {
-                              return var8 == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + var8;
+                              return var11 == 3 ? "ENTITY_PARTICLE_TEXTURE" : "Unknown - " + var11;
                            }
                         }
                      });
-                     throw new ReportedException(var15);
+                     throw new ReportedException(var18);
                   }
                }
 
-               var10.draw();
+               var13.draw();
             }
          }
       }
 
       GlStateManager.depthMask(true);
       GlStateManager.disableBlend();
@@ -329,40 +376,49 @@
       }
 
       this.particleEmitters.clear();
    }
 
    public void addBlockDestroyEffects(BlockPos var1, IBlockState var2) {
-      if (var2.getMaterial() != Material.AIR) {
-         var2 = var2.getActualState(this.world, var1);
-         byte var3 = 4;
-
-         for (int var4 = 0; var4 < 4; var4++) {
-            for (int var5 = 0; var5 < 4; var5++) {
-               for (int var6 = 0; var6 < 4; var6++) {
-                  double var7 = (var4 + 0.5) / 4.0;
-                  double var9 = (var5 + 0.5) / 4.0;
-                  double var11 = (var6 + 0.5) / 4.0;
+      boolean var3;
+      if (Reflector.ForgeBlock_addDestroyEffects.exists() && Reflector.ForgeBlock_isAir.exists()) {
+         Block var4 = var2.getBlock();
+         var3 = !Reflector.callBoolean(var4, Reflector.ForgeBlock_isAir, new Object[]{var2, this.world, var1})
+            && !Reflector.callBoolean(var4, Reflector.ForgeBlock_addDestroyEffects, new Object[]{this.world, var1, this});
+      } else {
+         var3 = var2.a() != Material.AIR;
+      }
+
+      if (var3) {
+         var2 = var2.c(this.world, var1);
+         byte var15 = 4;
+
+         for (int var5 = 0; var5 < 4; var5++) {
+            for (int var6 = 0; var6 < 4; var6++) {
+               for (int var7 = 0; var7 < 4; var7++) {
+                  double var8 = (var5 + 0.5) / 4.0;
+                  double var10 = (var6 + 0.5) / 4.0;
+                  double var12 = (var7 + 0.5) / 4.0;
                   this.addEffect(
-                     new ParticleDigging(this.world, var1.getX() + var7, var1.getY() + var9, var1.getZ() + var11, var7 - 0.5, var9 - 0.5, var11 - 0.5, var2)
+                     new ParticleDigging(this.world, var1.getX() + var8, var1.getY() + var10, var1.getZ() + var12, var8 - 0.5, var10 - 0.5, var12 - 0.5, var2)
                         .setBlockPos(var1)
                   );
                }
             }
          }
       }
    }
 
    public void addBlockHitEffects(BlockPos var1, EnumFacing var2) {
       IBlockState var3 = this.world.getBlockState(var1);
-      if (var3.getRenderType() != EnumBlockRenderType.INVISIBLE) {
+      if (var3.i() != EnumBlockRenderType.INVISIBLE) {
          int var4 = var1.getX();
          int var5 = var1.getY();
          int var6 = var1.getZ();
          float var7 = 0.1F;
-         AxisAlignedBB var8 = var3.getBoundingBox(this.world, var1);
+         AxisAlignedBB var8 = var3.e(this.world, var1);
          double var9 = var4 + this.rand.nextDouble() * (var8.maxX - var8.minX - 0.2F) + 0.1F + var8.minX;
          double var11 = var5 + this.rand.nextDouble() * (var8.maxY - var8.minY - 0.2F) + 0.1F + var8.minY;
          double var13 = var6 + this.rand.nextDouble() * (var8.maxZ - var8.minZ - 0.2F) + 0.1F + var8.minZ;
          if (var2 == EnumFacing.DOWN) {
             var11 = var5 + var8.minY - 0.1F;
          }
@@ -400,8 +456,29 @@
          for (int var3 = 0; var3 < 2; var3++) {
             var1 += this.fxLayers[var2][var3].size();
          }
       }
 
       return "" + var1;
+   }
+
+   private boolean reuseBarrierParticle(Particle var1, ArrayDeque<Particle> var2) {
+      for (Particle var4 : var2) {
+         if (var4 instanceof Barrier && var1.prevPosX == var4.prevPosX && var1.prevPosY == var4.prevPosY && var1.prevPosZ == var4.prevPosZ) {
+            var4.particleAge = 0;
+            return true;
+         }
+      }
+
+      return false;
+   }
+
+   public void addBlockHitEffects(BlockPos var1, RayTraceResult var2) {
+      IBlockState var3 = this.world.getBlockState(var1);
+      if (var3 != null) {
+         boolean var4 = Reflector.callBoolean(var3.getBlock(), Reflector.ForgeBlock_addHitEffects, new Object[]{var3, this.world, var2, this});
+         if (var3 != null && !var4) {
+            this.addBlockHitEffects(var1, var2.sideHit);
+         }
+      }
    }
 }
--- net/minecraft/client/particle/ParticleMobAppearance.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleMobAppearance.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleNote.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleNote.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticlePortal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticlePortal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleRain.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleRain.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleRedstone.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleRedstone.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSimpleAnimated.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSimpleAnimated.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSmokeLarge.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSmokeLarge.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSmokeNormal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSmokeNormal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSnowShovel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSnowShovel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSpell.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSpell.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSpit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSpit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSplash.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSplash.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSuspend.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSuspend.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSuspendedTown.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSuspendedTown.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleSweepAttack.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleSweepAttack.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleTotem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleTotem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/particle/ParticleWaterWake.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/particle/ParticleWaterWake.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/player/inventory/ContainerLocalMenu.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/player/inventory/ContainerLocalMenu.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/player/inventory/LocalBlockIntercommunication.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/player/inventory/LocalBlockIntercommunication.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/ConditionAnd.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/ConditionAnd.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/ConditionOr.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/ConditionOr.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/ConditionPropertyValue.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/ConditionPropertyValue.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/ICondition.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/ICondition.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/Multipart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/Multipart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/multipart/Selector.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/multipart/Selector.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/BakedQuad.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BakedQuad.java	Mon Aug 18 09:39:52 2025
@@ -1,38 +1,219 @@
 package net.minecraft.client.renderer.block.model;
 
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.util.EnumFacing;
+import net.minecraftforge.client.model.pipeline.IVertexConsumer;
+import net.minecraftforge.client.model.pipeline.IVertexProducer;
+import net.optifine.model.QuadBounds;
+import net.optifine.reflect.Reflector;
 
-public class BakedQuad {
-   protected final int[] vertexData;
+public class BakedQuad implements IVertexProducer {
+   protected int[] vertexData;
    protected final int tintIndex;
-   protected final EnumFacing face;
-   protected final TextureAtlasSprite sprite;
+   protected EnumFacing face;
+   protected TextureAtlasSprite sprite;
+   private int[] vertexDataSingle = null;
+   protected boolean applyDiffuseLighting = Reflector.ForgeHooksClient_fillNormal.exists();
+   protected VertexFormat format = DefaultVertexFormats.ITEM;
+   private QuadBounds quadBounds;
+   private boolean quadEmissiveChecked;
+   private BakedQuad quadEmissive;
+
+   public BakedQuad(int[] var1, int var2, EnumFacing var3, TextureAtlasSprite var4, boolean var5, VertexFormat var6) {
+      this.vertexData = var1;
+      this.tintIndex = var2;
+      this.face = var3;
+      this.sprite = var4;
+      this.applyDiffuseLighting = var5;
+      this.format = var6;
+      this.fixVertexData();
+   }
 
    public BakedQuad(int[] var1, int var2, EnumFacing var3, TextureAtlasSprite var4) {
       this.vertexData = var1;
       this.tintIndex = var2;
       this.face = var3;
       this.sprite = var4;
+      this.fixVertexData();
    }
 
    public TextureAtlasSprite getSprite() {
+      if (this.sprite == null) {
+         this.sprite = getSpriteByUv(this.getVertexData());
+      }
+
       return this.sprite;
    }
 
    public int[] getVertexData() {
+      this.fixVertexData();
       return this.vertexData;
    }
 
    public boolean hasTintIndex() {
       return this.tintIndex != -1;
    }
 
    public int getTintIndex() {
       return this.tintIndex;
    }
 
    public EnumFacing getFace() {
+      if (this.face == null) {
+         this.face = FaceBakery.getFacingFromVertexData(this.getVertexData());
+      }
+
       return this.face;
+   }
+
+   public int[] getVertexDataSingle() {
+      if (this.vertexDataSingle == null) {
+         this.vertexDataSingle = makeVertexDataSingle(this.getVertexData(), this.getSprite());
+      }
+
+      return this.vertexDataSingle;
+   }
+
+   private static int[] makeVertexDataSingle(int[] var0, TextureAtlasSprite var1) {
+      int[] var2 = (int[])var0.clone();
+      int var3 = var2.length / 4;
+
+      for (int var4 = 0; var4 < 4; var4++) {
+         int var5 = var4 * var3;
+         float var6 = Float.intBitsToFloat(var2[var5 + 4]);
+         float var7 = Float.intBitsToFloat(var2[var5 + 4 + 1]);
+         float var8 = var1.toSingleU(var6);
+         float var9 = var1.toSingleV(var7);
+         var2[var5 + 4] = Float.floatToRawIntBits(var8);
+         var2[var5 + 4 + 1] = Float.floatToRawIntBits(var9);
+      }
+
+      return var2;
+   }
+
+   public void pipe(IVertexConsumer var1) {
+      Reflector.callVoid(Reflector.LightUtil_putBakedQuad, new Object[]{var1, this});
+   }
+
+   public VertexFormat getFormat() {
+      return this.format;
+   }
+
+   public boolean shouldApplyDiffuseLighting() {
+      return this.applyDiffuseLighting;
+   }
+
+   private static TextureAtlasSprite getSpriteByUv(int[] var0) {
+      float var1 = 1.0F;
+      float var2 = 1.0F;
+      float var3 = 0.0F;
+      float var4 = 0.0F;
+      int var5 = var0.length / 4;
+
+      for (int var6 = 0; var6 < 4; var6++) {
+         int var7 = var6 * var5;
+         float var8 = Float.intBitsToFloat(var0[var7 + 4]);
+         float var9 = Float.intBitsToFloat(var0[var7 + 4 + 1]);
+         var1 = Math.min(var1, var8);
+         var2 = Math.min(var2, var9);
+         var3 = Math.max(var3, var8);
+         var4 = Math.max(var4, var9);
+      }
+
+      float var10 = (var1 + var3) / 2.0F;
+      float var11 = (var2 + var4) / 2.0F;
+      return Minecraft.getMinecraft().getTextureMapBlocks().getIconByUV(var10, var11);
+   }
+
+   protected void fixVertexData() {
+      if (Config.isShaders()) {
+         if (this.vertexData.length == 28) {
+            this.vertexData = expandVertexData(this.vertexData);
+         }
+      } else if (this.vertexData.length == 56) {
+         this.vertexData = compactVertexData(this.vertexData);
+      }
+   }
+
+   private static int[] expandVertexData(int[] var0) {
+      int var1 = var0.length / 4;
+      int var2 = var1 * 2;
+      int[] var3 = new int[var2 * 4];
+
+      for (int var4 = 0; var4 < 4; var4++) {
+         System.arraycopy(var0, var4 * var1, var3, var4 * var2, var1);
+      }
+
+      return var3;
+   }
+
+   private static int[] compactVertexData(int[] var0) {
+      int var1 = var0.length / 4;
+      int var2 = var1 / 2;
+      int[] var3 = new int[var2 * 4];
+
+      for (int var4 = 0; var4 < 4; var4++) {
+         System.arraycopy(var0, var4 * var1, var3, var4 * var2, var2);
+      }
+
+      return var3;
+   }
+
+   public QuadBounds getQuadBounds() {
+      if (this.quadBounds == null) {
+         this.quadBounds = new QuadBounds(this.getVertexData());
+      }
+
+      return this.quadBounds;
+   }
+
+   public float getMidX() {
+      QuadBounds var1 = this.getQuadBounds();
+      return (var1.getMaxX() + var1.getMinX()) / 2.0F;
+   }
+
+   public double getMidY() {
+      QuadBounds var1 = this.getQuadBounds();
+      return (var1.getMaxY() + var1.getMinY()) / 2.0F;
+   }
+
+   public double getMidZ() {
+      QuadBounds var1 = this.getQuadBounds();
+      return (var1.getMaxZ() + var1.getMinZ()) / 2.0F;
+   }
+
+   public boolean isFaceQuad() {
+      QuadBounds var1 = this.getQuadBounds();
+      return var1.isFaceQuad(this.face);
+   }
+
+   public boolean isFullQuad() {
+      QuadBounds var1 = this.getQuadBounds();
+      return var1.isFullQuad(this.face);
+   }
+
+   public boolean isFullFaceQuad() {
+      return this.isFullQuad() && this.isFaceQuad();
+   }
+
+   public BakedQuad getQuadEmissive() {
+      if (this.quadEmissiveChecked) {
+         return this.quadEmissive;
+      } else {
+         if (this.quadEmissive == null && this.sprite != null && this.sprite.spriteEmissive != null) {
+            this.quadEmissive = new BakedQuadRetextured(this, this.sprite.spriteEmissive);
+         }
+
+         this.quadEmissiveChecked = true;
+         return this.quadEmissive;
+      }
+   }
+
+   @Override
+   public String toString() {
+      return "vertex: " + this.vertexData.length / 7 + ", tint: " + this.tintIndex + ", facing: " + this.face + ", sprite: " + this.sprite;
    }
 }
--- net/minecraft/client/renderer/block/model/BakedQuadRetextured.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BakedQuadRetextured.java	Mon Aug 18 09:39:52 2025
@@ -2,30 +2,43 @@
 
 import java.util.Arrays;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 
 public class BakedQuadRetextured extends BakedQuad {
    private final TextureAtlasSprite texture;
+   private final TextureAtlasSprite spriteOld;
 
    public BakedQuadRetextured(BakedQuad var1, TextureAtlasSprite var2) {
       super(
          Arrays.copyOf(var1.getVertexData(), var1.getVertexData().length),
          var1.tintIndex,
          FaceBakery.getFacingFromVertexData(var1.getVertexData()),
-         var1.getSprite()
+         var2,
+         var1.applyDiffuseLighting,
+         var1.format
       );
       this.texture = var2;
+      this.format = var1.format;
+      this.applyDiffuseLighting = var1.applyDiffuseLighting;
+      this.spriteOld = var1.getSprite();
       this.remapQuad();
+      this.fixVertexData();
    }
 
    private void remapQuad() {
       for (int var1 = 0; var1 < 4; var1++) {
-         int var2 = 7 * var1;
-         this.vertexData[var2 + 4] = Float.floatToRawIntBits(
-            this.texture.getInterpolatedU(this.sprite.getUnInterpolatedU(Float.intBitsToFloat(this.vertexData[var2 + 4])))
+         int var2 = this.format.getIntegerSize() * var1;
+         int var3 = this.format.getUvOffsetById(0) / 4;
+         this.vertexData[var2 + var3] = Float.floatToRawIntBits(
+            this.texture.getInterpolatedU(this.spriteOld.getUnInterpolatedU(Float.intBitsToFloat(this.vertexData[var2 + var3])))
          );
-         this.vertexData[var2 + 4 + 1] = Float.floatToRawIntBits(
-            this.texture.getInterpolatedV(this.sprite.getUnInterpolatedV(Float.intBitsToFloat(this.vertexData[var2 + 4 + 1])))
+         this.vertexData[var2 + var3 + 1] = Float.floatToRawIntBits(
+            this.texture.getInterpolatedV(this.spriteOld.getUnInterpolatedV(Float.intBitsToFloat(this.vertexData[var2 + var3 + 1])))
          );
       }
+   }
+
+   @Override
+   public TextureAtlasSprite getSprite() {
+      return this.texture;
    }
 }
--- net/minecraft/client/renderer/block/model/BlockFaceUV.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BlockFaceUV.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/BlockPart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BlockPart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/BlockPartFace.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BlockPartFace.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/BlockPartRotation.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BlockPartRotation.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/BuiltInModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/BuiltInModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/FaceBakery.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/FaceBakery.java	Mon Aug 18 09:39:52 2025
@@ -1,21 +1,28 @@
 package net.minecraft.client.renderer.block.model;
 
 import javax.annotation.Nullable;
 import net.minecraft.client.renderer.EnumFaceDirection;
+import net.minecraft.client.renderer.EnumFaceDirection.Constants;
+import net.minecraft.client.renderer.EnumFaceDirection.VertexInformation;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3i;
+import net.minecraftforge.common.model.ITransformation;
+import net.optifine.model.BlockModelUtils;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 import org.lwjgl.util.vector.Matrix4f;
 import org.lwjgl.util.vector.Vector3f;
 import org.lwjgl.util.vector.Vector4f;
 
 public class FaceBakery {
    private static final float SCALE_ROTATION_22_5 = 1.0F / (float)Math.cos((float) (Math.PI / 8)) - 1.0F;
-   private static final float SCALE_ROTATION_GENERAL = 1.0F / (float)Math.cos((float) (Math.PI / 4)) - 1.0F;
+   private static final float SCALE_ROTATION_GENERAL = 1.0F / (float)Math.cos(Math.PI / 4) - 1.0F;
    private static final FaceBakery.Rotation[] UV_ROTATIONS = new FaceBakery.Rotation[ModelRotation.values().length * EnumFacing.values().length];
    private static final FaceBakery.Rotation UV_ROTATION_0 = new FaceBakery.Rotation() {
       @Override
       BlockFaceUV makeRotatedUV(float var1, float var2, float var3, float var4) {
          return new BlockFaceUV(new float[]{var1, var2, var3, var4}, 0);
       }
@@ -47,104 +54,147 @@
       EnumFacing var5,
       ModelRotation var6,
       @Nullable BlockPartRotation var7,
       boolean var8,
       boolean var9
    ) {
+      return this.makeBakedQuad(var1, var2, var3, var4, var5, (ITransformation)var6, var7, var8, var9);
+   }
+
+   public BakedQuad makeBakedQuad(
+      Vector3f var1,
+      Vector3f var2,
+      BlockPartFace var3,
+      TextureAtlasSprite var4,
+      EnumFacing var5,
+      ITransformation var6,
+      BlockPartRotation var7,
+      boolean var8,
+      boolean var9
+   ) {
       BlockFaceUV var10 = var3.blockFaceUV;
       if (var8) {
-         var10 = this.applyUVLock(var3.blockFaceUV, var5, var6);
+         if (Reflector.ForgeHooksClient_applyUVLock.exists()) {
+            var10 = (BlockFaceUV)Reflector.call(Reflector.ForgeHooksClient_applyUVLock, new Object[]{var3.blockFaceUV, var5, var6});
+         } else {
+            var10 = this.applyUVLock(var3.blockFaceUV, var5, (ModelRotation)var6);
+         }
       }
 
-      int[] var11 = this.makeQuadVertexData(var10, var4, var5, this.getPositionsDiv16(var1, var2), var6, var7, var9);
-      EnumFacing var12 = getFacingFromVertexData(var11);
+      boolean var11 = var9 && !Reflector.ForgeHooksClient_fillNormal.exists();
+      int[] var12 = this.makeQuadVertexData(var10, var4, var5, this.getPositionsDiv16(var1, var2), var6, var7, var11);
+      EnumFacing var13 = getFacingFromVertexData(var12);
       if (var7 == null) {
-         this.applyFacing(var11, var12);
+         this.applyFacing(var12, var13);
       }
 
-      return new BakedQuad(var11, var3.tintIndex, var12, var4);
+      if (Reflector.ForgeHooksClient_fillNormal.exists()) {
+         Reflector.call(Reflector.ForgeHooksClient_fillNormal, new Object[]{var12, var13});
+         return new BakedQuad(var12, var3.tintIndex, var13, var4, var9, DefaultVertexFormats.ITEM);
+      } else {
+         return new BakedQuad(var12, var3.tintIndex, var13, var4);
+      }
    }
 
    private BlockFaceUV applyUVLock(BlockFaceUV var1, EnumFacing var2, ModelRotation var3) {
       return UV_ROTATIONS[getIndex(var3, var2)].rotateUV(var1);
    }
 
    private int[] makeQuadVertexData(
-      BlockFaceUV var1, TextureAtlasSprite var2, EnumFacing var3, float[] var4, ModelRotation var5, @Nullable BlockPartRotation var6, boolean var7
+      BlockFaceUV var1, TextureAtlasSprite var2, EnumFacing var3, float[] var4, ITransformation var5, @Nullable BlockPartRotation var6, boolean var7
    ) {
-      int[] var8 = new int[28];
+      byte var8 = 28;
+      if (Config.isShaders()) {
+         var8 = 56;
+      }
+
+      int[] var9 = new int[var8];
 
-      for (int var9 = 0; var9 < 4; var9++) {
-         this.fillVertexData(var8, var9, var3, var1, var4, var2, var5, var6, var7);
+      for (int var10 = 0; var10 < 4; var10++) {
+         this.fillVertexData(var9, var10, var3, var1, var4, var2, var5, var6, var7);
       }
 
-      return var8;
+      return var9;
    }
 
    private int getFaceShadeColor(EnumFacing var1) {
-      float var2 = this.getFaceBrightness(var1);
+      float var2 = getFaceBrightness(var1);
       int var3 = MathHelper.clamp((int)(var2 * 255.0F), 0, 255);
       return 0xFF000000 | var3 << 16 | var3 << 8 | var3;
    }
 
-   private float getFaceBrightness(EnumFacing var1) {
-      switch (var1) {
+   public static float getFaceBrightness(EnumFacing var0) {
+      switch (var0) {
          case DOWN:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel05;
+            }
+
             return 0.5F;
          case UP:
             return 1.0F;
          case NORTH:
          case SOUTH:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel08;
+            }
+
             return 0.8F;
          case WEST:
          case EAST:
+            if (Config.isShaders()) {
+               return Shaders.blockLightLevel06;
+            }
+
             return 0.6F;
          default:
             return 1.0F;
       }
    }
 
    private float[] getPositionsDiv16(Vector3f var1, Vector3f var2) {
       float[] var3 = new float[EnumFacing.values().length];
-      var3[EnumFaceDirection.Constants.WEST_INDEX] = var1.x / 16.0F;
-      var3[EnumFaceDirection.Constants.DOWN_INDEX] = var1.y / 16.0F;
-      var3[EnumFaceDirection.Constants.NORTH_INDEX] = var1.z / 16.0F;
-      var3[EnumFaceDirection.Constants.EAST_INDEX] = var2.x / 16.0F;
-      var3[EnumFaceDirection.Constants.UP_INDEX] = var2.y / 16.0F;
-      var3[EnumFaceDirection.Constants.SOUTH_INDEX] = var2.z / 16.0F;
+      var3[Constants.WEST_INDEX] = var1.x / 16.0F;
+      var3[Constants.DOWN_INDEX] = var1.y / 16.0F;
+      var3[Constants.NORTH_INDEX] = var1.z / 16.0F;
+      var3[Constants.EAST_INDEX] = var2.x / 16.0F;
+      var3[Constants.UP_INDEX] = var2.y / 16.0F;
+      var3[Constants.SOUTH_INDEX] = var2.z / 16.0F;
       return var3;
    }
 
    private void fillVertexData(
       int[] var1,
       int var2,
       EnumFacing var3,
       BlockFaceUV var4,
       float[] var5,
       TextureAtlasSprite var6,
-      ModelRotation var7,
+      ITransformation var7,
       @Nullable BlockPartRotation var8,
       boolean var9
    ) {
-      EnumFacing var10 = var7.rotateFace(var3);
+      EnumFacing var10 = var7.rotate(var3);
       int var11 = var9 ? this.getFaceShadeColor(var10) : -1;
-      EnumFaceDirection.VertexInformation var12 = EnumFaceDirection.getFacing(var3).getVertexInformation(var2);
+      VertexInformation var12 = EnumFaceDirection.getFacing(var3).getVertexInformation(var2);
       Vector3f var13 = new Vector3f(var5[var12.xIndex], var5[var12.yIndex], var5[var12.zIndex]);
       this.rotatePart(var13, var8);
       int var14 = this.rotateVertex(var13, var3, var2, var7);
+      BlockModelUtils.snapVertexPosition(var13);
       this.storeVertexData(var1, var14, var2, var13, var11, var6, var4);
    }
 
    private void storeVertexData(int[] var1, int var2, int var3, Vector3f var4, int var5, TextureAtlasSprite var6, BlockFaceUV var7) {
-      int var8 = var2 * 7;
-      var1[var8] = Float.floatToRawIntBits(var4.x);
-      var1[var8 + 1] = Float.floatToRawIntBits(var4.y);
-      var1[var8 + 2] = Float.floatToRawIntBits(var4.z);
-      var1[var8 + 3] = var5;
-      var1[var8 + 4] = Float.floatToRawIntBits(var6.getInterpolatedU(var7.getVertexU(var3)));
-      var1[var8 + 4 + 1] = Float.floatToRawIntBits(var6.getInterpolatedV(var7.getVertexV(var3)));
+      int var8 = var1.length / 4;
+      int var9 = var2 * var8;
+      var1[var9] = Float.floatToRawIntBits(var4.x);
+      var1[var9 + 1] = Float.floatToRawIntBits(var4.y);
+      var1[var9 + 2] = Float.floatToRawIntBits(var4.z);
+      var1[var9 + 3] = var5;
+      var1[var9 + 4] = Float.floatToRawIntBits(var6.getInterpolatedU(var7.getVertexU(var3) * 0.999 + var7.getVertexU((var3 + 2) % 4) * 0.001));
+      var1[var9 + 4 + 1] = Float.floatToRawIntBits(var6.getInterpolatedV(var7.getVertexV(var3) * 0.999 + var7.getVertexV((var3 + 2) % 4) * 0.001));
    }
 
    private void rotatePart(Vector3f var1, @Nullable BlockPartRotation var2) {
       if (var2 != null) {
          Matrix4f var3 = this.getMatrixIdentity();
          Vector3f var4 = new Vector3f(0.0F, 0.0F, 0.0F);
@@ -176,17 +226,26 @@
 
          this.rotateScale(var1, new Vector3f(var2.origin), var3, var4);
       }
    }
 
    public int rotateVertex(Vector3f var1, EnumFacing var2, int var3, ModelRotation var4) {
+      return this.rotateVertex(var1, var2, var3, (ITransformation)var4);
+   }
+
+   public int rotateVertex(Vector3f var1, EnumFacing var2, int var3, ITransformation var4) {
       if (var4 == ModelRotation.X0_Y0) {
          return var3;
       } else {
-         this.rotateScale(var1, new Vector3f(0.5F, 0.5F, 0.5F), var4.matrix(), new Vector3f(1.0F, 1.0F, 1.0F));
-         return var4.rotateVertex(var2, var3);
+         if (Reflector.ForgeHooksClient_transform.exists()) {
+            Reflector.call(Reflector.ForgeHooksClient_transform, new Object[]{var1, var4.getMatrix()});
+         } else {
+            this.rotateScale(var1, new Vector3f(0.5F, 0.5F, 0.5F), ((ModelRotation)var4).matrix(), new Vector3f(1.0F, 1.0F, 1.0F));
+         }
+
+         return var4.rotate(var2, var3);
       }
    }
 
    private void rotateScale(Vector3f var1, Vector3f var2, Matrix4f var3, Vector3f var4) {
       Vector4f var5 = new Vector4f(var1.x - var2.x, var1.y - var2.y, var1.z - var2.z, 1.0F);
       Matrix4f.transform(var3, var5, var5);
@@ -200,102 +259,105 @@
       Matrix4f var1 = new Matrix4f();
       var1.setIdentity();
       return var1;
    }
 
    public static EnumFacing getFacingFromVertexData(int[] var0) {
-      Vector3f var1 = new Vector3f(Float.intBitsToFloat(var0[0]), Float.intBitsToFloat(var0[1]), Float.intBitsToFloat(var0[2]));
-      Vector3f var2 = new Vector3f(Float.intBitsToFloat(var0[7]), Float.intBitsToFloat(var0[8]), Float.intBitsToFloat(var0[9]));
-      Vector3f var3 = new Vector3f(Float.intBitsToFloat(var0[14]), Float.intBitsToFloat(var0[15]), Float.intBitsToFloat(var0[16]));
-      Vector3f var4 = new Vector3f();
-      Vector3f var5 = new Vector3f();
+      int var1 = var0.length / 4;
+      int var2 = var1 * 2;
+      Vector3f var3 = new Vector3f(Float.intBitsToFloat(var0[0]), Float.intBitsToFloat(var0[1]), Float.intBitsToFloat(var0[2]));
+      Vector3f var4 = new Vector3f(Float.intBitsToFloat(var0[var1]), Float.intBitsToFloat(var0[var1 + 1]), Float.intBitsToFloat(var0[var1 + 2]));
+      Vector3f var5 = new Vector3f(Float.intBitsToFloat(var0[var2]), Float.intBitsToFloat(var0[var2 + 1]), Float.intBitsToFloat(var0[var2 + 2]));
       Vector3f var6 = new Vector3f();
-      Vector3f.sub(var1, var2, var4);
-      Vector3f.sub(var3, var2, var5);
-      Vector3f.cross(var5, var4, var6);
-      float var7 = (float)Math.sqrt(var6.x * var6.x + var6.y * var6.y + var6.z * var6.z);
-      var6.x /= var7;
-      var6.y /= var7;
-      var6.z /= var7;
-      EnumFacing var8 = null;
-      float var9 = 0.0F;
-
-      for (EnumFacing var13 : EnumFacing.values()) {
-         Vec3i var14 = var13.getDirectionVec();
-         Vector3f var15 = new Vector3f(var14.getX(), var14.getY(), var14.getZ());
-         float var16 = Vector3f.dot(var6, var15);
-         if (var16 >= 0.0F && var16 > var9) {
-            var9 = var16;
-            var8 = var13;
+      Vector3f var7 = new Vector3f();
+      Vector3f var8 = new Vector3f();
+      Vector3f.sub(var3, var4, var6);
+      Vector3f.sub(var5, var4, var7);
+      Vector3f.cross(var7, var6, var8);
+      float var9 = (float)Math.sqrt(var8.x * var8.x + var8.y * var8.y + var8.z * var8.z);
+      var8.x /= var9;
+      var8.y /= var9;
+      var8.z /= var9;
+      EnumFacing var10 = null;
+      float var11 = 0.0F;
+
+      for (EnumFacing var15 : EnumFacing.values()) {
+         Vec3i var16 = var15.getDirectionVec();
+         Vector3f var17 = new Vector3f(var16.getX(), var16.getY(), var16.getZ());
+         float var18 = Vector3f.dot(var8, var17);
+         if (var18 >= 0.0F && var18 > var11) {
+            var11 = var18;
+            var10 = var15;
          }
       }
 
-      return var8 == null ? EnumFacing.UP : var8;
+      return var10 == null ? EnumFacing.UP : var10;
    }
 
    private void applyFacing(int[] var1, EnumFacing var2) {
       int[] var3 = new int[var1.length];
       System.arraycopy(var1, 0, var3, 0, var1.length);
       float[] var4 = new float[EnumFacing.values().length];
-      var4[EnumFaceDirection.Constants.WEST_INDEX] = 999.0F;
-      var4[EnumFaceDirection.Constants.DOWN_INDEX] = 999.0F;
-      var4[EnumFaceDirection.Constants.NORTH_INDEX] = 999.0F;
-      var4[EnumFaceDirection.Constants.EAST_INDEX] = -999.0F;
-      var4[EnumFaceDirection.Constants.UP_INDEX] = -999.0F;
-      var4[EnumFaceDirection.Constants.SOUTH_INDEX] = -999.0F;
-
-      for (int var5 = 0; var5 < 4; var5++) {
-         int var6 = 7 * var5;
-         float var7 = Float.intBitsToFloat(var3[var6]);
-         float var8 = Float.intBitsToFloat(var3[var6 + 1]);
-         float var9 = Float.intBitsToFloat(var3[var6 + 2]);
-         if (var7 < var4[EnumFaceDirection.Constants.WEST_INDEX]) {
-            var4[EnumFaceDirection.Constants.WEST_INDEX] = var7;
+      var4[Constants.WEST_INDEX] = 999.0F;
+      var4[Constants.DOWN_INDEX] = 999.0F;
+      var4[Constants.NORTH_INDEX] = 999.0F;
+      var4[Constants.EAST_INDEX] = -999.0F;
+      var4[Constants.UP_INDEX] = -999.0F;
+      var4[Constants.SOUTH_INDEX] = -999.0F;
+      int var5 = var1.length / 4;
+
+      for (int var6 = 0; var6 < 4; var6++) {
+         int var7 = var5 * var6;
+         float var8 = Float.intBitsToFloat(var3[var7]);
+         float var9 = Float.intBitsToFloat(var3[var7 + 1]);
+         float var10 = Float.intBitsToFloat(var3[var7 + 2]);
+         if (var8 < var4[Constants.WEST_INDEX]) {
+            var4[Constants.WEST_INDEX] = var8;
          }
 
-         if (var8 < var4[EnumFaceDirection.Constants.DOWN_INDEX]) {
-            var4[EnumFaceDirection.Constants.DOWN_INDEX] = var8;
+         if (var9 < var4[Constants.DOWN_INDEX]) {
+            var4[Constants.DOWN_INDEX] = var9;
          }
 
-         if (var9 < var4[EnumFaceDirection.Constants.NORTH_INDEX]) {
-            var4[EnumFaceDirection.Constants.NORTH_INDEX] = var9;
+         if (var10 < var4[Constants.NORTH_INDEX]) {
+            var4[Constants.NORTH_INDEX] = var10;
          }
 
-         if (var7 > var4[EnumFaceDirection.Constants.EAST_INDEX]) {
-            var4[EnumFaceDirection.Constants.EAST_INDEX] = var7;
+         if (var8 > var4[Constants.EAST_INDEX]) {
+            var4[Constants.EAST_INDEX] = var8;
          }
 
-         if (var8 > var4[EnumFaceDirection.Constants.UP_INDEX]) {
-            var4[EnumFaceDirection.Constants.UP_INDEX] = var8;
+         if (var9 > var4[Constants.UP_INDEX]) {
+            var4[Constants.UP_INDEX] = var9;
          }
 
-         if (var9 > var4[EnumFaceDirection.Constants.SOUTH_INDEX]) {
-            var4[EnumFaceDirection.Constants.SOUTH_INDEX] = var9;
+         if (var10 > var4[Constants.SOUTH_INDEX]) {
+            var4[Constants.SOUTH_INDEX] = var10;
          }
       }
 
-      EnumFaceDirection var17 = EnumFaceDirection.getFacing(var2);
-
-      for (int var18 = 0; var18 < 4; var18++) {
-         int var19 = 7 * var18;
-         EnumFaceDirection.VertexInformation var20 = var17.getVertexInformation(var18);
-         float var21 = var4[var20.xIndex];
-         float var10 = var4[var20.yIndex];
-         float var11 = var4[var20.zIndex];
-         var1[var19] = Float.floatToRawIntBits(var21);
-         var1[var19 + 1] = Float.floatToRawIntBits(var10);
-         var1[var19 + 2] = Float.floatToRawIntBits(var11);
+      EnumFaceDirection var18 = EnumFaceDirection.getFacing(var2);
 
-         for (int var12 = 0; var12 < 4; var12++) {
-            int var13 = 7 * var12;
-            float var14 = Float.intBitsToFloat(var3[var13]);
-            float var15 = Float.intBitsToFloat(var3[var13 + 1]);
-            float var16 = Float.intBitsToFloat(var3[var13 + 2]);
-            if (MathHelper.epsilonEquals(var21, var14) && MathHelper.epsilonEquals(var10, var15) && MathHelper.epsilonEquals(var11, var16)) {
-               var1[var19 + 4] = var3[var13 + 4];
-               var1[var19 + 4 + 1] = var3[var13 + 4 + 1];
+      for (int var19 = 0; var19 < 4; var19++) {
+         int var20 = var5 * var19;
+         VertexInformation var21 = var18.getVertexInformation(var19);
+         float var22 = var4[var21.xIndex];
+         float var11 = var4[var21.yIndex];
+         float var12 = var4[var21.zIndex];
+         var1[var20] = Float.floatToRawIntBits(var22);
+         var1[var20 + 1] = Float.floatToRawIntBits(var11);
+         var1[var20 + 2] = Float.floatToRawIntBits(var12);
+
+         for (int var13 = 0; var13 < 4; var13++) {
+            int var14 = var5 * var13;
+            float var15 = Float.intBitsToFloat(var3[var14]);
+            float var16 = Float.intBitsToFloat(var3[var14 + 1]);
+            float var17 = Float.intBitsToFloat(var3[var14 + 2]);
+            if (MathHelper.epsilonEquals(var22, var15) && MathHelper.epsilonEquals(var11, var16) && MathHelper.epsilonEquals(var12, var17)) {
+               var1[var20 + 4] = var3[var14 + 4];
+               var1[var20 + 4 + 1] = var3[var14 + 4 + 1];
             }
          }
       }
    }
 
    private static void addUvRotation(ModelRotation var0, EnumFacing var1, FaceBakery.Rotation var2) {
--- net/minecraft/client/renderer/block/model/IBakedModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/IBakedModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ItemCameraTransforms.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ItemCameraTransforms.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ItemModelGenerator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ItemModelGenerator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ItemOverride.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ItemOverride.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ItemOverrideList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ItemOverrideList.java	Mon Aug 18 09:39:52 2025
@@ -1,36 +1,76 @@
 package net.minecraft.client.renderer.block.model;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.util.List;
 import javax.annotation.Nullable;
+import net.minecraft.client.Minecraft;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.world.World;
+import net.optifine.ItemOverrideCache;
+import net.optifine.reflect.Reflector;
 
 public class ItemOverrideList {
    public static final ItemOverrideList NONE = new ItemOverrideList();
    private final List<ItemOverride> overrides = Lists.newArrayList();
+   private ItemOverrideCache itemOverrideCache;
 
    private ItemOverrideList() {
    }
 
    public ItemOverrideList(List<ItemOverride> var1) {
       for (int var2 = var1.size() - 1; var2 >= 0; var2--) {
          this.overrides.add((ItemOverride)var1.get(var2));
       }
+
+      if (this.overrides.size() > 65) {
+         this.itemOverrideCache = ItemOverrideCache.make(this.overrides);
+      }
    }
 
    @Nullable
    public ResourceLocation applyOverride(ItemStack var1, @Nullable World var2, @Nullable EntityLivingBase var3) {
       if (!this.overrides.isEmpty()) {
+         if (this.itemOverrideCache != null) {
+            ResourceLocation var4 = this.itemOverrideCache.getModelLocation(var1, var2, var3);
+            if (var4 != null) {
+               return var4 == ItemOverrideCache.LOCATION_NULL ? null : var4;
+            }
+         }
+
          for (ItemOverride var5 : this.overrides) {
             if (var5.matchesItemStack(var1, var2, var3)) {
+               if (this.itemOverrideCache != null) {
+                  this.itemOverrideCache.putModelLocation(var1, var2, var3, var5.getLocation());
+               }
+
                return var5.getLocation();
             }
          }
+
+         if (this.itemOverrideCache != null) {
+            this.itemOverrideCache.putModelLocation(var1, var2, var3, ItemOverrideCache.LOCATION_NULL);
+         }
       }
 
       return null;
+   }
+
+   public IBakedModel handleItemState(IBakedModel var1, ItemStack var2, @Nullable World var3, @Nullable EntityLivingBase var4) {
+      if (!var2.isEmpty() && var2.getItem().hasCustomProperties()) {
+         ResourceLocation var5 = this.applyOverride(var2, var3, var4);
+         if (var5 != null && Reflector.ModelLoader_getInventoryVariant.exists()) {
+            ModelResourceLocation var6 = (ModelResourceLocation)Reflector.call(Reflector.ModelLoader_getInventoryVariant, new Object[]{var5.toString()});
+            return Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager().getModel(var6);
+         }
+      }
+
+      return var1;
+   }
+
+   public ImmutableList<ItemOverride> getOverrides() {
+      return ImmutableList.copyOf(this.overrides);
    }
 }
--- net/minecraft/client/renderer/block/model/ItemTransformVec3f.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ItemTransformVec3f.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ModelBakery.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelBakery.java	Mon Aug 18 09:39:52 2025
@@ -25,12 +25,13 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.client.renderer.BlockModelShapes;
+import net.minecraft.client.renderer.block.model.MultipartBakedModel.Builder;
 import net.minecraft.client.renderer.block.model.multipart.Multipart;
 import net.minecraft.client.renderer.block.model.multipart.Selector;
 import net.minecraft.client.renderer.block.statemap.BlockStateMapper;
 import net.minecraft.client.renderer.texture.ITextureMapPopulator;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
@@ -40,12 +41,19 @@
 import net.minecraft.init.Items;
 import net.minecraft.item.Item;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.registry.IRegistry;
 import net.minecraft.util.registry.RegistrySimple;
+import net.minecraftforge.common.model.ITransformation;
+import net.minecraftforge.common.model.TRSRTransformation;
+import net.minecraftforge.registries.IRegistryDelegate;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.util.StrUtils;
+import net.optifine.util.TextureUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class ModelBakery {
    private static final Set<ResourceLocation> LOCATIONS_BUILTIN_TEXTURES = Sets.newHashSet(
@@ -100,20 +108,21 @@
    private final Map<ModelResourceLocation, VariantList> variants = Maps.newLinkedHashMap();
    private final Map<ModelBlockDefinition, Collection<ModelResourceLocation>> multipartVariantMap = Maps.newLinkedHashMap();
    private final TextureMap textureMap;
    private final BlockModelShapes blockModelShapes;
    private final FaceBakery faceBakery = new FaceBakery();
    private final ItemModelGenerator itemModelGenerator = new ItemModelGenerator();
-   private final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple<>();
+   private final RegistrySimple<ModelResourceLocation, IBakedModel> bakedRegistry = new RegistrySimple();
    private static final String EMPTY_MODEL_RAW = "{    'elements': [        {   'from': [0, 0, 0],            'to': [16, 16, 16],            'faces': {                'down': {'uv': [0, 0, 16, 16], 'texture': '' }            }        }    ]}"
       .replaceAll("'", "\"");
    private static final ModelBlock MODEL_GENERATED = ModelBlock.deserialize(EMPTY_MODEL_RAW);
    private static final ModelBlock MODEL_ENTITY = ModelBlock.deserialize(EMPTY_MODEL_RAW);
    private final Map<String, ResourceLocation> itemLocations = Maps.newLinkedHashMap();
    private final Map<ResourceLocation, ModelBlockDefinition> blockDefinitions = Maps.newHashMap();
    private final Map<Item, List<String>> variantNames = Maps.newIdentityHashMap();
+   private static Map<IRegistryDelegate<Item>, Set<String>> customVariantNames = Maps.newHashMap();
 
    public ModelBakery(IResourceManager var1, TextureMap var2, BlockModelShapes var3) {
       this.resourceManager = var1;
       this.textureMap = var2;
       this.blockModelShapes = var3;
    }
@@ -130,46 +139,54 @@
    }
 
    private void loadBlocks() {
       BlockStateMapper var1 = this.blockModelShapes.getBlockStateMapper();
 
       for (Block var3 : Block.REGISTRY) {
-         for (final ResourceLocation var5 : var1.getBlockstateLocations(var3)) {
+         for (ResourceLocation var5 : var1.getBlockstateLocations(var3)) {
             try {
-               ModelBlockDefinition var6 = this.getModelBlockDefinition(var5);
-               Map var7 = var1.getVariants(var3);
-               if (var6.hasMultipartData()) {
-                  HashSet var8 = Sets.newHashSet(var7.values());
-                  var6.getMultipartData().setStateContainer(var3.getBlockState());
-                  Object var9 = this.multipartVariantMap.get(var6);
-                  if (var9 == null) {
-                     var9 = Lists.newArrayList();
-                     this.multipartVariantMap.put(var6, (Collection<ModelResourceLocation>)var9);
-                  }
+               this.loadBlock(var1, var3, var5);
+            } catch (Exception var7) {
+               LOGGER.warn("Unable to load definition " + var5, var7);
+            }
+         }
+      }
+   }
 
-                  var9.addAll(Lists.newArrayList(Iterables.filter(var8, new Predicate<ModelResourceLocation>() {
-                     public boolean apply(@Nullable ModelResourceLocation var1) {
-                        return var5.equals(var1);
-                     }
-                  })));
-               }
-
-               for (Entry var15 : var7.entrySet()) {
-                  ModelResourceLocation var10 = (ModelResourceLocation)var15.getValue();
-                  if (var5.equals(var10)) {
-                     try {
-                        this.variants.put(var10, var6.getVariant(var10.getVariant()));
-                     } catch (RuntimeException var12) {
-                        if (!var6.hasMultipartData()) {
-                           LOGGER.warn("Unable to load variant: {} from {}", var10.getVariant(), var10);
-                        }
-                     }
-                  }
+   protected void loadBlock(BlockStateMapper var1, Block var2, final ResourceLocation var3) {
+      ModelBlockDefinition var4 = this.getModelBlockDefinition(var3);
+      Map var5 = var1.getVariants(var2);
+      if (var4.hasMultipartData()) {
+         HashSet var6 = Sets.newHashSet(var5.values());
+         var4.getMultipartData().setStateContainer(var2.getBlockState());
+         Object var7 = this.multipartVariantMap.get(var4);
+         if (var7 == null) {
+            var7 = Lists.newArrayList();
+         }
+
+         var7.addAll(Lists.newArrayList(Iterables.filter(var6, new Predicate<ModelResourceLocation>() {
+            public boolean apply(@Nullable ModelResourceLocation var1) {
+               return var3.equals(var1);
+            }
+         })));
+         this.registerMultipartVariant(var4, (Collection<ModelResourceLocation>)var7);
+      }
+
+      for (Entry var12 : var5.entrySet()) {
+         ModelResourceLocation var8 = (ModelResourceLocation)var12.getValue();
+         if (var3.equals(var8)) {
+            try {
+               if (Reflector.ForgeItem_delegate.exists()) {
+                  this.registerVariant(var4, var8);
+               } else {
+                  this.variants.put(var8, var4.getVariant(var8.getVariant()));
+               }
+            } catch (RuntimeException var10) {
+               if (!var4.hasMultipartData()) {
+                  LOGGER.warn("Unable to load variant: " + var8.getVariant() + " from " + var8, var10);
                }
-            } catch (Exception var13) {
-               LOGGER.warn("Unable to load definition {}", var5, var13);
             }
          }
       }
    }
 
    private void loadVariantItemModels() {
@@ -179,12 +196,14 @@
             new VariantList(Lists.newArrayList(new Variant[]{new Variant(new ResourceLocation(MODEL_MISSING.getPath()), ModelRotation.X0_Y0, false, 1)}))
          );
       this.loadStaticModels();
       this.loadVariantModels();
       this.loadMultipartVariantModels();
       this.loadItemModels();
+      CustomItems.update();
+      CustomItems.loadModels(this);
    }
 
    private void loadStaticModels() {
       ResourceLocation var1 = new ResourceLocation("item_frame");
       ModelBlockDefinition var2 = this.getModelBlockDefinition(var1);
       this.registerVariant(var2, new ModelResourceLocation(var1, "normal"));
@@ -229,23 +248,29 @@
    private ModelBlockDefinition loadModelBlockDefinition(ResourceLocation var1, IResource var2) {
       InputStream var3 = null;
 
       ModelBlockDefinition var4;
       try {
          var3 = var2.getInputStream();
-         var4 = ModelBlockDefinition.parseFromReader(new InputStreamReader(var3, StandardCharsets.UTF_8));
-      } catch (Exception var8) {
+         if (Reflector.ForgeModelBlockDefinition_parseFromReader2.exists()) {
+            var4 = (ModelBlockDefinition)Reflector.call(
+               Reflector.ForgeModelBlockDefinition_parseFromReader2, new Object[]{new InputStreamReader(var3, StandardCharsets.UTF_8), var1}
+            );
+         } else {
+            var4 = ModelBlockDefinition.parseFromReader(new InputStreamReader(var3, StandardCharsets.UTF_8));
+         }
+      } catch (Exception var9) {
          throw new RuntimeException(
             "Encountered an exception when loading model definition of '"
                + var1
                + "' from: '"
                + var2.getResourceLocation()
                + "' in resourcepack: '"
                + var2.getResourcePackName()
                + "'",
-            var8
+            var9
          );
       } finally {
          IOUtils.closeQuietly(var3);
       }
 
       return var4;
@@ -285,84 +310,99 @@
    }
 
    private ModelBlock loadModel(ResourceLocation var1) throws IOException {
       Object var2 = null;
       IResource var3 = null;
 
-      ModelBlock var5;
+      ModelBlock var6;
       try {
-         String var4 = var1.getPath();
-         if ("builtin/generated".equals(var4)) {
+         String var5 = var1.getPath();
+         if ("builtin/generated".equals(var5)) {
             return MODEL_GENERATED;
          }
 
-         if (!"builtin/entity".equals(var4)) {
-            if (var4.startsWith("builtin/")) {
-               String var10 = var4.substring("builtin/".length());
-               String var6 = BUILT_IN_MODELS.get(var10);
-               if (var6 == null) {
+         if (!"builtin/entity".equals(var5)) {
+            if (var5.startsWith("builtin/")) {
+               String var14 = var5.substring("builtin/".length());
+               String var7 = BUILT_IN_MODELS.get(var14);
+               if (var7 == null) {
                   throw new FileNotFoundException(var1.toString());
                }
 
-               var2 = new StringReader(var6);
+               var2 = new StringReader(var7);
             } else {
-               var3 = this.resourceManager.getResource(this.getModelLocation(var1));
+               var1 = this.getModelLocation(var1);
+               var3 = this.resourceManager.getResource(var1);
                var2 = new InputStreamReader(var3.getInputStream(), StandardCharsets.UTF_8);
             }
 
-            var5 = ModelBlock.deserialize((Reader)var2);
-            var5.name = var1.toString();
-            return var5;
+            ModelBlock var12 = ModelBlock.deserialize((Reader)var2);
+            var12.name = var1.toString();
+            String var15 = TextureUtils.getBasePath(var1.getPath());
+            fixModelLocations(var12, var15);
+            return var12;
          }
 
-         var5 = MODEL_ENTITY;
+         ModelBlock var4 = MODEL_ENTITY;
+         var6 = var4;
       } finally {
          IOUtils.closeQuietly((Reader)var2);
          IOUtils.closeQuietly(var3);
       }
 
-      return var5;
+      return var6;
    }
 
    private ResourceLocation getModelLocation(ResourceLocation var1) {
-      return new ResourceLocation(var1.getNamespace(), "models/" + var1.getPath() + ".json");
+      String var2 = var1.getPath();
+      if (!var2.startsWith("mcpatcher") && !var2.startsWith("optifine")) {
+         return new ResourceLocation(var1.getNamespace(), "models/" + var1.getPath() + ".json");
+      } else {
+         if (!var2.endsWith(".json")) {
+            var1 = new ResourceLocation(var1.getNamespace(), var2 + ".json");
+         }
+
+         return var1;
+      }
    }
 
    private void loadItemModels() {
       this.registerVariantNames();
 
       for (Item var2 : Item.REGISTRY) {
-         for (String var5 : this.getVariantNames(var2)) {
-            ResourceLocation var6 = this.getItemLocation(var5);
-            ResourceLocation var7 = Item.REGISTRY.getNameForObject(var2);
-            this.loadItemModel(var5, var6, var7);
+         for (String var4 : this.getVariantNames(var2)) {
+            ResourceLocation var5 = this.getItemLocation(var4);
+            ResourceLocation var6 = (ResourceLocation)Item.REGISTRY.getNameForObject(var2);
+            this.loadItemModel(var4, var5, var6);
             if (var2.hasCustomProperties()) {
-               ModelBlock var8 = this.models.get(var6);
-               if (var8 != null) {
-                  for (ResourceLocation var10 : var8.getOverrideLocations()) {
-                     this.loadItemModel(var10.toString(), var10, var7);
+               ModelBlock var7 = this.models.get(var5);
+               if (var7 != null) {
+                  for (ResourceLocation var9 : var7.getOverrideLocations()) {
+                     this.loadItemModel(var9.toString(), var9, var6);
                   }
                }
             }
          }
       }
    }
 
-   private void loadItemModel(String var1, ResourceLocation var2, ResourceLocation var3) {
+   public void loadItemModel(String var1, ResourceLocation var2, ResourceLocation var3) {
       this.itemLocations.put(var1, var2);
       if (this.models.get(var2) == null) {
          try {
             ModelBlock var4 = this.loadModel(var2);
             this.models.put(var2, var4);
          } catch (Exception var5) {
-            LOGGER.warn("Unable to load item model: '{}' for item: '{}'", var2, var3, var5);
+            LOGGER.warn("Unable to load item model: '{}' for item: '{}'", new Object[]{var2, var3});
+            LOGGER.warn(var5.getClass().getName() + ": " + var5.getMessage());
          }
       }
    }
 
    private void registerVariantNames() {
+      this.variantNames.clear();
       this.variantNames
          .put(
             Item.getItemFromBlock(Blocks.STONE),
             Lists.newArrayList(new String[]{"stone", "granite", "granite_smooth", "diorite", "diorite_smooth", "andesite", "andesite_smooth"})
          );
       this.variantNames.put(Item.getItemFromBlock(Blocks.DIRT), Lists.newArrayList(new String[]{"dirt", "coarse_dirt", "podzol"}));
@@ -642,25 +682,33 @@
       this.variantNames.put(Item.getItemFromBlock(Blocks.AIR), Collections.emptyList());
       this.variantNames.put(Item.getItemFromBlock(Blocks.OAK_FENCE_GATE), Lists.newArrayList(new String[]{"oak_fence_gate"}));
       this.variantNames.put(Item.getItemFromBlock(Blocks.OAK_FENCE), Lists.newArrayList(new String[]{"oak_fence"}));
       this.variantNames.put(Items.OAK_DOOR, Lists.newArrayList(new String[]{"oak_door"}));
       this.variantNames.put(Items.BOAT, Lists.newArrayList(new String[]{"oak_boat"}));
       this.variantNames.put(Items.TOTEM_OF_UNDYING, Lists.newArrayList(new String[]{"totem"}));
+
+      for (Entry var2 : customVariantNames.entrySet()) {
+         this.variantNames.put((Item)((IRegistryDelegate)var2.getKey()).get(), Lists.newArrayList(((Set)var2.getValue()).iterator()));
+      }
    }
 
    private List<String> getVariantNames(Item var1) {
       List var2 = this.variantNames.get(var1);
       if (var2 == null) {
-         var2 = Collections.singletonList(Item.REGISTRY.getNameForObject(var1).toString());
+         var2 = Collections.singletonList(((ResourceLocation)Item.REGISTRY.getNameForObject(var1)).toString());
       }
 
       return var2;
    }
 
    private ResourceLocation getItemLocation(String var1) {
       ResourceLocation var2 = new ResourceLocation(var1);
+      if (Reflector.ForgeHooksClient.exists()) {
+         var2 = new ResourceLocation(var1.replaceAll("#.*", ""));
+      }
+
       return new ResourceLocation(var2.getNamespace(), "item/" + var2.getPath());
    }
 
    private void bakeBlockModels() {
       for (ModelResourceLocation var2 : this.variants.keySet()) {
          IBakedModel var3 = this.createRandomModelForVariantList(this.variants.get(var2), var2.toString());
@@ -669,14 +717,14 @@
          }
       }
 
       for (Entry var11 : this.multipartVariantMap.entrySet()) {
          ModelBlockDefinition var12 = (ModelBlockDefinition)var11.getKey();
          Multipart var4 = var12.getMultipartData();
-         String var5 = Block.REGISTRY.getNameForObject(var4.getStateContainer().getBlock()).toString();
-         MultipartBakedModel.Builder var6 = new MultipartBakedModel.Builder();
+         String var5 = ((ResourceLocation)Block.REGISTRY.getNameForObject(var4.getStateContainer().getBlock())).toString();
+         Builder var6 = new Builder();
 
          for (Selector var8 : var4.getSelectors()) {
             IBakedModel var9 = this.createRandomModelForVariantList(var8.getVariantList(), "selector of " + var5);
             if (var9 != null) {
                var6.putModel(var8.getPredicate(var4.getStateContainer()), var9);
             }
@@ -694,13 +742,13 @@
 
    @Nullable
    private IBakedModel createRandomModelForVariantList(VariantList var1, String var2) {
       if (var1.getVariantList().isEmpty()) {
          return null;
       } else {
-         WeightedBakedModel.Builder var3 = new WeightedBakedModel.Builder();
+         net.minecraft.client.renderer.block.model.WeightedBakedModel.Builder var3 = new net.minecraft.client.renderer.block.model.WeightedBakedModel.Builder();
          int var4 = 0;
 
          for (Variant var6 : var1.getVariantList()) {
             ModelBlock var7 = this.models.get(var6.getModelLocation());
             if (var7 == null || !var7.isResolved()) {
                LOGGER.warn("Missing model for: {}", var2);
@@ -729,12 +777,16 @@
    }
 
    private void bakeItemModels() {
       for (Entry var2 : this.itemLocations.entrySet()) {
          ResourceLocation var3 = (ResourceLocation)var2.getValue();
          ModelResourceLocation var4 = new ModelResourceLocation((String)var2.getKey(), "inventory");
+         if (Reflector.ForgeHooksClient.exists()) {
+            var4 = (ModelResourceLocation)Reflector.call(Reflector.ModelLoader_getInventoryVariant, new Object[]{var2.getKey()});
+         }
+
          ModelBlock var5 = this.models.get(var3);
          if (var5 == null || !var5.isResolved()) {
             LOGGER.warn("Missing model for: {}", var3);
          } else if (var5.getElements().isEmpty()) {
             LOGGER.warn("Missing elements for: {}", var3);
          } else if (this.isCustomRenderer(var5)) {
@@ -785,35 +837,53 @@
 
       var1.addAll(LOCATIONS_BUILTIN_TEXTURES);
       return var1;
    }
 
    @Nullable
-   private IBakedModel bakeModel(ModelBlock var1, ModelRotation var2, boolean var3) {
+   public IBakedModel bakeModel(ModelBlock var1, ModelRotation var2, boolean var3) {
+      return this.bakeModel(var1, (ITransformation)var2, var3);
+   }
+
+   protected IBakedModel bakeModel(ModelBlock var1, ITransformation var2, boolean var3) {
       TextureAtlasSprite var4 = this.sprites.get(new ResourceLocation(var1.resolveTextureName("particle")));
-      SimpleBakedModel.Builder var5 = new SimpleBakedModel.Builder(var1, var1.createOverrides()).setTexture(var4);
+      net.minecraft.client.renderer.block.model.SimpleBakedModel.Builder var5 = new net.minecraft.client.renderer.block.model.SimpleBakedModel.Builder(
+            var1, var1.createOverrides()
+         )
+         .setTexture(var4);
       if (var1.getElements().isEmpty()) {
          return null;
       } else {
          for (BlockPart var7 : var1.getElements()) {
             for (EnumFacing var9 : var7.mapFaces.keySet()) {
-               BlockPartFace var10 = var7.mapFaces.get(var9);
+               BlockPartFace var10 = (BlockPartFace)var7.mapFaces.get(var9);
                TextureAtlasSprite var11 = this.sprites.get(new ResourceLocation(var1.resolveTextureName(var10.texture)));
-               if (var10.cullFace == null) {
-                  var5.addGeneralQuad(this.makeBakedQuad(var7, var10, var11, var9, var2, var3));
+               boolean var12 = true;
+               if (Reflector.ForgeHooksClient.exists()) {
+                  var12 = TRSRTransformation.isInteger(var2.getMatrix());
+               }
+
+               if (var10.cullFace != null && var12) {
+                  var5.addFaceQuad(var2.rotate(var10.cullFace), this.makeBakedQuad(var7, var10, var11, var9, var2, var3));
                } else {
-                  var5.addFaceQuad(var2.rotateFace(var10.cullFace), this.makeBakedQuad(var7, var10, var11, var9, var2, var3));
+                  var5.addGeneralQuad(this.makeBakedQuad(var7, var10, var11, var9, var2, var3));
                }
             }
          }
 
          return var5.makeBakedModel();
       }
    }
 
    private BakedQuad makeBakedQuad(BlockPart var1, BlockPartFace var2, TextureAtlasSprite var3, EnumFacing var4, ModelRotation var5, boolean var6) {
+      return Reflector.ForgeHooksClient.exists()
+         ? this.makeBakedQuad(var1, var2, var3, var4, (ITransformation)var5, var6)
+         : this.faceBakery.makeBakedQuad(var1.positionFrom, var1.positionTo, var2, var3, var4, var5, var1.partRotation, var6, var1.shade);
+   }
+
+   protected BakedQuad makeBakedQuad(BlockPart var1, BlockPartFace var2, TextureAtlasSprite var3, EnumFacing var4, ITransformation var5, boolean var6) {
       return this.faceBakery.makeBakedQuad(var1.positionFrom, var1.positionTo, var2, var3, var4, var5, var1.partRotation, var6, var1.shade);
    }
 
    private void loadModelsCheck() {
       this.loadModels();
 
@@ -842,13 +912,13 @@
             }
 
             ModelBlock var7 = this.loadModel(var6);
             this.models.put(var6, var7);
             this.addModelParentLocation(var1, var2, var7);
          } catch (Exception var5) {
-            LOGGER.warn("In parent chain: {}; unable to load model: '{}'", JOINER.join(this.getParentPath(var6)), var6, var5);
+            LOGGER.warn("In parent chain: {}; unable to load model: '{}'", new Object[]{JOINER.join(this.getParentPath(var6)), var6});
          }
 
          var2.add(var6);
       }
    }
 
@@ -898,13 +968,12 @@
 
    private void loadSprites() {
       final Set var1 = this.getVariantsTextureLocations();
       var1.addAll(this.getItemsTextureLocations());
       var1.remove(TextureMap.LOCATION_MISSING_TEXTURE);
       ITextureMapPopulator var2 = new ITextureMapPopulator() {
-         @Override
          public void registerSprites(TextureMap var1x) {
             for (ResourceLocation var3 : var1) {
                TextureAtlasSprite var4 = var1x.registerSprite(var3);
                ModelBakery.this.sprites.put(var3, var4);
             }
          }
@@ -972,12 +1041,72 @@
          }
       }
    }
 
    private ModelBlock makeItemModel(ModelBlock var1) {
       return this.itemModelGenerator.makeItemModel(this.textureMap, var1);
+   }
+
+   public ModelBlock getModelBlock(ResourceLocation var1) {
+      return this.models.get(var1);
+   }
+
+   public static void fixModelLocations(ModelBlock var0, String var1) {
+      ResourceLocation var2 = fixModelLocation(var0.parentLocation, var1);
+      if (var2 != var0.parentLocation) {
+         var0.parentLocation = var2;
+      }
+
+      if (var0.textures != null) {
+         for (Entry var4 : var0.textures.entrySet()) {
+            String var5 = (String)var4.getValue();
+            String var6 = fixResourcePath(var5, var1);
+            if (var6 != var5) {
+               var4.setValue(var6);
+            }
+         }
+      }
+   }
+
+   public static ResourceLocation fixModelLocation(ResourceLocation var0, String var1) {
+      if (var0 != null && var1 != null) {
+         if (!var0.getNamespace().equals("minecraft")) {
+            return var0;
+         } else {
+            String var2 = var0.getPath();
+            String var3 = fixResourcePath(var2, var1);
+            if (var3 != var2) {
+               var0 = new ResourceLocation(var0.getNamespace(), var3);
+            }
+
+            return var0;
+         }
+      } else {
+         return var0;
+      }
+   }
+
+   private static String fixResourcePath(String var0, String var1) {
+      var0 = TextureUtils.fixResourcePath(var0, var1);
+      var0 = StrUtils.removeSuffix(var0, ".json");
+      return StrUtils.removeSuffix(var0, ".png");
+   }
+
+   protected void registerMultipartVariant(ModelBlockDefinition var1, Collection<ModelResourceLocation> var2) {
+      this.multipartVariantMap.put(var1, var2);
+   }
+
+   public static void registerItemVariants(Item var0, ResourceLocation... var1) {
+      IRegistryDelegate var2 = (IRegistryDelegate)Reflector.getFieldValue(var0, Reflector.ForgeItem_delegate);
+      if (!customVariantNames.containsKey(var2)) {
+         customVariantNames.put(var2, Sets.newHashSet());
+      }
+
+      for (ResourceLocation var6 : var1) {
+         customVariantNames.get(var2).add(var6.toString());
+      }
    }
 
    static {
       BUILT_IN_MODELS.put("missing", MISSING_MODEL_MESH);
       MODEL_GENERATED.name = "generation marker";
       MODEL_ENTITY.name = "block entity marker";
--- net/minecraft/client/renderer/block/model/ModelBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ModelBlockDefinition.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelBlockDefinition.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ModelManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelManager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ModelResourceLocation.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelResourceLocation.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/ModelRotation.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/ModelRotation.java	Mon Aug 18 09:39:52 2025
@@ -1,16 +1,22 @@
 package net.minecraft.client.renderer.block.model;
 
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Optional;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.MathHelper;
+import net.minecraftforge.common.model.IModelPart;
+import net.minecraftforge.common.model.IModelState;
+import net.minecraftforge.common.model.ITransformation;
+import net.minecraftforge.common.model.TRSRTransformation;
+import net.optifine.reflect.Reflector;
 import org.lwjgl.util.vector.Matrix4f;
 import org.lwjgl.util.vector.Vector3f;
 
-public enum ModelRotation {
+public enum ModelRotation implements IModelState, ITransformation {
    X0_Y0(0, 0),
    X0_Y90(0, 90),
    X0_Y180(0, 180),
    X0_Y270(0, 270),
    X90_Y0(90, 0),
    X90_Y90(90, 90),
@@ -87,12 +93,36 @@
 
       return var3;
    }
 
    public static ModelRotation getModelRotation(int var0, int var1) {
       return MAP_ROTATIONS.get(combineXY(MathHelper.normalizeAngle(var0, 360), MathHelper.normalizeAngle(var1, 360)));
+   }
+
+   public Optional<TRSRTransformation> apply(Optional<? extends IModelPart> var1) {
+      return Reflector.ForgeHooksClient_applyTransform_MR.exists()
+         ? (Optional)Reflector.call(Reflector.ForgeHooksClient_applyTransform_MR, new Object[]{this, var1})
+         : (Optional)Reflector.call(Reflector.ForgeHooksClient_applyTransform_M4, new Object[]{this.getMatrix(), var1});
+   }
+
+   public javax.vecmath.Matrix4f getMatrix() {
+      if (Reflector.ForgeHooksClient_applyTransform_MR.exists()) {
+         return TRSRTransformation.from(this).getMatrix();
+      } else {
+         return Reflector.ForgeHooksClient_getMatrix.exists()
+            ? (javax.vecmath.Matrix4f)Reflector.call(Reflector.ForgeHooksClient_getMatrix, new Object[]{this})
+            : new javax.vecmath.Matrix4f(this.matrix());
+      }
+   }
+
+   public EnumFacing rotate(EnumFacing var1) {
+      return this.rotateFace(var1);
+   }
+
+   public int rotate(EnumFacing var1, int var2) {
+      return this.rotateVertex(var1, var2);
    }
 
    static {
       for (ModelRotation var3 : values()) {
          MAP_ROTATIONS.put(var3.combinedXY, var3);
       }
--- net/minecraft/client/renderer/block/model/MultipartBakedModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/MultipartBakedModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/SimpleBakedModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/SimpleBakedModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/Variant.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/Variant.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/VariantList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/VariantList.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/model/WeightedBakedModel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/model/WeightedBakedModel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/statemap/BlockStateMapper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/statemap/BlockStateMapper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/statemap/DefaultStateMapper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/statemap/DefaultStateMapper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/statemap/IStateMapper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/statemap/IStateMapper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/statemap/StateMap.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/statemap/StateMap.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/block/statemap/StateMapperBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/block/statemap/StateMapperBase.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/ChunkCompileTaskGenerator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/ChunkCompileTaskGenerator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/ChunkRenderDispatcher.java	Mon Aug 18 09:39:52 2025
@@ -10,12 +10,13 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.PriorityBlockingQueue;
 import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.RegionRenderCacheBuilder;
 import net.minecraft.client.renderer.VertexBufferUploader;
@@ -35,30 +36,40 @@
    private final PriorityBlockingQueue<ChunkCompileTaskGenerator> queueChunkUpdates = Queues.newPriorityBlockingQueue();
    private final BlockingQueue<RegionRenderCacheBuilder> queueFreeRenderBuilders;
    private final WorldVertexBufferUploader worldVertexUploader = new WorldVertexBufferUploader();
    private final VertexBufferUploader vertexUploader = new VertexBufferUploader();
    private final Queue<ChunkRenderDispatcher.PendingUpload> queueChunkUploads = Queues.newPriorityQueue();
    private final ChunkRenderWorker renderWorker;
+   private List<RegionRenderCacheBuilder> listPausedBuilders = new ArrayList<>();
 
    public ChunkRenderDispatcher() {
-      int var1 = Math.max(1, (int)(Runtime.getRuntime().maxMemory() * 0.3) / 10485760);
-      int var2 = Math.max(1, MathHelper.clamp(Runtime.getRuntime().availableProcessors(), 1, var1 / 5));
-      this.countRenderBuilders = MathHelper.clamp(var2 * 10, 1, var1);
-      if (var2 > 1) {
-         for (int var3 = 0; var3 < var2; var3++) {
-            ChunkRenderWorker var4 = new ChunkRenderWorker(this);
-            Thread var5 = THREAD_FACTORY.newThread(var4);
-            var5.start();
-            this.listThreadedWorkers.add(var4);
-            this.listWorkerThreads.add(var5);
+      this(-1);
+   }
+
+   public ChunkRenderDispatcher(int var1) {
+      int var2 = Math.max(1, (int)(Runtime.getRuntime().maxMemory() * 0.3) / 10485760);
+      int var3 = Math.max(1, MathHelper.clamp(Runtime.getRuntime().availableProcessors() - 2, 1, var2 / 5));
+      if (var1 < 0) {
+         this.countRenderBuilders = MathHelper.clamp(var3 * 8, 1, var2);
+      } else {
+         this.countRenderBuilders = var1;
+      }
+
+      if (var3 > 1) {
+         for (int var4 = 0; var4 < var3; var4++) {
+            ChunkRenderWorker var5 = new ChunkRenderWorker(this);
+            Thread var6 = THREAD_FACTORY.newThread(var5);
+            var6.start();
+            this.listThreadedWorkers.add(var5);
+            this.listWorkerThreads.add(var6);
          }
       }
 
       this.queueFreeRenderBuilders = Queues.newArrayBlockingQueue(this.countRenderBuilders);
 
-      for (int var6 = 0; var6 < this.countRenderBuilders; var6++) {
+      for (int var7 = 0; var7 < this.countRenderBuilders; var7++) {
          this.queueFreeRenderBuilders.add(new RegionRenderCacheBuilder());
       }
 
       this.renderWorker = new ChunkRenderWorker(this, new RegionRenderCacheBuilder());
    }
 
@@ -77,73 +88,76 @@
          if (this.listWorkerThreads.isEmpty()) {
             ChunkCompileTaskGenerator var5 = this.queueChunkUpdates.poll();
             if (var5 != null) {
                try {
                   this.renderWorker.processTask(var5);
                   var4 = true;
-               } catch (InterruptedException var8) {
+               } catch (InterruptedException var9) {
                   LOGGER.warn("Skipped task due to interrupt");
                }
             }
          }
 
+         Object var10 = null;
          synchronized (this.queueChunkUploads) {
-            if (!this.queueChunkUploads.isEmpty()) {
-               this.queueChunkUploads.poll().uploadTask.run();
-               var4 = true;
-               var3 = true;
-            }
+            var10 = this.queueChunkUploads.poll();
+         }
+
+         if (var10 != null) {
+            ((ChunkRenderDispatcher.PendingUpload)var10).uploadTask.run();
+            var4 = true;
+            var3 = true;
          }
       } while (var1 != 0L && var4 && var1 >= System.nanoTime());
 
       return var3;
    }
 
    public boolean updateChunkLater(RenderChunk var1) {
       var1.getLockCompileTask().lock();
 
-      boolean var4;
+      boolean var2;
       try {
-         final ChunkCompileTaskGenerator var2 = var1.makeCompileTaskChunk();
-         var2.addFinishRunnable(new Runnable() {
+         final ChunkCompileTaskGenerator var3 = var1.makeCompileTaskChunk();
+         var3.addFinishRunnable(new Runnable() {
             @Override
             public void run() {
-               ChunkRenderDispatcher.this.queueChunkUpdates.remove(var2);
+               ChunkRenderDispatcher.this.queueChunkUpdates.remove(var3);
             }
          });
-         boolean var3 = this.queueChunkUpdates.offer(var2);
-         if (!var3) {
-            var2.finish();
+         boolean var4 = this.queueChunkUpdates.offer(var3);
+         if (!var4) {
+            var3.finish();
          }
 
-         var4 = var3;
+         var2 = var4;
       } finally {
          var1.getLockCompileTask().unlock();
       }
 
-      return var4;
+      return var2;
    }
 
    public boolean updateChunkNow(RenderChunk var1) {
       var1.getLockCompileTask().lock();
 
-      boolean var3;
+      boolean var2;
       try {
-         ChunkCompileTaskGenerator var2 = var1.makeCompileTaskChunk();
+         ChunkCompileTaskGenerator var3 = var1.makeCompileTaskChunk();
 
          try {
-            this.renderWorker.processTask(var2);
-         } catch (InterruptedException var7) {
+            this.renderWorker.processTask(var3);
+         } catch (InterruptedException var8) {
          }
 
-         var3 = true;
+         var2 = true;
       } finally {
          var1.getLockCompileTask().unlock();
       }
 
-      return var3;
+      return var2;
    }
 
    public void stopChunkUpdates() {
       this.clearChunkUpdates();
       ArrayList var1 = Lists.newArrayList();
 
@@ -171,31 +185,32 @@
       return this.queueChunkUpdates.take();
    }
 
    public boolean updateTransparencyLater(RenderChunk var1) {
       var1.getLockCompileTask().lock();
 
-      boolean var3;
+      boolean var4;
       try {
-         final ChunkCompileTaskGenerator var2 = var1.makeCompileTaskTransparency();
-         if (var2 == null) {
-            return true;
+         final ChunkCompileTaskGenerator var3 = var1.makeCompileTaskTransparency();
+         if (var3 != null) {
+            var3.addFinishRunnable(new Runnable() {
+               @Override
+               public void run() {
+                  ChunkRenderDispatcher.this.queueChunkUpdates.remove(var3);
+               }
+            });
+            return this.queueChunkUpdates.offer(var3);
          }
 
-         var2.addFinishRunnable(new Runnable() {
-            @Override
-            public void run() {
-               ChunkRenderDispatcher.this.queueChunkUpdates.remove(var2);
-            }
-         });
-         var3 = this.queueChunkUpdates.offer(var2);
+         boolean var2 = true;
+         var4 = var2;
       } finally {
          var1.getLockCompileTask().unlock();
       }
 
-      return var3;
+      return var4;
    }
 
    public ListenableFuture<Object> uploadChunk(
       final BlockRenderLayer var1, final BufferBuilder var2, final RenderChunk var3, final CompiledChunk var4, final double var5
    ) {
       if (Minecraft.getMinecraft().isCallingFromMinecraftThread()) {
@@ -266,12 +281,30 @@
 
       this.queueFreeRenderBuilders.clear();
    }
 
    public boolean hasNoFreeRenderBuilders() {
       return this.queueFreeRenderBuilders.isEmpty();
+   }
+
+   public void pauseChunkUpdates() {
+      while (this.listPausedBuilders.size() != this.countRenderBuilders) {
+         try {
+            this.runChunkUploads(Long.MAX_VALUE);
+            RegionRenderCacheBuilder var1 = this.queueFreeRenderBuilders.poll(100L, TimeUnit.MILLISECONDS);
+            if (var1 != null) {
+               this.listPausedBuilders.add(var1);
+            }
+         } catch (InterruptedException var2) {
+         }
+      }
+   }
+
+   public void resumeChunkUpdates() {
+      this.queueFreeRenderBuilders.addAll(this.listPausedBuilders);
+      this.listPausedBuilders.clear();
    }
 
    class PendingUpload implements Comparable<ChunkRenderDispatcher.PendingUpload> {
       private final ListenableFutureTask<Object> uploadTask;
       private final double distanceSq;
 
--- net/minecraft/client/renderer/chunk/ChunkRenderWorker.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/ChunkRenderWorker.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/CompiledChunk.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/CompiledChunk.java	Mon Aug 18 09:39:52 2025
@@ -1,9 +1,10 @@
 package net.minecraft.client.renderer.chunk;
 
 import com.google.common.collect.Lists;
+import java.util.BitSet;
 import java.util.List;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumFacing;
 
@@ -20,19 +21,25 @@
       }
 
       @Override
       public boolean isVisible(EnumFacing var1, EnumFacing var2) {
          return false;
       }
+
+      @Override
+      public void setAnimatedSprites(BlockRenderLayer var1, BitSet var2) {
+         throw new UnsupportedOperationException();
+      }
    };
-   private final boolean[] layersUsed = new boolean[BlockRenderLayer.values().length];
-   private final boolean[] layersStarted = new boolean[BlockRenderLayer.values().length];
+   private final boolean[] layersUsed = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
+   private final boolean[] layersStarted = new boolean[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
    private boolean empty = true;
    private final List<TileEntity> tileEntities = Lists.newArrayList();
    private SetVisibility setVisibility = new SetVisibility();
    private BufferBuilder.State state;
+   private BitSet[] animatedSprites = new BitSet[RenderChunk.ENUM_WORLD_BLOCK_LAYERS.length];
 
    public boolean isEmpty() {
       return this.empty;
    }
 
    protected void setLayerUsed(BlockRenderLayer var1) {
@@ -71,8 +78,16 @@
    public BufferBuilder.State getState() {
       return this.state;
    }
 
    public void setState(BufferBuilder.State var1) {
       this.state = var1;
+   }
+
+   public BitSet getAnimatedSprites(BlockRenderLayer var1) {
+      return this.animatedSprites[var1.ordinal()];
+   }
+
+   public void setAnimatedSprites(BlockRenderLayer var1, BitSet var2) {
+      this.animatedSprites[var1.ordinal()] = var2;
    }
 }
--- net/minecraft/client/renderer/chunk/IRenderChunkFactory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/IRenderChunkFactory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/ListChunkFactory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/ListChunkFactory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/ListedRenderChunk.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/ListedRenderChunk.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/RenderChunk.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/RenderChunk.java	Mon Aug 18 09:39:52 2025
@@ -1,40 +1,59 @@
 package net.minecraft.client.renderer.chunk;
 
 import com.google.common.collect.Sets;
 import java.nio.FloatBuffer;
+import java.util.BitSet;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockCactus;
+import net.minecraft.block.BlockRedstoneWire;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.RegionRenderCacheBuilder;
 import net.minecraft.client.renderer.RenderGlobal;
+import net.minecraft.client.renderer.ViewFrustum;
+import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator.Status;
+import net.minecraft.client.renderer.chunk.ChunkCompileTaskGenerator.Type;
+import net.minecraft.client.renderer.culling.ICamera;
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumBlockRenderType;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.ChunkCache;
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.Chunk.EnumCreateEntityType;
+import net.optifine.BlockPosM;
+import net.optifine.CustomBlockLayers;
+import net.optifine.override.ChunkCacheOF;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.render.AabbFrame;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
 
 public class RenderChunk {
-   private World world;
+   private final World world;
    private final RenderGlobal renderGlobal;
    public static int renderChunksUpdated;
    public CompiledChunk compiledChunk = CompiledChunk.DUMMY;
    private final ReentrantLock lockCompileTask = new ReentrantLock();
    private final ReentrantLock lockCompiledChunk = new ReentrantLock();
    private ChunkCompileTaskGenerator compileTask;
@@ -42,20 +61,34 @@
    private final int index;
    private final FloatBuffer modelviewMatrix = GLAllocation.createDirectFloatBuffer(16);
    private final VertexBuffer[] vertexBuffers = new VertexBuffer[BlockRenderLayer.values().length];
    public AxisAlignedBB boundingBox;
    private int frameIndex = -1;
    private boolean needsUpdate = true;
-   private final BlockPos.MutableBlockPos position = new BlockPos.MutableBlockPos(-1, -1, -1);
-   private final BlockPos.MutableBlockPos[] mapEnumFacing = new BlockPos.MutableBlockPos[6];
+   private final MutableBlockPos position = new MutableBlockPos(-1, -1, -1);
+   private final MutableBlockPos[] mapEnumFacing = new MutableBlockPos[6];
    private boolean needsImmediateUpdate;
-   private ChunkCache worldView;
+   public static final BlockRenderLayer[] ENUM_WORLD_BLOCK_LAYERS = BlockRenderLayer.values();
+   private final BlockRenderLayer[] blockLayersSingle = new BlockRenderLayer[1];
+   private final boolean isMipmaps = Config.isMipmaps();
+   private final boolean fixBlockLayer = !Reflector.BetterFoliageClient.exists();
+   private boolean playerUpdate = false;
+   public int regionX;
+   public int regionZ;
+   private final RenderChunk[] renderChunksOfset16 = new RenderChunk[6];
+   private boolean renderChunksOffset16Updated = false;
+   private Chunk chunk;
+   private RenderChunk[] renderChunkNeighbours = new RenderChunk[EnumFacing.VALUES.length];
+   private RenderChunk[] renderChunkNeighboursValid = new RenderChunk[EnumFacing.VALUES.length];
+   private boolean renderChunkNeighboursUpated = false;
+   private RenderGlobal.ContainerLocalRenderInformation renderInfo = new RenderGlobal.ContainerLocalRenderInformation(this, null, 0);
+   public AabbFrame boundingBoxParent;
 
    public RenderChunk(World var1, RenderGlobal var2, int var3) {
       for (int var4 = 0; var4 < this.mapEnumFacing.length; var4++) {
-         this.mapEnumFacing[var4] = new BlockPos.MutableBlockPos();
+         this.mapEnumFacing[var4] = new MutableBlockPos();
       }
 
       this.world = var1;
       this.renderGlobal = var2;
       this.index = var3;
       if (OpenGlHelper.useVbo()) {
@@ -79,122 +112,186 @@
    }
 
    public void setPosition(int var1, int var2, int var3) {
       if (var1 != this.position.getX() || var2 != this.position.getY() || var3 != this.position.getZ()) {
          this.stopCompileTask();
          this.position.setPos(var1, var2, var3);
+         byte var4 = 8;
+         this.regionX = var1 >> var4 << var4;
+         this.regionZ = var3 >> var4 << var4;
          this.boundingBox = new AxisAlignedBB(var1, var2, var3, var1 + 16, var2 + 16, var3 + 16);
 
-         for (EnumFacing var7 : EnumFacing.values()) {
-            this.mapEnumFacing[var7.ordinal()].setPos(this.position).move(var7, 16);
+         for (EnumFacing var8 : EnumFacing.VALUES) {
+            this.mapEnumFacing[var8.ordinal()].setPos(this.position).move(var8, 16);
          }
 
+         this.renderChunksOffset16Updated = false;
+         this.renderChunkNeighboursUpated = false;
+
+         for (int var9 = 0; var9 < this.renderChunkNeighbours.length; var9++) {
+            RenderChunk var10 = this.renderChunkNeighbours[var9];
+            if (var10 != null) {
+               var10.renderChunkNeighboursUpated = false;
+            }
+         }
+
+         this.chunk = null;
+         this.boundingBoxParent = null;
          this.initModelviewMatrix();
       }
    }
 
    public void resortTransparency(float var1, float var2, float var3, ChunkCompileTaskGenerator var4) {
       CompiledChunk var5 = var4.getCompiledChunk();
       if (var5.getState() != null && !var5.isLayerEmpty(BlockRenderLayer.TRANSLUCENT)) {
-         this.preRenderBlocks(var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), this.position);
-         var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT).setVertexState(var5.getState());
-         this.postRenderBlocks(
-            BlockRenderLayer.TRANSLUCENT, var1, var2, var3, var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT), var5
-         );
+         BufferBuilder var6 = var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(BlockRenderLayer.TRANSLUCENT);
+         this.preRenderBlocks(var6, this.position);
+         var6.setVertexState(var5.getState());
+         this.postRenderBlocks(BlockRenderLayer.TRANSLUCENT, var1, var2, var3, var6, var5);
       }
    }
 
    public void rebuildChunk(float var1, float var2, float var3, ChunkCompileTaskGenerator var4) {
       CompiledChunk var5 = new CompiledChunk();
       boolean var6 = true;
-      BlockPos.MutableBlockPos var7 = this.position;
+      BlockPos var7 = new BlockPos(this.position);
       BlockPos var8 = var7.add(15, 15, 15);
       var4.getLock().lock();
 
       try {
-         if (var4.getStatus() != ChunkCompileTaskGenerator.Status.COMPILING) {
+         if (var4.getStatus() != Status.COMPILING) {
             return;
          }
 
          var4.setCompiledChunk(var5);
       } finally {
          var4.getLock().unlock();
       }
 
       VisGraph var9 = new VisGraph();
       HashSet var10 = Sets.newHashSet();
-      if (!this.worldView.isEmpty()) {
+      if (!this.isChunkRegionEmpty(var7)) {
          renderChunksUpdated++;
-         boolean[] var11 = new boolean[BlockRenderLayer.values().length];
-         BlockRendererDispatcher var12 = Minecraft.getMinecraft().getBlockRendererDispatcher();
-
-         for (BlockPos.MutableBlockPos var14 : BlockPos.getAllInBoxMutable(var7, var8)) {
-            IBlockState var15 = this.worldView.getBlockState(var14);
-            Block var16 = var15.getBlock();
-            if (var15.isOpaqueCube()) {
-               var9.setOpaqueCube(var14);
+         ChunkCacheOF var11 = this.makeChunkCacheOF(var7);
+         var11.renderStart();
+         boolean[] var12 = new boolean[ENUM_WORLD_BLOCK_LAYERS.length];
+         BlockRendererDispatcher var13 = Minecraft.getMinecraft().getBlockRendererDispatcher();
+         boolean var14 = Reflector.ForgeBlock_canRenderInLayer.exists();
+         boolean var15 = Reflector.ForgeHooksClient_setRenderLayer.exists();
+
+         for (BlockPosM var17 : BlockPosM.getAllInBoxMutable(var7, var8)) {
+            IBlockState var18 = var11.getBlockState(var17);
+            Block var19 = var18.getBlock();
+            if (var18.p()) {
+               var9.setOpaqueCube(var17);
             }
 
-            if (var16.hasTileEntity()) {
-               TileEntity var17 = this.worldView.getTileEntity(var14, Chunk.EnumCreateEntityType.CHECK);
-               if (var17 != null) {
-                  TileEntitySpecialRenderer var18 = TileEntityRendererDispatcher.instance.getRenderer(var17);
-                  if (var18 != null) {
-                     var5.addTileEntity(var17);
-                     if (var18.isGlobalRenderer(var17)) {
-                        var10.add(var17);
+            if (ReflectorForge.blockHasTileEntity(var18)) {
+               TileEntity var20 = var11.getTileEntity(var17, EnumCreateEntityType.CHECK);
+               if (var20 != null) {
+                  TileEntitySpecialRenderer var21 = TileEntityRendererDispatcher.instance.getRenderer(var20);
+                  if (var21 != null) {
+                     if (var21.isGlobalRenderer(var20)) {
+                        var10.add(var20);
+                     } else {
+                        var5.addTileEntity(var20);
                      }
                   }
                }
             }
 
-            BlockRenderLayer var33 = var16.getRenderLayer();
-            int var34 = var33.ordinal();
-            if (var16.getDefaultState().getRenderType() != EnumBlockRenderType.INVISIBLE) {
-               BufferBuilder var19 = var4.getRegionRenderCacheBuilder().getWorldRendererByLayerId(var34);
-               if (!var5.isLayerStarted(var33)) {
-                  var5.setLayerStarted(var33);
-                  this.preRenderBlocks(var19, var7);
+            BlockRenderLayer[] var38;
+            if (var14) {
+               var38 = ENUM_WORLD_BLOCK_LAYERS;
+            } else {
+               var38 = this.blockLayersSingle;
+               var38[0] = var19.getRenderLayer();
+            }
+
+            for (int var40 = 0; var40 < var38.length; var40++) {
+               BlockRenderLayer var22 = var38[var40];
+               if (var14) {
+                  boolean var23 = Reflector.callBoolean(var19, Reflector.ForgeBlock_canRenderInLayer, new Object[]{var18, var22});
+                  if (!var23) {
+                     continue;
+                  }
+               }
+
+               if (var15) {
+                  Reflector.callVoid(Reflector.ForgeHooksClient_setRenderLayer, new Object[]{var22});
                }
 
-               var11[var34] |= var12.renderBlock(var15, var14, this.worldView, var19);
+               var22 = this.fixBlockLayer(var18, var22);
+               int var43 = var22.ordinal();
+               if (var19.getDefaultState().i() != EnumBlockRenderType.INVISIBLE) {
+                  BufferBuilder var24 = var4.getRegionRenderCacheBuilder().getWorldRendererByLayerId(var43);
+                  var24.setBlockLayer(var22);
+                  RenderEnv var25 = var24.getRenderEnv(var18, var17);
+                  var25.setRegionRenderCacheBuilder(var4.getRegionRenderCacheBuilder());
+                  if (!var5.isLayerStarted(var22)) {
+                     var5.setLayerStarted(var22);
+                     this.preRenderBlocks(var24, var7);
+                  }
+
+                  var12[var43] |= var13.renderBlock(var18, var17, var11, var24);
+                  if (var25.isOverlaysRendered()) {
+                     this.postRenderOverlays(var4.getRegionRenderCacheBuilder(), var5, var12);
+                     var25.setOverlaysRendered(false);
+                  }
+               }
+            }
+
+            if (var15) {
+               Reflector.callVoid(Reflector.ForgeHooksClient_setRenderLayer, new Object[]{null});
             }
          }
 
-         for (BlockRenderLayer var32 : BlockRenderLayer.values()) {
-            if (var11[var32.ordinal()]) {
-               var5.setLayerUsed(var32);
+         for (BlockRenderLayer var39 : ENUM_WORLD_BLOCK_LAYERS) {
+            if (var12[var39.ordinal()]) {
+               var5.setLayerUsed(var39);
             }
 
-            if (var5.isLayerStarted(var32)) {
-               this.postRenderBlocks(var32, var1, var2, var3, var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(var32), var5);
+            if (var5.isLayerStarted(var39)) {
+               if (Config.isShaders()) {
+                  SVertexBuilder.calcNormalChunkLayer(var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(var39));
+               }
+
+               BufferBuilder var41 = var4.getRegionRenderCacheBuilder().getWorldRendererByLayer(var39);
+               this.postRenderBlocks(var39, var1, var2, var3, var41, var5);
+               if (var41.animatedSprites != null) {
+                  var5.setAnimatedSprites(var39, (BitSet)var41.animatedSprites.clone());
+               }
+            } else {
+               var5.setAnimatedSprites(var39, null);
             }
          }
+
+         var11.renderFinish();
       }
 
       var5.setVisibility(var9.computeVisibility());
       this.lockCompileTask.lock();
 
       try {
-         HashSet var27 = Sets.newHashSet(var10);
-         HashSet var28 = Sets.newHashSet(this.setTileEntities);
-         var27.removeAll(this.setTileEntities);
-         var28.removeAll(var10);
+         HashSet var33 = Sets.newHashSet(var10);
+         HashSet var34 = Sets.newHashSet(this.setTileEntities);
+         var33.removeAll(this.setTileEntities);
+         var34.removeAll(var10);
          this.setTileEntities.clear();
          this.setTileEntities.addAll(var10);
-         this.renderGlobal.updateTileEntities(var28, var27);
+         this.renderGlobal.updateTileEntities(var34, var33);
       } finally {
          this.lockCompileTask.unlock();
       }
    }
 
    protected void finishCompileTask() {
       this.lockCompileTask.lock();
 
       try {
-         if (this.compileTask != null && this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.DONE) {
+         if (this.compileTask != null && this.compileTask.getStatus() != Status.DONE) {
             this.compileTask.finish();
             this.compileTask = null;
          }
       } finally {
          this.lockCompileTask.unlock();
       }
@@ -207,63 +304,73 @@
    public ChunkCompileTaskGenerator makeCompileTaskChunk() {
       this.lockCompileTask.lock();
 
       ChunkCompileTaskGenerator var1;
       try {
          this.finishCompileTask();
-         this.compileTask = new ChunkCompileTaskGenerator(this, ChunkCompileTaskGenerator.Type.REBUILD_CHUNK, this.getDistanceSq());
+         this.compileTask = new ChunkCompileTaskGenerator(this, Type.REBUILD_CHUNK, this.getDistanceSq());
          this.rebuildWorldView();
          var1 = this.compileTask;
       } finally {
          this.lockCompileTask.unlock();
       }
 
       return var1;
    }
 
    private void rebuildWorldView() {
       boolean var1 = true;
-      this.worldView = new ChunkCache(this.world, this.position.add(-1, -1, -1), this.position.add(16, 16, 16), 1);
    }
 
    @Nullable
    public ChunkCompileTaskGenerator makeCompileTaskTransparency() {
       this.lockCompileTask.lock();
 
-      Object var1;
+      ChunkCompileTaskGenerator var2;
       try {
-         if (this.compileTask == null || this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.PENDING) {
-            if (this.compileTask != null && this.compileTask.getStatus() != ChunkCompileTaskGenerator.Status.DONE) {
-               this.compileTask.finish();
-               this.compileTask = null;
-            }
+         if (this.compileTask != null && this.compileTask.getStatus() == Status.PENDING) {
+            return null;
+         }
 
-            this.compileTask = new ChunkCompileTaskGenerator(this, ChunkCompileTaskGenerator.Type.RESORT_TRANSPARENCY, this.getDistanceSq());
-            this.compileTask.setCompiledChunk(this.compiledChunk);
-            return this.compileTask;
+         if (this.compileTask != null && this.compileTask.getStatus() != Status.DONE) {
+            this.compileTask.finish();
+            this.compileTask = null;
          }
 
-         var1 = null;
+         this.compileTask = new ChunkCompileTaskGenerator(this, Type.RESORT_TRANSPARENCY, this.getDistanceSq());
+         this.compileTask.setCompiledChunk(this.compiledChunk);
+         ChunkCompileTaskGenerator var1 = this.compileTask;
+         var2 = var1;
       } finally {
          this.lockCompileTask.unlock();
       }
 
-      return (ChunkCompileTaskGenerator)var1;
+      return var2;
    }
 
    protected double getDistanceSq() {
       EntityPlayerSP var1 = Minecraft.getMinecraft().player;
       double var2 = this.boundingBox.minX + 8.0 - var1.posX;
       double var4 = this.boundingBox.minY + 8.0 - var1.posY;
       double var6 = this.boundingBox.minZ + 8.0 - var1.posZ;
       return var2 * var2 + var4 * var4 + var6 * var6;
    }
 
    private void preRenderBlocks(BufferBuilder var1, BlockPos var2) {
       var1.begin(7, DefaultVertexFormats.BLOCK);
-      var1.setTranslation(-var2.getX(), -var2.getY(), -var2.getZ());
+      if (Config.isRenderRegions()) {
+         byte var3 = 8;
+         int var4 = var2.getX() >> var3 << var3;
+         int var5 = var2.getY() >> var3 << var3;
+         int var6 = var2.getZ() >> var3 << var3;
+         var4 = this.regionX;
+         var6 = this.regionZ;
+         var1.setTranslation(-var4, -var5, -var6);
+      } else {
+         var1.setTranslation(-var2.getX(), -var2.getY(), -var2.getZ());
+      }
    }
 
    private void postRenderBlocks(BlockRenderLayer var1, float var2, float var3, float var4, BufferBuilder var5, CompiledChunk var6) {
       if (var1 == BlockRenderLayer.TRANSLUCENT && !var6.isLayerEmpty(var1)) {
          var5.sortVertexData(var2, var3, var4);
          var6.setState(var5.getVertexState());
@@ -305,13 +412,12 @@
       this.finishCompileTask();
       this.compiledChunk = CompiledChunk.DUMMY;
    }
 
    public void deleteGlResources() {
       this.stopCompileTask();
-      this.world = null;
 
       for (int var1 = 0; var1 < BlockRenderLayer.values().length; var1++) {
          if (this.vertexBuffers[var1] != null) {
             this.vertexBuffers[var1].deleteGlBuffers();
          }
       }
@@ -325,17 +431,21 @@
       if (this.needsUpdate) {
          var1 |= this.needsImmediateUpdate;
       }
 
       this.needsUpdate = true;
       this.needsImmediateUpdate = var1;
+      if (this.isWorldPlayerUpdate()) {
+         this.playerUpdate = true;
+      }
    }
 
    public void clearNeedsUpdate() {
       this.needsUpdate = false;
       this.needsImmediateUpdate = false;
+      this.playerUpdate = false;
    }
 
    public boolean needsUpdate() {
       return this.needsUpdate;
    }
 
@@ -346,8 +456,187 @@
    public BlockPos getBlockPosOffset16(EnumFacing var1) {
       return this.mapEnumFacing[var1.ordinal()];
    }
 
    public World getWorld() {
       return this.world;
+   }
+
+   private boolean isWorldPlayerUpdate() {
+      if (this.world instanceof WorldClient) {
+         WorldClient var1 = (WorldClient)this.world;
+         return var1.isPlayerUpdate();
+      } else {
+         return false;
+      }
+   }
+
+   public boolean isPlayerUpdate() {
+      return this.playerUpdate;
+   }
+
+   private BlockRenderLayer fixBlockLayer(IBlockState var1, BlockRenderLayer var2) {
+      if (CustomBlockLayers.isActive()) {
+         BlockRenderLayer var3 = CustomBlockLayers.getRenderLayer(var1);
+         if (var3 != null) {
+            return var3;
+         }
+      }
+
+      if (!this.fixBlockLayer) {
+         return var2;
+      } else {
+         if (this.isMipmaps) {
+            if (var2 == BlockRenderLayer.CUTOUT) {
+               Block var4 = var1.getBlock();
+               if (var4 instanceof BlockRedstoneWire) {
+                  return var2;
+               }
+
+               if (var4 instanceof BlockCactus) {
+                  return var2;
+               }
+
+               return BlockRenderLayer.CUTOUT_MIPPED;
+            }
+         } else if (var2 == BlockRenderLayer.CUTOUT_MIPPED) {
+            return BlockRenderLayer.CUTOUT;
+         }
+
+         return var2;
+      }
+   }
+
+   private void postRenderOverlays(RegionRenderCacheBuilder var1, CompiledChunk var2, boolean[] var3) {
+      this.postRenderOverlay(BlockRenderLayer.CUTOUT, var1, var2, var3);
+      this.postRenderOverlay(BlockRenderLayer.CUTOUT_MIPPED, var1, var2, var3);
+      this.postRenderOverlay(BlockRenderLayer.TRANSLUCENT, var1, var2, var3);
+   }
+
+   private void postRenderOverlay(BlockRenderLayer var1, RegionRenderCacheBuilder var2, CompiledChunk var3, boolean[] var4) {
+      BufferBuilder var5 = var2.getWorldRendererByLayer(var1);
+      if (var5.isDrawing()) {
+         var3.setLayerStarted(var1);
+         var4[var1.ordinal()] = true;
+      }
+   }
+
+   private ChunkCacheOF makeChunkCacheOF(BlockPos var1) {
+      BlockPos var2 = var1.add(-1, -1, -1);
+      BlockPos var3 = var1.add(16, 16, 16);
+      ChunkCache var4 = this.createRegionRenderCache(this.world, var2, var3, 1);
+      if (Reflector.MinecraftForgeClient_onRebuildChunk.exists()) {
+         Reflector.call(Reflector.MinecraftForgeClient_onRebuildChunk, new Object[]{this.world, var1, var4});
+      }
+
+      return new ChunkCacheOF(var4, var2, var3, 1);
+   }
+
+   public RenderChunk getRenderChunkOffset16(ViewFrustum var1, EnumFacing var2) {
+      if (!this.renderChunksOffset16Updated) {
+         for (int var3 = 0; var3 < EnumFacing.VALUES.length; var3++) {
+            EnumFacing var4 = EnumFacing.VALUES[var3];
+            BlockPos var5 = this.getBlockPosOffset16(var4);
+            this.renderChunksOfset16[var3] = var1.getRenderChunk(var5);
+         }
+
+         this.renderChunksOffset16Updated = true;
+      }
+
+      return this.renderChunksOfset16[var2.ordinal()];
+   }
+
+   public Chunk getChunk() {
+      return this.getChunk(this.position);
+   }
+
+   private Chunk getChunk(BlockPos var1) {
+      Chunk var2 = this.chunk;
+      if (var2 != null && var2.isLoaded()) {
+         return var2;
+      } else {
+         var2 = this.world.getChunk(var1);
+         this.chunk = var2;
+         return var2;
+      }
+   }
+
+   public boolean isChunkRegionEmpty() {
+      return this.isChunkRegionEmpty(this.position);
+   }
+
+   private boolean isChunkRegionEmpty(BlockPos var1) {
+      int var2 = var1.getY();
+      int var3 = var2 + 15;
+      return this.getChunk(var1).isEmptyBetween(var2, var3);
+   }
+
+   public void setRenderChunkNeighbour(EnumFacing var1, RenderChunk var2) {
+      this.renderChunkNeighbours[var1.ordinal()] = var2;
+      this.renderChunkNeighboursValid[var1.ordinal()] = var2;
+   }
+
+   public RenderChunk getRenderChunkNeighbour(EnumFacing var1) {
+      if (!this.renderChunkNeighboursUpated) {
+         this.updateRenderChunkNeighboursValid();
+      }
+
+      return this.renderChunkNeighboursValid[var1.ordinal()];
+   }
+
+   public RenderGlobal.ContainerLocalRenderInformation getRenderInfo() {
+      return this.renderInfo;
+   }
+
+   private void updateRenderChunkNeighboursValid() {
+      int var1 = this.getPosition().getX();
+      int var2 = this.getPosition().getZ();
+      int var3 = EnumFacing.NORTH.ordinal();
+      int var4 = EnumFacing.SOUTH.ordinal();
+      int var5 = EnumFacing.WEST.ordinal();
+      int var6 = EnumFacing.EAST.ordinal();
+      this.renderChunkNeighboursValid[var3] = this.renderChunkNeighbours[var3].getPosition().getZ() == var2 - 16 ? this.renderChunkNeighbours[var3] : null;
+      this.renderChunkNeighboursValid[var4] = this.renderChunkNeighbours[var4].getPosition().getZ() == var2 + 16 ? this.renderChunkNeighbours[var4] : null;
+      this.renderChunkNeighboursValid[var5] = this.renderChunkNeighbours[var5].getPosition().getX() == var1 - 16 ? this.renderChunkNeighbours[var5] : null;
+      this.renderChunkNeighboursValid[var6] = this.renderChunkNeighbours[var6].getPosition().getX() == var1 + 16 ? this.renderChunkNeighbours[var6] : null;
+      this.renderChunkNeighboursUpated = true;
+   }
+
+   public boolean isBoundingBoxInFrustum(ICamera var1, int var2) {
+      return this.getBoundingBoxParent().isBoundingBoxInFrustumFully(var1, var2) ? true : var1.isBoundingBoxInFrustum(this.boundingBox);
+   }
+
+   public AabbFrame getBoundingBoxParent() {
+      if (this.boundingBoxParent == null) {
+         BlockPos var1 = this.getPosition();
+         int var2 = var1.getX();
+         int var3 = var1.getY();
+         int var4 = var1.getZ();
+         byte var5 = 5;
+         int var6 = var2 >> var5 << var5;
+         int var7 = var3 >> var5 << var5;
+         int var8 = var4 >> var5 << var5;
+         if (var6 != var2 || var7 != var3 || var8 != var4) {
+            AabbFrame var9 = this.renderGlobal.getRenderChunk(new BlockPos(var6, var7, var8)).getBoundingBoxParent();
+            if (var9 != null && var9.minX == var6 && var9.minY == var7 && var9.minZ == var8) {
+               this.boundingBoxParent = var9;
+            }
+         }
+
+         if (this.boundingBoxParent == null) {
+            int var10 = 1 << var5;
+            this.boundingBoxParent = new AabbFrame(var6, var7, var8, var6 + var10, var7 + var10, var8 + var10);
+         }
+      }
+
+      return this.boundingBoxParent;
+   }
+
+   @Override
+   public String toString() {
+      return "pos: " + this.getPosition() + ", frameIndex: " + this.frameIndex;
+   }
+
+   protected ChunkCache createRegionRenderCache(World var1, BlockPos var2, BlockPos var3, int var4) {
+      return new ChunkCache(var1, var2, var3, var4);
    }
 }
--- net/minecraft/client/renderer/chunk/SetVisibility.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/SetVisibility.java	Mon Aug 18 09:39:52 2025
@@ -1,35 +1,38 @@
 package net.minecraft.client.renderer.chunk;
 
-import java.util.BitSet;
 import java.util.Set;
 import net.minecraft.util.EnumFacing;
 
 public class SetVisibility {
    private static final int COUNT_FACES = EnumFacing.values().length;
-   private final BitSet bitSet = new BitSet(COUNT_FACES * COUNT_FACES);
+   private long bits;
 
    public void setManyVisible(Set<EnumFacing> var1) {
       for (EnumFacing var3 : var1) {
          for (EnumFacing var5 : var1) {
             this.setVisible(var3, var5, true);
          }
       }
    }
 
    public void setVisible(EnumFacing var1, EnumFacing var2, boolean var3) {
-      this.bitSet.set(var1.ordinal() + var2.ordinal() * COUNT_FACES, var3);
-      this.bitSet.set(var2.ordinal() + var1.ordinal() * COUNT_FACES, var3);
+      this.setBit(var1.ordinal() + var2.ordinal() * COUNT_FACES, var3);
+      this.setBit(var2.ordinal() + var1.ordinal() * COUNT_FACES, var3);
    }
 
    public void setAllVisible(boolean var1) {
-      this.bitSet.set(0, this.bitSet.size(), var1);
+      if (var1) {
+         this.bits = -1L;
+      } else {
+         this.bits = 0L;
+      }
    }
 
    public boolean isVisible(EnumFacing var1, EnumFacing var2) {
-      return this.bitSet.get(var1.ordinal() + var2.ordinal() * COUNT_FACES);
+      return this.getBit(var1.ordinal() + var2.ordinal() * COUNT_FACES);
    }
 
    @Override
    public String toString() {
       StringBuilder var1 = new StringBuilder();
       var1.append(' ');
@@ -53,8 +56,28 @@
          }
 
          var1.append('\n');
       }
 
       return var1.toString();
+   }
+
+   private boolean getBit(int var1) {
+      return (this.bits & 1 << var1) != 0L;
+   }
+
+   private void setBit(int var1, boolean var2) {
+      if (var2) {
+         this.setBit(var1);
+      } else {
+         this.clearBit(var1);
+      }
+   }
+
+   private void setBit(int var1) {
+      this.bits |= 1 << var1;
+   }
+
+   private void clearBit(int var1) {
+      this.bits &= ~(1 << var1);
    }
 }
--- net/minecraft/client/renderer/chunk/VboChunkFactory.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/VboChunkFactory.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/chunk/VisGraph.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/chunk/VisGraph.java	Mon Aug 18 09:39:52 2025
@@ -1,9 +1,8 @@
 package net.minecraft.client.renderer.chunk;
 
-import com.google.common.collect.Queues;
 import java.util.ArrayDeque;
 import java.util.BitSet;
 import java.util.EnumSet;
 import java.util.Set;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.IntegerCache;
@@ -50,21 +49,21 @@
    public Set<EnumFacing> getVisibleFacings(BlockPos var1) {
       return this.floodFill(getIndex(var1));
    }
 
    private Set<EnumFacing> floodFill(int var1) {
       EnumSet var2 = EnumSet.noneOf(EnumFacing.class);
-      ArrayDeque var3 = Queues.newArrayDeque();
+      ArrayDeque var3 = new ArrayDeque(384);
       var3.add(IntegerCache.getInteger(var1));
       this.bitSet.set(var1, true);
 
       while (!var3.isEmpty()) {
          int var4 = (Integer)var3.poll();
          this.addEdges(var4, var2);
 
-         for (EnumFacing var8 : EnumFacing.values()) {
+         for (EnumFacing var8 : EnumFacing.VALUES) {
             int var9 = this.getNeighborIndexAtFace(var4, var8);
             if (var9 >= 0 && !this.bitSet.get(var9)) {
                this.bitSet.set(var9, true);
                var3.add(IntegerCache.getInteger(var9));
             }
          }
--- net/minecraft/client/renderer/color/BlockColors.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/color/BlockColors.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/color/IBlockColor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/color/IBlockColor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/color/IItemColor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/color/IItemColor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/color/ItemColors.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/color/ItemColors.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/culling/ClippingHelper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/culling/ClippingHelper.java	Mon Aug 18 09:39:52 2025
@@ -2,29 +2,89 @@
 
 public class ClippingHelper {
    public float[][] frustum = new float[6][4];
    public float[] projectionMatrix = new float[16];
    public float[] modelviewMatrix = new float[16];
    public float[] clippingMatrix = new float[16];
+   public boolean disabled = false;
 
-   private double dot(float[] var1, double var2, double var4, double var6) {
-      return var1[0] * var2 + var1[1] * var4 + var1[2] * var6 + var1[3];
+   private float dot(float[] var1, float var2, float var3, float var4) {
+      return var1[0] * var2 + var1[1] * var3 + var1[2] * var4 + var1[3];
    }
 
    public boolean isBoxInFrustum(double var1, double var3, double var5, double var7, double var9, double var11) {
-      for (int var13 = 0; var13 < 6; var13++) {
-         float[] var14 = this.frustum[var13];
-         if (!(this.dot(var14, var1, var3, var5) > 0.0)
-            && !(this.dot(var14, var7, var3, var5) > 0.0)
-            && !(this.dot(var14, var1, var9, var5) > 0.0)
-            && !(this.dot(var14, var7, var9, var5) > 0.0)
-            && !(this.dot(var14, var1, var3, var11) > 0.0)
-            && !(this.dot(var14, var7, var3, var11) > 0.0)
-            && !(this.dot(var14, var1, var9, var11) > 0.0)
-            && !(this.dot(var14, var7, var9, var11) > 0.0)) {
-            return false;
+      if (this.disabled) {
+         return true;
+      } else {
+         float var13 = (float)var1;
+         float var14 = (float)var3;
+         float var15 = (float)var5;
+         float var16 = (float)var7;
+         float var17 = (float)var9;
+         float var18 = (float)var11;
+
+         for (int var19 = 0; var19 < 6; var19++) {
+            float[] var20 = this.frustum[var19];
+            float var21 = var20[0];
+            float var22 = var20[1];
+            float var23 = var20[2];
+            float var24 = var20[3];
+            if (var21 * var13 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+               && var21 * var16 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+               && var21 * var13 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+               && var21 * var16 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+               && var21 * var13 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+               && var21 * var16 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+               && var21 * var13 + var22 * var17 + var23 * var18 + var24 <= 0.0F
+               && var21 * var16 + var22 * var17 + var23 * var18 + var24 <= 0.0F) {
+               return false;
+            }
          }
+
+         return true;
       }
+   }
+
+   public boolean isBoxInFrustumFully(double var1, double var3, double var5, double var7, double var9, double var11) {
+      if (this.disabled) {
+         return true;
+      } else {
+         float var13 = (float)var1;
+         float var14 = (float)var3;
+         float var15 = (float)var5;
+         float var16 = (float)var7;
+         float var17 = (float)var9;
+         float var18 = (float)var11;
 
-      return true;
+         for (int var19 = 0; var19 < 6; var19++) {
+            float[] var20 = this.frustum[var19];
+            float var21 = var20[0];
+            float var22 = var20[1];
+            float var23 = var20[2];
+            float var24 = var20[3];
+            if (var19 < 4) {
+               if (var21 * var13 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+                  || var21 * var16 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+                  || var21 * var13 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+                  || var21 * var16 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+                  || var21 * var13 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+                  || var21 * var16 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+                  || var21 * var13 + var22 * var17 + var23 * var18 + var24 <= 0.0F
+                  || var21 * var16 + var22 * var17 + var23 * var18 + var24 <= 0.0F) {
+                  return false;
+               }
+            } else if (var21 * var13 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+               && var21 * var16 + var22 * var14 + var23 * var15 + var24 <= 0.0F
+               && var21 * var13 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+               && var21 * var16 + var22 * var17 + var23 * var15 + var24 <= 0.0F
+               && var21 * var13 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+               && var21 * var16 + var22 * var14 + var23 * var18 + var24 <= 0.0F
+               && var21 * var13 + var22 * var17 + var23 * var18 + var24 <= 0.0F
+               && var21 * var16 + var22 * var17 + var23 * var18 + var24 <= 0.0F) {
+               return false;
+            }
+         }
+
+         return true;
+      }
    }
 }
--- net/minecraft/client/renderer/culling/ClippingHelperImpl.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/culling/ClippingHelperImpl.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/culling/Frustum.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/culling/Frustum.java	Mon Aug 18 09:39:52 2025
@@ -13,22 +13,24 @@
    }
 
    public Frustum(ClippingHelper var1) {
       this.clippingHelper = var1;
    }
 
-   @Override
    public void setPosition(double var1, double var3, double var5) {
       this.x = var1;
       this.y = var3;
       this.z = var5;
    }
 
    public boolean isBoxInFrustum(double var1, double var3, double var5, double var7, double var9, double var11) {
       return this.clippingHelper.isBoxInFrustum(var1 - this.x, var3 - this.y, var5 - this.z, var7 - this.x, var9 - this.y, var11 - this.z);
    }
 
-   @Override
    public boolean isBoundingBoxInFrustum(AxisAlignedBB var1) {
       return this.isBoxInFrustum(var1.minX, var1.minY, var1.minZ, var1.maxX, var1.maxY, var1.maxZ);
+   }
+
+   public boolean isBoxInFrustumFully(double var1, double var3, double var5, double var7, double var9, double var11) {
+      return this.clippingHelper.isBoxInFrustumFully(var1 - this.x, var3 - this.y, var5 - this.z, var7 - this.x, var9 - this.y, var11 - this.z);
    }
 }
--- net/minecraft/client/renderer/culling/ICamera.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/culling/ICamera.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRenderer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererChunkBorder.java	Mon Aug 18 09:39:52 2025
@@ -2,104 +2,114 @@
 
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.client.renderer.debug.DebugRenderer.IDebugRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.optifine.shaders.Shaders;
 
-public class DebugRendererChunkBorder implements DebugRenderer.IDebugRenderer {
+public class DebugRendererChunkBorder implements IDebugRenderer {
    private final Minecraft minecraft;
 
    public DebugRendererChunkBorder(Minecraft var1) {
       this.minecraft = var1;
    }
 
-   @Override
    public void render(float var1, long var2) {
-      EntityPlayerSP var4 = this.minecraft.player;
-      Tessellator var5 = Tessellator.getInstance();
-      BufferBuilder var6 = var5.getBuffer();
-      double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * var1;
-      double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * var1;
-      double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * var1;
-      double var13 = 0.0 - var9;
-      double var15 = 256.0 - var9;
-      GlStateManager.disableTexture2D();
-      GlStateManager.disableBlend();
-      double var17 = (var4.chunkCoordX << 4) - var7;
-      double var19 = (var4.chunkCoordZ << 4) - var11;
-      GlStateManager.glLineWidth(1.0F);
-      var6.begin(3, DefaultVertexFormats.POSITION_COLOR);
-
-      for (byte var21 = -16; var21 <= 32; var21 += 16) {
-         for (byte var22 = -16; var22 <= 32; var22 += 16) {
-            var6.pos(var17 + var21, var13, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
-            var6.pos(var17 + var21, var13, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
-            var6.pos(var17 + var21, var15, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
-            var6.pos(var17 + var21, var15, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+      if (!Shaders.isShadowPass) {
+         if (Config.isShaders()) {
+            Shaders.beginLeash();
          }
-      }
 
-      for (byte var24 = 2; var24 < 16; var24 += 2) {
-         var6.pos(var17 + var24, var13, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17 + var24, var13, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + var24, var15, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + var24, var15, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17 + var24, var13, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17 + var24, var13, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + var24, var15, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + var24, var15, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         EntityPlayerSP var4 = this.minecraft.player;
+         Tessellator var5 = Tessellator.getInstance();
+         BufferBuilder var6 = var5.getBuffer();
+         double var7 = var4.lastTickPosX + (var4.posX - var4.lastTickPosX) * var1;
+         double var9 = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * var1;
+         double var11 = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * var1;
+         double var13 = 0.0 - var9;
+         double var15 = 256.0 - var9;
+         GlStateManager.disableTexture2D();
+         GlStateManager.disableBlend();
+         double var17 = (var4.chunkCoordX << 4) - var7;
+         double var19 = (var4.chunkCoordZ << 4) - var11;
+         GlStateManager.glLineWidth(1.0F);
+         var6.begin(3, DefaultVertexFormats.POSITION_COLOR);
+
+         for (byte var21 = -16; var21 <= 32; var21 += 16) {
+            for (byte var22 = -16; var22 <= 32; var22 += 16) {
+               var6.pos(var17 + var21, var13, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+               var6.pos(var17 + var21, var13, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
+               var6.pos(var17 + var21, var15, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.5F).endVertex();
+               var6.pos(var17 + var21, var15, var19 + var22).color(1.0F, 0.0F, 0.0F, 0.0F).endVertex();
+            }
+         }
 
-      for (byte var25 = 2; var25 < 16; var25 += 2) {
-         var6.pos(var17, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17 + 16.0, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17 + 16.0, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         for (byte var24 = 2; var24 < 16; var24 += 2) {
+            var6.pos(var17 + var24, var13, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17 + var24, var13, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + var24, var15, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + var24, var15, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17 + var24, var13, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17 + var24, var13, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + var24, var15, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + var24, var15, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+         }
 
-      for (byte var26 = 0; var26 <= 256; var26 += 2) {
-         double var29 = var26 - var9;
-         var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-         var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17, var29, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var29, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
-         var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
-      }
+         for (byte var25 = 2; var25 < 16; var25 += 2) {
+            var6.pos(var17, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17 + 16.0, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17 + 16.0, var13, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var15, var19 + var25).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+         }
 
-      var5.draw();
-      GlStateManager.glLineWidth(2.0F);
-      var6.begin(3, DefaultVertexFormats.POSITION_COLOR);
-
-      for (byte var27 = 0; var27 <= 16; var27 += 16) {
-         for (byte var30 = 0; var30 <= 16; var30 += 16) {
-            var6.pos(var17 + var27, var13, var19 + var30).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-            var6.pos(var17 + var27, var13, var19 + var30).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-            var6.pos(var17 + var27, var15, var19 + var30).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-            var6.pos(var17 + var27, var15, var19 + var30).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+         for (byte var26 = 0; var26 <= 256; var26 += 2) {
+            double var29 = var26 - var9;
+            var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
+            var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17, var29, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var29, var19 + 16.0).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 1.0F).endVertex();
+            var6.pos(var17, var29, var19).color(1.0F, 1.0F, 0.0F, 0.0F).endVertex();
          }
-      }
 
-      for (byte var28 = 0; var28 <= 256; var28 += 16) {
-         double var31 = var28 - var9;
-         var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-         var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         var6.pos(var17, var31, var19 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var31, var19 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         var6.pos(var17 + 16.0, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
-         var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
-      }
+         var5.draw();
+         GlStateManager.glLineWidth(2.0F);
+         var6.begin(3, DefaultVertexFormats.POSITION_COLOR);
+
+         for (byte var27 = 0; var27 <= 16; var27 += 16) {
+            for (byte var30 = 0; var30 <= 16; var30 += 16) {
+               var6.pos(var17 + var27, var13, var19 + var30).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+               var6.pos(var17 + var27, var13, var19 + var30).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+               var6.pos(var17 + var27, var15, var19 + var30).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+               var6.pos(var17 + var27, var15, var19 + var30).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+            }
+         }
 
-      var5.draw();
-      GlStateManager.glLineWidth(1.0F);
-      GlStateManager.enableBlend();
-      GlStateManager.enableTexture2D();
+         for (byte var28 = 0; var28 <= 256; var28 += 16) {
+            double var31 = var28 - var9;
+            var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+            var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            var6.pos(var17, var31, var19 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var31, var19 + 16.0).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            var6.pos(var17 + 16.0, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 1.0F).endVertex();
+            var6.pos(var17, var31, var19).color(0.25F, 0.25F, 1.0F, 0.0F).endVertex();
+         }
+
+         var5.draw();
+         GlStateManager.glLineWidth(1.0F);
+         GlStateManager.enableBlend();
+         GlStateManager.enableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.endLeash();
+         }
+      }
    }
 }
--- net/minecraft/client/renderer/debug/DebugRendererCollisionBox.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererCollisionBox.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererHeightMap.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererHeightMap.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererNeighborsUpdate.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererNeighborsUpdate.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererPathfinding.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererPathfinding.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererSolidFace.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererSolidFace.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/debug/DebugRendererWater.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/debug/DebugRendererWater.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerArmorBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerArmorBase.java	Mon Aug 18 09:39:52 2025
@@ -3,17 +3,23 @@
 import com.google.common.collect.Maps;
 import java.util.Map;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.model.ModelBase;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderLivingBase;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.item.ItemArmor;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
 
 public abstract class LayerArmorBase<T extends ModelBase> implements LayerRenderer<EntityLivingBase> {
    protected static final ResourceLocation ENCHANTED_ITEM_GLINT_RES = new ResourceLocation("textures/misc/enchanted_item_glint.png");
    protected T modelLeggings;
    protected T modelArmor;
    private final RenderLivingBase<?> renderer;
@@ -26,57 +32,94 @@
 
    public LayerArmorBase(RenderLivingBase<?> var1) {
       this.renderer = var1;
       this.initArmor();
    }
 
-   @Override
    public void doRenderLayer(EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
       this.renderArmorLayer(var1, var2, var3, var4, var5, var6, var7, var8, EntityEquipmentSlot.CHEST);
       this.renderArmorLayer(var1, var2, var3, var4, var5, var6, var7, var8, EntityEquipmentSlot.LEGS);
       this.renderArmorLayer(var1, var2, var3, var4, var5, var6, var7, var8, EntityEquipmentSlot.FEET);
       this.renderArmorLayer(var1, var2, var3, var4, var5, var6, var7, var8, EntityEquipmentSlot.HEAD);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 
    private void renderArmorLayer(
       EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8, EntityEquipmentSlot var9
    ) {
       ItemStack var10 = var1.getItemStackFromSlot(var9);
       if (var10.getItem() instanceof ItemArmor) {
          ItemArmor var11 = (ItemArmor)var10.getItem();
          if (var11.getEquipmentSlot() == var9) {
             ModelBase var12 = this.getModelFromSlot(var9);
+            if (Reflector.ForgeHooksClient.exists()) {
+               var12 = this.getArmorModelHook(var1, var10, var9, (T)var12);
+            }
+
             var12.setModelAttributes(this.renderer.getMainModel());
             var12.setLivingAnimations(var1, var2, var3, var4);
             this.setModelSlotVisible((T)var12, var9);
             boolean var13 = this.isLegSlot(var9);
-            this.renderer.bindTexture(this.getArmorResource(var11, var13));
+            if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(var10, var9, null)) {
+               if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
+                  this.renderer.bindTexture(this.getArmorResource(var1, var10, var9, null));
+               } else {
+                  this.renderer.bindTexture(this.getArmorResource(var11, var13));
+               }
+            }
+
+            if (Reflector.ForgeHooksClient_getArmorTexture.exists()) {
+               if (ReflectorForge.armorHasOverlay(var11, var10)) {
+                  int var18 = var11.getColor(var10);
+                  float var19 = (var18 >> 16 & 0xFF) / 255.0F;
+                  float var20 = (var18 >> 8 & 0xFF) / 255.0F;
+                  float var21 = (var18 & 0xFF) / 255.0F;
+                  GlStateManager.color(this.colorR * var19, this.colorG * var20, this.colorB * var21, this.alpha);
+                  var12.render(var1, var2, var3, var5, var6, var7, var8);
+                  if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(var10, var9, "overlay")) {
+                     this.renderer.bindTexture(this.getArmorResource(var1, var10, var9, "overlay"));
+                  }
+               }
+
+               GlStateManager.color(this.colorR, this.colorG, this.colorB, this.alpha);
+               var12.render(var1, var2, var3, var5, var6, var7, var8);
+               if (!this.skipRenderGlint
+                  && var10.hasEffect()
+                  && (!Config.isCustomItems() || !CustomItems.renderCustomArmorEffect(var1, var10, var12, var2, var3, var4, var5, var6, var7, var8))) {
+                  renderEnchantedGlint(this.renderer, var1, var12, var2, var3, var4, var5, var6, var7, var8);
+               }
+
+               return;
+            }
+
             switch (var11.getArmorMaterial()) {
                case LEATHER:
                   int var14 = var11.getColor(var10);
                   float var15 = (var14 >> 16 & 0xFF) / 255.0F;
                   float var16 = (var14 >> 8 & 0xFF) / 255.0F;
                   float var17 = (var14 & 0xFF) / 255.0F;
                   GlStateManager.color(this.colorR * var15, this.colorG * var16, this.colorB * var17, this.alpha);
                   var12.render(var1, var2, var3, var5, var6, var7, var8);
-                  this.renderer.bindTexture(this.getArmorResource(var11, var13, "overlay"));
+                  if (!Config.isCustomItems() || !CustomItems.bindCustomArmorTexture(var10, var9, "overlay")) {
+                     this.renderer.bindTexture(this.getArmorResource(var11, var13, "overlay"));
+                  }
                case CHAIN:
                case IRON:
                case GOLD:
                case DIAMOND:
                   GlStateManager.color(this.colorR, this.colorG, this.colorB, this.alpha);
                   var12.render(var1, var2, var3, var5, var6, var7, var8);
-               default:
-                  if (!this.skipRenderGlint && var10.isItemEnchanted()) {
-                     renderEnchantedGlint(this.renderer, var1, var12, var2, var3, var4, var5, var6, var7, var8);
-                  }
+            }
+
+            if (!this.skipRenderGlint
+               && var10.isItemEnchanted()
+               && (!Config.isCustomItems() || !CustomItems.renderCustomArmorEffect(var1, var10, var12, var2, var3, var4, var5, var6, var7, var8))) {
+               renderEnchantedGlint(this.renderer, var1, var12, var2, var3, var4, var5, var6, var7, var8);
             }
          }
       }
    }
 
    public T getModelFromSlot(EntityEquipmentSlot var1) {
@@ -87,49 +130,58 @@
       return var1 == EntityEquipmentSlot.LEGS;
    }
 
    public static void renderEnchantedGlint(
       RenderLivingBase<?> var0, EntityLivingBase var1, ModelBase var2, float var3, float var4, float var5, float var6, float var7, float var8, float var9
    ) {
-      float var10 = var1.ticksExisted + var5;
-      var0.bindTexture(ENCHANTED_ITEM_GLINT_RES);
-      Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      GlStateManager.enableBlend();
-      GlStateManager.depthFunc(514);
-      GlStateManager.depthMask(false);
-      float var11 = 0.5F;
-      GlStateManager.color(0.5F, 0.5F, 0.5F, 1.0F);
-
-      for (int var12 = 0; var12 < 2; var12++) {
-         GlStateManager.disableLighting();
-         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
-         float var13 = 0.76F;
-         GlStateManager.color(0.38F, 0.19F, 0.608F, 1.0F);
+      if (!Config.isShaders() || !Shaders.isShadowPass) {
+         float var10 = var1.ticksExisted + var5;
+         var0.bindTexture(ENCHANTED_ITEM_GLINT_RES);
+         if (Config.isShaders()) {
+            ShadersRender.renderEnchantedGlintBegin();
+         }
+
+         Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+         GlStateManager.enableBlend();
+         GlStateManager.depthFunc(514);
+         GlStateManager.depthMask(false);
+         float var11 = 0.5F;
+         GlStateManager.color(0.5F, 0.5F, 0.5F, 1.0F);
+
+         for (int var12 = 0; var12 < 2; var12++) {
+            GlStateManager.disableLighting();
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
+            float var13 = 0.76F;
+            GlStateManager.color(0.38F, 0.19F, 0.608F, 1.0F);
+            GlStateManager.matrixMode(5890);
+            GlStateManager.loadIdentity();
+            float var14 = 0.33333334F;
+            GlStateManager.scale(0.33333334F, 0.33333334F, 0.33333334F);
+            GlStateManager.rotate(30.0F - var12 * 60.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.translate(0.0F, var10 * (0.001F + var12 * 0.003F) * 20.0F, 0.0F);
+            GlStateManager.matrixMode(5888);
+            var2.render(var1, var3, var4, var6, var7, var8, var9);
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+         }
+
          GlStateManager.matrixMode(5890);
          GlStateManager.loadIdentity();
-         float var14 = 0.33333334F;
-         GlStateManager.scale(0.33333334F, 0.33333334F, 0.33333334F);
-         GlStateManager.rotate(30.0F - var12 * 60.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.translate(0.0F, var10 * (0.001F + var12 * 0.003F) * 20.0F, 0.0F);
          GlStateManager.matrixMode(5888);
-         var2.render(var1, var3, var4, var6, var7, var8, var9);
-         GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+         GlStateManager.enableLighting();
+         GlStateManager.depthMask(true);
+         GlStateManager.depthFunc(515);
+         GlStateManager.disableBlend();
+         Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
+         if (Config.isShaders()) {
+            ShadersRender.renderEnchantedGlintEnd();
+         }
       }
-
-      GlStateManager.matrixMode(5890);
-      GlStateManager.loadIdentity();
-      GlStateManager.matrixMode(5888);
-      GlStateManager.enableLighting();
-      GlStateManager.depthMask(true);
-      GlStateManager.depthFunc(515);
-      GlStateManager.disableBlend();
-      Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
    }
 
    private ResourceLocation getArmorResource(ItemArmor var1, boolean var2) {
-      return this.getArmorResource(var1, var2, null);
+      return this.getArmorResource(var1, var2, (String)null);
    }
 
    private ResourceLocation getArmorResource(ItemArmor var1, boolean var2, String var3) {
       String var4 = String.format(
          "textures/models/armor/%s_layer_%d%s.png", var1.getArmorMaterial().getName(), var2 ? 2 : 1, var3 == null ? "" : String.format("_%s", var3)
       );
@@ -142,7 +194,34 @@
       return var5;
    }
 
    protected abstract void initArmor();
 
    protected abstract void setModelSlotVisible(T var1, EntityEquipmentSlot var2);
+
+   protected T getArmorModelHook(EntityLivingBase var1, ItemStack var2, EntityEquipmentSlot var3, T var4) {
+      return (T)var4;
+   }
+
+   public ResourceLocation getArmorResource(Entity var1, ItemStack var2, EntityEquipmentSlot var3, String var4) {
+      ItemArmor var5 = (ItemArmor)var2.getItem();
+      String var6 = var5.getArmorMaterial().getName();
+      String var7 = "minecraft";
+      int var8 = var6.indexOf(58);
+      if (var8 != -1) {
+         var7 = var6.substring(0, var8);
+         var6 = var6.substring(var8 + 1);
+      }
+
+      String var9 = String.format(
+         "%s:textures/models/armor/%s_layer_%d%s.png", var7, var6, this.isLegSlot(var3) ? 2 : 1, var4 == null ? "" : String.format("_%s", var4)
+      );
+      var9 = Reflector.callString(Reflector.ForgeHooksClient_getArmorTexture, new Object[]{var1, var2, var9, var3, var4});
+      ResourceLocation var10 = ARMOR_TEXTURE_RES_MAP.get(var9);
+      if (var10 == null) {
+         var10 = new ResourceLocation(var9);
+         ARMOR_TEXTURE_RES_MAP.put(var9, var10);
+      }
+
+      return var10;
+   }
 }
--- net/minecraft/client/renderer/entity/layers/LayerArrow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerArrow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerBipedArmor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerBipedArmor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerCape.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerCape.java	Mon Aug 18 09:39:52 2025
@@ -35,29 +35,37 @@
             float var22 = (float)(var10 * var17 + var14 * var19) * 100.0F;
             float var23 = (float)(var10 * var19 - var14 * var17) * 100.0F;
             if (var22 < 0.0F) {
                var22 = 0.0F;
             }
 
+            if (var22 > 165.0F) {
+               var22 = 165.0F;
+            }
+
+            if (var21 < -5.0F) {
+               var21 = -5.0F;
+            }
+
             float var24 = var1.prevCameraYaw + (var1.cameraYaw - var1.prevCameraYaw) * var4;
             var21 += MathHelper.sin((var1.prevDistanceWalkedModified + (var1.distanceWalkedModified - var1.prevDistanceWalkedModified) * var4) * 6.0F)
                * 32.0F
                * var24;
             if (var1.isSneaking()) {
                var21 += 25.0F;
+               GlStateManager.translate(0.0F, 0.142F, -0.0178F);
             }
 
             GlStateManager.rotate(6.0F + var22 / 2.0F + var21, 1.0F, 0.0F, 0.0F);
             GlStateManager.rotate(var23 / 2.0F, 0.0F, 0.0F, 1.0F);
             GlStateManager.rotate(-var23 / 2.0F, 0.0F, 1.0F, 0.0F);
             GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
             this.playerRenderer.getMainModel().renderCape(0.0625F);
             GlStateManager.popMatrix();
          }
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerCreeperCharge.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerCreeperCharge.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerCustomHead.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerCustomHead.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerDeadmau5Head.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerDeadmau5Head.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerElytra.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerElytra.java	Mon Aug 18 09:39:52 2025
@@ -7,40 +7,50 @@
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.player.EnumPlayerModelParts;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomItems;
 
 public class LayerElytra implements LayerRenderer<EntityLivingBase> {
    private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");
    protected final RenderLivingBase<?> renderPlayer;
    private final ModelElytra modelElytra = new ModelElytra();
 
    public LayerElytra(RenderLivingBase<?> var1) {
       this.renderPlayer = var1;
    }
 
-   @Override
    public void doRenderLayer(EntityLivingBase var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
       ItemStack var9 = var1.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
       if (var9.getItem() == Items.ELYTRA) {
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
          GlStateManager.enableBlend();
          GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
          if (var1 instanceof AbstractClientPlayer) {
-            AbstractClientPlayer var10 = (AbstractClientPlayer)var1;
-            if (var10.isPlayerInfoSet() && var10.getLocationElytra() != null) {
-               this.renderPlayer.bindTexture(var10.getLocationElytra());
-            } else if (var10.hasPlayerInfo() && var10.getLocationCape() != null && var10.isWearing(EnumPlayerModelParts.CAPE)) {
-               this.renderPlayer.bindTexture(var10.getLocationCape());
+            AbstractClientPlayer var12 = (AbstractClientPlayer)var1;
+            if (var12.isPlayerInfoSet() && var12.getLocationElytra() != null) {
+               this.renderPlayer.bindTexture(var12.getLocationElytra());
+            } else if (var12.hasElytraCape() && var12.hasPlayerInfo() && var12.getLocationCape() != null && var12.isWearing(EnumPlayerModelParts.CAPE)) {
+               this.renderPlayer.bindTexture(var12.getLocationCape());
             } else {
-               this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
+               ResourceLocation var11 = TEXTURE_ELYTRA;
+               if (Config.isCustomItems()) {
+                  var11 = CustomItems.getCustomElytraTexture(var9, var11);
+               }
+
+               this.renderPlayer.bindTexture(var11);
             }
          } else {
-            this.renderPlayer.bindTexture(TEXTURE_ELYTRA);
+            ResourceLocation var10 = TEXTURE_ELYTRA;
+            if (Config.isCustomItems()) {
+               var10 = CustomItems.getCustomElytraTexture(var9, var10);
+            }
+
+            this.renderPlayer.bindTexture(var10);
          }
 
          GlStateManager.pushMatrix();
          GlStateManager.translate(0.0F, 0.0F, 0.125F);
          this.modelElytra.setRotationAngles(var2, var3, var5, var6, var7, var8, var1);
          this.modelElytra.render(var1, var2, var3, var5, var6, var7, var8);
@@ -50,11 +60,10 @@
 
          GlStateManager.disableBlend();
          GlStateManager.popMatrix();
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerEnderDragonDeath.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerEnderDragonDeath.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerEnderDragonEyes.java	Mon Aug 18 09:39:52 2025
@@ -3,42 +3,52 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.entity.RenderDragon;
 import net.minecraft.entity.boss.EntityDragon;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEnderDragonEyes implements LayerRenderer<EntityDragon> {
    private static final ResourceLocation TEXTURE = new ResourceLocation("textures/entity/enderdragon/dragon_eyes.png");
    private final RenderDragon dragonRenderer;
 
    public LayerEnderDragonEyes(RenderDragon var1) {
       this.dragonRenderer = var1;
    }
 
    public void doRenderLayer(EntityDragon var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.dragonRenderer.bindTexture(TEXTURE);
+      this.dragonRenderer.a(TEXTURE);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
       GlStateManager.disableLighting();
       GlStateManager.depthFunc(514);
       char var9 = '\uf0f0';
       char var10 = '\uf0f0';
       boolean var11 = false;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
       GlStateManager.enableLighting();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      this.dragonRenderer.getMainModel().render(var1, var2, var3, var5, var6, var7, var8);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
+      this.dragonRenderer.b().render(var1, var2, var3, var5, var6, var7, var8);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-      this.dragonRenderer.setLightmap(var1);
+      this.dragonRenderer.c(var1);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
       GlStateManager.depthFunc(515);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerEndermanEyes.java	Mon Aug 18 09:39:52 2025
@@ -3,42 +3,52 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.entity.RenderEnderman;
 import net.minecraft.entity.monster.EntityEnderman;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEndermanEyes implements LayerRenderer<EntityEnderman> {
    private static final ResourceLocation RES_ENDERMAN_EYES = new ResourceLocation("textures/entity/enderman/enderman_eyes.png");
    private final RenderEnderman endermanRenderer;
 
    public LayerEndermanEyes(RenderEnderman var1) {
       this.endermanRenderer = var1;
    }
 
    public void doRenderLayer(EntityEnderman var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.endermanRenderer.bindTexture(RES_ENDERMAN_EYES);
+      this.endermanRenderer.a(RES_ENDERMAN_EYES);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
       GlStateManager.disableLighting();
       GlStateManager.depthMask(!var1.isInvisible());
       char var9 = '\uf0f0';
       char var10 = '\uf0f0';
       boolean var11 = false;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 61680.0F, 0.0F);
       GlStateManager.enableLighting();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
       this.endermanRenderer.getMainModel().render(var1, var2, var3, var5, var6, var7, var8);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
-      this.endermanRenderer.setLightmap(var1);
+      this.endermanRenderer.c(var1);
       GlStateManager.depthMask(true);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerEntityOnShoulder.java	Mon Aug 18 09:39:52 2025
@@ -1,22 +1,26 @@
 package net.minecraft.client.renderer.entity.layers;
 
 import java.util.UUID;
 import javax.annotation.Nullable;
+import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.model.ModelBase;
 import net.minecraft.client.model.ModelParrot;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderLivingBase;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.entity.RenderParrot;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityList;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.passive.EntityParrot;
+import net.minecraft.entity.passive.EntityShoulderRiding;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerEntityOnShoulder implements LayerRenderer<EntityPlayer> {
    private final RenderManager renderManager;
    protected RenderLivingBase<? extends EntityLivingBase> leftRenderer;
    private ModelBase leftModel;
    private ResourceLocation leftResource;
@@ -116,29 +120,45 @@
             var4 = new RenderParrot(this.renderManager);
             var5 = new ModelParrot();
             var6 = RenderParrot.PARROT_TEXTURES[var3.getInteger("Variant")];
          }
       }
 
+      Entity var16 = Config.getRenderGlobal().renderedEntity;
+      if (var1 instanceof AbstractClientPlayer) {
+         AbstractClientPlayer var17 = (AbstractClientPlayer)var1;
+         EntityShoulderRiding var18 = var2 == this.leftUniqueId ? var17.entityShoulderLeft : var17.entityShoulderRight;
+         if (var18 != null) {
+            Config.getRenderGlobal().renderedEntity = var18;
+            if (Config.isShaders()) {
+               Shaders.nextEntity(var18);
+            }
+         }
+      }
+
       ((RenderLivingBase)var4).bindTexture(var6);
       GlStateManager.pushMatrix();
-      float var16 = var1.isSneaking() ? -1.3F : -1.5F;
-      float var17 = var15 ? 0.4F : -0.4F;
-      GlStateManager.translate(var17, var16, 0.0F);
+      float var19 = var1.isSneaking() ? -1.3F : -1.5F;
+      float var20 = var15 ? 0.4F : -0.4F;
+      GlStateManager.translate(var20, var19, 0.0F);
       if (var7 == EntityParrot.class) {
          var11 = 0.0F;
       }
 
-      ((ModelBase)var5).setLivingAnimations(var1, var8, var9, var10);
-      ((ModelBase)var5).setRotationAngles(var8, var9, var11, var12, var13, var14, var1);
-      ((ModelBase)var5).render(var1, var8, var9, var11, var12, var13, var14);
+      var5.setLivingAnimations(var1, var8, var9, var10);
+      var5.setRotationAngles(var8, var9, var11, var12, var13, var14, var1);
+      var5.render(var1, var8, var9, var11, var12, var13, var14);
       GlStateManager.popMatrix();
+      Config.getRenderGlobal().renderedEntity = var16;
+      if (Config.isShaders()) {
+         Shaders.nextEntity(var16);
+      }
+
       return new LayerEntityOnShoulder.DataHolder(var2, (RenderLivingBase<? extends EntityLivingBase>)var4, (ModelBase)var5, var6, var7);
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 
    class DataHolder {
       public UUID entityId;
--- net/minecraft/client/renderer/entity/layers/LayerHeldBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerHeldBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerHeldItem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerHeldItem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerHeldItemWitch.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerHeldItemWitch.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerIronGolemFlower.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerIronGolemFlower.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerLlamaDecor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerLlamaDecor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerMooshroomMushroom.java	Mon Aug 18 09:39:52 2025
@@ -1,56 +1,94 @@
 package net.minecraft.client.renderer.entity.layers;
 
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.model.ModelRenderer;
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderMooshroom;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.entity.passive.EntityMooshroom;
 import net.minecraft.init.Blocks;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.MathHelper;
 
 public class LayerMooshroomMushroom implements LayerRenderer<EntityMooshroom> {
    private final RenderMooshroom mooshroomRenderer;
+   private ModelRenderer modelRendererMushroom;
+   private static final ResourceLocation LOCATION_MUSHROOM_RED = new ResourceLocation("textures/entity/cow/mushroom_red.png");
+   private static boolean hasTextureMushroom = false;
+
+   public static void update() {
+      hasTextureMushroom = Config.hasResource(LOCATION_MUSHROOM_RED);
+   }
 
    public LayerMooshroomMushroom(RenderMooshroom var1) {
       this.mooshroomRenderer = var1;
+      this.modelRendererMushroom = new ModelRenderer(this.mooshroomRenderer.f);
+      this.modelRendererMushroom.setTextureSize(16, 16);
+      this.modelRendererMushroom.rotationPointX = -6.0F;
+      this.modelRendererMushroom.rotationPointZ = -8.0F;
+      this.modelRendererMushroom.rotateAngleY = MathHelper.PI / 4.0F;
+      int[][] var2 = new int[][]{null, null, {16, 16, 0, 0}, {16, 16, 0, 0}, null, null};
+      this.modelRendererMushroom.addBox(var2, 0.0F, 0.0F, 10.0F, 20.0F, 16.0F, 0.0F, 0.0F);
+      int[][] var3 = new int[][]{null, null, null, null, {16, 16, 0, 0}, {16, 16, 0, 0}};
+      this.modelRendererMushroom.addBox(var3, 10.0F, 0.0F, 0.0F, 0.0F, 16.0F, 20.0F, 0.0F);
    }
 
    public void doRenderLayer(EntityMooshroom var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (!var1.isChild() && !var1.isInvisible()) {
+      if (!var1.l_() && !var1.aX()) {
          BlockRendererDispatcher var9 = Minecraft.getMinecraft().getBlockRendererDispatcher();
-         this.mooshroomRenderer.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+         if (hasTextureMushroom) {
+            this.mooshroomRenderer.a(LOCATION_MUSHROOM_RED);
+         } else {
+            this.mooshroomRenderer.a(TextureMap.LOCATION_BLOCKS_TEXTURE);
+         }
+
          GlStateManager.enableCull();
          GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
          GlStateManager.pushMatrix();
          GlStateManager.scale(1.0F, -1.0F, 1.0F);
          GlStateManager.translate(0.2F, 0.35F, 0.5F);
          GlStateManager.rotate(42.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.pushMatrix();
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.pushMatrix();
          GlStateManager.translate(0.1F, 0.0F, -0.6F);
          GlStateManager.rotate(42.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.popMatrix();
          GlStateManager.pushMatrix();
-         this.mooshroomRenderer.getMainModel().head.postRender(0.0625F);
+         this.mooshroomRenderer.getMainModel().modelTextureMap.postRender(0.0625F);
          GlStateManager.scale(1.0F, -1.0F, 1.0F);
          GlStateManager.translate(0.0F, 0.7F, -0.2F);
          GlStateManager.rotate(12.0F, 0.0F, 1.0F, 0.0F);
          GlStateManager.translate(-0.5F, -0.5F, 0.5F);
-         var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         if (hasTextureMushroom) {
+            this.modelRendererMushroom.render(0.0625F);
+         } else {
+            var9.renderBlockBrightness(Blocks.RED_MUSHROOM.getDefaultState(), 1.0F);
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.cullFace(GlStateManager.CullFace.BACK);
          GlStateManager.disableCull();
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerRenderer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerSaddle.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerSaddle.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerSheepWool.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerSheepWool.java	Mon Aug 18 09:39:52 2025
@@ -3,17 +3,18 @@
 import net.minecraft.client.model.ModelSheep1;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderSheep;
 import net.minecraft.entity.passive.EntitySheep;
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
 
 public class LayerSheepWool implements LayerRenderer<EntitySheep> {
    private static final ResourceLocation TEXTURE = new ResourceLocation("textures/entity/sheep/sheep_fur.png");
    private final RenderSheep sheepRenderer;
-   private final ModelSheep1 sheepModel = new ModelSheep1();
+   public ModelSheep1 sheepModel = new ModelSheep1();
 
    public LayerSheepWool(RenderSheep var1) {
       this.sheepRenderer = var1;
    }
 
    public void doRenderLayer(EntitySheep var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
@@ -25,25 +26,33 @@
             int var11 = EnumDyeColor.values().length;
             int var12 = var10 % var11;
             int var13 = (var10 + 1) % var11;
             float var14 = (var1.ticksExisted % 25 + var4) / 25.0F;
             float[] var15 = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(var12));
             float[] var16 = EntitySheep.getDyeRgb(EnumDyeColor.byMetadata(var13));
+            if (Config.isCustomColors()) {
+               var15 = CustomColors.getSheepColors(EnumDyeColor.byMetadata(var12), var15);
+               var16 = CustomColors.getSheepColors(EnumDyeColor.byMetadata(var13), var16);
+            }
+
             GlStateManager.color(
                var15[0] * (1.0F - var14) + var16[0] * var14, var15[1] * (1.0F - var14) + var16[1] * var14, var15[2] * (1.0F - var14) + var16[2] * var14
             );
          } else {
             float[] var9 = EntitySheep.getDyeRgb(var1.getFleeceColor());
+            if (Config.isCustomColors()) {
+               var9 = CustomColors.getSheepColors(var1.getFleeceColor(), var9);
+            }
+
             GlStateManager.color(var9[0], var9[1], var9[2]);
          }
 
-         this.sheepModel.setModelAttributes(this.sheepRenderer.getMainModel());
+         this.sheepModel.setModelAttributes(this.sheepRenderer.b());
          this.sheepModel.setLivingAnimations(var1, var2, var3, var4);
          this.sheepModel.render(var1, var2, var3, var5, var6, var7, var8);
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerSlimeGel.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerSlimeGel.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerSnowmanHead.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerSnowmanHead.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerSpiderEyes.java	Mon Aug 18 09:39:52 2025
@@ -3,23 +3,24 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.entity.RenderSpider;
 import net.minecraft.entity.monster.EntitySpider;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.Shaders;
 
 public class LayerSpiderEyes<T extends EntitySpider> implements LayerRenderer<T> {
    private static final ResourceLocation SPIDER_EYES = new ResourceLocation("textures/entity/spider_eyes.png");
    private final RenderSpider<T> spiderRenderer;
 
    public LayerSpiderEyes(RenderSpider<T> var1) {
       this.spiderRenderer = var1;
    }
 
    public void doRenderLayer(T var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      this.spiderRenderer.bindTexture(SPIDER_EYES);
+      this.spiderRenderer.a(SPIDER_EYES);
       GlStateManager.enableBlend();
       GlStateManager.disableAlpha();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
       if (var1.isInvisible()) {
          GlStateManager.depthMask(false);
       } else {
@@ -29,22 +30,31 @@
       int var9 = 61680;
       int var10 = var9 % 65536;
       int var11 = var9 / 65536;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var10, var11);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
-      this.spiderRenderer.getMainModel().render(var1, var2, var3, var5, var6, var7, var8);
+      if (Config.isShaders()) {
+         Shaders.beginSpiderEyes();
+      }
+
+      Config.getRenderGlobal().renderOverlayEyes = true;
+      this.spiderRenderer.b().render(var1, var2, var3, var5, var6, var7, var8);
+      Config.getRenderGlobal().renderOverlayEyes = false;
+      if (Config.isShaders()) {
+         Shaders.endSpiderEyes();
+      }
+
       Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
       var9 = var1.getBrightnessForRender();
       var10 = var9 % 65536;
       var11 = var9 / 65536;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var10, var11);
-      this.spiderRenderer.setLightmap((T)var1);
+      this.spiderRenderer.c(var1);
       GlStateManager.disableBlend();
       GlStateManager.enableAlpha();
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return false;
    }
 }
--- net/minecraft/client/renderer/entity/layers/LayerStrayClothing.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerStrayClothing.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerVillagerArmor.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerVillagerArmor.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerWitherAura.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerWitherAura.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/layers/LayerWolfCollar.java	Mon Aug 18 09:39:52 2025
@@ -1,29 +1,33 @@
 package net.minecraft.client.renderer.entity.layers;
 
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.entity.RenderWolf;
 import net.minecraft.entity.passive.EntityWolf;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomColors;
 
 public class LayerWolfCollar implements LayerRenderer<EntityWolf> {
    private static final ResourceLocation WOLF_COLLAR = new ResourceLocation("textures/entity/wolf/wolf_collar.png");
    private final RenderWolf wolfRenderer;
 
    public LayerWolfCollar(RenderWolf var1) {
       this.wolfRenderer = var1;
    }
 
    public void doRenderLayer(EntityWolf var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
-      if (var1.isTamed() && !var1.isInvisible()) {
-         this.wolfRenderer.bindTexture(WOLF_COLLAR);
+      if (var1.dl() && !var1.isInvisible()) {
+         this.wolfRenderer.a(WOLF_COLLAR);
          float[] var9 = var1.getCollarColor().getColorComponentValues();
+         if (Config.isCustomColors()) {
+            var9 = CustomColors.getWolfCollarColors(var1.getCollarColor(), var9);
+         }
+
          GlStateManager.color(var9[0], var9[1], var9[2]);
-         this.wolfRenderer.getMainModel().render(var1, var2, var3, var5, var6, var7, var8);
+         this.wolfRenderer.b().render(var1, var2, var3, var5, var6, var7, var8);
       }
    }
 
-   @Override
    public boolean shouldCombineTextures() {
       return true;
    }
 }
--- net/minecraft/client/renderer/entity/Render.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/Render.java	Mon Aug 18 09:39:52 2025
@@ -13,25 +13,30 @@
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.scoreboard.ScorePlayerTeam;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumBlockRenderType;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.World;
+import net.optifine.entity.model.IEntityRenderer;
+import net.optifine.shaders.Shaders;
 
-public abstract class Render<T extends Entity> {
+public abstract class Render<T extends Entity> implements IEntityRenderer {
    private static final ResourceLocation SHADOW_TEXTURES = new ResourceLocation("textures/misc/shadow.png");
    protected final RenderManager renderManager;
-   protected float shadowSize;
+   public float shadowSize;
    protected float shadowOpaque = 1.0F;
    protected boolean renderOutlines;
+   private Class entityClass = null;
+   private ResourceLocation locationTextureCustom = null;
 
    protected Render(RenderManager var1) {
       this.renderManager = var1;
    }
 
    public void setRenderOutlines(boolean var1) {
@@ -64,13 +69,13 @@
       }
 
       return var2;
    }
 
    protected void renderName(T var1, double var2, double var4, double var6) {
-      if (this.canRenderName(var1)) {
+      if (this.canRenderName((T)var1)) {
          this.renderLivingLabel((T)var1, var1.getDisplayName().getFormattedText(), var2, var4, var6, 64);
       }
    }
 
    protected boolean canRenderName(T var1) {
       return var1.getAlwaysRenderNameTagForRender() && var1.hasCustomName();
@@ -82,12 +87,16 @@
 
    @Nullable
    protected abstract ResourceLocation getEntityTexture(T var1);
 
    protected boolean bindEntityTexture(T var1) {
       ResourceLocation var2 = this.getEntityTexture((T)var1);
+      if (this.locationTextureCustom != null) {
+         var2 = this.locationTextureCustom;
+      }
+
       if (var2 == null) {
          return false;
       } else {
          this.bindTexture(var2);
          return true;
       }
@@ -114,104 +123,117 @@
       float var18 = (float)(var1.posY - var1.getEntityBoundingBox().minY);
       GlStateManager.rotate(-this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
       GlStateManager.translate(0.0F, 0.0F, -0.3F + (int)var17 * 0.02F);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       float var19 = 0.0F;
       int var20 = 0;
+      boolean var21 = Config.isMultiTexture();
+      if (var21) {
+         var14.setBlockLayer(BlockRenderLayer.SOLID);
+      }
+
       var14.begin(7, DefaultVertexFormats.POSITION_TEX);
 
       while (var17 > 0.0F) {
-         TextureAtlasSprite var21 = var20 % 2 == 0 ? var10 : var11;
+         TextureAtlasSprite var22 = var20 % 2 == 0 ? var10 : var11;
+         var14.setSprite(var22);
          this.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
-         float var22 = var21.getMinU();
-         float var23 = var21.getMinV();
-         float var24 = var21.getMaxU();
-         float var25 = var21.getMaxV();
+         float var23 = var22.getMinU();
+         float var24 = var22.getMinV();
+         float var25 = var22.getMaxU();
+         float var26 = var22.getMaxV();
          if (var20 / 2 % 2 == 0) {
-            float var26 = var24;
-            var24 = var22;
-            var22 = var26;
+            float var27 = var25;
+            var25 = var23;
+            var23 = var27;
          }
 
-         var14.pos(var15 - 0.0F, 0.0F - var18, var19).tex(var24, var25).endVertex();
-         var14.pos(-var15 - 0.0F, 0.0F - var18, var19).tex(var22, var25).endVertex();
-         var14.pos(-var15 - 0.0F, 1.4F - var18, var19).tex(var22, var23).endVertex();
-         var14.pos(var15 - 0.0F, 1.4F - var18, var19).tex(var24, var23).endVertex();
+         var14.pos(var15 - 0.0F, 0.0F - var18, var19).tex(var25, var26).endVertex();
+         var14.pos(-var15 - 0.0F, 0.0F - var18, var19).tex(var23, var26).endVertex();
+         var14.pos(-var15 - 0.0F, 1.4F - var18, var19).tex(var23, var24).endVertex();
+         var14.pos(var15 - 0.0F, 1.4F - var18, var19).tex(var25, var24).endVertex();
          var17 -= 0.45F;
          var18 -= 0.45F;
          var15 *= 0.9F;
          var19 += 0.03F;
          var20++;
       }
 
       var13.draw();
+      if (var21) {
+         var14.setBlockLayer(null);
+         GlStateManager.bindCurrentTexture();
+      }
+
       GlStateManager.popMatrix();
       GlStateManager.enableLighting();
    }
 
    private void renderShadow(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.enableBlend();
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
-      this.renderManager.renderEngine.bindTexture(SHADOW_TEXTURES);
-      World var10 = this.getWorldFromRenderManager();
-      GlStateManager.depthMask(false);
-      float var11 = this.shadowSize;
-      if (var1 instanceof EntityLiving) {
-         EntityLiving var12 = (EntityLiving)var1;
-         var11 *= var12.getRenderSizeModifier();
-         if (var12.isChild()) {
-            var11 *= 0.5F;
+      if (!Config.isShaders() || !Shaders.shouldSkipDefaultShadow) {
+         GlStateManager.enableBlend();
+         GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+         this.renderManager.renderEngine.bindTexture(SHADOW_TEXTURES);
+         World var10 = this.getWorldFromRenderManager();
+         GlStateManager.depthMask(false);
+         float var11 = this.shadowSize;
+         if (var1 instanceof EntityLiving) {
+            EntityLiving var12 = (EntityLiving)var1;
+            var11 *= var12.getRenderSizeModifier();
+            if (var12.isChild()) {
+               var11 *= 0.5F;
+            }
          }
-      }
 
-      double var35 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var9;
-      double var14 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var9;
-      double var16 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var9;
-      int var18 = MathHelper.floor(var35 - var11);
-      int var19 = MathHelper.floor(var35 + var11);
-      int var20 = MathHelper.floor(var14 - var11);
-      int var21 = MathHelper.floor(var14);
-      int var22 = MathHelper.floor(var16 - var11);
-      int var23 = MathHelper.floor(var16 + var11);
-      double var24 = var2 - var35;
-      double var26 = var4 - var14;
-      double var28 = var6 - var16;
-      Tessellator var30 = Tessellator.getInstance();
-      BufferBuilder var31 = var30.getBuffer();
-      var31.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-
-      for (BlockPos var33 : BlockPos.getAllInBoxMutable(new BlockPos(var18, var20, var22), new BlockPos(var19, var21, var23))) {
-         IBlockState var34 = var10.getBlockState(var33.down());
-         if (var34.getRenderType() != EnumBlockRenderType.INVISIBLE && var10.getLightFromNeighbors(var33) > 3) {
-            this.renderShadowSingle(var34, var2, var4, var6, var33, var8, var11, var24, var26, var28);
+         double var35 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var9;
+         double var14 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var9;
+         double var16 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var9;
+         int var18 = MathHelper.floor(var35 - var11);
+         int var19 = MathHelper.floor(var35 + var11);
+         int var20 = MathHelper.floor(var14 - var11);
+         int var21 = MathHelper.floor(var14);
+         int var22 = MathHelper.floor(var16 - var11);
+         int var23 = MathHelper.floor(var16 + var11);
+         double var24 = var2 - var35;
+         double var26 = var4 - var14;
+         double var28 = var6 - var16;
+         Tessellator var30 = Tessellator.getInstance();
+         BufferBuilder var31 = var30.getBuffer();
+         var31.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+
+         for (BlockPos var33 : BlockPos.getAllInBoxMutable(new BlockPos(var18, var20, var22), new BlockPos(var19, var21, var23))) {
+            IBlockState var34 = var10.getBlockState(var33.down());
+            if (var34.i() != EnumBlockRenderType.INVISIBLE && var10.getLightFromNeighbors(var33) > 3) {
+               this.renderShadowSingle(var34, var2, var4, var6, var33, var8, var11, var24, var26, var28);
+            }
          }
-      }
 
-      var30.draw();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.disableBlend();
-      GlStateManager.depthMask(true);
+         var30.draw();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.disableBlend();
+         GlStateManager.depthMask(true);
+      }
    }
 
    private World getWorldFromRenderManager() {
       return this.renderManager.world;
    }
 
    private void renderShadowSingle(
       IBlockState var1, double var2, double var4, double var6, BlockPos var8, float var9, float var10, double var11, double var13, double var15
    ) {
-      if (var1.isFullCube()) {
+      if (var1.g()) {
          Tessellator var17 = Tessellator.getInstance();
          BufferBuilder var18 = var17.getBuffer();
          double var19 = (var9 - (var4 - (var8.getY() + var13)) / 2.0) * 0.5 * this.getWorldFromRenderManager().getLightBrightness(var8);
-         if (!(var19 < 0.0)) {
+         if (var19 >= 0.0) {
             if (var19 > 1.0) {
                var19 = 1.0;
             }
 
-            AxisAlignedBB var21 = var1.getBoundingBox(this.getWorldFromRenderManager(), var8);
+            AxisAlignedBB var21 = var1.e(this.getWorldFromRenderManager(), var8);
             double var22 = var8.getX() + var21.minX + var11;
             double var24 = var8.getX() + var21.maxX + var11;
             double var26 = var8.getY() + var21.minY + var13 + 0.015625;
             double var28 = var8.getZ() + var21.minZ + var15;
             double var30 = var8.getZ() + var21.maxZ + var15;
             float var32 = (float)((var2 - var22) / 2.0 / var10 + 0.5);
@@ -281,13 +303,13 @@
    public FontRenderer getFontRendererFromRenderManager() {
       return this.renderManager.getFontRenderer();
    }
 
    protected void renderLivingLabel(T var1, String var2, double var3, double var5, double var7, int var9) {
       double var10 = var1.getDistanceSq(this.renderManager.renderViewEntity);
-      if (!(var10 > var9 * var9)) {
+      if (var10 <= var9 * var9) {
          boolean var12 = var1.isSneaking();
          float var13 = this.renderManager.playerViewY;
          float var14 = this.renderManager.playerViewX;
          boolean var15 = this.renderManager.options.thirdPersonView == 2;
          float var16 = var1.height + 0.5F - (var12 ? 0.25F : 0.0F);
          int var17 = "deadmau5".equals(var2) ? -10 : 0;
@@ -303,8 +325,24 @@
 
    public boolean isMultipass() {
       return false;
    }
 
    public void renderMultipass(T var1, double var2, double var4, double var6, float var8, float var9) {
+   }
+
+   public Class getEntityClass() {
+      return this.entityClass;
+   }
+
+   public void setEntityClass(Class var1) {
+      this.entityClass = var1;
+   }
+
+   public ResourceLocation getLocationTextureCustom() {
+      return this.locationTextureCustom;
+   }
+
+   public void setLocationTextureCustom(ResourceLocation var1) {
+      this.locationTextureCustom = var1;
    }
 }
--- net/minecraft/client/renderer/entity/RenderAbstractHorse.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderAbstractHorse.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderAreaEffectCloud.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderAreaEffectCloud.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderArmorStand.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderArmorStand.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderArrow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderArrow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderBat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderBat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderBiped.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderBiped.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderBlaze.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderBlaze.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderBoat.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderBoat.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderCaveSpider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderCaveSpider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderChicken.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderChicken.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderCow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderCow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderCreeper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderCreeper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderDragon.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderDragon.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderDragonFireball.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderDragonFireball.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderElderGuardian.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderElderGuardian.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEnderCrystal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEnderCrystal.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEnderman.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEnderman.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEndermite.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEndermite.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEntity.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEntity.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEntityItem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEntityItem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEvoker.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEvoker.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderEvokerFangs.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderEvokerFangs.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderFallingBlock.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderFallingBlock.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderFireball.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderFireball.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderFish.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderFish.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderGhast.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderGhast.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderGiantZombie.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderGiantZombie.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderGuardian.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderGuardian.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderHorse.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderHorse.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderHusk.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderHusk.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderIllusionIllager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderIllusionIllager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderIronGolem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderIronGolem.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderItemFrame.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderItemFrame.java	Mon Aug 18 09:39:52 2025
@@ -1,51 +1,58 @@
 package net.minecraft.client.renderer.entity;
 
 import javax.annotation.Nullable;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.renderer.BlockRendererDispatcher;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.RenderHelper;
 import net.minecraft.client.renderer.RenderItem;
 import net.minecraft.client.renderer.block.model.IBakedModel;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.block.model.ModelManager;
 import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.entity.Entity;
 import net.minecraft.entity.item.EntityItemFrame;
 import net.minecraft.init.Items;
+import net.minecraft.item.ItemMap;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.storage.MapData;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
 
 public class RenderItemFrame extends Render<EntityItemFrame> {
    private static final ResourceLocation MAP_BACKGROUND_TEXTURES = new ResourceLocation("textures/map/map_background.png");
    private final Minecraft mc = Minecraft.getMinecraft();
    private final ModelResourceLocation itemFrameModel = new ModelResourceLocation("item_frame", "normal");
    private final ModelResourceLocation mapModel = new ModelResourceLocation("item_frame", "map");
    private final RenderItem itemRenderer;
+   private static double itemRenderDistanceSq = 4096.0;
 
    public RenderItemFrame(RenderManager var1, RenderItem var2) {
       super(var1);
       this.itemRenderer = var2;
    }
 
    public void doRender(EntityItemFrame var1, double var2, double var4, double var6, float var8, float var9) {
       GlStateManager.pushMatrix();
-      BlockPos var10 = var1.getHangingPosition();
+      BlockPos var10 = var1.q();
       double var11 = var10.getX() - var1.posX + var2;
       double var13 = var10.getY() - var1.posY + var4;
       double var15 = var10.getZ() - var1.posZ + var6;
       GlStateManager.translate(var11 + 0.5, var13 + 0.5, var15 + 0.5);
       GlStateManager.rotate(180.0F - var1.rotationYaw, 0.0F, 1.0F, 0.0F);
       this.renderManager.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       BlockRendererDispatcher var17 = this.mc.getBlockRendererDispatcher();
       ModelManager var18 = var17.getBlockModelShapes().getModelManager();
       IBakedModel var19;
-      if (var1.getDisplayedItem().getItem() == Items.FILLED_MAP) {
+      if (var1.getDisplayedItem().getItem() instanceof ItemMap) {
          var19 = var18.getModel(this.mapModel);
       } else {
          var19 = var18.getModel(this.itemFrameModel);
       }
 
       GlStateManager.pushMatrix();
@@ -62,46 +69,60 @@
       }
 
       GlStateManager.popMatrix();
       GlStateManager.translate(0.0F, 0.0F, 0.4375F);
       this.renderItem(var1);
       GlStateManager.popMatrix();
-      this.renderName(var1, var2 + var1.facingDirection.getXOffset() * 0.3F, var4 - 0.25, var6 + var1.facingDirection.getZOffset() * 0.3F);
+      this.renderName(var1, var2 + var1.EMPTY_EQUIPMENT.getXOffset() * 0.3F, var4 - 0.25, var6 + var1.EMPTY_EQUIPMENT.getZOffset() * 0.3F);
    }
 
    @Nullable
    protected ResourceLocation getEntityTexture(EntityItemFrame var1) {
       return null;
    }
 
    private void renderItem(EntityItemFrame var1) {
       ItemStack var2 = var1.getDisplayedItem();
       if (!var2.isEmpty()) {
+         if (!this.isRenderItem(var1)) {
+            return;
+         }
+
+         if (!Config.zoomMode) {
+            EntityPlayerSP var3 = this.mc.player;
+            double var4 = var1.getDistanceSq(var3.posX, var3.posY, var3.posZ);
+            if (var4 > 4096.0) {
+               return;
+            }
+         }
+
          GlStateManager.pushMatrix();
          GlStateManager.disableLighting();
-         boolean var3 = var2.getItem() == Items.FILLED_MAP;
-         int var4 = var3 ? var1.getRotation() % 4 * 2 : var1.getRotation();
-         GlStateManager.rotate(var4 * 360.0F / 8.0F, 0.0F, 0.0F, 1.0F);
-         if (var3) {
-            this.renderManager.renderEngine.bindTexture(MAP_BACKGROUND_TEXTURES);
-            GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
-            float var5 = 0.0078125F;
-            GlStateManager.scale(0.0078125F, 0.0078125F, 0.0078125F);
-            GlStateManager.translate(-64.0F, -64.0F, 0.0F);
-            MapData var6 = Items.FILLED_MAP.getMapData(var2, var1.world);
-            GlStateManager.translate(0.0F, 0.0F, -1.0F);
-            if (var6 != null) {
-               this.mc.entityRenderer.getMapItemRenderer().renderMap(var6, true);
+         boolean var7 = var2.getItem() instanceof ItemMap;
+         int var8 = var7 ? var1.getRotation() % 4 * 2 : var1.getRotation();
+         GlStateManager.rotate(var8 * 360.0F / 8.0F, 0.0F, 0.0F, 1.0F);
+         if (!Reflector.postForgeBusEvent(Reflector.RenderItemInFrameEvent_Constructor, new Object[]{var1, this})) {
+            if (var7) {
+               this.renderManager.renderEngine.bindTexture(MAP_BACKGROUND_TEXTURES);
+               GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
+               float var5 = 0.0078125F;
+               GlStateManager.scale(0.0078125F, 0.0078125F, 0.0078125F);
+               GlStateManager.translate(-64.0F, -64.0F, 0.0F);
+               MapData var6 = ReflectorForge.getMapData(Items.FILLED_MAP, var2, var1.world);
+               GlStateManager.translate(0.0F, 0.0F, -1.0F);
+               if (var6 != null) {
+                  this.mc.entityRenderer.getMapItemRenderer().renderMap(var6, true);
+               }
+            } else {
+               GlStateManager.scale(0.5F, 0.5F, 0.5F);
+               GlStateManager.pushAttrib();
+               RenderHelper.enableStandardItemLighting();
+               this.itemRenderer.renderItem(var2, TransformType.FIXED);
+               RenderHelper.disableStandardItemLighting();
+               GlStateManager.popAttrib();
             }
-         } else {
-            GlStateManager.scale(0.5F, 0.5F, 0.5F);
-            GlStateManager.pushAttrib();
-            RenderHelper.enableStandardItemLighting();
-            this.itemRenderer.renderItem(var2, ItemCameraTransforms.TransformType.FIXED);
-            RenderHelper.disableStandardItemLighting();
-            GlStateManager.popAttrib();
          }
 
          GlStateManager.enableLighting();
          GlStateManager.popMatrix();
       }
    }
@@ -110,13 +131,36 @@
       if (Minecraft.isGuiEnabled()
          && !var1.getDisplayedItem().isEmpty()
          && var1.getDisplayedItem().hasDisplayName()
          && this.renderManager.pointedEntity == var1) {
          double var8 = var1.getDistanceSq(this.renderManager.renderViewEntity);
          float var10 = var1.isSneaking() ? 32.0F : 64.0F;
-         if (!(var8 >= var10 * var10)) {
+         if (var8 < var10 * var10) {
             String var11 = var1.getDisplayedItem().getDisplayName();
             this.renderLivingLabel(var1, var11, var2, var4, var6, 64);
          }
       }
+   }
+
+   private boolean isRenderItem(EntityItemFrame var1) {
+      if (Shaders.isShadowPass) {
+         return false;
+      } else {
+         if (!Config.zoomMode) {
+            Entity var2 = this.mc.getRenderViewEntity();
+            double var3 = var1.getDistanceSq(var2.posX, var2.posY, var2.posZ);
+            if (var3 > itemRenderDistanceSq) {
+               return false;
+            }
+         }
+
+         return true;
+      }
+   }
+
+   public static void updateItemRenderDistance() {
+      Minecraft var0 = Config.getMinecraft();
+      double var1 = Config.limit(var0.gameSettings.fovSetting, 1.0F, 120.0F);
+      double var3 = Math.max(6.0 * var0.displayHeight / var1, 16.0);
+      itemRenderDistanceSq = var3 * var3;
    }
 }
--- net/minecraft/client/renderer/entity/RenderLeashKnot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLeashKnot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderLightningBolt.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLightningBolt.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderLiving.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLiving.java	Mon Aug 18 09:39:52 2025
@@ -7,12 +7,13 @@
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.culling.ICamera;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityHanging;
 import net.minecraft.entity.EntityLiving;
+import net.optifine.shaders.Shaders;
 
 public abstract class RenderLiving<T extends EntityLiving> extends RenderLivingBase<T> {
    public RenderLiving(RenderManager var1, ModelBase var2, float var3) {
       super(var1, var2, var3);
    }
 
@@ -47,98 +48,116 @@
 
    private double interpolateValue(double var1, double var3, double var5) {
       return var1 + (var3 - var1) * var5;
    }
 
    protected void renderLeash(T var1, double var2, double var4, double var6, float var8, float var9) {
-      Entity var10 = var1.getLeashHolder();
-      if (var10 != null) {
-         var4 -= (1.6 - var1.height) * 0.5;
-         Tessellator var11 = Tessellator.getInstance();
-         BufferBuilder var12 = var11.getBuffer();
-         double var13 = this.interpolateValue(var10.prevRotationYaw, var10.rotationYaw, var9 * 0.5F) * (float) (Math.PI / 180.0);
-         double var15 = this.interpolateValue(var10.prevRotationPitch, var10.rotationPitch, var9 * 0.5F) * (float) (Math.PI / 180.0);
-         double var17 = Math.cos(var13);
-         double var19 = Math.sin(var13);
-         double var21 = Math.sin(var15);
-         if (var10 instanceof EntityHanging) {
-            var17 = 0.0;
-            var19 = 0.0;
-            var21 = -1.0;
-         }
+      if (!Config.isShaders() || !Shaders.isShadowPass) {
+         Entity var10 = var1.getLeashHolder();
+         if (var10 != null) {
+            var4 -= (1.6 - var1.height) * 0.5;
+            Tessellator var11 = Tessellator.getInstance();
+            BufferBuilder var12 = var11.getBuffer();
+            double var13 = this.interpolateValue(var10.prevRotationYaw, var10.rotationYaw, var9 * 0.5F) * (float) (Math.PI / 180.0);
+            double var15 = this.interpolateValue(var10.prevRotationPitch, var10.rotationPitch, var9 * 0.5F) * (float) (Math.PI / 180.0);
+            double var17 = Math.cos(var13);
+            double var19 = Math.sin(var13);
+            double var21 = Math.sin(var15);
+            if (var10 instanceof EntityHanging) {
+               var17 = 0.0;
+               var19 = 0.0;
+               var21 = -1.0;
+            }
 
-         double var23 = Math.cos(var15);
-         double var25 = this.interpolateValue(var10.prevPosX, var10.posX, var9) - var17 * 0.7 - var19 * 0.5 * var23;
-         double var27 = this.interpolateValue(var10.prevPosY + var10.getEyeHeight() * 0.7, var10.posY + var10.getEyeHeight() * 0.7, var9) - var21 * 0.5 - 0.25;
-         double var29 = this.interpolateValue(var10.prevPosZ, var10.posZ, var9) - var19 * 0.7 + var17 * 0.5 * var23;
-         double var31 = this.interpolateValue(var1.prevRenderYawOffset, var1.renderYawOffset, var9) * (float) (Math.PI / 180.0) + (Math.PI / 2);
-         var17 = Math.cos(var31) * var1.width * 0.4;
-         var19 = Math.sin(var31) * var1.width * 0.4;
-         double var33 = this.interpolateValue(var1.prevPosX, var1.posX, var9) + var17;
-         double var35 = this.interpolateValue(var1.prevPosY, var1.posY, var9);
-         double var37 = this.interpolateValue(var1.prevPosZ, var1.posZ, var9) + var19;
-         var2 += var17;
-         var6 += var19;
-         double var39 = (float)(var25 - var33);
-         double var41 = (float)(var27 - var35);
-         double var43 = (float)(var29 - var37);
-         GlStateManager.disableTexture2D();
-         GlStateManager.disableLighting();
-         GlStateManager.disableCull();
-         byte var45 = 24;
-         double var46 = 0.025;
-         var12.begin(5, DefaultVertexFormats.POSITION_COLOR);
-
-         for (int var48 = 0; var48 <= 24; var48++) {
-            float var49 = 0.5F;
-            float var50 = 0.4F;
-            float var51 = 0.3F;
-            if (var48 % 2 == 0) {
-               var49 *= 0.7F;
-               var50 *= 0.7F;
-               var51 *= 0.7F;
+            double var23 = Math.cos(var15);
+            double var25 = this.interpolateValue(var10.prevPosX, var10.posX, var9) - var17 * 0.7 - var19 * 0.5 * var23;
+            double var27 = this.interpolateValue(var10.prevPosY + var10.getEyeHeight() * 0.7, var10.posY + var10.getEyeHeight() * 0.7, var9)
+               - var21 * 0.5
+               - 0.25;
+            double var29 = this.interpolateValue(var10.prevPosZ, var10.posZ, var9) - var19 * 0.7 + var17 * 0.5 * var23;
+            double var31 = this.interpolateValue(var1.prevRenderYawOffset, var1.renderYawOffset, var9) * (float) (Math.PI / 180.0) + (Math.PI / 2);
+            var17 = Math.cos(var31) * var1.width * 0.4;
+            var19 = Math.sin(var31) * var1.width * 0.4;
+            double var33 = this.interpolateValue(var1.prevPosX, var1.posX, var9) + var17;
+            double var35 = this.interpolateValue(var1.prevPosY, var1.posY, var9);
+            double var37 = this.interpolateValue(var1.prevPosZ, var1.posZ, var9) + var19;
+            var2 += var17;
+            var6 += var19;
+            double var39 = (float)(var25 - var33);
+            double var41 = (float)(var27 - var35);
+            double var43 = (float)(var29 - var37);
+            GlStateManager.disableTexture2D();
+            GlStateManager.disableLighting();
+            GlStateManager.disableCull();
+            if (Config.isShaders()) {
+               Shaders.beginLeash();
             }
 
-            float var52 = var48 / 24.0F;
-            var12.pos(var2 + var39 * var52 + 0.0, var4 + var41 * (var52 * var52 + var52) * 0.5 + ((24.0F - var48) / 18.0F + 0.125F), var6 + var43 * var52)
-               .color(var49, var50, var51, 1.0F)
-               .endVertex();
-            var12.pos(
-                  var2 + var39 * var52 + 0.025, var4 + var41 * (var52 * var52 + var52) * 0.5 + ((24.0F - var48) / 18.0F + 0.125F) + 0.025, var6 + var43 * var52
-               )
-               .color(var49, var50, var51, 1.0F)
-               .endVertex();
-         }
+            byte var45 = 24;
+            double var46 = 0.025;
+            var12.begin(5, DefaultVertexFormats.POSITION_COLOR);
+
+            for (int var48 = 0; var48 <= 24; var48++) {
+               float var49 = 0.5F;
+               float var50 = 0.4F;
+               float var51 = 0.3F;
+               if (var48 % 2 == 0) {
+                  var49 *= 0.7F;
+                  var50 *= 0.7F;
+                  var51 *= 0.7F;
+               }
+
+               float var52 = var48 / 24.0F;
+               var12.pos(var2 + var39 * var52 + 0.0, var4 + var41 * (var52 * var52 + var52) * 0.5 + ((24.0F - var48) / 18.0F + 0.125F), var6 + var43 * var52)
+                  .color(var49, var50, var51, 1.0F)
+                  .endVertex();
+               var12.pos(
+                     var2 + var39 * var52 + 0.025,
+                     var4 + var41 * (var52 * var52 + var52) * 0.5 + ((24.0F - var48) / 18.0F + 0.125F) + 0.025,
+                     var6 + var43 * var52
+                  )
+                  .color(var49, var50, var51, 1.0F)
+                  .endVertex();
+            }
 
-         var11.draw();
-         var12.begin(5, DefaultVertexFormats.POSITION_COLOR);
+            var11.draw();
+            var12.begin(5, DefaultVertexFormats.POSITION_COLOR);
 
-         for (int var58 = 0; var58 <= 24; var58++) {
-            float var59 = 0.5F;
-            float var60 = 0.4F;
-            float var61 = 0.3F;
-            if (var58 % 2 == 0) {
-               var59 *= 0.7F;
-               var60 *= 0.7F;
-               var61 *= 0.7F;
+            for (int var58 = 0; var58 <= 24; var58++) {
+               float var59 = 0.5F;
+               float var60 = 0.4F;
+               float var61 = 0.3F;
+               if (var58 % 2 == 0) {
+                  var59 *= 0.7F;
+                  var60 *= 0.7F;
+                  var61 *= 0.7F;
+               }
+
+               float var62 = var58 / 24.0F;
+               var12.pos(
+                     var2 + var39 * var62 + 0.0,
+                     var4 + var41 * (var62 * var62 + var62) * 0.5 + ((24.0F - var58) / 18.0F + 0.125F) + 0.025,
+                     var6 + var43 * var62
+                  )
+                  .color(var59, var60, var61, 1.0F)
+                  .endVertex();
+               var12.pos(
+                     var2 + var39 * var62 + 0.025,
+                     var4 + var41 * (var62 * var62 + var62) * 0.5 + ((24.0F - var58) / 18.0F + 0.125F),
+                     var6 + var43 * var62 + 0.025
+                  )
+                  .color(var59, var60, var61, 1.0F)
+                  .endVertex();
             }
 
-            float var62 = var58 / 24.0F;
-            var12.pos(
-                  var2 + var39 * var62 + 0.0, var4 + var41 * (var62 * var62 + var62) * 0.5 + ((24.0F - var58) / 18.0F + 0.125F) + 0.025, var6 + var43 * var62
-               )
-               .color(var59, var60, var61, 1.0F)
-               .endVertex();
-            var12.pos(
-                  var2 + var39 * var62 + 0.025, var4 + var41 * (var62 * var62 + var62) * 0.5 + ((24.0F - var58) / 18.0F + 0.125F), var6 + var43 * var62 + 0.025
-               )
-               .color(var59, var60, var61, 1.0F)
-               .endVertex();
-         }
+            var11.draw();
+            if (Config.isShaders()) {
+               Shaders.endLeash();
+            }
 
-         var11.draw();
-         GlStateManager.enableLighting();
-         GlStateManager.enableTexture2D();
-         GlStateManager.enableCull();
+            GlStateManager.enableLighting();
+            GlStateManager.enableTexture2D();
+            GlStateManager.enableCull();
+         }
       }
    }
 }
--- net/minecraft/client/renderer/entity/RenderLivingBase.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLivingBase.java	Mon Aug 18 09:39:52 2025
@@ -4,41 +4,61 @@
 import java.nio.Buffer;
 import java.nio.FloatBuffer;
 import java.util.List;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.model.ModelBase;
+import net.minecraft.client.model.ModelSpider;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.entity.layers.LayerRenderer;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EnumPlayerModelParts;
 import net.minecraft.scoreboard.Team;
+import net.minecraft.scoreboard.Team.EnumVisible;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.text.TextFormatting;
+import net.optifine.EmissiveTextures;
+import net.optifine.entity.model.CustomEntityModels;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public abstract class RenderLivingBase<T extends EntityLivingBase> extends Render<T> {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final DynamicTexture TEXTURE_BRIGHTNESS = new DynamicTexture(16, 16);
-   protected ModelBase mainModel;
+   public ModelBase mainModel;
    protected FloatBuffer brightnessBuffer = GLAllocation.createDirectFloatBuffer(4);
    protected List<LayerRenderer<T>> layerRenderers = Lists.newArrayList();
    protected boolean renderMarker;
+   public static float NAME_TAG_RANGE = 64.0F;
+   public static float NAME_TAG_RANGE_SNEAK = 32.0F;
+   public EntityLivingBase renderEntity;
+   public float renderLimbSwing;
+   public float renderLimbSwingAmount;
+   public float renderAgeInTicks;
+   public float renderHeadYaw;
+   public float renderHeadPitch;
+   public float renderScaleFactor;
+   public float renderPartialTicks;
+   private boolean renderModelPushMatrix;
+   private boolean renderLayersPushMatrix;
+   public static final boolean animateModelLiving = Boolean.getBoolean("animate.model.living");
 
    public RenderLivingBase(RenderManager var1, ModelBase var2, float var3) {
       super(var1);
       this.mainModel = var2;
       this.shadowSize = var3;
+      this.renderModelPushMatrix = this.mainModel instanceof ModelSpider;
    }
 
-   protected <V extends EntityLivingBase, U extends LayerRenderer<V>> boolean addLayer(U var1) {
+   public <V extends EntityLivingBase, U extends LayerRenderer<V>> boolean addLayer(U var1) {
       return this.layerRenderers.add(var1);
    }
 
    public ModelBase getMainModel() {
       return this.mainModel;
    }
@@ -58,106 +78,162 @@
    }
 
    public void transformHeldFull3DItemLayer() {
    }
 
    public void doRender(T var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.pushMatrix();
-      GlStateManager.disableCull();
-      this.mainModel.swingProgress = this.getSwingProgress((T)var1, var9);
-      this.mainModel.isRiding = var1.isRiding();
-      this.mainModel.isChild = var1.isChild();
-
-      try {
-         float var10 = this.interpolateRotation(var1.prevRenderYawOffset, var1.renderYawOffset, var9);
-         float var11 = this.interpolateRotation(var1.prevRotationYawHead, var1.rotationYawHead, var9);
-         float var12 = var11 - var10;
-         if (var1.isRiding() && var1.getRidingEntity() instanceof EntityLivingBase) {
-            EntityLivingBase var13 = (EntityLivingBase)var1.getRidingEntity();
-            var10 = this.interpolateRotation(var13.prevRenderYawOffset, var13.renderYawOffset, var9);
-            var12 = var11 - var10;
-            float var14 = MathHelper.wrapDegrees(var12);
-            if (var14 < -85.0F) {
-               var14 = -85.0F;
-            }
-
-            if (var14 >= 85.0F) {
-               var14 = 85.0F;
-            }
-
-            var10 = var11 - var14;
-            if (var14 * var14 > 2500.0F) {
-               var10 += var14 * 0.2F;
-            }
-
-            var12 = var11 - var10;
-         }
-
-         float var22 = var1.prevRotationPitch + (var1.rotationPitch - var1.prevRotationPitch) * var9;
-         this.renderLivingAt((T)var1, var2, var4, var6);
-         float var23 = this.handleRotationFloat((T)var1, var9);
-         this.applyRotations((T)var1, var23, var10, var9);
-         float var15 = this.prepareScale((T)var1, var9);
-         float var16 = 0.0F;
-         float var17 = 0.0F;
-         if (!var1.isRiding()) {
-            var16 = var1.prevLimbSwingAmount + (var1.limbSwingAmount - var1.prevLimbSwingAmount) * var9;
-            var17 = var1.limbSwing - var1.limbSwingAmount * (1.0F - var9);
-            if (var1.isChild()) {
-               var17 *= 3.0F;
-            }
-
-            if (var16 > 1.0F) {
-               var16 = 1.0F;
-            }
-         }
+      if (!Reflector.RenderLivingEvent_Pre_Constructor.exists()
+         || !Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Pre_Constructor, new Object[]{var1, this, var9, var2, var4, var6})) {
+         if (animateModelLiving) {
+            var1.limbSwingAmount = 1.0F;
+         }
+
+         GlStateManager.pushMatrix();
+         GlStateManager.disableCull();
+         this.mainModel.swingProgress = this.getSwingProgress((T)var1, var9);
+         this.mainModel.isRiding = var1.isRiding();
+         if (Reflector.ForgeEntity_shouldRiderSit.exists()) {
+            this.mainModel.isRiding = var1.isRiding()
+               && var1.getRidingEntity() != null
+               && Reflector.callBoolean(var1.getRidingEntity(), Reflector.ForgeEntity_shouldRiderSit, new Object[0]);
+         }
+
+         this.mainModel.isChild = var1.isChild();
+
+         try {
+            float var10 = this.interpolateRotation(var1.prevRenderYawOffset, var1.renderYawOffset, var9);
+            float var11 = this.interpolateRotation(var1.prevRotationYawHead, var1.rotationYawHead, var9);
+            float var12 = var11 - var10;
+            if (this.mainModel.isRiding && var1.getRidingEntity() instanceof EntityLivingBase) {
+               EntityLivingBase var13 = (EntityLivingBase)var1.getRidingEntity();
+               var10 = this.interpolateRotation(var13.prevRenderYawOffset, var13.renderYawOffset, var9);
+               var12 = var11 - var10;
+               float var14 = MathHelper.wrapDegrees(var12);
+               if (var14 < -85.0F) {
+                  var14 = -85.0F;
+               }
+
+               if (var14 >= 85.0F) {
+                  var14 = 85.0F;
+               }
+
+               var10 = var11 - var14;
+               if (var14 * var14 > 2500.0F) {
+                  var10 += var14 * 0.2F;
+               }
+
+               var12 = var11 - var10;
+            }
+
+            float var22 = var1.prevRotationPitch + (var1.rotationPitch - var1.prevRotationPitch) * var9;
+            this.renderLivingAt((T)var1, var2, var4, var6);
+            float var23 = this.handleRotationFloat((T)var1, var9);
+            this.applyRotations((T)var1, var23, var10, var9);
+            float var15 = this.prepareScale((T)var1, var9);
+            float var16 = 0.0F;
+            float var17 = 0.0F;
+            if (!var1.isRiding()) {
+               var16 = var1.prevLimbSwingAmount + (var1.limbSwingAmount - var1.prevLimbSwingAmount) * var9;
+               var17 = var1.limbSwing - var1.limbSwingAmount * (1.0F - var9);
+               if (var1.isChild()) {
+                  var17 *= 3.0F;
+               }
+
+               if (var16 > 1.0F) {
+                  var16 = 1.0F;
+               }
+            }
+
+            GlStateManager.enableAlpha();
+            this.mainModel.setLivingAnimations(var1, var17, var16, var9);
+            this.mainModel.setRotationAngles(var17, var16, var23, var12, var22, var15, var1);
+            if (CustomEntityModels.isActive()) {
+               this.renderEntity = var1;
+               this.renderLimbSwing = var17;
+               this.renderLimbSwingAmount = var16;
+               this.renderAgeInTicks = var23;
+               this.renderHeadYaw = var12;
+               this.renderHeadPitch = var22;
+               this.renderScaleFactor = var15;
+               this.renderPartialTicks = var9;
+            }
+
+            if (this.renderOutlines) {
+               boolean var24 = this.setScoreTeamColor((T)var1);
+               GlStateManager.enableColorMaterial();
+               GlStateManager.enableOutlineMode(this.getTeamColor((T)var1));
+               if (!this.renderMarker) {
+                  this.renderModel((T)var1, var17, var16, var23, var12, var22, var15);
+               }
+
+               if (!(var1 instanceof EntityPlayer) || !((EntityPlayer)var1).isSpectator()) {
+                  this.renderLayers((T)var1, var17, var16, var9, var23, var12, var22, var15);
+               }
+
+               GlStateManager.disableOutlineMode();
+               GlStateManager.disableColorMaterial();
+               if (var24) {
+                  this.unsetScoreTeamColor();
+               }
+            } else {
+               boolean var18 = this.setDoRenderBrightness((T)var1, var9);
+               if (EmissiveTextures.isActive()) {
+                  EmissiveTextures.beginRender();
+               }
+
+               if (this.renderModelPushMatrix) {
+                  GlStateManager.pushMatrix();
+               }
 
-         GlStateManager.enableAlpha();
-         this.mainModel.setLivingAnimations(var1, var17, var16, var9);
-         this.mainModel.setRotationAngles(var17, var16, var23, var12, var22, var15, var1);
-         if (this.renderOutlines) {
-            boolean var24 = this.setScoreTeamColor((T)var1);
-            GlStateManager.enableColorMaterial();
-            GlStateManager.enableOutlineMode(this.getTeamColor((T)var1));
-            if (!this.renderMarker) {
                this.renderModel((T)var1, var17, var16, var23, var12, var22, var15);
-            }
-
-            if (!(var1 instanceof EntityPlayer) || !((EntityPlayer)var1).isSpectator()) {
-               this.renderLayers((T)var1, var17, var16, var9, var23, var12, var22, var15);
-            }
-
-            GlStateManager.disableOutlineMode();
-            GlStateManager.disableColorMaterial();
-            if (var24) {
-               this.unsetScoreTeamColor();
-            }
-         } else {
-            boolean var18 = this.setDoRenderBrightness((T)var1, var9);
-            this.renderModel((T)var1, var17, var16, var23, var12, var22, var15);
-            if (var18) {
-               this.unsetBrightness();
-            }
-
-            GlStateManager.depthMask(true);
-            if (!(var1 instanceof EntityPlayer) || !((EntityPlayer)var1).isSpectator()) {
-               this.renderLayers((T)var1, var17, var16, var9, var23, var12, var22, var15);
-            }
+               if (this.renderModelPushMatrix) {
+                  GlStateManager.popMatrix();
+               }
+
+               if (EmissiveTextures.isActive()) {
+                  if (EmissiveTextures.hasEmissive()) {
+                     this.renderModelPushMatrix = true;
+                     EmissiveTextures.beginRenderEmissive();
+                     GlStateManager.pushMatrix();
+                     this.renderModel((T)var1, var17, var16, var23, var12, var22, var15);
+                     GlStateManager.popMatrix();
+                     EmissiveTextures.endRenderEmissive();
+                  }
+
+                  EmissiveTextures.endRender();
+               }
+
+               if (var18) {
+                  this.unsetBrightness();
+               }
+
+               GlStateManager.depthMask(true);
+               if (!(var1 instanceof EntityPlayer) || !((EntityPlayer)var1).isSpectator()) {
+                  this.renderLayers((T)var1, var17, var16, var9, var23, var12, var22, var15);
+               }
+            }
+
+            if (CustomEntityModels.isActive()) {
+               this.renderEntity = null;
+            }
+
+            GlStateManager.disableRescaleNormal();
+         } catch (Exception var19) {
+            LOGGER.error("Couldn't render entity", var19);
          }
 
-         GlStateManager.disableRescaleNormal();
-      } catch (Exception var19) {
-         LOGGER.error("Couldn't render entity", var19);
+         GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
+         GlStateManager.enableTexture2D();
+         GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+         GlStateManager.enableCull();
+         GlStateManager.popMatrix();
+         super.doRender((T)var1, var2, var4, var6, var8, var9);
+         if (Reflector.RenderLivingEvent_Post_Constructor.exists()) {
+            Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Post_Constructor, new Object[]{var1, this, var9, var2, var4, var6});
+         }
       }
-
-      GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
-      GlStateManager.enableTexture2D();
-      GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
-      GlStateManager.enableCull();
-      GlStateManager.popMatrix();
-      super.doRender((T)var1, var2, var4, var6, var8, var9);
    }
 
    public float prepareScale(T var1, float var2) {
       GlStateManager.enableRescaleNormal();
       GlStateManager.scale(-1.0F, -1.0F, 1.0F);
       this.preRenderCallback((T)var1, var2);
@@ -245,21 +321,27 @@
          ((Buffer)this.brightnessBuffer).position(0);
          if (var7) {
             this.brightnessBuffer.put(1.0F);
             this.brightnessBuffer.put(0.0F);
             this.brightnessBuffer.put(0.0F);
             this.brightnessBuffer.put(0.3F);
+            if (Config.isShaders()) {
+               Shaders.setEntityColor(1.0F, 0.0F, 0.0F, 0.3F);
+            }
          } else {
             float var8 = (var5 >> 24 & 0xFF) / 255.0F;
             float var9 = (var5 >> 16 & 0xFF) / 255.0F;
             float var10 = (var5 >> 8 & 0xFF) / 255.0F;
             float var11 = (var5 & 0xFF) / 255.0F;
             this.brightnessBuffer.put(var9);
             this.brightnessBuffer.put(var10);
             this.brightnessBuffer.put(var11);
             this.brightnessBuffer.put(1.0F - var8);
+            if (Config.isShaders()) {
+               Shaders.setEntityColor(var9, var10, var11, 1.0F - var8);
+            }
          }
 
          ((Buffer)this.brightnessBuffer).flip();
          GlStateManager.glTexEnv(8960, 8705, this.brightnessBuffer);
          GlStateManager.setActiveTexture(OpenGlHelper.GL_TEXTURE2);
          GlStateManager.enableTexture2D();
@@ -313,12 +395,15 @@
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_SOURCE0_RGB, 5890);
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_SOURCE1_RGB, OpenGlHelper.GL_PREVIOUS);
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_COMBINE_ALPHA, 8448);
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_OPERAND0_ALPHA, 770);
       GlStateManager.glTexEnvi(8960, OpenGlHelper.GL_SOURCE0_ALPHA, 5890);
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.setEntityColor(0.0F, 0.0F, 0.0F, 0.0F);
+      }
    }
 
    protected void renderLivingAt(T var1, double var2, double var4, double var6) {
       GlStateManager.translate((float)var2, (float)var4, (float)var6);
    }
 
@@ -351,13 +436,38 @@
       return var1.ticksExisted + var2;
    }
 
    protected void renderLayers(T var1, float var2, float var3, float var4, float var5, float var6, float var7, float var8) {
       for (LayerRenderer var10 : this.layerRenderers) {
          boolean var11 = this.setBrightness((T)var1, var4, var10.shouldCombineTextures());
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.beginRender();
+         }
+
+         if (this.renderLayersPushMatrix) {
+            GlStateManager.pushMatrix();
+         }
+
          var10.doRenderLayer(var1, var2, var3, var4, var5, var6, var7, var8);
+         if (this.renderLayersPushMatrix) {
+            GlStateManager.popMatrix();
+         }
+
+         if (EmissiveTextures.isActive()) {
+            if (EmissiveTextures.hasEmissive()) {
+               this.renderLayersPushMatrix = true;
+               EmissiveTextures.beginRenderEmissive();
+               GlStateManager.pushMatrix();
+               var10.doRenderLayer(var1, var2, var3, var4, var5, var6, var7, var8);
+               GlStateManager.popMatrix();
+               EmissiveTextures.endRenderEmissive();
+            }
+
+            EmissiveTextures.endRender();
+         }
+
          if (var11) {
             this.unsetBrightness();
          }
       }
    }
 
@@ -370,31 +480,38 @@
    }
 
    protected void preRenderCallback(T var1, float var2) {
    }
 
    public void renderName(T var1, double var2, double var4, double var6) {
-      if (this.canRenderName(var1)) {
-         double var8 = var1.getDistanceSq(this.renderManager.renderViewEntity);
-         float var10 = var1.isSneaking() ? 32.0F : 64.0F;
-         if (!(var8 >= var10 * var10)) {
-            String var11 = var1.getDisplayName().getFormattedText();
-            GlStateManager.alphaFunc(516, 0.1F);
-            this.renderEntityName((T)var1, var2, var4, var6, var11, var8);
+      if (!Reflector.RenderLivingEvent_Specials_Pre_Constructor.exists()
+         || !Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Specials_Pre_Constructor, new Object[]{var1, this, var2, var4, var6})) {
+         if (this.canRenderName((T)var1)) {
+            double var8 = var1.getDistanceSq(this.renderManager.renderViewEntity);
+            float var10 = var1.isSneaking() ? NAME_TAG_RANGE_SNEAK : NAME_TAG_RANGE;
+            if (var8 < var10 * var10) {
+               String var11 = var1.getDisplayName().getFormattedText();
+               GlStateManager.alphaFunc(516, 0.1F);
+               this.renderEntityName((T)var1, var2, var4, var6, var11, var8);
+            }
+         }
+
+         if (Reflector.RenderLivingEvent_Specials_Post_Constructor.exists()) {
+            Reflector.postForgeBusEvent(Reflector.RenderLivingEvent_Specials_Post_Constructor, new Object[]{var1, this, var2, var4, var6});
          }
       }
    }
 
    protected boolean canRenderName(T var1) {
       EntityPlayerSP var2 = Minecraft.getMinecraft().player;
       boolean var3 = !var1.isInvisibleToPlayer(var2);
       if (var1 != var2) {
          Team var4 = var1.getTeam();
          Team var5 = var2.getTeam();
          if (var4 != null) {
-            Team.EnumVisible var6 = var4.getNameTagVisibility();
+            EnumVisible var6 = var4.getNameTagVisibility();
             switch (var6) {
                case ALWAYS:
                   return var3;
                case NEVER:
                   return false;
                case HIDE_FOR_OTHER_TEAMS:
@@ -405,12 +522,16 @@
                   return true;
             }
          }
       }
 
       return Minecraft.isGuiEnabled() && var1 != this.renderManager.renderViewEntity && var3 && !var1.isBeingRidden();
+   }
+
+   public List<LayerRenderer<T>> getLayerRenderers() {
+      return this.layerRenderers;
    }
 
    static {
       int[] var0 = TEXTURE_BRIGHTNESS.getTextureData();
 
       for (int var1 = 0; var1 < 256; var1++) {
--- net/minecraft/client/renderer/entity/RenderLlama.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLlama.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderLlamaSpit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderLlamaSpit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderMagmaCube.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderMagmaCube.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderManager.java	Mon Aug 18 09:39:52 2025
@@ -1,9 +1,10 @@
 package net.minecraft.client.renderer.entity;
 
 import com.google.common.collect.Maps;
+import java.util.Collections;
 import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
@@ -103,17 +104,22 @@
 import net.minecraft.entity.projectile.EntitySnowball;
 import net.minecraft.entity.projectile.EntitySpectralArrow;
 import net.minecraft.entity.projectile.EntityTippedArrow;
 import net.minecraft.entity.projectile.EntityWitherSkull;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
+import net.optifine.entity.model.CustomEntityModels;
+import net.optifine.player.PlayerItemsLayer;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
 
 public class RenderManager {
    private final Map<Class<? extends Entity>, Render<? extends Entity>> entityRenderMap = Maps.newHashMap();
    private final Map<String, RenderPlayer> skinMap = Maps.newHashMap();
    private final RenderPlayer playerRenderer;
    private FontRenderer textRenderer;
@@ -130,12 +136,13 @@
    public double viewerPosX;
    public double viewerPosY;
    public double viewerPosZ;
    private boolean renderOutlines;
    private boolean renderShadow = true;
    private boolean debugBoundingBox;
+   public Render renderRender = null;
 
    public RenderManager(TextureManager var1, RenderItem var2) {
       this.renderEngine = var1;
       this.entityRenderMap.put(EntityCaveSpider.class, new RenderCaveSpider(this));
       this.entityRenderMap.put(EntitySpider.class, new RenderSpider(this));
       this.entityRenderMap.put(EntityPig.class, new RenderPig(this));
@@ -183,19 +190,19 @@
       this.entityRenderMap.put(Entity.class, new RenderEntity(this));
       this.entityRenderMap.put(EntityPainting.class, new RenderPainting(this));
       this.entityRenderMap.put(EntityItemFrame.class, new RenderItemFrame(this, var2));
       this.entityRenderMap.put(EntityLeashKnot.class, new RenderLeashKnot(this));
       this.entityRenderMap.put(EntityTippedArrow.class, new RenderTippedArrow(this));
       this.entityRenderMap.put(EntitySpectralArrow.class, new RenderSpectralArrow(this));
-      this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball<>(this, Items.SNOWBALL, var2));
-      this.entityRenderMap.put(EntityEnderPearl.class, new RenderSnowball<>(this, Items.ENDER_PEARL, var2));
-      this.entityRenderMap.put(EntityEnderEye.class, new RenderSnowball<>(this, Items.ENDER_EYE, var2));
-      this.entityRenderMap.put(EntityEgg.class, new RenderSnowball<>(this, Items.EGG, var2));
+      this.entityRenderMap.put(EntitySnowball.class, new RenderSnowball(this, Items.SNOWBALL, var2));
+      this.entityRenderMap.put(EntityEnderPearl.class, new RenderSnowball(this, Items.ENDER_PEARL, var2));
+      this.entityRenderMap.put(EntityEnderEye.class, new RenderSnowball(this, Items.ENDER_EYE, var2));
+      this.entityRenderMap.put(EntityEgg.class, new RenderSnowball(this, Items.EGG, var2));
       this.entityRenderMap.put(EntityPotion.class, new RenderPotion(this, var2));
-      this.entityRenderMap.put(EntityExpBottle.class, new RenderSnowball<>(this, Items.EXPERIENCE_BOTTLE, var2));
-      this.entityRenderMap.put(EntityFireworkRocket.class, new RenderSnowball<>(this, Items.FIREWORKS, var2));
+      this.entityRenderMap.put(EntityExpBottle.class, new RenderSnowball(this, Items.EXPERIENCE_BOTTLE, var2));
+      this.entityRenderMap.put(EntityFireworkRocket.class, new RenderSnowball(this, Items.FIREWORKS, var2));
       this.entityRenderMap.put(EntityLargeFireball.class, new RenderFireball(this, 2.0F));
       this.entityRenderMap.put(EntitySmallFireball.class, new RenderFireball(this, 0.5F));
       this.entityRenderMap.put(EntityDragonFireball.class, new RenderDragonFireball(this));
       this.entityRenderMap.put(EntityWitherSkull.class, new RenderWitherSkull(this));
       this.entityRenderMap.put(EntityShulkerBullet.class, new RenderShulkerBullet(this));
       this.entityRenderMap.put(EntityItem.class, new RenderEntityItem(this, var2));
@@ -218,12 +225,16 @@
       this.entityRenderMap.put(EntityLlama.class, new RenderLlama(this));
       this.entityRenderMap.put(EntityLlamaSpit.class, new RenderLlamaSpit(this));
       this.entityRenderMap.put(EntityLightningBolt.class, new RenderLightningBolt(this));
       this.playerRenderer = new RenderPlayer(this);
       this.skinMap.put("default", this.playerRenderer);
       this.skinMap.put("slim", new RenderPlayer(this, true));
+      PlayerItemsLayer.register(this.skinMap);
+      if (Reflector.RenderingRegistry_loadEntityRenderers.exists()) {
+         Reflector.call(Reflector.RenderingRegistry_loadEntityRenderers, new Object[]{this, this.entityRenderMap});
+      }
    }
 
    public void setRenderPosition(double var1, double var3, double var5) {
       this.renderPosX = var1;
       this.renderPosY = var3;
       this.renderPosZ = var5;
@@ -256,15 +267,20 @@
       this.renderViewEntity = var3;
       this.pointedEntity = var4;
       this.textRenderer = var2;
       if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).isPlayerSleeping()) {
          IBlockState var7 = var1.getBlockState(new BlockPos(var3));
          Block var8 = var7.getBlock();
-         if (var8 == Blocks.BED) {
-            int var9 = var7.getValue(BlockBed.FACING).getHorizontalIndex();
-            this.playerViewY = var9 * 90 + 180;
+         if (Reflector.callBoolean(var8, Reflector.ForgeBlock_isBed, new Object[]{var7, var1, new BlockPos(var3), (EntityLivingBase)var3})) {
+            EnumFacing var9 = (EnumFacing)Reflector.call(var8, Reflector.ForgeBlock_getBedDirection, new Object[]{var7, var1, new BlockPos(var3)});
+            int var10 = var9.getHorizontalIndex();
+            this.playerViewY = var10 * 90 + 180;
+            this.playerViewX = 0.0F;
+         } else if (var8 == Blocks.BED) {
+            int var11 = ((EnumFacing)var7.getValue(BlockBed.D)).getHorizontalIndex();
+            this.playerViewY = var11 * 90 + 180;
             this.playerViewX = 0.0F;
          }
       } else {
          this.playerViewY = var3.prevRotationYaw + (var3.rotationYaw - var3.prevRotationYaw) * var6;
          this.playerViewX = var3.prevRotationPitch + (var3.rotationPitch - var3.prevRotationPitch) * var6;
       }
@@ -335,23 +351,27 @@
 
       try {
          var11 = this.getEntityRenderObject(var1);
          if (var11 != null && this.renderEngine != null) {
             try {
                var11.setRenderOutlines(this.renderOutlines);
+               if (CustomEntityModels.isActive()) {
+                  this.renderRender = var11;
+               }
+
                var11.doRender(var1, var2, var4, var6, var8, var9);
-            } catch (Throwable var17) {
-               throw new ReportedException(CrashReport.makeCrashReport(var17, "Rendering entity in world"));
+            } catch (Throwable var18) {
+               throw new ReportedException(CrashReport.makeCrashReport(var18, "Rendering entity in world"));
             }
 
             try {
                if (!this.renderOutlines) {
                   var11.doRenderShadowAndFire(var1, var2, var4, var6, var8, var9);
                }
-            } catch (Throwable var18) {
-               throw new ReportedException(CrashReport.makeCrashReport(var18, "Post-rendering entity in world"));
+            } catch (Throwable var17) {
+               throw new ReportedException(CrashReport.makeCrashReport(var17, "Post-rendering entity in world"));
             }
 
             if (this.debugBoundingBox && !var1.isInvisible() && !var10 && !Minecraft.getMinecraft().isReducedDebug()) {
                try {
                   this.renderDebugBoundingBox(var1, var2, var4, var6, var8, var9);
                } catch (Throwable var16) {
@@ -396,81 +416,83 @@
       if (var13 != null && this.renderEngine != null) {
          var13.renderMultipass(var1, var3 - this.renderPosX, var5 - this.renderPosY, var7 - this.renderPosZ, var9, var2);
       }
    }
 
    private void renderDebugBoundingBox(Entity var1, double var2, double var4, double var6, float var8, float var9) {
-      GlStateManager.depthMask(false);
-      GlStateManager.disableTexture2D();
-      GlStateManager.disableLighting();
-      GlStateManager.disableCull();
-      GlStateManager.disableBlend();
-      float var10 = var1.width / 2.0F;
-      AxisAlignedBB var11 = var1.getEntityBoundingBox();
-      RenderGlobal.drawBoundingBox(
-         var11.minX - var1.posX + var2,
-         var11.minY - var1.posY + var4,
-         var11.minZ - var1.posZ + var6,
-         var11.maxX - var1.posX + var2,
-         var11.maxY - var1.posY + var4,
-         var11.maxZ - var1.posZ + var6,
-         1.0F,
-         1.0F,
-         1.0F,
-         1.0F
-      );
-      Entity[] var12 = var1.getParts();
-      if (var12 != null) {
-         for (Entity var16 : var12) {
-            double var17 = (var16.posX - var16.prevPosX) * var9;
-            double var19 = (var16.posY - var16.prevPosY) * var9;
-            double var21 = (var16.posZ - var16.prevPosZ) * var9;
-            AxisAlignedBB var23 = var16.getEntityBoundingBox();
+      if (!Shaders.isShadowPass) {
+         GlStateManager.depthMask(false);
+         GlStateManager.disableTexture2D();
+         GlStateManager.disableLighting();
+         GlStateManager.disableCull();
+         GlStateManager.disableBlend();
+         float var10 = var1.width / 2.0F;
+         AxisAlignedBB var11 = var1.getEntityBoundingBox();
+         RenderGlobal.drawBoundingBox(
+            var11.minX - var1.posX + var2,
+            var11.minY - var1.posY + var4,
+            var11.minZ - var1.posZ + var6,
+            var11.maxX - var1.posX + var2,
+            var11.maxY - var1.posY + var4,
+            var11.maxZ - var1.posZ + var6,
+            1.0F,
+            1.0F,
+            1.0F,
+            1.0F
+         );
+         Entity[] var12 = var1.getParts();
+         if (var12 != null) {
+            for (Entity var16 : var12) {
+               double var17 = (var16.posX - var16.prevPosX) * var9;
+               double var19 = (var16.posY - var16.prevPosY) * var9;
+               double var21 = (var16.posZ - var16.prevPosZ) * var9;
+               AxisAlignedBB var23 = var16.getEntityBoundingBox();
+               RenderGlobal.drawBoundingBox(
+                  var23.minX - this.renderPosX + var17,
+                  var23.minY - this.renderPosY + var19,
+                  var23.minZ - this.renderPosZ + var21,
+                  var23.maxX - this.renderPosX + var17,
+                  var23.maxY - this.renderPosY + var19,
+                  var23.maxZ - this.renderPosZ + var21,
+                  0.25F,
+                  1.0F,
+                  0.0F,
+                  1.0F
+               );
+            }
+         }
+
+         if (var1 instanceof EntityLivingBase) {
+            float var24 = 0.01F;
             RenderGlobal.drawBoundingBox(
-               var23.minX - this.renderPosX + var17,
-               var23.minY - this.renderPosY + var19,
-               var23.minZ - this.renderPosZ + var21,
-               var23.maxX - this.renderPosX + var17,
-               var23.maxY - this.renderPosY + var19,
-               var23.maxZ - this.renderPosZ + var21,
-               0.25F,
+               var2 - var10,
+               var4 + var1.getEyeHeight() - 0.01F,
+               var6 - var10,
+               var2 + var10,
+               var4 + var1.getEyeHeight() + 0.01F,
+               var6 + var10,
                1.0F,
                0.0F,
+               0.0F,
                1.0F
             );
          }
-      }
 
-      if (var1 instanceof EntityLivingBase) {
-         float var24 = 0.01F;
-         RenderGlobal.drawBoundingBox(
-            var2 - var10,
-            var4 + var1.getEyeHeight() - 0.01F,
-            var6 - var10,
-            var2 + var10,
-            var4 + var1.getEyeHeight() + 0.01F,
-            var6 + var10,
-            1.0F,
-            0.0F,
-            0.0F,
-            1.0F
-         );
+         Tessellator var25 = Tessellator.getInstance();
+         BufferBuilder var26 = var25.getBuffer();
+         Vec3d var27 = var1.getLook(var9);
+         var26.begin(3, DefaultVertexFormats.POSITION_COLOR);
+         var26.pos(var2, var4 + var1.getEyeHeight(), var6).color(0, 0, 255, 255).endVertex();
+         var26.pos(var2 + var27.x * 2.0, var4 + var1.getEyeHeight() + var27.y * 2.0, var6 + var27.z * 2.0).color(0, 0, 255, 255).endVertex();
+         var25.draw();
+         GlStateManager.enableTexture2D();
+         GlStateManager.enableLighting();
+         GlStateManager.enableCull();
+         GlStateManager.disableBlend();
+         GlStateManager.depthMask(true);
       }
-
-      Tessellator var25 = Tessellator.getInstance();
-      BufferBuilder var26 = var25.getBuffer();
-      Vec3d var27 = var1.getLook(var9);
-      var26.begin(3, DefaultVertexFormats.POSITION_COLOR);
-      var26.pos(var2, var4 + var1.getEyeHeight(), var6).color(0, 0, 255, 255).endVertex();
-      var26.pos(var2 + var27.x * 2.0, var4 + var1.getEyeHeight() + var27.y * 2.0, var6 + var27.z * 2.0).color(0, 0, 255, 255).endVertex();
-      var25.draw();
-      GlStateManager.enableTexture2D();
-      GlStateManager.enableLighting();
-      GlStateManager.enableCull();
-      GlStateManager.disableBlend();
-      GlStateManager.depthMask(true);
    }
 
    public void setWorld(@Nullable World var1) {
       this.world = var1;
       if (var1 == null) {
          this.renderViewEntity = null;
@@ -487,8 +509,16 @@
    public FontRenderer getFontRenderer() {
       return this.textRenderer;
    }
 
    public void setRenderOutlines(boolean var1) {
       this.renderOutlines = var1;
+   }
+
+   public Map<Class, Render> getEntityRenderMap() {
+      return this.entityRenderMap;
+   }
+
+   public Map<String, RenderPlayer> getSkinMap() {
+      return Collections.unmodifiableMap(this.skinMap);
    }
 }
--- net/minecraft/client/renderer/entity/RenderMinecart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderMinecart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderMinecartMobSpawner.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderMinecartMobSpawner.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderMooshroom.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderMooshroom.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderOcelot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderOcelot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPainting.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPainting.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderParrot.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderParrot.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPig.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPig.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPigZombie.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPigZombie.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPlayer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPlayer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPolarBear.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPolarBear.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderPotion.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderPotion.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderRabbit.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderRabbit.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSheep.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSheep.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderShulker.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderShulker.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderShulkerBullet.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderShulkerBullet.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSilverfish.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSilverfish.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSkeleton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSkeleton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSlime.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSlime.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSnowball.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSnowball.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSnowMan.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSnowMan.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSpectralArrow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSpectralArrow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSpider.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSpider.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderSquid.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderSquid.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderStray.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderStray.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderTippedArrow.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderTippedArrow.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderTntMinecart.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderTntMinecart.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderTNTPrimed.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderTNTPrimed.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderVex.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderVex.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderVillager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderVillager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderVindicator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderVindicator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderWitch.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderWitch.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderWither.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderWither.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderWitherSkeleton.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderWitherSkeleton.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderWitherSkull.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderWitherSkull.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderWolf.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderWolf.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderXPOrb.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderXPOrb.java	Mon Aug 18 09:39:52 2025
@@ -6,12 +6,13 @@
 import net.minecraft.client.renderer.RenderHelper;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.CustomColors;
 
 public class RenderXPOrb extends Render<EntityXPOrb> {
    private static final ResourceLocation EXPERIENCE_ORB_TEXTURES = new ResourceLocation("textures/entity/experience_orb.png");
 
    public RenderXPOrb(RenderManager var1) {
       super(var1);
@@ -35,30 +36,46 @@
          float var17 = 0.25F;
          int var18 = var1.getBrightnessForRender();
          int var19 = var18 % 65536;
          int var20 = var18 / 65536;
          OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var19, var20);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         float var26 = 255.0F;
-         float var27 = (var1.xpColor + var9) / 2.0F;
-         var20 = (int)((MathHelper.sin(var27 + 0.0F) + 1.0F) * 0.5F * 255.0F);
-         short var21 = 255;
-         int var22 = (int)((MathHelper.sin(var27 + (float) (Math.PI * 4.0 / 3.0)) + 1.0F) * 0.1F * 255.0F);
+         float var21 = 255.0F;
+         float var22 = (var1.xpColor + var9) / 2.0F;
+         if (Config.isCustomColors()) {
+            var22 = CustomColors.getXpOrbTimer(var22);
+         }
+
+         var20 = (int)((MathHelper.sin(var22 + 0.0F) + 1.0F) * 0.5F * 255.0F);
+         short var23 = 255;
+         int var24 = (int)((MathHelper.sin(var22 + (float) (Math.PI * 4.0 / 3.0)) + 1.0F) * 0.1F * 255.0F);
          GlStateManager.translate(0.0F, 0.1F, 0.0F);
          GlStateManager.rotate(180.0F - this.renderManager.playerViewY, 0.0F, 1.0F, 0.0F);
          GlStateManager.rotate((this.renderManager.options.thirdPersonView == 2 ? -1 : 1) * -this.renderManager.playerViewX, 1.0F, 0.0F, 0.0F);
-         float var23 = 0.3F;
+         float var25 = 0.3F;
          GlStateManager.scale(0.3F, 0.3F, 0.3F);
-         Tessellator var24 = Tessellator.getInstance();
-         BufferBuilder var25 = var24.getBuffer();
-         var25.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
-         var25.pos(-0.5, -0.25, 0.0).tex(var11, var14).color(var20, 255, var22, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         var25.pos(0.5, -0.25, 0.0).tex(var12, var14).color(var20, 255, var22, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         var25.pos(0.5, 0.75, 0.0).tex(var12, var13).color(var20, 255, var22, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         var25.pos(-0.5, 0.75, 0.0).tex(var11, var13).color(var20, 255, var22, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
-         var24.draw();
+         Tessellator var26 = Tessellator.getInstance();
+         BufferBuilder var27 = var26.getBuffer();
+         var27.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
+         int var28 = var20;
+         int var29 = 255;
+         int var30 = var24;
+         if (Config.isCustomColors()) {
+            int var31 = CustomColors.getXpOrbColor(var22);
+            if (var31 >= 0) {
+               var28 = var31 >> 16 & 0xFF;
+               var29 = var31 >> 8 & 0xFF;
+               var30 = var31 >> 0 & 0xFF;
+            }
+         }
+
+         var27.pos(-0.5, -0.25, 0.0).tex(var11, var14).color(var28, var29, var30, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         var27.pos(0.5, -0.25, 0.0).tex(var12, var14).color(var28, var29, var30, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         var27.pos(0.5, 0.75, 0.0).tex(var12, var13).color(var28, var29, var30, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         var27.pos(-0.5, 0.75, 0.0).tex(var11, var13).color(var28, var29, var30, 128).normal(0.0F, 1.0F, 0.0F).endVertex();
+         var26.draw();
          GlStateManager.disableBlend();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
          super.doRender(var1, var2, var4, var6, var8, var9);
       }
    }
--- net/minecraft/client/renderer/entity/RenderZombie.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderZombie.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/entity/RenderZombieVillager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/entity/RenderZombieVillager.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/texture/AbstractTexture.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/AbstractTexture.java	Mon Aug 18 09:39:52 2025
@@ -1,16 +1,19 @@
 package net.minecraft.client.renderer.texture;
 
 import net.minecraft.client.renderer.GlStateManager;
+import net.optifine.shaders.MultiTexID;
+import net.optifine.shaders.ShadersTex;
 
 public abstract class AbstractTexture implements ITextureObject {
    protected int glTextureId = -1;
    protected boolean blur;
    protected boolean mipmap;
    protected boolean blurLast;
    protected boolean mipmapLast;
+   public MultiTexID multiTex;
 
    public void setBlurMipmapDirect(boolean var1, boolean var2) {
       this.blur = var1;
       this.mipmap = var2;
       int var3;
       short var4;
@@ -19,12 +22,13 @@
          var4 = 9729;
       } else {
          var3 = var2 ? 9986 : 9728;
          var4 = 9728;
       }
 
+      GlStateManager.bindTexture(this.getGlTextureId());
       GlStateManager.glTexParameteri(3553, 10241, var3);
       GlStateManager.glTexParameteri(3553, 10240, var4);
    }
 
    @Override
    public void setBlurMipmap(boolean var1, boolean var2) {
@@ -45,12 +49,18 @@
       }
 
       return this.glTextureId;
    }
 
    public void deleteGlTexture() {
+      ShadersTex.deleteTextures(this, this.glTextureId);
       if (this.glTextureId != -1) {
          TextureUtil.deleteTexture(this.glTextureId);
          this.glTextureId = -1;
       }
+   }
+
+   @Override
+   public MultiTexID getMultiTexID() {
+      return ShadersTex.getMultiTexID(this);
    }
 }
--- net/minecraft/client/renderer/texture/DynamicTexture.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/DynamicTexture.java	Mon Aug 18 09:39:52 2025
@@ -1,36 +1,52 @@
 package net.minecraft.client.renderer.texture;
 
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import net.minecraft.client.resources.IResourceManager;
+import net.optifine.shaders.ShadersTex;
 
 public class DynamicTexture extends AbstractTexture {
    private final int[] dynamicTextureData;
    private final int width;
    private final int height;
+   private boolean shadersInitialized = false;
 
    public DynamicTexture(BufferedImage var1) {
       this(var1.getWidth(), var1.getHeight());
       var1.getRGB(0, 0, var1.getWidth(), var1.getHeight(), this.dynamicTextureData, 0, var1.getWidth());
       this.updateDynamicTexture();
    }
 
    public DynamicTexture(int var1, int var2) {
       this.width = var1;
       this.height = var2;
-      this.dynamicTextureData = new int[var1 * var2];
-      TextureUtil.allocateTexture(this.getGlTextureId(), var1, var2);
+      this.dynamicTextureData = new int[var1 * var2 * 3];
+      if (Config.isShaders()) {
+         ShadersTex.initDynamicTexture(this.getGlTextureId(), var1, var2, this);
+         this.shadersInitialized = true;
+      } else {
+         TextureUtil.allocateTexture(this.getGlTextureId(), var1, var2);
+      }
    }
 
    @Override
    public void loadTexture(IResourceManager var1) throws IOException {
    }
 
    public void updateDynamicTexture() {
-      TextureUtil.uploadTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height);
+      if (Config.isShaders()) {
+         if (!this.shadersInitialized) {
+            ShadersTex.initDynamicTexture(this.getGlTextureId(), this.width, this.height, this);
+            this.shadersInitialized = true;
+         }
+
+         ShadersTex.updateDynamicTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height, this);
+      } else {
+         TextureUtil.uploadTexture(this.getGlTextureId(), this.dynamicTextureData, this.width, this.height);
+      }
    }
 
    public int[] getTextureData() {
       return this.dynamicTextureData;
    }
 }
--- net/minecraft/client/renderer/texture/ITextureMapPopulator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/ITextureMapPopulator.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/texture/ITextureObject.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/ITextureObject.java	Mon Aug 18 09:39:52 2025
@@ -1,14 +1,17 @@
 package net.minecraft.client.renderer.texture;
 
 import java.io.IOException;
 import net.minecraft.client.resources.IResourceManager;
+import net.optifine.shaders.MultiTexID;
 
 public interface ITextureObject {
    void setBlurMipmap(boolean var1, boolean var2);
 
    void restoreLastBlurMipmap();
 
    void loadTexture(IResourceManager var1) throws IOException;
 
    int getGlTextureId();
+
+   MultiTexID getMultiTexID();
 }
--- net/minecraft/client/renderer/texture/ITickable.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/ITickable.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/texture/ITickableTextureObject.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/ITickableTextureObject.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/LayeredColorMaskTexture.java	Mon Aug 18 09:39:52 2025
@@ -1,17 +1,20 @@
 package net.minecraft.client.renderer.texture;
 
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.util.List;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class LayeredColorMaskTexture extends AbstractTexture {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -25,70 +28,76 @@
       this.listDyeColors = var3;
    }
 
    @Override
    public void loadTexture(IResourceManager var1) throws IOException {
       this.deleteGlTexture();
-      IResource var3 = null;
+      IResource var2 = null;
 
-      BufferedImage var2;
-      label198: {
+      BufferedImage var3;
+      label201: {
          try {
-            var3 = var1.getResource(this.textureLocation);
-            BufferedImage var4 = TextureUtil.readBufferedImage(var3.getInputStream());
+            var2 = var1.getResource(this.textureLocation);
+            BufferedImage var4 = TextureUtil.readBufferedImage(var2.getInputStream());
             int var5 = var4.getType();
             if (var5 == 0) {
                var5 = 6;
             }
 
-            var2 = new BufferedImage(var4.getWidth(), var4.getHeight(), var5);
-            Graphics var6 = var2.getGraphics();
-            var6.drawImage(var4, 0, 0, null);
+            var3 = new BufferedImage(var4.getWidth(), var4.getHeight(), var5);
+            Graphics var6 = var3.getGraphics();
+            var6.drawImage(var4, 0, 0, (ImageObserver)null);
             int var7 = 0;
 
             while (true) {
                if (var7 >= 17 || var7 >= this.listTextures.size() || var7 >= this.listDyeColors.size()) {
-                  break label198;
+                  break label201;
                }
 
                IResource var8 = null;
 
                try {
                   String var9 = this.listTextures.get(var7);
                   int var10 = this.listDyeColors.get(var7).getColorValue();
                   if (var9 != null) {
                      var8 = var1.getResource(new ResourceLocation(var9));
-                     BufferedImage var11 = TextureUtil.readBufferedImage(var8.getInputStream());
-                     if (var11.getWidth() == var2.getWidth() && var11.getHeight() == var2.getHeight() && var11.getType() == 6) {
+                     BufferedImage var11 = Reflector.MinecraftForgeClient_getImageLayer.exists()
+                        ? (BufferedImage)Reflector.call(Reflector.MinecraftForgeClient_getImageLayer, new Object[]{new ResourceLocation(var9), var1})
+                        : TextureUtil.readBufferedImage(var8.getInputStream());
+                     if (var11.getWidth() == var3.getWidth() && var11.getHeight() == var3.getHeight() && var11.getType() == 6) {
                         for (int var12 = 0; var12 < var11.getHeight(); var12++) {
                            for (int var13 = 0; var13 < var11.getWidth(); var13++) {
                               int var14 = var11.getRGB(var13, var12);
                               if ((var14 & 0xFF000000) != 0) {
                                  int var15 = (var14 & 0xFF0000) << 8 & 0xFF000000;
                                  int var16 = var4.getRGB(var13, var12);
                                  int var17 = MathHelper.multiplyColor(var16, var10) & 16777215;
                                  var11.setRGB(var13, var12, var15 | var17);
                               }
                            }
                         }
 
-                        var2.getGraphics().drawImage(var11, 0, 0, null);
+                        var3.getGraphics().drawImage(var11, 0, 0, (ImageObserver)null);
                      }
                   }
                } finally {
                   IOUtils.closeQuietly(var8);
                }
 
                var7++;
             }
          } catch (IOException var27) {
             LOGGER.error("Couldn't load layered image", var27);
          } finally {
-            IOUtils.closeQuietly(var3);
+            IOUtils.closeQuietly(var2);
          }
 
          return;
       }
 
-      TextureUtil.uploadTextureImage(this.getGlTextureId(), var2);
+      if (Config.isShaders()) {
+         ShadersTex.loadSimpleTexture(this.getGlTextureId(), var3, false, false, var1, this.textureLocation, this.getMultiTexID());
+      } else {
+         TextureUtil.uploadTextureImage(this.getGlTextureId(), var3);
+      }
    }
 }
--- net/minecraft/client/renderer/texture/LayeredTexture.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/LayeredTexture.java	Mon Aug 18 09:39:52 2025
@@ -1,25 +1,31 @@
 package net.minecraft.client.renderer.texture;
 
 import com.google.common.collect.Lists;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.util.List;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class LayeredTexture extends AbstractTexture {
    private static final Logger LOGGER = LogManager.getLogger();
    public final List<String> layeredTextureNames;
+   private ResourceLocation textureLocation;
 
    public LayeredTexture(String... var1) {
       this.layeredTextureNames = Lists.newArrayList(var1);
+      if (var1.length > 0 && var1[0] != null) {
+         this.textureLocation = new ResourceLocation(var1[0]);
+      }
    }
 
    @Override
    public void loadTexture(IResourceManager var1) throws IOException {
       this.deleteGlTexture();
       BufferedImage var2 = null;
@@ -32,21 +38,25 @@
                var5 = var1.getResource(new ResourceLocation(var4));
                BufferedImage var6 = TextureUtil.readBufferedImage(var5.getInputStream());
                if (var2 == null) {
                   var2 = new BufferedImage(var6.getWidth(), var6.getHeight(), 2);
                }
 
-               var2.getGraphics().drawImage(var6, 0, 0, null);
+               var2.getGraphics().drawImage(var6, 0, 0, (ImageObserver)null);
             }
             continue;
          } catch (IOException var10) {
             LOGGER.error("Couldn't load layered image", var10);
          } finally {
             IOUtils.closeQuietly(var5);
          }
 
          return;
       }
 
-      TextureUtil.uploadTextureImage(this.getGlTextureId(), var2);
+      if (Config.isShaders()) {
+         ShadersTex.loadSimpleTexture(this.getGlTextureId(), var2, false, false, var1, this.textureLocation, this.getMultiTexID());
+      } else {
+         TextureUtil.uploadTextureImage(this.getGlTextureId(), var2);
+      }
    }
 }
--- net/minecraft/client/renderer/texture/PngSizeInfo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/PngSizeInfo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/texture/SimpleTexture.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/SimpleTexture.java	Mon Aug 18 09:39:52 2025
@@ -3,19 +3,23 @@
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.data.TextureMetadataSection;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.EmissiveTextures;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class SimpleTexture extends AbstractTexture {
    private static final Logger LOGGER = LogManager.getLogger();
    protected final ResourceLocation textureLocation;
+   public ResourceLocation locationEmissive;
+   public boolean isEmissive;
 
    public SimpleTexture(ResourceLocation var1) {
       this.textureLocation = var1;
    }
 
    @Override
@@ -27,22 +31,30 @@
          var2 = var1.getResource(this.textureLocation);
          BufferedImage var3 = TextureUtil.readBufferedImage(var2.getInputStream());
          boolean var4 = false;
          boolean var5 = false;
          if (var2.hasMetadata()) {
             try {
-               TextureMetadataSection var6 = var2.getMetadata("texture");
+               TextureMetadataSection var6 = (TextureMetadataSection)var2.getMetadata("texture");
                if (var6 != null) {
                   var4 = var6.getTextureBlur();
                   var5 = var6.getTextureClamp();
                }
             } catch (RuntimeException var10) {
                LOGGER.warn("Failed reading metadata of: {}", this.textureLocation, var10);
             }
          }
 
-         TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(), var3, var4, var5);
+         if (Config.isShaders()) {
+            ShadersTex.loadSimpleTexture(this.getGlTextureId(), var3, var4, var5, var1, this.textureLocation, this.getMultiTexID());
+         } else {
+            TextureUtil.uploadTextureImageAllocate(this.getGlTextureId(), var3, var4, var5);
+         }
+
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.loadTexture(this.textureLocation, this);
+         }
       } finally {
          IOUtils.closeQuietly(var2);
       }
    }
 }
--- net/minecraft/client/renderer/texture/Stitcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/Stitcher.java	Mon Aug 18 09:39:52 2025
@@ -5,12 +5,13 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 import net.minecraft.client.renderer.StitcherException;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.util.MathUtils;
 
 public class Stitcher {
    private final int mipmapLevelStitcher;
    private final Set<Stitcher.Holder> setStitchHolders = Sets.newHashSetWithExpectedSize(256);
    private final List<Stitcher.Slot> stitchSlots = Lists.newArrayListWithCapacity(256);
    private int currentWidth;
@@ -42,21 +43,25 @@
 
       this.setStitchHolders.add(var2);
    }
 
    public void doStitch() {
       Stitcher.Holder[] var1 = this.setStitchHolders.toArray(new Stitcher.Holder[this.setStitchHolders.size()]);
-      Arrays.sort((Object[])var1);
+      Arrays.sort(var1);
 
       for (Stitcher.Holder var5 : var1) {
          if (!this.allocateSlot(var5)) {
             String var6 = String.format(
-               "Unable to fit: %s - size: %dx%d - Maybe try a lowerresolution resourcepack?",
+               "Unable to fit: %s, size: %dx%d, atlas: %dx%d, atlasMax: %dx%d - Maybe try a lower resolution resourcepack?",
                var5.getAtlasSprite().getIconName(),
                var5.getAtlasSprite().getIconWidth(),
-               var5.getAtlasSprite().getIconHeight()
+               var5.getAtlasSprite().getIconHeight(),
+               this.currentWidth,
+               this.currentHeight,
+               this.maxWidth,
+               this.maxHeight
             );
             throw new StitcherException(var5, var6);
          }
       }
 
       this.currentWidth = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth);
@@ -108,49 +113,46 @@
       return this.expandAndAllocateSlot(var1);
    }
 
    private boolean expandAndAllocateSlot(Stitcher.Holder var1) {
       int var2 = Math.min(var1.getWidth(), var1.getHeight());
       int var3 = Math.max(var1.getWidth(), var1.getHeight());
-      int var5 = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth);
-      int var6 = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight);
-      int var7 = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth + var2);
-      int var8 = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight + var2);
-      boolean var9 = var7 <= this.maxWidth;
-      boolean var10 = var8 <= this.maxHeight;
-      if (!var9 && !var10) {
+      int var4 = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth);
+      int var5 = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight);
+      int var6 = MathHelper.smallestEncompassingPowerOfTwo(this.currentWidth + var2);
+      int var7 = MathHelper.smallestEncompassingPowerOfTwo(this.currentHeight + var2);
+      boolean var8 = var6 <= this.maxWidth;
+      boolean var9 = var7 <= this.maxHeight;
+      if (!var8 && !var9) {
          return false;
       } else {
-         boolean var11 = var9 && var5 != var7;
-         boolean var12 = var10 && var6 != var8;
-         boolean var4;
-         if (var11 ^ var12) {
-            var4 = var11;
-         } else {
-            var4 = var9 && var5 <= var6;
+         int var10 = MathUtils.roundDownToPowerOfTwo(this.currentHeight);
+         boolean var11 = var8 && var6 <= 2 * var10;
+         if (this.currentWidth == 0 && this.currentHeight == 0) {
+            var11 = true;
          }
 
-         Stitcher.Slot var13;
-         if (var4) {
+         Stitcher.Slot var12;
+         if (var11) {
             if (var1.getWidth() > var1.getHeight()) {
                var1.rotate();
             }
 
             if (this.currentHeight == 0) {
                this.currentHeight = var1.getHeight();
             }
 
-            var13 = new Stitcher.Slot(this.currentWidth, 0, var1.getWidth(), this.currentHeight);
+            var12 = new Stitcher.Slot(this.currentWidth, 0, var1.getWidth(), this.currentHeight);
             this.currentWidth = this.currentWidth + var1.getWidth();
          } else {
-            var13 = new Stitcher.Slot(0, this.currentHeight, this.currentWidth, var1.getHeight());
+            var12 = new Stitcher.Slot(0, this.currentHeight, this.currentWidth, var1.getHeight());
             this.currentHeight = this.currentHeight + var1.getHeight();
          }
 
-         var13.addSlot(var1);
-         this.stitchSlots.add(var13);
+         var12.addSlot(var1);
+         this.stitchSlots.add(var12);
          return true;
       }
    }
 
    public static class Holder implements Comparable<Stitcher.Holder> {
       private final TextureAtlasSprite sprite;
@@ -195,13 +197,13 @@
             this.scaleFactor = (float)var1 / Math.min(this.width, this.height);
          }
       }
 
       @Override
       public String toString() {
-         return "Holder{width=" + this.width + ", height=" + this.height + '}';
+         return "Holder{width=" + this.width + ", height=" + this.height + ", name=" + this.sprite.getIconName() + '}';
       }
 
       public int compareTo(Stitcher.Holder var1) {
          int var2;
          if (this.getHeight() == var1.getHeight()) {
             if (this.getWidth() == var1.getWidth()) {
--- net/minecraft/client/renderer/texture/TextureAtlasSprite.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/TextureAtlasSprite.java	Mon Aug 18 09:39:52 2025
@@ -1,21 +1,29 @@
 package net.minecraft.client.renderer.texture;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
+import java.util.function.Function;
 import net.minecraft.client.resources.IResource;
+import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.data.AnimationFrame;
 import net.minecraft.client.resources.data.AnimationMetadataSection;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.SmartAnimations;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.CounterInt;
+import net.optifine.util.TextureUtils;
 
 public class TextureAtlasSprite {
    private final String iconName;
    protected List<int[][]> framesTextureData = Lists.newArrayList();
    protected int[][] interpolatedFrameData;
    private AnimationMetadataSection animationMetadata;
@@ -27,15 +35,40 @@
    private float minU;
    private float maxU;
    private float minV;
    private float maxV;
    protected int frameCounter;
    protected int tickCounter;
+   private int indexInMap = -1;
+   public float baseU;
+   public float baseV;
+   public int sheetWidth;
+   public int sheetHeight;
+   public int glSpriteTextureId = -1;
+   public TextureAtlasSprite spriteSingle = null;
+   public boolean isSpriteSingle = false;
+   public int mipmapLevels = 0;
+   public TextureAtlasSprite spriteNormal = null;
+   public TextureAtlasSprite spriteSpecular = null;
+   public boolean isShadersSprite = false;
+   public boolean isDependencyParent = false;
+   public boolean isEmissive = false;
+   public TextureAtlasSprite spriteEmissive = null;
+   private int animationIndex = -1;
+   private boolean animationActive = false;
 
-   protected TextureAtlasSprite(String var1) {
+   private TextureAtlasSprite(String var1, boolean var2) {
       this.iconName = var1;
+      this.isSpriteSingle = var2;
+   }
+
+   public TextureAtlasSprite(String var1) {
+      this.iconName = var1;
+      if (Config.isMultiTexture()) {
+         this.spriteSingle = new TextureAtlasSprite(this.getIconName() + ".spriteSingle", true);
+      }
    }
 
    protected static TextureAtlasSprite makeAtlasSprite(ResourceLocation var0) {
       return new TextureAtlasSprite(var0.toString());
    }
 
@@ -46,24 +79,52 @@
       float var6 = (float)(0.01F / var1);
       float var7 = (float)(0.01F / var2);
       this.minU = var3 / (float)var1 + var6;
       this.maxU = (var3 + this.width) / (float)var1 - var6;
       this.minV = (float)var4 / var2 + var7;
       this.maxV = (float)(var4 + this.height) / var2 - var7;
+      this.baseU = Math.min(this.minU, this.maxU);
+      this.baseV = Math.min(this.minV, this.maxV);
+      if (this.spriteSingle != null) {
+         this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
+      }
+
+      if (this.spriteNormal != null) {
+         this.spriteNormal.copyFrom(this);
+      }
+
+      if (this.spriteSpecular != null) {
+         this.spriteSpecular.copyFrom(this);
+      }
    }
 
    public void copyFrom(TextureAtlasSprite var1) {
       this.originX = var1.originX;
       this.originY = var1.originY;
       this.width = var1.width;
       this.height = var1.height;
       this.rotated = var1.rotated;
       this.minU = var1.minU;
       this.maxU = var1.maxU;
       this.minV = var1.minV;
       this.maxV = var1.maxV;
+      if (var1 != Config.getTextureMap().getMissingSprite()) {
+         this.indexInMap = var1.indexInMap;
+      }
+
+      this.baseU = var1.baseU;
+      this.baseV = var1.baseV;
+      this.sheetWidth = var1.sheetWidth;
+      this.sheetHeight = var1.sheetHeight;
+      this.glSpriteTextureId = var1.glSpriteTextureId;
+      this.mipmapLevels = var1.mipmapLevels;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.initSprite(this.width, this.height, 0, 0, false);
+      }
+
+      this.animationIndex = var1.animationIndex;
    }
 
    public int getOriginX() {
       return this.originX;
    }
 
@@ -117,24 +178,37 @@
 
    public String getIconName() {
       return this.iconName;
    }
 
    public void updateAnimation() {
-      this.tickCounter++;
-      if (this.tickCounter >= this.animationMetadata.getFrameTimeSingle(this.frameCounter)) {
-         int var1 = this.animationMetadata.getFrameIndex(this.frameCounter);
-         int var2 = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
-         this.frameCounter = (this.frameCounter + 1) % var2;
-         this.tickCounter = 0;
-         int var3 = this.animationMetadata.getFrameIndex(this.frameCounter);
-         if (var1 != var3 && var3 >= 0 && var3 < this.framesTextureData.size()) {
-            TextureUtil.uploadTextureMipmap(this.framesTextureData.get(var3), this.width, this.height, this.originX, this.originY, false, false);
+      if (this.animationMetadata != null) {
+         this.animationActive = SmartAnimations.isActive() ? SmartAnimations.isSpriteRendered(this.animationIndex) : true;
+         this.tickCounter++;
+         if (this.tickCounter >= this.animationMetadata.getFrameTimeSingle(this.frameCounter)) {
+            int var1 = this.animationMetadata.getFrameIndex(this.frameCounter);
+            int var2 = this.animationMetadata.getFrameCount() == 0 ? this.framesTextureData.size() : this.animationMetadata.getFrameCount();
+            this.frameCounter = (this.frameCounter + 1) % var2;
+            this.tickCounter = 0;
+            int var3 = this.animationMetadata.getFrameIndex(this.frameCounter);
+            boolean var4 = false;
+            boolean var5 = this.isSpriteSingle;
+            if (!this.animationActive) {
+               return;
+            }
+
+            if (var1 != var3 && var3 >= 0 && var3 < this.framesTextureData.size()) {
+               TextureUtil.uploadTextureMipmap(this.framesTextureData.get(var3), this.width, this.height, this.originX, this.originY, var4, var5);
+            }
+         } else if (this.animationMetadata.isInterpolate()) {
+            if (!this.animationActive) {
+               return;
+            }
+
+            this.updateAnimationInterpolated();
          }
-      } else if (this.animationMetadata.isInterpolate()) {
-         this.updateAnimationInterpolated();
       }
    }
 
    private void updateAnimationInterpolated() {
       double var1 = 1.0 - (double)this.tickCounter / this.animationMetadata.getFrameTimeSingle(this.frameCounter);
       int var3 = this.animationMetadata.getFrameIndex(this.frameCounter);
@@ -179,32 +253,47 @@
    public int getFrameCount() {
       return this.framesTextureData.size();
    }
 
    public void setIconWidth(int var1) {
       this.width = var1;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setIconWidth(this.width);
+      }
    }
 
    public void setIconHeight(int var1) {
       this.height = var1;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setIconHeight(this.height);
+      }
    }
 
    public void loadSprite(PngSizeInfo var1, boolean var2) throws IOException {
       this.resetSprite();
       this.width = var1.pngWidth;
       this.height = var1.pngHeight;
       if (var2) {
          this.height = this.width;
       } else if (var1.pngHeight != var1.pngWidth) {
          throw new RuntimeException("broken aspect ratio and not an animation");
       }
+
+      if (this.spriteSingle != null) {
+         this.spriteSingle.width = this.width;
+         this.spriteSingle.height = this.height;
+      }
    }
 
    public void loadSpriteFrames(IResource var1, int var2) throws IOException {
       BufferedImage var3 = TextureUtil.readBufferedImage(var1.getInputStream());
-      AnimationMetadataSection var4 = var1.getMetadata("animation");
+      if (this.width != var3.getWidth()) {
+         var3 = TextureUtils.scaleImage(var3, this.width);
+      }
+
+      AnimationMetadataSection var4 = (AnimationMetadataSection)var1.getMetadata("animation");
       int[][] var5 = new int[var2][];
       var5[0] = new int[var3.getWidth() * var3.getHeight()];
       var3.getRGB(0, 0, var3.getWidth(), var3.getHeight(), var5[0], 0, var3.getWidth());
       if (var4 == null) {
          this.framesTextureData.add(var5);
       } else {
@@ -218,20 +307,41 @@
                this.allocateFrameTextureData(var8);
                this.framesTextureData.set(var8, getFrameTextureData(var5, this.width, this.width, var8));
             }
 
             this.animationMetadata = var4;
          } else {
-            ArrayList var9 = Lists.newArrayList();
+            ArrayList var12 = Lists.newArrayList();
 
-            for (int var10 = 0; var10 < var6; var10++) {
-               this.framesTextureData.add(getFrameTextureData(var5, this.width, this.width, var10));
-               var9.add(new AnimationFrame(var10, -1));
+            for (int var14 = 0; var14 < var6; var14++) {
+               this.framesTextureData.add(getFrameTextureData(var5, this.width, this.width, var14));
+               var12.add(new AnimationFrame(var14, -1));
             }
 
-            this.animationMetadata = new AnimationMetadataSection(var9, this.width, this.height, var4.getFrameTime(), var4.isInterpolate());
+            this.animationMetadata = new AnimationMetadataSection(var12, this.width, this.height, var4.getFrameTime(), var4.isInterpolate());
+         }
+      }
+
+      if (!this.isShadersSprite) {
+         if (Config.isShaders()) {
+            this.loadShadersSprites();
+         }
+
+         for (int var10 = 0; var10 < this.framesTextureData.size(); var10++) {
+            int[][] var13 = this.framesTextureData.get(var10);
+            if (var13 != null && !this.iconName.startsWith("minecraft:blocks/leaves_")) {
+               for (int var15 = 0; var15 < var13.length; var15++) {
+                  int[] var9 = var13[var15];
+                  this.fixTransparentColor(var9);
+               }
+            }
+         }
+
+         if (this.spriteSingle != null) {
+            IResource var11 = Config.getResourceManager().getResource(var1.getResourceLocation());
+            this.spriteSingle.loadSpriteFrames(var11, var2);
          }
       }
    }
 
    public void generateMipmaps(int var1) {
       ArrayList var2 = Lists.newArrayList();
@@ -263,20 +373,27 @@
                throw new ReportedException(var6);
             }
          }
       }
 
       this.setFramesTextureData(var2);
+      if (this.spriteSingle != null) {
+         this.spriteSingle.generateMipmaps(var1);
+      }
    }
 
    private void allocateFrameTextureData(int var1) {
       if (this.framesTextureData.size() <= var1) {
          for (int var2 = this.framesTextureData.size(); var2 <= var1; var2++) {
             this.framesTextureData.add(null);
          }
       }
+
+      if (this.spriteSingle != null) {
+         this.spriteSingle.allocateFrameTextureData(var1);
+      }
    }
 
    private static int[][] getFrameTextureData(int[][] var0, int var1, int var2, int var3) {
       int[][] var4 = new int[var0.length][];
 
       for (int var5 = 0; var5 < var0.length; var5++) {
@@ -289,27 +406,36 @@
 
       return var4;
    }
 
    public void clearFramesTextureData() {
       this.framesTextureData.clear();
+      if (this.spriteSingle != null) {
+         this.spriteSingle.clearFramesTextureData();
+      }
    }
 
    public boolean hasAnimationMetadata() {
       return this.animationMetadata != null;
    }
 
    public void setFramesTextureData(List<int[][]> var1) {
       this.framesTextureData = var1;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.setFramesTextureData(var1);
+      }
    }
 
    private void resetSprite() {
       this.animationMetadata = null;
       this.setFramesTextureData(Lists.newArrayList());
       this.frameCounter = 0;
       this.tickCounter = 0;
+      if (this.spriteSingle != null) {
+         this.spriteSingle.resetSprite();
+      }
    }
 
    @Override
    public String toString() {
       return "TextureAtlasSprite{name='"
          + this.iconName
@@ -332,8 +458,170 @@
          + this.maxU
          + ", v0="
          + this.minV
          + ", v1="
          + this.maxV
          + '}';
+   }
+
+   public boolean hasCustomLoader(IResourceManager var1, ResourceLocation var2) {
+      return false;
+   }
+
+   public boolean load(IResourceManager var1, ResourceLocation var2, Function<ResourceLocation, TextureAtlasSprite> var3) {
+      return true;
+   }
+
+   public Collection<ResourceLocation> getDependencies() {
+      return ImmutableList.of();
+   }
+
+   public int getIndexInMap() {
+      return this.indexInMap;
+   }
+
+   public void setIndexInMap(int var1) {
+      this.indexInMap = var1;
+   }
+
+   public void updateIndexInMap(CounterInt var1) {
+      if (this.indexInMap < 0) {
+         this.indexInMap = var1.nextValue();
+      }
+   }
+
+   public int getAnimationIndex() {
+      return this.animationIndex;
+   }
+
+   public void setAnimationIndex(int var1) {
+      this.animationIndex = var1;
+      if (this.spriteNormal != null) {
+         this.spriteNormal.setAnimationIndex(var1);
+      }
+
+      if (this.spriteSpecular != null) {
+         this.spriteSpecular.setAnimationIndex(var1);
+      }
+   }
+
+   public boolean isAnimationActive() {
+      return this.animationActive;
+   }
+
+   private void fixTransparentColor(int[] var1) {
+      if (var1 != null) {
+         long var2 = 0L;
+         long var4 = 0L;
+         long var6 = 0L;
+         long var8 = 0L;
+
+         for (int var10 = 0; var10 < var1.length; var10++) {
+            int var11 = var1[var10];
+            int var12 = var11 >> 24 & 0xFF;
+            if (var12 >= 16) {
+               int var13 = var11 >> 16 & 0xFF;
+               int var14 = var11 >> 8 & 0xFF;
+               int var15 = var11 & 0xFF;
+               var2 += var13;
+               var4 += var14;
+               var6 += var15;
+               var8++;
+            }
+         }
+
+         if (var8 > 0L) {
+            int var17 = (int)(var2 / var8);
+            int var18 = (int)(var4 / var8);
+            int var19 = (int)(var6 / var8);
+            int var20 = var17 << 16 | var18 << 8 | var19;
+
+            for (int var21 = 0; var21 < var1.length; var21++) {
+               int var22 = var1[var21];
+               int var16 = var22 >> 24 & 0xFF;
+               if (var16 <= 16) {
+                  var1[var21] = var20;
+               }
+            }
+         }
+      }
+   }
+
+   public double getSpriteU16(float var1) {
+      float var2 = this.maxU - this.minU;
+      return (var1 - this.minU) / var2 * 16.0F;
+   }
+
+   public double getSpriteV16(float var1) {
+      float var2 = this.maxV - this.minV;
+      return (var1 - this.minV) / var2 * 16.0F;
+   }
+
+   public void bindSpriteTexture() {
+      if (this.glSpriteTextureId < 0) {
+         this.glSpriteTextureId = TextureUtil.glGenTextures();
+         TextureUtil.allocateTextureImpl(this.glSpriteTextureId, this.mipmapLevels, this.width, this.height);
+         TextureUtils.applyAnisotropicLevel();
+      }
+
+      TextureUtils.bindTexture(this.glSpriteTextureId);
+   }
+
+   public void deleteSpriteTexture() {
+      if (this.glSpriteTextureId >= 0) {
+         TextureUtil.deleteTexture(this.glSpriteTextureId);
+         this.glSpriteTextureId = -1;
+      }
+   }
+
+   public float toSingleU(float var1) {
+      var1 -= this.baseU;
+      float var2 = (float)this.sheetWidth / this.width;
+      return var1 * var2;
+   }
+
+   public float toSingleV(float var1) {
+      var1 -= this.baseV;
+      float var2 = (float)this.sheetHeight / this.height;
+      return var1 * var2;
+   }
+
+   public List<int[][]> getFramesTextureData() {
+      ArrayList var1 = new ArrayList();
+      var1.addAll(this.framesTextureData);
+      return var1;
+   }
+
+   public AnimationMetadataSection getAnimationMetadata() {
+      return this.animationMetadata;
+   }
+
+   public void setAnimationMetadata(AnimationMetadataSection var1) {
+      this.animationMetadata = var1;
+   }
+
+   private void loadShadersSprites() {
+      if (Shaders.configNormalMap) {
+         String var1 = this.iconName + "_n";
+         ResourceLocation var2 = new ResourceLocation(var1);
+         var2 = Config.getTextureMap().completeResourceLocation(var2);
+         if (Config.hasResource(var2)) {
+            this.spriteNormal = new TextureAtlasSprite(var1);
+            this.spriteNormal.isShadersSprite = true;
+            this.spriteNormal.copyFrom(this);
+            Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteNormal);
+         }
+      }
+
+      if (Shaders.configSpecularMap) {
+         String var3 = this.iconName + "_s";
+         ResourceLocation var5 = new ResourceLocation(var3);
+         var5 = Config.getTextureMap().completeResourceLocation(var5);
+         if (Config.hasResource(var5)) {
+            this.spriteSpecular = new TextureAtlasSprite(var3);
+            this.spriteSpecular.isShadersSprite = true;
+            this.spriteSpecular.copyFrom(this);
+            Config.getTextureMap().generateMipmaps(Config.getResourceManager(), this.spriteSpecular);
+         }
+      }
    }
 }
--- net/minecraft/client/renderer/texture/TextureManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/TextureManager.java	Mon Aug 18 09:39:52 2025
@@ -1,45 +1,71 @@
 package net.minecraft.client.renderer.texture;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.io.IOException;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.CustomGuis;
+import net.optifine.EmissiveTextures;
+import net.optifine.RandomEntities;
+import net.optifine.shaders.ShadersTex;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class TextureManager implements ITickable, IResourceManagerReloadListener {
    private static final Logger LOGGER = LogManager.getLogger();
    public static final ResourceLocation RESOURCE_LOCATION_EMPTY = new ResourceLocation("");
    private final Map<ResourceLocation, ITextureObject> mapTextureObjects = Maps.newHashMap();
    private final List<ITickable> listTickables = Lists.newArrayList();
    private final Map<String, Integer> mapTextureCounters = Maps.newHashMap();
    private final IResourceManager resourceManager;
+   private ITextureObject boundTexture;
+   private ResourceLocation boundTextureLocation;
 
    public TextureManager(IResourceManager var1) {
       this.resourceManager = var1;
    }
 
    public void bindTexture(ResourceLocation var1) {
+      if (Config.isRandomEntities()) {
+         var1 = RandomEntities.getTextureLocation(var1);
+      }
+
+      if (Config.isCustomGuis()) {
+         var1 = CustomGuis.getTextureLocation(var1);
+      }
+
       Object var2 = this.mapTextureObjects.get(var1);
+      if (EmissiveTextures.isActive()) {
+         var2 = EmissiveTextures.getEmissiveTexture((ITextureObject)var2, this.mapTextureObjects);
+      }
+
       if (var2 == null) {
          var2 = new SimpleTexture(var1);
          this.loadTexture(var1, (ITextureObject)var2);
       }
 
-      TextureUtil.bindTexture(((ITextureObject)var2).getGlTextureId());
+      if (Config.isShaders()) {
+         ShadersTex.bindTexture((ITextureObject)var2);
+      } else {
+         TextureUtil.bindTexture(((ITextureObject)var2).getGlTextureId());
+      }
+
+      this.boundTexture = (ITextureObject)var2;
+      this.boundTextureLocation = var1;
    }
 
    public boolean loadTickableTexture(ResourceLocation var1, ITickableTextureObject var2) {
       if (this.loadTexture(var1, var2)) {
          this.listTickables.add(var2);
          return true;
@@ -59,32 +85,36 @@
          }
 
          var2 = TextureUtil.MISSING_TEXTURE;
          this.mapTextureObjects.put(var1, (ITextureObject)var2);
          var3 = false;
       } catch (Throwable var9) {
-         CrashReport var5 = CrashReport.makeCrashReport(var9, "Registering texture");
-         CrashReportCategory var6 = var5.makeCategory("Resource location being registered");
-         var6.addCrashSection("Resource location", var1);
-         var6.addDetail("Texture object class", new ICrashReportDetail<String>() {
+         CrashReport var6 = CrashReport.makeCrashReport(var9, "Registering texture");
+         CrashReportCategory var7 = var6.makeCategory("Resource location being registered");
+         var7.addCrashSection("Resource location", var1);
+         var7.addDetail("Texture object class", new ICrashReportDetail<String>() {
             public String call() throws Exception {
                return var2.getClass().getName();
             }
          });
-         throw new ReportedException(var5);
+         throw new ReportedException(var6);
       }
 
       this.mapTextureObjects.put(var1, (ITextureObject)var2);
       return var3;
    }
 
    public ITextureObject getTexture(ResourceLocation var1) {
       return this.mapTextureObjects.get(var1);
    }
 
    public ResourceLocation getDynamicTextureLocation(String var1, DynamicTexture var2) {
+      if (var1.equals("logo")) {
+         var2 = Config.getMojangLogoTexture(var2);
+      }
+
       Integer var3 = this.mapTextureCounters.get(var1);
       if (var3 == null) {
          var3 = 1;
       } else {
          var3 = var3 + 1;
       }
@@ -92,35 +122,72 @@
       this.mapTextureCounters.put(var1, var3);
       ResourceLocation var4 = new ResourceLocation(String.format("dynamic/%s_%d", var1, var3));
       this.loadTexture(var4, var2);
       return var4;
    }
 
-   @Override
    public void tick() {
       for (ITickable var2 : this.listTickables) {
          var2.tick();
       }
    }
 
    public void deleteTexture(ResourceLocation var1) {
       ITextureObject var2 = this.getTexture(var1);
       if (var2 != null) {
+         this.mapTextureObjects.remove(var1);
          TextureUtil.deleteTexture(var2.getGlTextureId());
       }
    }
 
-   @Override
    public void onResourceManagerReload(IResourceManager var1) {
-      Iterator var2 = this.mapTextureObjects.entrySet().iterator();
+      Config.dbg("*** Reloading textures ***");
+      Config.log("Resource packs: " + Config.getResourcePackNames());
+      Iterator var2 = this.mapTextureObjects.keySet().iterator();
 
       while (var2.hasNext()) {
-         Entry var3 = (Entry)var2.next();
-         ITextureObject var4 = (ITextureObject)var3.getValue();
-         if (var4 == TextureUtil.MISSING_TEXTURE) {
+         ResourceLocation var3 = (ResourceLocation)var2.next();
+         String var4 = var3.getPath();
+         if (var4.startsWith("mcpatcher/") || var4.startsWith("optifine/") || EmissiveTextures.isEmissive(var3)) {
+            ITextureObject var5 = this.mapTextureObjects.get(var3);
+            if (var5 instanceof AbstractTexture) {
+               AbstractTexture var6 = (AbstractTexture)var5;
+               var6.deleteGlTexture();
+            }
+
             var2.remove();
+         }
+      }
+
+      EmissiveTextures.update();
+      HashSet var7 = new HashSet<>(this.mapTextureObjects.entrySet());
+      Iterator var8 = var7.iterator();
+
+      while (var8.hasNext()) {
+         Entry var9 = (Entry)var8.next();
+         ITextureObject var10 = (ITextureObject)var9.getValue();
+         if (var10 == TextureUtil.MISSING_TEXTURE) {
+            var8.remove();
          } else {
-            this.loadTexture((ResourceLocation)var3.getKey(), var4);
+            this.loadTexture((ResourceLocation)var9.getKey(), var10);
+         }
+      }
+   }
+
+   public void reloadBannerTextures() {
+      for (Entry var3 : new HashSet<>(this.mapTextureObjects.entrySet())) {
+         ResourceLocation var4 = (ResourceLocation)var3.getKey();
+         ITextureObject var5 = (ITextureObject)var3.getValue();
+         if (var5 instanceof LayeredColorMaskTexture) {
+            this.loadTexture(var4, var5);
          }
       }
+   }
+
+   public ITextureObject getBoundTexture() {
+      return this.boundTexture;
+   }
+
+   public ResourceLocation getBoundTextureLocation() {
+      return this.boundTextureLocation;
    }
 }
--- net/minecraft/client/renderer/texture/TextureMap.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/TextureMap.java	Mon Aug 18 09:39:52 2025
@@ -1,261 +1,787 @@
 package net.minecraft.client.renderer.texture;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import java.awt.Dimension;
+import java.awt.image.BufferedImage;
 import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.Map.Entry;
 import javax.annotation.Nullable;
-import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.StitcherException;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.BetterGrass;
+import net.optifine.ConnectedTextures;
+import net.optifine.CustomItems;
+import net.optifine.EmissiveTextures;
+import net.optifine.SmartAnimations;
+import net.optifine.SpriteDependencies;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.ShadersTex;
+import net.optifine.util.CounterInt;
+import net.optifine.util.TextureUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class TextureMap extends AbstractTexture implements ITickableTextureObject {
    private static final Logger LOGGER = LogManager.getLogger();
    public static final ResourceLocation LOCATION_MISSING_TEXTURE = new ResourceLocation("missingno");
    public static final ResourceLocation LOCATION_BLOCKS_TEXTURE = new ResourceLocation("textures/atlas/blocks.png");
-   private final List<TextureAtlasSprite> listAnimatedSprites = Lists.newArrayList();
-   private final Map<String, TextureAtlasSprite> mapRegisteredSprites = Maps.newHashMap();
-   private final Map<String, TextureAtlasSprite> mapUploadedSprites = Maps.newHashMap();
+   private final List<TextureAtlasSprite> listAnimatedSprites;
+   private final Map<String, TextureAtlasSprite> mapRegisteredSprites;
+   private final Map<String, TextureAtlasSprite> mapUploadedSprites;
    private final String basePath;
    private final ITextureMapPopulator iconCreator;
    private int mipmapLevels;
-   private final TextureAtlasSprite missingImage = new TextureAtlasSprite("missingno");
+   private final TextureAtlasSprite missingImage;
+   private TextureAtlasSprite[] iconGrid = null;
+   private int iconGridSize = -1;
+   private int iconGridCountX = -1;
+   private int iconGridCountY = -1;
+   private double iconGridSizeU = -1.0;
+   private double iconGridSizeV = -1.0;
+   private CounterInt counterIndexInMap = new CounterInt(0);
+   public int atlasWidth = 0;
+   public int atlasHeight = 0;
+   private int countAnimationsActive;
+   private int frameCountAnimations;
 
    public TextureMap(String var1) {
-      this(var1, null);
+      this(var1, (ITextureMapPopulator)null);
+   }
+
+   public TextureMap(String var1, boolean var2) {
+      this(var1, (ITextureMapPopulator)null, var2);
    }
 
    public TextureMap(String var1, @Nullable ITextureMapPopulator var2) {
+      this(var1, var2, false);
+   }
+
+   public TextureMap(String var1, ITextureMapPopulator var2, boolean var3) {
+      this.listAnimatedSprites = Lists.newArrayList();
+      this.mapRegisteredSprites = Maps.newHashMap();
+      this.mapUploadedSprites = Maps.newHashMap();
+      this.missingImage = new TextureAtlasSprite("missingno");
       this.basePath = var1;
       this.iconCreator = var2;
    }
 
    private void initMissingImage() {
-      int[] var1 = TextureUtil.MISSING_TEXTURE_DATA;
-      this.missingImage.setIconWidth(16);
-      this.missingImage.setIconHeight(16);
-      int[][] var2 = new int[this.mipmapLevels + 1][];
-      var2[0] = var1;
-      this.missingImage.setFramesTextureData(Lists.newArrayList(new int[][][]{var2}));
+      int var1 = this.getMinSpriteSize();
+      int[] var2 = this.getMissingImageData(var1);
+      this.missingImage.setIconWidth(var1);
+      this.missingImage.setIconHeight(var1);
+      int[][] var3 = new int[this.mipmapLevels + 1][];
+      var3[0] = var2;
+      this.missingImage.setFramesTextureData(Lists.newArrayList(new int[][][]{var3}));
+      this.missingImage.setIndexInMap(this.counterIndexInMap.nextValue());
    }
 
    @Override
    public void loadTexture(IResourceManager var1) throws IOException {
       if (this.iconCreator != null) {
          this.loadSprites(var1, this.iconCreator);
       }
    }
 
    public void loadSprites(IResourceManager var1, ITextureMapPopulator var2) {
       this.mapRegisteredSprites.clear();
+      this.counterIndexInMap.reset();
+      Reflector.callVoid(Reflector.ForgeHooksClient_onTextureStitchedPre, new Object[]{this});
       var2.registerSprites(this);
+      if (this.mipmapLevels >= 4) {
+         this.mipmapLevels = this.detectMaxMipmapLevel(this.mapRegisteredSprites, var1);
+         Config.log("Mipmap levels: " + this.mipmapLevels);
+      }
+
       this.initMissingImage();
       this.deleteGlTexture();
       this.loadTextureAtlas(var1);
    }
 
    public void loadTextureAtlas(IResourceManager var1) {
-      int var2 = Minecraft.getGLMaximumTextureSize();
-      Stitcher var3 = new Stitcher(var2, var2, 0, this.mipmapLevels);
+      Config.dbg("Multitexture: " + Config.isMultiTexture());
+      if (Config.isMultiTexture()) {
+         for (TextureAtlasSprite var3 : this.mapUploadedSprites.values()) {
+            var3.deleteSpriteTexture();
+         }
+      }
+
+      ConnectedTextures.updateIcons(this);
+      CustomItems.updateIcons(this);
+      BetterGrass.updateIcons(this);
+      int var34 = TextureUtils.getGLMaximumTextureSize();
+      Stitcher var35 = new Stitcher(var34, var34, 0, this.mipmapLevels);
       this.mapUploadedSprites.clear();
       this.listAnimatedSprites.clear();
       int var4 = Integer.MAX_VALUE;
-      int var5 = 1 << this.mipmapLevels;
+      int var5 = this.getMinSpriteSize();
+      this.iconGridSize = var5;
+      int var6 = 1 << this.mipmapLevels;
+      int var7 = 0;
+      int var8 = 0;
+      SpriteDependencies.reset();
+      ArrayList var9 = new ArrayList<>(this.mapRegisteredSprites.values());
+
+      for (int var10 = 0; var10 < var9.size(); var10++) {
+         TextureAtlasSprite var11 = SpriteDependencies.resolveDependencies(var9, var10, this);
+         ResourceLocation var12 = this.getResourceLocation(var11);
+         IResource var13 = null;
+         var11.updateIndexInMap(this.counterIndexInMap);
+         if (var11.hasCustomLoader(var1, var12)) {
+            if (var11.load(var1, var12, var1x -> this.mapRegisteredSprites.get(var1x.toString()))) {
+               Config.detail("Custom loader (skipped): " + var11);
+               var8++;
+               continue;
+            }
 
-      for (Entry var7 : this.mapRegisteredSprites.entrySet()) {
-         TextureAtlasSprite var8 = (TextureAtlasSprite)var7.getValue();
-         ResourceLocation var9 = this.getResourceLocation(var8);
-         IResource var10 = null;
+            Config.detail("Custom loader: " + var11);
+            var7++;
+         } else {
+            try {
+               PngSizeInfo var14 = PngSizeInfo.makeFromResource(var1.getResource(var12));
+               var13 = var1.getResource(var12);
+               boolean var15 = var13.getMetadata("animation") != null;
+               var11.loadSprite(var14, var15);
+            } catch (RuntimeException var31) {
+               LOGGER.error("Unable to parse metadata from {}", var12, var31);
+               ReflectorForge.FMLClientHandler_trackBrokenTexture(var12, var31.getMessage());
+               continue;
+            } catch (IOException var32) {
+               LOGGER.error("Using missing texture, unable to load " + var12 + ", " + var32.getClass().getName());
+               ReflectorForge.FMLClientHandler_trackMissingTexture(var12);
+               continue;
+            } finally {
+               IOUtils.closeQuietly(var13);
+            }
+         }
 
-         try {
-            PngSizeInfo var11 = PngSizeInfo.makeFromResource(var1.getResource(var9));
-            var10 = var1.getResource(var9);
-            boolean var12 = var10.getMetadata("animation") != null;
-            var8.loadSprite(var11, var12);
-         } catch (RuntimeException var22) {
-            LOGGER.error("Unable to parse metadata from {}", var9, var22);
-            continue;
-         } catch (IOException var23) {
-            LOGGER.error("Using missing texture, unable to load {}", var9, var23);
-            continue;
-         } finally {
-            IOUtils.closeQuietly(var10);
-         }
-
-         var4 = Math.min(var4, Math.min(var8.getIconWidth(), var8.getIconHeight()));
-         int var32 = Math.min(Integer.lowestOneBit(var8.getIconWidth()), Integer.lowestOneBit(var8.getIconHeight()));
-         if (var32 < var5) {
-            LOGGER.warn(
-               "Texture {} with size {}x{} limits mip level from {} to {}",
-               var9,
-               var8.getIconWidth(),
-               var8.getIconHeight(),
-               MathHelper.log2(var5),
-               MathHelper.log2(var32)
-            );
-            var5 = var32;
-         }
-
-         var3.addSprite(var8);
-      }
-
-      int var25 = Math.min(var4, var5);
-      int var26 = MathHelper.log2(var25);
-      if (var26 < this.mipmapLevels) {
-         LOGGER.warn("{}: dropping miplevel from {} to {}, because of minimum power of two: {}", this.basePath, this.mipmapLevels, var26, var25);
-         this.mipmapLevels = var26;
+         int var42 = var11.getIconWidth();
+         int var46 = var11.getIconHeight();
+         if (var42 >= 1 && var46 >= 1) {
+            if (var42 < var5 || this.mipmapLevels > 0) {
+               int var16 = this.mipmapLevels > 0 ? TextureUtils.scaleToGrid(var42, var5) : TextureUtils.scaleToMin(var42, var5);
+               if (var16 != var42) {
+                  if (!TextureUtils.isPowerOfTwo(var42)) {
+                     Config.log("Scaled non power of 2: " + var11.getIconName() + ", " + var42 + " -> " + var16);
+                  } else {
+                     Config.log("Scaled too small texture: " + var11.getIconName() + ", " + var42 + " -> " + var16);
+                  }
+
+                  int var17 = var46 * var16 / var42;
+                  var11.setIconWidth(var16);
+                  var11.setIconHeight(var17);
+               }
+            }
+
+            var4 = Math.min(var4, Math.min(var11.getIconWidth(), var11.getIconHeight()));
+            int var49 = Math.min(Integer.lowestOneBit(var11.getIconWidth()), Integer.lowestOneBit(var11.getIconHeight()));
+            if (var49 < var6) {
+               LOGGER.warn(
+                  "Texture {} with size {}x{} limits mip level from {} to {}",
+                  var12,
+                  var11.getIconWidth(),
+                  var11.getIconHeight(),
+                  MathHelper.log2(var6),
+                  MathHelper.log2(var49)
+               );
+               var6 = var49;
+            }
+
+            if (this.generateMipmaps(var1, var11)) {
+               var35.addSprite(var11);
+            }
+         } else {
+            Config.warn("Invalid sprite size: " + var11);
+         }
+      }
+
+      if (var7 > 0) {
+         Config.dbg("Custom loader sprites: " + var7);
+      }
+
+      if (var8 > 0) {
+         Config.dbg("Custom loader sprites (skipped): " + var8);
+      }
+
+      if (SpriteDependencies.getCountDependencies() > 0) {
+         Config.dbg("Sprite dependencies: " + SpriteDependencies.getCountDependencies());
+      }
+
+      int var36 = Math.min(var4, var6);
+      int var37 = MathHelper.log2(var36);
+      if (var37 < 0) {
+         var37 = 0;
+      }
+
+      if (var37 < this.mipmapLevels) {
+         LOGGER.warn("{}: dropping miplevel from {} to {}, because of minimum power of two: {}", this.basePath, this.mipmapLevels, var37, var36);
+         this.mipmapLevels = var37;
       }
 
       this.missingImage.generateMipmaps(this.mipmapLevels);
-      var3.addSprite(this.missingImage);
+      var35.addSprite(this.missingImage);
 
       try {
-         var3.doStitch();
-      } catch (StitcherException var21) {
-         throw var21;
+         var35.doStitch();
+      } catch (StitcherException var30) {
+         throw var30;
       }
 
-      LOGGER.info("Created: {}x{} {}-atlas", var3.getCurrentWidth(), var3.getCurrentHeight(), this.basePath);
-      TextureUtil.allocateTextureImpl(this.getGlTextureId(), this.mipmapLevels, var3.getCurrentWidth(), var3.getCurrentHeight());
-      HashMap var27 = Maps.newHashMap(this.mapRegisteredSprites);
-
-      for (TextureAtlasSprite var30 : var3.getStichSlots()) {
-         if (var30 == this.missingImage || this.generateMipmaps(var1, var30)) {
-            String var33 = var30.getIconName();
-            var27.remove(var33);
-            this.mapUploadedSprites.put(var33, var30);
+      LOGGER.info("Created: {}x{} {}-atlas", var35.getCurrentWidth(), var35.getCurrentHeight(), this.basePath);
+      if (Config.isShaders()) {
+         ShadersTex.allocateTextureMap(this.getGlTextureId(), this.mipmapLevels, var35.getCurrentWidth(), var35.getCurrentHeight(), var35, this);
+      } else {
+         TextureUtil.allocateTextureImpl(this.getGlTextureId(), this.mipmapLevels, var35.getCurrentWidth(), var35.getCurrentHeight());
+      }
 
-            try {
+      HashMap var38 = Maps.newHashMap(this.mapRegisteredSprites);
+
+      for (TextureAtlasSprite var43 : var35.getStichSlots()) {
+         String var47 = var43.getIconName();
+         var38.remove(var47);
+         this.mapUploadedSprites.put(var47, var43);
+
+         try {
+            if (Config.isShaders()) {
+               ShadersTex.uploadTexSubForLoadAtlas(
+                  this,
+                  var43.getIconName(),
+                  var43.getFrameTextureData(0),
+                  var43.getIconWidth(),
+                  var43.getIconHeight(),
+                  var43.getOriginX(),
+                  var43.getOriginY(),
+                  false,
+                  false
+               );
+            } else {
                TextureUtil.uploadTextureMipmap(
-                  var30.getFrameTextureData(0), var30.getIconWidth(), var30.getIconHeight(), var30.getOriginX(), var30.getOriginY(), false, false
+                  var43.getFrameTextureData(0), var43.getIconWidth(), var43.getIconHeight(), var43.getOriginX(), var43.getOriginY(), false, false
                );
-            } catch (Throwable var20) {
-               CrashReport var13 = CrashReport.makeCrashReport(var20, "Stitching texture atlas");
-               CrashReportCategory var14 = var13.makeCategory("Texture being stitched together");
-               var14.addCrashSection("Atlas path", this.basePath);
-               var14.addCrashSection("Sprite", var30);
-               throw new ReportedException(var13);
             }
+         } catch (Throwable var29) {
+            CrashReport var51 = CrashReport.makeCrashReport(var29, "Stitching texture atlas");
+            CrashReportCategory var18 = var51.makeCategory("Texture being stitched together");
+            var18.addCrashSection("Atlas path", this.basePath);
+            var18.addCrashSection("Sprite", var43);
+            throw new ReportedException(var51);
+         }
 
-            if (var30.hasAnimationMetadata()) {
-               this.listAnimatedSprites.add(var30);
+         if (var43.hasAnimationMetadata()) {
+            var43.setAnimationIndex(this.listAnimatedSprites.size());
+            this.listAnimatedSprites.add(var43);
+         }
+      }
+
+      for (TextureAtlasSprite var44 : var38.values()) {
+         var44.copyFrom(this.missingImage);
+      }
+
+      Config.log("Animated sprites: " + this.listAnimatedSprites.size());
+      if (Config.isMultiTexture()) {
+         int var41 = var35.getCurrentWidth();
+         int var45 = var35.getCurrentHeight();
+
+         for (TextureAtlasSprite var52 : var35.getStichSlots()) {
+            var52.sheetWidth = var41;
+            var52.sheetHeight = var45;
+            var52.mipmapLevels = this.mipmapLevels;
+            TextureAtlasSprite var53 = var52.spriteSingle;
+            if (var53 != null) {
+               if (var53.getIconWidth() <= 0) {
+                  var53.setIconWidth(var52.getIconWidth());
+                  var53.setIconHeight(var52.getIconHeight());
+                  var53.initSprite(var52.getIconWidth(), var52.getIconHeight(), 0, 0, false);
+                  var53.clearFramesTextureData();
+                  List var19 = var52.getFramesTextureData();
+                  var53.setFramesTextureData(var19);
+                  var53.setAnimationMetadata(var52.getAnimationMetadata());
+               }
+
+               var53.sheetWidth = var41;
+               var53.sheetHeight = var45;
+               var53.mipmapLevels = this.mipmapLevels;
+               var53.setAnimationIndex(var52.getAnimationIndex());
+               var52.bindSpriteTexture();
+               boolean var54 = false;
+               boolean var20 = true;
+
+               try {
+                  TextureUtil.uploadTextureMipmap(
+                     var53.getFrameTextureData(0), var53.getIconWidth(), var53.getIconHeight(), var53.getOriginX(), var53.getOriginY(), var54, var20
+                  );
+               } catch (Exception var28) {
+                  Config.dbg("Error uploading sprite single: " + var53 + ", parent: " + var52);
+                  var28.printStackTrace();
+               }
             }
          }
+
+         Config.getMinecraft().getTextureManager().bindTexture(LOCATION_BLOCKS_TEXTURE);
       }
 
-      for (TextureAtlasSprite var31 : var27.values()) {
-         var31.copyFrom(this.missingImage);
+      Reflector.callVoid(Reflector.ForgeHooksClient_onTextureStitchedPost, new Object[]{this});
+      this.updateIconGrid(var35.getCurrentWidth(), var35.getCurrentHeight());
+      if (Config.equals(System.getProperty("saveTextureMap"), "true")) {
+         Config.dbg("Exporting texture map: " + this.basePath);
+         TextureUtils.saveGlTexture(
+            "debug/" + this.basePath.replaceAll("/", "_"), this.getGlTextureId(), this.mipmapLevels, var35.getCurrentWidth(), var35.getCurrentHeight()
+         );
       }
    }
 
-   private boolean generateMipmaps(IResourceManager var1, final TextureAtlasSprite var2) {
+   public boolean generateMipmaps(IResourceManager var1, final TextureAtlasSprite var2) {
       ResourceLocation var3 = this.getResourceLocation(var2);
       IResource var4 = null;
+      if (var2.hasCustomLoader(var1, var3)) {
+         TextureUtils.generateCustomMipmaps(var2, this.mipmapLevels);
+      } else {
+         label60: {
+            boolean var7;
+            try {
+               var4 = var1.getResource(var3);
+               var2.loadSpriteFrames(var4, this.mipmapLevels + 1);
+               break label60;
+            } catch (RuntimeException var14) {
+               LOGGER.error("Unable to parse metadata from {}", var3, var14);
+               return false;
+            } catch (IOException var15) {
+               LOGGER.error("Using missing texture, unable to load {}", var3, var15);
+               boolean var5 = false;
+               var7 = var5;
+            } finally {
+               IOUtils.closeQuietly(var4);
+            }
 
-      label45: {
-         boolean var6;
-         try {
-            var4 = var1.getResource(var3);
-            var2.loadSpriteFrames(var4, this.mipmapLevels + 1);
-            break label45;
-         } catch (RuntimeException var13) {
-            LOGGER.error("Unable to parse metadata from {}", var3, var13);
-            return false;
-         } catch (IOException var14) {
-            LOGGER.error("Using missing texture, unable to load {}", var3, var14);
-            var6 = false;
-         } finally {
-            IOUtils.closeQuietly(var4);
+            return var7;
          }
-
-         return var6;
       }
 
       try {
          var2.generateMipmaps(this.mipmapLevels);
          return true;
-      } catch (Throwable var12) {
-         CrashReport var17 = CrashReport.makeCrashReport(var12, "Applying mipmap");
-         CrashReportCategory var7 = var17.makeCategory("Sprite being mipmapped");
-         var7.addDetail("Sprite name", new ICrashReportDetail<String>() {
+      } catch (Throwable var13) {
+         CrashReport var6 = CrashReport.makeCrashReport(var13, "Applying mipmap");
+         CrashReportCategory var18 = var6.makeCategory("Sprite being mipmapped");
+         var18.addDetail("Sprite name", new ICrashReportDetail<String>() {
             public String call() throws Exception {
                return var2.getIconName();
             }
          });
-         var7.addDetail("Sprite size", new ICrashReportDetail<String>() {
+         var18.addDetail("Sprite size", new ICrashReportDetail<String>() {
             public String call() throws Exception {
                return var2.getIconWidth() + " x " + var2.getIconHeight();
             }
          });
-         var7.addDetail("Sprite frames", new ICrashReportDetail<String>() {
+         var18.addDetail("Sprite frames", new ICrashReportDetail<String>() {
             public String call() throws Exception {
                return var2.getFrameCount() + " frames";
             }
          });
-         var7.addCrashSection("Mipmap levels", this.mipmapLevels);
-         throw new ReportedException(var17);
+         var18.addCrashSection("Mipmap levels", this.mipmapLevels);
+         throw new ReportedException(var6);
       }
    }
 
-   private ResourceLocation getResourceLocation(TextureAtlasSprite var1) {
+   public ResourceLocation getResourceLocation(TextureAtlasSprite var1) {
       ResourceLocation var2 = new ResourceLocation(var1.getIconName());
-      return new ResourceLocation(var2.getNamespace(), String.format("%s/%s%s", this.basePath, var2.getPath(), ".png"));
+      return this.completeResourceLocation(var2);
+   }
+
+   public ResourceLocation completeResourceLocation(ResourceLocation var1) {
+      return this.isAbsoluteLocation(var1)
+         ? new ResourceLocation(var1.getNamespace(), var1.getPath() + ".png")
+         : new ResourceLocation(var1.getNamespace(), String.format("%s/%s%s", this.basePath, var1.getPath(), ".png"));
    }
 
    public TextureAtlasSprite getAtlasSprite(String var1) {
       TextureAtlasSprite var2 = this.mapUploadedSprites.get(var1);
       if (var2 == null) {
          var2 = this.missingImage;
       }
 
       return var2;
    }
 
    public void updateAnimations() {
+      boolean var1 = false;
+      boolean var2 = false;
       TextureUtil.bindTexture(this.getGlTextureId());
+      int var3 = 0;
+
+      for (TextureAtlasSprite var5 : this.listAnimatedSprites) {
+         if (this.isTerrainAnimationActive(var5)) {
+            var5.updateAnimation();
+            if (var5.isAnimationActive()) {
+               var3++;
+            }
 
-      for (TextureAtlasSprite var2 : this.listAnimatedSprites) {
-         var2.updateAnimation();
+            if (var5.spriteNormal != null) {
+               var1 = true;
+            }
+
+            if (var5.spriteSpecular != null) {
+               var2 = true;
+            }
+         }
+      }
+
+      if (Config.isMultiTexture()) {
+         for (TextureAtlasSprite var11 : this.listAnimatedSprites) {
+            if (this.isTerrainAnimationActive(var11)) {
+               TextureAtlasSprite var6 = var11.spriteSingle;
+               if (var6 != null) {
+                  if (var11 == TextureUtils.iconClock || var11 == TextureUtils.iconCompass) {
+                     var6.frameCounter = var11.frameCounter;
+                  }
+
+                  var11.bindSpriteTexture();
+                  var6.updateAnimation();
+                  if (var6.isAnimationActive()) {
+                     var3++;
+                  }
+               }
+            }
+         }
+
+         TextureUtil.bindTexture(this.getGlTextureId());
+      }
+
+      if (Config.isShaders()) {
+         if (var1) {
+            TextureUtil.bindTexture(this.getMultiTexID().norm);
+
+            for (TextureAtlasSprite var12 : this.listAnimatedSprites) {
+               if (var12.spriteNormal != null && this.isTerrainAnimationActive(var12)) {
+                  if (var12 == TextureUtils.iconClock || var12 == TextureUtils.iconCompass) {
+                     var12.spriteNormal.frameCounter = var12.frameCounter;
+                  }
+
+                  var12.spriteNormal.updateAnimation();
+                  if (var12.spriteNormal.isAnimationActive()) {
+                     var3++;
+                  }
+               }
+            }
+         }
+
+         if (var2) {
+            TextureUtil.bindTexture(this.getMultiTexID().spec);
+
+            for (TextureAtlasSprite var13 : this.listAnimatedSprites) {
+               if (var13.spriteSpecular != null && this.isTerrainAnimationActive(var13)) {
+                  if (var13 == TextureUtils.iconClock || var13 == TextureUtils.iconCompass) {
+                     var13.spriteNormal.frameCounter = var13.frameCounter;
+                  }
+
+                  var13.spriteSpecular.updateAnimation();
+                  if (var13.spriteSpecular.isAnimationActive()) {
+                     var3++;
+                  }
+               }
+            }
+         }
+
+         if (var1 || var2) {
+            TextureUtil.bindTexture(this.getGlTextureId());
+         }
+      }
+
+      int var10 = Config.getMinecraft().entityRenderer.frameCount;
+      if (var10 != this.frameCountAnimations) {
+         this.countAnimationsActive = var3;
+         this.frameCountAnimations = var10;
+      }
+
+      if (SmartAnimations.isActive()) {
+         SmartAnimations.resetSpritesRendered();
       }
    }
 
    public TextureAtlasSprite registerSprite(ResourceLocation var1) {
       if (var1 == null) {
          throw new IllegalArgumentException("Location cannot be null!");
       } else {
-         TextureAtlasSprite var2 = this.mapRegisteredSprites.get(var1);
+         TextureAtlasSprite var2 = this.mapRegisteredSprites.get(var1.toString());
          if (var2 == null) {
             var2 = TextureAtlasSprite.makeAtlasSprite(var1);
             this.mapRegisteredSprites.put(var1.toString(), var2);
+            var2.updateIndexInMap(this.counterIndexInMap);
+            if (Config.isEmissiveTextures()) {
+               this.checkEmissive(var1, var2);
+            }
          }
 
          return var2;
       }
    }
 
-   @Override
    public void tick() {
       this.updateAnimations();
    }
 
    public void setMipmapLevels(int var1) {
       this.mipmapLevels = var1;
    }
 
    public TextureAtlasSprite getMissingSprite() {
       return this.missingImage;
+   }
+
+   @Nullable
+   public TextureAtlasSprite getTextureExtry(String var1) {
+      return this.mapRegisteredSprites.get(var1);
+   }
+
+   public boolean setTextureEntry(TextureAtlasSprite var1) {
+      String var2 = var1.getIconName();
+      if (!this.mapRegisteredSprites.containsKey(var2)) {
+         this.mapRegisteredSprites.put(var2, var1);
+         var1.updateIndexInMap(this.counterIndexInMap);
+         return true;
+      } else {
+         return false;
+      }
+   }
+
+   public String getBasePath() {
+      return this.basePath;
+   }
+
+   public int getMipmapLevels() {
+      return this.mipmapLevels;
+   }
+
+   private boolean isAbsoluteLocation(ResourceLocation var1) {
+      String var2 = var1.getPath();
+      return this.isAbsoluteLocationPath(var2);
+   }
+
+   private boolean isAbsoluteLocationPath(String var1) {
+      String var2 = var1.toLowerCase();
+      return var2.startsWith("mcpatcher/") || var2.startsWith("optifine/");
+   }
+
+   public TextureAtlasSprite getSpriteSafe(String var1) {
+      ResourceLocation var2 = new ResourceLocation(var1);
+      return this.mapRegisteredSprites.get(var2.toString());
+   }
+
+   public TextureAtlasSprite getRegisteredSprite(ResourceLocation var1) {
+      return this.mapRegisteredSprites.get(var1.toString());
+   }
+
+   private boolean isTerrainAnimationActive(TextureAtlasSprite var1) {
+      if (var1 == TextureUtils.iconWaterStill || var1 == TextureUtils.iconWaterFlow) {
+         return Config.isAnimatedWater();
+      } else if (var1 == TextureUtils.iconLavaStill || var1 == TextureUtils.iconLavaFlow) {
+         return Config.isAnimatedLava();
+      } else if (var1 == TextureUtils.iconFireLayer0 || var1 == TextureUtils.iconFireLayer1) {
+         return Config.isAnimatedFire();
+      } else if (var1 == TextureUtils.iconPortal) {
+         return Config.isAnimatedPortal();
+      } else {
+         return var1 != TextureUtils.iconClock && var1 != TextureUtils.iconCompass ? Config.isAnimatedTerrain() : true;
+      }
+   }
+
+   public int getCountRegisteredSprites() {
+      return this.counterIndexInMap.getValue();
+   }
+
+   private int detectMaxMipmapLevel(Map var1, IResourceManager var2) {
+      int var3 = this.detectMinimumSpriteSize(var1, var2, 20);
+      if (var3 < 16) {
+         var3 = 16;
+      }
+
+      var3 = MathHelper.smallestEncompassingPowerOfTwo(var3);
+      if (var3 > 16) {
+         Config.log("Sprite size: " + var3);
+      }
+
+      int var4 = MathHelper.log2(var3);
+      if (var4 < 4) {
+         var4 = 4;
+      }
+
+      return var4;
+   }
+
+   private int detectMinimumSpriteSize(Map var1, IResourceManager var2, int var3) {
+      HashMap var4 = new HashMap();
+
+      for (Entry var7 : var1.entrySet()) {
+         TextureAtlasSprite var8 = (TextureAtlasSprite)var7.getValue();
+         ResourceLocation var9 = new ResourceLocation(var8.getIconName());
+         ResourceLocation var10 = this.completeResourceLocation(var9);
+         if (!var8.hasCustomLoader(var2, var9)) {
+            try {
+               IResource var11 = var2.getResource(var10);
+               if (var11 != null) {
+                  InputStream var12 = var11.getInputStream();
+                  if (var12 != null) {
+                     Dimension var13 = TextureUtils.getImageSize(var12, "png");
+                     var12.close();
+                     if (var13 != null) {
+                        int var14 = var13.width;
+                        int var15 = MathHelper.smallestEncompassingPowerOfTwo(var14);
+                        if (!var4.containsKey(var15)) {
+                           var4.put(var15, 1);
+                        } else {
+                           int var16 = (Integer)var4.get(var15);
+                           var4.put(var15, var16 + 1);
+                        }
+                     }
+                  }
+               }
+            } catch (Exception var17) {
+            }
+         }
+      }
+
+      int var18 = 0;
+      Set var19 = var4.keySet();
+      TreeSet var20 = new TreeSet(var19);
+
+      for (int var23 : var20) {
+         int var25 = (Integer)var4.get(var23);
+         var18 += var25;
+      }
+
+      int var22 = 16;
+      int var24 = 0;
+      int var26 = var18 * var3 / 100;
+
+      for (int var28 : var20) {
+         int var29 = (Integer)var4.get(var28);
+         var24 += var29;
+         if (var28 > var22) {
+            var22 = var28;
+         }
+
+         if (var24 > var26) {
+            return var22;
+         }
+      }
+
+      return var22;
+   }
+
+   private int getMinSpriteSize() {
+      int var1 = 1 << this.mipmapLevels;
+      if (var1 < 8) {
+         var1 = 8;
+      }
+
+      return var1;
+   }
+
+   private int[] getMissingImageData(int var1) {
+      BufferedImage var2 = new BufferedImage(16, 16, 2);
+      var2.setRGB(0, 0, 16, 16, TextureUtil.MISSING_TEXTURE_DATA, 0, 16);
+      BufferedImage var3 = TextureUtils.scaleImage(var2, var1);
+      int[] var4 = new int[var1 * var1];
+      var3.getRGB(0, 0, var1, var1, var4, 0, var1);
+      return var4;
+   }
+
+   public boolean isTextureBound() {
+      int var1 = GlStateManager.getBoundTexture();
+      int var2 = this.getGlTextureId();
+      return var1 == var2;
+   }
+
+   private void updateIconGrid(int var1, int var2) {
+      this.iconGridCountX = -1;
+      this.iconGridCountY = -1;
+      this.iconGrid = null;
+      if (this.iconGridSize > 0) {
+         this.iconGridCountX = var1 / this.iconGridSize;
+         this.iconGridCountY = var2 / this.iconGridSize;
+         this.iconGrid = new TextureAtlasSprite[this.iconGridCountX * this.iconGridCountY];
+         this.iconGridSizeU = 1.0 / this.iconGridCountX;
+         this.iconGridSizeV = 1.0 / this.iconGridCountY;
+
+         for (TextureAtlasSprite var4 : this.mapUploadedSprites.values()) {
+            double var5 = 0.5 / var1;
+            double var7 = 0.5 / var2;
+            double var9 = Math.min(var4.getMinU(), var4.getMaxU()) + var5;
+            double var11 = Math.min(var4.getMinV(), var4.getMaxV()) + var7;
+            double var13 = Math.max(var4.getMinU(), var4.getMaxU()) - var5;
+            double var15 = Math.max(var4.getMinV(), var4.getMaxV()) - var7;
+            int var17 = (int)(var9 / this.iconGridSizeU);
+            int var18 = (int)(var11 / this.iconGridSizeV);
+            int var19 = (int)(var13 / this.iconGridSizeU);
+            int var20 = (int)(var15 / this.iconGridSizeV);
+
+            for (int var21 = var17; var21 <= var19; var21++) {
+               if (var21 >= 0 && var21 < this.iconGridCountX) {
+                  for (int var22 = var18; var22 <= var20; var22++) {
+                     if (var22 >= 0 && var22 < this.iconGridCountX) {
+                        int var23 = var22 * this.iconGridCountX + var21;
+                        this.iconGrid[var23] = var4;
+                     } else {
+                        Config.warn("Invalid grid V: " + var22 + ", icon: " + var4.getIconName());
+                     }
+                  }
+               } else {
+                  Config.warn("Invalid grid U: " + var21 + ", icon: " + var4.getIconName());
+               }
+            }
+         }
+      }
+   }
+
+   public TextureAtlasSprite getIconByUV(double var1, double var3) {
+      if (this.iconGrid == null) {
+         return null;
+      } else {
+         int var5 = (int)(var1 / this.iconGridSizeU);
+         int var6 = (int)(var3 / this.iconGridSizeV);
+         int var7 = var6 * this.iconGridCountX + var5;
+         return var7 >= 0 && var7 <= this.iconGrid.length ? this.iconGrid[var7] : null;
+      }
+   }
+
+   private void checkEmissive(ResourceLocation var1, TextureAtlasSprite var2) {
+      String var3 = EmissiveTextures.getSuffixEmissive();
+      if (var3 != null) {
+         if (!var1.getPath().endsWith(var3)) {
+            ResourceLocation var4 = new ResourceLocation(var1.getNamespace(), var1.getPath() + var3);
+            ResourceLocation var5 = this.completeResourceLocation(var4);
+            if (Config.hasResource(var5)) {
+               TextureAtlasSprite var6 = this.registerSprite(var4);
+               var6.isEmissive = true;
+               var2.spriteEmissive = var6;
+            }
+         }
+      }
+   }
+
+   public int getCountAnimations() {
+      return this.listAnimatedSprites.size();
+   }
+
+   public int getCountAnimationsActive() {
+      return this.countAnimationsActive;
    }
 }
--- net/minecraft/client/renderer/texture/TextureUtil.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/texture/TextureUtil.java	Mon Aug 18 09:39:52 2025
@@ -9,23 +9,26 @@
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.GLAllocation;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.resources.IResource;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.Mipmaps;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class TextureUtil {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final IntBuffer DATA_BUFFER = GLAllocation.createDirectIntBuffer(4194304);
    public static final DynamicTexture MISSING_TEXTURE = new DynamicTexture(16, 16);
    public static final int[] MISSING_TEXTURE_DATA = MISSING_TEXTURE.getTextureData();
    private static final float[] COLOR_GAMMAS;
    private static final int[] MIPMAP_BUFFER;
+   private static int[] dataArray = new int[4194304];
 
    private static float getColorGamma(int var0) {
       return COLOR_GAMMAS[var0 & 0xFF];
    }
 
    public static int glGenTextures() {
@@ -48,13 +51,13 @@
    public static int[][] generateMipmapData(int var0, int var1, int[][] var2) {
       int[][] var3 = new int[var0 + 1][];
       var3[0] = var2[0];
       if (var0 > 0) {
          boolean var4 = false;
 
-         for (int var5 = 0; var5 < var2.length; var5++) {
+         for (int var5 = 0; var5 < var2[0].length; var5++) {
             if (var2[0][var5] >> 24 == 0) {
                var4 = true;
                break;
             }
          }
 
@@ -81,51 +84,13 @@
       }
 
       return var3;
    }
 
    private static int blendColors(int var0, int var1, int var2, int var3, boolean var4) {
-      if (var4) {
-         MIPMAP_BUFFER[0] = var0;
-         MIPMAP_BUFFER[1] = var1;
-         MIPMAP_BUFFER[2] = var2;
-         MIPMAP_BUFFER[3] = var3;
-         float var13 = 0.0F;
-         float var15 = 0.0F;
-         float var17 = 0.0F;
-         float var19 = 0.0F;
-
-         for (int var9 = 0; var9 < 4; var9++) {
-            if (MIPMAP_BUFFER[var9] >> 24 != 0) {
-               var13 += getColorGamma(MIPMAP_BUFFER[var9] >> 24);
-               var15 += getColorGamma(MIPMAP_BUFFER[var9] >> 16);
-               var17 += getColorGamma(MIPMAP_BUFFER[var9] >> 8);
-               var19 += getColorGamma(MIPMAP_BUFFER[var9] >> 0);
-            }
-         }
-
-         var13 /= 4.0F;
-         var15 /= 4.0F;
-         var17 /= 4.0F;
-         var19 /= 4.0F;
-         int var21 = (int)(Math.pow(var13, 0.45454545454545453) * 255.0);
-         int var10 = (int)(Math.pow(var15, 0.45454545454545453) * 255.0);
-         int var11 = (int)(Math.pow(var17, 0.45454545454545453) * 255.0);
-         int var12 = (int)(Math.pow(var19, 0.45454545454545453) * 255.0);
-         if (var21 < 96) {
-            var21 = 0;
-         }
-
-         return var21 << 24 | var10 << 16 | var11 << 8 | var12;
-      } else {
-         int var5 = blendColorComponent(var0, var1, var2, var3, 24);
-         int var6 = blendColorComponent(var0, var1, var2, var3, 16);
-         int var7 = blendColorComponent(var0, var1, var2, var3, 8);
-         int var8 = blendColorComponent(var0, var1, var2, var3, 0);
-         return var5 << 24 | var6 << 16 | var7 << 8 | var8;
-      }
+      return Mipmaps.alphaBlend(var0, var1, var2, var3);
    }
 
    private static int blendColorComponent(int var0, int var1, int var2, int var3, int var4) {
       float var5 = getColorGamma(var0 >> var4);
       float var6 = getColorGamma(var1 >> var4);
       float var7 = getColorGamma(var2 >> var4);
@@ -142,21 +107,21 @@
    }
 
    private static void uploadTextureSub(int var0, int[] var1, int var2, int var3, int var4, int var5, boolean var6, boolean var7, boolean var8) {
       int var9 = 4194304 / var2;
       setTextureBlurMipmap(var6, var8);
       setTextureClamped(var7);
-      int var10 = 0;
+      int var11 = 0;
 
-      while (var10 < var2 * var3) {
-         int var11 = var10 / var2;
-         int var12 = Math.min(var9, var3 - var11);
-         int var13 = var2 * var12;
-         copyToBufferPos(var1, var10, var13);
-         GlStateManager.glTexSubImage2D(3553, var0, var4, var5 + var11, var2, var12, 32993, 33639, DATA_BUFFER);
-         var10 += var2 * var12;
+      while (var11 < var2 * var3) {
+         int var12 = var11 / var2;
+         int var10 = Math.min(var9, var3 - var12);
+         int var13 = var2 * var10;
+         copyToBufferPos(var1, var11, var13);
+         GlStateManager.glTexSubImage2D(3553, var0, var4, var5 + var12, var2, var10, 32993, 33639, DATA_BUFFER);
+         var11 += var2 * var10;
       }
    }
 
    public static int uploadTextureImageAllocate(int var0, BufferedImage var1, boolean var2, boolean var3) {
       allocateTexture(var0, var1.getWidth(), var1.getHeight());
       return uploadTextureImageSub(var0, var1, 0, 0, var2, var3);
@@ -164,23 +129,31 @@
 
    public static void allocateTexture(int var0, int var1, int var2) {
       allocateTextureImpl(var0, 0, var1, var2);
    }
 
    public static void allocateTextureImpl(int var0, int var1, int var2, int var3) {
-      deleteTexture(var0);
-      bindTexture(var0);
+      Class<TextureUtil> var4 = TextureUtil.class;
+      if (Reflector.SplashScreen.exists()) {
+         var4 = Reflector.SplashScreen.getTargetClass();
+      }
+
+      synchronized (var4) {
+         deleteTexture(var0);
+         bindTexture(var0);
+      }
+
       if (var1 >= 0) {
          GlStateManager.glTexParameteri(3553, 33085, var1);
          GlStateManager.glTexParameteri(3553, 33082, 0);
          GlStateManager.glTexParameteri(3553, 33083, var1);
          GlStateManager.glTexParameterf(3553, 34049, 0.0F);
       }
 
-      for (int var4 = 0; var4 <= var1; var4++) {
-         GlStateManager.glTexImage2D(3553, var4, 6408, var2 >> var4, var3 >> var4, 0, 32993, 33639, null);
+      for (int var5 = 0; var5 <= var1; var5++) {
+         GlStateManager.glTexImage2D(3553, var5, 6408, var2 >> var5, var3 >> var5, 0, 32993, 33639, (IntBuffer)null);
       }
    }
 
    public static int uploadTextureImageSub(int var0, BufferedImage var1, int var2, int var3, boolean var4, boolean var5) {
       bindTexture(var0);
       uploadTextureImageSubImpl(var1, var2, var3, var4, var5);
@@ -188,13 +161,13 @@
    }
 
    private static void uploadTextureImageSubImpl(BufferedImage var0, int var1, int var2, boolean var3, boolean var4) {
       int var5 = var0.getWidth();
       int var6 = var0.getHeight();
       int var7 = 4194304 / var5;
-      int[] var8 = new int[var7 * var5];
+      int[] var8 = dataArray;
       setTextureBlurred(var3);
       setTextureClamped(var4);
 
       for (int var9 = 0; var9 < var5 * var6; var9 += var5 * var7) {
          int var10 = var9 / var5;
          int var11 = Math.min(var7, var6 - var10);
@@ -202,32 +175,33 @@
          var0.getRGB(0, var10, var5, var11, var8, 0, var5);
          copyToBuffer(var8, var12);
          GlStateManager.glTexSubImage2D(3553, 0, var1, var2 + var10, var5, var11, 32993, 33639, DATA_BUFFER);
       }
    }
 
-   private static void setTextureClamped(boolean var0) {
+   public static void setTextureClamped(boolean var0) {
       if (var0) {
-         GlStateManager.glTexParameteri(3553, 10242, 10496);
-         GlStateManager.glTexParameteri(3553, 10243, 10496);
+         GlStateManager.glTexParameteri(3553, 10242, 33071);
+         GlStateManager.glTexParameteri(3553, 10243, 33071);
       } else {
          GlStateManager.glTexParameteri(3553, 10242, 10497);
          GlStateManager.glTexParameteri(3553, 10243, 10497);
       }
    }
 
    private static void setTextureBlurred(boolean var0) {
       setTextureBlurMipmap(var0, false);
    }
 
-   private static void setTextureBlurMipmap(boolean var0, boolean var1) {
+   public static void setTextureBlurMipmap(boolean var0, boolean var1) {
       if (var0) {
          GlStateManager.glTexParameteri(3553, 10241, var1 ? 9987 : 9729);
          GlStateManager.glTexParameteri(3553, 10240, 9729);
       } else {
-         GlStateManager.glTexParameteri(3553, 10241, var1 ? 9986 : 9728);
+         int var2 = Config.getMipmapType();
+         GlStateManager.glTexParameteri(3553, 10241, var1 ? var2 : 9728);
          GlStateManager.glTexParameteri(3553, 10240, 9728);
       }
    }
 
    private static void copyToBuffer(int[] var0, int var1) {
       copyToBufferPos(var0, 0, var1);
@@ -248,37 +222,45 @@
       GlStateManager.bindTexture(var0);
    }
 
    public static int[] readImageData(IResourceManager var0, ResourceLocation var1) throws IOException {
       IResource var2 = null;
 
-      int[] var7;
+      Object var5;
       try {
          var2 = var0.getResource(var1);
-         BufferedImage var3 = readBufferedImage(var2.getInputStream());
-         int var4 = var3.getWidth();
-         int var5 = var3.getHeight();
-         int[] var6 = new int[var4 * var5];
-         var3.getRGB(0, 0, var4, var5, var6, 0, var4);
-         var7 = var6;
+         BufferedImage var4 = readBufferedImage(var2.getInputStream());
+         if (var4 != null) {
+            int var11 = var4.getWidth();
+            int var6 = var4.getHeight();
+            int[] var7 = new int[var11 * var6];
+            var4.getRGB(0, 0, var11, var6, var7, 0, var11);
+            return var7;
+         }
+
+         var5 = null;
       } finally {
          IOUtils.closeQuietly(var2);
       }
 
-      return var7;
+      return (int[])var5;
    }
 
    public static BufferedImage readBufferedImage(InputStream var0) throws IOException {
-      BufferedImage var1;
-      try {
-         var1 = ImageIO.read(var0);
-      } finally {
-         IOUtils.closeQuietly(var0);
-      }
+      if (var0 == null) {
+         return null;
+      } else {
+         BufferedImage var1;
+         try {
+            var1 = ImageIO.read(var0);
+         } finally {
+            IOUtils.closeQuietly(var0);
+         }
 
-      return var1;
+         return var1;
+      }
    }
 
    public static int[] updateAnaglyph(int[] var0) {
       int[] var1 = new int[var0.length];
 
       for (int var2 = 0; var2 < var0.length; var2++) {
--- net/minecraft/client/renderer/tileentity/TileEntityBannerRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityBannerRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityBeaconRenderer.java	Mon Aug 18 09:39:52 2025
@@ -3,36 +3,48 @@
 import java.util.List;
 import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.tileentity.TileEntityBeacon;
+import net.minecraft.tileentity.TileEntityBeacon.BeamSegment;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.shaders.Shaders;
 
 public class TileEntityBeaconRenderer extends TileEntitySpecialRenderer<TileEntityBeacon> {
    public static final ResourceLocation TEXTURE_BEACON_BEAM = new ResourceLocation("textures/entity/beacon_beam.png");
 
    public void render(TileEntityBeacon var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      this.renderBeacon(var2, var4, var6, var8, var1.shouldBeamRender(), var1.getBeamSegments(), var1.getWorld().getTotalWorldTime());
+      this.renderBeacon(var2, var4, var6, var8, var1.shouldBeamRender(), var1.getBeamSegments(), var1.D().getTotalWorldTime());
    }
 
-   public void renderBeacon(double var1, double var3, double var5, double var7, double var9, List<TileEntityBeacon.BeamSegment> var11, double var12) {
-      GlStateManager.alphaFunc(516, 0.1F);
-      this.bindTexture(TEXTURE_BEACON_BEAM);
-      if (var9 > 0.0) {
-         GlStateManager.disableFog();
-         int var14 = 0;
-
-         for (int var15 = 0; var15 < var11.size(); var15++) {
-            TileEntityBeacon.BeamSegment var16 = (TileEntityBeacon.BeamSegment)var11.get(var15);
-            renderBeamSegment(var1, var3, var5, var7, var9, var12, var14, var16.getHeight(), var16.getColors());
-            var14 += var16.getHeight();
+   public void renderBeacon(double var1, double var3, double var5, double var7, double var9, List<BeamSegment> var11, double var12) {
+      if (!(var9 <= 0.0) && var11.size() > 0) {
+         if (Config.isShaders()) {
+            Shaders.beginBeacon();
          }
 
-         GlStateManager.enableFog();
+         GlStateManager.alphaFunc(516, 0.1F);
+         this.bindTexture(TEXTURE_BEACON_BEAM);
+         if (var9 > 0.0) {
+            GlStateManager.disableFog();
+            int var14 = 0;
+
+            for (int var15 = 0; var15 < var11.size(); var15++) {
+               BeamSegment var16 = (BeamSegment)var11.get(var15);
+               renderBeamSegment(var1, var3, var5, var7, var9, var12, var14, var16.getHeight(), var16.getColors());
+               var14 += var16.getHeight();
+            }
+
+            GlStateManager.enableFog();
+         }
+
+         if (Config.isShaders()) {
+            Shaders.endBeacon();
+         }
       }
    }
 
    public static void renderBeamSegment(double var0, double var2, double var4, double var6, double var8, double var10, int var12, int var13, float[] var14) {
       renderBeamSegment(var0, var2, var4, var6, var8, var10, var12, var13, var14, 0.2, 0.25);
    }
@@ -91,12 +103,16 @@
       var20.draw();
       GlStateManager.enableBlend();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.depthMask(false);
+      if (Config.isShaders()) {
+         GlStateManager.depthMask(Shaders.isBeaconBeamDepth());
+      }
+
       var31 = 0.5 - var17;
       var33 = 0.5 - var17;
       var35 = 0.5 + var17;
       var37 = 0.5 - var17;
       var39 = 0.5 - var17;
       var41 = 0.5 + var17;
--- net/minecraft/client/renderer/tileentity/TileEntityBedRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityBedRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityChestRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityChestRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityEnchantmentTableRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityEnchantmentTableRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityEnderChestRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityEnderChestRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityEndGatewayRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityEndGatewayRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityEndPortalRenderer.java	Mon Aug 18 09:39:52 2025
@@ -9,134 +9,137 @@
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.tileentity.TileEntityEndPortal;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.shaders.ShadersRender;
 
 public class TileEntityEndPortalRenderer extends TileEntitySpecialRenderer<TileEntityEndPortal> {
    private static final ResourceLocation END_SKY_TEXTURE = new ResourceLocation("textures/environment/end_sky.png");
    private static final ResourceLocation END_PORTAL_TEXTURE = new ResourceLocation("textures/entity/end_portal.png");
    private static final Random RANDOM = new Random(31100L);
    private static final FloatBuffer MODELVIEW = GLAllocation.createDirectFloatBuffer(16);
    private static final FloatBuffer PROJECTION = GLAllocation.createDirectFloatBuffer(16);
    private final FloatBuffer buffer = GLAllocation.createDirectFloatBuffer(16);
 
    public void render(TileEntityEndPortal var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      GlStateManager.disableLighting();
-      RANDOM.setSeed(31100L);
-      GlStateManager.getFloat(2982, MODELVIEW);
-      GlStateManager.getFloat(2983, PROJECTION);
-      double var11 = var2 * var2 + var4 * var4 + var6 * var6;
-      int var13 = this.getPasses(var11);
-      float var14 = this.getOffset();
-      boolean var15 = false;
-
-      for (int var16 = 0; var16 < var13; var16++) {
-         GlStateManager.pushMatrix();
-         float var17 = 2.0F / (18 - var16);
-         if (var16 == 0) {
+      if (!Config.isShaders() || !ShadersRender.renderEndPortal(var1, var2, var4, var6, var8, var9, this.getOffset())) {
+         GlStateManager.disableLighting();
+         RANDOM.setSeed(31100L);
+         GlStateManager.getFloat(2982, MODELVIEW);
+         GlStateManager.getFloat(2983, PROJECTION);
+         double var11 = var2 * var2 + var4 * var4 + var6 * var6;
+         int var13 = this.getPasses(var11);
+         float var14 = this.getOffset();
+         boolean var15 = false;
+
+         for (int var16 = 0; var16 < var13; var16++) {
+            GlStateManager.pushMatrix();
+            float var17 = 2.0F / (18 - var16);
+            if (var16 == 0) {
+               this.bindTexture(END_SKY_TEXTURE);
+               var17 = 0.15F;
+               GlStateManager.enableBlend();
+               GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+            }
+
+            if (var16 >= 1) {
+               this.bindTexture(END_PORTAL_TEXTURE);
+               var15 = true;
+               Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+            }
+
+            if (var16 == 1) {
+               GlStateManager.enableBlend();
+               GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
+            }
+
+            GlStateManager.texGen(GlStateManager.TexGen.S, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.T, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.R, 9216);
+            GlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));
+            GlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));
+            GlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);
+            GlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5890);
+            GlStateManager.pushMatrix();
+            GlStateManager.loadIdentity();
+            GlStateManager.translate(0.5F, 0.5F, 0.0F);
+            GlStateManager.scale(0.5F, 0.5F, 1.0F);
+            float var18 = var16 + 1;
+            GlStateManager.translate(17.0F / var18, (2.0F + var18 / 1.5F) * ((float)Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);
+            GlStateManager.rotate((var18 * var18 * 4321.0F + var18 * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);
+            GlStateManager.scale(4.5F - var18 / 4.0F, 4.5F - var18 / 4.0F, 1.0F);
+            GlStateManager.multMatrix(PROJECTION);
+            GlStateManager.multMatrix(MODELVIEW);
+            Tessellator var19 = Tessellator.getInstance();
+            BufferBuilder var20 = var19.getBuffer();
+            var20.begin(7, DefaultVertexFormats.POSITION_COLOR);
+            float var21 = (RANDOM.nextFloat() * 0.5F + 0.1F) * var17;
+            float var22 = (RANDOM.nextFloat() * 0.5F + 0.4F) * var17;
+            float var23 = (RANDOM.nextFloat() * 0.5F + 0.5F) * var17;
+            if (var1.shouldRenderFace(EnumFacing.SOUTH)) {
+               var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            if (var1.shouldRenderFace(EnumFacing.NORTH)) {
+               var20.pos(var2, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            if (var1.shouldRenderFace(EnumFacing.EAST)) {
+               var20.pos(var2 + 1.0, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            if (var1.shouldRenderFace(EnumFacing.WEST)) {
+               var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            if (var1.shouldRenderFace(EnumFacing.DOWN)) {
+               var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            if (var1.shouldRenderFace(EnumFacing.UP)) {
+               var20.pos(var2, var4 + var14, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4 + var14, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2 + 1.0, var4 + var14, var6).color(var21, var22, var23, 1.0F).endVertex();
+               var20.pos(var2, var4 + var14, var6).color(var21, var22, var23, 1.0F).endVertex();
+            }
+
+            var19.draw();
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5888);
             this.bindTexture(END_SKY_TEXTURE);
-            var17 = 0.15F;
-            GlStateManager.enableBlend();
-            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
          }
 
-         if (var16 >= 1) {
-            this.bindTexture(END_PORTAL_TEXTURE);
-            var15 = true;
-            Minecraft.getMinecraft().entityRenderer.setupFogColor(true);
+         GlStateManager.disableBlend();
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);
+         GlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);
+         GlStateManager.enableLighting();
+         if (var15) {
+            Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
          }
-
-         if (var16 == 1) {
-            GlStateManager.enableBlend();
-            GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);
-         }
-
-         GlStateManager.texGen(GlStateManager.TexGen.S, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.T, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.R, 9216);
-         GlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));
-         GlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));
-         GlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);
-         GlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);
-         GlStateManager.popMatrix();
-         GlStateManager.matrixMode(5890);
-         GlStateManager.pushMatrix();
-         GlStateManager.loadIdentity();
-         GlStateManager.translate(0.5F, 0.5F, 0.0F);
-         GlStateManager.scale(0.5F, 0.5F, 1.0F);
-         float var18 = var16 + 1;
-         GlStateManager.translate(17.0F / var18, (2.0F + var18 / 1.5F) * ((float)Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);
-         GlStateManager.rotate((var18 * var18 * 4321.0F + var18 * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);
-         GlStateManager.scale(4.5F - var18 / 4.0F, 4.5F - var18 / 4.0F, 1.0F);
-         GlStateManager.multMatrix(PROJECTION);
-         GlStateManager.multMatrix(MODELVIEW);
-         Tessellator var19 = Tessellator.getInstance();
-         BufferBuilder var20 = var19.getBuffer();
-         var20.begin(7, DefaultVertexFormats.POSITION_COLOR);
-         float var21 = (RANDOM.nextFloat() * 0.5F + 0.1F) * var17;
-         float var22 = (RANDOM.nextFloat() * 0.5F + 0.4F) * var17;
-         float var23 = (RANDOM.nextFloat() * 0.5F + 0.5F) * var17;
-         if (var1.shouldRenderFace(EnumFacing.SOUTH)) {
-            var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         if (var1.shouldRenderFace(EnumFacing.NORTH)) {
-            var20.pos(var2, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         if (var1.shouldRenderFace(EnumFacing.EAST)) {
-            var20.pos(var2 + 1.0, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         if (var1.shouldRenderFace(EnumFacing.WEST)) {
-            var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4 + 1.0, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4 + 1.0, var6).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         if (var1.shouldRenderFace(EnumFacing.DOWN)) {
-            var20.pos(var2, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         if (var1.shouldRenderFace(EnumFacing.UP)) {
-            var20.pos(var2, var4 + var14, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4 + var14, var6 + 1.0).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2 + 1.0, var4 + var14, var6).color(var21, var22, var23, 1.0F).endVertex();
-            var20.pos(var2, var4 + var14, var6).color(var21, var22, var23, 1.0F).endVertex();
-         }
-
-         var19.draw();
-         GlStateManager.popMatrix();
-         GlStateManager.matrixMode(5888);
-         this.bindTexture(END_SKY_TEXTURE);
-      }
-
-      GlStateManager.disableBlend();
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);
-      GlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);
-      GlStateManager.enableLighting();
-      if (var15) {
-         Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
       }
    }
 
    protected int getPasses(double var1) {
       byte var3;
       if (var1 > 36864.0) {
--- net/minecraft/client/renderer/tileentity/TileEntityItemStackRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityItemStackRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityMobSpawnerRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityMobSpawnerRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityPistonRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityPistonRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityRendererDispatcher.java	Mon Aug 18 09:39:52 2025
@@ -1,17 +1,21 @@
 package net.minecraft.client.renderer.tileentity;
 
 import com.google.common.collect.Maps;
 import java.util.Map;
 import javax.annotation.Nullable;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.model.ModelShulker;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.RenderHelper;
+import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.texture.TextureManager;
+import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.tileentity.TileEntityBanner;
 import net.minecraft.tileentity.TileEntityBeacon;
@@ -27,30 +31,36 @@
 import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.tileentity.TileEntitySkull;
 import net.minecraft.tileentity.TileEntityStructure;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.RayTraceResult;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.World;
+import net.optifine.EmissiveTextures;
+import net.optifine.reflect.Reflector;
 
 public class TileEntityRendererDispatcher {
-   private final Map<Class<? extends TileEntity>, TileEntitySpecialRenderer<? extends TileEntity>> renderers = Maps.newHashMap();
+   public final Map<Class<? extends TileEntity>, TileEntitySpecialRenderer<? extends TileEntity>> renderers = Maps.newHashMap();
    public static TileEntityRendererDispatcher instance = new TileEntityRendererDispatcher();
-   private FontRenderer fontRenderer;
+   public FontRenderer fontRenderer;
    public static double staticPlayerX;
    public static double staticPlayerY;
    public static double staticPlayerZ;
    public TextureManager renderEngine;
    public World world;
    public Entity entity;
    public float entityYaw;
    public float entityPitch;
    public RayTraceResult cameraHitResult;
    public double entityX;
    public double entityY;
    public double entityZ;
+   public TileEntity tileEntityRendered;
+   private Tessellator batchBuffer = new Tessellator(2097152);
+   private boolean drawingBatch = false;
 
    private TileEntityRendererDispatcher() {
       this.renderers.put(TileEntitySign.class, new TileEntitySignRenderer());
       this.renderers.put(TileEntityMobSpawner.class, new TileEntityMobSpawnerRenderer());
       this.renderers.put(TileEntityPiston.class, new TileEntityPistonRenderer());
       this.renderers.put(TileEntityChest.class, new TileEntityChestRenderer());
@@ -79,13 +89,13 @@
 
       return var2;
    }
 
    @Nullable
    public <T extends TileEntity> TileEntitySpecialRenderer<T> getRenderer(@Nullable TileEntity var1) {
-      return var1 == null ? null : this.getRenderer((Class<? extends TileEntity>)var1.getClass());
+      return var1 != null && !var1.isInvalid() ? this.getRenderer((Class<? extends TileEntity>)var1.getClass()) : null;
    }
 
    public void prepare(World var1, TextureManager var2, FontRenderer var3, Entity var4, RayTraceResult var5, float var6) {
       if (this.world != var1) {
          this.setWorld(var1);
       }
@@ -100,20 +110,45 @@
       this.entityY = var4.lastTickPosY + (var4.posY - var4.lastTickPosY) * var6;
       this.entityZ = var4.lastTickPosZ + (var4.posZ - var4.lastTickPosZ) * var6;
    }
 
    public void render(TileEntity var1, float var2, int var3) {
       if (var1.getDistanceSq(this.entityX, this.entityY, this.entityZ) < var1.getMaxRenderDistanceSquared()) {
-         RenderHelper.enableStandardItemLighting();
-         int var4 = this.world.getCombinedLight(var1.getPos(), 0);
-         int var5 = var4 % 65536;
-         int var6 = var4 / 65536;
-         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var5, var6);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         BlockPos var7 = var1.getPos();
-         this.render(var1, var7.getX() - staticPlayerX, var7.getY() - staticPlayerY, var7.getZ() - staticPlayerZ, var2, var3, 1.0F);
+         boolean var4 = true;
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            var4 = !this.drawingBatch || !Reflector.callBoolean(var1, Reflector.ForgeTileEntity_hasFastRenderer, new Object[0]);
+         }
+
+         if (var4) {
+            RenderHelper.enableStandardItemLighting();
+            int var5 = this.world.getCombinedLight(var1.getPos(), 0);
+            int var6 = var5 % 65536;
+            int var7 = var5 / 65536;
+            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var6, var7);
+            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         }
+
+         BlockPos var8 = var1.getPos();
+         if (!this.world.isBlockLoaded(var8, false)) {
+            return;
+         }
+
+         if (EmissiveTextures.isActive()) {
+            EmissiveTextures.beginRender();
+         }
+
+         this.render(var1, var8.getX() - staticPlayerX, var8.getY() - staticPlayerY, var8.getZ() - staticPlayerZ, var2, var3, 1.0F);
+         if (EmissiveTextures.isActive()) {
+            if (EmissiveTextures.hasEmissive()) {
+               EmissiveTextures.beginRenderEmissive();
+               this.render(var1, var8.getX() - staticPlayerX, var8.getY() - staticPlayerY, var8.getZ() - staticPlayerZ, var2, var3, 1.0F);
+               EmissiveTextures.endRenderEmissive();
+            }
+
+            EmissiveTextures.endRender();
+         }
       }
    }
 
    public void render(TileEntity var1, double var2, double var4, double var6, float var8) {
       this.render(var1, var2, var4, var6, var8, 1.0F);
    }
@@ -123,13 +158,20 @@
    }
 
    public void render(TileEntity var1, double var2, double var4, double var6, float var8, int var9, float var10) {
       TileEntitySpecialRenderer var11 = this.getRenderer(var1);
       if (var11 != null) {
          try {
-            var11.render(var1, var2, var4, var6, var8, var9, var10);
+            this.tileEntityRendered = var1;
+            if (this.drawingBatch && Reflector.callBoolean(var1, Reflector.ForgeTileEntity_hasFastRenderer, new Object[0])) {
+               var11.renderTileEntityFast(var1, var2, var4, var6, var8, var9, var10, this.batchBuffer.getBuffer());
+            } else {
+               var11.render(var1, var2, var4, var6, var8, var9, var10);
+            }
+
+            this.tileEntityRendered = null;
          } catch (Throwable var15) {
             CrashReport var13 = CrashReport.makeCrashReport(var15, "Rendering Block Entity");
             CrashReportCategory var14 = var13.makeCategory("Block Entity Details");
             var1.addInfoToCrashReport(var14);
             throw new ReportedException(var13);
          }
@@ -142,8 +184,39 @@
          this.entity = null;
       }
    }
 
    public FontRenderer getFontRenderer() {
       return this.fontRenderer;
+   }
+
+   public void preDrawBatch() {
+      this.batchBuffer.getBuffer().begin(7, DefaultVertexFormats.BLOCK);
+      this.drawingBatch = true;
+   }
+
+   public void drawBatch(int var1) {
+      this.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+      RenderHelper.disableStandardItemLighting();
+      GlStateManager.blendFunc(770, 771);
+      GlStateManager.enableBlend();
+      GlStateManager.disableCull();
+      if (Minecraft.isAmbientOcclusionEnabled()) {
+         GlStateManager.shadeModel(7425);
+      } else {
+         GlStateManager.shadeModel(7424);
+      }
+
+      if (var1 > 0) {
+         Vec3d var2 = (Vec3d)Reflector.call(Reflector.ActiveRenderInfo_getCameraPosition, new Object[0]);
+         if (var2 != null) {
+            this.batchBuffer.getBuffer().sortVertexData((float)var2.x, (float)var2.y, (float)var2.z);
+         } else {
+            this.batchBuffer.getBuffer().sortVertexData(0.0F, 0.0F, 0.0F);
+         }
+      }
+
+      this.batchBuffer.draw();
+      RenderHelper.enableStandardItemLighting();
+      this.drawingBatch = false;
    }
 }
--- net/minecraft/client/renderer/tileentity/TileEntityShulkerBoxRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityShulkerBoxRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntitySignRenderer.java	Mon Aug 18 09:39:52 2025
@@ -1,34 +1,39 @@
 package net.minecraft.client.renderer.tileentity;
 
 import java.util.List;
 import net.minecraft.block.Block;
+import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.gui.GuiUtilRenderComponents;
 import net.minecraft.client.model.ModelSign;
 import net.minecraft.client.renderer.GlStateManager;
+import net.minecraft.entity.Entity;
 import net.minecraft.init.Blocks;
 import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.text.ITextComponent;
+import net.optifine.CustomColors;
+import net.optifine.shaders.Shaders;
 
 public class TileEntitySignRenderer extends TileEntitySpecialRenderer<TileEntitySign> {
    private static final ResourceLocation SIGN_TEXTURE = new ResourceLocation("textures/entity/sign.png");
    private final ModelSign model = new ModelSign();
+   private static double textRenderDistanceSq = 4096.0;
 
    public void render(TileEntitySign var1, double var2, double var4, double var6, float var8, int var9, float var10) {
-      Block var11 = var1.getBlockType();
+      Block var11 = var1.x();
       GlStateManager.pushMatrix();
       float var12 = 0.6666667F;
       if (var11 == Blocks.STANDING_SIGN) {
          GlStateManager.translate((float)var2 + 0.5F, (float)var4 + 0.5F, (float)var6 + 0.5F);
-         float var13 = var1.getBlockMetadata() * 360 / 16.0F;
+         float var13 = var1.v() * 360 / 16.0F;
          GlStateManager.rotate(-var13, 0.0F, 1.0F, 0.0F);
          this.model.signStick.showModel = true;
       } else {
-         int var20 = var1.getBlockMetadata();
+         int var20 = var1.v();
          float var14 = 0.0F;
          if (var20 == 2) {
             var14 = 180.0F;
          }
 
          if (var20 == 4) {
@@ -58,30 +63,36 @@
 
       GlStateManager.enableRescaleNormal();
       GlStateManager.pushMatrix();
       GlStateManager.scale(0.6666667F, -0.6666667F, -0.6666667F);
       this.model.renderSign();
       GlStateManager.popMatrix();
-      FontRenderer var21 = this.getFontRenderer();
-      float var22 = 0.010416667F;
-      GlStateManager.translate(0.0F, 0.33333334F, 0.046666667F);
-      GlStateManager.scale(0.010416667F, -0.010416667F, 0.010416667F);
-      GlStateManager.glNormal3f(0.0F, 0.0F, -0.010416667F);
-      GlStateManager.depthMask(false);
-      boolean var15 = false;
-      if (var9 < 0) {
-         for (int var16 = 0; var16 < var1.signText.length; var16++) {
-            if (var1.signText[var16] != null) {
-               ITextComponent var17 = var1.signText[var16];
-               List var18 = GuiUtilRenderComponents.splitText(var17, 90, var21, false, true);
-               String var19 = var18 != null && !var18.isEmpty() ? ((ITextComponent)var18.get(0)).getFormattedText() : "";
-               if (var16 == var1.lineBeingEdited) {
-                  var19 = "> " + var19 + " <";
-                  var21.drawString(var19, -var21.getStringWidth(var19) / 2, var16 * 10 - var1.signText.length * 5, 0);
-               } else {
-                  var21.drawString(var19, -var21.getStringWidth(var19) / 2, var16 * 10 - var1.signText.length * 5, 0);
+      if (isRenderText(var1)) {
+         FontRenderer var21 = this.getFontRenderer();
+         float var22 = 0.010416667F;
+         GlStateManager.translate(0.0F, 0.33333334F, 0.046666667F);
+         GlStateManager.scale(0.010416667F, -0.010416667F, 0.010416667F);
+         GlStateManager.glNormal3f(0.0F, 0.0F, -0.010416667F);
+         GlStateManager.depthMask(false);
+         int var15 = 0;
+         if (Config.isCustomColors()) {
+            var15 = CustomColors.getSignTextColor(var15);
+         }
+
+         if (var9 < 0) {
+            for (int var16 = 0; var16 < var1.signText.length; var16++) {
+               if (var1.signText[var16] != null) {
+                  ITextComponent var17 = var1.signText[var16];
+                  List var18 = GuiUtilRenderComponents.splitText(var17, 90, var21, false, true);
+                  String var19 = var18 != null && !var18.isEmpty() ? ((ITextComponent)var18.get(0)).getFormattedText() : "";
+                  if (var16 == var1.lineBeingEdited) {
+                     var19 = "> " + var19 + " <";
+                     var21.drawString(var19, -var21.getStringWidth(var19) / 2, var16 * 10 - var1.signText.length * 5, var15);
+                  } else {
+                     var21.drawString(var19, -var21.getStringWidth(var19) / 2, var16 * 10 - var1.signText.length * 5, var15);
+                  }
                }
             }
          }
       }
 
       GlStateManager.depthMask(true);
@@ -89,8 +100,31 @@
       GlStateManager.popMatrix();
       if (var9 >= 0) {
          GlStateManager.matrixMode(5890);
          GlStateManager.popMatrix();
          GlStateManager.matrixMode(5888);
       }
+   }
+
+   private static boolean isRenderText(TileEntitySign var0) {
+      if (Shaders.isShadowPass) {
+         return false;
+      } else {
+         if (!Config.zoomMode && var0.lineBeingEdited < 0) {
+            Entity var1 = Config.getMinecraft().getRenderViewEntity();
+            double var2 = var0.a(var1.posX, var1.posY, var1.posZ);
+            if (var2 > textRenderDistanceSq) {
+               return false;
+            }
+         }
+
+         return true;
+      }
+   }
+
+   public static void updateTextRenderDistance() {
+      Minecraft var0 = Config.getMinecraft();
+      double var1 = Config.limit(var0.gameSettings.fovSetting, 1.0F, 120.0F);
+      double var3 = Math.max(1.5 * var0.displayHeight / var1, 16.0);
+      textRenderDistanceSq = var3 * var3;
    }
 }
--- net/minecraft/client/renderer/tileentity/TileEntitySkullRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntitySkullRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntitySpecialRenderer.java	Mon Aug 18 09:39:52 2025
@@ -1,20 +1,22 @@
 package net.minecraft.client.renderer.tileentity;
 
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.renderer.BufferBuilder;
 import net.minecraft.client.renderer.EntityRenderer;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.entity.Entity;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.world.World;
+import net.optifine.entity.model.IEntityRenderer;
 
-public abstract class TileEntitySpecialRenderer<T extends TileEntity> {
+public abstract class TileEntitySpecialRenderer<T extends TileEntity> implements IEntityRenderer {
    protected static final ResourceLocation[] DESTROY_STAGES = new ResourceLocation[]{
       new ResourceLocation("textures/blocks/destroy_stage_0.png"),
       new ResourceLocation("textures/blocks/destroy_stage_1.png"),
       new ResourceLocation("textures/blocks/destroy_stage_2.png"),
       new ResourceLocation("textures/blocks/destroy_stage_3.png"),
       new ResourceLocation("textures/blocks/destroy_stage_4.png"),
@@ -22,12 +24,14 @@
       new ResourceLocation("textures/blocks/destroy_stage_6.png"),
       new ResourceLocation("textures/blocks/destroy_stage_7.png"),
       new ResourceLocation("textures/blocks/destroy_stage_8.png"),
       new ResourceLocation("textures/blocks/destroy_stage_9.png")
    };
    protected TileEntityRendererDispatcher rendererDispatcher;
+   private Class tileEntityClass = null;
+   private ResourceLocation locationTextureCustom = null;
 
    public void render(T var1, double var2, double var4, double var6, float var8, int var9, float var10) {
       ITextComponent var11 = var1.getDisplayName();
       if (var11 != null && this.rendererDispatcher.cameraHitResult != null && var1.getPos().equals(this.rendererDispatcher.cameraHitResult.getBlockPos())) {
          this.setLightmapDisabled(true);
          this.drawNameplate((T)var1, var11.getFormattedText(), var2, var4, var6, 12);
@@ -69,14 +73,33 @@
       return false;
    }
 
    protected void drawNameplate(T var1, String var2, double var3, double var5, double var7, int var9) {
       Entity var10 = this.rendererDispatcher.entity;
       double var11 = var1.getDistanceSq(var10.posX, var10.posY, var10.posZ);
-      if (!(var11 > var9 * var9)) {
+      if (var11 <= var9 * var9) {
          float var13 = this.rendererDispatcher.entityYaw;
          float var14 = this.rendererDispatcher.entityPitch;
          boolean var15 = false;
          EntityRenderer.drawNameplate(this.getFontRenderer(), var2, (float)var3 + 0.5F, (float)var5 + 1.5F, (float)var7 + 0.5F, 0, var13, var14, false, false);
       }
+   }
+
+   public void renderTileEntityFast(T var1, double var2, double var4, double var6, float var8, int var9, float var10, BufferBuilder var11) {
+   }
+
+   public Class getEntityClass() {
+      return this.tileEntityClass;
+   }
+
+   public void setEntityClass(Class var1) {
+      this.tileEntityClass = var1;
+   }
+
+   public ResourceLocation getLocationTextureCustom() {
+      return this.locationTextureCustom;
+   }
+
+   public void setLocationTextureCustom(ResourceLocation var1) {
+      this.locationTextureCustom = var1;
    }
 }
--- net/minecraft/client/renderer/tileentity/TileEntityStructureRenderer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/tileentity/TileEntityStructureRenderer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/vertex/DefaultVertexFormats.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/vertex/DefaultVertexFormats.java	Mon Aug 18 09:39:52 2025
@@ -1,29 +1,65 @@
 package net.minecraft.client.renderer.vertex;
 
+import java.lang.reflect.Field;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumType;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.optifine.reflect.ReflectorClass;
+import net.optifine.reflect.ReflectorField;
+import net.optifine.shaders.SVertexFormat;
+
 public class DefaultVertexFormats {
-   public static final VertexFormat BLOCK = new VertexFormat();
-   public static final VertexFormat ITEM = new VertexFormat();
+   public static VertexFormat BLOCK = new VertexFormat();
+   public static VertexFormat ITEM = new VertexFormat();
+   private static final VertexFormat BLOCK_VANILLA = BLOCK;
+   private static final VertexFormat ITEM_VANILLA = ITEM;
+   public static ReflectorClass Attributes = new ReflectorClass("net.minecraftforge.client.model.Attributes");
+   public static ReflectorField Attributes_DEFAULT_BAKED_FORMAT = new ReflectorField(Attributes, "DEFAULT_BAKED_FORMAT");
+   private static final VertexFormat FORGE_BAKED = SVertexFormat.duplicate((VertexFormat)getFieldValue(Attributes_DEFAULT_BAKED_FORMAT));
    public static final VertexFormat OLDMODEL_POSITION_TEX_NORMAL = new VertexFormat();
    public static final VertexFormat PARTICLE_POSITION_TEX_COLOR_LMAP = new VertexFormat();
    public static final VertexFormat POSITION = new VertexFormat();
    public static final VertexFormat POSITION_COLOR = new VertexFormat();
    public static final VertexFormat POSITION_TEX = new VertexFormat();
    public static final VertexFormat POSITION_NORMAL = new VertexFormat();
    public static final VertexFormat POSITION_TEX_COLOR = new VertexFormat();
    public static final VertexFormat POSITION_TEX_NORMAL = new VertexFormat();
    public static final VertexFormat POSITION_TEX_LMAP_COLOR = new VertexFormat();
    public static final VertexFormat POSITION_TEX_COLOR_NORMAL = new VertexFormat();
-   public static final VertexFormatElement POSITION_3F = new VertexFormatElement(
-      0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.POSITION, 3
-   );
-   public static final VertexFormatElement COLOR_4UB = new VertexFormatElement(0, VertexFormatElement.EnumType.UBYTE, VertexFormatElement.EnumUsage.COLOR, 4);
-   public static final VertexFormatElement TEX_2F = new VertexFormatElement(0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.UV, 2);
-   public static final VertexFormatElement TEX_2S = new VertexFormatElement(1, VertexFormatElement.EnumType.SHORT, VertexFormatElement.EnumUsage.UV, 2);
-   public static final VertexFormatElement NORMAL_3B = new VertexFormatElement(0, VertexFormatElement.EnumType.BYTE, VertexFormatElement.EnumUsage.NORMAL, 3);
-   public static final VertexFormatElement PADDING_1B = new VertexFormatElement(0, VertexFormatElement.EnumType.BYTE, VertexFormatElement.EnumUsage.PADDING, 1);
+   public static final VertexFormatElement POSITION_3F = new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.POSITION, 3);
+   public static final VertexFormatElement COLOR_4UB = new VertexFormatElement(0, EnumType.UBYTE, EnumUsage.COLOR, 4);
+   public static final VertexFormatElement TEX_2F = new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.UV, 2);
+   public static final VertexFormatElement TEX_2S = new VertexFormatElement(1, EnumType.SHORT, EnumUsage.UV, 2);
+   public static final VertexFormatElement NORMAL_3B = new VertexFormatElement(0, EnumType.BYTE, EnumUsage.NORMAL, 3);
+   public static final VertexFormatElement PADDING_1B = new VertexFormatElement(0, EnumType.BYTE, EnumUsage.PADDING, 1);
+
+   public static void updateVertexFormats() {
+      if (Config.isShaders()) {
+         BLOCK = SVertexFormat.makeDefVertexFormatBlock();
+         ITEM = SVertexFormat.makeDefVertexFormatItem();
+         if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
+            SVertexFormat.setDefBakedFormat((VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue());
+         }
+      } else {
+         BLOCK = BLOCK_VANILLA;
+         ITEM = ITEM_VANILLA;
+         if (Attributes_DEFAULT_BAKED_FORMAT.exists()) {
+            SVertexFormat.copy(FORGE_BAKED, (VertexFormat)Attributes_DEFAULT_BAKED_FORMAT.getValue());
+         }
+      }
+   }
+
+   public static Object getFieldValue(ReflectorField var0) {
+      try {
+         Field var1 = var0.getTargetField();
+         return var1 == null ? null : var1.get(null);
+      } catch (Throwable var3) {
+         var3.printStackTrace();
+         return null;
+      }
+   }
 
    static {
       BLOCK.addElement(POSITION_3F);
       BLOCK.addElement(COLOR_4UB);
       BLOCK.addElement(TEX_2F);
       BLOCK.addElement(TEX_2S);
--- net/minecraft/client/renderer/vertex/VertexBuffer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/vertex/VertexBuffer.java	Mon Aug 18 09:39:52 2025
@@ -1,42 +1,83 @@
 package net.minecraft.client.renderer.vertex;
 
 import java.nio.ByteBuffer;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
+import net.optifine.render.VboRange;
+import net.optifine.render.VboRegion;
 
 public class VertexBuffer {
    private int glBufferId;
    private final VertexFormat vertexFormat;
    private int count;
+   private VboRegion vboRegion;
+   private VboRange vboRange;
+   private int drawMode;
 
    public VertexBuffer(VertexFormat var1) {
       this.vertexFormat = var1;
       this.glBufferId = OpenGlHelper.glGenBuffers();
    }
 
    public void bindBuffer() {
       OpenGlHelper.glBindBuffer(OpenGlHelper.GL_ARRAY_BUFFER, this.glBufferId);
    }
 
    public void bufferData(ByteBuffer var1) {
-      this.bindBuffer();
-      OpenGlHelper.glBufferData(OpenGlHelper.GL_ARRAY_BUFFER, var1, 35044);
-      this.unbindBuffer();
-      this.count = var1.limit() / this.vertexFormat.getSize();
+      if (this.vboRegion != null) {
+         this.vboRegion.bufferData(var1, this.vboRange);
+      } else {
+         this.bindBuffer();
+         OpenGlHelper.glBufferData(OpenGlHelper.GL_ARRAY_BUFFER, var1, 35044);
+         this.unbindBuffer();
+         this.count = var1.limit() / this.vertexFormat.getSize();
+      }
    }
 
    public void drawArrays(int var1) {
-      GlStateManager.glDrawArrays(var1, 0, this.count);
+      if (this.drawMode > 0) {
+         var1 = this.drawMode;
+      }
+
+      if (this.vboRegion != null) {
+         this.vboRegion.drawArrays(var1, this.vboRange);
+      } else {
+         GlStateManager.glDrawArrays(var1, 0, this.count);
+      }
    }
 
    public void unbindBuffer() {
       OpenGlHelper.glBindBuffer(OpenGlHelper.GL_ARRAY_BUFFER, 0);
    }
 
    public void deleteGlBuffers() {
       if (this.glBufferId >= 0) {
          OpenGlHelper.glDeleteBuffers(this.glBufferId);
          this.glBufferId = -1;
       }
+   }
+
+   public void setVboRegion(VboRegion var1) {
+      if (var1 != null) {
+         this.deleteGlBuffers();
+         this.vboRegion = var1;
+         this.vboRange = new VboRange();
+      }
+   }
+
+   public VboRegion getVboRegion() {
+      return this.vboRegion;
+   }
+
+   public VboRange getVboRange() {
+      return this.vboRange;
+   }
+
+   public int getDrawMode() {
+      return this.drawMode;
+   }
+
+   public void setDrawMode(int var1) {
+      this.drawMode = var1;
    }
 }
--- net/minecraft/client/renderer/vertex/VertexFormat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/vertex/VertexFormat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/vertex/VertexFormatElement.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/renderer/vertex/VertexFormatElement.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/renderer/ActiveRenderInfo.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ActiveRenderInfo.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/BannerTextures.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BannerTextures.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/BlockFluidRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BlockFluidRenderer.java	Mon Aug 18 09:39:52 2025
@@ -1,21 +1,27 @@
 package net.minecraft.client.renderer;
 
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockLiquid;
+import net.minecraft.block.BlockSlab;
+import net.minecraft.block.BlockSlab.EnumBlockHalf;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.block.model.FaceBakery;
 import net.minecraft.client.renderer.color.BlockColors;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.init.Blocks;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.IBlockAccess;
+import net.optifine.CustomColors;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
 
 public class BlockFluidRenderer {
    private final BlockColors blockColors;
    private final TextureAtlasSprite[] atlasSpritesLava = new TextureAtlasSprite[2];
    private final TextureAtlasSprite[] atlasSpritesWater = new TextureAtlasSprite[2];
    private TextureAtlasSprite atlasSpriteWaterOverlay;
@@ -32,234 +38,297 @@
       this.atlasSpritesWater[0] = var1.getAtlasSprite("minecraft:blocks/water_still");
       this.atlasSpritesWater[1] = var1.getAtlasSprite("minecraft:blocks/water_flow");
       this.atlasSpriteWaterOverlay = var1.getAtlasSprite("minecraft:blocks/water_overlay");
    }
 
    public boolean renderFluid(IBlockAccess var1, IBlockState var2, BlockPos var3, BufferBuilder var4) {
-      BlockLiquid var5 = (BlockLiquid)var2.getBlock();
-      boolean var6 = var2.getMaterial() == Material.LAVA;
-      TextureAtlasSprite[] var7 = var6 ? this.atlasSpritesLava : this.atlasSpritesWater;
-      int var8 = this.blockColors.colorMultiplier(var2, var1, var3, 0);
-      float var9 = (var8 >> 16 & 0xFF) / 255.0F;
-      float var10 = (var8 >> 8 & 0xFF) / 255.0F;
-      float var11 = (var8 & 0xFF) / 255.0F;
-      boolean var12 = var2.shouldSideBeRendered(var1, var3, EnumFacing.UP);
-      boolean var13 = var2.shouldSideBeRendered(var1, var3, EnumFacing.DOWN);
-      boolean[] var14 = new boolean[]{
-         var2.shouldSideBeRendered(var1, var3, EnumFacing.NORTH),
-         var2.shouldSideBeRendered(var1, var3, EnumFacing.SOUTH),
-         var2.shouldSideBeRendered(var1, var3, EnumFacing.WEST),
-         var2.shouldSideBeRendered(var1, var3, EnumFacing.EAST)
-      };
-      if (!var12 && !var13 && !var14[0] && !var14[1] && !var14[2] && !var14[3]) {
-         return false;
-      } else {
-         boolean var15 = false;
-         float var16 = 0.5F;
-         float var17 = 1.0F;
-         float var18 = 0.8F;
-         float var19 = 0.6F;
-         Material var20 = var2.getMaterial();
-         float var21 = this.getFluidHeight(var1, var3, var20);
-         float var22 = this.getFluidHeight(var1, var3.south(), var20);
-         float var23 = this.getFluidHeight(var1, var3.east().south(), var20);
-         float var24 = this.getFluidHeight(var1, var3.east(), var20);
-         double var25 = var3.getX();
-         double var27 = var3.getY();
-         double var29 = var3.getZ();
-         float var31 = 0.001F;
-         if (var12) {
-            var15 = true;
-            float var32 = BlockLiquid.getSlopeAngle(var1, var3, var20, var2);
-            TextureAtlasSprite var33 = var32 > -999.0F ? var7[1] : var7[0];
-            var21 -= 0.001F;
-            var22 -= 0.001F;
-            var23 -= 0.001F;
-            var24 -= 0.001F;
-            float var34;
-            float var35;
-            float var36;
-            float var37;
-            float var38;
-            float var39;
-            float var40;
-            float var41;
-            if (var32 < -999.0F) {
-               var34 = var33.getInterpolatedU(0.0);
-               var38 = var33.getInterpolatedV(0.0);
-               var35 = var34;
-               var39 = var33.getInterpolatedV(16.0);
-               var36 = var33.getInterpolatedU(16.0);
-               var40 = var39;
-               var37 = var36;
-               var41 = var38;
-            } else {
-               float var42 = MathHelper.sin(var32) * 0.25F;
-               float var43 = MathHelper.cos(var32) * 0.25F;
-               float var44 = 8.0F;
-               var34 = var33.getInterpolatedU(8.0F + (-var43 - var42) * 16.0F);
-               var38 = var33.getInterpolatedV(8.0F + (-var43 + var42) * 16.0F);
-               var35 = var33.getInterpolatedU(8.0F + (-var43 + var42) * 16.0F);
-               var39 = var33.getInterpolatedV(8.0F + (var43 + var42) * 16.0F);
-               var36 = var33.getInterpolatedU(8.0F + (var43 + var42) * 16.0F);
-               var40 = var33.getInterpolatedV(8.0F + (var43 - var42) * 16.0F);
-               var37 = var33.getInterpolatedU(8.0F + (var43 - var42) * 16.0F);
-               var41 = var33.getInterpolatedV(8.0F + (-var43 - var42) * 16.0F);
-            }
-
-            int var76 = var2.getPackedLightmapCoords(var1, var3);
-            int var77 = var76 >> 16 & 65535;
-            int var79 = var76 & 65535;
-            float var45 = 1.0F * var9;
-            float var46 = 1.0F * var10;
-            float var47 = 1.0F * var11;
-            var4.pos(var25 + 0.0, var27 + var21, var29 + 0.0).color(var45, var46, var47, 1.0F).tex(var34, var38).lightmap(var77, var79).endVertex();
-            var4.pos(var25 + 0.0, var27 + var22, var29 + 1.0).color(var45, var46, var47, 1.0F).tex(var35, var39).lightmap(var77, var79).endVertex();
-            var4.pos(var25 + 1.0, var27 + var23, var29 + 1.0).color(var45, var46, var47, 1.0F).tex(var36, var40).lightmap(var77, var79).endVertex();
-            var4.pos(var25 + 1.0, var27 + var24, var29 + 0.0).color(var45, var46, var47, 1.0F).tex(var37, var41).lightmap(var77, var79).endVertex();
-            if (var5.shouldRenderSides(var1, var3.up())) {
-               var4.pos(var25 + 0.0, var27 + var21, var29 + 0.0).color(var45, var46, var47, 1.0F).tex(var34, var38).lightmap(var77, var79).endVertex();
-               var4.pos(var25 + 1.0, var27 + var24, var29 + 0.0).color(var45, var46, var47, 1.0F).tex(var37, var41).lightmap(var77, var79).endVertex();
-               var4.pos(var25 + 1.0, var27 + var23, var29 + 1.0).color(var45, var46, var47, 1.0F).tex(var36, var40).lightmap(var77, var79).endVertex();
-               var4.pos(var25 + 0.0, var27 + var22, var29 + 1.0).color(var45, var46, var47, 1.0F).tex(var35, var39).lightmap(var77, var79).endVertex();
-            }
+      boolean var16;
+      try {
+         if (Config.isShaders()) {
+            SVertexBuilder.pushEntity(var2, var3, var1, var4);
          }
 
-         if (var13) {
-            float var59 = var7[0].getMinU();
-            float var61 = var7[0].getMaxU();
-            float var63 = var7[0].getMinV();
-            float var65 = var7[0].getMaxV();
-            int var67 = var2.getPackedLightmapCoords(var1, var3.down());
-            int var69 = var67 >> 16 & 65535;
-            int var72 = var67 & 65535;
-            var4.pos(var25, var27, var29 + 1.0).color(0.5F, 0.5F, 0.5F, 1.0F).tex(var59, var65).lightmap(var69, var72).endVertex();
-            var4.pos(var25, var27, var29).color(0.5F, 0.5F, 0.5F, 1.0F).tex(var59, var63).lightmap(var69, var72).endVertex();
-            var4.pos(var25 + 1.0, var27, var29).color(0.5F, 0.5F, 0.5F, 1.0F).tex(var61, var63).lightmap(var69, var72).endVertex();
-            var4.pos(var25 + 1.0, var27, var29 + 1.0).color(0.5F, 0.5F, 0.5F, 1.0F).tex(var61, var65).lightmap(var69, var72).endVertex();
-            var15 = true;
-         }
+         BlockLiquid var5 = (BlockLiquid)var2.getBlock();
+         boolean var6 = var2.a() == Material.LAVA;
+         TextureAtlasSprite[] var7 = var6 ? this.atlasSpritesLava : this.atlasSpritesWater;
+         RenderEnv var8 = var4.getRenderEnv(var2, var3);
+         int var9 = CustomColors.getFluidColor(var1, var2, var3, var8);
+         float var10 = (var9 >> 16 & 0xFF) / 255.0F;
+         float var11 = (var9 >> 8 & 0xFF) / 255.0F;
+         float var12 = (var9 & 0xFF) / 255.0F;
+         boolean var13 = var2.c(var1, var3, EnumFacing.UP);
+         boolean var14 = var2.c(var1, var3, EnumFacing.DOWN);
+         boolean[] var15 = var8.getBorderFlags();
+         var15[0] = var2.c(var1, var3, EnumFacing.NORTH);
+         var15[1] = var2.c(var1, var3, EnumFacing.SOUTH);
+         var15[2] = var2.c(var1, var3, EnumFacing.WEST);
+         var15[3] = var2.c(var1, var3, EnumFacing.EAST);
+         if (var13 || var14 || var15[0] || var15[1] || var15[2] || var15[3]) {
+            var16 = false;
+            float var17 = 0.5F;
+            float var18 = 1.0F;
+            float var19 = 0.8F;
+            float var20 = 0.6F;
+            Material var21 = var2.a();
+            float var22 = this.getFluidHeight(var1, var3, var21);
+            float var23 = this.getFluidHeight(var1, var3.south(), var21);
+            float var24 = this.getFluidHeight(var1, var3.east().south(), var21);
+            float var25 = this.getFluidHeight(var1, var3.east(), var21);
+            double var26 = var3.getX();
+            double var28 = var3.getY();
+            double var30 = var3.getZ();
+            float var32 = 0.001F;
+            if (var13) {
+               var16 = true;
+               float var33 = BlockLiquid.getSlopeAngle(var1, var3, var21, var2);
+               TextureAtlasSprite var34 = var33 > -999.0F ? var7[1] : var7[0];
+               var4.setSprite(var34);
+               var22 -= 0.001F;
+               var23 -= 0.001F;
+               var24 -= 0.001F;
+               var25 -= 0.001F;
+               float var35;
+               float var36;
+               float var37;
+               float var38;
+               float var39;
+               float var40;
+               float var41;
+               float var42;
+               if (var33 < -999.0F) {
+                  var35 = var34.getInterpolatedU(0.0);
+                  var39 = var34.getInterpolatedV(0.0);
+                  var36 = var35;
+                  var40 = var34.getInterpolatedV(16.0);
+                  var37 = var34.getInterpolatedU(16.0);
+                  var41 = var40;
+                  var38 = var37;
+                  var42 = var39;
+               } else {
+                  float var43 = MathHelper.sin(var33) * 0.25F;
+                  float var44 = MathHelper.cos(var33) * 0.25F;
+                  float var45 = 8.0F;
+                  var35 = var34.getInterpolatedU(8.0F + (-var44 - var43) * 16.0F);
+                  var39 = var34.getInterpolatedV(8.0F + (-var44 + var43) * 16.0F);
+                  var36 = var34.getInterpolatedU(8.0F + (-var44 + var43) * 16.0F);
+                  var40 = var34.getInterpolatedV(8.0F + (var44 + var43) * 16.0F);
+                  var37 = var34.getInterpolatedU(8.0F + (var44 + var43) * 16.0F);
+                  var41 = var34.getInterpolatedV(8.0F + (var44 - var43) * 16.0F);
+                  var38 = var34.getInterpolatedU(8.0F + (var44 - var43) * 16.0F);
+                  var42 = var34.getInterpolatedV(8.0F + (-var44 - var43) * 16.0F);
+               }
 
-         for (int var60 = 0; var60 < 4; var60++) {
-            int var62 = 0;
-            int var64 = 0;
-            if (var60 == 0) {
-               var64--;
+               int var92 = var2.b(var1, var3);
+               int var93 = var92 >> 16 & 65535;
+               int var95 = var92 & 65535;
+               float var46 = 1.0F * var10;
+               float var47 = 1.0F * var11;
+               float var48 = 1.0F * var12;
+               var4.pos(var26 + 0.0, var28 + var22, var30 + 0.0).color(var46, var47, var48, 1.0F).tex(var35, var39).lightmap(var93, var95).endVertex();
+               var4.pos(var26 + 0.0, var28 + var23, var30 + 1.0).color(var46, var47, var48, 1.0F).tex(var36, var40).lightmap(var93, var95).endVertex();
+               var4.pos(var26 + 1.0, var28 + var24, var30 + 1.0).color(var46, var47, var48, 1.0F).tex(var37, var41).lightmap(var93, var95).endVertex();
+               var4.pos(var26 + 1.0, var28 + var25, var30 + 0.0).color(var46, var47, var48, 1.0F).tex(var38, var42).lightmap(var93, var95).endVertex();
+               if (var5.shouldRenderSides(var1, var3.up())) {
+                  var4.pos(var26 + 0.0, var28 + var22, var30 + 0.0).color(var46, var47, var48, 1.0F).tex(var35, var39).lightmap(var93, var95).endVertex();
+                  var4.pos(var26 + 1.0, var28 + var25, var30 + 0.0).color(var46, var47, var48, 1.0F).tex(var38, var42).lightmap(var93, var95).endVertex();
+                  var4.pos(var26 + 1.0, var28 + var24, var30 + 1.0).color(var46, var47, var48, 1.0F).tex(var37, var41).lightmap(var93, var95).endVertex();
+                  var4.pos(var26 + 0.0, var28 + var23, var30 + 1.0).color(var46, var47, var48, 1.0F).tex(var36, var40).lightmap(var93, var95).endVertex();
+               }
             }
 
-            if (var60 == 1) {
-               var64++;
+            if (var14) {
+               var4.setSprite(var7[0]);
+               float var68 = var7[0].getMinU();
+               float var71 = var7[0].getMaxU();
+               float var73 = var7[0].getMinV();
+               float var75 = var7[0].getMaxV();
+               int var77 = var2.b(var1, var3.down());
+               int var79 = var77 >> 16 & 65535;
+               int var82 = var77 & 65535;
+               float var85 = FaceBakery.getFaceBrightness(EnumFacing.DOWN);
+               var4.pos(var26, var28, var30 + 1.0)
+                  .color(var10 * var85, var11 * var85, var12 * var85, 1.0F)
+                  .tex(var68, var75)
+                  .lightmap(var79, var82)
+                  .endVertex();
+               var4.pos(var26, var28, var30).color(var10 * var85, var11 * var85, var12 * var85, 1.0F).tex(var68, var73).lightmap(var79, var82).endVertex();
+               var4.pos(var26 + 1.0, var28, var30)
+                  .color(var10 * var85, var11 * var85, var12 * var85, 1.0F)
+                  .tex(var71, var73)
+                  .lightmap(var79, var82)
+                  .endVertex();
+               var4.pos(var26 + 1.0, var28, var30 + 1.0)
+                  .color(var10 * var85, var11 * var85, var12 * var85, 1.0F)
+                  .tex(var71, var75)
+                  .lightmap(var79, var82)
+                  .endVertex();
+               var16 = true;
             }
 
-            if (var60 == 2) {
-               var62--;
-            }
+            for (int var69 = 0; var69 < 4; var69++) {
+               int var72 = 0;
+               int var74 = 0;
+               if (var69 == 0) {
+                  var74--;
+               }
 
-            if (var60 == 3) {
-               var62++;
-            }
+               if (var69 == 1) {
+                  var74++;
+               }
 
-            BlockPos var66 = var3.add(var62, 0, var64);
-            TextureAtlasSprite var68 = var7[1];
-            if (!var6) {
-               Block var70 = var1.getBlockState(var66).getBlock();
-               if (var70 == Blocks.GLASS || var70 == Blocks.STAINED_GLASS) {
-                  var68 = this.atlasSpriteWaterOverlay;
+               if (var69 == 2) {
+                  var72--;
                }
-            }
 
-            if (var14[var60]) {
-               float var71;
-               float var73;
-               double var74;
-               double var75;
-               double var78;
-               double var80;
-               if (var60 == 0) {
-                  var71 = var21;
-                  var73 = var24;
-                  var74 = var25;
-                  var78 = var25 + 1.0;
-                  var75 = var29 + 0.001F;
-                  var80 = var29 + 0.001F;
-               } else if (var60 == 1) {
-                  var71 = var23;
-                  var73 = var22;
-                  var74 = var25 + 1.0;
-                  var78 = var25;
-                  var75 = var29 + 1.0 - 0.001F;
-                  var80 = var29 + 1.0 - 0.001F;
-               } else if (var60 == 2) {
-                  var71 = var22;
-                  var73 = var21;
-                  var74 = var25 + 0.001F;
-                  var78 = var25 + 0.001F;
-                  var75 = var29 + 1.0;
-                  var80 = var29;
-               } else {
-                  var71 = var24;
-                  var73 = var23;
-                  var74 = var25 + 1.0 - 0.001F;
-                  var78 = var25 + 1.0 - 0.001F;
-                  var75 = var29;
-                  var80 = var29 + 1.0;
-               }
-
-               var15 = true;
-               float var81 = var68.getInterpolatedU(0.0);
-               float var48 = var68.getInterpolatedU(8.0);
-               float var49 = var68.getInterpolatedV((1.0F - var71) * 16.0F * 0.5F);
-               float var50 = var68.getInterpolatedV((1.0F - var73) * 16.0F * 0.5F);
-               float var51 = var68.getInterpolatedV(8.0);
-               int var52 = var2.getPackedLightmapCoords(var1, var66);
-               int var53 = var52 >> 16 & 65535;
-               int var54 = var52 & 65535;
-               float var55 = var60 < 2 ? 0.8F : 0.6F;
-               float var56 = 1.0F * var55 * var9;
-               float var57 = 1.0F * var55 * var10;
-               float var58 = 1.0F * var55 * var11;
-               var4.pos(var74, var27 + var71, var75).color(var56, var57, var58, 1.0F).tex(var81, var49).lightmap(var53, var54).endVertex();
-               var4.pos(var78, var27 + var73, var80).color(var56, var57, var58, 1.0F).tex(var48, var50).lightmap(var53, var54).endVertex();
-               var4.pos(var78, var27 + 0.0, var80).color(var56, var57, var58, 1.0F).tex(var48, var51).lightmap(var53, var54).endVertex();
-               var4.pos(var74, var27 + 0.0, var75).color(var56, var57, var58, 1.0F).tex(var81, var51).lightmap(var53, var54).endVertex();
-               if (var68 != this.atlasSpriteWaterOverlay) {
-                  var4.pos(var74, var27 + 0.0, var75).color(var56, var57, var58, 1.0F).tex(var81, var51).lightmap(var53, var54).endVertex();
-                  var4.pos(var78, var27 + 0.0, var80).color(var56, var57, var58, 1.0F).tex(var48, var51).lightmap(var53, var54).endVertex();
-                  var4.pos(var78, var27 + var73, var80).color(var56, var57, var58, 1.0F).tex(var48, var50).lightmap(var53, var54).endVertex();
-                  var4.pos(var74, var27 + var71, var75).color(var56, var57, var58, 1.0F).tex(var81, var49).lightmap(var53, var54).endVertex();
+               if (var69 == 3) {
+                  var72++;
+               }
+
+               BlockPos var76 = var3.add(var72, 0, var74);
+               TextureAtlasSprite var78 = var7[1];
+               var4.setSprite(var78);
+               float var80 = 0.0F;
+               float var83 = 0.0F;
+               if (!var6) {
+                  IBlockState var86 = var1.getBlockState(var76);
+                  Block var88 = var86.getBlock();
+                  if (var88 == Blocks.GLASS || var88 == Blocks.STAINED_GLASS || var88 == Blocks.BEACON || var88 == Blocks.SLIME_BLOCK) {
+                     var78 = this.atlasSpriteWaterOverlay;
+                     var4.setSprite(var78);
+                  }
+
+                  if (var88 == Blocks.FARMLAND || var88 == Blocks.GRASS_PATH) {
+                     var80 = 0.9375F;
+                     var83 = 0.9375F;
+                  }
+
+                  if (var88 instanceof BlockSlab) {
+                     BlockSlab var90 = (BlockSlab)var88;
+                     if (!var90.isDouble() && var86.getValue(BlockSlab.HALF) == EnumBlockHalf.BOTTOM) {
+                        var80 = 0.5F;
+                        var83 = 0.5F;
+                     }
+                  }
+               }
+
+               if (var15[var69]) {
+                  float var87;
+                  float var89;
+                  double var91;
+                  double var94;
+                  double var96;
+                  double var97;
+                  if (var69 == 0) {
+                     var87 = var22;
+                     var89 = var25;
+                     var91 = var26;
+                     var96 = var26 + 1.0;
+                     var94 = var30 + 0.001F;
+                     var97 = var30 + 0.001F;
+                  } else if (var69 == 1) {
+                     var87 = var24;
+                     var89 = var23;
+                     var91 = var26 + 1.0;
+                     var96 = var26;
+                     var94 = var30 + 1.0 - 0.001F;
+                     var97 = var30 + 1.0 - 0.001F;
+                  } else if (var69 == 2) {
+                     var87 = var23;
+                     var89 = var22;
+                     var91 = var26 + 0.001F;
+                     var96 = var26 + 0.001F;
+                     var94 = var30 + 1.0;
+                     var97 = var30;
+                  } else {
+                     var87 = var25;
+                     var89 = var24;
+                     var91 = var26 + 1.0 - 0.001F;
+                     var96 = var26 + 1.0 - 0.001F;
+                     var94 = var30;
+                     var97 = var30 + 1.0;
+                  }
+
+                  if (!(var87 <= var80) || !(var89 <= var83)) {
+                     var80 = Math.min(var80, var87);
+                     var83 = Math.min(var83, var89);
+                     if (var80 > var32) {
+                        var80 -= var32;
+                     }
+
+                     if (var83 > var32) {
+                        var83 -= var32;
+                     }
+
+                     var16 = true;
+                     float var50 = var78.getInterpolatedU(0.0);
+                     float var51 = var78.getInterpolatedU(8.0);
+                     float var52 = var78.getInterpolatedV((1.0F - var87) * 16.0F * 0.5F);
+                     float var53 = var78.getInterpolatedV((1.0F - var89) * 16.0F * 0.5F);
+                     float var54 = var78.getInterpolatedV(8.0);
+                     float var55 = var78.getInterpolatedV((1.0F - var80) * 16.0F * 0.5F);
+                     float var56 = var78.getInterpolatedV((1.0F - var83) * 16.0F * 0.5F);
+                     int var57 = var2.b(var1, var76);
+                     int var58 = var57 >> 16 & 65535;
+                     int var59 = var57 & 65535;
+                     float var60 = var69 < 2 ? FaceBakery.getFaceBrightness(EnumFacing.NORTH) : FaceBakery.getFaceBrightness(EnumFacing.WEST);
+                     float var61 = 1.0F * var60 * var10;
+                     float var62 = 1.0F * var60 * var11;
+                     float var63 = 1.0F * var60 * var12;
+                     var4.pos(var91, var28 + var87, var94).color(var61, var62, var63, 1.0F).tex(var50, var52).lightmap(var58, var59).endVertex();
+                     var4.pos(var96, var28 + var89, var97).color(var61, var62, var63, 1.0F).tex(var51, var53).lightmap(var58, var59).endVertex();
+                     var4.pos(var96, var28 + var83, var97).color(var61, var62, var63, 1.0F).tex(var51, var56).lightmap(var58, var59).endVertex();
+                     var4.pos(var91, var28 + var80, var94).color(var61, var62, var63, 1.0F).tex(var50, var55).lightmap(var58, var59).endVertex();
+                     if (var78 != this.atlasSpriteWaterOverlay) {
+                        var4.pos(var91, var28 + var80, var94).color(var61, var62, var63, 1.0F).tex(var50, var55).lightmap(var58, var59).endVertex();
+                        var4.pos(var96, var28 + var83, var97).color(var61, var62, var63, 1.0F).tex(var51, var56).lightmap(var58, var59).endVertex();
+                        var4.pos(var96, var28 + var89, var97).color(var61, var62, var63, 1.0F).tex(var51, var53).lightmap(var58, var59).endVertex();
+                        var4.pos(var91, var28 + var87, var94).color(var61, var62, var63, 1.0F).tex(var50, var52).lightmap(var58, var59).endVertex();
+                     }
+                  }
                }
             }
+
+            var4.setSprite(null);
+            return var16;
          }
 
-         return var15;
+         var16 = false;
+      } finally {
+         if (Config.isShaders()) {
+            SVertexBuilder.popEntity(var4);
+         }
       }
+
+      return var16;
    }
 
    private float getFluidHeight(IBlockAccess var1, BlockPos var2, Material var3) {
       int var4 = 0;
       float var5 = 0.0F;
 
       for (int var6 = 0; var6 < 4; var6++) {
          BlockPos var7 = var2.add(-(var6 & 1), 0, -(var6 >> 1 & 1));
-         if (var1.getBlockState(var7.up()).getMaterial() == var3) {
+         if (var1.getBlockState(var7.up()).a() == var3) {
             return 1.0F;
          }
 
          IBlockState var8 = var1.getBlockState(var7);
-         Material var9 = var8.getMaterial();
-         if (var9 == var3) {
-            int var10 = var8.getValue(BlockLiquid.LEVEL);
+         Material var9 = var8.a();
+         if (var9 != var3) {
+            if (!var9.isSolid()) {
+               var5++;
+               var4++;
+            }
+         } else {
+            int var10 = (Integer)var8.getValue(BlockLiquid.LEVEL);
             if (var10 >= 8 || var10 == 0) {
                var5 += BlockLiquid.getLiquidHeightPercent(var10) * 10.0F;
                var4 += 10;
             }
 
             var5 += BlockLiquid.getLiquidHeightPercent(var10);
-            var4++;
-         } else if (!var9.isSolid()) {
-            var5++;
             var4++;
          }
       }
 
       return 1.0F - var5 / var4;
    }
--- net/minecraft/client/renderer/BlockModelRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BlockModelRenderer.java	Mon Aug 18 09:39:52 2025
@@ -4,261 +4,367 @@
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.block.model.BakedQuad;
+import net.minecraft.client.renderer.block.model.FaceBakery;
 import net.minecraft.client.renderer.block.model.IBakedModel;
 import net.minecraft.client.renderer.color.BlockColors;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3d;
 import net.minecraft.util.math.Vec3i;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.IBlockAccess;
+import net.optifine.BetterSnow;
+import net.optifine.CustomColors;
+import net.optifine.model.BlockModelCustomizer;
+import net.optifine.model.ListQuadsOverlay;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
+import net.optifine.shaders.Shaders;
 
 public class BlockModelRenderer {
    private final BlockColors blockColors;
+   private static float aoLightValueOpaque = 0.2F;
+   private static boolean separateAoLightValue = false;
+   private static final BlockRenderLayer[] OVERLAY_LAYERS = new BlockRenderLayer[]{
+      BlockRenderLayer.CUTOUT, BlockRenderLayer.CUTOUT_MIPPED, BlockRenderLayer.TRANSLUCENT
+   };
 
    public BlockModelRenderer(BlockColors var1) {
       this.blockColors = var1;
+      if (Reflector.ForgeModContainer_forgeLightPipelineEnabled.exists()) {
+         Reflector.setFieldValue(Reflector.ForgeModContainer_forgeLightPipelineEnabled, false);
+      }
    }
 
    public boolean renderModel(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6) {
       return this.renderModel(var1, var2, var3, var4, var5, var6, MathHelper.getPositionRandom(var4));
    }
 
    public boolean renderModel(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
-      boolean var9 = Minecraft.isAmbientOcclusionEnabled() && var3.getLightValue() == 0 && var2.isAmbientOcclusion();
+      boolean var9 = Minecraft.isAmbientOcclusionEnabled()
+         && ReflectorForge.getLightValue(var3, var1, var4) == 0
+         && ReflectorForge.isAmbientOcclusion(var2, var3);
 
       try {
-         return var9 ? this.renderModelSmooth(var1, var2, var3, var4, var5, var6, var7) : this.renderModelFlat(var1, var2, var3, var4, var5, var6, var7);
+         if (Config.isShaders()) {
+            SVertexBuilder.pushEntity(var3, var4, var1, var5);
+         }
+
+         if (!Config.isAlternateBlocks()) {
+            var7 = 0L;
+         }
+
+         RenderEnv var10 = var5.getRenderEnv(var3, var4);
+         var2 = BlockModelCustomizer.getRenderModel(var2, var3, var10);
+         boolean var15 = var9
+            ? this.renderModelSmooth(var1, var2, var3, var4, var5, var6, var7)
+            : this.renderModelFlat(var1, var2, var3, var4, var5, var6, var7);
+         if (var15) {
+            this.renderOverlayModels(var1, var2, var3, var4, var5, var6, var7, var10, var9);
+         }
+
+         if (Config.isShaders()) {
+            SVertexBuilder.popEntity(var5);
+         }
+
+         return var15;
       } catch (Throwable var13) {
          CrashReport var11 = CrashReport.makeCrashReport(var13, "Tesselating block model");
          CrashReportCategory var12 = var11.makeCategory("Block model being tesselated");
          CrashReportCategory.addBlockInfo(var12, var4, var3);
          var12.addCrashSection("Using AO", var9);
          throw new ReportedException(var11);
       }
    }
 
    public boolean renderModelSmooth(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
       boolean var9 = false;
-      float[] var10 = new float[EnumFacing.values().length * 2];
-      BitSet var11 = new BitSet(3);
-      BlockModelRenderer.AmbientOcclusionFace var12 = new BlockModelRenderer.AmbientOcclusionFace();
-
-      for (EnumFacing var16 : EnumFacing.values()) {
-         List var17 = var2.getQuads(var3, var16, var7);
-         if (!var17.isEmpty() && (!var6 || var3.shouldSideBeRendered(var1, var4, var16))) {
-            this.renderQuadsSmooth(var1, var3, var4, var5, var17, var10, var11, var12);
+      RenderEnv var10 = var5.getRenderEnv(var3, var4);
+      BlockRenderLayer var11 = var5.getBlockLayer();
+
+      for (EnumFacing var15 : EnumFacing.VALUES) {
+         List var16 = var2.getQuads(var3, var15, var7);
+         if (!var16.isEmpty() && (!var6 || var3.c(var1, var4, var15))) {
+            var16 = BlockModelCustomizer.getRenderQuads(var16, var1, var3, var4, var15, var11, var7, var10);
+            this.renderQuadsSmooth(var1, var3, var4, var5, var16, var10);
             var9 = true;
          }
       }
 
-      List var18 = var2.getQuads(var3, null, var7);
-      if (!var18.isEmpty()) {
-         this.renderQuadsSmooth(var1, var3, var4, var5, var18, var10, var11, var12);
+      List var17 = var2.getQuads(var3, (EnumFacing)null, var7);
+      if (!var17.isEmpty()) {
+         var17 = BlockModelCustomizer.getRenderQuads(var17, var1, var3, var4, null, var11, var7, var10);
+         this.renderQuadsSmooth(var1, var3, var4, var5, var17, var10);
          var9 = true;
       }
 
       return var9;
    }
 
    public boolean renderModelFlat(IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7) {
       boolean var9 = false;
-      BitSet var10 = new BitSet(3);
+      RenderEnv var10 = var5.getRenderEnv(var3, var4);
+      BlockRenderLayer var11 = var5.getBlockLayer();
 
-      for (EnumFacing var14 : EnumFacing.values()) {
-         List var15 = var2.getQuads(var3, var14, var7);
-         if (!var15.isEmpty() && (!var6 || var3.shouldSideBeRendered(var1, var4, var14))) {
-            int var16 = var3.getPackedLightmapCoords(var1, var4.offset(var14));
-            this.renderQuadsFlat(var1, var3, var4, var16, false, var5, var15, var10);
+      for (EnumFacing var15 : EnumFacing.VALUES) {
+         List var16 = var2.getQuads(var3, var15, var7);
+         if (!var16.isEmpty() && (!var6 || var3.c(var1, var4, var15))) {
+            int var17 = var3.b(var1, var4.offset(var15));
+            var16 = BlockModelCustomizer.getRenderQuads(var16, var1, var3, var4, var15, var11, var7, var10);
+            this.renderQuadsFlat(var1, var3, var4, var17, false, var5, var16, var10);
             var9 = true;
          }
       }
 
-      List var17 = var2.getQuads(var3, null, var7);
-      if (!var17.isEmpty()) {
-         this.renderQuadsFlat(var1, var3, var4, -1, true, var5, var17, var10);
+      List var18 = var2.getQuads(var3, (EnumFacing)null, var7);
+      if (!var18.isEmpty()) {
+         var18 = BlockModelCustomizer.getRenderQuads(var18, var1, var3, var4, null, var11, var7, var10);
+         this.renderQuadsFlat(var1, var3, var4, -1, true, var5, var18, var10);
          var9 = true;
       }
 
       return var9;
    }
 
-   private void renderQuadsSmooth(
-      IBlockAccess var1,
-      IBlockState var2,
-      BlockPos var3,
-      BufferBuilder var4,
-      List<BakedQuad> var5,
-      float[] var6,
-      BitSet var7,
-      BlockModelRenderer.AmbientOcclusionFace var8
-   ) {
-      Vec3d var9 = var2.getOffset(var1, var3);
-      double var10 = var3.getX() + var9.x;
-      double var12 = var3.getY() + var9.y;
-      double var14 = var3.getZ() + var9.z;
-      int var16 = 0;
-
-      for (int var17 = var5.size(); var16 < var17; var16++) {
-         BakedQuad var18 = (BakedQuad)var5.get(var16);
-         this.fillQuadBounds(var2, var18.getVertexData(), var18.getFace(), var6, var7);
-         var8.updateVertexBrightness(var1, var2, var3, var18.getFace(), var6, var7);
-         var4.addVertexData(var18.getVertexData());
-         var4.putBrightness4(var8.vertexBrightness[0], var8.vertexBrightness[1], var8.vertexBrightness[2], var8.vertexBrightness[3]);
-         if (var18.hasTintIndex()) {
-            int var19 = this.blockColors.colorMultiplier(var2, var1, var3, var18.getTintIndex());
+   private void renderQuadsSmooth(IBlockAccess var1, IBlockState var2, BlockPos var3, BufferBuilder var4, List<BakedQuad> var5, RenderEnv var6) {
+      float[] var7 = var6.getQuadBounds();
+      BitSet var8 = var6.getBoundsFlags();
+      BlockModelRenderer.AmbientOcclusionFace var9 = var6.getAoFace();
+      Vec3d var10 = var2.f(var1, var3);
+      double var11 = var3.getX() + var10.x;
+      double var13 = var3.getY() + var10.y;
+      double var15 = var3.getZ() + var10.z;
+      int var17 = 0;
+
+      for (int var18 = var5.size(); var17 < var18; var17++) {
+         BakedQuad var19 = (BakedQuad)var5.get(var17);
+         this.fillQuadBounds(var2, var19.getVertexData(), var19.getFace(), var7, var8);
+         var9.updateVertexBrightness(var1, var2, var3, var19.getFace(), var7, var8);
+         if (var19.getSprite().isEmissive) {
+            var9.setMaxBlockLight();
+         }
+
+         if (var4.isMultiTexture()) {
+            var4.addVertexData(var19.getVertexDataSingle());
+         } else {
+            var4.addVertexData(var19.getVertexData());
+         }
+
+         var4.putSprite(var19.getSprite());
+         var4.putBrightness4(var9.vertexBrightness[0], var9.vertexBrightness[1], var9.vertexBrightness[2], var9.vertexBrightness[3]);
+         if (var19.shouldApplyDiffuseLighting()) {
+            float var20 = FaceBakery.getFaceBrightness(var19.getFace());
+            var9.vertexColorMultiplier[0] *= var20;
+            var9.vertexColorMultiplier[1] *= var20;
+            var9.vertexColorMultiplier[2] *= var20;
+            var9.vertexColorMultiplier[3] *= var20;
+         }
+
+         int var25 = CustomColors.getColorMultiplier(var19, var2, var1, var3, var6);
+         if (var19.hasTintIndex() || var25 != -1) {
+            int var21 = var25;
+            if (var25 == -1) {
+               var21 = this.blockColors.colorMultiplier(var2, var1, var3, var19.getTintIndex());
+            }
+
             if (EntityRenderer.anaglyphEnable) {
-               var19 = TextureUtil.anaglyphColor(var19);
+               var21 = TextureUtil.anaglyphColor(var21);
             }
 
-            float var20 = (var19 >> 16 & 0xFF) / 255.0F;
-            float var21 = (var19 >> 8 & 0xFF) / 255.0F;
-            float var22 = (var19 & 0xFF) / 255.0F;
-            var4.putColorMultiplier(var8.vertexColorMultiplier[0] * var20, var8.vertexColorMultiplier[0] * var21, var8.vertexColorMultiplier[0] * var22, 4);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[1] * var20, var8.vertexColorMultiplier[1] * var21, var8.vertexColorMultiplier[1] * var22, 3);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[2] * var20, var8.vertexColorMultiplier[2] * var21, var8.vertexColorMultiplier[2] * var22, 2);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[3] * var20, var8.vertexColorMultiplier[3] * var21, var8.vertexColorMultiplier[3] * var22, 1);
+            float var22 = (var21 >> 16 & 0xFF) / 255.0F;
+            float var23 = (var21 >> 8 & 0xFF) / 255.0F;
+            float var24 = (var21 & 0xFF) / 255.0F;
+            if (separateAoLightValue) {
+               var4.putColorMultiplierRgba(var22, var23, var24, var9.vertexColorMultiplier[0], 4);
+               var4.putColorMultiplierRgba(var22, var23, var24, var9.vertexColorMultiplier[1], 3);
+               var4.putColorMultiplierRgba(var22, var23, var24, var9.vertexColorMultiplier[2], 2);
+               var4.putColorMultiplierRgba(var22, var23, var24, var9.vertexColorMultiplier[3], 1);
+            } else {
+               var4.putColorMultiplier(var9.vertexColorMultiplier[0] * var22, var9.vertexColorMultiplier[0] * var23, var9.vertexColorMultiplier[0] * var24, 4);
+               var4.putColorMultiplier(var9.vertexColorMultiplier[1] * var22, var9.vertexColorMultiplier[1] * var23, var9.vertexColorMultiplier[1] * var24, 3);
+               var4.putColorMultiplier(var9.vertexColorMultiplier[2] * var22, var9.vertexColorMultiplier[2] * var23, var9.vertexColorMultiplier[2] * var24, 2);
+               var4.putColorMultiplier(var9.vertexColorMultiplier[3] * var22, var9.vertexColorMultiplier[3] * var23, var9.vertexColorMultiplier[3] * var24, 1);
+            }
+         } else if (separateAoLightValue) {
+            var4.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, var9.vertexColorMultiplier[0], 4);
+            var4.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, var9.vertexColorMultiplier[1], 3);
+            var4.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, var9.vertexColorMultiplier[2], 2);
+            var4.putColorMultiplierRgba(1.0F, 1.0F, 1.0F, var9.vertexColorMultiplier[3], 1);
          } else {
-            var4.putColorMultiplier(var8.vertexColorMultiplier[0], var8.vertexColorMultiplier[0], var8.vertexColorMultiplier[0], 4);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[1], var8.vertexColorMultiplier[1], var8.vertexColorMultiplier[1], 3);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[2], var8.vertexColorMultiplier[2], var8.vertexColorMultiplier[2], 2);
-            var4.putColorMultiplier(var8.vertexColorMultiplier[3], var8.vertexColorMultiplier[3], var8.vertexColorMultiplier[3], 1);
+            var4.putColorMultiplier(var9.vertexColorMultiplier[0], var9.vertexColorMultiplier[0], var9.vertexColorMultiplier[0], 4);
+            var4.putColorMultiplier(var9.vertexColorMultiplier[1], var9.vertexColorMultiplier[1], var9.vertexColorMultiplier[1], 3);
+            var4.putColorMultiplier(var9.vertexColorMultiplier[2], var9.vertexColorMultiplier[2], var9.vertexColorMultiplier[2], 2);
+            var4.putColorMultiplier(var9.vertexColorMultiplier[3], var9.vertexColorMultiplier[3], var9.vertexColorMultiplier[3], 1);
          }
 
-         var4.putPosition(var10, var12, var14);
+         var4.putPosition(var11, var13, var15);
       }
    }
 
    private void fillQuadBounds(IBlockState var1, int[] var2, EnumFacing var3, @Nullable float[] var4, BitSet var5) {
       float var6 = 32.0F;
       float var7 = 32.0F;
       float var8 = 32.0F;
       float var9 = -32.0F;
       float var10 = -32.0F;
       float var11 = -32.0F;
+      int var12 = var2.length / 4;
 
-      for (int var12 = 0; var12 < 4; var12++) {
-         float var13 = Float.intBitsToFloat(var2[var12 * 7]);
-         float var14 = Float.intBitsToFloat(var2[var12 * 7 + 1]);
-         float var15 = Float.intBitsToFloat(var2[var12 * 7 + 2]);
-         var6 = Math.min(var6, var13);
-         var7 = Math.min(var7, var14);
-         var8 = Math.min(var8, var15);
-         var9 = Math.max(var9, var13);
-         var10 = Math.max(var10, var14);
-         var11 = Math.max(var11, var15);
+      for (int var13 = 0; var13 < 4; var13++) {
+         float var14 = Float.intBitsToFloat(var2[var13 * var12]);
+         float var15 = Float.intBitsToFloat(var2[var13 * var12 + 1]);
+         float var16 = Float.intBitsToFloat(var2[var13 * var12 + 2]);
+         var6 = Math.min(var6, var14);
+         var7 = Math.min(var7, var15);
+         var8 = Math.min(var8, var16);
+         var9 = Math.max(var9, var14);
+         var10 = Math.max(var10, var15);
+         var11 = Math.max(var11, var16);
       }
 
       if (var4 != null) {
          var4[EnumFacing.WEST.getIndex()] = var6;
          var4[EnumFacing.EAST.getIndex()] = var9;
          var4[EnumFacing.DOWN.getIndex()] = var7;
          var4[EnumFacing.UP.getIndex()] = var10;
          var4[EnumFacing.NORTH.getIndex()] = var8;
          var4[EnumFacing.SOUTH.getIndex()] = var11;
-         int var16 = EnumFacing.values().length;
-         var4[EnumFacing.WEST.getIndex() + var16] = 1.0F - var6;
-         var4[EnumFacing.EAST.getIndex() + var16] = 1.0F - var9;
-         var4[EnumFacing.DOWN.getIndex() + var16] = 1.0F - var7;
-         var4[EnumFacing.UP.getIndex() + var16] = 1.0F - var10;
-         var4[EnumFacing.NORTH.getIndex() + var16] = 1.0F - var8;
-         var4[EnumFacing.SOUTH.getIndex() + var16] = 1.0F - var11;
+         int var17 = EnumFacing.VALUES.length;
+         var4[EnumFacing.WEST.getIndex() + var17] = 1.0F - var6;
+         var4[EnumFacing.EAST.getIndex() + var17] = 1.0F - var9;
+         var4[EnumFacing.DOWN.getIndex() + var17] = 1.0F - var7;
+         var4[EnumFacing.UP.getIndex() + var17] = 1.0F - var10;
+         var4[EnumFacing.NORTH.getIndex() + var17] = 1.0F - var8;
+         var4[EnumFacing.SOUTH.getIndex() + var17] = 1.0F - var11;
       }
 
-      float var17 = 1.0E-4F;
-      float var18 = 0.9999F;
+      float var18 = 1.0E-4F;
+      float var19 = 0.9999F;
       switch (var3) {
          case DOWN:
             var5.set(1, var6 >= 1.0E-4F || var8 >= 1.0E-4F || var9 <= 0.9999F || var11 <= 0.9999F);
-            var5.set(0, (var7 < 1.0E-4F || var1.isFullCube()) && var7 == var10);
+            var5.set(0, (var7 < 1.0E-4F || var1.g()) && var7 == var10);
             break;
          case UP:
             var5.set(1, var6 >= 1.0E-4F || var8 >= 1.0E-4F || var9 <= 0.9999F || var11 <= 0.9999F);
-            var5.set(0, (var10 > 0.9999F || var1.isFullCube()) && var7 == var10);
+            var5.set(0, (var10 > 0.9999F || var1.g()) && var7 == var10);
             break;
          case NORTH:
             var5.set(1, var6 >= 1.0E-4F || var7 >= 1.0E-4F || var9 <= 0.9999F || var10 <= 0.9999F);
-            var5.set(0, (var8 < 1.0E-4F || var1.isFullCube()) && var8 == var11);
+            var5.set(0, (var8 < 1.0E-4F || var1.g()) && var8 == var11);
             break;
          case SOUTH:
             var5.set(1, var6 >= 1.0E-4F || var7 >= 1.0E-4F || var9 <= 0.9999F || var10 <= 0.9999F);
-            var5.set(0, (var11 > 0.9999F || var1.isFullCube()) && var8 == var11);
+            var5.set(0, (var11 > 0.9999F || var1.g()) && var8 == var11);
             break;
          case WEST:
             var5.set(1, var7 >= 1.0E-4F || var8 >= 1.0E-4F || var10 <= 0.9999F || var11 <= 0.9999F);
-            var5.set(0, (var6 < 1.0E-4F || var1.isFullCube()) && var6 == var9);
+            var5.set(0, (var6 < 1.0E-4F || var1.g()) && var6 == var9);
             break;
          case EAST:
             var5.set(1, var7 >= 1.0E-4F || var8 >= 1.0E-4F || var10 <= 0.9999F || var11 <= 0.9999F);
-            var5.set(0, (var9 > 0.9999F || var1.isFullCube()) && var6 == var9);
+            var5.set(0, (var9 > 0.9999F || var1.g()) && var6 == var9);
       }
    }
 
    private void renderQuadsFlat(
-      IBlockAccess var1, IBlockState var2, BlockPos var3, int var4, boolean var5, BufferBuilder var6, List<BakedQuad> var7, BitSet var8
+      IBlockAccess var1, IBlockState var2, BlockPos var3, int var4, boolean var5, BufferBuilder var6, List<BakedQuad> var7, RenderEnv var8
    ) {
-      Vec3d var9 = var2.getOffset(var1, var3);
-      double var10 = var3.getX() + var9.x;
-      double var12 = var3.getY() + var9.y;
-      double var14 = var3.getZ() + var9.z;
-      int var16 = 0;
+      BitSet var9 = var8.getBoundsFlags();
+      Vec3d var10 = var2.f(var1, var3);
+      double var11 = var3.getX() + var10.x;
+      double var13 = var3.getY() + var10.y;
+      double var15 = var3.getZ() + var10.z;
+      int var17 = 0;
 
-      for (int var17 = var7.size(); var16 < var17; var16++) {
-         BakedQuad var18 = (BakedQuad)var7.get(var16);
+      for (int var18 = var7.size(); var17 < var18; var17++) {
+         BakedQuad var19 = (BakedQuad)var7.get(var17);
          if (var5) {
-            this.fillQuadBounds(var2, var18.getVertexData(), var18.getFace(), null, var8);
-            BlockPos var19 = var8.get(0) ? var3.offset(var18.getFace()) : var3;
-            var4 = var2.getPackedLightmapCoords(var1, var19);
+            this.fillQuadBounds(var2, var19.getVertexData(), var19.getFace(), (float[])null, var9);
+            BlockPos var20 = var9.get(0) ? var3.offset(var19.getFace()) : var3;
+            var4 = var2.b(var1, var20);
+         }
+
+         if (var19.getSprite().isEmissive) {
+            var4 |= 240;
+         }
+
+         if (var6.isMultiTexture()) {
+            var6.addVertexData(var19.getVertexDataSingle());
+         } else {
+            var6.addVertexData(var19.getVertexData());
          }
 
-         var6.addVertexData(var18.getVertexData());
+         var6.putSprite(var19.getSprite());
          var6.putBrightness4(var4, var4, var4, var4);
-         if (var18.hasTintIndex()) {
-            int var23 = this.blockColors.colorMultiplier(var2, var1, var3, var18.getTintIndex());
+         int var26 = CustomColors.getColorMultiplier(var19, var2, var1, var3, var8);
+         if (var19.hasTintIndex() || var26 != -1) {
+            int var27 = var26;
+            if (var26 == -1) {
+               var27 = this.blockColors.colorMultiplier(var2, var1, var3, var19.getTintIndex());
+            }
+
             if (EntityRenderer.anaglyphEnable) {
-               var23 = TextureUtil.anaglyphColor(var23);
+               var27 = TextureUtil.anaglyphColor(var27);
             }
 
-            float var20 = (var23 >> 16 & 0xFF) / 255.0F;
-            float var21 = (var23 >> 8 & 0xFF) / 255.0F;
-            float var22 = (var23 & 0xFF) / 255.0F;
-            var6.putColorMultiplier(var20, var21, var22, 4);
-            var6.putColorMultiplier(var20, var21, var22, 3);
-            var6.putColorMultiplier(var20, var21, var22, 2);
-            var6.putColorMultiplier(var20, var21, var22, 1);
+            float var22 = (var27 >> 16 & 0xFF) / 255.0F;
+            float var23 = (var27 >> 8 & 0xFF) / 255.0F;
+            float var24 = (var27 & 0xFF) / 255.0F;
+            if (var19.shouldApplyDiffuseLighting()) {
+               float var25 = FaceBakery.getFaceBrightness(var19.getFace());
+               var22 *= var25;
+               var23 *= var25;
+               var24 *= var25;
+            }
+
+            var6.putColorMultiplier(var22, var23, var24, 4);
+            var6.putColorMultiplier(var22, var23, var24, 3);
+            var6.putColorMultiplier(var22, var23, var24, 2);
+            var6.putColorMultiplier(var22, var23, var24, 1);
+         } else if (var19.shouldApplyDiffuseLighting()) {
+            float var21 = FaceBakery.getFaceBrightness(var19.getFace());
+            var6.putColorMultiplier(var21, var21, var21, 4);
+            var6.putColorMultiplier(var21, var21, var21, 3);
+            var6.putColorMultiplier(var21, var21, var21, 2);
+            var6.putColorMultiplier(var21, var21, var21, 1);
          }
 
-         var6.putPosition(var10, var12, var14);
+         var6.putPosition(var11, var13, var15);
       }
    }
 
    public void renderModelBrightnessColor(IBakedModel var1, float var2, float var3, float var4, float var5) {
-      this.renderModelBrightnessColor(null, var1, var2, var3, var4, var5);
+      this.renderModelBrightnessColor((IBlockState)null, var1, var2, var3, var4, var5);
    }
 
    public void renderModelBrightnessColor(IBlockState var1, IBakedModel var2, float var3, float var4, float var5, float var6) {
-      for (EnumFacing var10 : EnumFacing.values()) {
+      for (EnumFacing var10 : EnumFacing.VALUES) {
          this.renderModelBrightnessColorQuads(var3, var4, var5, var6, var2.getQuads(var1, var10, 0L));
       }
 
-      this.renderModelBrightnessColorQuads(var3, var4, var5, var6, var2.getQuads(var1, null, 0L));
+      this.renderModelBrightnessColorQuads(var3, var4, var5, var6, var2.getQuads(var1, (EnumFacing)null, 0L));
    }
 
    public void renderModelBrightness(IBakedModel var1, IBlockState var2, float var3, boolean var4) {
       Block var5 = var2.getBlock();
       GlStateManager.rotate(90.0F, 0.0F, 1.0F, 0.0F);
-      int var6 = this.blockColors.colorMultiplier(var2, null, null, 0);
+      int var6 = this.blockColors.colorMultiplier(var2, (IBlockAccess)null, (BlockPos)null, 0);
       if (EntityRenderer.anaglyphEnable) {
          var6 = TextureUtil.anaglyphColor(var6);
       }
 
       float var7 = (var6 >> 16 & 0xFF) / 255.0F;
       float var8 = (var6 >> 8 & 0xFF) / 255.0F;
@@ -276,112 +382,192 @@
       int var8 = 0;
 
       for (int var9 = var5.size(); var8 < var9; var8++) {
          BakedQuad var10 = (BakedQuad)var5.get(var8);
          var7.begin(7, DefaultVertexFormats.ITEM);
          var7.addVertexData(var10.getVertexData());
+         var7.putSprite(var10.getSprite());
          if (var10.hasTintIndex()) {
             var7.putColorRGB_F4(var2 * var1, var3 * var1, var4 * var1);
          } else {
             var7.putColorRGB_F4(var1, var1, var1);
          }
 
          Vec3i var11 = var10.getFace().getDirectionVec();
          var7.putNormal(var11.getX(), var11.getY(), var11.getZ());
          var6.draw();
       }
    }
 
-   class AmbientOcclusionFace {
+   public static float fixAoLightValue(float var0) {
+      return var0 == 0.2F ? aoLightValueOpaque : var0;
+   }
+
+   public static void updateAoLightValue() {
+      aoLightValueOpaque = 1.0F - Config.getAmbientOcclusionLevel() * 0.8F;
+      separateAoLightValue = Config.isShaders() && Shaders.isSeparateAo();
+   }
+
+   private void renderOverlayModels(
+      IBlockAccess var1, IBakedModel var2, IBlockState var3, BlockPos var4, BufferBuilder var5, boolean var6, long var7, RenderEnv var9, boolean var10
+   ) {
+      if (var9.isOverlaysRendered()) {
+         for (int var11 = 0; var11 < OVERLAY_LAYERS.length; var11++) {
+            BlockRenderLayer var12 = OVERLAY_LAYERS[var11];
+            ListQuadsOverlay var13 = var9.getListQuadsOverlay(var12);
+            if (var13.size() > 0) {
+               RegionRenderCacheBuilder var14 = var9.getRegionRenderCacheBuilder();
+               if (var14 != null) {
+                  BufferBuilder var15 = var14.getWorldRendererByLayer(var12);
+                  if (!var15.isDrawing()) {
+                     var15.begin(7, DefaultVertexFormats.BLOCK);
+                     var15.setTranslation(var5.getXOffset(), var5.getYOffset(), var5.getZOffset());
+                  }
+
+                  for (int var16 = 0; var16 < var13.size(); var16++) {
+                     BakedQuad var17 = var13.getQuad(var16);
+                     List var18 = var13.getListQuadsSingle(var17);
+                     IBlockState var19 = var13.getBlockState(var16);
+                     if (var17.getQuadEmissive() != null) {
+                        var13.addQuad(var17.getQuadEmissive(), var19);
+                     }
+
+                     var9.reset(var19, var4);
+                     if (var10) {
+                        this.renderQuadsSmooth(var1, var19, var4, var15, var18, var9);
+                     } else {
+                        int var20 = var19.b(var1, var4.offset(var17.getFace()));
+                        this.renderQuadsFlat(var1, var19, var4, var20, false, var15, var18, var9);
+                     }
+                  }
+               }
+
+               var13.clear();
+            }
+         }
+      }
+
+      if (Config.isBetterSnow() && !var9.isBreakingAnimation() && BetterSnow.shouldRender(var1, var3, var4)) {
+         IBakedModel var21 = BetterSnow.getModelSnowLayer();
+         IBlockState var22 = BetterSnow.getStateSnowLayer();
+         this.renderModel(var1, var21, var22, var4, var5, var6, var7);
+      }
+   }
+
+   public static class AmbientOcclusionFace {
       private final float[] vertexColorMultiplier = new float[4];
       private final int[] vertexBrightness = new int[4];
+      private MutableBlockPos[] blockPosArr = new MutableBlockPos[5];
 
       public AmbientOcclusionFace() {
+         this(null);
+      }
+
+      public AmbientOcclusionFace(BlockModelRenderer var1) {
+         for (int var2 = 0; var2 < this.blockPosArr.length; var2++) {
+            this.blockPosArr[var2] = new MutableBlockPos();
+         }
+      }
+
+      public void setMaxBlockLight() {
+         short var1 = 240;
+         this.vertexBrightness[0] = this.vertexBrightness[0] | var1;
+         this.vertexBrightness[1] = this.vertexBrightness[1] | var1;
+         this.vertexBrightness[2] = this.vertexBrightness[2] | var1;
+         this.vertexBrightness[3] = this.vertexBrightness[3] | var1;
+         this.vertexColorMultiplier[0] = 1.0F;
+         this.vertexColorMultiplier[1] = 1.0F;
+         this.vertexColorMultiplier[2] = 1.0F;
+         this.vertexColorMultiplier[3] = 1.0F;
       }
 
       public void updateVertexBrightness(IBlockAccess var1, IBlockState var2, BlockPos var3, EnumFacing var4, float[] var5, BitSet var6) {
          BlockPos var7 = var6.get(0) ? var3.offset(var4) : var3;
-         BlockPos.PooledMutableBlockPos var8 = BlockPos.PooledMutableBlockPos.retain();
+         MutableBlockPos var8 = this.blockPosArr[0].setPos(0, 0, 0);
          BlockModelRenderer.EnumNeighborInfo var9 = BlockModelRenderer.EnumNeighborInfo.getNeighbourInfo(var4);
-         BlockPos.PooledMutableBlockPos var10 = BlockPos.PooledMutableBlockPos.retain(var7).move(var9.corners[0]);
-         BlockPos.PooledMutableBlockPos var11 = BlockPos.PooledMutableBlockPos.retain(var7).move(var9.corners[1]);
-         BlockPos.PooledMutableBlockPos var12 = BlockPos.PooledMutableBlockPos.retain(var7).move(var9.corners[2]);
-         BlockPos.PooledMutableBlockPos var13 = BlockPos.PooledMutableBlockPos.retain(var7).move(var9.corners[3]);
-         int var14 = var2.getPackedLightmapCoords(var1, var10);
-         int var15 = var2.getPackedLightmapCoords(var1, var11);
-         int var16 = var2.getPackedLightmapCoords(var1, var12);
-         int var17 = var2.getPackedLightmapCoords(var1, var13);
-         float var18 = var1.getBlockState(var10).getAmbientOcclusionLightValue();
-         float var19 = var1.getBlockState(var11).getAmbientOcclusionLightValue();
-         float var20 = var1.getBlockState(var12).getAmbientOcclusionLightValue();
-         float var21 = var1.getBlockState(var13).getAmbientOcclusionLightValue();
-         boolean var22 = var1.getBlockState(var8.setPos(var10).move(var4)).isTranslucent();
-         boolean var23 = var1.getBlockState(var8.setPos(var11).move(var4)).isTranslucent();
-         boolean var24 = var1.getBlockState(var8.setPos(var12).move(var4)).isTranslucent();
-         boolean var25 = var1.getBlockState(var8.setPos(var13).move(var4)).isTranslucent();
-         float var26;
-         int var30;
+         MutableBlockPos var10 = this.blockPosArr[1].setPos(var7).move(var9.corners[0]);
+         MutableBlockPos var11 = this.blockPosArr[2].setPos(var7).move(var9.corners[1]);
+         MutableBlockPos var12 = this.blockPosArr[3].setPos(var7).move(var9.corners[2]);
+         MutableBlockPos var13 = this.blockPosArr[4].setPos(var7).move(var9.corners[3]);
+         int var14 = var2.b(var1, var10);
+         int var15 = var2.b(var1, var11);
+         int var16 = var2.b(var1, var12);
+         int var17 = var2.b(var1, var13);
+         float var18 = var1.getBlockState(var10).j();
+         float var19 = var1.getBlockState(var11).j();
+         float var20 = var1.getBlockState(var12).j();
+         float var21 = var1.getBlockState(var13).j();
+         var18 = BlockModelRenderer.fixAoLightValue(var18);
+         var19 = BlockModelRenderer.fixAoLightValue(var19);
+         var20 = BlockModelRenderer.fixAoLightValue(var20);
+         var21 = BlockModelRenderer.fixAoLightValue(var21);
+         boolean var22 = var1.getBlockState(var8.setPos(var10).move(var4)).e();
+         boolean var23 = var1.getBlockState(var8.setPos(var11).move(var4)).e();
+         boolean var24 = var1.getBlockState(var8.setPos(var12).move(var4)).e();
+         boolean var25 = var1.getBlockState(var8.setPos(var13).move(var4)).e();
+         int var27;
+         float var65;
          if (!var24 && !var22) {
-            var26 = var18;
-            var30 = var14;
+            var65 = var18;
+            var27 = var14;
          } else {
-            BlockPos.PooledMutableBlockPos var34 = var8.setPos(var10).move(var9.corners[2]);
-            var26 = var1.getBlockState(var34).getAmbientOcclusionLightValue();
-            var30 = var2.getPackedLightmapCoords(var1, var34);
+            MutableBlockPos var28 = var8.setPos(var10).move(var9.corners[2]);
+            var65 = var1.getBlockState(var28).j();
+            var65 = BlockModelRenderer.fixAoLightValue(var65);
+            var27 = var2.b(var1, var28);
          }
 
-         float var27;
-         int var31;
+         int var29;
+         float var67;
          if (!var25 && !var22) {
-            var27 = var18;
-            var31 = var14;
+            var67 = var18;
+            var29 = var14;
          } else {
-            BlockPos.PooledMutableBlockPos var61 = var8.setPos(var10).move(var9.corners[3]);
-            var27 = var1.getBlockState(var61).getAmbientOcclusionLightValue();
-            var31 = var2.getPackedLightmapCoords(var1, var61);
+            MutableBlockPos var30 = var8.setPos(var10).move(var9.corners[3]);
+            var67 = var1.getBlockState(var30).j();
+            var67 = BlockModelRenderer.fixAoLightValue(var67);
+            var29 = var2.b(var1, var30);
          }
 
-         float var28;
-         int var32;
+         int var31;
+         float var69;
          if (!var24 && !var23) {
-            var28 = var19;
-            var32 = var15;
+            var69 = var19;
+            var31 = var15;
          } else {
-            BlockPos.PooledMutableBlockPos var62 = var8.setPos(var11).move(var9.corners[2]);
-            var28 = var1.getBlockState(var62).getAmbientOcclusionLightValue();
-            var32 = var2.getPackedLightmapCoords(var1, var62);
+            MutableBlockPos var32 = var8.setPos(var11).move(var9.corners[2]);
+            var69 = var1.getBlockState(var32).j();
+            var69 = BlockModelRenderer.fixAoLightValue(var69);
+            var31 = var2.b(var1, var32);
          }
 
-         float var29;
          int var33;
+         float var71;
          if (!var25 && !var23) {
-            var29 = var19;
+            var71 = var19;
             var33 = var15;
          } else {
-            BlockPos.PooledMutableBlockPos var63 = var8.setPos(var11).move(var9.corners[3]);
-            var29 = var1.getBlockState(var63).getAmbientOcclusionLightValue();
-            var33 = var2.getPackedLightmapCoords(var1, var63);
+            MutableBlockPos var34 = var8.setPos(var11).move(var9.corners[3]);
+            var71 = var1.getBlockState(var34).j();
+            var71 = BlockModelRenderer.fixAoLightValue(var71);
+            var33 = var2.b(var1, var34);
          }
 
-         int var64 = var2.getPackedLightmapCoords(var1, var3);
-         if (var6.get(0) || !var1.getBlockState(var3.offset(var4)).isOpaqueCube()) {
-            var64 = var2.getPackedLightmapCoords(var1, var3.offset(var4));
+         int var72 = var2.b(var1, var3);
+         if (var6.get(0) || !var1.getBlockState(var3.offset(var4)).p()) {
+            var72 = var2.b(var1, var3.offset(var4));
          }
 
-         float var35 = var6.get(0) ? var1.getBlockState(var7).getAmbientOcclusionLightValue() : var1.getBlockState(var3).getAmbientOcclusionLightValue();
+         float var35 = var6.get(0) ? var1.getBlockState(var7).j() : var1.getBlockState(var3).j();
+         var35 = BlockModelRenderer.fixAoLightValue(var35);
          BlockModelRenderer.VertexTranslations var36 = BlockModelRenderer.VertexTranslations.getVertexTranslations(var4);
-         var8.release();
-         var10.release();
-         var11.release();
-         var12.release();
-         var13.release();
          if (var6.get(1) && var9.doNonCubicWeight) {
-            float var65 = (var21 + var18 + var27 + var35) * 0.25F;
-            float var66 = (var20 + var18 + var26 + var35) * 0.25F;
-            float var67 = (var20 + var19 + var28 + var35) * 0.25F;
-            float var68 = (var21 + var19 + var29 + var35) * 0.25F;
+            float var74 = (var21 + var18 + var67 + var35) * 0.25F;
+            float var75 = (var20 + var18 + var65 + var35) * 0.25F;
+            float var76 = (var20 + var19 + var69 + var35) * 0.25F;
+            float var77 = (var21 + var19 + var71 + var35) * 0.25F;
             float var41 = var5[var9.vert0Weights[0].shape] * var5[var9.vert0Weights[1].shape];
             float var42 = var5[var9.vert0Weights[2].shape] * var5[var9.vert0Weights[3].shape];
             float var43 = var5[var9.vert0Weights[4].shape] * var5[var9.vert0Weights[5].shape];
             float var44 = var5[var9.vert0Weights[6].shape] * var5[var9.vert0Weights[7].shape];
             float var45 = var5[var9.vert1Weights[0].shape] * var5[var9.vert1Weights[1].shape];
             float var46 = var5[var9.vert1Weights[2].shape] * var5[var9.vert1Weights[3].shape];
@@ -392,33 +578,33 @@
             float var51 = var5[var9.vert2Weights[4].shape] * var5[var9.vert2Weights[5].shape];
             float var52 = var5[var9.vert2Weights[6].shape] * var5[var9.vert2Weights[7].shape];
             float var53 = var5[var9.vert3Weights[0].shape] * var5[var9.vert3Weights[1].shape];
             float var54 = var5[var9.vert3Weights[2].shape] * var5[var9.vert3Weights[3].shape];
             float var55 = var5[var9.vert3Weights[4].shape] * var5[var9.vert3Weights[5].shape];
             float var56 = var5[var9.vert3Weights[6].shape] * var5[var9.vert3Weights[7].shape];
-            this.vertexColorMultiplier[var36.vert0] = var65 * var41 + var66 * var42 + var67 * var43 + var68 * var44;
-            this.vertexColorMultiplier[var36.vert1] = var65 * var45 + var66 * var46 + var67 * var47 + var68 * var48;
-            this.vertexColorMultiplier[var36.vert2] = var65 * var49 + var66 * var50 + var67 * var51 + var68 * var52;
-            this.vertexColorMultiplier[var36.vert3] = var65 * var53 + var66 * var54 + var67 * var55 + var68 * var56;
-            int var57 = this.getAoBrightness(var17, var14, var31, var64);
-            int var58 = this.getAoBrightness(var16, var14, var30, var64);
-            int var59 = this.getAoBrightness(var16, var15, var32, var64);
-            int var60 = this.getAoBrightness(var17, var15, var33, var64);
+            this.vertexColorMultiplier[var36.vert0] = var74 * var41 + var75 * var42 + var76 * var43 + var77 * var44;
+            this.vertexColorMultiplier[var36.vert1] = var74 * var45 + var75 * var46 + var76 * var47 + var77 * var48;
+            this.vertexColorMultiplier[var36.vert2] = var74 * var49 + var75 * var50 + var76 * var51 + var77 * var52;
+            this.vertexColorMultiplier[var36.vert3] = var74 * var53 + var75 * var54 + var76 * var55 + var77 * var56;
+            int var57 = this.getAoBrightness(var17, var14, var29, var72);
+            int var58 = this.getAoBrightness(var16, var14, var27, var72);
+            int var59 = this.getAoBrightness(var16, var15, var31, var72);
+            int var60 = this.getAoBrightness(var17, var15, var33, var72);
             this.vertexBrightness[var36.vert0] = this.getVertexBrightness(var57, var58, var59, var60, var41, var42, var43, var44);
             this.vertexBrightness[var36.vert1] = this.getVertexBrightness(var57, var58, var59, var60, var45, var46, var47, var48);
             this.vertexBrightness[var36.vert2] = this.getVertexBrightness(var57, var58, var59, var60, var49, var50, var51, var52);
             this.vertexBrightness[var36.vert3] = this.getVertexBrightness(var57, var58, var59, var60, var53, var54, var55, var56);
          } else {
-            float var37 = (var21 + var18 + var27 + var35) * 0.25F;
-            float var38 = (var20 + var18 + var26 + var35) * 0.25F;
-            float var39 = (var20 + var19 + var28 + var35) * 0.25F;
-            float var40 = (var21 + var19 + var29 + var35) * 0.25F;
-            this.vertexBrightness[var36.vert0] = this.getAoBrightness(var17, var14, var31, var64);
-            this.vertexBrightness[var36.vert1] = this.getAoBrightness(var16, var14, var30, var64);
-            this.vertexBrightness[var36.vert2] = this.getAoBrightness(var16, var15, var32, var64);
-            this.vertexBrightness[var36.vert3] = this.getAoBrightness(var17, var15, var33, var64);
+            float var37 = (var21 + var18 + var67 + var35) * 0.25F;
+            float var38 = (var20 + var18 + var65 + var35) * 0.25F;
+            float var39 = (var20 + var19 + var69 + var35) * 0.25F;
+            float var40 = (var21 + var19 + var71 + var35) * 0.25F;
+            this.vertexBrightness[var36.vert0] = this.getAoBrightness(var17, var14, var29, var72);
+            this.vertexBrightness[var36.vert1] = this.getAoBrightness(var16, var14, var27, var72);
+            this.vertexBrightness[var36.vert2] = this.getAoBrightness(var16, var15, var31, var72);
+            this.vertexBrightness[var36.vert3] = this.getAoBrightness(var17, var15, var33, var72);
             this.vertexColorMultiplier[var36.vert0] = var37;
             this.vertexColorMultiplier[var36.vert1] = var38;
             this.vertexColorMultiplier[var36.vert2] = var39;
             this.vertexColorMultiplier[var36.vert3] = var40;
          }
       }
--- net/minecraft/client/renderer/BlockModelShapes.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BlockModelShapes.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/BlockRendererDispatcher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BlockRendererDispatcher.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/BufferBuilder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/BufferBuilder.java	Mon Aug 18 09:39:52 2025
@@ -7,40 +7,62 @@
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import java.nio.ShortBuffer;
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Comparator;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.optifine.SmartAnimations;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.SVertexBuilder;
+import net.optifine.util.TextureUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.opengl.GL11;
 
 public class BufferBuilder {
    private static final Logger LOGGER = LogManager.getLogger();
    private ByteBuffer byteBuffer;
-   private IntBuffer rawIntBuffer;
+   public IntBuffer rawIntBuffer;
    private ShortBuffer rawShortBuffer;
-   private FloatBuffer rawFloatBuffer;
-   private int vertexCount;
+   public FloatBuffer rawFloatBuffer;
+   public int vertexCount;
    private VertexFormatElement vertexFormatElement;
    private int vertexFormatIndex;
    private boolean noColor;
-   private int drawMode;
+   public int drawMode;
    private double xOffset;
    private double yOffset;
    private double zOffset;
    private VertexFormat vertexFormat;
    private boolean isDrawing;
+   private BlockRenderLayer blockLayer = null;
+   private boolean[] drawnIcons = new boolean[256];
+   private TextureAtlasSprite[] quadSprites = null;
+   private TextureAtlasSprite[] quadSpritesPrev = null;
+   private TextureAtlasSprite quadSprite = null;
+   public SVertexBuilder sVertexBuilder;
+   public RenderEnv renderEnv = null;
+   public BitSet animatedSprites = null;
+   public BitSet animatedSpritesCached = new BitSet();
+   private boolean modeTriangles = false;
+   private ByteBuffer byteBufferTriangles;
 
    public BufferBuilder(int var1) {
       this.byteBuffer = GLAllocation.createDirectByteBuffer(var1 * 4);
       this.rawIntBuffer = this.byteBuffer.asIntBuffer();
       this.rawShortBuffer = this.byteBuffer.asShortBuffer();
       this.rawFloatBuffer = this.byteBuffer.asFloatBuffer();
+      SVertexBuilder.initVertexBuilder(this);
    }
 
    private void growBuffer(int var1) {
       if (MathHelper.roundUp(var1, 4) / 4 > this.rawIntBuffer.remaining() || this.vertexCount * this.vertexFormat.getSize() + var1 > this.byteBuffer.capacity()
          )
        {
@@ -50,17 +72,24 @@
          int var4 = this.rawIntBuffer.position();
          ByteBuffer var5 = GLAllocation.createDirectByteBuffer(var3);
          ((Buffer)this.byteBuffer).position(0);
          var5.put(this.byteBuffer);
          ((Buffer)var5).rewind();
          this.byteBuffer = var5;
-         this.rawFloatBuffer = this.byteBuffer.asFloatBuffer().asReadOnlyBuffer();
+         this.rawFloatBuffer = this.byteBuffer.asFloatBuffer();
          this.rawIntBuffer = this.byteBuffer.asIntBuffer();
          ((Buffer)this.rawIntBuffer).position(var4);
          this.rawShortBuffer = this.byteBuffer.asShortBuffer();
          ((Buffer)this.rawShortBuffer).position(var4 << 1);
+         if (this.quadSprites != null) {
+            TextureAtlasSprite[] var6 = this.quadSprites;
+            int var7 = this.getBufferQuadSize();
+            this.quadSprites = new TextureAtlasSprite[var7];
+            System.arraycopy(var6, 0, this.quadSprites, 0, Math.min(var6.length, this.quadSprites.length));
+            this.quadSpritesPrev = null;
+         }
       }
    }
 
    public void sortVertexData(float var1, float var2, float var3) {
       int var4 = this.vertexCount / 4;
       final float[] var5 = new float[var4];
@@ -114,26 +143,47 @@
             ((Buffer)this.rawIntBuffer).position(var10 * var8);
             this.rawIntBuffer.put(var9);
          }
 
          var16.set(var10);
       }
+
+      ((Buffer)this.rawIntBuffer).limit(this.rawIntBuffer.capacity());
+      ((Buffer)this.rawIntBuffer).position(this.getBufferSize());
+      if (this.quadSprites != null) {
+         TextureAtlasSprite[] var17 = new TextureAtlasSprite[this.vertexCount / 4];
+         int var18 = this.vertexFormat.getSize() / 4 * 4;
+
+         for (int var19 = 0; var19 < var15.length; var19++) {
+            int var20 = var15[var19];
+            var17[var19] = this.quadSprites[var20];
+         }
+
+         System.arraycopy(var17, 0, this.quadSprites, 0, var17.length);
+      }
    }
 
    public BufferBuilder.State getVertexState() {
       ((Buffer)this.rawIntBuffer).rewind();
       int var1 = this.getBufferSize();
       ((Buffer)this.rawIntBuffer).limit(var1);
       int[] var2 = new int[var1];
       this.rawIntBuffer.get(var2);
       ((Buffer)this.rawIntBuffer).limit(this.rawIntBuffer.capacity());
       ((Buffer)this.rawIntBuffer).position(var1);
-      return new BufferBuilder.State(var2, new VertexFormat(this.vertexFormat));
+      TextureAtlasSprite[] var3 = null;
+      if (this.quadSprites != null) {
+         int var4 = this.vertexCount / 4;
+         var3 = new TextureAtlasSprite[var4];
+         System.arraycopy(this.quadSprites, 0, var3, 0, var4);
+      }
+
+      return new BufferBuilder.State(var2, new VertexFormat(this.vertexFormat), var3);
    }
 
-   private int getBufferSize() {
+   public int getBufferSize() {
       return this.vertexCount * this.vertexFormat.getIntegerSize();
    }
 
    private static float getDistanceSq(FloatBuffer var0, float var1, float var2, float var3, int var4, int var5) {
       float var6 = var0.get(var5 + var4 * 0 + 0);
       float var7 = var0.get(var5 + var4 * 0 + 1);
@@ -156,18 +206,48 @@
    public void setVertexState(BufferBuilder.State var1) {
       ((Buffer)this.rawIntBuffer).clear();
       this.growBuffer(var1.getRawBuffer().length * 4);
       this.rawIntBuffer.put(var1.getRawBuffer());
       this.vertexCount = var1.getVertexCount();
       this.vertexFormat = new VertexFormat(var1.getVertexFormat());
+      if (var1.stateQuadSprites != null) {
+         if (this.quadSprites == null) {
+            this.quadSprites = this.quadSpritesPrev;
+         }
+
+         if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
+            this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
+         }
+
+         TextureAtlasSprite[] var2 = var1.stateQuadSprites;
+         System.arraycopy(var2, 0, this.quadSprites, 0, var2.length);
+      } else {
+         if (this.quadSprites != null) {
+            this.quadSpritesPrev = this.quadSprites;
+         }
+
+         this.quadSprites = null;
+      }
    }
 
    public void reset() {
       this.vertexCount = 0;
       this.vertexFormatElement = null;
       this.vertexFormatIndex = 0;
+      this.quadSprite = null;
+      if (SmartAnimations.isActive()) {
+         if (this.animatedSprites == null) {
+            this.animatedSprites = this.animatedSpritesCached;
+         }
+
+         this.animatedSprites.clear();
+      } else if (this.animatedSprites != null) {
+         this.animatedSprites = null;
+      }
+
+      this.modeTriangles = false;
    }
 
    public void begin(int var1, VertexFormat var2) {
       if (this.isDrawing) {
          throw new IllegalStateException("Already building!");
       } else {
@@ -175,16 +255,43 @@
          this.reset();
          this.drawMode = var1;
          this.vertexFormat = var2;
          this.vertexFormatElement = var2.getElement(this.vertexFormatIndex);
          this.noColor = false;
          ((Buffer)this.byteBuffer).limit(this.byteBuffer.capacity());
+         if (Config.isShaders()) {
+            SVertexBuilder.endSetVertexFormat(this);
+         }
+
+         if (Config.isMultiTexture()) {
+            if (this.blockLayer != null) {
+               if (this.quadSprites == null) {
+                  this.quadSprites = this.quadSpritesPrev;
+               }
+
+               if (this.quadSprites == null || this.quadSprites.length < this.getBufferQuadSize()) {
+                  this.quadSprites = new TextureAtlasSprite[this.getBufferQuadSize()];
+               }
+            }
+         } else {
+            if (this.quadSprites != null) {
+               this.quadSpritesPrev = this.quadSprites;
+            }
+
+            this.quadSprites = null;
+         }
       }
    }
 
    public BufferBuilder tex(double var1, double var3) {
+      if (this.quadSprite != null && this.quadSprites != null) {
+         var1 = this.quadSprite.toSingleU((float)var1);
+         var3 = this.quadSprite.toSingleV((float)var3);
+         this.quadSprites[this.vertexCount / 4] = this.quadSprite;
+      }
+
       int var5 = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
             this.byteBuffer.putFloat(var5, (float)var1);
             this.byteBuffer.putFloat(var5 + 4, (float)var3);
             break;
@@ -255,13 +362,13 @@
          this.rawIntBuffer.put(var10, Float.floatToRawIntBits((float)(var1 + this.xOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(var10))));
          this.rawIntBuffer.put(var11, Float.floatToRawIntBits((float)(var3 + this.yOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(var11))));
          this.rawIntBuffer.put(var12, Float.floatToRawIntBits((float)(var5 + this.zOffset) + Float.intBitsToFloat(this.rawIntBuffer.get(var12))));
       }
    }
 
-   private int getColorIndex(int var1) {
+   public int getColorIndex(int var1) {
       return ((this.vertexCount - var1) * this.vertexFormat.getSize() + this.vertexFormat.getColorOffset()) / 4;
    }
 
    public void putColorMultiplier(float var1, float var2, float var3, int var4) {
       int var5 = this.getColorIndex(var4);
       int var6 = -1;
@@ -269,19 +376,19 @@
          var6 = this.rawIntBuffer.get(var5);
          if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
             int var7 = (int)((var6 & 0xFF) * var1);
             int var8 = (int)((var6 >> 8 & 0xFF) * var2);
             int var9 = (int)((var6 >> 16 & 0xFF) * var3);
             var6 &= -16777216;
-            var6 |= var9 << 16 | var8 << 8 | var7;
+            var6 = var6 | var9 << 16 | var8 << 8 | var7;
          } else {
             int var13 = (int)((var6 >> 24 & 0xFF) * var1);
             int var14 = (int)((var6 >> 16 & 0xFF) * var2);
             int var15 = (int)((var6 >> 8 & 0xFF) * var3);
             var6 &= 255;
-            var6 |= var13 << 24 | var14 << 16 | var15 << 8;
+            var6 = var6 | var13 << 24 | var14 << 16 | var15 << 8;
          }
       }
 
       this.rawIntBuffer.put(var5, var6);
    }
 
@@ -298,13 +405,13 @@
       int var6 = MathHelper.clamp((int)(var1 * 255.0F), 0, 255);
       int var7 = MathHelper.clamp((int)(var2 * 255.0F), 0, 255);
       int var8 = MathHelper.clamp((int)(var3 * 255.0F), 0, 255);
       this.putColorRGBA(var5, var6, var7, var8);
    }
 
-   private void putColorRGBA(int var1, int var2, int var3, int var4) {
+   public void putColorRGBA(int var1, int var2, int var3, int var4) {
       if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
          this.rawIntBuffer.put(var1, 0xFF000000 | var4 << 16 | var3 << 8 | var2);
       } else {
          this.rawIntBuffer.put(var1, var2 << 24 | var3 << 16 | var4 << 8 | 0xFF);
       }
    }
@@ -361,24 +468,40 @@
          this.nextVertexFormatIndex();
          return this;
       }
    }
 
    public void addVertexData(int[] var1) {
-      this.growBuffer(var1.length * 4);
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertexData(this, var1);
+      }
+
+      this.growBuffer(var1.length * 4 + this.vertexFormat.getSize());
       ((Buffer)this.rawIntBuffer).position(this.getBufferSize());
       this.rawIntBuffer.put(var1);
       this.vertexCount = this.vertexCount + var1.length / this.vertexFormat.getIntegerSize();
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertexData(this);
+      }
    }
 
    public void endVertex() {
       this.vertexCount++;
       this.growBuffer(this.vertexFormat.getSize());
+      this.vertexFormatIndex = 0;
+      this.vertexFormatElement = this.vertexFormat.getElement(this.vertexFormatIndex);
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertex(this);
+      }
    }
 
    public BufferBuilder pos(double var1, double var3, double var5) {
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertex(this);
+      }
+
       int var7 = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
       switch (this.vertexFormatElement.getType()) {
          case FLOAT:
             this.byteBuffer.putFloat(var7, (float)(var1 + this.xOffset));
             this.byteBuffer.putFloat(var7 + 4, (float)(var3 + this.yOffset));
             this.byteBuffer.putFloat(var7 + 8, (float)(var5 + this.zOffset));
@@ -420,13 +543,13 @@
    }
 
    private void nextVertexFormatIndex() {
       this.vertexFormatIndex++;
       this.vertexFormatIndex = this.vertexFormatIndex % this.vertexFormat.getElementCount();
       this.vertexFormatElement = this.vertexFormat.getElement(this.vertexFormatIndex);
-      if (this.vertexFormatElement.getUsage() == VertexFormatElement.EnumUsage.PADDING) {
+      if (this.vertexFormatElement.getUsage() == EnumUsage.PADDING) {
          this.nextVertexFormatIndex();
       }
    }
 
    public BufferBuilder normal(float var1, float var2, float var3) {
       int var4 = this.vertexCount * this.vertexFormat.getSize() + this.vertexFormat.getOffset(this.vertexFormatIndex);
@@ -441,21 +564,21 @@
             this.byteBuffer.putInt(var4, (int)var1);
             this.byteBuffer.putInt(var4 + 4, (int)var2);
             this.byteBuffer.putInt(var4 + 8, (int)var3);
             break;
          case USHORT:
          case SHORT:
-            this.byteBuffer.putShort(var4, (short)((int)var1 * 32767 & 65535));
-            this.byteBuffer.putShort(var4 + 2, (short)((int)var2 * 32767 & 65535));
-            this.byteBuffer.putShort(var4 + 4, (short)((int)var3 * 32767 & 65535));
+            this.byteBuffer.putShort(var4, (short)((int)(var1 * 32767.0F) & 65535));
+            this.byteBuffer.putShort(var4 + 2, (short)((int)(var2 * 32767.0F) & 65535));
+            this.byteBuffer.putShort(var4 + 4, (short)((int)(var3 * 32767.0F) & 65535));
             break;
          case UBYTE:
          case BYTE:
-            this.byteBuffer.put(var4, (byte)((int)var1 * 127 & 0xFF));
-            this.byteBuffer.put(var4 + 1, (byte)((int)var2 * 127 & 0xFF));
-            this.byteBuffer.put(var4 + 2, (byte)((int)var3 * 127 & 0xFF));
+            this.byteBuffer.put(var4, (byte)((int)(var1 * 127.0F) & 0xFF));
+            this.byteBuffer.put(var4 + 1, (byte)((int)(var2 * 127.0F) & 0xFF));
+            this.byteBuffer.put(var4 + 2, (byte)((int)(var3 * 127.0F) & 0xFF));
       }
 
       this.nextVertexFormatIndex();
       return this;
    }
 
@@ -473,25 +596,25 @@
          ((Buffer)this.byteBuffer).position(0);
          ((Buffer)this.byteBuffer).limit(this.getBufferSize() * 4);
       }
    }
 
    public ByteBuffer getByteBuffer() {
-      return this.byteBuffer;
+      return this.modeTriangles ? this.byteBufferTriangles : this.byteBuffer;
    }
 
    public VertexFormat getVertexFormat() {
       return this.vertexFormat;
    }
 
    public int getVertexCount() {
-      return this.vertexCount;
+      return this.modeTriangles ? this.vertexCount / 4 * 6 : this.vertexCount;
    }
 
    public int getDrawMode() {
-      return this.drawMode;
+      return this.modeTriangles ? 4 : this.drawMode;
    }
 
    public void putColor4(int var1) {
       for (int var2 = 0; var2 < 4; var2++) {
          this.putColor(var1, var2 + 1);
       }
@@ -500,15 +623,263 @@
    public void putColorRGB_F4(float var1, float var2, float var3) {
       for (int var4 = 0; var4 < 4; var4++) {
          this.putColorRGB_F(var1, var2, var3, var4 + 1);
       }
    }
 
+   public void putSprite(TextureAtlasSprite var1) {
+      if (this.animatedSprites != null && var1 != null && var1.getAnimationIndex() >= 0) {
+         this.animatedSprites.set(var1.getAnimationIndex());
+      }
+
+      if (this.quadSprites != null) {
+         int var2 = this.vertexCount / 4;
+         this.quadSprites[var2 - 1] = var1;
+      }
+   }
+
+   public void setSprite(TextureAtlasSprite var1) {
+      if (this.animatedSprites != null && var1 != null && var1.getAnimationIndex() >= 0) {
+         this.animatedSprites.set(var1.getAnimationIndex());
+      }
+
+      if (this.quadSprites != null) {
+         this.quadSprite = var1;
+      }
+   }
+
+   public boolean isMultiTexture() {
+      return this.quadSprites != null;
+   }
+
+   public void drawMultiTexture() {
+      if (this.quadSprites != null) {
+         int var1 = Config.getMinecraft().getTextureMapBlocks().getCountRegisteredSprites();
+         if (this.drawnIcons.length <= var1) {
+            this.drawnIcons = new boolean[var1 + 1];
+         }
+
+         Arrays.fill(this.drawnIcons, false);
+         int var2 = 0;
+         int var3 = -1;
+         int var4 = this.vertexCount / 4;
+
+         for (int var5 = 0; var5 < var4; var5++) {
+            TextureAtlasSprite var6 = this.quadSprites[var5];
+            if (var6 != null) {
+               int var7 = var6.getIndexInMap();
+               if (!this.drawnIcons[var7]) {
+                  if (var6 == TextureUtils.iconGrassSideOverlay) {
+                     if (var3 < 0) {
+                        var3 = var5;
+                     }
+                  } else {
+                     var5 = this.drawForIcon(var6, var5) - 1;
+                     var2++;
+                     if (this.blockLayer != BlockRenderLayer.TRANSLUCENT) {
+                        this.drawnIcons[var7] = true;
+                     }
+                  }
+               }
+            }
+         }
+
+         if (var3 >= 0) {
+            this.drawForIcon(TextureUtils.iconGrassSideOverlay, var3);
+            var2++;
+         }
+
+         if (var2 > 0) {
+         }
+      }
+   }
+
+   private int drawForIcon(TextureAtlasSprite var1, int var2) {
+      GL11.glBindTexture(3553, var1.glSpriteTextureId);
+      int var3 = -1;
+      int var4 = -1;
+      int var5 = this.vertexCount / 4;
+
+      for (int var6 = var2; var6 < var5; var6++) {
+         TextureAtlasSprite var7 = this.quadSprites[var6];
+         if (var7 == var1) {
+            if (var4 < 0) {
+               var4 = var6;
+            }
+         } else if (var4 >= 0) {
+            this.draw(var4, var6);
+            if (this.blockLayer == BlockRenderLayer.TRANSLUCENT) {
+               return var6;
+            }
+
+            var4 = -1;
+            if (var3 < 0) {
+               var3 = var6;
+            }
+         }
+      }
+
+      if (var4 >= 0) {
+         this.draw(var4, var5);
+      }
+
+      if (var3 < 0) {
+         var3 = var5;
+      }
+
+      return var3;
+   }
+
+   private void draw(int var1, int var2) {
+      int var3 = var2 - var1;
+      if (var3 > 0) {
+         int var4 = var1 * 4;
+         int var5 = var3 * 4;
+         GL11.glDrawArrays(this.drawMode, var4, var5);
+      }
+   }
+
+   public void setBlockLayer(BlockRenderLayer var1) {
+      this.blockLayer = var1;
+      if (var1 == null) {
+         if (this.quadSprites != null) {
+            this.quadSpritesPrev = this.quadSprites;
+         }
+
+         this.quadSprites = null;
+         this.quadSprite = null;
+      }
+   }
+
+   private int getBufferQuadSize() {
+      return this.rawIntBuffer.capacity() * 4 / (this.vertexFormat.getIntegerSize() * 4);
+   }
+
+   public RenderEnv getRenderEnv(IBlockState var1, BlockPos var2) {
+      if (this.renderEnv == null) {
+         this.renderEnv = new RenderEnv(var1, var2);
+         return this.renderEnv;
+      } else {
+         this.renderEnv.reset(var1, var2);
+         return this.renderEnv;
+      }
+   }
+
+   public boolean isDrawing() {
+      return this.isDrawing;
+   }
+
+   public double getXOffset() {
+      return this.xOffset;
+   }
+
+   public double getYOffset() {
+      return this.yOffset;
+   }
+
+   public double getZOffset() {
+      return this.zOffset;
+   }
+
+   public BlockRenderLayer getBlockLayer() {
+      return this.blockLayer;
+   }
+
+   public void putColorMultiplierRgba(float var1, float var2, float var3, float var4, int var5) {
+      int var6 = this.getColorIndex(var5);
+      int var7 = -1;
+      if (!this.noColor) {
+         var7 = this.rawIntBuffer.get(var6);
+         if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+            int var8 = (int)((var7 & 0xFF) * var1);
+            int var9 = (int)((var7 >> 8 & 0xFF) * var2);
+            int var10 = (int)((var7 >> 16 & 0xFF) * var3);
+            int var11 = (int)((var7 >> 24 & 0xFF) * var4);
+            var7 = var11 << 24 | var10 << 16 | var9 << 8 | var8;
+         } else {
+            int var13 = (int)((var7 >> 24 & 0xFF) * var1);
+            int var14 = (int)((var7 >> 16 & 0xFF) * var2);
+            int var15 = (int)((var7 >> 8 & 0xFF) * var3);
+            int var16 = (int)((var7 & 0xFF) * var4);
+            var7 = var13 << 24 | var14 << 16 | var15 << 8 | var16;
+         }
+      }
+
+      this.rawIntBuffer.put(var6, var7);
+   }
+
+   public void quadsToTriangles() {
+      if (this.drawMode == 7) {
+         if (this.byteBufferTriangles == null) {
+            this.byteBufferTriangles = GLAllocation.createDirectByteBuffer(this.byteBuffer.capacity() * 2);
+         }
+
+         if (this.byteBufferTriangles.capacity() < this.byteBuffer.capacity() * 2) {
+            this.byteBufferTriangles = GLAllocation.createDirectByteBuffer(this.byteBuffer.capacity() * 2);
+         }
+
+         int var1 = this.vertexFormat.getSize();
+         int var2 = this.byteBuffer.limit();
+         ((Buffer)this.byteBuffer).rewind();
+         ((Buffer)this.byteBufferTriangles).clear();
+
+         for (byte var3 = 0; var3 < this.vertexCount; var3 += 4) {
+            ((Buffer)this.byteBuffer).limit((var3 + 3) * var1);
+            ((Buffer)this.byteBuffer).position(var3 * var1);
+            this.byteBufferTriangles.put(this.byteBuffer);
+            ((Buffer)this.byteBuffer).limit((var3 + 1) * var1);
+            ((Buffer)this.byteBuffer).position(var3 * var1);
+            this.byteBufferTriangles.put(this.byteBuffer);
+            ((Buffer)this.byteBuffer).limit((var3 + 2 + 2) * var1);
+            ((Buffer)this.byteBuffer).position((var3 + 2) * var1);
+            this.byteBufferTriangles.put(this.byteBuffer);
+         }
+
+         ((Buffer)this.byteBuffer).limit(var2);
+         ((Buffer)this.byteBuffer).rewind();
+         ((Buffer)this.byteBufferTriangles).flip();
+         this.modeTriangles = true;
+      }
+   }
+
+   public void putColorRGBA(int var1, int var2, int var3, int var4, int var5) {
+      if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+         this.rawIntBuffer.put(var1, var5 << 24 | var4 << 16 | var3 << 8 | var2);
+      } else {
+         this.rawIntBuffer.put(var1, var2 << 24 | var3 << 16 | var4 << 8 | var5);
+      }
+   }
+
+   public boolean isColorDisabled() {
+      return this.noColor;
+   }
+
+   public void putBulkData(ByteBuffer var1) {
+      if (Config.isShaders()) {
+         SVertexBuilder.beginAddVertexData(this, var1);
+      }
+
+      this.growBuffer(var1.limit() + this.vertexFormat.getSize());
+      ((Buffer)this.byteBuffer).position(this.vertexCount * this.vertexFormat.getSize());
+      this.byteBuffer.put(var1);
+      this.vertexCount = this.vertexCount + var1.limit() / this.vertexFormat.getSize();
+      if (Config.isShaders()) {
+         SVertexBuilder.endAddVertexData(this);
+      }
+   }
+
    public class State {
       private final int[] stateRawBuffer;
       private final VertexFormat stateVertexFormat;
+      private TextureAtlasSprite[] stateQuadSprites;
+
+      public State(int[] var2, VertexFormat var3, TextureAtlasSprite[] var4) {
+         this.stateRawBuffer = var2;
+         this.stateVertexFormat = var3;
+         this.stateQuadSprites = var4;
+      }
 
       public State(int[] var2, VertexFormat var3) {
          this.stateRawBuffer = var2;
          this.stateVertexFormat = var3;
       }
 
--- net/minecraft/client/renderer/ChestRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ChestRenderer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/ChunkRenderContainer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ChunkRenderContainer.java	Mon Aug 18 09:39:52 2025
@@ -1,34 +1,56 @@
 package net.minecraft.client.renderer;
 
 import com.google.common.collect.Lists;
+import java.util.BitSet;
 import java.util.List;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.math.BlockPos;
+import net.optifine.SmartAnimations;
 
 public abstract class ChunkRenderContainer {
    private double viewEntityX;
    private double viewEntityY;
    private double viewEntityZ;
    protected List<RenderChunk> renderChunks = Lists.newArrayListWithCapacity(17424);
    protected boolean initialized;
+   private BitSet animatedSpritesRendered;
+   private final BitSet animatedSpritesCached = new BitSet();
 
    public void initialize(double var1, double var3, double var5) {
       this.initialized = true;
       this.renderChunks.clear();
       this.viewEntityX = var1;
       this.viewEntityY = var3;
       this.viewEntityZ = var5;
+      if (SmartAnimations.isActive()) {
+         if (this.animatedSpritesRendered != null) {
+            SmartAnimations.spritesRendered(this.animatedSpritesRendered);
+         } else {
+            this.animatedSpritesRendered = this.animatedSpritesCached;
+         }
+
+         this.animatedSpritesRendered.clear();
+      } else if (this.animatedSpritesRendered != null) {
+         SmartAnimations.spritesRendered(this.animatedSpritesRendered);
+         this.animatedSpritesRendered = null;
+      }
    }
 
    public void preRenderChunk(RenderChunk var1) {
       BlockPos var2 = var1.getPosition();
       GlStateManager.translate((float)(var2.getX() - this.viewEntityX), (float)(var2.getY() - this.viewEntityY), (float)(var2.getZ() - this.viewEntityZ));
    }
 
    public void addRenderChunk(RenderChunk var1, BlockRenderLayer var2) {
       this.renderChunks.add(var1);
+      if (this.animatedSpritesRendered != null) {
+         BitSet var3 = var1.compiledChunk.getAnimatedSprites(var2);
+         if (var3 != null) {
+            this.animatedSpritesRendered.or(var3);
+         }
+      }
    }
 
    public abstract void renderChunkLayer(BlockRenderLayer var1);
 }
--- net/minecraft/client/renderer/DestroyBlockProgress.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/DestroyBlockProgress.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/EntityRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/EntityRenderer.java	Mon Aug 18 09:39:52 2025
@@ -2,38 +2,51 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.gson.JsonSyntaxException;
 import java.awt.Graphics2D;
 import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
 import java.io.IOException;
 import java.nio.Buffer;
 import java.nio.FloatBuffer;
+import java.util.Calendar;
+import java.util.Date;
 import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.gui.FontRenderer;
+import net.minecraft.client.gui.GuiChat;
+import net.minecraft.client.gui.GuiDownloadTerrain;
+import net.minecraft.client.gui.GuiMainMenu;
 import net.minecraft.client.gui.MapItemRenderer;
 import net.minecraft.client.gui.ScaledResolution;
+import net.minecraft.client.gui.advancements.GuiScreenAdvancements;
 import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.client.particle.ParticleManager;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
+import net.minecraft.client.renderer.chunk.RenderChunk;
+import net.minecraft.client.renderer.culling.ClippingHelper;
 import net.minecraft.client.renderer.culling.ClippingHelperImpl;
 import net.minecraft.client.renderer.culling.Frustum;
+import net.minecraft.client.renderer.culling.ICamera;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import net.minecraft.client.renderer.texture.TextureMap;
+import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
+import net.minecraft.client.resources.I18n;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
+import net.minecraft.client.settings.GameSettings;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.enchantment.EnchantmentHelper;
@@ -47,31 +60,56 @@
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.MobEffects;
 import net.minecraft.init.SoundEvents;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.item.ItemStack;
+import net.minecraft.server.integrated.IntegratedServer;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EntitySelectors;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.MouseFilter;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.ScreenShotHelper;
 import net.minecraft.util.SoundCategory;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
+import net.minecraft.util.math.RayTraceResult.Type;
+import net.minecraft.util.text.Style;
+import net.minecraft.util.text.TextComponentString;
+import net.minecraft.util.text.event.ClickEvent;
+import net.minecraft.util.text.event.ClickEvent.Action;
 import net.minecraft.world.GameType;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.biome.Biome;
+import net.optifine.CustomColors;
+import net.optifine.GlErrors;
+import net.optifine.Lagometer;
+import net.optifine.RandomEntities;
+import net.optifine.gui.GuiChatOF;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.reflect.ReflectorResolver;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
+import net.optifine.util.MemoryMonitor;
+import net.optifine.util.TextureUtils;
+import net.optifine.util.TimedEvent;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.glu.Project;
 
 public class EntityRenderer implements IResourceManagerReloadListener {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final ResourceLocation RAIN_TEXTURES = new ResourceLocation("textures/environment/rain.png");
@@ -79,18 +117,18 @@
    public static boolean anaglyphEnable;
    public static int anaglyphField;
    private final Minecraft mc;
    private final IResourceManager resourceManager;
    private final Random random = new Random();
    private float farPlaneDistance;
-   public final ItemRenderer itemRenderer;
+   public ItemRenderer itemRenderer;
    private final MapItemRenderer mapItemRenderer;
    private int rendererUpdateCount;
    private Entity pointedEntity;
-   private final MouseFilter mouseFilterXAxis = new MouseFilter();
-   private final MouseFilter mouseFilterYAxis = new MouseFilter();
+   private MouseFilter mouseFilterXAxis = new MouseFilter();
+   private MouseFilter mouseFilterYAxis = new MouseFilter();
    private final float thirdPersonDistance = 4.0F;
    private float thirdPersonDistancePrev = 4.0F;
    private float smoothCamYaw;
    private float smoothCamPitch;
    private float smoothCamFilterX;
    private float smoothCamFilterY;
@@ -112,15 +150,15 @@
    private float torchFlickerX;
    private float torchFlickerDX;
    private int rainSoundCounter;
    private final float[] rainXCoords = new float[1024];
    private final float[] rainYCoords = new float[1024];
    private final FloatBuffer fogColorBuffer = GLAllocation.createDirectFloatBuffer(16);
-   private float fogColorRed;
-   private float fogColorGreen;
-   private float fogColorBlue;
+   public float fogColorRed;
+   public float fogColorGreen;
+   public float fogColorBlue;
    private float fogColor2;
    private float fogColor1;
    private int debugViewDirection;
    private boolean debugView;
    private double cameraZoom = 1.0;
    private double cameraYaw;
@@ -154,17 +192,30 @@
       new ResourceLocation("shaders/post/blobs.json"),
       new ResourceLocation("shaders/post/antialias.json"),
       new ResourceLocation("shaders/post/creeper.json"),
       new ResourceLocation("shaders/post/spider.json")
    };
    public static final int SHADER_COUNT = SHADERS_TEXTURES.length;
-   private int shaderIndex = SHADER_COUNT;
+   private int shaderIndex;
    private boolean useShader;
-   private int frameCount;
+   public int frameCount;
+   private boolean initialized = false;
+   private World updatedWorld = null;
+   public boolean fogStandard = false;
+   private float clipDistance = 128.0F;
+   private long lastServerTime = 0L;
+   private int lastServerTicks = 0;
+   private int serverWaitTime = 0;
+   private int serverWaitTimeCurrent = 0;
+   private float avgServerTimeDiff = 0.0F;
+   private float avgServerTickDiff = 0.0F;
+   private ShaderGroup[] fxaaShaders = new ShaderGroup[10];
+   private boolean loadVisibleChunks = false;
 
    public EntityRenderer(Minecraft var1, IResourceManager var2) {
+      this.shaderIndex = SHADER_COUNT;
       this.mc = var1;
       this.resourceManager = var2;
       this.itemRenderer = var1.getItemRenderer();
       this.mapItemRenderer = new MapItemRenderer(var1.getTextureManager());
       this.lightmapTexture = new DynamicTexture(16, 16);
       this.locationLightMap = var1.getTextureManager().getDynamicTextureLocation("lightMap", this.lightmapTexture);
@@ -209,33 +260,36 @@
          if (var1 instanceof EntityCreeper) {
             this.loadShader(new ResourceLocation("shaders/post/creeper.json"));
          } else if (var1 instanceof EntitySpider) {
             this.loadShader(new ResourceLocation("shaders/post/spider.json"));
          } else if (var1 instanceof EntityEnderman) {
             this.loadShader(new ResourceLocation("shaders/post/invert.json"));
+         } else if (Reflector.ForgeHooksClient_loadEntityShader.exists()) {
+            Reflector.call(Reflector.ForgeHooksClient_loadEntityShader, new Object[]{var1, this});
          }
       }
    }
 
    private void loadShader(ResourceLocation var1) {
-      try {
-         this.shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), var1);
-         this.shaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
-         this.useShader = true;
-      } catch (IOException var3) {
-         LOGGER.warn("Failed to load shader: {}", var1, var3);
-         this.shaderIndex = SHADER_COUNT;
-         this.useShader = false;
-      } catch (JsonSyntaxException var4) {
-         LOGGER.warn("Failed to load shader: {}", var1, var4);
-         this.shaderIndex = SHADER_COUNT;
-         this.useShader = false;
+      if (OpenGlHelper.isFramebufferEnabled()) {
+         try {
+            this.shaderGroup = new ShaderGroup(this.mc.getTextureManager(), this.resourceManager, this.mc.getFramebuffer(), var1);
+            this.shaderGroup.createBindFramebuffers(this.mc.displayWidth, this.mc.displayHeight);
+            this.useShader = true;
+         } catch (IOException var3) {
+            LOGGER.warn("Failed to load shader: {}", var1, var3);
+            this.shaderIndex = SHADER_COUNT;
+            this.useShader = false;
+         } catch (JsonSyntaxException var4) {
+            LOGGER.warn("Failed to load shader: {}", var1, var4);
+            this.shaderIndex = SHADER_COUNT;
+            this.useShader = false;
+         }
       }
    }
 
-   @Override
    public void onResourceManagerReload(IResourceManager var1) {
       if (this.shaderGroup != null) {
          this.shaderGroup.deleteShaderGroup();
       }
 
       this.shaderGroup = null;
@@ -271,16 +325,21 @@
       }
 
       if (this.mc.getRenderViewEntity() == null) {
          this.mc.setRenderViewEntity(this.mc.player);
       }
 
-      float var4 = this.mc.world.getLightBrightness(new BlockPos(this.mc.getRenderViewEntity()));
-      float var5 = this.mc.gameSettings.renderDistanceChunks / 32.0F;
-      float var3 = var4 * (1.0F - var5) + var5;
-      this.fogColor1 = this.fogColor1 + (var3 - this.fogColor1) * 0.1F;
+      Entity var11 = this.mc.getRenderViewEntity();
+      double var12 = var11.posX;
+      double var4 = var11.posY + var11.getEyeHeight();
+      double var6 = var11.posZ;
+      float var8 = this.mc.world.getLightBrightness(new BlockPos(var12, var4, var6));
+      float var9 = this.mc.gameSettings.renderDistanceChunks / 16.0F;
+      var9 = MathHelper.clamp(var9, 0.0F, 1.0F);
+      float var10 = var8 * (1.0F - var9) + var9;
+      this.fogColor1 = this.fogColor1 + (var10 - this.fogColor1) * 0.1F;
       this.rendererUpdateCount++;
       this.itemRenderer.updateEquippedItem();
       this.addRainParticles();
       this.bossColorModifierPrev = this.bossColorModifier;
       if (this.mc.ingameGUI.getBossOverlay().shouldDarkenSky()) {
          this.bossColorModifier += 0.05F;
@@ -312,96 +371,93 @@
          this.mc.renderGlobal.createBindEntityOutlineFbs(var1, var2);
       }
    }
 
    public void getMouseOver(float var1) {
       Entity var2 = this.mc.getRenderViewEntity();
-      if (var2 != null) {
-         if (this.mc.world != null) {
-            this.mc.profiler.startSection("pick");
-            this.mc.pointedEntity = null;
-            double var3 = this.mc.playerController.getBlockReachDistance();
-            this.mc.objectMouseOver = var2.rayTrace(var3, var1);
-            Vec3d var5 = var2.getPositionEyes(var1);
-            boolean var6 = false;
-            byte var7 = 3;
-            double var8 = var3;
-            if (this.mc.playerController.extendedReach()) {
-               var8 = 6.0;
-               var3 = var8;
-            } else {
-               if (var3 > 3.0) {
-                  var6 = true;
-               }
-
-               var3 = var3;
-            }
-
-            if (this.mc.objectMouseOver != null) {
-               var8 = this.mc.objectMouseOver.hitVec.distanceTo(var5);
-            }
+      if (var2 != null && this.mc.world != null) {
+         this.mc.profiler.startSection("pick");
+         this.mc.pointedEntity = null;
+         double var3 = this.mc.playerController.getBlockReachDistance();
+         this.mc.objectMouseOver = var2.rayTrace(var3, var1);
+         Vec3d var5 = var2.getPositionEyes(var1);
+         boolean var6 = false;
+         byte var7 = 3;
+         double var8 = var3;
+         if (this.mc.playerController.extendedReach()) {
+            var8 = 6.0;
+            var3 = var8;
+         } else if (var3 > 3.0) {
+            var6 = true;
+         }
+
+         if (this.mc.objectMouseOver != null) {
+            var8 = this.mc.objectMouseOver.hitVec.distanceTo(var5);
+         }
+
+         Vec3d var10 = var2.getLook(1.0F);
+         Vec3d var11 = var5.add(var10.x * var3, var10.y * var3, var10.z * var3);
+         this.pointedEntity = null;
+         Vec3d var12 = null;
+         float var13 = 1.0F;
+         List var14 = this.mc
+            .world
+            .getEntitiesInAABBexcluding(
+               var2,
+               var2.getEntityBoundingBox().expand(var10.x * var3, var10.y * var3, var10.z * var3).grow(1.0, 1.0, 1.0),
+               Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>() {
+                  public boolean apply(@Nullable Entity var1) {
+                     return var1 != null && var1.canBeCollidedWith();
+                  }
+               })
+            );
+         double var15 = var8;
 
-            Vec3d var10 = var2.getLook(1.0F);
-            Vec3d var11 = var5.add(var10.x * var3, var10.y * var3, var10.z * var3);
-            this.pointedEntity = null;
-            Vec3d var12 = null;
-            float var13 = 1.0F;
-            List var14 = this.mc
-               .world
-               .getEntitiesInAABBexcluding(
-                  var2,
-                  var2.getEntityBoundingBox().expand(var10.x * var3, var10.y * var3, var10.z * var3).grow(1.0, 1.0, 1.0),
-                  Predicates.and(EntitySelectors.NOT_SPECTATING, new Predicate<Entity>() {
-                     public boolean apply(@Nullable Entity var1) {
-                        return var1 != null && var1.canBeCollidedWith();
-                     }
-                  })
-               );
-            double var15 = var8;
+         for (int var17 = 0; var17 < var14.size(); var17++) {
+            Entity var18 = (Entity)var14.get(var17);
+            AxisAlignedBB var19 = var18.getEntityBoundingBox().grow(var18.getCollisionBorderSize());
+            RayTraceResult var20 = var19.calculateIntercept(var5, var11);
+            if (var19.contains(var5)) {
+               if (var15 >= 0.0) {
+                  this.pointedEntity = var18;
+                  var12 = var20 == null ? var5 : var20.hitVec;
+                  var15 = 0.0;
+               }
+            } else if (var20 != null) {
+               double var21 = var5.distanceTo(var20.hitVec);
+               if (var21 < var15 || var15 == 0.0) {
+                  boolean var23 = false;
+                  if (Reflector.ForgeEntity_canRiderInteract.exists()) {
+                     var23 = Reflector.callBoolean(var18, Reflector.ForgeEntity_canRiderInteract, new Object[0]);
+                  }
 
-            for (int var17 = 0; var17 < var14.size(); var17++) {
-               Entity var18 = (Entity)var14.get(var17);
-               AxisAlignedBB var19 = var18.getEntityBoundingBox().grow(var18.getCollisionBorderSize());
-               RayTraceResult var20 = var19.calculateIntercept(var5, var11);
-               if (var19.contains(var5)) {
-                  if (var15 >= 0.0) {
+                  if (var23 || var18.getLowestRidingEntity() != var2.getLowestRidingEntity()) {
                      this.pointedEntity = var18;
-                     var12 = var20 == null ? var5 : var20.hitVec;
-                     var15 = 0.0;
-                  }
-               } else if (var20 != null) {
-                  double var21 = var5.distanceTo(var20.hitVec);
-                  if (var21 < var15 || var15 == 0.0) {
-                     if (var18.getLowestRidingEntity() == var2.getLowestRidingEntity()) {
-                        if (var15 == 0.0) {
-                           this.pointedEntity = var18;
-                           var12 = var20.hitVec;
-                        }
-                     } else {
-                        this.pointedEntity = var18;
-                        var12 = var20.hitVec;
-                        var15 = var21;
-                     }
+                     var12 = var20.hitVec;
+                     var15 = var21;
+                  } else if (var15 == 0.0) {
+                     this.pointedEntity = var18;
+                     var12 = var20.hitVec;
                   }
                }
             }
+         }
 
-            if (this.pointedEntity != null && var6 && var5.distanceTo(var12) > 3.0) {
-               this.pointedEntity = null;
-               this.mc.objectMouseOver = new RayTraceResult(RayTraceResult.Type.MISS, var12, null, new BlockPos(var12));
-            }
+         if (this.pointedEntity != null && var6 && var5.distanceTo(var12) > 3.0) {
+            this.pointedEntity = null;
+            this.mc.objectMouseOver = new RayTraceResult(Type.MISS, var12, (EnumFacing)null, new BlockPos(var12));
+         }
 
-            if (this.pointedEntity != null && (var15 < var8 || this.mc.objectMouseOver == null)) {
-               this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, var12);
-               if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
-                  this.mc.pointedEntity = this.pointedEntity;
-               }
+         if (this.pointedEntity != null && (var15 < var8 || this.mc.objectMouseOver == null)) {
+            this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, var12);
+            if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame) {
+               this.mc.pointedEntity = this.pointedEntity;
             }
-
-            this.mc.profiler.endSection();
          }
+
+         this.mc.profiler.endSection();
       }
    }
 
    private void updateFovModifierHand() {
       float var1 = 1.0F;
       if (this.mc.getRenderViewEntity() instanceof AbstractClientPlayer) {
@@ -425,26 +481,54 @@
          return 90.0F;
       } else {
          Entity var3 = this.mc.getRenderViewEntity();
          float var4 = 70.0F;
          if (var2) {
             var4 = this.mc.gameSettings.fovSetting;
-            var4 *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * var1;
+            if (Config.isDynamicFov()) {
+               var4 *= this.fovModifierHandPrev + (this.fovModifierHand - this.fovModifierHandPrev) * var1;
+            }
+         }
+
+         boolean var5 = false;
+         if (this.mc.currentScreen == null) {
+            var5 = GameSettings.isKeyDown(this.mc.gameSettings.ofKeyBindZoom);
+         }
+
+         if (var5) {
+            if (!Config.zoomMode) {
+               Config.zoomMode = true;
+               Config.zoomSmoothCamera = this.mc.gameSettings.smoothCamera;
+               this.mc.gameSettings.smoothCamera = true;
+               this.mc.renderGlobal.displayListEntitiesDirty = true;
+            }
+
+            if (Config.zoomMode) {
+               var4 /= 4.0F;
+            }
+         } else if (Config.zoomMode) {
+            Config.zoomMode = false;
+            this.mc.gameSettings.smoothCamera = Config.zoomSmoothCamera;
+            this.mouseFilterXAxis = new MouseFilter();
+            this.mouseFilterYAxis = new MouseFilter();
+            this.mc.renderGlobal.displayListEntitiesDirty = true;
          }
 
          if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).getHealth() <= 0.0F) {
-            float var5 = ((EntityLivingBase)var3).deathTime + var1;
-            var4 /= (1.0F - 500.0F / (var5 + 500.0F)) * 2.0F + 1.0F;
+            float var6 = ((EntityLivingBase)var3).deathTime + var1;
+            var4 /= (1.0F - 500.0F / (var6 + 500.0F)) * 2.0F + 1.0F;
          }
 
          IBlockState var7 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, var3, var1);
-         if (var7.getMaterial() == Material.WATER) {
+         if (var7.a() == Material.WATER) {
             var4 = var4 * 60.0F / 70.0F;
          }
 
-         return var4;
+         return Reflector.ForgeHooksClient_getFOVModifier.exists()
+            ? Reflector.callFloat(Reflector.ForgeHooksClient_getFOVModifier, new Object[]{this, var3, var7, var1, var4})
+            : var4;
       }
    }
 
    private void hurtCameraEffect(float var1) {
       if (this.mc.getRenderViewEntity() instanceof EntityLivingBase) {
          EntityLivingBase var2 = (EntityLivingBase)this.mc.getRenderViewEntity();
@@ -490,16 +574,18 @@
       if (var2 instanceof EntityLivingBase && ((EntityLivingBase)var2).isPlayerSleeping()) {
          var3 = (float)(var3 + 1.0);
          GlStateManager.translate(0.0F, 0.3F, 0.0F);
          if (!this.mc.gameSettings.debugCamEnable) {
             BlockPos var30 = new BlockPos(var2);
             IBlockState var11 = this.mc.world.getBlockState(var30);
-            Block var32 = var11.getBlock();
-            if (var32 == Blocks.BED) {
-               int var33 = var11.getValue(BlockBed.FACING).getHorizontalIndex();
-               GlStateManager.rotate(var33 * 90, 0.0F, 1.0F, 0.0F);
+            Block var36 = var11.getBlock();
+            if (Reflector.ForgeHooksClient_orientBedCamera.exists()) {
+               Reflector.callVoid(Reflector.ForgeHooksClient_orientBedCamera, new Object[]{this.mc.world, var30, var11, var2});
+            } else if (var36 == Blocks.BED) {
+               int var39 = ((EnumFacing)var11.getValue(BlockBed.D)).getHorizontalIndex();
+               GlStateManager.rotate(var39 * 90, 0.0F, 1.0F, 0.0F);
             }
 
             GlStateManager.rotate(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * var1 + 180.0F, 0.0F, -1.0F, 0.0F);
             GlStateManager.rotate(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * var1, -1.0F, 0.0F, 0.0F);
          }
       } else if (this.mc.gameSettings.thirdPersonView > 0) {
@@ -548,46 +634,79 @@
             GlStateManager.rotate(var13 - var2.rotationPitch, 1.0F, 0.0F, 0.0F);
          }
       } else {
          GlStateManager.translate(0.0F, 0.0F, 0.05F);
       }
 
-      if (!this.mc.gameSettings.debugCamEnable) {
+      if (Reflector.EntityViewRenderEvent_CameraSetup_Constructor.exists()) {
+         if (!this.mc.gameSettings.debugCamEnable) {
+            float var31 = var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * var1 + 180.0F;
+            float var34 = var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * var1;
+            float var37 = 0.0F;
+            if (var2 instanceof EntityAnimal) {
+               EntityAnimal var40 = (EntityAnimal)var2;
+               var31 = var40.aQ + (var40.aP - var40.aQ) * var1 + 180.0F;
+            }
+
+            IBlockState var41 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, var2, var1);
+            Object var42 = Reflector.newInstance(
+               Reflector.EntityViewRenderEvent_CameraSetup_Constructor, new Object[]{this, var2, var41, var1, var31, var34, var37}
+            );
+            Reflector.postForgeBusEvent(var42);
+            var37 = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_CameraSetup_getRoll, new Object[0]);
+            var34 = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_CameraSetup_getPitch, new Object[0]);
+            var31 = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_CameraSetup_getYaw, new Object[0]);
+            GlStateManager.rotate(var37, 0.0F, 0.0F, 1.0F);
+            GlStateManager.rotate(var34, 1.0F, 0.0F, 0.0F);
+            GlStateManager.rotate(var31, 0.0F, 1.0F, 0.0F);
+         }
+      } else if (!this.mc.gameSettings.debugCamEnable) {
          GlStateManager.rotate(var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * var1, 1.0F, 0.0F, 0.0F);
          if (var2 instanceof EntityAnimal) {
-            EntityAnimal var31 = (EntityAnimal)var2;
-            GlStateManager.rotate(var31.prevRotationYawHead + (var31.rotationYawHead - var31.prevRotationYawHead) * var1 + 180.0F, 0.0F, 1.0F, 0.0F);
+            EntityAnimal var33 = (EntityAnimal)var2;
+            GlStateManager.rotate(var33.aQ + (var33.aP - var33.aQ) * var1 + 180.0F, 0.0F, 1.0F, 0.0F);
          } else {
             GlStateManager.rotate(var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * var1 + 180.0F, 0.0F, 1.0F, 0.0F);
          }
       }
 
       GlStateManager.translate(0.0F, -var3, 0.0F);
       var4 = var2.prevPosX + (var2.posX - var2.prevPosX) * var1;
       var6 = var2.prevPosY + (var2.posY - var2.prevPosY) * var1 + var3;
       var8 = var2.prevPosZ + (var2.posZ - var2.prevPosZ) * var1;
       this.cloudFog = this.mc.renderGlobal.hasCloudFog(var4, var6, var8, var1);
    }
 
-   private void setupCameraTransform(float var1, int var2) {
+   public void setupCameraTransform(float var1, int var2) {
       this.farPlaneDistance = this.mc.gameSettings.renderDistanceChunks * 16;
+      if (Config.isFogFancy()) {
+         this.farPlaneDistance *= 0.95F;
+      }
+
+      if (Config.isFogFast()) {
+         this.farPlaneDistance *= 0.83F;
+      }
+
       GlStateManager.matrixMode(5889);
       GlStateManager.loadIdentity();
       float var3 = 0.07F;
       if (this.mc.gameSettings.anaglyph) {
          GlStateManager.translate(-(var2 * 2 - 1) * 0.07F, 0.0F, 0.0F);
       }
 
+      this.clipDistance = this.farPlaneDistance * 2.0F;
+      if (this.clipDistance < 173.0F) {
+         this.clipDistance = 173.0F;
+      }
+
       if (this.cameraZoom != 1.0) {
          GlStateManager.translate((float)this.cameraYaw, (float)(-this.cameraPitch), 0.0F);
          GlStateManager.scale(this.cameraZoom, this.cameraZoom, 1.0);
       }
 
-      Project.gluPerspective(
-         this.getFOVModifier(var1, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-      );
+      Project.gluPerspective(this.getFOVModifier(var1, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
       GlStateManager.matrixMode(5888);
       GlStateManager.loadIdentity();
       if (this.mc.gameSettings.anaglyph) {
          GlStateManager.translate((var2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
       }
 
@@ -629,42 +748,65 @@
                GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
          }
       }
    }
 
    private void renderHand(float var1, int var2) {
+      this.renderHand(var1, var2, true, true, false);
+   }
+
+   public void renderHand(float var1, int var2, boolean var3, boolean var4, boolean var5) {
       if (!this.debugView) {
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         float var3 = 0.07F;
+         float var6 = 0.07F;
          if (this.mc.gameSettings.anaglyph) {
             GlStateManager.translate(-(var2 * 2 - 1) * 0.07F, 0.0F, 0.0F);
          }
 
+         if (Config.isShaders()) {
+            Shaders.applyHandDepth();
+         }
+
          Project.gluPerspective(this.getFOVModifier(var1, false), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
          GlStateManager.matrixMode(5888);
          GlStateManager.loadIdentity();
          if (this.mc.gameSettings.anaglyph) {
             GlStateManager.translate((var2 * 2 - 1) * 0.1F, 0.0F, 0.0F);
          }
 
-         GlStateManager.pushMatrix();
-         this.hurtCameraEffect(var1);
-         if (this.mc.gameSettings.viewBobbing) {
-            this.applyBobbing(var1);
+         boolean var7 = false;
+         if (var3) {
+            GlStateManager.pushMatrix();
+            this.hurtCameraEffect(var1);
+            if (this.mc.gameSettings.viewBobbing) {
+               this.applyBobbing(var1);
+            }
+
+            var7 = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
+            boolean var8 = !ReflectorForge.renderFirstPersonHand(this.mc.renderGlobal, var1, var2);
+            if (var8 && this.mc.gameSettings.thirdPersonView == 0 && !var7 && !this.mc.gameSettings.hideGUI && !this.mc.playerController.isSpectator()) {
+               this.enableLightmap();
+               if (Config.isShaders()) {
+                  ShadersRender.renderItemFP(this.itemRenderer, var1, var5);
+               } else {
+                  this.itemRenderer.renderItemInFirstPerson(var1);
+               }
+
+               this.disableLightmap();
+            }
+
+            GlStateManager.popMatrix();
          }
 
-         boolean var4 = this.mc.getRenderViewEntity() instanceof EntityLivingBase && ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping();
-         if (this.mc.gameSettings.thirdPersonView == 0 && !var4 && !this.mc.gameSettings.hideGUI && !this.mc.playerController.isSpectator()) {
-            this.enableLightmap();
-            this.itemRenderer.renderItemInFirstPerson(var1);
-            this.disableLightmap();
+         if (!var4) {
+            return;
          }
 
-         GlStateManager.popMatrix();
-         if (this.mc.gameSettings.thirdPersonView == 0 && !var4) {
+         this.disableLightmap();
+         if (this.mc.gameSettings.thirdPersonView == 0 && !var7) {
             this.itemRenderer.renderOverlays(var1);
             this.hurtCameraEffect(var1);
          }
 
          if (this.mc.gameSettings.viewBobbing) {
             this.applyBobbing(var1);
@@ -673,12 +815,15 @@
    }
 
    public void disableLightmap() {
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
       GlStateManager.disableTexture2D();
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.disableLightmap();
+      }
    }
 
    public void enableLightmap() {
       GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
       GlStateManager.matrixMode(5890);
       GlStateManager.loadIdentity();
@@ -686,17 +831,20 @@
       GlStateManager.scale(0.00390625F, 0.00390625F, 0.00390625F);
       GlStateManager.translate(8.0F, 8.0F, 8.0F);
       GlStateManager.matrixMode(5888);
       this.mc.getTextureManager().bindTexture(this.locationLightMap);
       GlStateManager.glTexParameteri(3553, 10241, 9729);
       GlStateManager.glTexParameteri(3553, 10240, 9729);
-      GlStateManager.glTexParameteri(3553, 10242, 10496);
-      GlStateManager.glTexParameteri(3553, 10243, 10496);
+      GlStateManager.glTexParameteri(3553, 10242, 33071);
+      GlStateManager.glTexParameteri(3553, 10243, 33071);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.enableTexture2D();
       GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
+      if (Config.isShaders()) {
+         Shaders.enableLightmap();
+      }
    }
 
    private void updateTorchFlicker() {
       this.torchFlickerDX = (float)(this.torchFlickerDX + (Math.random() - Math.random()) * Math.random() * Math.random());
       this.torchFlickerDX = (float)(this.torchFlickerDX * 0.9);
       this.torchFlickerX = this.torchFlickerX + (this.torchFlickerDX - this.torchFlickerX);
@@ -705,130 +853,150 @@
 
    private void updateLightmap(float var1) {
       if (this.lightmapUpdateNeeded) {
          this.mc.profiler.startSection("lightTex");
          WorldClient var2 = this.mc.world;
          if (var2 != null) {
+            if (Config.isCustomColors()
+               && CustomColors.updateLightmap(var2, this.torchFlickerX, this.lightmapColors, this.mc.player.isPotionActive(MobEffects.NIGHT_VISION), var1)) {
+               this.lightmapTexture.updateDynamicTexture();
+               this.lightmapUpdateNeeded = false;
+               this.mc.profiler.endSection();
+               return;
+            }
+
             float var3 = var2.getSunBrightness(1.0F);
             float var4 = var3 * 0.95F + 0.05F;
 
             for (int var5 = 0; var5 < 256; var5++) {
                float var6 = var2.provider.getLightBrightnessTable()[var5 / 16] * var4;
                float var7 = var2.provider.getLightBrightnessTable()[var5 % 16] * (this.torchFlickerX * 0.1F + 1.5F);
                if (var2.getLastLightningBolt() > 0) {
                   var6 = var2.provider.getLightBrightnessTable()[var5 / 16];
                }
 
                float var8 = var6 * (var3 * 0.65F + 0.35F);
                float var9 = var6 * (var3 * 0.65F + 0.35F);
-               float var12 = var7 * ((var7 * 0.6F + 0.4F) * 0.6F + 0.4F);
-               float var13 = var7 * (var7 * var7 * 0.6F + 0.4F);
-               float var14 = var8 + var7;
-               float var15 = var9 + var12;
-               float var16 = var6 + var13;
+               float var10 = var7 * ((var7 * 0.6F + 0.4F) * 0.6F + 0.4F);
+               float var11 = var7 * (var7 * var7 * 0.6F + 0.4F);
+               float var12 = var8 + var7;
+               float var13 = var9 + var10;
+               float var14 = var6 + var11;
+               var12 = var12 * 0.96F + 0.03F;
+               var13 = var13 * 0.96F + 0.03F;
                var14 = var14 * 0.96F + 0.03F;
-               var15 = var15 * 0.96F + 0.03F;
-               var16 = var16 * 0.96F + 0.03F;
                if (this.bossColorModifier > 0.0F) {
-                  float var17 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * var1;
-                  var14 = var14 * (1.0F - var17) + var14 * 0.7F * var17;
-                  var15 = var15 * (1.0F - var17) + var15 * 0.6F * var17;
-                  var16 = var16 * (1.0F - var17) + var16 * 0.6F * var17;
+                  float var15 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * var1;
+                  var12 = var12 * (1.0F - var15) + var12 * 0.7F * var15;
+                  var13 = var13 * (1.0F - var15) + var13 * 0.6F * var15;
+                  var14 = var14 * (1.0F - var15) + var14 * 0.6F * var15;
                }
 
                if (var2.provider.getDimensionType().getId() == 1) {
-                  var14 = 0.22F + var7 * 0.75F;
-                  var15 = 0.28F + var12 * 0.75F;
-                  var16 = 0.25F + var13 * 0.75F;
-               }
-
+                  var12 = 0.22F + var7 * 0.75F;
+                  var13 = 0.28F + var10 * 0.75F;
+                  var14 = 0.25F + var11 * 0.75F;
+               }
+
+               if (Reflector.ForgeWorldProvider_getLightmapColors.exists()) {
+                  float[] var35 = new float[]{var12, var13, var14};
+                  Reflector.call(var2.provider, Reflector.ForgeWorldProvider_getLightmapColors, new Object[]{var1, var3, var6, var7, var35});
+                  var12 = var35[0];
+                  var13 = var35[1];
+                  var14 = var35[2];
+               }
+
+               var12 = MathHelper.clamp(var12, 0.0F, 1.0F);
+               var13 = MathHelper.clamp(var13, 0.0F, 1.0F);
+               var14 = MathHelper.clamp(var14, 0.0F, 1.0F);
                if (this.mc.player.isPotionActive(MobEffects.NIGHT_VISION)) {
-                  float var34 = this.getNightVisionBrightness(this.mc.player, var1);
-                  float var18 = 1.0F / var14;
-                  if (var18 > 1.0F / var15) {
-                     var18 = 1.0F / var15;
+                  float var36 = this.getNightVisionBrightness(this.mc.player, var1);
+                  float var16 = 1.0F / var12;
+                  if (var16 > 1.0F / var13) {
+                     var16 = 1.0F / var13;
                   }
 
-                  if (var18 > 1.0F / var16) {
-                     var18 = 1.0F / var16;
+                  if (var16 > 1.0F / var14) {
+                     var16 = 1.0F / var14;
                   }
 
-                  var14 = var14 * (1.0F - var34) + var14 * var18 * var34;
-                  var15 = var15 * (1.0F - var34) + var15 * var18 * var34;
-                  var16 = var16 * (1.0F - var34) + var16 * var18 * var34;
+                  var12 = var12 * (1.0F - var36) + var12 * var16 * var36;
+                  var13 = var13 * (1.0F - var36) + var13 * var16 * var36;
+                  var14 = var14 * (1.0F - var36) + var14 * var16 * var36;
+               }
+
+               if (var12 > 1.0F) {
+                  var12 = 1.0F;
+               }
+
+               if (var13 > 1.0F) {
+                  var13 = 1.0F;
                }
 
                if (var14 > 1.0F) {
                   var14 = 1.0F;
                }
 
-               if (var15 > 1.0F) {
-                  var15 = 1.0F;
+               float var37 = this.mc.gameSettings.gammaSetting;
+               float var38 = 1.0F - var12;
+               float var17 = 1.0F - var13;
+               float var18 = 1.0F - var14;
+               var38 = 1.0F - var38 * var38 * var38 * var38;
+               var17 = 1.0F - var17 * var17 * var17 * var17;
+               var18 = 1.0F - var18 * var18 * var18 * var18;
+               var12 = var12 * (1.0F - var37) + var38 * var37;
+               var13 = var13 * (1.0F - var37) + var17 * var37;
+               var14 = var14 * (1.0F - var37) + var18 * var37;
+               var12 = var12 * 0.96F + 0.03F;
+               var13 = var13 * 0.96F + 0.03F;
+               var14 = var14 * 0.96F + 0.03F;
+               if (var12 > 1.0F) {
+                  var12 = 1.0F;
                }
 
-               if (var16 > 1.0F) {
-                  var16 = 1.0F;
+               if (var13 > 1.0F) {
+                  var13 = 1.0F;
                }
 
-               float var35 = this.mc.gameSettings.gammaSetting;
-               float var36 = 1.0F - var14;
-               float var19 = 1.0F - var15;
-               float var20 = 1.0F - var16;
-               var36 = 1.0F - var36 * var36 * var36 * var36;
-               var19 = 1.0F - var19 * var19 * var19 * var19;
-               var20 = 1.0F - var20 * var20 * var20 * var20;
-               var14 = var14 * (1.0F - var35) + var36 * var35;
-               var15 = var15 * (1.0F - var35) + var19 * var35;
-               var16 = var16 * (1.0F - var35) + var20 * var35;
-               var14 = var14 * 0.96F + 0.03F;
-               var15 = var15 * 0.96F + 0.03F;
-               var16 = var16 * 0.96F + 0.03F;
                if (var14 > 1.0F) {
                   var14 = 1.0F;
                }
 
-               if (var15 > 1.0F) {
-                  var15 = 1.0F;
+               if (var12 < 0.0F) {
+                  var12 = 0.0F;
                }
 
-               if (var16 > 1.0F) {
-                  var16 = 1.0F;
+               if (var13 < 0.0F) {
+                  var13 = 0.0F;
                }
 
                if (var14 < 0.0F) {
                   var14 = 0.0F;
                }
 
-               if (var15 < 0.0F) {
-                  var15 = 0.0F;
-               }
-
-               if (var16 < 0.0F) {
-                  var16 = 0.0F;
-               }
-
-               short var21 = 255;
+               short var19 = 255;
+               int var20 = (int)(var12 * 255.0F);
+               int var21 = (int)(var13 * 255.0F);
                int var22 = (int)(var14 * 255.0F);
-               int var23 = (int)(var15 * 255.0F);
-               int var24 = (int)(var16 * 255.0F);
-               this.lightmapColors[var5] = 0xFF000000 | var22 << 16 | var23 << 8 | var24;
+               this.lightmapColors[var5] = 0xFF000000 | var20 << 16 | var21 << 8 | var22;
             }
 
             this.lightmapTexture.updateDynamicTexture();
             this.lightmapUpdateNeeded = false;
             this.mc.profiler.endSection();
          }
       }
    }
 
-   private float getNightVisionBrightness(EntityLivingBase var1, float var2) {
+   public float getNightVisionBrightness(EntityLivingBase var1, float var2) {
       int var3 = var1.getActivePotionEffect(MobEffects.NIGHT_VISION).getDuration();
       return var3 > 200 ? 1.0F : 0.7F + MathHelper.sin((var3 - var2) * (float) Math.PI * 0.2F) * 0.3F;
    }
 
    public void updateCameraAndRender(float var1, long var2) {
+      this.frameInit();
       boolean var4 = Display.isActive();
       if (!var4 && this.mc.gameSettings.pauseOnLostFocus && (!this.mc.gameSettings.touchscreen || !Mouse.isButtonDown(1))) {
          if (Minecraft.getSystemTime() - this.prevFrameTime > 500L) {
             this.mc.displayInGameMenu();
          }
       } else {
@@ -875,13 +1043,23 @@
          final ScaledResolution var17 = new ScaledResolution(this.mc);
          int var18 = var17.getScaledWidth();
          int var20 = var17.getScaledHeight();
          final int var22 = Mouse.getX() * var18 / this.mc.displayWidth;
          final int var23 = var20 - Mouse.getY() * var20 / this.mc.displayHeight - 1;
          int var24 = this.mc.gameSettings.limitFramerate;
-         if (this.mc.world != null) {
+         if (this.mc.world == null) {
+            GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+            GlStateManager.matrixMode(5889);
+            GlStateManager.loadIdentity();
+            GlStateManager.matrixMode(5888);
+            GlStateManager.loadIdentity();
+            this.setupOverlayRendering();
+            this.renderEndNanoTime = System.nanoTime();
+            TileEntityRendererDispatcher.instance.renderEngine = this.mc.getTextureManager();
+            TileEntityRendererDispatcher.instance.fontRenderer = this.mc.fontRenderer;
+         } else {
             this.mc.profiler.startSection("level");
             int var11 = Math.min(Minecraft.getDebugFPS(), var24);
             var11 = Math.max(var11, 60);
             long var12 = System.nanoTime() - var2;
             long var14 = Math.max(1000000000 / var11 / 4 - var12, 0L);
             this.renderWorld(var1, System.nanoTime() + var14);
@@ -909,30 +1087,33 @@
             this.mc.profiler.endStartSection("gui");
             if (!this.mc.gameSettings.hideGUI || this.mc.currentScreen != null) {
                GlStateManager.alphaFunc(516, 0.1F);
                this.setupOverlayRendering();
                this.renderItemActivation(var18, var20, var1);
                this.mc.ingameGUI.renderGameOverlay(var1);
+               if (this.mc.gameSettings.ofShowFps && !this.mc.gameSettings.showDebugInfo) {
+                  Config.drawFps();
+               }
+
+               if (this.mc.gameSettings.showDebugInfo) {
+                  Lagometer.showLagometer(var17);
+               }
             }
 
             this.mc.profiler.endSection();
-         } else {
-            GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
-            GlStateManager.matrixMode(5889);
-            GlStateManager.loadIdentity();
-            GlStateManager.matrixMode(5888);
-            GlStateManager.loadIdentity();
-            this.setupOverlayRendering();
-            this.renderEndNanoTime = System.nanoTime();
          }
 
          if (this.mc.currentScreen != null) {
             GlStateManager.clear(256);
 
             try {
-               this.mc.currentScreen.drawScreen(var22, var23, this.mc.getTickLength());
+               if (Reflector.ForgeHooksClient_drawScreen.exists()) {
+                  Reflector.callVoid(Reflector.ForgeHooksClient_drawScreen, new Object[]{this.mc.currentScreen, var22, var23, this.mc.getTickLength()});
+               } else {
+                  this.mc.currentScreen.drawScreen(var22, var23, this.mc.getTickLength());
+               }
             } catch (Throwable var16) {
                CrashReport var26 = CrashReport.makeCrashReport(var16, "Rendering screen");
                CrashReportCategory var13 = var26.makeCategory("Screen render details");
                var13.addDetail("Screen name", new ICrashReportDetail<String>() {
                   public String call() throws Exception {
                      return EntityRenderer.this.mc.currentScreen.getClass().getCanonicalName();
@@ -959,12 +1140,20 @@
                   }
                );
                throw new ReportedException(var26);
             }
          }
       }
+
+      this.frameFinish();
+      this.waitForServerThread();
+      MemoryMonitor.update();
+      Lagometer.updateLagometer();
+      if (this.mc.gameSettings.ofProfiler) {
+         this.mc.gameSettings.showDebugProfilerChart = true;
+      }
    }
 
    private void createWorldIcon() {
       if (this.mc.renderGlobal.getRenderedChunks() > 10 && this.mc.renderGlobal.hasNoChunkUpdates() && !this.mc.getIntegratedServer().isWorldIconSet()) {
          BufferedImage var1 = ScreenShotHelper.createScreenshot(this.mc.displayWidth, this.mc.displayHeight, this.mc.getFramebuffer());
          int var2 = var1.getWidth();
@@ -978,13 +1167,13 @@
             var5 = (var3 - var2) / 2;
          }
 
          try {
             BufferedImage var6 = new BufferedImage(64, 64, 1);
             Graphics2D var7 = var6.createGraphics();
-            var7.drawImage(var1, 0, 0, 64, 64, var4, var5, var4 + var2, var5 + var2, null);
+            var7.drawImage(var1, 0, 0, 64, 64, var4, var5, var4 + var2, var5 + var2, (ImageObserver)null);
             var7.dispose();
             ImageIO.write(var6, "png", this.mc.getIntegratedServer().getWorldIconFile());
          } catch (IOException var8) {
             LOGGER.warn("Couldn't save auto screenshot", var8);
          }
       }
@@ -999,19 +1188,20 @@
          return false;
       } else {
          Entity var1 = this.mc.getRenderViewEntity();
          boolean var2 = var1 instanceof EntityPlayer && !this.mc.gameSettings.hideGUI;
          if (var2 && !((EntityPlayer)var1).capabilities.allowEdit) {
             ItemStack var3 = ((EntityPlayer)var1).getHeldItemMainhand();
-            if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == RayTraceResult.Type.BLOCK) {
+            if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == Type.BLOCK) {
                BlockPos var4 = this.mc.objectMouseOver.getBlockPos();
-               Block var5 = this.mc.world.getBlockState(var4).getBlock();
+               IBlockState var5 = this.mc.world.getBlockState(var4);
+               Block var6 = var5.getBlock();
                if (this.mc.playerController.getCurrentGameType() == GameType.SPECTATOR) {
-                  var2 = var5.hasTileEntity() && this.mc.world.getTileEntity(var4) instanceof IInventory;
+                  var2 = ReflectorForge.blockHasTileEntity(var5) && this.mc.world.getTileEntity(var4) instanceof IInventory;
                } else {
-                  var2 = !var3.isEmpty() && (var3.canDestroy(var5) || var3.canPlaceOn(var5));
+                  var2 = !var3.isEmpty() && (var3.canDestroy(var6) || var3.canPlaceOn(var6));
                }
             }
          }
 
          return var2;
       }
@@ -1021,15 +1211,19 @@
       this.updateLightmap(var1);
       if (this.mc.getRenderViewEntity() == null) {
          this.mc.setRenderViewEntity(this.mc.player);
       }
 
       this.getMouseOver(var1);
+      if (Config.isShaders()) {
+         Shaders.beginRender(this.mc, var1, var2);
+      }
+
       GlStateManager.enableDepth();
       GlStateManager.enableAlpha();
-      GlStateManager.alphaFunc(516, 0.5F);
+      GlStateManager.alphaFunc(516, 0.1F);
       this.mc.profiler.startSection("center");
       if (this.mc.gameSettings.anaglyph) {
          anaglyphField = 0;
          GlStateManager.colorMask(false, true, true, false);
          this.renderWorldPass(0, var1, var2);
          anaglyphField = 1;
@@ -1041,186 +1235,345 @@
       }
 
       this.mc.profiler.endSection();
    }
 
    private void renderWorldPass(int var1, float var2, long var3) {
-      RenderGlobal var5 = this.mc.renderGlobal;
-      ParticleManager var6 = this.mc.effectRenderer;
-      boolean var7 = this.isDrawBlockOutline();
+      boolean var5 = Config.isShaders();
+      if (var5) {
+         Shaders.beginRenderPass(var1, var2, var3);
+      }
+
+      RenderGlobal var6 = this.mc.renderGlobal;
+      ParticleManager var7 = this.mc.effectRenderer;
+      boolean var8 = this.isDrawBlockOutline();
       GlStateManager.enableCull();
       this.mc.profiler.endStartSection("clear");
-      GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+      if (var5) {
+         Shaders.setViewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+      } else {
+         GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
+      }
+
       this.updateFogColor(var2);
       GlStateManager.clear(16640);
+      if (var5) {
+         Shaders.clearRenderBuffer();
+      }
+
       this.mc.profiler.endStartSection("camera");
       this.setupCameraTransform(var2, var1);
-      ActiveRenderInfo.updateRenderInfo(this.mc.player, this.mc.gameSettings.thirdPersonView == 2);
+      if (var5) {
+         Shaders.setCamera(var2);
+      }
+
+      if (Reflector.ActiveRenderInfo_updateRenderInfo2.exists()) {
+         Reflector.call(Reflector.ActiveRenderInfo_updateRenderInfo2, new Object[]{this.mc.getRenderViewEntity(), this.mc.gameSettings.thirdPersonView == 2});
+      } else {
+         ActiveRenderInfo.updateRenderInfo(this.mc.player, this.mc.gameSettings.thirdPersonView == 2);
+      }
+
       this.mc.profiler.endStartSection("frustum");
-      ClippingHelperImpl.getInstance();
+      ClippingHelper var9 = ClippingHelperImpl.getInstance();
       this.mc.profiler.endStartSection("culling");
-      Frustum var8 = new Frustum();
-      Entity var9 = this.mc.getRenderViewEntity();
-      double var10 = var9.lastTickPosX + (var9.posX - var9.lastTickPosX) * var2;
-      double var12 = var9.lastTickPosY + (var9.posY - var9.lastTickPosY) * var2;
-      double var14 = var9.lastTickPosZ + (var9.posZ - var9.lastTickPosZ) * var2;
-      var8.setPosition(var10, var12, var14);
-      if (this.mc.gameSettings.renderDistanceChunks >= 4) {
+      var9.disabled = Config.isShaders() && !Shaders.isFrustumCulling();
+      Frustum var10 = new Frustum(var9);
+      Entity var11 = this.mc.getRenderViewEntity();
+      double var12 = var11.lastTickPosX + (var11.posX - var11.lastTickPosX) * var2;
+      double var14 = var11.lastTickPosY + (var11.posY - var11.lastTickPosY) * var2;
+      double var16 = var11.lastTickPosZ + (var11.posZ - var11.lastTickPosZ) * var2;
+      if (var5) {
+         ShadersRender.setFrustrumPosition(var10, var12, var14, var16);
+      } else {
+         var10.setPosition(var12, var14, var16);
+      }
+
+      if ((Config.isSkyEnabled() || Config.isSunMoonEnabled() || Config.isStarsEnabled()) && !Shaders.isShadowPass) {
          this.setupFog(-1, var2);
          this.mc.profiler.endStartSection("sky");
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 2.0F);
+         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
-         var5.renderSky(var2, var1);
+         if (var5) {
+            Shaders.beginSky();
+         }
+
+         var6.renderSky(var2, var1);
+         if (var5) {
+            Shaders.endSky();
+         }
+
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(
-            this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-         );
+         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
+      } else {
+         GlStateManager.disableBlend();
       }
 
       this.setupFog(0, var2);
       GlStateManager.shadeModel(7425);
-      if (var9.posY + var9.getEyeHeight() < 128.0) {
-         this.renderCloudsCheck(var5, var2, var1, var10, var12, var14);
+      if (var11.posY + var11.getEyeHeight() < 128.0 + this.mc.gameSettings.ofCloudsHeight * 128.0F) {
+         this.renderCloudsCheck(var6, var2, var1, var12, var14, var16);
       }
 
       this.mc.profiler.endStartSection("prepareterrain");
       this.setupFog(0, var2);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       RenderHelper.disableStandardItemLighting();
       this.mc.profiler.endStartSection("terrain_setup");
-      var5.setupTerrain(var9, var2, var8, this.frameCount++, this.mc.player.isSpectator());
+      this.checkLoadVisibleChunks(var11, var2, var10, this.mc.player.isSpectator());
+      if (var5) {
+         ShadersRender.setupTerrain(var6, var11, var2, var10, this.frameCount++, this.mc.player.isSpectator());
+      } else {
+         var6.setupTerrain(var11, var2, var10, this.frameCount++, this.mc.player.isSpectator());
+      }
+
       if (var1 == 0 || var1 == 2) {
          this.mc.profiler.endStartSection("updatechunks");
+         Lagometer.timerChunkUpload.start();
          this.mc.renderGlobal.updateChunks(var3);
+         Lagometer.timerChunkUpload.end();
       }
 
       this.mc.profiler.endStartSection("terrain");
+      Lagometer.timerTerrain.start();
+      if (this.mc.gameSettings.ofSmoothFps && var1 > 0) {
+         this.mc.profiler.endStartSection("finish");
+         GL11.glFinish();
+         this.mc.profiler.endStartSection("terrain");
+      }
+
       GlStateManager.matrixMode(5888);
       GlStateManager.pushMatrix();
       GlStateManager.disableAlpha();
-      var5.renderBlockLayer(BlockRenderLayer.SOLID, var2, var1, var9);
+      if (var5) {
+         ShadersRender.beginTerrainSolid();
+      }
+
+      var6.renderBlockLayer(BlockRenderLayer.SOLID, var2, var1, var11);
       GlStateManager.enableAlpha();
-      var5.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, var2, var1, var9);
+      if (var5) {
+         ShadersRender.beginTerrainCutoutMipped();
+      }
+
+      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, this.mc.gameSettings.mipmapLevels > 0);
+      var6.renderBlockLayer(BlockRenderLayer.CUTOUT_MIPPED, var2, var1, var11);
+      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
       this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-      var5.renderBlockLayer(BlockRenderLayer.CUTOUT, var2, var1, var9);
+      if (var5) {
+         ShadersRender.beginTerrainCutout();
+      }
+
+      var6.renderBlockLayer(BlockRenderLayer.CUTOUT, var2, var1, var11);
       this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      if (var5) {
+         ShadersRender.endTerrain();
+      }
+
+      Lagometer.timerTerrain.end();
       GlStateManager.shadeModel(7424);
       GlStateManager.alphaFunc(516, 0.1F);
       if (!this.debugView) {
          GlStateManager.matrixMode(5888);
          GlStateManager.popMatrix();
          GlStateManager.pushMatrix();
          RenderHelper.enableStandardItemLighting();
          this.mc.profiler.endStartSection("entities");
-         var5.renderEntities(var9, var8, var2);
+         if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{0});
+         }
+
+         var6.renderEntities(var11, var10, var2);
+         if (Reflector.ForgeHooksClient_setRenderPass.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{-1});
+         }
+
          RenderHelper.disableStandardItemLighting();
          this.disableLightmap();
       }
 
       GlStateManager.matrixMode(5888);
       GlStateManager.popMatrix();
-      if (var7 && this.mc.objectMouseOver != null && !var9.isInsideOfMaterial(Material.WATER)) {
-         EntityPlayer var16 = (EntityPlayer)var9;
+      if (var8 && this.mc.objectMouseOver != null && !var11.isInsideOfMaterial(Material.WATER)) {
+         EntityPlayer var18 = (EntityPlayer)var11;
          GlStateManager.disableAlpha();
          this.mc.profiler.endStartSection("outline");
-         var5.drawSelectionBox(var16, this.mc.objectMouseOver, 0, var2);
+         if (!Reflector.ForgeHooksClient_onDrawBlockHighlight.exists()
+            || !Reflector.callBoolean(Reflector.ForgeHooksClient_onDrawBlockHighlight, new Object[]{var6, var18, this.mc.objectMouseOver, 0, var2})) {
+            var6.drawSelectionBox(var18, this.mc.objectMouseOver, 0, var2);
+         }
+
          GlStateManager.enableAlpha();
       }
 
       if (this.mc.debugRenderer.shouldRender()) {
+         boolean var19 = GlStateManager.isFogEnabled();
+         GlStateManager.disableFog();
          this.mc.debugRenderer.renderDebug(var2, var3);
+         GlStateManager.setFogEnabled(var19);
       }
 
-      this.mc.profiler.endStartSection("destroyProgress");
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
-      var5.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), var9, var2);
-      this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      if (!var6.damagedBlocks.isEmpty()) {
+         this.mc.profiler.endStartSection("destroyProgress");
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
+         );
+         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
+         var6.drawBlockDamageTexture(Tessellator.getInstance(), Tessellator.getInstance().getBuffer(), var11, var2);
+         this.mc.getTextureManager().getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+         GlStateManager.disableBlend();
+      }
+
+      GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
       GlStateManager.disableBlend();
       if (!this.debugView) {
          this.enableLightmap();
          this.mc.profiler.endStartSection("litParticles");
-         var6.renderLitParticles(var9, var2);
+         if (var5) {
+            Shaders.beginLitParticles();
+         }
+
+         var7.renderLitParticles(var11, var2);
          RenderHelper.disableStandardItemLighting();
          this.setupFog(0, var2);
          this.mc.profiler.endStartSection("particles");
-         var6.renderParticles(var9, var2);
+         if (var5) {
+            Shaders.beginParticles();
+         }
+
+         var7.renderParticles(var11, var2);
+         if (var5) {
+            Shaders.endParticles();
+         }
+
          this.disableLightmap();
       }
 
       GlStateManager.depthMask(false);
+      if (Config.isShaders()) {
+         GlStateManager.depthMask(Shaders.isRainDepth());
+      }
+
       GlStateManager.enableCull();
       this.mc.profiler.endStartSection("weather");
+      if (var5) {
+         Shaders.beginWeather();
+      }
+
       this.renderRainSnow(var2);
+      if (var5) {
+         Shaders.endWeather();
+      }
+
       GlStateManager.depthMask(true);
-      var5.renderWorldBorder(var9, var2);
+      var6.renderWorldBorder(var11, var2);
+      if (var5) {
+         ShadersRender.renderHand0(this, var2, var1);
+         Shaders.preWater();
+      }
+
       GlStateManager.disableBlend();
       GlStateManager.enableCull();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.alphaFunc(516, 0.1F);
       this.setupFog(0, var2);
       GlStateManager.enableBlend();
       GlStateManager.depthMask(false);
       this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       GlStateManager.shadeModel(7425);
       this.mc.profiler.endStartSection("translucent");
-      var5.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, var2, var1, var9);
+      if (var5) {
+         Shaders.beginWater();
+      }
+
+      var6.renderBlockLayer(BlockRenderLayer.TRANSLUCENT, var2, var1, var11);
+      if (var5) {
+         Shaders.endWater();
+      }
+
+      if (Reflector.ForgeHooksClient_setRenderPass.exists() && !this.debugView) {
+         RenderHelper.enableStandardItemLighting();
+         this.mc.profiler.endStartSection("entities");
+         Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{1});
+         this.mc.renderGlobal.renderEntities(var11, var10, var2);
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         Reflector.callVoid(Reflector.ForgeHooksClient_setRenderPass, new Object[]{-1});
+         RenderHelper.disableStandardItemLighting();
+      }
+
       GlStateManager.shadeModel(7424);
       GlStateManager.depthMask(true);
       GlStateManager.enableCull();
       GlStateManager.disableBlend();
       GlStateManager.disableFog();
-      if (var9.posY + var9.getEyeHeight() >= 128.0) {
+      if (var11.posY + var11.getEyeHeight() >= 128.0 + this.mc.gameSettings.ofCloudsHeight * 128.0F) {
          this.mc.profiler.endStartSection("aboveClouds");
-         this.renderCloudsCheck(var5, var2, var1, var10, var12, var14);
+         this.renderCloudsCheck(var6, var2, var1, var12, var14, var16);
+      }
+
+      if (Reflector.ForgeHooksClient_dispatchRenderLast.exists()) {
+         this.mc.profiler.endStartSection("forge_render_last");
+         Reflector.callVoid(Reflector.ForgeHooksClient_dispatchRenderLast, new Object[]{var6, var2});
       }
 
       this.mc.profiler.endStartSection("hand");
-      if (this.renderHand) {
+      if (this.renderHand && !Shaders.isShadowPass) {
+         if (var5) {
+            ShadersRender.renderHand1(this, var2, var1);
+            Shaders.renderCompositeFinal();
+         }
+
          GlStateManager.clear(256);
-         this.renderHand(var2, var1);
+         if (var5) {
+            ShadersRender.renderFPOverlay(this, var2, var1);
+         } else {
+            this.renderHand(var2, var1);
+         }
+      }
+
+      if (var5) {
+         Shaders.endRender();
       }
    }
 
    private void renderCloudsCheck(RenderGlobal var1, float var2, int var3, double var4, double var6, double var8) {
-      if (this.mc.gameSettings.shouldRenderClouds() != 0) {
+      if (this.mc.gameSettings.renderDistanceChunks >= 4 && !Config.isCloudsOff() && Shaders.shouldRenderClouds(this.mc.gameSettings)) {
          this.mc.profiler.endStartSection("clouds");
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * 4.0F);
+         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance * 4.0F);
          GlStateManager.matrixMode(5888);
          GlStateManager.pushMatrix();
          this.setupFog(0, var2);
          var1.renderClouds(var2, var3, var4, var6, var8);
          GlStateManager.disableFog();
          GlStateManager.popMatrix();
          GlStateManager.matrixMode(5889);
          GlStateManager.loadIdentity();
-         Project.gluPerspective(
-            this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.farPlaneDistance * MathHelper.SQRT_2
-         );
+         Project.gluPerspective(this.getFOVModifier(var2, true), (float)this.mc.displayWidth / this.mc.displayHeight, 0.05F, this.clipDistance);
          GlStateManager.matrixMode(5888);
       }
    }
 
    private void addRainParticles() {
       float var1 = this.mc.world.getRainStrength(1.0F);
-      if (!this.mc.gameSettings.fancyGraphics) {
+      if (!Config.isRainFancy()) {
          var1 /= 2.0F;
       }
 
-      if (var1 != 0.0F) {
+      if (var1 != 0.0F && Config.isRainSplash()) {
          this.random.setSeed(this.rendererUpdateCount * 312987231L);
          Entity var2 = this.mc.getRenderViewEntity();
          WorldClient var3 = this.mc.world;
          BlockPos var4 = new BlockPos(var2);
          byte var5 = 10;
          double var6 = 0.0;
@@ -1241,20 +1594,20 @@
             Biome var16 = var3.getBiome(var15);
             BlockPos var17 = var15.down();
             IBlockState var18 = var3.getBlockState(var17);
             if (var15.getY() <= var4.getY() + 10 && var15.getY() >= var4.getY() - 10 && var16.canRain() && var16.getTemperature(var15) >= 0.15F) {
                double var19 = this.random.nextDouble();
                double var21 = this.random.nextDouble();
-               AxisAlignedBB var23 = var18.getBoundingBox(var3, var17);
-               if (var18.getMaterial() == Material.LAVA || var18.getBlock() == Blocks.MAGMA) {
+               AxisAlignedBB var23 = var18.e(var3, var17);
+               if (var18.a() == Material.LAVA || var18.getBlock() == Blocks.MAGMA) {
                   this.mc
                      .world
                      .spawnParticle(
                         EnumParticleTypes.SMOKE_NORMAL, var15.getX() + var19, var15.getY() + 0.1F - var23.minY, var15.getZ() + var21, 0.0, 0.0, 0.0, new int[0]
                      );
-               } else if (var18.getMaterial() != Material.AIR) {
+               } else if (var18.a() != Material.AIR) {
                   if (this.random.nextInt(++var12) == 0) {
                      var6 = var17.getX() + var19;
                      var8 = var17.getY() + 0.1F + var23.maxY - 1.0;
                      var10 = var17.getZ() + var21;
                   }
 
@@ -1276,46 +1629,59 @@
             }
          }
       }
    }
 
    protected void renderRainSnow(float var1) {
-      float var2 = this.mc.world.getRainStrength(var1);
-      if (!(var2 <= 0.0F)) {
+      if (Reflector.ForgeWorldProvider_getWeatherRenderer.exists()) {
+         WorldProvider var2 = this.mc.world.provider;
+         Object var3 = Reflector.call(var2, Reflector.ForgeWorldProvider_getWeatherRenderer, new Object[0]);
+         if (var3 != null) {
+            Reflector.callVoid(var3, Reflector.IRenderHandler_render, new Object[]{var1, this.mc.world, this.mc});
+            return;
+         }
+      }
+
+      float var49 = this.mc.world.getRainStrength(var1);
+      if (var49 > 0.0F) {
+         if (Config.isRainOff()) {
+            return;
+         }
+
          this.enableLightmap();
-         Entity var3 = this.mc.getRenderViewEntity();
+         Entity var50 = this.mc.getRenderViewEntity();
          WorldClient var4 = this.mc.world;
-         int var5 = MathHelper.floor(var3.posX);
-         int var6 = MathHelper.floor(var3.posY);
-         int var7 = MathHelper.floor(var3.posZ);
+         int var5 = MathHelper.floor(var50.posX);
+         int var6 = MathHelper.floor(var50.posY);
+         int var7 = MathHelper.floor(var50.posZ);
          Tessellator var8 = Tessellator.getInstance();
          BufferBuilder var9 = var8.getBuffer();
          GlStateManager.disableCull();
          GlStateManager.glNormal3f(0.0F, 1.0F, 0.0F);
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
             GlStateManager.SourceFactor.ONE,
             GlStateManager.DestFactor.ZERO
          );
          GlStateManager.alphaFunc(516, 0.1F);
-         double var10 = var3.lastTickPosX + (var3.posX - var3.lastTickPosX) * var1;
-         double var12 = var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * var1;
-         double var14 = var3.lastTickPosZ + (var3.posZ - var3.lastTickPosZ) * var1;
+         double var10 = var50.lastTickPosX + (var50.posX - var50.lastTickPosX) * var1;
+         double var12 = var50.lastTickPosY + (var50.posY - var50.lastTickPosY) * var1;
+         double var14 = var50.lastTickPosZ + (var50.posZ - var50.lastTickPosZ) * var1;
          int var16 = MathHelper.floor(var12);
          byte var17 = 5;
-         if (this.mc.gameSettings.fancyGraphics) {
+         if (Config.isRainFancy()) {
             var17 = 10;
          }
 
          byte var18 = -1;
          float var19 = this.rendererUpdateCount + var1;
          var9.setTranslation(-var10, -var12, -var14);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-         BlockPos.MutableBlockPos var20 = new BlockPos.MutableBlockPos();
+         MutableBlockPos var20 = new MutableBlockPos();
 
          for (int var21 = var7 - var17; var21 <= var7 + var17; var21++) {
             for (int var22 = var5 - var17; var22 <= var5 + var17; var22++) {
                int var23 = (var21 - var7 + 16) * 32 + var22 - var5 + 16;
                double var24 = this.rainXCoords[var23] * 0.5;
                double var26 = this.rainYCoords[var23] * 0.5;
@@ -1355,16 +1721,16 @@
 
                         double var34 = -(
                               (double)(this.rendererUpdateCount + var22 * var22 * 3121 + var22 * 45238971 + var21 * var21 * 418711 + var21 * 13761 & 31) + var1
                            )
                            / 32.0
                            * (3.0 + this.random.nextDouble());
-                        double var36 = var22 + 0.5F - var3.posX;
-                        double var38 = var21 + 0.5F - var3.posZ;
+                        double var36 = var22 + 0.5F - var50.posX;
+                        double var38 = var21 + 0.5F - var50.posZ;
                         float var40 = MathHelper.sqrt(var36 * var36 + var38 * var38) / var17;
-                        float var41 = ((1.0F - var40 * var40) * 0.5F + 0.5F) * var2;
+                        float var41 = ((1.0F - var40 * var40) * 0.5F + 0.5F) * var49;
                         var20.setPos(var22, var32, var21);
                         int var42 = var4.getCombinedLight(var20, 0);
                         int var43 = var42 >> 16 & 65535;
                         int var44 = var42 & 65535;
                         var9.pos(var22 - var24 + 0.5, var31, var21 - var26 + 0.5)
                            .tex(0.0, var30 * 0.25 + var34)
@@ -1394,40 +1760,40 @@
 
                            var18 = 1;
                            this.mc.getTextureManager().bindTexture(SNOW_TEXTURES);
                            var9.begin(7, DefaultVertexFormats.PARTICLE_POSITION_TEX_COLOR_LMAP);
                         }
 
-                        double var49 = -((this.rendererUpdateCount & 511) + var1) / 512.0F;
-                        double var50 = this.random.nextDouble() + var19 * 0.01 * (float)this.random.nextGaussian();
-                        double var51 = this.random.nextDouble() + var19 * (float)this.random.nextGaussian() * 0.001;
-                        double var52 = var22 + 0.5F - var3.posX;
-                        double var53 = var21 + 0.5F - var3.posZ;
-                        float var54 = MathHelper.sqrt(var52 * var52 + var53 * var53) / var17;
-                        float var45 = ((1.0F - var54 * var54) * 0.3F + 0.5F) * var2;
+                        double var51 = -((this.rendererUpdateCount & 511) + var1) / 512.0F;
+                        double var52 = this.random.nextDouble() + var19 * 0.01 * (float)this.random.nextGaussian();
+                        double var53 = this.random.nextDouble() + var19 * (float)this.random.nextGaussian() * 0.001;
+                        double var54 = var22 + 0.5F - var50.posX;
+                        double var55 = var21 + 0.5F - var50.posZ;
+                        float var56 = MathHelper.sqrt(var54 * var54 + var55 * var55) / var17;
+                        float var45 = ((1.0F - var56 * var56) * 0.3F + 0.5F) * var49;
                         var20.setPos(var22, var32, var21);
                         int var46 = (var4.getCombinedLight(var20, 0) * 3 + 15728880) / 4;
                         int var47 = var46 >> 16 & 65535;
                         int var48 = var46 & 65535;
                         var9.pos(var22 - var24 + 0.5, var31, var21 - var26 + 0.5)
-                           .tex(0.0 + var50, var30 * 0.25 + var49 + var51)
+                           .tex(0.0 + var52, var30 * 0.25 + var51 + var53)
                            .color(1.0F, 1.0F, 1.0F, var45)
                            .lightmap(var47, var48)
                            .endVertex();
                         var9.pos(var22 + var24 + 0.5, var31, var21 + var26 + 0.5)
-                           .tex(1.0 + var50, var30 * 0.25 + var49 + var51)
+                           .tex(1.0 + var52, var30 * 0.25 + var51 + var53)
                            .color(1.0F, 1.0F, 1.0F, var45)
                            .lightmap(var47, var48)
                            .endVertex();
                         var9.pos(var22 + var24 + 0.5, var30, var21 + var26 + 0.5)
-                           .tex(1.0 + var50, var31 * 0.25 + var49 + var51)
+                           .tex(1.0 + var52, var31 * 0.25 + var51 + var53)
                            .color(1.0F, 1.0F, 1.0F, var45)
                            .lightmap(var47, var48)
                            .endVertex();
                         var9.pos(var22 - var24 + 0.5, var30, var21 - var26 + 0.5)
-                           .tex(0.0 + var50, var31 * 0.25 + var49 + var51)
+                           .tex(0.0 + var52, var31 * 0.25 + var51 + var53)
                            .color(1.0F, 1.0F, 1.0F, var45)
                            .lightmap(var47, var48)
                            .endVertex();
                      }
                   }
                }
@@ -1460,16 +1826,18 @@
    private void updateFogColor(float var1) {
       WorldClient var2 = this.mc.world;
       Entity var3 = this.mc.getRenderViewEntity();
       float var4 = 0.25F + 0.75F * this.mc.gameSettings.renderDistanceChunks / 32.0F;
       var4 = 1.0F - (float)Math.pow(var4, 0.25);
       Vec3d var5 = var2.getSkyColor(this.mc.getRenderViewEntity(), var1);
+      var5 = CustomColors.getWorldSkyColor(var5, var2, this.mc.getRenderViewEntity(), var1);
       float var6 = (float)var5.x;
       float var7 = (float)var5.y;
       float var8 = (float)var5.z;
       Vec3d var9 = var2.getFogColor(var1);
+      var9 = CustomColors.getWorldFogColor(var9, var2, this.mc.getRenderViewEntity(), var1);
       this.fogColorRed = (float)var9.x;
       this.fogColorGreen = (float)var9.y;
       this.fogColorBlue = (float)var9.z;
       if (this.mc.gameSettings.renderDistanceChunks >= 4) {
          double var10 = MathHelper.sin(var2.getCelestialAngleRadians(var1)) > 0.0F ? -1.0 : 1.0;
          Vec3d var12 = new Vec3d(var10, 0.0, 0.0);
@@ -1489,173 +1857,242 @@
          }
       }
 
       this.fogColorRed = this.fogColorRed + (var6 - this.fogColorRed) * var4;
       this.fogColorGreen = this.fogColorGreen + (var7 - this.fogColorGreen) * var4;
       this.fogColorBlue = this.fogColorBlue + (var8 - this.fogColorBlue) * var4;
-      float var20 = var2.getRainStrength(var1);
-      if (var20 > 0.0F) {
-         float var11 = 1.0F - var20 * 0.5F;
-         float var22 = 1.0F - var20 * 0.4F;
+      float var22 = var2.getRainStrength(var1);
+      if (var22 > 0.0F) {
+         float var11 = 1.0F - var22 * 0.5F;
+         float var24 = 1.0F - var22 * 0.4F;
          this.fogColorRed *= var11;
          this.fogColorGreen *= var11;
-         this.fogColorBlue *= var22;
+         this.fogColorBlue *= var24;
       }
 
-      float var21 = var2.getThunderStrength(var1);
-      if (var21 > 0.0F) {
-         float var23 = 1.0F - var21 * 0.5F;
-         this.fogColorRed *= var23;
-         this.fogColorGreen *= var23;
-         this.fogColorBlue *= var23;
+      float var23 = var2.getThunderStrength(var1);
+      if (var23 > 0.0F) {
+         float var25 = 1.0F - var23 * 0.5F;
+         this.fogColorRed *= var25;
+         this.fogColorGreen *= var25;
+         this.fogColorBlue *= var25;
       }
 
-      IBlockState var24 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, var3, var1);
+      IBlockState var26 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, var3, var1);
       if (this.cloudFog) {
-         Vec3d var26 = var2.getCloudColour(var1);
-         this.fogColorRed = (float)var26.x;
-         this.fogColorGreen = (float)var26.y;
-         this.fogColorBlue = (float)var26.z;
-      } else if (var24.getMaterial() == Material.WATER) {
-         float var27 = 0.0F;
+         Vec3d var28 = var2.getCloudColour(var1);
+         this.fogColorRed = (float)var28.x;
+         this.fogColorGreen = (float)var28.y;
+         this.fogColorBlue = (float)var28.z;
+      } else if (Reflector.ForgeBlock_getFogColor.exists()) {
+         Vec3d var29 = ActiveRenderInfo.projectViewFromEntity(var3, var1);
+         BlockPos var35 = new BlockPos(var29);
+         IBlockState var15 = this.mc.world.getBlockState(var35);
+         Vec3d var16 = (Vec3d)Reflector.call(
+            var15.getBlock(),
+            Reflector.ForgeBlock_getFogColor,
+            new Object[]{this.mc.world, var35, var15, var3, new Vec3d(this.fogColorRed, this.fogColorGreen, this.fogColorBlue), var1}
+         );
+         this.fogColorRed = (float)var16.x;
+         this.fogColorGreen = (float)var16.y;
+         this.fogColorBlue = (float)var16.z;
+      } else if (var26.a() == Material.WATER) {
+         float var30 = 0.0F;
          if (var3 instanceof EntityLivingBase) {
-            var27 = EnchantmentHelper.getRespirationModifier((EntityLivingBase)var3) * 0.2F;
+            var30 = EnchantmentHelper.getRespirationModifier((EntityLivingBase)var3) * 0.2F;
+            var30 = Config.limit(var30, 0.0F, 0.6F);
             if (((EntityLivingBase)var3).isPotionActive(MobEffects.WATER_BREATHING)) {
-               var27 = var27 * 0.3F + 0.6F;
+               var30 = var30 * 0.3F + 0.6F;
             }
          }
 
-         this.fogColorRed = 0.02F + var27;
-         this.fogColorGreen = 0.02F + var27;
-         this.fogColorBlue = 0.2F + var27;
-      } else if (var24.getMaterial() == Material.LAVA) {
+         this.fogColorRed = 0.02F + var30;
+         this.fogColorGreen = 0.02F + var30;
+         this.fogColorBlue = 0.2F + var30;
+      } else if (var26.a() == Material.LAVA) {
          this.fogColorRed = 0.6F;
          this.fogColorGreen = 0.1F;
          this.fogColorBlue = 0.0F;
       }
 
-      float var28 = this.fogColor2 + (this.fogColor1 - this.fogColor2) * var1;
-      this.fogColorRed *= var28;
-      this.fogColorGreen *= var28;
-      this.fogColorBlue *= var28;
-      double var29 = (var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * var1) * var2.provider.getVoidFogYFactor();
+      if (var26.a() == Material.WATER) {
+         Vec3d var32 = CustomColors.getUnderwaterColor(
+            this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (var32 != null) {
+            this.fogColorRed = (float)var32.x;
+            this.fogColorGreen = (float)var32.y;
+            this.fogColorBlue = (float)var32.z;
+         }
+      } else if (var26.a() == Material.LAVA) {
+         Vec3d var33 = CustomColors.getUnderlavaColor(
+            this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (var33 != null) {
+            this.fogColorRed = (float)var33.x;
+            this.fogColorGreen = (float)var33.y;
+            this.fogColorBlue = (float)var33.z;
+         }
+      }
+
+      float var34 = this.fogColor2 + (this.fogColor1 - this.fogColor2) * var1;
+      this.fogColorRed *= var34;
+      this.fogColorGreen *= var34;
+      this.fogColorBlue *= var34;
+      double var36 = (var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * var1) * var2.provider.getVoidFogYFactor();
       if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).isPotionActive(MobEffects.BLINDNESS)) {
-         int var16 = ((EntityLivingBase)var3).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
-         if (var16 < 20) {
-            var29 *= 1.0F - var16 / 20.0F;
+         int var38 = ((EntityLivingBase)var3).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
+         if (var38 < 20) {
+            var36 *= 1.0F - var38 / 20.0F;
          } else {
-            var29 = 0.0;
+            var36 = 0.0;
          }
       }
 
-      if (var29 < 1.0) {
-         if (var29 < 0.0) {
-            var29 = 0.0;
+      if (var36 < 1.0) {
+         if (var36 < 0.0) {
+            var36 = 0.0;
          }
 
-         var29 *= var29;
-         this.fogColorRed = (float)(this.fogColorRed * var29);
-         this.fogColorGreen = (float)(this.fogColorGreen * var29);
-         this.fogColorBlue = (float)(this.fogColorBlue * var29);
+         var36 *= var36;
+         this.fogColorRed = (float)(this.fogColorRed * var36);
+         this.fogColorGreen = (float)(this.fogColorGreen * var36);
+         this.fogColorBlue = (float)(this.fogColorBlue * var36);
       }
 
       if (this.bossColorModifier > 0.0F) {
-         float var31 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * var1;
-         this.fogColorRed = this.fogColorRed * (1.0F - var31) + this.fogColorRed * 0.7F * var31;
-         this.fogColorGreen = this.fogColorGreen * (1.0F - var31) + this.fogColorGreen * 0.6F * var31;
-         this.fogColorBlue = this.fogColorBlue * (1.0F - var31) + this.fogColorBlue * 0.6F * var31;
+         float var39 = this.bossColorModifierPrev + (this.bossColorModifier - this.bossColorModifierPrev) * var1;
+         this.fogColorRed = this.fogColorRed * (1.0F - var39) + this.fogColorRed * 0.7F * var39;
+         this.fogColorGreen = this.fogColorGreen * (1.0F - var39) + this.fogColorGreen * 0.6F * var39;
+         this.fogColorBlue = this.fogColorBlue * (1.0F - var39) + this.fogColorBlue * 0.6F * var39;
       }
 
       if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).isPotionActive(MobEffects.NIGHT_VISION)) {
-         float var32 = this.getNightVisionBrightness((EntityLivingBase)var3, var1);
+         float var40 = this.getNightVisionBrightness((EntityLivingBase)var3, var1);
          float var17 = 1.0F / this.fogColorRed;
          if (var17 > 1.0F / this.fogColorGreen) {
             var17 = 1.0F / this.fogColorGreen;
          }
 
          if (var17 > 1.0F / this.fogColorBlue) {
             var17 = 1.0F / this.fogColorBlue;
          }
 
-         this.fogColorRed = this.fogColorRed * (1.0F - var32) + this.fogColorRed * var17 * var32;
-         this.fogColorGreen = this.fogColorGreen * (1.0F - var32) + this.fogColorGreen * var17 * var32;
-         this.fogColorBlue = this.fogColorBlue * (1.0F - var32) + this.fogColorBlue * var17 * var32;
+         if (Float.isInfinite(var17)) {
+            var17 = Math.nextAfter(var17, 0.0);
+         }
+
+         this.fogColorRed = this.fogColorRed * (1.0F - var40) + this.fogColorRed * var17 * var40;
+         this.fogColorGreen = this.fogColorGreen * (1.0F - var40) + this.fogColorGreen * var17 * var40;
+         this.fogColorBlue = this.fogColorBlue * (1.0F - var40) + this.fogColorBlue * var17 * var40;
       }
 
       if (this.mc.gameSettings.anaglyph) {
-         float var33 = (this.fogColorRed * 30.0F + this.fogColorGreen * 59.0F + this.fogColorBlue * 11.0F) / 100.0F;
-         float var34 = (this.fogColorRed * 30.0F + this.fogColorGreen * 70.0F) / 100.0F;
+         float var41 = (this.fogColorRed * 30.0F + this.fogColorGreen * 59.0F + this.fogColorBlue * 11.0F) / 100.0F;
+         float var43 = (this.fogColorRed * 30.0F + this.fogColorGreen * 70.0F) / 100.0F;
          float var18 = (this.fogColorRed * 30.0F + this.fogColorBlue * 70.0F) / 100.0F;
-         this.fogColorRed = var33;
-         this.fogColorGreen = var34;
+         this.fogColorRed = var41;
+         this.fogColorGreen = var43;
          this.fogColorBlue = var18;
       }
 
-      GlStateManager.clearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
+      if (Reflector.EntityViewRenderEvent_FogColors_Constructor.exists()) {
+         Object var42 = Reflector.newInstance(
+            Reflector.EntityViewRenderEvent_FogColors_Constructor,
+            new Object[]{this, var3, var26, var1, this.fogColorRed, this.fogColorGreen, this.fogColorBlue}
+         );
+         Reflector.postForgeBusEvent(var42);
+         this.fogColorRed = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_FogColors_getRed, new Object[0]);
+         this.fogColorGreen = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_FogColors_getGreen, new Object[0]);
+         this.fogColorBlue = Reflector.callFloat(var42, Reflector.EntityViewRenderEvent_FogColors_getBlue, new Object[0]);
+      }
+
+      Shaders.setClearColor(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 0.0F);
    }
 
    private void setupFog(int var1, float var2) {
+      this.fogStandard = false;
       Entity var3 = this.mc.getRenderViewEntity();
       this.setupFogColor(false);
       GlStateManager.glNormal3f(0.0F, -1.0F, 0.0F);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       IBlockState var4 = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, var3, var2);
-      if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).isPotionActive(MobEffects.BLINDNESS)) {
-         float var7 = 5.0F;
-         int var6 = ((EntityLivingBase)var3).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
-         if (var6 < 20) {
-            var7 = 5.0F + (this.farPlaneDistance - 5.0F) * (1.0F - var6 / 20.0F);
+      float var5 = -1.0F;
+      if (Reflector.ForgeHooksClient_getFogDensity.exists()) {
+         var5 = Reflector.callFloat(Reflector.ForgeHooksClient_getFogDensity, new Object[]{this, var3, var4, var2, 0.1F});
+      }
+
+      if (var5 >= 0.0F) {
+         GlStateManager.setFogDensity(var5);
+      } else if (var3 instanceof EntityLivingBase && ((EntityLivingBase)var3).isPotionActive(MobEffects.BLINDNESS)) {
+         float var9 = 5.0F;
+         int var10 = ((EntityLivingBase)var3).getActivePotionEffect(MobEffects.BLINDNESS).getDuration();
+         if (var10 < 20) {
+            var9 = 5.0F + (this.farPlaneDistance - 5.0F) * (1.0F - var10 / 20.0F);
          }
 
          GlStateManager.setFog(GlStateManager.FogMode.LINEAR);
          if (var1 == -1) {
             GlStateManager.setFogStart(0.0F);
-            GlStateManager.setFogEnd(var7 * 0.8F);
+            GlStateManager.setFogEnd(var9 * 0.8F);
          } else {
-            GlStateManager.setFogStart(var7 * 0.25F);
-            GlStateManager.setFogEnd(var7);
+            GlStateManager.setFogStart(var9 * 0.25F);
+            GlStateManager.setFogEnd(var9);
          }
 
-         if (GLContext.getCapabilities().GL_NV_fog_distance) {
+         if (GLContext.getCapabilities().GL_NV_fog_distance && Config.isFogFancy()) {
             GlStateManager.glFogi(34138, 34139);
          }
       } else if (this.cloudFog) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
          GlStateManager.setFogDensity(0.1F);
-      } else if (var4.getMaterial() == Material.WATER) {
+      } else if (var4.a() == Material.WATER) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
+         float var6 = Config.isClearWater() ? 0.02F : 0.1F;
          if (var3 instanceof EntityLivingBase) {
             if (((EntityLivingBase)var3).isPotionActive(MobEffects.WATER_BREATHING)) {
                GlStateManager.setFogDensity(0.01F);
             } else {
-               GlStateManager.setFogDensity(0.1F - EnchantmentHelper.getRespirationModifier((EntityLivingBase)var3) * 0.03F);
+               float var7 = 0.1F - EnchantmentHelper.getRespirationModifier((EntityLivingBase)var3) * 0.03F;
+               GlStateManager.setFogDensity(Config.limit(var7, 0.0F, var6));
             }
          } else {
-            GlStateManager.setFogDensity(0.1F);
+            GlStateManager.setFogDensity(var6);
          }
-      } else if (var4.getMaterial() == Material.LAVA) {
+      } else if (var4.a() == Material.LAVA) {
          GlStateManager.setFog(GlStateManager.FogMode.EXP);
          GlStateManager.setFogDensity(2.0F);
       } else {
-         float var5 = this.farPlaneDistance;
+         float var8 = this.farPlaneDistance;
+         this.fogStandard = true;
          GlStateManager.setFog(GlStateManager.FogMode.LINEAR);
          if (var1 == -1) {
             GlStateManager.setFogStart(0.0F);
-            GlStateManager.setFogEnd(var5);
+            GlStateManager.setFogEnd(var8);
          } else {
-            GlStateManager.setFogStart(var5 * 0.75F);
-            GlStateManager.setFogEnd(var5);
+            GlStateManager.setFogStart(var8 * Config.getFogStart());
+            GlStateManager.setFogEnd(var8);
          }
 
          if (GLContext.getCapabilities().GL_NV_fog_distance) {
-            GlStateManager.glFogi(34138, 34139);
+            if (Config.isFogFancy()) {
+               GlStateManager.glFogi(34138, 34139);
+            }
+
+            if (Config.isFogFast()) {
+               GlStateManager.glFogi(34138, 34140);
+            }
          }
 
          if (this.mc.world.provider.doesXZShowFog((int)var3.posX, (int)var3.posZ) || this.mc.ingameGUI.getBossOverlay().shouldCreateFog()) {
-            GlStateManager.setFogStart(var5 * 0.05F);
-            GlStateManager.setFogEnd(Math.min(var5, 192.0F) * 0.5F);
+            GlStateManager.setFogStart(var8 * 0.05F);
+            GlStateManager.setFogEnd(var8);
+         }
+
+         if (Reflector.ForgeHooksClient_onFogRender.exists()) {
+            Reflector.callVoid(Reflector.ForgeHooksClient_onFogRender, new Object[]{this, var3, var4, var2, var1, var8});
          }
       }
 
       GlStateManager.enableColorMaterial();
       GlStateManager.enableFog();
       GlStateManager.colorMaterial(1028, 4608);
@@ -1667,12 +2104,16 @@
       } else {
          GlStateManager.glFog(2918, this.setFogColorBuffer(this.fogColorRed, this.fogColorGreen, this.fogColorBlue, 1.0F));
       }
    }
 
    private FloatBuffer setFogColorBuffer(float var1, float var2, float var3, float var4) {
+      if (Config.isShaders()) {
+         Shaders.setFogColor(var1, var2, var3);
+      }
+
       ((Buffer)this.fogColorBuffer).clear();
       this.fogColorBuffer.put(var1).put(var2).put(var3).put(var4);
       ((Buffer)this.fogColorBuffer).flip();
       return this.fogColorBuffer;
    }
 
@@ -1682,12 +2123,271 @@
    }
 
    public MapItemRenderer getMapItemRenderer() {
       return this.mapItemRenderer;
    }
 
+   private void waitForServerThread() {
+      this.serverWaitTimeCurrent = 0;
+      if (!Config.isSmoothWorld() || !Config.isSingleProcessor()) {
+         this.lastServerTime = 0L;
+         this.lastServerTicks = 0;
+      } else if (this.mc.isIntegratedServerRunning()) {
+         IntegratedServer var1 = this.mc.getIntegratedServer();
+         if (var1 != null) {
+            boolean var2 = this.mc.isGamePaused();
+            if (!var2 && !(this.mc.currentScreen instanceof GuiDownloadTerrain)) {
+               if (this.serverWaitTime > 0) {
+                  Lagometer.timerServer.start();
+                  Config.sleep(this.serverWaitTime);
+                  Lagometer.timerServer.end();
+                  this.serverWaitTimeCurrent = this.serverWaitTime;
+               }
+
+               long var3 = System.nanoTime() / 1000000L;
+               if (this.lastServerTime != 0L && this.lastServerTicks != 0) {
+                  long var5 = var3 - this.lastServerTime;
+                  if (var5 < 0L) {
+                     this.lastServerTime = var3;
+                     var5 = 0L;
+                  }
+
+                  if (var5 >= 50L) {
+                     this.lastServerTime = var3;
+                     int var7 = var1.getTickCounter();
+                     int var8 = var7 - this.lastServerTicks;
+                     if (var8 < 0) {
+                        this.lastServerTicks = var7;
+                        var8 = 0;
+                     }
+
+                     if (var8 < 1 && this.serverWaitTime < 100) {
+                        this.serverWaitTime += 2;
+                     }
+
+                     if (var8 > 1 && this.serverWaitTime > 0) {
+                        this.serverWaitTime--;
+                     }
+
+                     this.lastServerTicks = var7;
+                  }
+               } else {
+                  this.lastServerTime = var3;
+                  this.lastServerTicks = var1.getTickCounter();
+                  this.avgServerTickDiff = 1.0F;
+                  this.avgServerTimeDiff = 50.0F;
+               }
+            } else {
+               if (this.mc.currentScreen instanceof GuiDownloadTerrain) {
+                  Config.sleep(20L);
+               }
+
+               this.lastServerTime = 0L;
+               this.lastServerTicks = 0;
+            }
+         }
+      }
+   }
+
+   private void frameInit() {
+      GlErrors.frameStart();
+      if (!this.initialized) {
+         ReflectorResolver.resolve();
+         TextureUtils.registerResourceListener();
+         if (Config.getBitsOs() == 64 && Config.getBitsJre() == 32) {
+            Config.setNotify64BitJava(true);
+         }
+
+         this.initialized = true;
+      }
+
+      Config.checkDisplayMode();
+      WorldClient var1 = this.mc.world;
+      if (var1 != null) {
+         if (Config.getNewRelease() != null) {
+            String var2 = "HD_U".replace("HD_U", "HD Ultra").replace("L", "Light");
+            String var3 = var2 + " " + Config.getNewRelease();
+            TextComponentString var4 = new TextComponentString(I18n.format("of.message.newVersion", "§n" + var3 + "§r"));
+            var4.setStyle(new Style().setClickEvent(new ClickEvent(Action.OPEN_URL, "https://optifine.net/downloads")));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(var4);
+            Config.setNewRelease(null);
+         }
+
+         if (Config.isNotify64BitJava()) {
+            Config.setNotify64BitJava(false);
+            TextComponentString var5 = new TextComponentString(I18n.format("of.message.java64Bit"));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(var5);
+         }
+      }
+
+      if (this.mc.currentScreen instanceof GuiMainMenu) {
+         this.updateMainMenu((GuiMainMenu)this.mc.currentScreen);
+      }
+
+      if (this.updatedWorld != var1) {
+         RandomEntities.worldChanged(this.updatedWorld, var1);
+         Config.updateThreadPriorities();
+         this.lastServerTime = 0L;
+         this.lastServerTicks = 0;
+         this.updatedWorld = var1;
+      }
+
+      if (!this.setFxaaShader(Shaders.configAntialiasingLevel)) {
+         Shaders.configAntialiasingLevel = 0;
+      }
+
+      if (this.mc.currentScreen != null && this.mc.currentScreen.getClass() == GuiChat.class) {
+         this.mc.displayGuiScreen(new GuiChatOF((GuiChat)this.mc.currentScreen));
+      }
+   }
+
+   private void frameFinish() {
+      if (this.mc.world != null && Config.isShowGlErrors() && TimedEvent.isActive("CheckGlErrorFrameFinish", 10000L)) {
+         int var1 = GlStateManager.glGetError();
+         if (var1 != 0 && GlErrors.isEnabled(var1)) {
+            String var2 = Config.getGlErrorString(var1);
+            TextComponentString var3 = new TextComponentString(I18n.format("of.message.openglError", var1, var2));
+            this.mc.ingameGUI.getChatGUI().printChatMessage(var3);
+         }
+      }
+   }
+
+   private void updateMainMenu(GuiMainMenu var1) {
+      try {
+         String var2 = null;
+         Calendar var3 = Calendar.getInstance();
+         var3.setTime(new Date());
+         int var4 = var3.get(5);
+         int var5 = var3.get(2) + 1;
+         if (var4 == 8 && var5 == 4) {
+            var2 = "Happy birthday, OptiFine!";
+         }
+
+         if (var4 == 14 && var5 == 8) {
+            var2 = "Happy birthday, sp614x!";
+         }
+
+         if (var2 == null) {
+            return;
+         }
+
+         Reflector.setFieldValue(var1, Reflector.GuiMainMenu_splashText, var2);
+      } catch (Throwable var6) {
+      }
+   }
+
+   public boolean setFxaaShader(int var1) {
+      if (!OpenGlHelper.isFramebufferEnabled()) {
+         return false;
+      } else if (this.shaderGroup != null && this.shaderGroup != this.fxaaShaders[2] && this.shaderGroup != this.fxaaShaders[4]) {
+         return true;
+      } else if (var1 != 2 && var1 != 4) {
+         if (this.shaderGroup == null) {
+            return true;
+         } else {
+            this.shaderGroup.deleteShaderGroup();
+            this.shaderGroup = null;
+            return true;
+         }
+      } else if (this.shaderGroup != null && this.shaderGroup == this.fxaaShaders[var1]) {
+         return true;
+      } else if (this.mc.world == null) {
+         return true;
+      } else {
+         this.loadShader(new ResourceLocation("shaders/post/fxaa_of_" + var1 + "x.json"));
+         this.fxaaShaders[var1] = this.shaderGroup;
+         return this.useShader;
+      }
+   }
+
+   private void checkLoadVisibleChunks(Entity var1, float var2, ICamera var3, boolean var4) {
+      int var5 = 201435902;
+      if (this.loadVisibleChunks) {
+         this.loadVisibleChunks = false;
+         this.loadAllVisibleChunks(var1, var2, var3, var4);
+         this.mc.ingameGUI.getChatGUI().deleteChatLine(var5);
+      }
+
+      if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(38)) {
+         if (this.mc.gameSettings.keyBindAdvancements.getKeyCode() == 38) {
+            if (this.mc.currentScreen instanceof GuiScreenAdvancements) {
+               this.mc.displayGuiScreen(null);
+            }
+
+            while (Keyboard.next()) {
+            }
+         }
+
+         if (this.mc.currentScreen != null) {
+            return;
+         }
+
+         this.loadVisibleChunks = true;
+         TextComponentString var6 = new TextComponentString(I18n.format("of.message.loadingVisibleChunks"));
+         this.mc.ingameGUI.getChatGUI().printChatMessageWithOptionalDeletion(var6, var5);
+         Reflector.Minecraft_actionKeyF3.setValue(this.mc, Boolean.TRUE);
+      }
+   }
+
+   private void loadAllVisibleChunks(Entity var1, double var2, ICamera var4, boolean var5) {
+      int var6 = this.mc.gameSettings.ofChunkUpdates;
+      boolean var7 = this.mc.gameSettings.ofLazyChunkLoading;
+
+      try {
+         this.mc.gameSettings.ofChunkUpdates = 1000;
+         this.mc.gameSettings.ofLazyChunkLoading = false;
+         RenderGlobal var8 = Config.getRenderGlobal();
+         int var9 = var8.getCountLoadedChunks();
+         long var10 = System.currentTimeMillis();
+         Config.dbg("Loading visible chunks");
+         long var12 = System.currentTimeMillis() + 5000L;
+         int var14 = 0;
+         boolean var15 = false;
+
+         do {
+            var15 = false;
+
+            for (int var16 = 0; var16 < 100; var16++) {
+               var8.displayListEntitiesDirty = true;
+               var8.setupTerrain(var1, var2, var4, this.frameCount++, var5);
+               if (!var8.hasNoChunkUpdates()) {
+                  var15 = true;
+               }
+
+               var14 += var8.getCountChunksToUpdate();
+
+               while (!var8.hasNoChunkUpdates()) {
+                  var8.updateChunks(System.nanoTime() + 1000000000L);
+               }
+
+               var14 -= var8.getCountChunksToUpdate();
+               if (!var15) {
+                  break;
+               }
+            }
+
+            if (var8.getCountLoadedChunks() != var9) {
+               var15 = true;
+               var9 = var8.getCountLoadedChunks();
+            }
+
+            if (System.currentTimeMillis() > var12) {
+               Config.log("Chunks loaded: " + var14);
+               var12 = System.currentTimeMillis() + 5000L;
+            }
+         } while (var15);
+
+         Config.log("Chunks loaded: " + var14);
+         Config.log("Finished loading visible chunks");
+         RenderChunk.renderChunksUpdated = 0;
+      } finally {
+         this.mc.gameSettings.ofChunkUpdates = var6;
+         this.mc.gameSettings.ofLazyChunkLoading = var7;
+      }
+   }
+
    public static void drawNameplate(
       FontRenderer var0, String var1, float var2, float var3, float var4, int var5, float var6, float var7, boolean var8, boolean var9
    ) {
       GlStateManager.pushMatrix();
       GlStateManager.translate(var2, var3, var4);
       GlStateManager.glNormal3f(0.0F, 1.0F, 0.0F);
@@ -1756,13 +2456,13 @@
          );
          float var12 = 50.0F + 175.0F * MathHelper.sin(var9);
          GlStateManager.scale(var12, -var12, var12);
          GlStateManager.rotate(900.0F * MathHelper.abs(MathHelper.sin(var9)), 0.0F, 1.0F, 0.0F);
          GlStateManager.rotate(6.0F * MathHelper.cos(var5 * 8.0F), 1.0F, 0.0F, 0.0F);
          GlStateManager.rotate(6.0F * MathHelper.cos(var5 * 8.0F), 0.0F, 0.0F, 1.0F);
-         this.mc.getRenderItem().renderItem(this.itemActivationItem, ItemCameraTransforms.TransformType.FIXED);
+         this.mc.getRenderItem().renderItem(this.itemActivationItem, TransformType.FIXED);
          GlStateManager.popAttrib();
          GlStateManager.popMatrix();
          RenderHelper.disableStandardItemLighting();
          GlStateManager.enableCull();
          GlStateManager.disableDepth();
       }
--- net/minecraft/client/renderer/EnumFaceDirection.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/EnumFaceDirection.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/GLAllocation.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/GLAllocation.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/GlStateManager.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/GlStateManager.java	Mon Aug 18 09:39:52 2025
@@ -2,12 +2,17 @@
 
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 import javax.annotation.Nullable;
+import net.optifine.SmartAnimations;
+import net.optifine.render.GlAlphaState;
+import net.optifine.render.GlBlendState;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.LockCounter;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL14;
 import org.lwjgl.opengl.GLContext;
 import org.lwjgl.util.vector.Quaternion;
 
@@ -31,34 +36,52 @@
    private static int activeTextureUnit;
    private static final GlStateManager.TextureState[] textureState;
    private static int activeShadeModel;
    private static final GlStateManager.BooleanState rescaleNormalState;
    private static final GlStateManager.ColorMask colorMaskState;
    private static final GlStateManager.Color colorState;
+   public static boolean clearEnabled = true;
+   private static LockCounter alphaLock = new LockCounter();
+   private static GlAlphaState alphaLockState = new GlAlphaState();
+   private static LockCounter blendLock = new LockCounter();
+   private static GlBlendState blendLockState = new GlBlendState();
+   private static boolean creatingDisplayList = false;
 
    public static void pushAttrib() {
       GL11.glPushAttrib(8256);
    }
 
    public static void popAttrib() {
       GL11.glPopAttrib();
    }
 
    public static void disableAlpha() {
-      alphaState.alphaTest.setDisabled();
+      if (alphaLock.isLocked()) {
+         alphaLockState.setDisabled();
+      } else {
+         alphaState.alphaTest.setDisabled();
+      }
    }
 
    public static void enableAlpha() {
-      alphaState.alphaTest.setEnabled();
+      if (alphaLock.isLocked()) {
+         alphaLockState.setEnabled();
+      } else {
+         alphaState.alphaTest.setEnabled();
+      }
    }
 
    public static void alphaFunc(int var0, float var1) {
-      if (var0 != alphaState.func || var1 != alphaState.ref) {
-         alphaState.func = var0;
-         alphaState.ref = var1;
-         GL11.glAlphaFunc(var0, var1);
+      if (alphaLock.isLocked()) {
+         alphaLockState.setFuncRef(var0, var1);
+      } else {
+         if (var0 != alphaState.func || var1 != alphaState.ref) {
+            alphaState.func = var0;
+            alphaState.ref = var1;
+            GL11.glAlphaFunc(var0, var1);
+         }
       }
    }
 
    public static void enableLighting() {
       lightingState.setEnabled();
    }
@@ -123,44 +146,70 @@
          depthState.maskEnabled = var0;
          GL11.glDepthMask(var0);
       }
    }
 
    public static void disableBlend() {
-      blendState.blend.setDisabled();
+      if (blendLock.isLocked()) {
+         blendLockState.setDisabled();
+      } else {
+         blendState.blend.setDisabled();
+      }
    }
 
    public static void enableBlend() {
-      blendState.blend.setEnabled();
+      if (blendLock.isLocked()) {
+         blendLockState.setEnabled();
+      } else {
+         blendState.blend.setEnabled();
+      }
    }
 
    public static void blendFunc(GlStateManager.SourceFactor var0, GlStateManager.DestFactor var1) {
       blendFunc(var0.factor, var1.factor);
    }
 
    public static void blendFunc(int var0, int var1) {
-      if (var0 != blendState.srcFactor || var1 != blendState.dstFactor) {
-         blendState.srcFactor = var0;
-         blendState.dstFactor = var1;
-         GL11.glBlendFunc(var0, var1);
+      if (blendLock.isLocked()) {
+         blendLockState.setFactors(var0, var1);
+      } else {
+         if (var0 != blendState.srcFactor || var1 != blendState.dstFactor || var0 != blendState.srcFactorAlpha || var1 != blendState.dstFactorAlpha) {
+            blendState.srcFactor = var0;
+            blendState.dstFactor = var1;
+            blendState.srcFactorAlpha = var0;
+            blendState.dstFactorAlpha = var1;
+            if (Config.isShaders()) {
+               Shaders.uniform_blendFunc.setValue(var0, var1, var0, var1);
+            }
+
+            GL11.glBlendFunc(var0, var1);
+         }
       }
    }
 
    public static void tryBlendFuncSeparate(
       GlStateManager.SourceFactor var0, GlStateManager.DestFactor var1, GlStateManager.SourceFactor var2, GlStateManager.DestFactor var3
    ) {
       tryBlendFuncSeparate(var0.factor, var1.factor, var2.factor, var3.factor);
    }
 
    public static void tryBlendFuncSeparate(int var0, int var1, int var2, int var3) {
-      if (var0 != blendState.srcFactor || var1 != blendState.dstFactor || var2 != blendState.srcFactorAlpha || var3 != blendState.dstFactorAlpha) {
-         blendState.srcFactor = var0;
-         blendState.dstFactor = var1;
-         blendState.srcFactorAlpha = var2;
-         blendState.dstFactorAlpha = var3;
-         OpenGlHelper.glBlendFunc(var0, var1, var2, var3);
+      if (blendLock.isLocked()) {
+         blendLockState.setFactors(var0, var1, var2, var3);
+      } else {
+         if (var0 != blendState.srcFactor || var1 != blendState.dstFactor || var2 != blendState.srcFactorAlpha || var3 != blendState.dstFactorAlpha) {
+            blendState.srcFactor = var0;
+            blendState.dstFactor = var1;
+            blendState.srcFactorAlpha = var2;
+            blendState.dstFactorAlpha = var3;
+            if (Config.isShaders()) {
+               Shaders.uniform_blendFunc.setValue(var0, var1, var2, var3);
+            }
+
+            OpenGlHelper.glBlendFunc(var0, var1, var2, var3);
+         }
       }
    }
 
    public static void glBlendEquation(int var0) {
       GL14.glBlendEquation(var0);
    }
@@ -203,19 +252,29 @@
    }
 
    private static void setFog(int var0) {
       if (var0 != fogState.mode) {
          fogState.mode = var0;
          GL11.glFogi(2917, var0);
+         if (Config.isShaders()) {
+            Shaders.setFogMode(var0);
+         }
       }
    }
 
    public static void setFogDensity(float var0) {
+      if (var0 < 0.0F) {
+         var0 = 0.0F;
+      }
+
       if (var0 != fogState.density) {
          fogState.density = var0;
          GL11.glFogf(2914, var0);
+         if (Config.isShaders()) {
+            Shaders.setFogDensity(var0);
+         }
       }
    }
 
    public static void setFogStart(float var0) {
       if (var0 != fogState.start) {
          fogState.start = var0;
@@ -372,25 +431,30 @@
 
    public static int generateTexture() {
       return GL11.glGenTextures();
    }
 
    public static void deleteTexture(int var0) {
-      GL11.glDeleteTextures(var0);
+      if (var0 != 0) {
+         GL11.glDeleteTextures(var0);
 
-      for (GlStateManager.TextureState var4 : textureState) {
-         if (var4.textureName == var0) {
-            var4.textureName = -1;
+         for (GlStateManager.TextureState var4 : textureState) {
+            if (var4.textureName == var0) {
+               var4.textureName = 0;
+            }
          }
       }
    }
 
    public static void bindTexture(int var0) {
       if (var0 != textureState[activeTextureUnit].textureName) {
          textureState[activeTextureUnit].textureName = var0;
          GL11.glBindTexture(3553, var0);
+         if (SmartAnimations.isActive()) {
+            SmartAnimations.textureRendered(var0);
+         }
       }
    }
 
    public static void glTexImage2D(int var0, int var1, int var2, int var3, int var4, int var5, int var6, int var7, @Nullable IntBuffer var8) {
       GL11.glTexImage2D(var0, var1, var2, var3, var4, var5, var6, var7, var8);
    }
@@ -459,13 +523,15 @@
          clearState.color.alpha = var3;
          GL11.glClearColor(var0, var1, var2, var3);
       }
    }
 
    public static void clear(int var0) {
-      GL11.glClear(var0);
+      if (clearEnabled) {
+         GL11.glClear(var0);
+      }
    }
 
    public static void matrixMode(int var0) {
       GL11.glMatrixMode(var0);
    }
 
@@ -620,32 +686,71 @@
    public static void glEnd() {
       GL11.glEnd();
    }
 
    public static void glDrawArrays(int var0, int var1, int var2) {
       GL11.glDrawArrays(var0, var1, var2);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int var3 = Shaders.activeProgram.getCountInstances();
+         if (var3 > 1) {
+            for (int var4 = 1; var4 < var3; var4++) {
+               Shaders.uniform_instanceId.setValue(var4);
+               GL11.glDrawArrays(var0, var1, var2);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
    }
 
    public static void glLineWidth(float var0) {
       GL11.glLineWidth(var0);
    }
 
    public static void callList(int var0) {
       GL11.glCallList(var0);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int var1 = Shaders.activeProgram.getCountInstances();
+         if (var1 > 1) {
+            for (int var2 = 1; var2 < var1; var2++) {
+               Shaders.uniform_instanceId.setValue(var2);
+               GL11.glCallList(var0);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
+   }
+
+   public static void callLists(IntBuffer var0) {
+      GL11.glCallLists(var0);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int var1 = Shaders.activeProgram.getCountInstances();
+         if (var1 > 1) {
+            for (int var2 = 1; var2 < var1; var2++) {
+               Shaders.uniform_instanceId.setValue(var2);
+               GL11.glCallLists(var0);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
    }
 
    public static void glDeleteLists(int var0, int var1) {
       GL11.glDeleteLists(var0, var1);
    }
 
    public static void glNewList(int var0, int var1) {
       GL11.glNewList(var0, var1);
+      creatingDisplayList = true;
    }
 
    public static void glEndList() {
       GL11.glEndList();
+      creatingDisplayList = false;
    }
 
    public static int glGenLists(int var0) {
       return GL11.glGenLists(var0);
    }
 
@@ -678,12 +783,138 @@
    }
 
    public static void disableBlendProfile(GlStateManager.Profile var0) {
       var0.clean();
    }
 
+   public static int getActiveTextureUnit() {
+      return OpenGlHelper.defaultTexUnit + activeTextureUnit;
+   }
+
+   public static void bindCurrentTexture() {
+      GL11.glBindTexture(3553, textureState[activeTextureUnit].textureName);
+   }
+
+   public static int getBoundTexture() {
+      return textureState[activeTextureUnit].textureName;
+   }
+
+   public static void checkBoundTexture() {
+      if (Config.isMinecraftThread()) {
+         int var0 = GL11.glGetInteger(34016);
+         int var1 = GL11.glGetInteger(32873);
+         int var2 = getActiveTextureUnit();
+         int var3 = getBoundTexture();
+         if (var3 > 0) {
+            if (var0 != var2 || var1 != var3) {
+               Config.dbg("checkTexture: act: " + var2 + ", glAct: " + var0 + ", tex: " + var3 + ", glTex: " + var1);
+            }
+         }
+      }
+   }
+
+   public static void deleteTextures(IntBuffer var0) {
+      ((Buffer)var0).rewind();
+
+      while (var0.position() < var0.limit()) {
+         int var1 = var0.get();
+         deleteTexture(var1);
+      }
+
+      ((Buffer)var0).rewind();
+   }
+
+   public static boolean isFogEnabled() {
+      return fogState.fog.currentState;
+   }
+
+   public static void setFogEnabled(boolean var0) {
+      fogState.fog.setState(var0);
+   }
+
+   public static void lockAlpha(GlAlphaState var0) {
+      if (!alphaLock.isLocked()) {
+         getAlphaState(alphaLockState);
+         setAlphaState(var0);
+         alphaLock.lock();
+      }
+   }
+
+   public static void unlockAlpha() {
+      if (alphaLock.unlock()) {
+         setAlphaState(alphaLockState);
+      }
+   }
+
+   public static void getAlphaState(GlAlphaState var0) {
+      if (alphaLock.isLocked()) {
+         var0.setState(alphaLockState);
+      } else {
+         var0.setState(alphaState.alphaTest.currentState, alphaState.func, alphaState.ref);
+      }
+   }
+
+   public static void setAlphaState(GlAlphaState var0) {
+      if (alphaLock.isLocked()) {
+         alphaLockState.setState(var0);
+      } else {
+         alphaState.alphaTest.setState(var0.isEnabled());
+         alphaFunc(var0.getFunc(), var0.getRef());
+      }
+   }
+
+   public static void lockBlend(GlBlendState var0) {
+      if (!blendLock.isLocked()) {
+         getBlendState(blendLockState);
+         setBlendState(var0);
+         blendLock.lock();
+      }
+   }
+
+   public static void unlockBlend() {
+      if (blendLock.unlock()) {
+         setBlendState(blendLockState);
+      }
+   }
+
+   public static void getBlendState(GlBlendState var0) {
+      if (blendLock.isLocked()) {
+         var0.setState(blendLockState);
+      } else {
+         var0.setState(blendState.blend.currentState, blendState.srcFactor, blendState.dstFactor, blendState.srcFactorAlpha, blendState.dstFactorAlpha);
+      }
+   }
+
+   public static void setBlendState(GlBlendState var0) {
+      if (blendLock.isLocked()) {
+         blendLockState.setState(var0);
+      } else {
+         blendState.blend.setState(var0.isEnabled());
+         if (!var0.isSeparate()) {
+            blendFunc(var0.getSrcFactor(), var0.getDstFactor());
+         } else {
+            tryBlendFuncSeparate(var0.getSrcFactor(), var0.getDstFactor(), var0.getSrcFactorAlpha(), var0.getDstFactorAlpha());
+         }
+      }
+   }
+
+   public static void glMultiDrawArrays(int var0, IntBuffer var1, IntBuffer var2) {
+      GL14.glMultiDrawArrays(var0, var1, var2);
+      if (Config.isShaders() && !creatingDisplayList) {
+         int var3 = Shaders.activeProgram.getCountInstances();
+         if (var3 > 1) {
+            for (int var4 = 1; var4 < var3; var4++) {
+               Shaders.uniform_instanceId.setValue(var4);
+               GL14.glMultiDrawArrays(var0, var1, var2);
+            }
+
+            Shaders.uniform_instanceId.setValue(0);
+         }
+      }
+   }
+
    static {
       for (int var0 = 0; var0 < 8; var0++) {
          lightState[var0] = new GlStateManager.BooleanState(16384 + var0);
       }
 
       colorMaterialState = new GlStateManager.ColorMaterialState();
@@ -694,15 +925,15 @@
       polygonOffsetState = new GlStateManager.PolygonOffsetState();
       colorLogicState = new GlStateManager.ColorLogicState();
       texGenState = new GlStateManager.TexGenState();
       clearState = new GlStateManager.ClearState();
       stencilState = new GlStateManager.StencilState();
       normalizeState = new GlStateManager.BooleanState(2977);
-      textureState = new GlStateManager.TextureState[8];
+      textureState = new GlStateManager.TextureState[32];
 
-      for (int var1 = 0; var1 < 8; var1++) {
+      for (int var1 = 0; var1 < textureState.length; var1++) {
          textureState[var1] = new GlStateManager.TextureState();
       }
 
       activeShadeModel = 7425;
       rescaleNormalState = new GlStateManager.BooleanState(32826);
       colorMaskState = new GlStateManager.ColorMask();
@@ -924,24 +1155,24 @@
       DEFAULT {
          @Override
          public void apply() {
             GlStateManager.disableAlpha();
             GlStateManager.alphaFunc(519, 0.0F);
             GlStateManager.disableLighting();
-            GlStateManager.glLightModel(2899, RenderHelper.setColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
+            GL11.glLightModel(2899, RenderHelper.setColorBuffer(0.2F, 0.2F, 0.2F, 1.0F));
 
             for (int var1 = 0; var1 < 8; var1++) {
                GlStateManager.disableLight(var1);
-               GlStateManager.glLight(16384 + var1, 4608, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
-               GlStateManager.glLight(16384 + var1, 4611, RenderHelper.setColorBuffer(0.0F, 0.0F, 1.0F, 0.0F));
+               GL11.glLight(16384 + var1, 4608, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+               GL11.glLight(16384 + var1, 4611, RenderHelper.setColorBuffer(0.0F, 0.0F, 1.0F, 0.0F));
                if (var1 == 0) {
-                  GlStateManager.glLight(16384 + var1, 4609, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
-                  GlStateManager.glLight(16384 + var1, 4610, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+                  GL11.glLight(16384 + var1, 4609, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
+                  GL11.glLight(16384 + var1, 4610, RenderHelper.setColorBuffer(1.0F, 1.0F, 1.0F, 1.0F));
                } else {
-                  GlStateManager.glLight(16384 + var1, 4609, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
-                  GlStateManager.glLight(16384 + var1, 4610, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+                  GL11.glLight(16384 + var1, 4609, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
+                  GL11.glLight(16384 + var1, 4610, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 1.0F));
                }
             }
 
             GlStateManager.disableColorMaterial();
             GlStateManager.colorMaterial(1032, 5634);
             GlStateManager.disableDepth();
@@ -949,21 +1180,21 @@
             GlStateManager.depthMask(true);
             GlStateManager.disableBlend();
             GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
             GlStateManager.tryBlendFuncSeparate(
                GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
             );
-            GlStateManager.glBlendEquation(32774);
+            GL14.glBlendEquation(32774);
             GlStateManager.disableFog();
-            GlStateManager.glFogi(2917, 2048);
+            GL11.glFogi(2917, 2048);
             GlStateManager.setFogDensity(1.0F);
             GlStateManager.setFogStart(0.0F);
             GlStateManager.setFogEnd(1.0F);
-            GlStateManager.glFog(2918, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
+            GL11.glFog(2918, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             if (GLContext.getCapabilities().GL_NV_fog_distance) {
-               GlStateManager.glFogi(2917, 34140);
+               GL11.glFogi(2917, 34140);
             }
 
             GlStateManager.doPolygonOffset(0.0F, 0.0F);
             GlStateManager.disableColorLogic();
             GlStateManager.colorLogicOp(5379);
             GlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);
@@ -980,47 +1211,47 @@
             GlStateManager.texGen(GlStateManager.TexGen.R, 9217, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             GlStateManager.disableTexGenCoord(GlStateManager.TexGen.Q);
             GlStateManager.texGen(GlStateManager.TexGen.Q, 9216);
             GlStateManager.texGen(GlStateManager.TexGen.Q, 9474, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             GlStateManager.texGen(GlStateManager.TexGen.Q, 9217, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
             GlStateManager.setActiveTexture(0);
-            GlStateManager.glTexParameteri(3553, 10240, 9729);
-            GlStateManager.glTexParameteri(3553, 10241, 9986);
-            GlStateManager.glTexParameteri(3553, 10242, 10497);
-            GlStateManager.glTexParameteri(3553, 10243, 10497);
-            GlStateManager.glTexParameteri(3553, 33085, 1000);
-            GlStateManager.glTexParameteri(3553, 33083, 1000);
-            GlStateManager.glTexParameteri(3553, 33082, -1000);
-            GlStateManager.glTexParameterf(3553, 34049, 0.0F);
-            GlStateManager.glTexEnvi(8960, 8704, 8448);
-            GlStateManager.glTexEnv(8960, 8705, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
-            GlStateManager.glTexEnvi(8960, 34161, 8448);
-            GlStateManager.glTexEnvi(8960, 34162, 8448);
-            GlStateManager.glTexEnvi(8960, 34176, 5890);
-            GlStateManager.glTexEnvi(8960, 34177, 34168);
-            GlStateManager.glTexEnvi(8960, 34178, 34166);
-            GlStateManager.glTexEnvi(8960, 34184, 5890);
-            GlStateManager.glTexEnvi(8960, 34185, 34168);
-            GlStateManager.glTexEnvi(8960, 34186, 34166);
-            GlStateManager.glTexEnvi(8960, 34192, 768);
-            GlStateManager.glTexEnvi(8960, 34193, 768);
-            GlStateManager.glTexEnvi(8960, 34194, 770);
-            GlStateManager.glTexEnvi(8960, 34200, 770);
-            GlStateManager.glTexEnvi(8960, 34201, 770);
-            GlStateManager.glTexEnvi(8960, 34202, 770);
-            GlStateManager.glTexEnvf(8960, 34163, 1.0F);
-            GlStateManager.glTexEnvf(8960, 3356, 1.0F);
+            GL11.glTexParameteri(3553, 10240, 9729);
+            GL11.glTexParameteri(3553, 10241, 9986);
+            GL11.glTexParameteri(3553, 10242, 10497);
+            GL11.glTexParameteri(3553, 10243, 10497);
+            GL11.glTexParameteri(3553, 33085, 1000);
+            GL11.glTexParameteri(3553, 33083, 1000);
+            GL11.glTexParameteri(3553, 33082, -1000);
+            GL11.glTexParameterf(3553, 34049, 0.0F);
+            GL11.glTexEnvi(8960, 8704, 8448);
+            GL11.glTexEnv(8960, 8705, RenderHelper.setColorBuffer(0.0F, 0.0F, 0.0F, 0.0F));
+            GL11.glTexEnvi(8960, 34161, 8448);
+            GL11.glTexEnvi(8960, 34162, 8448);
+            GL11.glTexEnvi(8960, 34176, 5890);
+            GL11.glTexEnvi(8960, 34177, 34168);
+            GL11.glTexEnvi(8960, 34178, 34166);
+            GL11.glTexEnvi(8960, 34184, 5890);
+            GL11.glTexEnvi(8960, 34185, 34168);
+            GL11.glTexEnvi(8960, 34186, 34166);
+            GL11.glTexEnvi(8960, 34192, 768);
+            GL11.glTexEnvi(8960, 34193, 768);
+            GL11.glTexEnvi(8960, 34194, 770);
+            GL11.glTexEnvi(8960, 34200, 770);
+            GL11.glTexEnvi(8960, 34201, 770);
+            GL11.glTexEnvi(8960, 34202, 770);
+            GL11.glTexEnvf(8960, 34163, 1.0F);
+            GL11.glTexEnvf(8960, 3356, 1.0F);
             GlStateManager.disableNormalize();
             GlStateManager.shadeModel(7425);
             GlStateManager.disableRescaleNormal();
             GlStateManager.colorMask(true, true, true, true);
             GlStateManager.clearDepth(1.0);
-            GlStateManager.glLineWidth(1.0F);
-            GlStateManager.glNormal3f(0.0F, 0.0F, 1.0F);
-            GlStateManager.glPolygonMode(1028, 6914);
-            GlStateManager.glPolygonMode(1029, 6914);
+            GL11.glLineWidth(1.0F);
+            GL11.glNormal3f(0.0F, 0.0F, 1.0F);
+            GL11.glPolygonMode(1028, 6914);
+            GL11.glPolygonMode(1029, 6914);
          }
 
          @Override
          public void clean() {
          }
       },
--- net/minecraft/client/renderer/IImageBuffer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/IImageBuffer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/ImageBufferDownload.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ImageBufferDownload.java	Mon Aug 18 09:39:52 2025
@@ -1,62 +1,70 @@
 package net.minecraft.client.renderer;
 
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.image.BufferedImage;
 import java.awt.image.DataBufferInt;
+import java.awt.image.ImageObserver;
 import javax.annotation.Nullable;
 
 public class ImageBufferDownload implements IImageBuffer {
    private int[] imageData;
    private int imageWidth;
    private int imageHeight;
 
    @Nullable
-   @Override
    public BufferedImage parseUserSkin(BufferedImage var1) {
       if (var1 == null) {
          return null;
       } else {
          this.imageWidth = 64;
          this.imageHeight = 64;
-         BufferedImage var2 = new BufferedImage(this.imageWidth, this.imageHeight, 2);
-         Graphics var3 = var2.getGraphics();
-         var3.drawImage(var1, 0, 0, null);
-         boolean var4 = var1.getHeight() == 32;
-         if (var4) {
-            var3.setColor(new Color(0, 0, 0, 0));
-            var3.fillRect(0, 32, 64, 32);
-            var3.drawImage(var2, 24, 48, 20, 52, 4, 16, 8, 20, null);
-            var3.drawImage(var2, 28, 48, 24, 52, 8, 16, 12, 20, null);
-            var3.drawImage(var2, 20, 52, 16, 64, 8, 20, 12, 32, null);
-            var3.drawImage(var2, 24, 52, 20, 64, 4, 20, 8, 32, null);
-            var3.drawImage(var2, 28, 52, 24, 64, 0, 20, 4, 32, null);
-            var3.drawImage(var2, 32, 52, 28, 64, 12, 20, 16, 32, null);
-            var3.drawImage(var2, 40, 48, 36, 52, 44, 16, 48, 20, null);
-            var3.drawImage(var2, 44, 48, 40, 52, 48, 16, 52, 20, null);
-            var3.drawImage(var2, 36, 52, 32, 64, 48, 20, 52, 32, null);
-            var3.drawImage(var2, 40, 52, 36, 64, 44, 20, 48, 32, null);
-            var3.drawImage(var2, 44, 52, 40, 64, 40, 20, 44, 32, null);
-            var3.drawImage(var2, 48, 52, 44, 64, 52, 20, 56, 32, null);
+         int var3 = var1.getWidth();
+         int var4 = var1.getHeight();
+
+         byte var5;
+         for (var5 = 1; this.imageWidth < var3 || this.imageHeight < var4; var5 *= 2) {
+            this.imageWidth *= 2;
+            this.imageHeight *= 2;
+         }
+
+         BufferedImage var6 = new BufferedImage(this.imageWidth, this.imageHeight, 2);
+         Graphics var7 = var6.getGraphics();
+         var7.drawImage(var1, 0, 0, (ImageObserver)null);
+         boolean var8 = var1.getHeight() == 32 * var5;
+         if (var8) {
+            var7.setColor(new Color(0, 0, 0, 0));
+            var7.fillRect(0 * var5, 32 * var5, 64 * var5, 32 * var5);
+            var7.drawImage(var6, 24 * var5, 48 * var5, 20 * var5, 52 * var5, 4 * var5, 16 * var5, 8 * var5, 20 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 28 * var5, 48 * var5, 24 * var5, 52 * var5, 8 * var5, 16 * var5, 12 * var5, 20 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 20 * var5, 52 * var5, 16 * var5, 64 * var5, 8 * var5, 20 * var5, 12 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 24 * var5, 52 * var5, 20 * var5, 64 * var5, 4 * var5, 20 * var5, 8 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 28 * var5, 52 * var5, 24 * var5, 64 * var5, 0 * var5, 20 * var5, 4 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 32 * var5, 52 * var5, 28 * var5, 64 * var5, 12 * var5, 20 * var5, 16 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 40 * var5, 48 * var5, 36 * var5, 52 * var5, 44 * var5, 16 * var5, 48 * var5, 20 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 44 * var5, 48 * var5, 40 * var5, 52 * var5, 48 * var5, 16 * var5, 52 * var5, 20 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 36 * var5, 52 * var5, 32 * var5, 64 * var5, 48 * var5, 20 * var5, 52 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 40 * var5, 52 * var5, 36 * var5, 64 * var5, 44 * var5, 20 * var5, 48 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 44 * var5, 52 * var5, 40 * var5, 64 * var5, 40 * var5, 20 * var5, 44 * var5, 32 * var5, (ImageObserver)null);
+            var7.drawImage(var6, 48 * var5, 52 * var5, 44 * var5, 64 * var5, 52 * var5, 20 * var5, 56 * var5, 32 * var5, (ImageObserver)null);
          }
 
-         var3.dispose();
-         this.imageData = ((DataBufferInt)var2.getRaster().getDataBuffer()).getData();
-         this.setAreaOpaque(0, 0, 32, 16);
-         if (var4) {
-            this.setAreaTransparent(32, 0, 64, 32);
+         var7.dispose();
+         this.imageData = ((DataBufferInt)var6.getRaster().getDataBuffer()).getData();
+         this.setAreaOpaque(0 * var5, 0 * var5, 32 * var5, 16 * var5);
+         if (var8) {
+            this.setAreaTransparent(32 * var5, 0 * var5, 64 * var5, 32 * var5);
          }
 
-         this.setAreaOpaque(0, 16, 64, 32);
-         this.setAreaOpaque(16, 48, 48, 64);
-         return var2;
+         this.setAreaOpaque(0 * var5, 16 * var5, 64 * var5, 32 * var5);
+         this.setAreaOpaque(16 * var5, 48 * var5, 48 * var5, 64 * var5);
+         return var6;
       }
    }
 
-   @Override
    public void skinAvailable() {
    }
 
    private void setAreaTransparent(int var1, int var2, int var3, int var4) {
       for (int var5 = var1; var5 < var3; var5++) {
          for (int var6 = var2; var6 < var4; var6++) {
--- net/minecraft/client/renderer/InventoryEffectRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/InventoryEffectRenderer.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/ItemMeshDefinition.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ItemMeshDefinition.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/ItemModelMesher.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ItemModelMesher.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/ItemRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ItemRenderer.java	Mon Aug 18 09:39:52 2025
@@ -5,31 +5,37 @@
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.entity.EntityPlayerSP;
-import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.entity.Render;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.entity.RenderPlayer;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.init.Items;
 import net.minecraft.item.Item;
+import net.minecraft.item.ItemBow;
+import net.minecraft.item.ItemMap;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumBlockRenderType;
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.EnumHandSide;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.storage.MapData;
+import net.optifine.DynamicLights;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
 
 public class ItemRenderer {
    private static final ResourceLocation RES_MAP_BACKGROUND = new ResourceLocation("textures/map/map_background.png");
    private static final ResourceLocation RES_UNDERWATER_OVERLAY = new ResourceLocation("textures/misc/underwater.png");
    private final Minecraft mc;
    private ItemStack itemStackMainHand = ItemStack.EMPTY;
@@ -44,23 +50,23 @@
    public ItemRenderer(Minecraft var1) {
       this.mc = var1;
       this.renderManager = var1.getRenderManager();
       this.itemRenderer = var1.getRenderItem();
    }
 
-   public void renderItem(EntityLivingBase var1, ItemStack var2, ItemCameraTransforms.TransformType var3) {
+   public void renderItem(EntityLivingBase var1, ItemStack var2, TransformType var3) {
       this.renderItemSide(var1, var2, var3, false);
    }
 
-   public void renderItemSide(EntityLivingBase var1, ItemStack var2, ItemCameraTransforms.TransformType var3, boolean var4) {
+   public void renderItemSide(EntityLivingBase var1, ItemStack var2, TransformType var3, boolean var4) {
       if (!var2.isEmpty()) {
          Item var5 = var2.getItem();
          Block var6 = Block.getBlockFromItem(var5);
          GlStateManager.pushMatrix();
          boolean var7 = this.itemRenderer.shouldRenderItemIn3D(var2) && var6.getRenderLayer() == BlockRenderLayer.TRANSLUCENT;
-         if (var7) {
+         if (var7 && (!Config.isShaders() || !Shaders.renderItemKeepDepthMask)) {
             GlStateManager.depthMask(false);
          }
 
          this.itemRenderer.renderItem(var2, var1, var3, var4);
          if (var7) {
             GlStateManager.depthMask(true);
@@ -78,12 +84,16 @@
       GlStateManager.popMatrix();
    }
 
    private void setLightmap() {
       EntityPlayerSP var1 = this.mc.player;
       int var2 = this.mc.world.getCombinedLight(new BlockPos(var1.posX, var1.posY + var1.getEyeHeight(), var1.posZ), 0);
+      if (Config.isDynamicLights()) {
+         var2 = DynamicLights.getCombinedLight(this.mc.getRenderViewEntity(), var2);
+      }
+
       float var3 = var2 & 65535;
       float var4 = var2 >> 16;
       OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var3, var4);
    }
 
    private void rotateArm(float var1) {
@@ -183,13 +193,13 @@
       var3.begin(7, DefaultVertexFormats.POSITION_TEX);
       var3.pos(-7.0, 135.0, 0.0).tex(0.0, 1.0).endVertex();
       var3.pos(135.0, 135.0, 0.0).tex(1.0, 1.0).endVertex();
       var3.pos(135.0, -7.0, 0.0).tex(1.0, 0.0).endVertex();
       var3.pos(-7.0, -7.0, 0.0).tex(0.0, 0.0).endVertex();
       var2.draw();
-      MapData var4 = Items.FILLED_MAP.getMapData(var1, this.mc.world);
+      MapData var4 = ReflectorForge.getMapData(Items.FILLED_MAP, var1, this.mc.world);
       if (var4 != null) {
          this.mc.entityRenderer.getMapItemRenderer().renderMap(var4, false);
       }
 
       GlStateManager.enableLighting();
    }
@@ -211,13 +221,13 @@
       this.mc.getTextureManager().bindTexture(var12.getLocationSkin());
       GlStateManager.translate(var5 * -1.0F, 3.6F, 3.5F);
       GlStateManager.rotate(var5 * 120.0F, 0.0F, 0.0F, 1.0F);
       GlStateManager.rotate(200.0F, 1.0F, 0.0F, 0.0F);
       GlStateManager.rotate(var5 * -135.0F, 0.0F, 1.0F, 0.0F);
       GlStateManager.translate(var5 * 5.6F, 0.0F, 0.0F);
-      RenderPlayer var13 = (RenderPlayer)this.renderManager.<AbstractClientPlayer>getEntityRenderObject(var12);
+      RenderPlayer var13 = (RenderPlayer)this.renderManager.getEntityRenderObject(var12);
       GlStateManager.disableCull();
       if (var4) {
          var13.renderRightArm(var12);
       } else {
          var13.renderLeftArm(var12);
       }
@@ -263,13 +273,13 @@
       float var5 = var2.prevRotationPitch + (var2.rotationPitch - var2.prevRotationPitch) * var1;
       float var6 = var2.prevRotationYaw + (var2.rotationYaw - var2.prevRotationYaw) * var1;
       boolean var7 = true;
       boolean var8 = true;
       if (var2.isHandActive()) {
          ItemStack var9 = var2.getActiveItemStack();
-         if (var9.getItem() == Items.BOW) {
+         if (var9.getItem() instanceof ItemBow) {
             EnumHand var10 = var2.getActiveHand();
             var7 = var10 == EnumHand.MAIN_HAND;
             var8 = !var7;
          }
       }
 
@@ -277,125 +287,141 @@
       this.setLightmap();
       this.rotateArm(var1);
       GlStateManager.enableRescaleNormal();
       if (var7) {
          float var11 = var4 == EnumHand.MAIN_HAND ? var3 : 0.0F;
          float var13 = 1.0F - (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * var1);
-         this.renderItemInFirstPerson(var2, var1, var5, EnumHand.MAIN_HAND, var11, this.itemStackMainHand, var13);
+         if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists()
+            || !Reflector.callBoolean(
+               Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[]{EnumHand.MAIN_HAND, var1, var5, var11, var13, this.itemStackMainHand}
+            )) {
+            this.renderItemInFirstPerson(var2, var1, var5, EnumHand.MAIN_HAND, var11, this.itemStackMainHand, var13);
+         }
       }
 
       if (var8) {
          float var12 = var4 == EnumHand.OFF_HAND ? var3 : 0.0F;
          float var14 = 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * var1);
-         this.renderItemInFirstPerson(var2, var1, var5, EnumHand.OFF_HAND, var12, this.itemStackOffHand, var14);
+         if (!Reflector.ForgeHooksClient_renderSpecificFirstPersonHand.exists()
+            || !Reflector.callBoolean(
+               Reflector.ForgeHooksClient_renderSpecificFirstPersonHand, new Object[]{EnumHand.OFF_HAND, var1, var5, var12, var14, this.itemStackOffHand}
+            )) {
+            this.renderItemInFirstPerson(var2, var1, var5, EnumHand.OFF_HAND, var12, this.itemStackOffHand, var14);
+         }
       }
 
       GlStateManager.disableRescaleNormal();
       RenderHelper.disableStandardItemLighting();
    }
 
    public void renderItemInFirstPerson(AbstractClientPlayer var1, float var2, float var3, EnumHand var4, float var5, ItemStack var6, float var7) {
-      boolean var8 = var4 == EnumHand.MAIN_HAND;
-      EnumHandSide var9 = var8 ? var1.getPrimaryHand() : var1.getPrimaryHand().opposite();
-      GlStateManager.pushMatrix();
-      if (var6.isEmpty()) {
-         if (var8 && !var1.isInvisible()) {
-            this.renderArmFirstPerson(var7, var5, var9);
-         }
-      } else if (var6.getItem() == Items.FILLED_MAP) {
-         if (var8 && this.itemStackOffHand.isEmpty()) {
-            this.renderMapFirstPerson(var3, var7, var5);
-         } else {
-            this.renderMapFirstPersonSide(var7, var9, var5, var6);
-         }
-      } else {
-         boolean var10 = var9 == EnumHandSide.RIGHT;
-         if (var1.isHandActive() && var1.getItemInUseCount() > 0 && var1.getActiveHand() == var4) {
-            int var17 = var10 ? 1 : -1;
-            switch (var6.getItemUseAction()) {
-               case NONE:
-                  this.transformSideFirstPerson(var9, var7);
-                  break;
-               case EAT:
-               case DRINK:
-                  this.transformEatFirstPerson(var2, var9, var6);
-                  this.transformSideFirstPerson(var9, var7);
-                  break;
-               case BLOCK:
-                  this.transformSideFirstPerson(var9, var7);
-                  break;
-               case BOW:
-                  this.transformSideFirstPerson(var9, var7);
-                  GlStateManager.translate(var17 * -0.2785682F, 0.18344387F, 0.15731531F);
-                  GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
-                  GlStateManager.rotate(var17 * 35.3F, 0.0F, 1.0F, 0.0F);
-                  GlStateManager.rotate(var17 * -9.785F, 0.0F, 0.0F, 1.0F);
-                  float var18 = var6.getMaxItemUseDuration() - (this.mc.player.getItemInUseCount() - var2 + 1.0F);
-                  float var19 = var18 / 20.0F;
-                  var19 = (var19 * var19 + var19 * 2.0F) / 3.0F;
-                  if (var19 > 1.0F) {
-                     var19 = 1.0F;
-                  }
-
-                  if (var19 > 0.1F) {
-                     float var21 = MathHelper.sin((var18 - 0.1F) * 1.3F);
-                     float var15 = var19 - 0.1F;
-                     float var16 = var21 * var15;
-                     GlStateManager.translate(var16 * 0.0F, var16 * 0.004F, var16 * 0.0F);
-                  }
-
-                  GlStateManager.translate(var19 * 0.0F, var19 * 0.0F, var19 * 0.04F);
-                  GlStateManager.scale(1.0F, 1.0F, 1.0F + var19 * 0.2F);
-                  GlStateManager.rotate(var17 * 45.0F, 0.0F, -1.0F, 0.0F);
+      if (!Config.isShaders() || !Shaders.isSkipRenderHand(var4)) {
+         boolean var8 = var4 == EnumHand.MAIN_HAND;
+         EnumHandSide var9 = var8 ? var1.getPrimaryHand() : var1.getPrimaryHand().opposite();
+         GlStateManager.pushMatrix();
+         if (var6.isEmpty()) {
+            if (var8 && !var1.isInvisible()) {
+               this.renderArmFirstPerson(var7, var5, var9);
+            }
+         } else if (var6.getItem() instanceof ItemMap) {
+            if (var8 && this.itemStackOffHand.isEmpty()) {
+               this.renderMapFirstPerson(var3, var7, var5);
+            } else {
+               this.renderMapFirstPersonSide(var7, var9, var5, var6);
             }
          } else {
-            float var11 = -0.4F * MathHelper.sin(MathHelper.sqrt(var5) * (float) Math.PI);
-            float var12 = 0.2F * MathHelper.sin(MathHelper.sqrt(var5) * (float) (Math.PI * 2));
-            float var13 = -0.2F * MathHelper.sin(var5 * (float) Math.PI);
-            int var14 = var10 ? 1 : -1;
-            GlStateManager.translate(var14 * var11, var12, var13);
-            this.transformSideFirstPerson(var9, var7);
-            this.transformFirstPerson(var9, var5);
+            boolean var10 = var9 == EnumHandSide.RIGHT;
+            if (var1.isHandActive() && var1.getItemInUseCount() > 0 && var1.getActiveHand() == var4) {
+               int var17 = var10 ? 1 : -1;
+               switch (var6.getItemUseAction()) {
+                  case NONE:
+                     this.transformSideFirstPerson(var9, var7);
+                     break;
+                  case EAT:
+                  case DRINK:
+                     this.transformEatFirstPerson(var2, var9, var6);
+                     this.transformSideFirstPerson(var9, var7);
+                     break;
+                  case BLOCK:
+                     this.transformSideFirstPerson(var9, var7);
+                     break;
+                  case BOW:
+                     this.transformSideFirstPerson(var9, var7);
+                     GlStateManager.translate(var17 * -0.2785682F, 0.18344387F, 0.15731531F);
+                     GlStateManager.rotate(-13.935F, 1.0F, 0.0F, 0.0F);
+                     GlStateManager.rotate(var17 * 35.3F, 0.0F, 1.0F, 0.0F);
+                     GlStateManager.rotate(var17 * -9.785F, 0.0F, 0.0F, 1.0F);
+                     float var18 = var6.getMaxItemUseDuration() - (this.mc.player.getItemInUseCount() - var2 + 1.0F);
+                     float var19 = var18 / 20.0F;
+                     var19 = (var19 * var19 + var19 * 2.0F) / 3.0F;
+                     if (var19 > 1.0F) {
+                        var19 = 1.0F;
+                     }
+
+                     if (var19 > 0.1F) {
+                        float var21 = MathHelper.sin((var18 - 0.1F) * 1.3F);
+                        float var15 = var19 - 0.1F;
+                        float var16 = var21 * var15;
+                        GlStateManager.translate(var16 * 0.0F, var16 * 0.004F, var16 * 0.0F);
+                     }
+
+                     GlStateManager.translate(var19 * 0.0F, var19 * 0.0F, var19 * 0.04F);
+                     GlStateManager.scale(1.0F, 1.0F, 1.0F + var19 * 0.2F);
+                     GlStateManager.rotate(var17 * 45.0F, 0.0F, -1.0F, 0.0F);
+               }
+            } else {
+               float var11 = -0.4F * MathHelper.sin(MathHelper.sqrt(var5) * (float) Math.PI);
+               float var12 = 0.2F * MathHelper.sin(MathHelper.sqrt(var5) * (float) (Math.PI * 2));
+               float var13 = -0.2F * MathHelper.sin(var5 * (float) Math.PI);
+               int var14 = var10 ? 1 : -1;
+               GlStateManager.translate(var14 * var11, var12, var13);
+               this.transformSideFirstPerson(var9, var7);
+               this.transformFirstPerson(var9, var5);
+            }
+
+            this.renderItemSide(var1, var6, var10 ? TransformType.FIRST_PERSON_RIGHT_HAND : TransformType.FIRST_PERSON_LEFT_HAND, !var10);
          }
 
-         this.renderItemSide(
-            var1, var6, var10 ? ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND : ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND, !var10
-         );
+         GlStateManager.popMatrix();
       }
-
-      GlStateManager.popMatrix();
    }
 
    public void renderOverlays(float var1) {
       GlStateManager.disableAlpha();
       if (this.mc.player.isEntityInsideOpaqueBlock()) {
          IBlockState var2 = this.mc.world.getBlockState(new BlockPos(this.mc.player));
-         EntityPlayerSP var3 = this.mc.player;
+         BlockPos var3 = new BlockPos(this.mc.player);
+         EntityPlayerSP var4 = this.mc.player;
 
-         for (int var4 = 0; var4 < 8; var4++) {
-            double var5 = var3.posX + ((var4 >> 0) % 2 - 0.5F) * var3.width * 0.8F;
-            double var7 = var3.posY + ((var4 >> 1) % 2 - 0.5F) * 0.1F;
-            double var9 = var3.posZ + ((var4 >> 2) % 2 - 0.5F) * var3.width * 0.8F;
-            BlockPos var11 = new BlockPos(var5, var7 + var3.getEyeHeight(), var9);
-            IBlockState var12 = this.mc.world.getBlockState(var11);
-            if (var12.causesSuffocation()) {
-               var2 = var12;
+         for (int var5 = 0; var5 < 8; var5++) {
+            double var6 = var4.posX + ((var5 >> 0) % 2 - 0.5F) * var4.width * 0.8F;
+            double var8 = var4.posY + ((var5 >> 1) % 2 - 0.5F) * 0.1F;
+            double var10 = var4.posZ + ((var5 >> 2) % 2 - 0.5F) * var4.width * 0.8F;
+            BlockPos var12 = new BlockPos(var6, var8 + var4.getEyeHeight(), var10);
+            IBlockState var13 = this.mc.world.getBlockState(var12);
+            if (var13.r()) {
+               var2 = var13;
+               var3 = var12;
             }
          }
 
-         if (var2.getRenderType() != EnumBlockRenderType.INVISIBLE) {
-            this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(var2));
+         if (var2.i() != EnumBlockRenderType.INVISIBLE) {
+            Object var14 = Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
+            if (!Reflector.callBoolean(Reflector.ForgeEventFactory_renderBlockOverlay, new Object[]{this.mc.player, var1, var14, var2, var3})) {
+               this.renderSuffocationOverlay(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(var2));
+            }
          }
       }
 
       if (!this.mc.player.isSpectator()) {
-         if (this.mc.player.isInsideOfMaterial(Material.WATER)) {
+         if (this.mc.player.isInsideOfMaterial(Material.WATER)
+            && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, new Object[]{this.mc.player, var1})) {
             this.renderWaterOverlayTexture(var1);
          }
 
-         if (this.mc.player.isBurning()) {
+         if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, new Object[]{this.mc.player, var1})) {
             this.renderFireInFirstPerson();
          }
       }
 
       GlStateManager.enableAlpha();
    }
@@ -424,39 +450,44 @@
       var2.draw();
       GlStateManager.popMatrix();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
 
    private void renderWaterOverlayTexture(float var1) {
-      this.mc.getTextureManager().bindTexture(RES_UNDERWATER_OVERLAY);
-      Tessellator var2 = Tessellator.getInstance();
-      BufferBuilder var3 = var2.getBuffer();
-      float var4 = this.mc.player.getBrightness();
-      GlStateManager.color(var4, var4, var4, 0.5F);
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      GlStateManager.pushMatrix();
-      float var5 = 4.0F;
-      float var6 = -1.0F;
-      float var7 = 1.0F;
-      float var8 = -1.0F;
-      float var9 = 1.0F;
-      float var10 = -0.5F;
-      float var11 = -this.mc.player.rotationYaw / 64.0F;
-      float var12 = this.mc.player.rotationPitch / 64.0F;
-      var3.begin(7, DefaultVertexFormats.POSITION_TEX);
-      var3.pos(-1.0, -1.0, -0.5).tex(4.0F + var11, 4.0F + var12).endVertex();
-      var3.pos(1.0, -1.0, -0.5).tex(0.0F + var11, 4.0F + var12).endVertex();
-      var3.pos(1.0, 1.0, -0.5).tex(0.0F + var11, 0.0F + var12).endVertex();
-      var3.pos(-1.0, 1.0, -0.5).tex(4.0F + var11, 0.0F + var12).endVertex();
-      var2.draw();
-      GlStateManager.popMatrix();
-      GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-      GlStateManager.disableBlend();
+      if (!Config.isShaders() || Shaders.isUnderwaterOverlay()) {
+         this.mc.getTextureManager().bindTexture(RES_UNDERWATER_OVERLAY);
+         Tessellator var2 = Tessellator.getInstance();
+         BufferBuilder var3 = var2.getBuffer();
+         float var4 = this.mc.player.getBrightness();
+         GlStateManager.color(var4, var4, var4, 0.5F);
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         GlStateManager.pushMatrix();
+         float var5 = 4.0F;
+         float var6 = -1.0F;
+         float var7 = 1.0F;
+         float var8 = -1.0F;
+         float var9 = 1.0F;
+         float var10 = -0.5F;
+         float var11 = -this.mc.player.rotationYaw / 64.0F;
+         float var12 = this.mc.player.rotationPitch / 64.0F;
+         var3.begin(7, DefaultVertexFormats.POSITION_TEX);
+         var3.pos(-1.0, -1.0, -0.5).tex(4.0F + var11, 4.0F + var12).endVertex();
+         var3.pos(1.0, -1.0, -0.5).tex(0.0F + var11, 4.0F + var12).endVertex();
+         var3.pos(1.0, 1.0, -0.5).tex(0.0F + var11, 0.0F + var12).endVertex();
+         var3.pos(-1.0, 1.0, -0.5).tex(4.0F + var11, 0.0F + var12).endVertex();
+         var2.draw();
+         GlStateManager.popMatrix();
+         GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+         GlStateManager.disableBlend();
+      }
    }
 
    private void renderFireInFirstPerson() {
       Tessellator var1 = Tessellator.getInstance();
       BufferBuilder var2 = var1.getBuffer();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 0.9F);
@@ -481,12 +512,13 @@
          float var12 = -0.5F;
          float var13 = 0.5F;
          float var14 = -0.5F;
          GlStateManager.translate(-(var4 * 2 - 1) * 0.24F, -0.3F, 0.0F);
          GlStateManager.rotate((var4 * 2 - 1) * 10.0F, 0.0F, 1.0F, 0.0F);
          var2.begin(7, DefaultVertexFormats.POSITION_TEX);
+         var2.setSprite(var5);
          var2.pos(-0.5, -0.5, -0.5).tex(var7, var9).endVertex();
          var2.pos(0.5, -0.5, -0.5).tex(var6, var9).endVertex();
          var2.pos(0.5, 0.5, -0.5).tex(var6, var8).endVertex();
          var2.pos(-0.5, 0.5, -0.5).tex(var7, var8).endVertex();
          var1.draw();
          GlStateManager.popMatrix();
@@ -506,24 +538,48 @@
       ItemStack var3 = var1.getHeldItemOffhand();
       if (var1.isRowingBoat()) {
          this.equippedProgressMainHand = MathHelper.clamp(this.equippedProgressMainHand - 0.4F, 0.0F, 1.0F);
          this.equippedProgressOffHand = MathHelper.clamp(this.equippedProgressOffHand - 0.4F, 0.0F, 1.0F);
       } else {
          float var4 = var1.getCooledAttackStrength(1.0F);
-         this.equippedProgressMainHand = this.equippedProgressMainHand
-            + MathHelper.clamp((Objects.equals(this.itemStackMainHand, var2) ? var4 * var4 * var4 : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
-         this.equippedProgressOffHand = this.equippedProgressOffHand
-            + MathHelper.clamp((Objects.equals(this.itemStackOffHand, var3) ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         if (Reflector.ForgeHooksClient_shouldCauseReequipAnimation.exists()) {
+            boolean var5 = Reflector.callBoolean(
+               Reflector.ForgeHooksClient_shouldCauseReequipAnimation, new Object[]{this.itemStackMainHand, var2, var1.inventory.currentItem}
+            );
+            boolean var6 = Reflector.callBoolean(Reflector.ForgeHooksClient_shouldCauseReequipAnimation, new Object[]{this.itemStackOffHand, var3, -1});
+            if (!var5 && !Objects.equals(this.itemStackMainHand, var2)) {
+               this.itemStackMainHand = var2;
+            }
+
+            if (!var5 && !Objects.equals(this.itemStackOffHand, var3)) {
+               this.itemStackOffHand = var3;
+            }
+
+            this.equippedProgressMainHand = this.equippedProgressMainHand
+               + MathHelper.clamp((!var5 ? var4 * var4 * var4 : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
+            this.equippedProgressOffHand = this.equippedProgressOffHand + MathHelper.clamp((!var6 ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         } else {
+            this.equippedProgressMainHand = this.equippedProgressMainHand
+               + MathHelper.clamp((Objects.equals(this.itemStackMainHand, var2) ? var4 * var4 * var4 : 0.0F) - this.equippedProgressMainHand, -0.4F, 0.4F);
+            this.equippedProgressOffHand = this.equippedProgressOffHand
+               + MathHelper.clamp((Objects.equals(this.itemStackOffHand, var3) ? 1 : 0) - this.equippedProgressOffHand, -0.4F, 0.4F);
+         }
       }
 
       if (this.equippedProgressMainHand < 0.1F) {
          this.itemStackMainHand = var2;
+         if (Config.isShaders()) {
+            Shaders.setItemToRenderMain(this.itemStackMainHand);
+         }
       }
 
       if (this.equippedProgressOffHand < 0.1F) {
          this.itemStackOffHand = var3;
+         if (Config.isShaders()) {
+            Shaders.setItemToRenderOff(this.itemStackOffHand);
+         }
       }
    }
 
    public void resetEquippedProgress(EnumHand var1) {
       if (var1 == EnumHand.MAIN_HAND) {
          this.equippedProgressMainHand = 0.0F;
--- net/minecraft/client/renderer/Matrix4f.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/Matrix4f.java	Mon Aug 18 09:39:52 2025
--- net/minecraft/client/renderer/OpenGlHelper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/OpenGlHelper.java	Mon Aug 18 09:39:52 2025
@@ -3,20 +3,22 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.URI;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
+import java.util.ArrayList;
 import java.util.Locale;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.settings.GameSettings;
 import net.minecraft.util.Util;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.Sys;
+import org.lwjgl.opengl.ARBCopyBuffer;
 import org.lwjgl.opengl.ARBFramebufferObject;
 import org.lwjgl.opengl.ARBMultitexture;
 import org.lwjgl.opengl.ARBShaderObjects;
 import org.lwjgl.opengl.ARBVertexBufferObject;
 import org.lwjgl.opengl.ARBVertexShader;
 import org.lwjgl.opengl.ContextCapabilities;
@@ -25,12 +27,13 @@
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.GL13;
 import org.lwjgl.opengl.GL14;
 import org.lwjgl.opengl.GL15;
 import org.lwjgl.opengl.GL20;
 import org.lwjgl.opengl.GL30;
+import org.lwjgl.opengl.GL31;
 import org.lwjgl.opengl.GLContext;
 import oshi.SystemInfo;
 import oshi.hardware.Processor;
 
 public class OpenGlHelper {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -85,17 +88,53 @@
    private static String cpu;
    public static boolean vboSupported;
    public static boolean vboSupportedAti;
    private static boolean arbVbo;
    public static int GL_ARRAY_BUFFER;
    public static int GL_STATIC_DRAW;
+   public static float lastBrightnessX = 0.0F;
+   public static float lastBrightnessY = 0.0F;
+   public static boolean openGL31;
+   public static boolean vboRegions;
+   public static int GL_COPY_READ_BUFFER;
+   public static int GL_COPY_WRITE_BUFFER;
+   public static final int GL_QUADS = 7;
+   public static final int GL_TRIANGLES = 4;
 
    public static void initializeTextures() {
+      Config.initDisplay();
       ContextCapabilities var0 = GLContext.getCapabilities();
       arbMultitexture = var0.GL_ARB_multitexture && !var0.OpenGL13;
       arbTextureEnvCombine = var0.GL_ARB_texture_env_combine && !var0.OpenGL13;
+      openGL31 = var0.OpenGL31;
+      if (openGL31) {
+         GL_COPY_READ_BUFFER = 36662;
+         GL_COPY_WRITE_BUFFER = 36663;
+      } else {
+         GL_COPY_READ_BUFFER = 36662;
+         GL_COPY_WRITE_BUFFER = 36663;
+      }
+
+      boolean var1 = openGL31 || var0.GL_ARB_copy_buffer;
+      boolean var2 = var0.OpenGL14;
+      vboRegions = var1 && var2;
+      if (!vboRegions) {
+         ArrayList var3 = new ArrayList();
+         if (!var1) {
+            var3.add("OpenGL 1.3, ARB_copy_buffer");
+         }
+
+         if (!var2) {
+            var3.add("OpenGL 1.4");
+         }
+
+         String var4 = "VboRegions not supported, missing: " + Config.listToString(var3);
+         Config.dbg(var4);
+         logText = logText + var4 + "\n";
+      }
+
       if (arbMultitexture) {
          logText = logText + "Using ARB_multitexture.\n";
          defaultTexUnit = 33984;
          lightmapTexUnit = 33985;
          GL_TEXTURE2 = 33986;
       } else {
@@ -224,14 +263,14 @@
          logText = logText + "ARB_shader_objects is " + (var0.GL_ARB_shader_objects ? "" : "not ") + "supported, ";
          logText = logText + "ARB_vertex_shader is " + (var0.GL_ARB_vertex_shader ? "" : "not ") + "supported, and ";
          logText = logText + "ARB_fragment_shader is " + (var0.GL_ARB_fragment_shader ? "" : "not ") + "supported.\n";
       }
 
       shadersSupported = framebufferSupported && shadersAvailable;
-      String var1 = GL11.glGetString(7936).toLowerCase(Locale.ROOT);
-      nvidia = var1.contains("nvidia");
+      String var6 = GL11.glGetString(7936).toLowerCase(Locale.ROOT);
+      nvidia = var6.contains("nvidia");
       arbVbo = !var0.OpenGL15 && var0.GL_ARB_vertex_buffer_object;
       vboSupported = var0.OpenGL15 || arbVbo;
       logText = logText + "VBOs are " + (vboSupported ? "" : "not ") + "available because ";
       if (vboSupported) {
          if (arbVbo) {
             logText = logText + "ARB_vertex_buffer_object is supported.\n";
@@ -241,25 +280,25 @@
             logText = logText + "OpenGL 1.5 is supported.\n";
             GL_STATIC_DRAW = 35044;
             GL_ARRAY_BUFFER = 34962;
          }
       }
 
-      ati = var1.contains("ati");
+      ati = var6.contains("ati");
       if (ati) {
          if (vboSupported) {
             vboSupportedAti = true;
          } else {
             GameSettings.Options.RENDER_DISTANCE.setValueMax(16.0F);
          }
       }
 
       try {
-         Processor[] var2 = new SystemInfo().getHardware().getProcessors();
-         cpu = String.format("%dx %s", var2.length, var2[0]).replaceAll("\\s+", " ");
-      } catch (Throwable var3) {
+         Processor[] var7 = new SystemInfo().getHardware().getProcessors();
+         cpu = String.format("%dx %s", var7.length, var7[0]).replaceAll("\\s+", " ");
+      } catch (Throwable var5) {
       }
    }
 
    public static boolean areShadersSupported() {
       return shadersSupported;
    }
@@ -478,13 +517,17 @@
       } else {
          GL15.glDeleteBuffers(var0);
       }
    }
 
    public static boolean useVbo() {
-      return vboSupported && Minecraft.getMinecraft().gameSettings.useVbo;
+      if (Config.isMultiTexture()) {
+         return false;
+      } else {
+         return Config.isRenderRegions() && !vboRegions ? false : vboSupported && Minecraft.getMinecraft().gameSettings.useVbo;
+      }
    }
 
    public static void glBindFramebuffer(int var0, int var1) {
       if (framebufferSupported) {
          switch (framebufferType) {
             case BASE:
@@ -659,12 +702,17 @@
    public static void setLightmapTextureCoords(int var0, float var1, float var2) {
       if (arbMultitexture) {
          ARBMultitexture.glMultiTexCoord2fARB(var0, var1, var2);
       } else {
          GL13.glMultiTexCoord2f(var0, var1, var2);
       }
+
+      if (var0 == lightmapTexUnit) {
+         lastBrightnessX = var1;
+         lastBrightnessY = var2;
+      }
    }
 
    public static void glBlendFunc(int var0, int var1, int var2, int var3) {
       if (openGL14) {
          if (extBlendFuncSeparate) {
             EXTBlendFuncSeparate.glBlendFuncSeparateEXT(var0, var1, var2, var3);
@@ -674,13 +722,41 @@
       } else {
          GL11.glBlendFunc(var0, var1);
       }
    }
 
    public static boolean isFramebufferEnabled() {
-      return framebufferSupported && Minecraft.getMinecraft().gameSettings.fboEnable;
+      if (Config.isFastRender()) {
+         return false;
+      } else {
+         return Config.isAntialiasing() ? false : framebufferSupported && Minecraft.getMinecraft().gameSettings.fboEnable;
+      }
+   }
+
+   public static void glBufferData(int var0, long var1, int var3) {
+      if (arbVbo) {
+         ARBVertexBufferObject.glBufferDataARB(var0, var1, var3);
+      } else {
+         GL15.glBufferData(var0, var1, var3);
+      }
+   }
+
+   public static void glBufferSubData(int var0, long var1, ByteBuffer var3) {
+      if (arbVbo) {
+         ARBVertexBufferObject.glBufferSubDataARB(var0, var1, var3);
+      } else {
+         GL15.glBufferSubData(var0, var1, var3);
+      }
+   }
+
+   public static void glCopyBufferSubData(int var0, int var1, long var2, long var4, long var6) {
+      if (openGL31) {
+         GL31.glCopyBufferSubData(var0, var1, var2, var4, var6);
+      } else {
+         ARBCopyBuffer.glCopyBufferSubData(var0, var1, var2, var4, var6);
+      }
    }
 
    public static String getCpu() {
       return cpu == null ? "<unknown>" : cpu;
    }
 
--- net/minecraft/client/renderer/RegionRenderCacheBuilder.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/RegionRenderCacheBuilder.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/RenderGlobal.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/RenderGlobal.java	Mon Aug 18 09:39:52 2025
@@ -1,18 +1,24 @@
 package net.minecraft.client.renderer;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.gson.JsonSyntaxException;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import java.io.IOException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
@@ -23,12 +29,13 @@
 import net.minecraft.block.SoundType;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.audio.ISound;
 import net.minecraft.client.audio.PositionedSoundRecord;
+import net.minecraft.client.multiplayer.ChunkProviderClient;
 import net.minecraft.client.multiplayer.WorldClient;
 import net.minecraft.client.particle.Particle;
 import net.minecraft.client.renderer.chunk.ChunkRenderDispatcher;
 import net.minecraft.client.renderer.chunk.CompiledChunk;
 import net.minecraft.client.renderer.chunk.IRenderChunkFactory;
 import net.minecraft.client.renderer.chunk.ListChunkFactory;
@@ -36,21 +43,25 @@
 import net.minecraft.client.renderer.chunk.VboChunkFactory;
 import net.minecraft.client.renderer.chunk.VisGraph;
 import net.minecraft.client.renderer.culling.ClippingHelper;
 import net.minecraft.client.renderer.culling.ClippingHelperImpl;
 import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.client.renderer.culling.ICamera;
+import net.minecraft.client.renderer.entity.RenderItemFrame;
 import net.minecraft.client.renderer.entity.RenderManager;
 import net.minecraft.client.renderer.texture.TextureAtlasSprite;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
+import net.minecraft.client.renderer.tileentity.TileEntitySignRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumType;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.client.resources.IResourceManagerReloadListener;
 import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.client.shader.ShaderGroup;
 import net.minecraft.client.shader.ShaderLinkHelper;
 import net.minecraft.crash.CrashReport;
@@ -77,45 +88,68 @@
 import net.minecraft.util.SoundEvent;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
 import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
+import net.minecraft.util.math.BlockPos.PooledMutableBlockPos;
+import net.minecraft.util.math.RayTraceResult.Type;
+import net.minecraft.world.DimensionType;
 import net.minecraft.world.IWorldEventListener;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldProvider;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.optifine.CustomColors;
+import net.optifine.CustomSky;
+import net.optifine.DynamicLights;
+import net.optifine.Lagometer;
+import net.optifine.RandomEntities;
+import net.optifine.SmartAnimations;
+import net.optifine.reflect.Reflector;
+import net.optifine.render.ChunkVisibility;
+import net.optifine.render.CloudRenderer;
+import net.optifine.render.RenderEnv;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
+import net.optifine.shaders.ShadowUtils;
+import net.optifine.shaders.gui.GuiShaderOptions;
+import net.optifine.util.ChunkUtils;
+import net.optifine.util.RenderChunkUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.lwjgl.input.Keyboard;
 import org.lwjgl.util.vector.Vector3f;
 import org.lwjgl.util.vector.Vector4f;
 
 public class RenderGlobal implements IWorldEventListener, IResourceManagerReloadListener {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final ResourceLocation MOON_PHASES_TEXTURES = new ResourceLocation("textures/environment/moon_phases.png");
    private static final ResourceLocation SUN_TEXTURES = new ResourceLocation("textures/environment/sun.png");
    private static final ResourceLocation CLOUDS_TEXTURES = new ResourceLocation("textures/environment/clouds.png");
    private static final ResourceLocation END_SKY_TEXTURES = new ResourceLocation("textures/environment/end_sky.png");
    private static final ResourceLocation FORCEFIELD_TEXTURES = new ResourceLocation("textures/misc/forcefield.png");
-   private final Minecraft mc;
+   public final Minecraft mc;
    private final TextureManager renderEngine;
    private final RenderManager renderManager;
    private WorldClient world;
-   private Set<RenderChunk> chunksToUpdate = Sets.newLinkedHashSet();
+   private Set<RenderChunk> chunksToUpdate = new ObjectLinkedOpenHashSet();
    private List<RenderGlobal.ContainerLocalRenderInformation> renderInfos = Lists.newArrayListWithCapacity(69696);
    private final Set<TileEntity> setTileEntities = Sets.newHashSet();
    private ViewFrustum viewFrustum;
    private int starGLCallList = -1;
    private int glSkyList = -1;
    private int glSkyList2 = -1;
    private final VertexFormat vertexBufferFormat;
    private VertexBuffer starVBO;
    private VertexBuffer skyVBO;
    private VertexBuffer sky2VBO;
    private int cloudTickCounter;
-   private final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
+   public final Map<Integer, DestroyBlockProgress> damagedBlocks = Maps.newHashMap();
    private final Map<BlockPos, ISound> mapSoundPositions = Maps.newHashMap();
    private final TextureAtlasSprite[] destroyBlockIcons = new TextureAtlasSprite[10];
    private Framebuffer entityOutlineFramebuffer;
    private ShaderGroup entityOutlineShader;
    private double frustumUpdatePosX = Double.MIN_VALUE;
    private double frustumUpdatePosY = Double.MIN_VALUE;
@@ -141,17 +175,44 @@
    private final Vector3d debugTerrainFrustumPosition = new Vector3d();
    private boolean vboEnabled;
    IRenderChunkFactory renderChunkFactory;
    private double prevRenderSortX;
    private double prevRenderSortY;
    private double prevRenderSortZ;
-   private boolean displayListEntitiesDirty = true;
+   public boolean displayListEntitiesDirty = true;
    private boolean entityOutlinesRendered;
    private final Set<BlockPos> setLightUpdates = Sets.newHashSet();
+   private CloudRenderer cloudRenderer;
+   public Entity renderedEntity;
+   public Set chunksToResortTransparency = new LinkedHashSet();
+   public Set chunksToUpdateForced = new LinkedHashSet();
+   private Set<RenderChunk> chunksToUpdatePrev = new ObjectLinkedOpenHashSet();
+   private Deque visibilityDeque = new ArrayDeque();
+   private List renderInfosEntities = new ArrayList(1024);
+   private List renderInfosTileEntities = new ArrayList(1024);
+   private List renderInfosNormal = new ArrayList(1024);
+   private List renderInfosEntitiesNormal = new ArrayList(1024);
+   private List renderInfosTileEntitiesNormal = new ArrayList(1024);
+   private List renderInfosShadow = new ArrayList(1024);
+   private List renderInfosEntitiesShadow = new ArrayList(1024);
+   private List renderInfosTileEntitiesShadow = new ArrayList(1024);
+   private int renderDistance = 0;
+   private int renderDistanceSq = 0;
+   private static final Set SET_ALL_FACINGS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(EnumFacing.VALUES)));
+   private int countTileEntitiesRendered;
+   private IChunkProvider worldChunkProvider = null;
+   private Long2ObjectMap<Chunk> worldChunkProviderMap = null;
+   private int countLoadedChunksPrev = 0;
+   private RenderEnv renderEnv = new RenderEnv(Blocks.AIR.getDefaultState(), new BlockPos(0, 0, 0));
+   public boolean renderOverlayDamaged = false;
+   public boolean renderOverlayEyes = false;
+   private boolean firstWorldLoad = false;
+   private static int renderEntitiesCounter = 0;
 
    public RenderGlobal(Minecraft var1) {
+      this.cloudRenderer = new CloudRenderer(var1);
       this.mc = var1;
       this.renderManager = var1.getRenderManager();
       this.renderEngine = var1.getTextureManager();
       this.renderEngine.bindTexture(FORCEFIELD_TEXTURES);
       GlStateManager.glTexParameteri(3553, 10242, 10497);
       GlStateManager.glTexParameteri(3553, 10243, 10497);
@@ -164,19 +225,18 @@
       } else {
          this.renderContainer = new RenderList();
          this.renderChunkFactory = new ListChunkFactory();
       }
 
       this.vertexBufferFormat = new VertexFormat();
-      this.vertexBufferFormat.addElement(new VertexFormatElement(0, VertexFormatElement.EnumType.FLOAT, VertexFormatElement.EnumUsage.POSITION, 3));
+      this.vertexBufferFormat.addElement(new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.POSITION, 3));
       this.generateStars();
       this.generateSky();
       this.generateSky2();
    }
 
-   @Override
    public void onResourceManagerReload(IResourceManager var1) {
       this.updateDestroyBlockIcons();
    }
 
    private void updateDestroyBlockIcons() {
       TextureMap var1 = this.mc.getTextureMapBlocks();
@@ -225,13 +285,15 @@
          this.entityOutlineFramebuffer.framebufferRenderExt(this.mc.displayWidth, this.mc.displayHeight, false);
          GlStateManager.disableBlend();
       }
    }
 
    protected boolean isRenderEntityOutlines() {
-      return this.entityOutlineFramebuffer != null && this.entityOutlineShader != null && this.mc.player != null;
+      return !Config.isFastRender() && !Config.isShaders() && !Config.isAntialiasing()
+         ? this.entityOutlineFramebuffer != null && this.entityOutlineShader != null && this.mc.player != null
+         : false;
    }
 
    private void generateSky2() {
       Tessellator var1 = Tessellator.getInstance();
       BufferBuilder var2 = var1.getBuffer();
       if (this.sky2VBO != null) {
@@ -286,26 +348,27 @@
    }
 
    private void renderSky(BufferBuilder var1, float var2, boolean var3) {
       byte var4 = 64;
       byte var5 = 6;
       var1.begin(7, DefaultVertexFormats.POSITION);
+      int var6 = (this.renderDistance / 64 + 1) * 64 + 64;
 
-      for (short var6 = -384; var6 <= 384; var6 += 64) {
-         for (short var7 = -384; var7 <= 384; var7 += 64) {
-            float var8 = var6;
-            float var9 = var6 + 64;
+      for (int var7 = -var6; var7 <= var6; var7 += 64) {
+         for (int var8 = -var6; var8 <= var6; var8 += 64) {
+            float var9 = var7;
+            float var10 = var7 + 64;
             if (var3) {
-               var9 = var6;
-               var8 = var6 + 64;
+               var10 = var7;
+               var9 = var7 + 64;
             }
 
-            var1.pos(var8, var2, var7).endVertex();
-            var1.pos(var9, var2, var7).endVertex();
-            var1.pos(var9, var2, var7 + 64).endVertex();
-            var1.pos(var8, var2, var7 + 64).endVertex();
+            var1.pos(var9, var2, var8).endVertex();
+            var1.pos(var10, var2, var8).endVertex();
+            var1.pos(var10, var2, var8 + 64).endVertex();
+            var1.pos(var9, var2, var8 + 64).endVertex();
          }
       }
    }
 
    private void generateStars() {
       Tessellator var1 = Tessellator.getInstance();
@@ -368,17 +431,17 @@
                double var39 = 0.0;
                double var41 = ((var38 & 2) - 1) * var10;
                double var43 = ((var38 + 1 & 2) - 1) * var10;
                double var45 = 0.0;
                double var47 = var41 * var36 - var43 * var34;
                double var49 = var43 * var36 + var41 * var34;
-               double var53 = var47 * var28 + 0.0 * var30;
-               double var55 = 0.0 * var28 - var47 * var30;
-               double var57 = var55 * var22 - var49 * var24;
-               double var61 = var49 * var22 + var55 * var24;
-               var1.pos(var14 + var57, var16 + var53, var18 + var61).endVertex();
+               double var51 = var47 * var28 + 0.0 * var30;
+               double var53 = 0.0 * var28 - var47 * var30;
+               double var55 = var53 * var22 - var49 * var24;
+               double var57 = var49 * var22 + var53 * var24;
+               var1.pos(var14 + var55, var16 + var51, var18 + var57).endVertex();
             }
          }
       }
    }
 
    public void setWorldAndLoadRenderers(@Nullable WorldClient var1) {
@@ -391,18 +454,28 @@
       this.frustumUpdatePosZ = Double.MIN_VALUE;
       this.frustumUpdatePosChunkX = Integer.MIN_VALUE;
       this.frustumUpdatePosChunkY = Integer.MIN_VALUE;
       this.frustumUpdatePosChunkZ = Integer.MIN_VALUE;
       this.renderManager.setWorld(var1);
       this.world = var1;
+      if (Config.isDynamicLights()) {
+         DynamicLights.clear();
+      }
+
+      ChunkVisibility.reset();
+      this.worldChunkProvider = null;
+      this.worldChunkProviderMap = null;
+      this.renderEnv.reset(null, null);
+      Shaders.checkWorldChanged(this.world);
       if (var1 != null) {
          var1.addEventListener(this);
          this.loadRenderers();
       } else {
          this.chunksToUpdate.clear();
-         this.renderInfos.clear();
+         this.chunksToUpdatePrev.clear();
+         this.clearRenderInfos();
          if (this.viewFrustum != null) {
             this.viewFrustum.deleteGlResources();
             this.viewFrustum = null;
          }
 
          if (this.renderDispatcher != null) {
@@ -417,31 +490,36 @@
       if (this.world != null) {
          if (this.renderDispatcher == null) {
             this.renderDispatcher = new ChunkRenderDispatcher();
          }
 
          this.displayListEntitiesDirty = true;
-         Blocks.LEAVES.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
-         Blocks.LEAVES2.setGraphicsLevel(this.mc.gameSettings.fancyGraphics);
+         Blocks.LEAVES.setGraphicsLevel(Config.isTreesFancy());
+         Blocks.LEAVES2.setGraphicsLevel(Config.isTreesFancy());
+         BlockModelRenderer.updateAoLightValue();
+         if (Config.isDynamicLights()) {
+            DynamicLights.clear();
+         }
+
+         SmartAnimations.update();
          this.renderDistanceChunks = this.mc.gameSettings.renderDistanceChunks;
+         this.renderDistance = this.renderDistanceChunks * 16;
+         this.renderDistanceSq = this.renderDistance * this.renderDistance;
          boolean var1 = this.vboEnabled;
          this.vboEnabled = OpenGlHelper.useVbo();
          if (var1 && !this.vboEnabled) {
             this.renderContainer = new RenderList();
             this.renderChunkFactory = new ListChunkFactory();
          } else if (!var1 && this.vboEnabled) {
             this.renderContainer = new VboRenderList();
             this.renderChunkFactory = new VboChunkFactory();
          }
 
-         if (var1 != this.vboEnabled) {
-            this.generateStars();
-            this.generateSky();
-            this.generateSky2();
-         }
-
+         this.generateStars();
+         this.generateSky();
+         this.generateSky2();
          if (this.viewFrustum != null) {
             this.viewFrustum.deleteGlResources();
          }
 
          this.stopChunkUpdates();
          synchronized (this.setTileEntities) {
@@ -455,115 +533,170 @@
                this.viewFrustum.updateChunkPositions(var5.posX, var5.posZ);
             }
          }
 
          this.renderEntitiesStartupCounter = 2;
       }
+
+      if (this.mc.player == null) {
+         this.firstWorldLoad = true;
+      }
    }
 
    protected void stopChunkUpdates() {
       this.chunksToUpdate.clear();
       this.renderDispatcher.stopChunkUpdates();
    }
 
    public void createBindEntityOutlineFbs(int var1, int var2) {
-      if (OpenGlHelper.shadersSupported) {
-         if (this.entityOutlineShader != null) {
-            this.entityOutlineShader.createBindFramebuffers(var1, var2);
-         }
+      if (OpenGlHelper.shadersSupported && this.entityOutlineShader != null) {
+         this.entityOutlineShader.createBindFramebuffers(var1, var2);
       }
    }
 
    public void renderEntities(Entity var1, ICamera var2, float var3) {
+      int var4 = 0;
+      if (Reflector.MinecraftForgeClient_getRenderPass.exists()) {
+         var4 = Reflector.callInt(Reflector.MinecraftForgeClient_getRenderPass, new Object[0]);
+      }
+
       if (this.renderEntitiesStartupCounter > 0) {
+         if (var4 > 0) {
+            return;
+         }
+
          this.renderEntitiesStartupCounter--;
       } else {
-         double var4 = var1.prevPosX + (var1.posX - var1.prevPosX) * var3;
-         double var6 = var1.prevPosY + (var1.posY - var1.prevPosY) * var3;
-         double var8 = var1.prevPosZ + (var1.posZ - var1.prevPosZ) * var3;
+         double var5 = var1.prevPosX + (var1.posX - var1.prevPosX) * var3;
+         double var7 = var1.prevPosY + (var1.posY - var1.prevPosY) * var3;
+         double var9 = var1.prevPosZ + (var1.posZ - var1.prevPosZ) * var3;
          this.world.profiler.startSection("prepare");
          TileEntityRendererDispatcher.instance
             .prepare(this.world, this.mc.getTextureManager(), this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.objectMouseOver, var3);
          this.renderManager
             .cacheActiveRenderInfo(this.world, this.mc.fontRenderer, this.mc.getRenderViewEntity(), this.mc.pointedEntity, this.mc.gameSettings, var3);
-         this.countEntitiesTotal = 0;
-         this.countEntitiesRendered = 0;
-         this.countEntitiesHidden = 0;
-         Entity var10 = this.mc.getRenderViewEntity();
-         double var11 = var10.lastTickPosX + (var10.posX - var10.lastTickPosX) * var3;
-         double var13 = var10.lastTickPosY + (var10.posY - var10.lastTickPosY) * var3;
-         double var15 = var10.lastTickPosZ + (var10.posZ - var10.lastTickPosZ) * var3;
-         TileEntityRendererDispatcher.staticPlayerX = var11;
-         TileEntityRendererDispatcher.staticPlayerY = var13;
-         TileEntityRendererDispatcher.staticPlayerZ = var15;
-         this.renderManager.setRenderPosition(var11, var13, var15);
+         renderEntitiesCounter++;
+         if (var4 == 0) {
+            this.countEntitiesTotal = 0;
+            this.countEntitiesRendered = 0;
+            this.countEntitiesHidden = 0;
+            this.countTileEntitiesRendered = 0;
+         }
+
+         Entity var11 = this.mc.getRenderViewEntity();
+         double var12 = var11.lastTickPosX + (var11.posX - var11.lastTickPosX) * var3;
+         double var14 = var11.lastTickPosY + (var11.posY - var11.lastTickPosY) * var3;
+         double var16 = var11.lastTickPosZ + (var11.posZ - var11.lastTickPosZ) * var3;
+         TileEntityRendererDispatcher.staticPlayerX = var12;
+         TileEntityRendererDispatcher.staticPlayerY = var14;
+         TileEntityRendererDispatcher.staticPlayerZ = var16;
+         this.renderManager.setRenderPosition(var12, var14, var16);
          this.mc.entityRenderer.enableLightmap();
          this.world.profiler.endStartSection("global");
-         List var17 = this.world.getLoadedEntityList();
-         this.countEntitiesTotal = var17.size();
+         List var18 = this.world.getLoadedEntityList();
+         if (var4 == 0) {
+            this.countEntitiesTotal = var18.size();
+         }
+
+         if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
+            GlStateManager.disableFog();
+         }
+
+         boolean var19 = Reflector.ForgeEntity_shouldRenderInPass.exists();
+         boolean var20 = Reflector.ForgeTileEntity_shouldRenderInPass.exists();
 
-         for (int var18 = 0; var18 < this.world.weatherEffects.size(); var18++) {
-            Entity var19 = this.world.weatherEffects.get(var18);
-            this.countEntitiesRendered++;
-            if (var19.isInRangeToRender3d(var4, var6, var8)) {
-               this.renderManager.renderEntityStatic(var19, var3, false);
+         for (int var21 = 0; var21 < this.world.weatherEffects.size(); var21++) {
+            Entity var22 = (Entity)this.world.weatherEffects.get(var21);
+            if (!var19 || Reflector.callBoolean(var22, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{var4})) {
+               this.countEntitiesRendered++;
+               if (var22.isInRangeToRender3d(var5, var7, var9)) {
+                  this.renderManager.renderEntityStatic(var22, var3, false);
+               }
             }
          }
 
          this.world.profiler.endStartSection("entities");
-         ArrayList var31 = Lists.newArrayList();
-         ArrayList var32 = Lists.newArrayList();
-         BlockPos.PooledMutableBlockPos var20 = BlockPos.PooledMutableBlockPos.retain();
-
-         for (RenderGlobal.ContainerLocalRenderInformation var22 : this.renderInfos) {
-            Chunk var23 = this.world.getChunk(var22.renderChunk.getPosition());
-            ClassInheritanceMultiMap var24 = var23.getEntityLists()[var22.renderChunk.getPosition().getY() / 16];
-            if (!var24.isEmpty()) {
-               for (Entity var26 : var24) {
-                  boolean var27 = this.renderManager.shouldRender(var26, var2, var4, var6, var8) || var26.isRidingOrBeingRiddenBy(this.mc.player);
-                  if (var27) {
-                     boolean var28 = this.mc.getRenderViewEntity() instanceof EntityLivingBase
-                        ? ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping()
-                        : false;
-                     if ((var26 != this.mc.getRenderViewEntity() || this.mc.gameSettings.thirdPersonView != 0 || var28)
-                        && (!(var26.posY >= 0.0) || !(var26.posY < 256.0) || this.world.isBlockLoaded(var20.setPos(var26)))) {
-                        this.countEntitiesRendered++;
-                        this.renderManager.renderEntityStatic(var26, var3, false);
-                        if (this.isOutlineActive(var26, var10, var2)) {
-                           var31.add(var26);
-                        }
-
-                        if (this.renderManager.isRenderMultipass(var26)) {
-                           var32.add(var26);
+         boolean var36 = Config.isShaders();
+         if (var36) {
+            Shaders.beginEntities();
+         }
+
+         RenderItemFrame.updateItemRenderDistance();
+         ArrayList var37 = Lists.newArrayList();
+         ArrayList var23 = Lists.newArrayList();
+         PooledMutableBlockPos var24 = PooledMutableBlockPos.retain();
+         boolean var25 = Shaders.isShadowPass && !this.mc.player.isSpectator();
+
+         for (RenderGlobal.ContainerLocalRenderInformation var27 : this.renderInfosEntities) {
+            Chunk var28 = var27.renderChunk.getChunk();
+            ClassInheritanceMultiMap var29 = var28.getEntityLists()[var27.renderChunk.getPosition().getY() / 16];
+            if (!var29.isEmpty()) {
+               for (Entity var31 : var29) {
+                  if (!var19 || Reflector.callBoolean(var31, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{var4})) {
+                     boolean var32 = this.renderManager.shouldRender(var31, var2, var5, var7, var9) || var31.isRidingOrBeingRiddenBy(this.mc.player);
+                     if (var32) {
+                        boolean var33 = this.mc.getRenderViewEntity() instanceof EntityLivingBase
+                           ? ((EntityLivingBase)this.mc.getRenderViewEntity()).isPlayerSleeping()
+                           : false;
+                        if ((var31 != this.mc.getRenderViewEntity() || var25 || this.mc.gameSettings.thirdPersonView != 0 || var33)
+                           && (var31.posY < 0.0 || var31.posY >= 256.0 || this.world.isBlockLoaded(var24.setPos(var31)))) {
+                           this.countEntitiesRendered++;
+                           this.renderedEntity = var31;
+                           if (var36) {
+                              Shaders.nextEntity(var31);
+                           }
+
+                           this.renderManager.renderEntityStatic(var31, var3, false);
+                           this.renderedEntity = null;
+                           if (this.isOutlineActive(var31, var11, var2)) {
+                              var37.add(var31);
+                           }
+
+                           if (this.renderManager.isRenderMultipass(var31)) {
+                              var23.add(var31);
+                           }
                         }
                      }
                   }
                }
             }
          }
 
-         var20.release();
-         if (!var32.isEmpty()) {
-            for (Entity var38 : var32) {
-               this.renderManager.renderMultipass(var38, var3);
+         var24.release();
+         if (!var23.isEmpty()) {
+            for (Entity var42 : var23) {
+               if (!var19 || Reflector.callBoolean(var42, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{var4})) {
+                  if (var36) {
+                     Shaders.nextEntity(var42);
+                  }
+
+                  this.renderManager.renderMultipass(var42, var3);
+               }
             }
          }
 
-         if (this.isRenderEntityOutlines() && (!var31.isEmpty() || this.entityOutlinesRendered)) {
+         if (var4 == 0 && this.isRenderEntityOutlines() && (!var37.isEmpty() || this.entityOutlinesRendered)) {
             this.world.profiler.endStartSection("entityOutlines");
             this.entityOutlineFramebuffer.framebufferClear();
-            this.entityOutlinesRendered = !var31.isEmpty();
-            if (!var31.isEmpty()) {
+            this.entityOutlinesRendered = !var37.isEmpty();
+            if (!var37.isEmpty()) {
                GlStateManager.depthFunc(519);
                GlStateManager.disableFog();
                this.entityOutlineFramebuffer.bindFramebuffer(false);
                RenderHelper.disableStandardItemLighting();
                this.renderManager.setRenderOutlines(true);
 
-               for (int var34 = 0; var34 < var31.size(); var34++) {
-                  this.renderManager.renderEntityStatic((Entity)var31.get(var34), var3, false);
+               for (int var39 = 0; var39 < var37.size(); var39++) {
+                  Entity var43 = (Entity)var37.get(var39);
+                  if (!var19 || Reflector.callBoolean(var43, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{var4})) {
+                     if (var36) {
+                        Shaders.nextEntity(var43);
+                     }
+
+                     this.renderManager.renderEntityStatic(var43, var3, false);
+                  }
                }
 
                this.renderManager.setRenderOutlines(false);
                RenderHelper.enableStandardItemLighting();
                GlStateManager.depthMask(false);
                this.entityOutlineShader.render(var3);
@@ -577,55 +710,138 @@
                GlStateManager.enableAlpha();
             }
 
             this.mc.getFramebuffer().bindFramebuffer(false);
          }
 
+         if (!this.isRenderEntityOutlines() && (!var37.isEmpty() || this.entityOutlinesRendered)) {
+            this.world.profiler.endStartSection("entityOutlines");
+            this.entityOutlinesRendered = !var37.isEmpty();
+            if (!var37.isEmpty()) {
+               if (var36) {
+                  Shaders.beginEntitiesGlowing();
+               }
+
+               GlStateManager.disableFog();
+               GlStateManager.disableDepth();
+               this.mc.entityRenderer.disableLightmap();
+               RenderHelper.disableStandardItemLighting();
+               this.renderManager.setRenderOutlines(true);
+
+               for (int var40 = 0; var40 < var37.size(); var40++) {
+                  Entity var44 = (Entity)var37.get(var40);
+                  if (!var19 || Reflector.callBoolean(var44, Reflector.ForgeEntity_shouldRenderInPass, new Object[]{var4})) {
+                     if (var36) {
+                        Shaders.nextEntity(var44);
+                     }
+
+                     this.renderManager.renderEntityStatic(var44, var3, false);
+                  }
+               }
+
+               this.renderManager.setRenderOutlines(false);
+               RenderHelper.enableStandardItemLighting();
+               this.mc.entityRenderer.enableLightmap();
+               GlStateManager.enableDepth();
+               GlStateManager.enableFog();
+               if (var36) {
+                  Shaders.endEntitiesGlowing();
+               }
+            }
+         }
+
+         if (var36) {
+            Shaders.endEntities();
+            Shaders.beginBlockEntities();
+         }
+
          this.world.profiler.endStartSection("blockentities");
          RenderHelper.enableStandardItemLighting();
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            TileEntityRendererDispatcher.instance.preDrawBatch();
+         }
+
+         TileEntitySignRenderer.updateTextRenderDistance();
+
+         for (RenderGlobal.ContainerLocalRenderInformation var45 : this.renderInfosTileEntities) {
+            List var48 = var45.renderChunk.getCompiledChunk().getTileEntities();
+            if (!var48.isEmpty()) {
+               for (TileEntity var54 : var48) {
+                  if (var20) {
+                     if (!Reflector.callBoolean(var54, Reflector.ForgeTileEntity_shouldRenderInPass, new Object[]{var4})) {
+                        continue;
+                     }
+
+                     AxisAlignedBB var56 = (AxisAlignedBB)Reflector.call(var54, Reflector.ForgeTileEntity_getRenderBoundingBox, new Object[0]);
+                     if (var56 != null && !var2.isBoundingBoxInFrustum(var56)) {
+                        continue;
+                     }
+                  }
+
+                  if (var36) {
+                     Shaders.nextBlockEntity(var54);
+                  }
 
-         for (RenderGlobal.ContainerLocalRenderInformation var39 : this.renderInfos) {
-            List var42 = var39.renderChunk.getCompiledChunk().getTileEntities();
-            if (!var42.isEmpty()) {
-               for (TileEntity var47 : var42) {
-                  TileEntityRendererDispatcher.instance.render(var47, var3, -1);
+                  TileEntityRendererDispatcher.instance.render(var54, var3, -1);
+                  this.countTileEntitiesRendered++;
                }
             }
          }
 
          synchronized (this.setTileEntities) {
-            for (TileEntity var43 : this.setTileEntities) {
-               TileEntityRendererDispatcher.instance.render(var43, var3, -1);
+            for (TileEntity var52 : this.setTileEntities) {
+               if (!var20 || Reflector.callBoolean(var52, Reflector.ForgeTileEntity_shouldRenderInPass, new Object[]{var4})) {
+                  if (var36) {
+                     Shaders.nextBlockEntity(var52);
+                  }
+
+                  TileEntityRendererDispatcher.instance.render(var52, var3, -1);
+               }
             }
          }
 
+         if (Reflector.ForgeTileEntity_hasFastRenderer.exists()) {
+            TileEntityRendererDispatcher.instance.drawBatch(var4);
+         }
+
+         this.renderOverlayDamaged = true;
          this.preRenderDamagedBlocks();
 
-         for (DestroyBlockProgress var41 : this.damagedBlocks.values()) {
-            BlockPos var44 = var41.getPosition();
-            if (this.world.getBlockState(var44).getBlock().hasTileEntity()) {
-               TileEntity var46 = this.world.getTileEntity(var44);
-               if (var46 instanceof TileEntityChest) {
-                  TileEntityChest var48 = (TileEntityChest)var46;
-                  if (var48.adjacentChestXNeg != null) {
-                     var44 = var44.offset(EnumFacing.WEST);
-                     var46 = this.world.getTileEntity(var44);
-                  } else if (var48.adjacentChestZNeg != null) {
-                     var44 = var44.offset(EnumFacing.NORTH);
-                     var46 = this.world.getTileEntity(var44);
+         for (DestroyBlockProgress var50 : this.damagedBlocks.values()) {
+            BlockPos var53 = var50.getPosition();
+            if (this.world.getBlockState(var53).getBlock().hasTileEntity()) {
+               TileEntity var55 = this.world.getTileEntity(var53);
+               if (var55 instanceof TileEntityChest) {
+                  TileEntityChest var57 = (TileEntityChest)var55;
+                  if (var57.adjacentChestXNeg != null) {
+                     var53 = var53.offset(EnumFacing.WEST);
+                     var55 = this.world.getTileEntity(var53);
+                  } else if (var57.adjacentChestZNeg != null) {
+                     var53 = var53.offset(EnumFacing.NORTH);
+                     var55 = this.world.getTileEntity(var53);
                   }
                }
 
-               IBlockState var49 = this.world.getBlockState(var44);
-               if (var46 != null && var49.hasCustomBreakingProgress()) {
-                  TileEntityRendererDispatcher.instance.render(var46, var3, var41.getPartialBlockDamage());
+               IBlockState var58 = this.world.getBlockState(var53);
+               if (var55 != null && var58.h()) {
+                  if (var36) {
+                     Shaders.nextBlockEntity(var55);
+                  }
+
+                  TileEntityRendererDispatcher.instance.render(var55, var3, var50.getPartialBlockDamage());
                }
             }
          }
 
          this.postRenderDamagedBlocks();
+         this.renderOverlayDamaged = false;
+         if (var36) {
+            Shaders.endBlockEntities();
+         }
+
+         renderEntitiesCounter--;
          this.mc.entityRenderer.disableLightmap();
          this.mc.profiler.endSection();
       }
    }
 
    private boolean isOutlineActive(Entity var1, Entity var2, ICamera var3) {
@@ -666,13 +882,13 @@
       }
 
       return var1;
    }
 
    public String getDebugInfoEntities() {
-      return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden;
+      return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ", B: " + this.countEntitiesHidden + ", " + Config.getVersionDebug();
    }
 
    public void setupTerrain(Entity var1, double var2, ICamera var4, int var5, boolean var6) {
       if (this.mc.gameSettings.renderDistanceChunks != this.renderDistanceChunks) {
          this.loadRenderers();
       }
@@ -691,12 +907,16 @@
          this.frustumUpdatePosChunkX = var1.chunkCoordX;
          this.frustumUpdatePosChunkY = var1.chunkCoordY;
          this.frustumUpdatePosChunkZ = var1.chunkCoordZ;
          this.viewFrustum.updateChunkPositions(var1.posX, var1.posZ);
       }
 
+      if (Config.isDynamicLights()) {
+         DynamicLights.update(this);
+      }
+
       this.world.profiler.endStartSection("renderlistcamera");
       double var13 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var2;
       double var15 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var2;
       double var17 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var2;
       this.renderContainer.initialize(var13, var15, var17);
       this.world.profiler.endStartSection("cull");
@@ -704,15 +924,15 @@
          Frustum var19 = new Frustum(this.debugFixedClippingHelper);
          var19.setPosition(this.debugTerrainFrustumPosition.x, this.debugTerrainFrustumPosition.y, this.debugTerrainFrustumPosition.z);
          var4 = var19;
       }
 
       this.mc.profiler.endStartSection("culling");
-      BlockPos var34 = new BlockPos(var13, var15 + var1.getEyeHeight(), var17);
-      RenderChunk var20 = this.viewFrustum.getRenderChunk(var34);
-      BlockPos var21 = new BlockPos(MathHelper.floor(var13 / 16.0) * 16, MathHelper.floor(var15 / 16.0) * 16, MathHelper.floor(var17 / 16.0) * 16);
+      BlockPos var40 = new BlockPos(var13, var15 + var1.getEyeHeight(), var17);
+      RenderChunk var20 = this.viewFrustum.getRenderChunk(var40);
+      new BlockPos(MathHelper.floor(var13 / 16.0) * 16, MathHelper.floor(var15 / 16.0) * 16, MathHelper.floor(var17 / 16.0) * 16);
       this.displayListEntitiesDirty = this.displayListEntitiesDirty
          || !this.chunksToUpdate.isEmpty()
          || var1.posX != this.lastViewEntityX
          || var1.posY != this.lastViewEntityY
          || var1.posZ != this.lastViewEntityZ
          || var1.rotationPitch != this.lastViewEntityPitch
@@ -721,74 +941,144 @@
       this.lastViewEntityY = var1.posY;
       this.lastViewEntityZ = var1.posZ;
       this.lastViewEntityPitch = var1.rotationPitch;
       this.lastViewEntityYaw = var1.rotationYaw;
       boolean var22 = this.debugFixedClippingHelper != null;
       this.mc.profiler.endStartSection("update");
-      if (!var22 && this.displayListEntitiesDirty) {
+      Lagometer.timerVisibility.start();
+      int var23 = this.getCountLoadedChunks();
+      if (var23 != this.countLoadedChunksPrev) {
+         this.countLoadedChunksPrev = var23;
+         this.displayListEntitiesDirty = true;
+      }
+
+      int var24 = 256;
+      if (!ChunkVisibility.isFinished()) {
+         this.displayListEntitiesDirty = true;
+      }
+
+      if (!var22 && this.displayListEntitiesDirty && Config.isIntegratedServerRunning()) {
+         var24 = ChunkVisibility.getMaxChunkY(this.world, var1, this.renderDistanceChunks);
+      }
+
+      RenderChunk var25 = this.viewFrustum.getRenderChunk(new BlockPos(var1.posX, var1.posY, var1.posZ));
+      if (Shaders.isShadowPass) {
+         this.renderInfos = this.renderInfosShadow;
+         this.renderInfosEntities = this.renderInfosEntitiesShadow;
+         this.renderInfosTileEntities = this.renderInfosTileEntitiesShadow;
+         if (!var22 && this.displayListEntitiesDirty) {
+            this.clearRenderInfos();
+            if (var25 != null && var25.getPosition().getY() > var24) {
+               this.renderInfosEntities.add(var25.getRenderInfo());
+            }
+
+            Iterator var26 = ShadowUtils.makeShadowChunkIterator(this.world, var2, var1, this.renderDistanceChunks, this.viewFrustum);
+
+            while (var26.hasNext()) {
+               RenderChunk var27 = (RenderChunk)var26.next();
+               if (var27 != null && var27.getPosition().getY() <= var24) {
+                  RenderGlobal.ContainerLocalRenderInformation var28 = var27.getRenderInfo();
+                  if (!var27.compiledChunk.isEmpty()) {
+                     this.renderInfos.add(var28);
+                  }
+
+                  if (ChunkUtils.hasEntities(var27.getChunk())) {
+                     this.renderInfosEntities.add(var28);
+                  }
+
+                  if (var27.getCompiledChunk().getTileEntities().size() > 0) {
+                     this.renderInfosTileEntities.add(var28);
+                  }
+               }
+            }
+         }
+      } else {
+         this.renderInfos = this.renderInfosNormal;
+         this.renderInfosEntities = this.renderInfosEntitiesNormal;
+         this.renderInfosTileEntities = this.renderInfosTileEntitiesNormal;
+      }
+
+      if (!var22 && this.displayListEntitiesDirty && !Shaders.isShadowPass) {
          this.displayListEntitiesDirty = false;
-         this.renderInfos = Lists.newArrayList();
-         ArrayDeque var23 = Queues.newArrayDeque();
+         this.clearRenderInfos();
+         this.visibilityDeque.clear();
+         Deque var41 = this.visibilityDeque;
          Entity.setRenderDistanceWeight(MathHelper.clamp(this.mc.gameSettings.renderDistanceChunks / 8.0, 1.0, 2.5));
-         boolean var24 = this.mc.renderChunksMany;
-         if (var20 != null) {
-            boolean var37 = false;
-            RenderGlobal.ContainerLocalRenderInformation var40 = new RenderGlobal.ContainerLocalRenderInformation(var20, null, 0);
-            Set var43 = this.getVisibleFacings(var34);
-            if (var43.size() == 1) {
-               Vector3f var46 = this.getViewVector(var1, var2);
-               EnumFacing var29 = EnumFacing.getFacingFromVector(var46.x, var46.y, var46.z).getOpposite();
-               var43.remove(var29);
+         boolean var43 = this.mc.renderChunksMany;
+         if (var20 != null && var20.getPosition().getY() <= var24) {
+            boolean var46 = false;
+            RenderGlobal.ContainerLocalRenderInformation var49 = new RenderGlobal.ContainerLocalRenderInformation(var20, (EnumFacing)null, 0);
+            Set var52 = SET_ALL_FACINGS;
+            if (var52.size() == 1) {
+               Vector3f var55 = this.getViewVector(var1, var2);
+               EnumFacing var58 = EnumFacing.getFacingFromVector(var55.x, var55.y, var55.z).getOpposite();
+               var52.remove(var58);
             }
 
-            if (var43.isEmpty()) {
-               var37 = true;
+            if (var52.isEmpty()) {
+               var46 = true;
             }
 
-            if (var37 && !var6) {
-               this.renderInfos.add(var40);
+            if (var46 && !var6) {
+               this.renderInfos.add(var49);
             } else {
-               if (var6 && this.world.getBlockState(var34).isOpaqueCube()) {
-                  var24 = false;
+               if (var6 && this.world.getBlockState(var40).p()) {
+                  var43 = false;
                }
 
                var20.setFrameIndex(var5);
-               var23.add(var40);
+               var41.add(var49);
             }
          } else {
-            int var25 = var34.getY() > 0 ? 248 : 8;
+            int var45 = var40.getY() > 0 ? Math.min(var24, 248) : 8;
+            if (var25 != null) {
+               this.renderInfosEntities.add(var25.getRenderInfo());
+            }
 
-            for (int var26 = -this.renderDistanceChunks; var26 <= this.renderDistanceChunks; var26++) {
-               for (int var27 = -this.renderDistanceChunks; var27 <= this.renderDistanceChunks; var27++) {
-                  RenderChunk var28 = this.viewFrustum.getRenderChunk(new BlockPos((var26 << 4) + 8, var25, (var27 << 4) + 8));
-                  if (var28 != null && ((ICamera)var4).isBoundingBoxInFrustum(var28.boundingBox)) {
-                     var28.setFrameIndex(var5);
-                     var23.add(new RenderGlobal.ContainerLocalRenderInformation(var28, null, 0));
+            for (int var29 = -this.renderDistanceChunks; var29 <= this.renderDistanceChunks; var29++) {
+               for (int var30 = -this.renderDistanceChunks; var30 <= this.renderDistanceChunks; var30++) {
+                  RenderChunk var31 = this.viewFrustum.getRenderChunk(new BlockPos((var29 << 4) + 8, var45, (var30 << 4) + 8));
+                  if (var31 != null && var31.isBoundingBoxInFrustum((ICamera)var4, var5)) {
+                     var31.setFrameIndex(var5);
+                     RenderGlobal.ContainerLocalRenderInformation var32 = var31.getRenderInfo();
+                     var32.initialize(null, 0);
+                     var41.add(var32);
                   }
                }
             }
          }
 
          this.mc.profiler.startSection("iteration");
+         boolean var47 = Config.isFogOn();
+
+         while (!var41.isEmpty()) {
+            RenderGlobal.ContainerLocalRenderInformation var50 = (RenderGlobal.ContainerLocalRenderInformation)var41.poll();
+            RenderChunk var53 = var50.renderChunk;
+            EnumFacing var56 = var50.facing;
+            CompiledChunk var59 = var53.compiledChunk;
+            if (!var59.isEmpty() || var53.needsUpdate()) {
+               this.renderInfos.add(var50);
+            }
+
+            if (ChunkUtils.hasEntities(var53.getChunk())) {
+               this.renderInfosEntities.add(var50);
+            }
 
-         while (!var23.isEmpty()) {
-            RenderGlobal.ContainerLocalRenderInformation var38 = (RenderGlobal.ContainerLocalRenderInformation)var23.poll();
-            RenderChunk var41 = var38.renderChunk;
-            EnumFacing var44 = var38.facing;
-            this.renderInfos.add(var38);
-
-            for (EnumFacing var31 : EnumFacing.values()) {
-               RenderChunk var32 = this.getRenderChunkOffset(var21, var41, var31);
-               if ((!var24 || !var38.hasDirection(var31.getOpposite()))
-                  && (!var24 || var44 == null || var41.getCompiledChunk().isVisible(var44.getOpposite(), var31))
-                  && var32 != null
-                  && var32.setFrameIndex(var5)
-                  && ((ICamera)var4).isBoundingBoxInFrustum(var32.boundingBox)) {
-                  RenderGlobal.ContainerLocalRenderInformation var33 = new RenderGlobal.ContainerLocalRenderInformation(var32, var31, var38.counter + 1);
-                  var33.setDirection(var38.setFacing, var31);
-                  var23.add(var33);
+            if (var59.getTileEntities().size() > 0) {
+               this.renderInfosTileEntities.add(var50);
+            }
+
+            for (EnumFacing var36 : var43 ? ChunkVisibility.getFacingsNotOpposite(var50.setFacing) : EnumFacing.VALUES) {
+               if (!var43 || var56 == null || var59.isVisible(var56.getOpposite(), var36)) {
+                  RenderChunk var37 = this.getRenderChunkOffset(var40, var53, var36, var47, var24);
+                  if (var37 != null && var37.setFrameIndex(var5) && var37.isBoundingBoxInFrustum((ICamera)var4, var5)) {
+                     int var38 = var50.setFacing | 1 << var36.ordinal();
+                     RenderGlobal.ContainerLocalRenderInformation var39 = var37.getRenderInfo();
+                     var39.initialize(var36, var38);
+                     var41.add(var39);
+                  }
                }
             }
          }
 
          this.mc.profiler.endSection();
       }
@@ -796,60 +1086,81 @@
       this.mc.profiler.endStartSection("captureFrustum");
       if (this.debugFixTerrainFrustum) {
          this.fixTerrainFrustum(var13, var15, var17);
          this.debugFixTerrainFrustum = false;
       }
 
-      this.mc.profiler.endStartSection("rebuildNear");
-      Set var35 = this.chunksToUpdate;
-      this.chunksToUpdate = Sets.newLinkedHashSet();
-
-      for (RenderGlobal.ContainerLocalRenderInformation var39 : this.renderInfos) {
-         RenderChunk var42 = var39.renderChunk;
-         if (var42.needsUpdate() || var35.contains(var42)) {
-            this.displayListEntitiesDirty = true;
-            BlockPos var45 = var42.getPosition().add(8, 8, 8);
-            boolean var48 = var45.distanceSq(var34) < 768.0;
-            if (!var42.needsImmediateUpdate() && !var48) {
-               this.chunksToUpdate.add(var42);
-            } else {
-               this.mc.profiler.startSection("build near");
-               this.renderDispatcher.updateChunkNow(var42);
-               var42.clearNeedsUpdate();
-               this.mc.profiler.endSection();
+      Lagometer.timerVisibility.end();
+      if (Shaders.isShadowPass) {
+         Shaders.mcProfilerEndSection();
+      } else {
+         this.mc.profiler.endStartSection("rebuildNear");
+         Set var42 = this.chunksToUpdate;
+         this.chunksToUpdate = this.chunksToUpdatePrev;
+         this.chunksToUpdatePrev = var42;
+         this.chunksToUpdate.clear();
+         Lagometer.timerChunkUpdate.start();
+
+         for (RenderGlobal.ContainerLocalRenderInformation var48 : this.renderInfos) {
+            RenderChunk var51 = var48.renderChunk;
+            if (var51.needsUpdate() || var42.contains(var51)) {
+               this.displayListEntitiesDirty = true;
+               BlockPos var54 = var51.getPosition();
+               boolean var57 = var40.distanceSq(var54.getX() + 8, var54.getY() + 8, var54.getZ() + 8) < 768.0;
+               if (!var57) {
+                  this.chunksToUpdate.add(var51);
+               } else if (!var51.isPlayerUpdate()) {
+                  this.chunksToUpdateForced.add(var51);
+               } else {
+                  this.mc.profiler.startSection("build near");
+                  this.renderDispatcher.updateChunkNow(var51);
+                  var51.clearNeedsUpdate();
+                  this.mc.profiler.endSection();
+               }
             }
          }
-      }
 
-      this.chunksToUpdate.addAll(var35);
-      this.mc.profiler.endSection();
+         Lagometer.timerChunkUpdate.end();
+         this.chunksToUpdate.addAll(var42);
+         this.mc.profiler.endSection();
+      }
    }
 
    private Set<EnumFacing> getVisibleFacings(BlockPos var1) {
       VisGraph var2 = new VisGraph();
       BlockPos var3 = new BlockPos(var1.getX() >> 4 << 4, var1.getY() >> 4 << 4, var1.getZ() >> 4 << 4);
       Chunk var4 = this.world.getChunk(var3);
 
-      for (BlockPos.MutableBlockPos var6 : BlockPos.getAllInBoxMutable(var3, var3.add(15, 15, 15))) {
-         if (var4.getBlockState(var6).isOpaqueCube()) {
+      for (MutableBlockPos var6 : BlockPos.getAllInBoxMutable(var3, var3.add(15, 15, 15))) {
+         if (var4.getBlockState(var6).p()) {
             var2.setOpaqueCube(var6);
          }
       }
 
       return var2.getVisibleFacings(var1);
    }
 
    @Nullable
-   private RenderChunk getRenderChunkOffset(BlockPos var1, RenderChunk var2, EnumFacing var3) {
-      BlockPos var4 = var2.getBlockPosOffset16(var3);
-      if (MathHelper.abs(var1.getX() - var4.getX()) > this.renderDistanceChunks * 16) {
+   private RenderChunk getRenderChunkOffset(BlockPos var1, RenderChunk var2, EnumFacing var3, boolean var4, int var5) {
+      RenderChunk var6 = var2.getRenderChunkNeighbour(var3);
+      if (var6 == null) {
          return null;
-      } else if (var4.getY() < 0 || var4.getY() >= 256) {
+      } else if (var6.getPosition().getY() > var5) {
          return null;
       } else {
-         return MathHelper.abs(var1.getZ() - var4.getZ()) > this.renderDistanceChunks * 16 ? null : this.viewFrustum.getRenderChunk(var4);
+         if (var4) {
+            BlockPos var7 = var6.getPosition();
+            int var8 = var1.getX() - var7.getX();
+            int var9 = var1.getZ() - var7.getZ();
+            int var10 = var8 * var8 + var9 * var9;
+            if (var10 > this.renderDistanceSq) {
+               return null;
+            }
+         }
+
+         return var6;
       }
    }
 
    private void fixTerrainFrustum(double var1, double var3, double var5) {
       this.debugFixedClippingHelper = new ClippingHelperImpl();
       ((ClippingHelperImpl)this.debugFixedClippingHelper).init();
@@ -894,26 +1205,27 @@
       float var9 = MathHelper.sin(-var4 * (float) (Math.PI / 180.0));
       return new Vector3f(var7 * var8, var9, var6 * var8);
    }
 
    public int renderBlockLayer(BlockRenderLayer var1, double var2, int var4, Entity var5) {
       RenderHelper.disableStandardItemLighting();
-      if (var1 == BlockRenderLayer.TRANSLUCENT) {
+      if (var1 == BlockRenderLayer.TRANSLUCENT && !Shaders.isShadowPass) {
          this.mc.profiler.startSection("translucent_sort");
          double var6 = var5.posX - this.prevRenderSortX;
          double var8 = var5.posY - this.prevRenderSortY;
          double var10 = var5.posZ - this.prevRenderSortZ;
          if (var6 * var6 + var8 * var8 + var10 * var10 > 1.0) {
             this.prevRenderSortX = var5.posX;
             this.prevRenderSortY = var5.posY;
             this.prevRenderSortZ = var5.posZ;
             int var12 = 0;
+            this.chunksToResortTransparency.clear();
 
             for (RenderGlobal.ContainerLocalRenderInformation var14 : this.renderInfos) {
                if (var14.renderChunk.compiledChunk.isLayerStarted(var1) && var12++ < 15) {
-                  this.renderDispatcher.updateTransparencyLater(var14.renderChunk);
+                  this.chunksToResortTransparency.add(var14.renderChunk);
                }
             }
          }
 
          this.mc.profiler.endSection();
       }
@@ -930,16 +1242,25 @@
          if (!var18.getCompiledChunk().isLayerEmpty(var1)) {
             var15++;
             this.renderContainer.addRenderChunk(var18, var1);
          }
       }
 
-      this.mc.profiler.func_194339_b(() -> "render_" + var1);
-      this.renderBlockLayer(var1);
-      this.mc.profiler.endSection();
-      return var15;
+      if (var15 == 0) {
+         this.mc.profiler.endSection();
+         return var15;
+      } else {
+         if (Config.isFogOff() && this.mc.entityRenderer.fogStandard) {
+            GlStateManager.disableFog();
+         }
+
+         this.mc.profiler.func_194339_b(() -> "render_" + var1);
+         this.renderBlockLayer(var1);
+         this.mc.profiler.endSection();
+         return var15;
+      }
    }
 
    private void renderBlockLayer(BlockRenderLayer var1) {
       this.mc.entityRenderer.enableLightmap();
       if (OpenGlHelper.useVbo()) {
          GlStateManager.glEnableClientState(32884);
@@ -948,23 +1269,31 @@
          OpenGlHelper.setClientActiveTexture(OpenGlHelper.lightmapTexUnit);
          GlStateManager.glEnableClientState(32888);
          OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
          GlStateManager.glEnableClientState(32886);
       }
 
+      if (Config.isShaders()) {
+         ShadersRender.preRenderChunkLayer(var1);
+      }
+
       this.renderContainer.renderChunkLayer(var1);
+      if (Config.isShaders()) {
+         ShadersRender.postRenderChunkLayer(var1);
+      }
+
       if (OpenGlHelper.useVbo()) {
-         for (VertexFormatElement var4 : DefaultVertexFormats.BLOCK.getElements()) {
-            VertexFormatElement.EnumUsage var5 = var4.getUsage();
-            int var6 = var4.getIndex();
-            switch (var5) {
+         for (VertexFormatElement var3 : DefaultVertexFormats.BLOCK.getElements()) {
+            EnumUsage var4 = var3.getUsage();
+            int var5 = var3.getIndex();
+            switch (var4) {
                case POSITION:
                   GlStateManager.glDisableClientState(32884);
                   break;
                case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var6);
+                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var5);
                   GlStateManager.glDisableClientState(32888);
                   OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
                   break;
                case COLOR:
                   GlStateManager.glDisableClientState(32886);
                   GlStateManager.resetColor();
@@ -983,197 +1312,289 @@
             var1.remove();
          }
       }
    }
 
    public void updateClouds() {
+      if (Config.isShaders()) {
+         if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(24)) {
+            GuiShaderOptions var1 = new GuiShaderOptions(null, Config.getGameSettings());
+            Config.getMinecraft().displayGuiScreen(var1);
+         }
+
+         if (Keyboard.isKeyDown(61) && Keyboard.isKeyDown(19)) {
+            Shaders.uninit();
+            Shaders.loadShaderPack();
+            Reflector.Minecraft_actionKeyF3.setValue(this.mc, Boolean.TRUE);
+         }
+      }
+
       this.cloudTickCounter++;
       if (this.cloudTickCounter % 20 == 0) {
          this.cleanupDamagedBlocks(this.damagedBlocks.values().iterator());
       }
 
       if (!this.setLightUpdates.isEmpty() && !this.renderDispatcher.hasNoFreeRenderBuilders() && this.chunksToUpdate.isEmpty()) {
-         Iterator var1 = this.setLightUpdates.iterator();
+         Iterator var6 = this.setLightUpdates.iterator();
 
-         while (var1.hasNext()) {
-            BlockPos var2 = (BlockPos)var1.next();
-            var1.remove();
+         while (var6.hasNext()) {
+            BlockPos var2 = (BlockPos)var6.next();
+            var6.remove();
             int var3 = var2.getX();
             int var4 = var2.getY();
             int var5 = var2.getZ();
             this.markBlocksForUpdate(var3 - 1, var4 - 1, var5 - 1, var3 + 1, var4 + 1, var5 + 1, false);
          }
       }
    }
 
    private void renderSkyEnd() {
-      GlStateManager.disableFog();
-      GlStateManager.disableAlpha();
-      GlStateManager.enableBlend();
-      GlStateManager.tryBlendFuncSeparate(
-         GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
-      );
-      RenderHelper.disableStandardItemLighting();
-      GlStateManager.depthMask(false);
-      this.renderEngine.bindTexture(END_SKY_TEXTURES);
-      Tessellator var1 = Tessellator.getInstance();
-      BufferBuilder var2 = var1.getBuffer();
+      if (Config.isSkyEnabled()) {
+         GlStateManager.disableFog();
+         GlStateManager.disableAlpha();
+         GlStateManager.enableBlend();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
+         RenderHelper.disableStandardItemLighting();
+         GlStateManager.depthMask(false);
+         this.renderEngine.bindTexture(END_SKY_TEXTURES);
+         Tessellator var1 = Tessellator.getInstance();
+         BufferBuilder var2 = var1.getBuffer();
 
-      for (int var3 = 0; var3 < 6; var3++) {
-         GlStateManager.pushMatrix();
-         if (var3 == 1) {
-            GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
-         }
+         for (int var3 = 0; var3 < 6; var3++) {
+            GlStateManager.pushMatrix();
+            if (var3 == 1) {
+               GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (var3 == 2) {
-            GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
-         }
+            if (var3 == 2) {
+               GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (var3 == 3) {
-            GlStateManager.rotate(180.0F, 1.0F, 0.0F, 0.0F);
-         }
+            if (var3 == 3) {
+               GlStateManager.rotate(180.0F, 1.0F, 0.0F, 0.0F);
+            }
 
-         if (var3 == 4) {
-            GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
-         }
+            if (var3 == 4) {
+               GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
+            }
+
+            if (var3 == 5) {
+               GlStateManager.rotate(-90.0F, 0.0F, 0.0F, 1.0F);
+            }
+
+            var2.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+            int var4 = 40;
+            int var5 = 40;
+            int var6 = 40;
+            if (Config.isCustomColors()) {
+               Vec3d var7 = new Vec3d(var4 / 255.0, var5 / 255.0, var6 / 255.0);
+               var7 = CustomColors.getWorldSkyColor(var7, this.world, this.mc.getRenderViewEntity(), 0.0F);
+               var4 = (int)(var7.x * 255.0);
+               var5 = (int)(var7.y * 255.0);
+               var6 = (int)(var7.z * 255.0);
+            }
 
-         if (var3 == 5) {
-            GlStateManager.rotate(-90.0F, 0.0F, 0.0F, 1.0F);
+            var2.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(var4, var5, var6, 255).endVertex();
+            var2.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(var4, var5, var6, 255).endVertex();
+            var2.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(var4, var5, var6, 255).endVertex();
+            var2.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(var4, var5, var6, 255).endVertex();
+            var1.draw();
+            GlStateManager.popMatrix();
          }
 
-         var2.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-         var2.pos(-100.0, -100.0, -100.0).tex(0.0, 0.0).color(40, 40, 40, 255).endVertex();
-         var2.pos(-100.0, -100.0, 100.0).tex(0.0, 16.0).color(40, 40, 40, 255).endVertex();
-         var2.pos(100.0, -100.0, 100.0).tex(16.0, 16.0).color(40, 40, 40, 255).endVertex();
-         var2.pos(100.0, -100.0, -100.0).tex(16.0, 0.0).color(40, 40, 40, 255).endVertex();
-         var1.draw();
-         GlStateManager.popMatrix();
+         GlStateManager.depthMask(true);
+         GlStateManager.enableTexture2D();
+         GlStateManager.enableAlpha();
+         GlStateManager.disableBlend();
       }
-
-      GlStateManager.depthMask(true);
-      GlStateManager.enableTexture2D();
-      GlStateManager.enableAlpha();
    }
 
    public void renderSky(float var1, int var2) {
-      if (this.mc.world.provider.getDimensionType().getId() == 1) {
+      if (Reflector.ForgeWorldProvider_getSkyRenderer.exists()) {
+         WorldProvider var3 = this.mc.world.provider;
+         Object var4 = Reflector.call(var3, Reflector.ForgeWorldProvider_getSkyRenderer, new Object[0]);
+         if (var4 != null) {
+            Reflector.callVoid(var4, Reflector.IRenderHandler_render, new Object[]{var1, this.world, this.mc});
+            return;
+         }
+      }
+
+      if (this.mc.world.provider.getDimensionType() == DimensionType.THE_END) {
          this.renderSkyEnd();
       } else if (this.mc.world.provider.isSurfaceWorld()) {
          GlStateManager.disableTexture2D();
-         Vec3d var3 = this.world.getSkyColor(this.mc.getRenderViewEntity(), var1);
-         float var4 = (float)var3.x;
-         float var5 = (float)var3.y;
-         float var6 = (float)var3.z;
+         boolean var20 = Config.isShaders();
+         if (var20) {
+            Shaders.disableTexture2D();
+         }
+
+         Vec3d var21 = this.world.getSkyColor(this.mc.getRenderViewEntity(), var1);
+         var21 = CustomColors.getSkyColor(
+            var21, this.mc.world, this.mc.getRenderViewEntity().posX, this.mc.getRenderViewEntity().posY + 1.0, this.mc.getRenderViewEntity().posZ
+         );
+         if (var20) {
+            Shaders.setSkyColor(var21);
+         }
+
+         float var5 = (float)var21.x;
+         float var6 = (float)var21.y;
+         float var7 = (float)var21.z;
          if (var2 != 2) {
-            float var7 = (var4 * 30.0F + var5 * 59.0F + var6 * 11.0F) / 100.0F;
-            float var8 = (var4 * 30.0F + var5 * 70.0F) / 100.0F;
-            float var9 = (var4 * 30.0F + var6 * 70.0F) / 100.0F;
-            var4 = var7;
+            float var8 = (var5 * 30.0F + var6 * 59.0F + var7 * 11.0F) / 100.0F;
+            float var9 = (var5 * 30.0F + var6 * 70.0F) / 100.0F;
+            float var10 = (var5 * 30.0F + var7 * 70.0F) / 100.0F;
             var5 = var8;
             var6 = var9;
+            var7 = var10;
          }
 
-         GlStateManager.color(var4, var5, var6);
-         Tessellator var20 = Tessellator.getInstance();
-         BufferBuilder var21 = var20.getBuffer();
+         GlStateManager.color(var5, var6, var7);
+         Tessellator var23 = Tessellator.getInstance();
+         BufferBuilder var24 = var23.getBuffer();
          GlStateManager.depthMask(false);
          GlStateManager.enableFog();
-         GlStateManager.color(var4, var5, var6);
-         if (this.vboEnabled) {
-            this.skyVBO.bindBuffer();
-            GlStateManager.glEnableClientState(32884);
-            GlStateManager.glVertexPointer(3, 5126, 12, 0);
-            this.skyVBO.drawArrays(7);
-            this.skyVBO.unbindBuffer();
-            GlStateManager.glDisableClientState(32884);
-         } else {
-            GlStateManager.callList(this.glSkyList);
+         if (var20) {
+            Shaders.enableFog();
+         }
+
+         GlStateManager.color(var5, var6, var7);
+         if (var20) {
+            Shaders.preSkyList();
+         }
+
+         if (Config.isSkyEnabled()) {
+            if (this.vboEnabled) {
+               this.skyVBO.bindBuffer();
+               GlStateManager.glEnableClientState(32884);
+               GlStateManager.glVertexPointer(3, 5126, 12, 0);
+               this.skyVBO.drawArrays(7);
+               this.skyVBO.unbindBuffer();
+               GlStateManager.glDisableClientState(32884);
+            } else {
+               GlStateManager.callList(this.glSkyList);
+            }
          }
 
          GlStateManager.disableFog();
+         if (var20) {
+            Shaders.disableFog();
+         }
+
          GlStateManager.disableAlpha();
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
             GlStateManager.SourceFactor.ONE,
             GlStateManager.DestFactor.ZERO
          );
          RenderHelper.disableStandardItemLighting();
-         float[] var22 = this.world.provider.calcSunriseSunsetColors(this.world.getCelestialAngle(var1), var1);
-         if (var22 != null) {
+         float[] var25 = this.world.provider.calcSunriseSunsetColors(this.world.getCelestialAngle(var1), var1);
+         if (var25 != null && Config.isSunMoonEnabled()) {
             GlStateManager.disableTexture2D();
+            if (var20) {
+               Shaders.disableTexture2D();
+            }
+
             GlStateManager.shadeModel(7425);
             GlStateManager.pushMatrix();
             GlStateManager.rotate(90.0F, 1.0F, 0.0F, 0.0F);
             GlStateManager.rotate(MathHelper.sin(this.world.getCelestialAngleRadians(var1)) < 0.0F ? 180.0F : 0.0F, 0.0F, 0.0F, 1.0F);
             GlStateManager.rotate(90.0F, 0.0F, 0.0F, 1.0F);
-            float var10 = var22[0];
-            float var11 = var22[1];
-            float var12 = var22[2];
+            float var11 = var25[0];
+            float var12 = var25[1];
+            float var13 = var25[2];
             if (var2 != 2) {
-               float var13 = (var10 * 30.0F + var11 * 59.0F + var12 * 11.0F) / 100.0F;
-               float var14 = (var10 * 30.0F + var11 * 70.0F) / 100.0F;
-               float var15 = (var10 * 30.0F + var12 * 70.0F) / 100.0F;
-               var10 = var13;
+               float var14 = (var11 * 30.0F + var12 * 59.0F + var13 * 11.0F) / 100.0F;
+               float var15 = (var11 * 30.0F + var12 * 70.0F) / 100.0F;
+               float var16 = (var11 * 30.0F + var13 * 70.0F) / 100.0F;
                var11 = var14;
                var12 = var15;
+               var13 = var16;
             }
 
-            var21.begin(6, DefaultVertexFormats.POSITION_COLOR);
-            var21.pos(0.0, 100.0, 0.0).color(var10, var11, var12, var22[3]).endVertex();
-            byte var29 = 16;
-
-            for (int var32 = 0; var32 <= 16; var32++) {
-               float var35 = var32 * (float) (Math.PI * 2) / 16.0F;
-               float var16 = MathHelper.sin(var35);
-               float var17 = MathHelper.cos(var35);
-               var21.pos(var16 * 120.0F, var17 * 120.0F, -var17 * 40.0F * var22[3]).color(var22[0], var22[1], var22[2], 0.0F).endVertex();
+            var24.begin(6, DefaultVertexFormats.POSITION_COLOR);
+            var24.pos(0.0, 100.0, 0.0).color(var11, var12, var13, var25[3]).endVertex();
+            byte var31 = 16;
+
+            for (int var34 = 0; var34 <= 16; var34++) {
+               float var36 = var34 * (float) (Math.PI * 2) / 16.0F;
+               float var17 = MathHelper.sin(var36);
+               float var18 = MathHelper.cos(var36);
+               var24.pos(var17 * 120.0F, var18 * 120.0F, -var18 * 40.0F * var25[3]).color(var25[0], var25[1], var25[2], 0.0F).endVertex();
             }
 
-            var20.draw();
+            var23.draw();
             GlStateManager.popMatrix();
             GlStateManager.shadeModel(7424);
          }
 
          GlStateManager.enableTexture2D();
+         if (var20) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
          );
          GlStateManager.pushMatrix();
-         float var23 = 1.0F - this.world.getRainStrength(var1);
-         GlStateManager.color(1.0F, 1.0F, 1.0F, var23);
+         float var26 = 1.0F - this.world.getRainStrength(var1);
+         GlStateManager.color(1.0F, 1.0F, 1.0F, var26);
          GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
+         CustomSky.renderSky(this.world, this.renderEngine, var1);
+         if (var20) {
+            Shaders.preCelestialRotate();
+         }
+
          GlStateManager.rotate(this.world.getCelestialAngle(var1) * 360.0F, 1.0F, 0.0F, 0.0F);
-         float var25 = 30.0F;
-         this.renderEngine.bindTexture(SUN_TEXTURES);
-         var21.begin(7, DefaultVertexFormats.POSITION_TEX);
-         var21.pos(-var25, 100.0, -var25).tex(0.0, 0.0).endVertex();
-         var21.pos(var25, 100.0, -var25).tex(1.0, 0.0).endVertex();
-         var21.pos(var25, 100.0, var25).tex(1.0, 1.0).endVertex();
-         var21.pos(-var25, 100.0, var25).tex(0.0, 1.0).endVertex();
-         var20.draw();
-         var25 = 20.0F;
-         this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
-         int var27 = this.world.getMoonPhase();
-         int var30 = var27 % 4;
-         int var33 = var27 / 4 % 2;
-         float var36 = (var30 + 0) / 4.0F;
-         float var37 = (var33 + 0) / 2.0F;
-         float var38 = (var30 + 1) / 4.0F;
-         float var18 = (var33 + 1) / 2.0F;
-         var21.begin(7, DefaultVertexFormats.POSITION_TEX);
-         var21.pos(-var25, -100.0, var25).tex(var38, var18).endVertex();
-         var21.pos(var25, -100.0, var25).tex(var36, var18).endVertex();
-         var21.pos(var25, -100.0, -var25).tex(var36, var37).endVertex();
-         var21.pos(-var25, -100.0, -var25).tex(var38, var37).endVertex();
-         var20.draw();
+         if (var20) {
+            Shaders.postCelestialRotate();
+         }
+
+         float var27 = 30.0F;
+         if (Config.isSunTexture()) {
+            this.renderEngine.bindTexture(SUN_TEXTURES);
+            var24.begin(7, DefaultVertexFormats.POSITION_TEX);
+            var24.pos(-var27, 100.0, -var27).tex(0.0, 0.0).endVertex();
+            var24.pos(var27, 100.0, -var27).tex(1.0, 0.0).endVertex();
+            var24.pos(var27, 100.0, var27).tex(1.0, 1.0).endVertex();
+            var24.pos(-var27, 100.0, var27).tex(0.0, 1.0).endVertex();
+            var23.draw();
+         }
+
+         var27 = 20.0F;
+         if (Config.isMoonTexture()) {
+            this.renderEngine.bindTexture(MOON_PHASES_TEXTURES);
+            int var29 = this.world.getMoonPhase();
+            int var32 = var29 % 4;
+            int var35 = var29 / 4 % 2;
+            float var37 = (var32 + 0) / 4.0F;
+            float var39 = (var35 + 0) / 2.0F;
+            float var41 = (var32 + 1) / 4.0F;
+            float var19 = (var35 + 1) / 2.0F;
+            var24.begin(7, DefaultVertexFormats.POSITION_TEX);
+            var24.pos(-var27, -100.0, var27).tex(var41, var19).endVertex();
+            var24.pos(var27, -100.0, var27).tex(var37, var19).endVertex();
+            var24.pos(var27, -100.0, -var27).tex(var37, var39).endVertex();
+            var24.pos(-var27, -100.0, -var27).tex(var41, var39).endVertex();
+            var23.draw();
+         }
+
          GlStateManager.disableTexture2D();
-         float var19 = this.world.getStarBrightness(var1) * var23;
-         if (var19 > 0.0F) {
-            GlStateManager.color(var19, var19, var19, var19);
+         if (var20) {
+            Shaders.disableTexture2D();
+         }
+
+         float var30 = this.world.getStarBrightness(var1) * var26;
+         if (var30 > 0.0F && Config.isStarsEnabled() && !CustomSky.hasSkyLayers(this.world)) {
+            GlStateManager.color(var30, var30, var30, var30);
             if (this.vboEnabled) {
                this.starVBO.bindBuffer();
                GlStateManager.glEnableClientState(32884);
                GlStateManager.glVertexPointer(3, 5126, 12, 0);
                this.starVBO.drawArrays(7);
                this.starVBO.unbindBuffer();
@@ -1184,17 +1605,25 @@
          }
 
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
          GlStateManager.disableBlend();
          GlStateManager.enableAlpha();
          GlStateManager.enableFog();
+         if (var20) {
+            Shaders.enableFog();
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.disableTexture2D();
+         if (var20) {
+            Shaders.disableTexture2D();
+         }
+
          GlStateManager.color(0.0F, 0.0F, 0.0F);
-         double var24 = this.mc.player.getPositionEyes(var1).y - this.world.getHorizon();
-         if (var24 < 0.0) {
+         double var33 = this.mc.player.getPositionEyes(var1).y - this.world.getHorizon();
+         if (var33 < 0.0) {
             GlStateManager.pushMatrix();
             GlStateManager.translate(0.0F, 12.0F, 0.0F);
             if (this.vboEnabled) {
                this.sky2VBO.bindBuffer();
                GlStateManager.glEnableClientState(32884);
                GlStateManager.glVertexPointer(3, 5126, 12, 0);
@@ -1203,183 +1632,234 @@
                GlStateManager.glDisableClientState(32884);
             } else {
                GlStateManager.callList(this.glSkyList2);
             }
 
             GlStateManager.popMatrix();
-            float var28 = 1.0F;
-            float var31 = -((float)(var24 + 65.0));
-            float var34 = -1.0F;
-            var21.begin(7, DefaultVertexFormats.POSITION_COLOR);
-            var21.pos(-1.0, var31, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, var31, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, var31, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, var31, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, var31, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, var31, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, var31, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, var31, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
-            var21.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
-            var20.draw();
+            float var38 = 1.0F;
+            float var40 = -((float)(var33 + 65.0));
+            float var42 = -1.0F;
+            var24.begin(7, DefaultVertexFormats.POSITION_COLOR);
+            var24.pos(-1.0, var40, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, var40, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, var40, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, var40, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, var40, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, var40, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, var40, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, var40, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(-1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, 1.0).color(0, 0, 0, 255).endVertex();
+            var24.pos(1.0, -1.0, -1.0).color(0, 0, 0, 255).endVertex();
+            var23.draw();
          }
 
          if (this.world.provider.isSkyColored()) {
-            GlStateManager.color(var4 * 0.2F + 0.04F, var5 * 0.2F + 0.04F, var6 * 0.6F + 0.1F);
+            GlStateManager.color(var5 * 0.2F + 0.04F, var6 * 0.2F + 0.04F, var7 * 0.6F + 0.1F);
          } else {
-            GlStateManager.color(var4, var5, var6);
+            GlStateManager.color(var5, var6, var7);
+         }
+
+         if (this.mc.gameSettings.renderDistanceChunks <= 4) {
+            GlStateManager.color(this.mc.entityRenderer.fogColorRed, this.mc.entityRenderer.fogColorGreen, this.mc.entityRenderer.fogColorBlue);
          }
 
          GlStateManager.pushMatrix();
-         GlStateManager.translate(0.0F, -((float)(var24 - 16.0)), 0.0F);
-         GlStateManager.callList(this.glSkyList2);
+         GlStateManager.translate(0.0F, -((float)(var33 - 16.0)), 0.0F);
+         if (Config.isSkyEnabled()) {
+            if (this.vboEnabled) {
+               this.sky2VBO.bindBuffer();
+               GlStateManager.glEnableClientState(32884);
+               GlStateManager.glVertexPointer(3, 5126, 12, 0);
+               this.sky2VBO.drawArrays(7);
+               this.sky2VBO.unbindBuffer();
+               GlStateManager.glDisableClientState(32884);
+            } else {
+               GlStateManager.callList(this.glSkyList2);
+            }
+         }
+
          GlStateManager.popMatrix();
          GlStateManager.enableTexture2D();
+         if (var20) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.depthMask(true);
       }
    }
 
    public void renderClouds(float var1, int var2, double var3, double var5, double var7) {
-      if (this.mc.world.provider.isSurfaceWorld()) {
-         if (this.mc.gameSettings.shouldRenderClouds() == 2) {
-            this.renderCloudsFancy(var1, var2, var3, var5, var7);
-         } else {
-            GlStateManager.disableCull();
-            byte var9 = 32;
-            byte var10 = 8;
-            Tessellator var11 = Tessellator.getInstance();
-            BufferBuilder var12 = var11.getBuffer();
-            this.renderEngine.bindTexture(CLOUDS_TEXTURES);
-            GlStateManager.enableBlend();
-            GlStateManager.tryBlendFuncSeparate(
-               GlStateManager.SourceFactor.SRC_ALPHA,
-               GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
-               GlStateManager.SourceFactor.ONE,
-               GlStateManager.DestFactor.ZERO
-            );
-            Vec3d var13 = this.world.getCloudColour(var1);
-            float var14 = (float)var13.x;
-            float var15 = (float)var13.y;
-            float var16 = (float)var13.z;
-            if (var2 != 2) {
-               float var17 = (var14 * 30.0F + var15 * 59.0F + var16 * 11.0F) / 100.0F;
-               float var18 = (var14 * 30.0F + var15 * 70.0F) / 100.0F;
-               float var19 = (var14 * 30.0F + var16 * 70.0F) / 100.0F;
-               var14 = var17;
-               var15 = var18;
-               var16 = var19;
-            }
-
-            float var31 = 4.8828125E-4F;
-            double var32 = this.cloudTickCounter + var1;
-            double var20 = var3 + var32 * 0.03F;
-            int var24 = MathHelper.floor(var20 / 2048.0);
-            int var25 = MathHelper.floor(var7 / 2048.0);
-            var20 -= var24 * 2048;
-            double var22 = var7 - var25 * 2048;
-            float var26 = this.world.provider.getCloudHeight() - (float)var5 + 0.33F;
-            float var27 = (float)(var20 * 4.8828125E-4);
-            float var28 = (float)(var22 * 4.8828125E-4);
-            var12.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-
-            for (short var29 = -256; var29 < 256; var29 += 32) {
-               for (short var30 = -256; var30 < 256; var30 += 32) {
-                  var12.pos(var29 + 0, var26, var30 + 32)
-                     .tex((var29 + 0) * 4.8828125E-4F + var27, (var30 + 32) * 4.8828125E-4F + var28)
-                     .color(var14, var15, var16, 0.8F)
-                     .endVertex();
-                  var12.pos(var29 + 32, var26, var30 + 32)
-                     .tex((var29 + 32) * 4.8828125E-4F + var27, (var30 + 32) * 4.8828125E-4F + var28)
-                     .color(var14, var15, var16, 0.8F)
-                     .endVertex();
-                  var12.pos(var29 + 32, var26, var30 + 0)
-                     .tex((var29 + 32) * 4.8828125E-4F + var27, (var30 + 0) * 4.8828125E-4F + var28)
-                     .color(var14, var15, var16, 0.8F)
-                     .endVertex();
-                  var12.pos(var29 + 0, var26, var30 + 0)
-                     .tex((var29 + 0) * 4.8828125E-4F + var27, (var30 + 0) * 4.8828125E-4F + var28)
-                     .color(var14, var15, var16, 0.8F)
-                     .endVertex();
+      if (!Config.isCloudsOff()) {
+         if (Reflector.ForgeWorldProvider_getCloudRenderer.exists()) {
+            WorldProvider var9 = this.mc.world.provider;
+            Object var10 = Reflector.call(var9, Reflector.ForgeWorldProvider_getCloudRenderer, new Object[0]);
+            if (var10 != null) {
+               Reflector.callVoid(var10, Reflector.IRenderHandler_render, new Object[]{var1, this.world, this.mc});
+               return;
+            }
+         }
+
+         if (this.mc.world.provider.isSurfaceWorld()) {
+            if (Config.isShaders()) {
+               Shaders.beginClouds();
+            }
+
+            if (Config.isCloudsFancy()) {
+               this.renderCloudsFancy(var1, var2, var3, var5, var7);
+            } else {
+               float var32 = 0.0F;
+               GlStateManager.disableCull();
+               byte var34 = 32;
+               byte var11 = 8;
+               Tessellator var12 = Tessellator.getInstance();
+               BufferBuilder var13 = var12.getBuffer();
+               this.renderEngine.bindTexture(CLOUDS_TEXTURES);
+               GlStateManager.enableBlend();
+               GlStateManager.tryBlendFuncSeparate(
+                  GlStateManager.SourceFactor.SRC_ALPHA,
+                  GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+                  GlStateManager.SourceFactor.ONE,
+                  GlStateManager.DestFactor.ZERO
+               );
+               Vec3d var14 = this.world.getCloudColour(var32);
+               float var15 = (float)var14.x;
+               float var16 = (float)var14.y;
+               float var17 = (float)var14.z;
+               this.cloudRenderer.prepareToRender(false, this.cloudTickCounter, var1, var14);
+               if (this.cloudRenderer.shouldUpdateGlList()) {
+                  this.cloudRenderer.startUpdateGlList();
+                  if (var2 != 2) {
+                     float var18 = (var15 * 30.0F + var16 * 59.0F + var17 * 11.0F) / 100.0F;
+                     float var19 = (var15 * 30.0F + var16 * 70.0F) / 100.0F;
+                     float var20 = (var15 * 30.0F + var17 * 70.0F) / 100.0F;
+                     var15 = var18;
+                     var16 = var19;
+                     var17 = var20;
+                  }
+
+                  float var35 = 4.8828125E-4F;
+                  double var36 = this.cloudTickCounter + var32;
+                  double var21 = var3 + var36 * 0.03F;
+                  int var23 = MathHelper.floor(var21 / 2048.0);
+                  int var24 = MathHelper.floor(var7 / 2048.0);
+                  var21 -= var23 * 2048;
+                  double var25 = var7 - var24 * 2048;
+                  float var27 = this.world.provider.getCloudHeight() - (float)var5 + 0.33F;
+                  var27 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
+                  float var28 = (float)(var21 * 4.8828125E-4);
+                  float var29 = (float)(var25 * 4.8828125E-4);
+                  var13.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+
+                  for (short var30 = -256; var30 < 256; var30 += 32) {
+                     for (short var31 = -256; var31 < 256; var31 += 32) {
+                        var13.pos(var30 + 0, var27, var31 + 32)
+                           .tex((var30 + 0) * 4.8828125E-4F + var28, (var31 + 32) * 4.8828125E-4F + var29)
+                           .color(var15, var16, var17, 0.8F)
+                           .endVertex();
+                        var13.pos(var30 + 32, var27, var31 + 32)
+                           .tex((var30 + 32) * 4.8828125E-4F + var28, (var31 + 32) * 4.8828125E-4F + var29)
+                           .color(var15, var16, var17, 0.8F)
+                           .endVertex();
+                        var13.pos(var30 + 32, var27, var31 + 0)
+                           .tex((var30 + 32) * 4.8828125E-4F + var28, (var31 + 0) * 4.8828125E-4F + var29)
+                           .color(var15, var16, var17, 0.8F)
+                           .endVertex();
+                        var13.pos(var30 + 0, var27, var31 + 0)
+                           .tex((var30 + 0) * 4.8828125E-4F + var28, (var31 + 0) * 4.8828125E-4F + var29)
+                           .color(var15, var16, var17, 0.8F)
+                           .endVertex();
+                     }
+                  }
+
+                  var12.draw();
+                  this.cloudRenderer.endUpdateGlList();
                }
+
+               this.cloudRenderer.renderGlList();
+               GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
+               GlStateManager.disableBlend();
+               GlStateManager.enableCull();
             }
 
-            var11.draw();
-            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
-            GlStateManager.disableBlend();
-            GlStateManager.enableCull();
+            if (Config.isShaders()) {
+               Shaders.endClouds();
+            }
          }
       }
    }
 
    public boolean hasCloudFog(double var1, double var3, double var5, float var7) {
       return false;
    }
 
    private void renderCloudsFancy(float var1, int var2, double var3, double var5, double var7) {
+      float var51 = 0.0F;
       GlStateManager.disableCull();
-      Tessellator var9 = Tessellator.getInstance();
-      BufferBuilder var10 = var9.getBuffer();
-      float var11 = 12.0F;
-      float var12 = 4.0F;
-      double var13 = this.cloudTickCounter + var1;
-      double var15 = (var3 + var13 * 0.03F) / 12.0;
-      double var17 = var7 / 12.0 + 0.33F;
-      float var19 = this.world.provider.getCloudHeight() - (float)var5 + 0.33F;
-      int var20 = MathHelper.floor(var15 / 2048.0);
-      int var21 = MathHelper.floor(var17 / 2048.0);
-      var15 -= var20 * 2048;
-      var17 -= var21 * 2048;
+      Tessellator var10 = Tessellator.getInstance();
+      BufferBuilder var11 = var10.getBuffer();
+      float var12 = 12.0F;
+      float var13 = 4.0F;
+      double var14 = this.cloudTickCounter + var51;
+      double var16 = (var3 + var14 * 0.03F) / 12.0;
+      double var18 = var7 / 12.0 + 0.33F;
+      float var20 = this.world.provider.getCloudHeight() - (float)var5 + 0.33F;
+      var20 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
+      int var21 = MathHelper.floor(var16 / 2048.0);
+      int var22 = MathHelper.floor(var18 / 2048.0);
+      var16 -= var21 * 2048;
+      var18 -= var22 * 2048;
       this.renderEngine.bindTexture(CLOUDS_TEXTURES);
       GlStateManager.enableBlend();
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
-      Vec3d var22 = this.world.getCloudColour(var1);
-      float var23 = (float)var22.x;
-      float var24 = (float)var22.y;
-      float var25 = (float)var22.z;
+      Vec3d var23 = this.world.getCloudColour(var51);
+      float var24 = (float)var23.x;
+      float var25 = (float)var23.y;
+      float var26 = (float)var23.z;
+      this.cloudRenderer.prepareToRender(true, this.cloudTickCounter, var1, var23);
       if (var2 != 2) {
-         float var26 = (var23 * 30.0F + var24 * 59.0F + var25 * 11.0F) / 100.0F;
-         float var27 = (var23 * 30.0F + var24 * 70.0F) / 100.0F;
-         float var28 = (var23 * 30.0F + var25 * 70.0F) / 100.0F;
-         var23 = var26;
+         float var27 = (var24 * 30.0F + var25 * 59.0F + var26 * 11.0F) / 100.0F;
+         float var28 = (var24 * 30.0F + var25 * 70.0F) / 100.0F;
+         float var29 = (var24 * 30.0F + var26 * 70.0F) / 100.0F;
          var24 = var27;
          var25 = var28;
+         var26 = var29;
       }
 
-      float var53 = var23 * 0.9F;
-      float var54 = var24 * 0.9F;
-      float var55 = var25 * 0.9F;
-      float var29 = var23 * 0.7F;
+      float var55 = var24 * 0.9F;
+      float var56 = var25 * 0.9F;
+      float var57 = var26 * 0.9F;
       float var30 = var24 * 0.7F;
       float var31 = var25 * 0.7F;
-      float var32 = var23 * 0.8F;
+      float var32 = var26 * 0.7F;
       float var33 = var24 * 0.8F;
       float var34 = var25 * 0.8F;
-      float var35 = 0.00390625F;
-      float var36 = MathHelper.floor(var15) * 0.00390625F;
-      float var37 = MathHelper.floor(var17) * 0.00390625F;
-      float var38 = (float)(var15 - MathHelper.floor(var15));
-      float var39 = (float)(var17 - MathHelper.floor(var17));
-      byte var40 = 8;
-      byte var41 = 4;
-      float var42 = 9.765625E-4F;
+      float var35 = var26 * 0.8F;
+      float var36 = 0.00390625F;
+      float var37 = MathHelper.floor(var16) * 0.00390625F;
+      float var38 = MathHelper.floor(var18) * 0.00390625F;
+      float var39 = (float)(var16 - MathHelper.floor(var16));
+      float var40 = (float)(var18 - MathHelper.floor(var18));
+      byte var41 = 8;
+      byte var42 = 4;
+      float var43 = 9.765625E-4F;
       GlStateManager.scale(12.0F, 1.0F, 12.0F);
 
-      for (int var43 = 0; var43 < 2; var43++) {
-         if (var43 == 0) {
+      for (int var44 = 0; var44 < 2; var44++) {
+         if (var44 == 0) {
             GlStateManager.colorMask(false, false, false, false);
          } else {
             switch (var2) {
                case 0:
                   GlStateManager.colorMask(false, true, true, true);
                   break;
@@ -1388,209 +1868,255 @@
                   break;
                case 2:
                   GlStateManager.colorMask(true, true, true, true);
             }
          }
 
-         for (int var44 = -3; var44 <= 4; var44++) {
+         this.cloudRenderer.renderGlList();
+      }
+
+      if (this.cloudRenderer.shouldUpdateGlList()) {
+         this.cloudRenderer.startUpdateGlList();
+
+         for (int var58 = -3; var58 <= 4; var58++) {
             for (int var45 = -3; var45 <= 4; var45++) {
-               var10.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
-               float var46 = var44 * 8;
+               var11.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR_NORMAL);
+               float var46 = var58 * 8;
                float var47 = var45 * 8;
-               float var48 = var46 - var38;
-               float var49 = var47 - var39;
-               if (var19 > -5.0F) {
-                  var10.pos(var48 + 0.0F, var19 + 0.0F, var49 + 8.0F)
-                     .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                     .color(var29, var30, var31, 0.8F)
+               float var48 = var46 - var39;
+               float var49 = var47 - var40;
+               if (var20 > -5.0F) {
+                  var11.pos(var48 + 0.0F, var20 + 0.0F, var49 + 8.0F)
+                     .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                     .color(var30, var31, var32, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 8.0F, var19 + 0.0F, var49 + 8.0F)
-                     .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                     .color(var29, var30, var31, 0.8F)
+                  var11.pos(var48 + 8.0F, var20 + 0.0F, var49 + 8.0F)
+                     .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                     .color(var30, var31, var32, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 8.0F, var19 + 0.0F, var49 + 0.0F)
-                     .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                     .color(var29, var30, var31, 0.8F)
+                  var11.pos(var48 + 8.0F, var20 + 0.0F, var49 + 0.0F)
+                     .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                     .color(var30, var31, var32, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 0.0F, var19 + 0.0F, var49 + 0.0F)
-                     .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                     .color(var29, var30, var31, 0.8F)
+                  var11.pos(var48 + 0.0F, var20 + 0.0F, var49 + 0.0F)
+                     .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                     .color(var30, var31, var32, 0.8F)
                      .normal(0.0F, -1.0F, 0.0F)
                      .endVertex();
                }
 
-               if (var19 <= 5.0F) {
-                  var10.pos(var48 + 0.0F, var19 + 4.0F - 9.765625E-4F, var49 + 8.0F)
-                     .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                     .color(var23, var24, var25, 0.8F)
+               if (var20 <= 5.0F) {
+                  var11.pos(var48 + 0.0F, var20 + 4.0F - 9.765625E-4F, var49 + 8.0F)
+                     .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                     .color(var24, var25, var26, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 8.0F, var19 + 4.0F - 9.765625E-4F, var49 + 8.0F)
-                     .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                     .color(var23, var24, var25, 0.8F)
+                  var11.pos(var48 + 8.0F, var20 + 4.0F - 9.765625E-4F, var49 + 8.0F)
+                     .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                     .color(var24, var25, var26, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 8.0F, var19 + 4.0F - 9.765625E-4F, var49 + 0.0F)
-                     .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                     .color(var23, var24, var25, 0.8F)
+                  var11.pos(var48 + 8.0F, var20 + 4.0F - 9.765625E-4F, var49 + 0.0F)
+                     .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                     .color(var24, var25, var26, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
-                  var10.pos(var48 + 0.0F, var19 + 4.0F - 9.765625E-4F, var49 + 0.0F)
-                     .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                     .color(var23, var24, var25, 0.8F)
+                  var11.pos(var48 + 0.0F, var20 + 4.0F - 9.765625E-4F, var49 + 0.0F)
+                     .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                     .color(var24, var25, var26, 0.8F)
                      .normal(0.0F, 1.0F, 0.0F)
                      .endVertex();
                }
 
-               if (var44 > -1) {
+               if (var58 > -1) {
                   for (int var50 = 0; var50 < 8; var50++) {
-                     var10.pos(var48 + var50 + 0.0F, var19 + 0.0F, var49 + 8.0F)
-                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var50 + 0.0F, var20 + 0.0F, var49 + 8.0F)
+                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var50 + 0.0F, var19 + 4.0F, var49 + 8.0F)
-                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var50 + 0.0F, var20 + 4.0F, var49 + 8.0F)
+                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var50 + 0.0F, var19 + 4.0F, var49 + 0.0F)
-                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var50 + 0.0F, var20 + 4.0F, var49 + 0.0F)
+                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var50 + 0.0F, var19 + 0.0F, var49 + 0.0F)
-                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var50 + 0.0F, var20 + 0.0F, var49 + 0.0F)
+                        .tex((var46 + var50 + 0.5F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(-1.0F, 0.0F, 0.0F)
                         .endVertex();
                   }
                }
 
-               if (var44 <= 1) {
-                  for (int var56 = 0; var56 < 8; var56++) {
-                     var10.pos(var48 + var56 + 1.0F - 9.765625E-4F, var19 + 0.0F, var49 + 8.0F)
-                        .tex((var46 + var56 + 0.5F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+               if (var58 <= 1) {
+                  for (int var59 = 0; var59 < 8; var59++) {
+                     var11.pos(var48 + var59 + 1.0F - 9.765625E-4F, var20 + 0.0F, var49 + 8.0F)
+                        .tex((var46 + var59 + 0.5F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var56 + 1.0F - 9.765625E-4F, var19 + 4.0F, var49 + 8.0F)
-                        .tex((var46 + var56 + 0.5F) * 0.00390625F + var36, (var47 + 8.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var59 + 1.0F - 9.765625E-4F, var20 + 4.0F, var49 + 8.0F)
+                        .tex((var46 + var59 + 0.5F) * 0.00390625F + var37, (var47 + 8.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var56 + 1.0F - 9.765625E-4F, var19 + 4.0F, var49 + 0.0F)
-                        .tex((var46 + var56 + 0.5F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var59 + 1.0F - 9.765625E-4F, var20 + 4.0F, var49 + 0.0F)
+                        .tex((var46 + var59 + 0.5F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
-                     var10.pos(var48 + var56 + 1.0F - 9.765625E-4F, var19 + 0.0F, var49 + 0.0F)
-                        .tex((var46 + var56 + 0.5F) * 0.00390625F + var36, (var47 + 0.0F) * 0.00390625F + var37)
-                        .color(var53, var54, var55, 0.8F)
+                     var11.pos(var48 + var59 + 1.0F - 9.765625E-4F, var20 + 0.0F, var49 + 0.0F)
+                        .tex((var46 + var59 + 0.5F) * 0.00390625F + var37, (var47 + 0.0F) * 0.00390625F + var38)
+                        .color(var55, var56, var57, 0.8F)
                         .normal(1.0F, 0.0F, 0.0F)
                         .endVertex();
                   }
                }
 
                if (var45 > -1) {
-                  for (int var57 = 0; var57 < 8; var57++) {
-                     var10.pos(var48 + 0.0F, var19 + 4.0F, var49 + var57 + 0.0F)
-                        .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + var57 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                  for (int var60 = 0; var60 < 8; var60++) {
+                     var11.pos(var48 + 0.0F, var20 + 4.0F, var49 + var60 + 0.0F)
+                        .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + var60 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     var10.pos(var48 + 8.0F, var19 + 4.0F, var49 + var57 + 0.0F)
-                        .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + var57 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 8.0F, var20 + 4.0F, var49 + var60 + 0.0F)
+                        .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + var60 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     var10.pos(var48 + 8.0F, var19 + 0.0F, var49 + var57 + 0.0F)
-                        .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + var57 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 8.0F, var20 + 0.0F, var49 + var60 + 0.0F)
+                        .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + var60 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
-                     var10.pos(var48 + 0.0F, var19 + 0.0F, var49 + var57 + 0.0F)
-                        .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + var57 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 0.0F, var20 + 0.0F, var49 + var60 + 0.0F)
+                        .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + var60 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, -1.0F)
                         .endVertex();
                   }
                }
 
                if (var45 <= 1) {
-                  for (int var58 = 0; var58 < 8; var58++) {
-                     var10.pos(var48 + 0.0F, var19 + 4.0F, var49 + var58 + 1.0F - 9.765625E-4F)
-                        .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + var58 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                  for (int var61 = 0; var61 < 8; var61++) {
+                     var11.pos(var48 + 0.0F, var20 + 4.0F, var49 + var61 + 1.0F - 9.765625E-4F)
+                        .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + var61 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     var10.pos(var48 + 8.0F, var19 + 4.0F, var49 + var58 + 1.0F - 9.765625E-4F)
-                        .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + var58 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 8.0F, var20 + 4.0F, var49 + var61 + 1.0F - 9.765625E-4F)
+                        .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + var61 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     var10.pos(var48 + 8.0F, var19 + 0.0F, var49 + var58 + 1.0F - 9.765625E-4F)
-                        .tex((var46 + 8.0F) * 0.00390625F + var36, (var47 + var58 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 8.0F, var20 + 0.0F, var49 + var61 + 1.0F - 9.765625E-4F)
+                        .tex((var46 + 8.0F) * 0.00390625F + var37, (var47 + var61 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
-                     var10.pos(var48 + 0.0F, var19 + 0.0F, var49 + var58 + 1.0F - 9.765625E-4F)
-                        .tex((var46 + 0.0F) * 0.00390625F + var36, (var47 + var58 + 0.5F) * 0.00390625F + var37)
-                        .color(var32, var33, var34, 0.8F)
+                     var11.pos(var48 + 0.0F, var20 + 0.0F, var49 + var61 + 1.0F - 9.765625E-4F)
+                        .tex((var46 + 0.0F) * 0.00390625F + var37, (var47 + var61 + 0.5F) * 0.00390625F + var38)
+                        .color(var33, var34, var35, 0.8F)
                         .normal(0.0F, 0.0F, 1.0F)
                         .endVertex();
                   }
                }
 
-               var9.draw();
+               var10.draw();
             }
          }
+
+         this.cloudRenderer.endUpdateGlList();
       }
 
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       GlStateManager.disableBlend();
       GlStateManager.enableCull();
    }
 
    public void updateChunks(long var1) {
+      var1 = (long)(var1 + 1.0E8);
       this.displayListEntitiesDirty = this.displayListEntitiesDirty | this.renderDispatcher.runChunkUploads(var1);
-      if (!this.chunksToUpdate.isEmpty()) {
-         Iterator var3 = this.chunksToUpdate.iterator();
+      if (this.chunksToUpdateForced.size() > 0) {
+         Iterator var3 = this.chunksToUpdateForced.iterator();
 
          while (var3.hasNext()) {
             RenderChunk var4 = (RenderChunk)var3.next();
-            boolean var5;
-            if (var4.needsImmediateUpdate()) {
-               var5 = this.renderDispatcher.updateChunkNow(var4);
-            } else {
-               var5 = this.renderDispatcher.updateChunkLater(var4);
-            }
-
-            if (!var5) {
+            if (!this.renderDispatcher.updateChunkLater(var4)) {
                break;
             }
 
             var4.clearNeedsUpdate();
             var3.remove();
-            long var6 = var1 - System.nanoTime();
-            if (var6 < 0L) {
+            this.chunksToUpdate.remove(var4);
+            this.chunksToResortTransparency.remove(var4);
+         }
+      }
+
+      if (this.chunksToResortTransparency.size() > 0) {
+         Iterator var13 = this.chunksToResortTransparency.iterator();
+         if (var13.hasNext()) {
+            RenderChunk var15 = (RenderChunk)var13.next();
+            if (this.renderDispatcher.updateTransparencyLater(var15)) {
+               var13.remove();
+            }
+         }
+      }
+
+      double var14 = 0.0;
+      int var5 = Config.getUpdatesPerFrame();
+      if (!this.chunksToUpdate.isEmpty()) {
+         Iterator var6 = this.chunksToUpdate.iterator();
+
+         while (var6.hasNext()) {
+            RenderChunk var7 = (RenderChunk)var6.next();
+            boolean var9 = var7.isChunkRegionEmpty();
+            boolean var8;
+            if (!var7.needsImmediateUpdate() && !var9) {
+               var8 = this.renderDispatcher.updateChunkLater(var7);
+            } else {
+               var8 = this.renderDispatcher.updateChunkNow(var7);
+            }
+
+            if (!var8) {
                break;
             }
+
+            var7.clearNeedsUpdate();
+            var6.remove();
+            if (!var9) {
+               double var10 = 2.0 * RenderChunkUtils.getRelativeBufferSize(var7);
+               var14 += var10;
+               if (var14 > var5) {
+                  break;
+               }
+            }
          }
       }
    }
 
    public void renderWorldBorder(Entity var1, float var2) {
       Tessellator var3 = Tessellator.getInstance();
       BufferBuilder var4 = var3.getBuffer();
       WorldBorder var5 = this.world.getWorldBorder();
       double var6 = this.mc.gameSettings.renderDistanceChunks * 16;
-      if (!(var1.posX < var5.maxX() - var6) || !(var1.posX > var5.minX() + var6) || !(var1.posZ < var5.maxZ() - var6) || !(var1.posZ > var5.minZ() + var6)) {
+      if (var1.posX >= var5.maxX() - var6 || var1.posX <= var5.minX() + var6 || var1.posZ >= var5.maxZ() - var6 || var1.posZ <= var5.minZ() + var6) {
+         if (Config.isShaders()) {
+            Shaders.pushProgram();
+            Shaders.useProgram(Shaders.ProgramTexturedLit);
+         }
+
          double var8 = 1.0 - var5.getClosestDistance(var1) / var6;
          var8 = Math.pow(var8, 4.0);
          double var10 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var2;
          double var12 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var2;
          double var14 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var2;
          GlStateManager.enableBlend();
@@ -1680,38 +2206,53 @@
          var4.setTranslation(0.0, 0.0, 0.0);
          GlStateManager.enableCull();
          GlStateManager.disableAlpha();
          GlStateManager.doPolygonOffset(0.0F, 0.0F);
          GlStateManager.disablePolygonOffset();
          GlStateManager.enableAlpha();
+         GlStateManager.tryBlendFuncSeparate(
+            GlStateManager.SourceFactor.SRC_ALPHA,
+            GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+            GlStateManager.SourceFactor.ONE,
+            GlStateManager.DestFactor.ZERO
+         );
          GlStateManager.disableBlend();
          GlStateManager.popMatrix();
          GlStateManager.depthMask(true);
+         if (Config.isShaders()) {
+            Shaders.popProgram();
+         }
       }
    }
 
    private void preRenderDamagedBlocks() {
       GlStateManager.tryBlendFuncSeparate(
          GlStateManager.SourceFactor.DST_COLOR, GlStateManager.DestFactor.SRC_COLOR, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO
       );
       GlStateManager.enableBlend();
       GlStateManager.color(1.0F, 1.0F, 1.0F, 0.5F);
-      GlStateManager.doPolygonOffset(-3.0F, -3.0F);
+      GlStateManager.doPolygonOffset(-1.0F, -10.0F);
       GlStateManager.enablePolygonOffset();
       GlStateManager.alphaFunc(516, 0.1F);
       GlStateManager.enableAlpha();
       GlStateManager.pushMatrix();
+      if (Config.isShaders()) {
+         ShadersRender.beginBlockDamage();
+      }
    }
 
    private void postRenderDamagedBlocks() {
       GlStateManager.disableAlpha();
       GlStateManager.doPolygonOffset(0.0F, 0.0F);
       GlStateManager.disablePolygonOffset();
       GlStateManager.enableAlpha();
       GlStateManager.depthMask(true);
       GlStateManager.popMatrix();
+      if (Config.isShaders()) {
+         ShadersRender.endBlockDamage();
+      }
    }
 
    public void drawBlockDamageTexture(Tessellator var1, BufferBuilder var2, Entity var3, float var4) {
       double var5 = var3.lastTickPosX + (var3.posX - var3.lastTickPosX) * var4;
       double var7 = var3.lastTickPosY + (var3.posY - var3.lastTickPosY) * var4;
       double var9 = var3.lastTickPosZ + (var3.posZ - var3.lastTickPosZ) * var4;
@@ -1727,56 +2268,79 @@
             DestroyBlockProgress var12 = (DestroyBlockProgress)var11.next();
             BlockPos var13 = var12.getPosition();
             double var14 = var13.getX() - var5;
             double var16 = var13.getY() - var7;
             double var18 = var13.getZ() - var9;
             Block var20 = this.world.getBlockState(var13).getBlock();
-            if (!(var20 instanceof BlockChest) && !(var20 instanceof BlockEnderChest) && !(var20 instanceof BlockSign) && !(var20 instanceof BlockSkull)) {
+            boolean var21;
+            if (Reflector.ForgeTileEntity_canRenderBreaking.exists()) {
+               boolean var22 = var20 instanceof BlockChest || var20 instanceof BlockEnderChest || var20 instanceof BlockSign || var20 instanceof BlockSkull;
+               if (!var22) {
+                  TileEntity var23 = this.world.getTileEntity(var13);
+                  if (var23 != null) {
+                     var22 = Reflector.callBoolean(var23, Reflector.ForgeTileEntity_canRenderBreaking, new Object[0]);
+                  }
+               }
+
+               var21 = !var22;
+            } else {
+               var21 = !(var20 instanceof BlockChest) && !(var20 instanceof BlockEnderChest) && !(var20 instanceof BlockSign) && !(var20 instanceof BlockSkull);
+            }
+
+            if (var21) {
                if (var14 * var14 + var16 * var16 + var18 * var18 > 1024.0) {
                   var11.remove();
                } else {
-                  IBlockState var21 = this.world.getBlockState(var13);
-                  if (var21.getMaterial() != Material.AIR) {
-                     int var22 = var12.getPartialBlockDamage();
-                     TextureAtlasSprite var23 = this.destroyBlockIcons[var22];
-                     BlockRendererDispatcher var24 = this.mc.getBlockRendererDispatcher();
-                     var24.renderBlockDamage(var21, var13, var23, this.world);
+                  IBlockState var26 = this.world.getBlockState(var13);
+                  if (var26.a() != Material.AIR) {
+                     int var27 = var12.getPartialBlockDamage();
+                     TextureAtlasSprite var24 = this.destroyBlockIcons[var27];
+                     BlockRendererDispatcher var25 = this.mc.getBlockRendererDispatcher();
+                     var25.renderBlockDamage(var26, var13, var24, this.world);
                   }
                }
             }
          }
 
          var1.draw();
          var2.setTranslation(0.0, 0.0, 0.0);
          this.postRenderDamagedBlocks();
       }
    }
 
    public void drawSelectionBox(EntityPlayer var1, RayTraceResult var2, int var3, float var4) {
-      if (var3 == 0 && var2.typeOfHit == RayTraceResult.Type.BLOCK) {
+      if (var3 == 0 && var2.typeOfHit == Type.BLOCK) {
          GlStateManager.enableBlend();
          GlStateManager.tryBlendFuncSeparate(
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
             GlStateManager.SourceFactor.ONE,
             GlStateManager.DestFactor.ZERO
          );
          GlStateManager.glLineWidth(2.0F);
          GlStateManager.disableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.disableTexture2D();
+         }
+
          GlStateManager.depthMask(false);
          BlockPos var5 = var2.getBlockPos();
          IBlockState var6 = this.world.getBlockState(var5);
-         if (var6.getMaterial() != Material.AIR && this.world.getWorldBorder().contains(var5)) {
+         if (var6.a() != Material.AIR && this.world.getWorldBorder().contains(var5)) {
             double var7 = var1.lastTickPosX + (var1.posX - var1.lastTickPosX) * var4;
             double var9 = var1.lastTickPosY + (var1.posY - var1.lastTickPosY) * var4;
             double var11 = var1.lastTickPosZ + (var1.posZ - var1.lastTickPosZ) * var4;
-            drawSelectionBoundingBox(var6.getSelectedBoundingBox(this.world, var5).grow(0.002F).offset(-var7, -var9, -var11), 0.0F, 0.0F, 0.0F, 0.4F);
+            drawSelectionBoundingBox(var6.c(this.world, var5).grow(0.002F).offset(-var7, -var9, -var11), 0.0F, 0.0F, 0.0F, 0.4F);
          }
 
          GlStateManager.depthMask(true);
          GlStateManager.enableTexture2D();
+         if (Config.isShaders()) {
+            Shaders.enableTexture2D();
+         }
+
          GlStateManager.disableBlend();
       }
    }
 
    public static void drawSelectionBoundingBox(AxisAlignedBB var0, float var1, float var2, float var3, float var4) {
       drawBoundingBox(var0.minX, var0.minY, var0.minZ, var0.maxX, var0.maxY, var0.maxZ, var1, var2, var3, var4);
@@ -1802,20 +2366,19 @@
       var0.pos(var1, var3, var11).color(var13, var14, var15, var16).endVertex();
       var0.pos(var1, var3, var5).color(var13, var14, var15, var16).endVertex();
       var0.pos(var1, var9, var5).color(var13, var14, var15, var16).endVertex();
       var0.pos(var7, var9, var5).color(var13, var14, var15, var16).endVertex();
       var0.pos(var7, var9, var11).color(var13, var14, var15, var16).endVertex();
       var0.pos(var1, var9, var11).color(var13, var14, var15, var16).endVertex();
-      var0.pos(var1, var9, var5).color(var13, var14, var15, var16).endVertex();
-      var0.pos(var1, var9, var11).color(var13, var14, var15, 0.0F).endVertex();
+      var0.pos(var1, var9, var5).color(var13, var14, var15, 0.0F).endVertex();
+      var0.pos(var1, var9, var11).color(var13, var14, var15, var16).endVertex();
       var0.pos(var1, var3, var11).color(var13, var14, var15, var16).endVertex();
-      var0.pos(var7, var9, var11).color(var13, var14, var15, 0.0F).endVertex();
-      var0.pos(var7, var3, var11).color(var13, var14, var15, var16).endVertex();
+      var0.pos(var7, var3, var11).color(var13, var14, var15, 0.0F).endVertex();
+      var0.pos(var7, var9, var11).color(var13, var14, var15, var16).endVertex();
       var0.pos(var7, var9, var5).color(var13, var14, var15, 0.0F).endVertex();
       var0.pos(var7, var3, var5).color(var13, var14, var15, var16).endVertex();
-      var0.pos(var7, var3, var5).color(var13, var14, var15, 0.0F).endVertex();
    }
 
    public static void renderFilledBox(AxisAlignedBB var0, float var1, float var2, float var3, float var4) {
       renderFilledBox(var0.minX, var0.minY, var0.minZ, var0.maxX, var0.maxY, var0.maxZ, var1, var2, var3, var4);
    }
 
@@ -1865,31 +2428,27 @@
    }
 
    private void markBlocksForUpdate(int var1, int var2, int var3, int var4, int var5, int var6, boolean var7) {
       this.viewFrustum.markBlocksForUpdate(var1, var2, var3, var4, var5, var6, var7);
    }
 
-   @Override
    public void notifyBlockUpdate(World var1, BlockPos var2, IBlockState var3, IBlockState var4, int var5) {
       int var6 = var2.getX();
       int var7 = var2.getY();
       int var8 = var2.getZ();
       this.markBlocksForUpdate(var6 - 1, var7 - 1, var8 - 1, var6 + 1, var7 + 1, var8 + 1, (var5 & 8) != 0);
    }
 
-   @Override
    public void notifyLightSet(BlockPos var1) {
       this.setLightUpdates.add(var1.toImmutable());
    }
 
-   @Override
    public void markBlockRangeForRenderUpdate(int var1, int var2, int var3, int var4, int var5, int var6) {
       this.markBlocksForUpdate(var1 - 1, var2 - 1, var3 - 1, var4 + 1, var5 + 1, var6 + 1, false);
    }
 
-   @Override
    public void playRecord(@Nullable SoundEvent var1, BlockPos var2) {
       ISound var3 = this.mapSoundPositions.get(var2);
       if (var3 != null) {
          this.mc.getSoundHandler().stopSound(var3);
          this.mapSoundPositions.remove(var2);
       }
@@ -1906,29 +2465,26 @@
       }
 
       this.setPartying(this.world, var2, var1 != null);
    }
 
    private void setPartying(World var1, BlockPos var2, boolean var3) {
-      for (EntityLivingBase var6 : var1.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(var2).grow(3.0))) {
-         var6.setPartying(var2, var3);
+      for (EntityLivingBase var5 : var1.getEntitiesWithinAABB(EntityLivingBase.class, new AxisAlignedBB(var2).grow(3.0))) {
+         var5.setPartying(var2, var3);
       }
    }
 
-   @Override
    public void playSoundToAllNearExcept(
       @Nullable EntityPlayer var1, SoundEvent var2, SoundCategory var3, double var4, double var6, double var8, float var10, float var11
    ) {
    }
 
-   @Override
    public void spawnParticle(int var1, boolean var2, double var3, double var5, double var7, double var9, double var11, double var13, int... var15) {
       this.spawnParticle(var1, var2, false, var3, var5, var7, var9, var11, var13, var15);
    }
 
-   @Override
    public void spawnParticle(
       int var1, boolean var2, boolean var3, final double var4, final double var6, final double var8, double var10, double var12, double var14, int... var16
    ) {
       try {
          this.spawnParticle0(var1, var2, var3, var4, var6, var8, var10, var12, var14, var16);
       } catch (Throwable var20) {
@@ -1964,18 +2520,90 @@
       Entity var17 = this.mc.getRenderViewEntity();
       if (this.mc != null && var17 != null && this.mc.effectRenderer != null) {
          int var18 = this.calculateParticleLevel(var3);
          double var19 = var17.posX - var4;
          double var21 = var17.posY - var6;
          double var23 = var17.posZ - var8;
-         if (var2) {
-            return this.mc.effectRenderer.spawnEffectParticle(var1, var4, var6, var8, var10, var12, var14, var16);
-         } else if (var19 * var19 + var21 * var21 + var23 * var23 > 1024.0) {
+         if (var1 == EnumParticleTypes.EXPLOSION_HUGE.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.EXPLOSION_LARGE.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.EXPLOSION_NORMAL.getParticleID() && !Config.isAnimatedExplosion()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SUSPENDED.getParticleID() && !Config.isWaterParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SUSPENDED_DEPTH.getParticleID() && !Config.isVoidParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SMOKE_NORMAL.getParticleID() && !Config.isAnimatedSmoke()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SMOKE_LARGE.getParticleID() && !Config.isAnimatedSmoke()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SPELL_MOB.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SPELL_MOB_AMBIENT.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SPELL.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SPELL_INSTANT.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.SPELL_WITCH.getParticleID() && !Config.isPotionParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.PORTAL.getParticleID() && !Config.isPortalParticles()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.FLAME.getParticleID() && !Config.isAnimatedFlame()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.REDSTONE.getParticleID() && !Config.isAnimatedRedstone()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.DRIP_WATER.getParticleID() && !Config.isDrippingWaterLava()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.DRIP_LAVA.getParticleID() && !Config.isDrippingWaterLava()) {
+            return null;
+         } else if (var1 == EnumParticleTypes.FIREWORKS_SPARK.getParticleID() && !Config.isFireworkParticles()) {
             return null;
          } else {
-            return var18 > 1 ? null : this.mc.effectRenderer.spawnEffectParticle(var1, var4, var6, var8, var10, var12, var14, var16);
+            if (!var2) {
+               double var26 = 1024.0;
+               if (var1 == EnumParticleTypes.CRIT.getParticleID()) {
+                  var26 = 38416.0;
+               }
+
+               if (var19 * var19 + var21 * var21 + var23 * var23 > var26) {
+                  return null;
+               }
+
+               if (var18 > 1) {
+                  return null;
+               }
+            }
+
+            Particle var28 = this.mc.effectRenderer.spawnEffectParticle(var1, var4, var6, var8, var10, var12, var14, var16);
+            if (var1 == EnumParticleTypes.WATER_BUBBLE.getParticleID()) {
+               CustomColors.updateWaterFX(var28, this.world, var4, var6, var8, this.renderEnv);
+            }
+
+            if (var1 == EnumParticleTypes.WATER_SPLASH.getParticleID()) {
+               CustomColors.updateWaterFX(var28, this.world, var4, var6, var8, this.renderEnv);
+            }
+
+            if (var1 == EnumParticleTypes.WATER_DROP.getParticleID()) {
+               CustomColors.updateWaterFX(var28, this.world, var4, var6, var8, this.renderEnv);
+            }
+
+            if (var1 == EnumParticleTypes.TOWN_AURA.getParticleID()) {
+               CustomColors.updateMyceliumFX(var28);
+            }
+
+            if (var1 == EnumParticleTypes.PORTAL.getParticleID()) {
+               CustomColors.updatePortalFX(var28);
+            }
+
+            if (var1 == EnumParticleTypes.REDSTONE.getParticleID()) {
+               CustomColors.updateReddustFX(var28, this.world, var4, var6, var8);
+            }
+
+            return var28;
          }
       } else {
          return null;
       }
    }
 
@@ -1989,24 +2617,29 @@
          var2 = 2;
       }
 
       return var2;
    }
 
-   @Override
    public void onEntityAdded(Entity var1) {
+      RandomEntities.entityLoaded(var1, this.world);
+      if (Config.isDynamicLights()) {
+         DynamicLights.entityAdded(var1, this);
+      }
    }
 
-   @Override
    public void onEntityRemoved(Entity var1) {
+      RandomEntities.entityUnloaded(var1, this.world);
+      if (Config.isDynamicLights()) {
+         DynamicLights.entityRemoved(var1, this);
+      }
    }
 
    public void deleteAllDisplayLists() {
    }
 
-   @Override
    public void broadcastSound(int var1, BlockPos var2, int var3) {
       switch (var1) {
          case 1023:
          case 1028:
          case 1038:
             Entity var4 = this.mc.getRenderViewEntity();
@@ -2032,13 +2665,12 @@
                   this.world.playSound(var13, var15, var17, SoundEvents.ENTITY_ENDERDRAGON_DEATH, SoundCategory.HOSTILE, 5.0F, 1.0F, false);
                }
             }
       }
    }
 
-   @Override
    public void playEvent(EntityPlayer var1, int var2, BlockPos var3, int var4) {
       Random var5 = this.world.rand;
       switch (var2) {
          case 1000:
             this.world.playSound(var3, SoundEvents.BLOCK_DISPENSER_DISPENSE, SoundCategory.BLOCKS, 1.0F, 1.0F, false);
             break;
@@ -2071,13 +2703,13 @@
                .playSound(var3, SoundEvents.BLOCK_FIRE_EXTINGUISH, SoundCategory.BLOCKS, 0.5F, 2.6F + (var5.nextFloat() - var5.nextFloat()) * 0.8F, false);
             break;
          case 1010:
             if (Item.getItemById(var4) instanceof ItemRecord) {
                this.world.playRecord(var3, ((ItemRecord)Item.getItemById(var4)).getSound());
             } else {
-               this.world.playRecord(var3, null);
+               this.world.playRecord(var3, (SoundEvent)null);
             }
             break;
          case 1011:
             this.world.playSound(var3, SoundEvents.BLOCK_IRON_DOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1012:
@@ -2168,150 +2800,157 @@
             this.world.playSound(var3, SoundEvents.BLOCK_IRON_TRAPDOOR_CLOSE, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 1037:
             this.world.playSound(var3, SoundEvents.BLOCK_IRON_TRAPDOOR_OPEN, SoundCategory.BLOCKS, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 2000:
-            int var31 = var4 % 3 - 1;
-            int var8 = var4 / 3 % 3 - 1;
-            double var33 = var3.getX() + var31 * 0.6 + 0.5;
-            double var35 = var3.getY() + 0.5;
-            double var39 = var3.getZ() + var8 * 0.6 + 0.5;
-
-            for (int var40 = 0; var40 < 10; var40++) {
-               double var41 = var5.nextDouble() * 0.2 + 0.01;
-               double var47 = var33 + var31 * 0.01 + (var5.nextDouble() - 0.5) * var8 * 0.5;
-               double var50 = var35 + (var5.nextDouble() - 0.5) * 0.5;
-               double var53 = var39 + var8 * 0.01 + (var5.nextDouble() - 0.5) * var31 * 0.5;
-               double var55 = var31 * var41 + var5.nextGaussian() * 0.01;
-               double var57 = -0.03 + var5.nextGaussian() * 0.01;
-               double var58 = var8 * var41 + var5.nextGaussian() * 0.01;
-               this.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, var47, var50, var53, var55, var57, var58);
+            int var6 = var4 % 3 - 1;
+            int var7 = var4 / 3 % 3 - 1;
+            double var8 = var3.getX() + var6 * 0.6 + 0.5;
+            double var10 = var3.getY() + 0.5;
+            double var12 = var3.getZ() + var7 * 0.6 + 0.5;
+
+            for (int var41 = 0; var41 < 10; var41++) {
+               double var43 = var5.nextDouble() * 0.2 + 0.01;
+               double var44 = var8 + var6 * 0.01 + (var5.nextDouble() - 0.5) * var7 * 0.5;
+               double var45 = var10 + (var5.nextDouble() - 0.5) * 0.5;
+               double var47 = var12 + var7 * 0.01 + (var5.nextDouble() - 0.5) * var6 * 0.5;
+               double var48 = var6 * var43 + var5.nextGaussian() * 0.01;
+               double var50 = -0.03 + var5.nextGaussian() * 0.01;
+               double var51 = var7 * var43 + var5.nextGaussian() * 0.01;
+               this.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, var44, var45, var47, var48, var50, var51);
             }
-            break;
+
+            return;
          case 2001:
-            Block var6 = Block.getBlockById(var4 & 4095);
-            if (var6.getDefaultState().getMaterial() != Material.AIR) {
-               SoundType var44 = var6.getSoundType();
-               this.world.playSound(var3, var44.getBreakSound(), SoundCategory.BLOCKS, (var44.getVolume() + 1.0F) / 2.0F, var44.getPitch() * 0.8F, false);
+            Block var14 = Block.getBlockById(var4 & 4095);
+            if (var14.getDefaultState().a() != Material.AIR) {
+               SoundType var42 = var14.getSoundType();
+               if (Reflector.ForgeBlock_getSoundType.exists()) {
+                  var42 = (SoundType)Reflector.call(var14, Reflector.ForgeBlock_getSoundType, new Object[]{Block.getStateById(var4), this.world, var3, null});
+               }
+
+               this.world.playSound(var3, var42.getBreakSound(), SoundCategory.BLOCKS, (var42.getVolume() + 1.0F) / 2.0F, var42.getPitch() * 0.8F, false);
             }
 
-            this.mc.effectRenderer.addBlockDestroyEffects(var3, var6.getStateFromMeta(var4 >> 12 & 0xFF));
+            this.mc.effectRenderer.addBlockDestroyEffects(var3, var14.getStateFromMeta(var4 >> 12 & 0xFF));
             break;
          case 2002:
          case 2007:
-            double var30 = var3.getX();
-            double var32 = var3.getY();
-            double var34 = var3.getZ();
+            double var15 = var3.getX();
+            double var17 = var3.getY();
+            double var19 = var3.getZ();
 
-            for (int var37 = 0; var37 < 8; var37++) {
+            for (int var21 = 0; var21 < 8; var21++) {
                this.spawnParticle(
                   EnumParticleTypes.ITEM_CRACK,
-                  var30,
-                  var32,
-                  var34,
+                  var15,
+                  var17,
+                  var19,
                   var5.nextGaussian() * 0.15,
                   var5.nextDouble() * 0.2,
                   var5.nextGaussian() * 0.15,
                   Item.getIdFromItem(Items.SPLASH_POTION)
                );
             }
 
-            float var38 = (var4 >> 16 & 0xFF) / 255.0F;
-            float var14 = (var4 >> 8 & 0xFF) / 255.0F;
-            float var15 = (var4 >> 0 & 0xFF) / 255.0F;
-            EnumParticleTypes var16 = var2 == 2007 ? EnumParticleTypes.SPELL_INSTANT : EnumParticleTypes.SPELL;
-
-            for (int var43 = 0; var43 < 100; var43++) {
-               double var46 = var5.nextDouble() * 4.0;
-               double var49 = var5.nextDouble() * Math.PI * 2.0;
-               double var52 = Math.cos(var49) * var46;
-               double var54 = 0.01 + var5.nextDouble() * 0.5;
-               double var56 = Math.sin(var49) * var46;
-               Particle var28 = this.spawnParticle0(
-                  var16.getParticleID(), var16.getShouldIgnoreRange(), var30 + var52 * 0.1, var32 + 0.3, var34 + var56 * 0.1, var52, var54, var56
+            float var46 = (var4 >> 16 & 0xFF) / 255.0F;
+            float var22 = (var4 >> 8 & 0xFF) / 255.0F;
+            float var23 = (var4 >> 0 & 0xFF) / 255.0F;
+            EnumParticleTypes var24 = var2 == 2007 ? EnumParticleTypes.SPELL_INSTANT : EnumParticleTypes.SPELL;
+
+            for (int var49 = 0; var49 < 100; var49++) {
+               double var26 = var5.nextDouble() * 4.0;
+               double var28 = var5.nextDouble() * Math.PI * 2.0;
+               double var30 = Math.cos(var28) * var26;
+               double var56 = 0.01 + var5.nextDouble() * 0.5;
+               double var58 = Math.sin(var28) * var26;
+               Particle var60 = this.spawnParticle0(
+                  var24.getParticleID(), var24.getShouldIgnoreRange(), var15 + var30 * 0.1, var17 + 0.3, var19 + var58 * 0.1, var30, var56, var58
                );
-               if (var28 != null) {
-                  float var29 = 0.75F + var5.nextFloat() * 0.25F;
-                  var28.setRBGColorF(var38 * var29, var14 * var29, var15 * var29);
-                  var28.multiplyVelocity((float)var46);
+               if (var60 != null) {
+                  float var37 = 0.75F + var5.nextFloat() * 0.25F;
+                  var60.setRBGColorF(var46 * var37, var22 * var37, var23 * var37);
+                  var60.multiplyVelocity((float)var26);
                }
             }
 
             this.world.playSound(var3, SoundEvents.ENTITY_SPLASH_POTION_BREAK, SoundCategory.NEUTRAL, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
          case 2003:
-            double var7 = var3.getX() + 0.5;
-            double var9 = var3.getY();
-            double var11 = var3.getZ() + 0.5;
+            double var25 = var3.getX() + 0.5;
+            double var27 = var3.getY();
+            double var29 = var3.getZ() + 0.5;
 
-            for (int var13 = 0; var13 < 8; var13++) {
+            for (int var53 = 0; var53 < 8; var53++) {
                this.spawnParticle(
                   EnumParticleTypes.ITEM_CRACK,
-                  var7,
-                  var9,
-                  var11,
+                  var25,
+                  var27,
+                  var29,
                   var5.nextGaussian() * 0.15,
                   var5.nextDouble() * 0.2,
                   var5.nextGaussian() * 0.15,
                   Item.getIdFromItem(Items.ENDER_EYE)
                );
             }
 
-            for (double var36 = 0.0; var36 < Math.PI * 2; var36 += Math.PI / 20) {
+            for (double var54 = 0.0; var54 < Math.PI * 2; var54 += Math.PI / 20) {
                this.spawnParticle(
                   EnumParticleTypes.PORTAL,
-                  var7 + Math.cos(var36) * 5.0,
-                  var9 - 0.4,
-                  var11 + Math.sin(var36) * 5.0,
-                  Math.cos(var36) * -5.0,
+                  var25 + Math.cos(var54) * 5.0,
+                  var27 - 0.4,
+                  var29 + Math.sin(var54) * 5.0,
+                  Math.cos(var54) * -5.0,
                   0.0,
-                  Math.sin(var36) * -5.0
+                  Math.sin(var54) * -5.0
                );
                this.spawnParticle(
                   EnumParticleTypes.PORTAL,
-                  var7 + Math.cos(var36) * 5.0,
-                  var9 - 0.4,
-                  var11 + Math.sin(var36) * 5.0,
-                  Math.cos(var36) * -7.0,
+                  var25 + Math.cos(var54) * 5.0,
+                  var27 - 0.4,
+                  var29 + Math.sin(var54) * 5.0,
+                  Math.cos(var54) * -7.0,
                   0.0,
-                  Math.sin(var36) * -7.0
+                  Math.sin(var54) * -7.0
                );
             }
-            break;
+
+            return;
          case 2004:
-            for (int var42 = 0; var42 < 20; var42++) {
-               double var45 = var3.getX() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               double var48 = var3.getY() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               double var51 = var3.getZ() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
-               this.world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, var45, var48, var51, 0.0, 0.0, 0.0, new int[0]);
-               this.world.spawnParticle(EnumParticleTypes.FLAME, var45, var48, var51, 0.0, 0.0, 0.0, new int[0]);
+            for (int var52 = 0; var52 < 20; var52++) {
+               double var55 = var3.getX() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               double var57 = var3.getY() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               double var59 = var3.getZ() + 0.5 + (this.world.rand.nextFloat() - 0.5) * 2.0;
+               this.world.spawnParticle(EnumParticleTypes.SMOKE_NORMAL, var55, var57, var59, 0.0, 0.0, 0.0, new int[0]);
+               this.world.spawnParticle(EnumParticleTypes.FLAME, var55, var57, var59, 0.0, 0.0, 0.0, new int[0]);
             }
-            break;
+
+            return;
          case 2005:
             ItemDye.spawnBonemealParticles(this.world, var3, var4);
             break;
          case 2006:
-            for (int var17 = 0; var17 < 200; var17++) {
-               float var18 = var5.nextFloat() * 4.0F;
-               float var19 = var5.nextFloat() * (float) (Math.PI * 2);
-               double var20 = MathHelper.cos(var19) * var18;
-               double var22 = 0.01 + var5.nextDouble() * 0.5;
-               double var24 = MathHelper.sin(var19) * var18;
-               Particle var26 = this.spawnParticle0(
+            for (int var31 = 0; var31 < 200; var31++) {
+               float var32 = var5.nextFloat() * 4.0F;
+               float var33 = var5.nextFloat() * (float) (Math.PI * 2);
+               double var34 = MathHelper.cos(var33) * var32;
+               double var36 = 0.01 + var5.nextDouble() * 0.5;
+               double var38 = MathHelper.sin(var33) * var32;
+               Particle var40 = this.spawnParticle0(
                   EnumParticleTypes.DRAGON_BREATH.getParticleID(),
                   false,
-                  var3.getX() + var20 * 0.1,
+                  var3.getX() + var34 * 0.1,
                   var3.getY() + 0.3,
-                  var3.getZ() + var24 * 0.1,
-                  var20,
-                  var22,
-                  var24
+                  var3.getZ() + var38 * 0.1,
+                  var34,
+                  var36,
+                  var38
                );
-               if (var26 != null) {
-                  var26.multiplyVelocity(var18);
+               if (var40 != null) {
+                  var40.multiplyVelocity(var32);
                }
             }
 
             this.world
                .playSound(var3, SoundEvents.ENTITY_ENDERDRAGON_FIREBALL_EPLD, SoundCategory.HOSTILE, 1.0F, this.world.rand.nextFloat() * 0.1F + 0.9F, false);
             break;
@@ -2330,13 +2969,12 @@
             break;
          case 3001:
             this.world.playSound(var3, SoundEvents.ENTITY_ENDERDRAGON_GROWL, SoundCategory.HOSTILE, 64.0F, 0.8F + this.world.rand.nextFloat() * 0.3F, false);
       }
    }
 
-   @Override
    public void sendBlockBreakProgress(int var1, BlockPos var2, int var3) {
       if (var3 >= 0 && var3 < 10) {
          DestroyBlockProgress var4 = this.damagedBlocks.get(var1);
          if (var4 == null || var4.getPosition().getX() != var2.getX() || var4.getPosition().getY() != var2.getY() || var4.getPosition().getZ() != var2.getZ()) {
             var4 = new DestroyBlockProgress(var1, var2);
             this.damagedBlocks.put(var1, var4);
@@ -2354,34 +2992,119 @@
    }
 
    public void setDisplayListEntitiesDirty() {
       this.displayListEntitiesDirty = true;
    }
 
+   public void resetClouds() {
+      this.cloudRenderer.reset();
+   }
+
+   public int getCountRenderers() {
+      return this.viewFrustum.renderChunks.length;
+   }
+
+   public int getCountActiveRenderers() {
+      return this.renderInfos.size();
+   }
+
+   public int getCountEntitiesRendered() {
+      return this.countEntitiesRendered;
+   }
+
+   public int getCountTileEntitiesRendered() {
+      return this.countTileEntitiesRendered;
+   }
+
+   public int getCountLoadedChunks() {
+      if (this.world == null) {
+         return 0;
+      } else {
+         ChunkProviderClient var1 = this.world.getChunkProvider();
+         if (var1 == null) {
+            return 0;
+         } else {
+            if (var1 != this.worldChunkProvider) {
+               this.worldChunkProvider = var1;
+               this.worldChunkProviderMap = (Long2ObjectMap<Chunk>)Reflector.getFieldValue(var1, Reflector.ChunkProviderClient_chunkMapping);
+            }
+
+            return this.worldChunkProviderMap == null ? 0 : this.worldChunkProviderMap.size();
+         }
+      }
+   }
+
+   public int getCountChunksToUpdate() {
+      return this.chunksToUpdate.size();
+   }
+
+   public RenderChunk getRenderChunk(BlockPos var1) {
+      return this.viewFrustum.getRenderChunk(var1);
+   }
+
+   public WorldClient getWorld() {
+      return this.world;
+   }
+
+   private void clearRenderInfos() {
+      if (renderEntitiesCounter > 0) {
+         this.renderInfos = new ArrayList<>(this.renderInfos.size() + 16);
+         this.renderInfosEntities = new ArrayList(this.renderInfosEntities.size() + 16);
+         this.renderInfosTileEntities = new ArrayList(this.renderInfosTileEntities.size() + 16);
+      } else {
+         this.renderInfos.clear();
+         this.renderInfosEntities.clear();
+         this.renderInfosTileEntities.clear();
+      }
+   }
+
+   public void onPlayerPositionSet() {
+      if (this.firstWorldLoad) {
+         this.loadRenderers();
+         this.firstWorldLoad = false;
+      }
+   }
+
+   public void pauseChunkUpdates() {
+      if (this.renderDispatcher != null) {
+         this.renderDispatcher.pauseChunkUpdates();
+      }
+   }
+
+   public void resumeChunkUpdates() {
+      if (this.renderDispatcher != null) {
+         this.renderDispatcher.resumeChunkUpdates();
+      }
+   }
+
    public void updateTileEntities(Collection<TileEntity> var1, Collection<TileEntity> var2) {
       synchronized (this.setTileEntities) {
          this.setTileEntities.removeAll(var1);
          this.setTileEntities.addAll(var2);
       }
    }
 
-   class ContainerLocalRenderInformation {
+   public static class ContainerLocalRenderInformation {
       final RenderChunk renderChunk;
-      final EnumFacing facing;
-      byte setFacing;
-      final int counter;
-
-      private ContainerLocalRenderInformation(RenderChunk var2, EnumFacing var3, @Nullable int var4) {
-         this.renderChunk = var2;
-         this.facing = var3;
-         this.counter = var4;
+      EnumFacing facing;
+      int setFacing;
+
+      public ContainerLocalRenderInformation(RenderChunk var1, EnumFacing var2, int var3) {
+         this.renderChunk = var1;
+         this.facing = var2;
+         this.setFacing = var3;
       }
 
       public void setDirection(byte var1, EnumFacing var2) {
-         this.setFacing = (byte)(this.setFacing | var1 | 1 << var2.ordinal());
+         this.setFacing = this.setFacing | var1 | 1 << var2.ordinal();
       }
 
       public boolean hasDirection(EnumFacing var1) {
          return (this.setFacing & 1 << var1.ordinal()) > 0;
+      }
+
+      private void initialize(EnumFacing var1, int var2) {
+         this.facing = var1;
+         this.setFacing = var2;
       }
    }
 }
--- net/minecraft/client/renderer/RenderHelper.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/RenderHelper.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/RenderItem.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/RenderItem.java	Mon Aug 18 09:39:52 2025
@@ -1,37 +1,26 @@
 package net.minecraft.client.renderer;
 
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.block.Block;
-import net.minecraft.block.BlockDirt;
-import net.minecraft.block.BlockDoublePlant;
-import net.minecraft.block.BlockFlower;
-import net.minecraft.block.BlockHugeMushroom;
-import net.minecraft.block.BlockPlanks;
-import net.minecraft.block.BlockPrismarine;
-import net.minecraft.block.BlockQuartz;
-import net.minecraft.block.BlockRedSandstone;
-import net.minecraft.block.BlockSand;
-import net.minecraft.block.BlockSandStone;
-import net.minecraft.block.BlockSilverfish;
-import net.minecraft.block.BlockStone;
-import net.minecraft.block.BlockStoneBrick;
-import net.minecraft.block.BlockStoneSlab;
-import net.minecraft.block.BlockStoneSlabNew;
-import net.minecraft.block.BlockTallGrass;
-import net.minecraft.block.BlockWall;
+import net.minecraft.block.BlockDirt.DirtType;
+import net.minecraft.block.BlockDoublePlant.EnumPlantType;
+import net.minecraft.block.BlockFlower.EnumFlowerType;
+import net.minecraft.block.BlockWall.EnumType;
+import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.client.gui.FontRenderer;
 import net.minecraft.client.renderer.block.model.BakedQuad;
 import net.minecraft.client.renderer.block.model.IBakedModel;
 import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.block.model.ItemTransformVec3f;
 import net.minecraft.client.renderer.block.model.ModelManager;
 import net.minecraft.client.renderer.block.model.ModelResourceLocation;
+import net.minecraft.client.renderer.block.model.ItemCameraTransforms.TransformType;
 import net.minecraft.client.renderer.color.ItemColors;
 import net.minecraft.client.renderer.texture.TextureManager;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
@@ -42,33 +31,52 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.item.EnumDyeColor;
 import net.minecraft.item.Item;
-import net.minecraft.item.ItemFishFood;
 import net.minecraft.item.ItemStack;
-import net.minecraft.tileentity.TileEntityStructure;
+import net.minecraft.item.ItemFishFood.FishType;
+import net.minecraft.tileentity.TileEntityStructure.Mode;
+import net.minecraft.util.BlockRenderLayer;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3i;
 import net.minecraft.world.World;
+import net.optifine.CustomColors;
+import net.optifine.CustomItems;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
+import net.optifine.shaders.Shaders;
+import net.optifine.shaders.ShadersRender;
 
 public class RenderItem implements IResourceManagerReloadListener {
    private static final ResourceLocation RES_ITEM_GLINT = new ResourceLocation("textures/misc/enchanted_item_glint.png");
    private boolean notRenderingEffectsInGUI = true;
    public float zLevel;
    private final ItemModelMesher itemModelMesher;
    private final TextureManager textureManager;
    private final ItemColors itemColors;
+   private ResourceLocation modelLocation = null;
+   private boolean renderItemGui = false;
+   public ModelManager modelManager = null;
+   private boolean renderModelHasEmissive = false;
+   private boolean renderModelEmissive = false;
+   private boolean forgeAllowEmissiveItems = Reflector.getFieldValueBoolean(Reflector.ForgeModContainer_allowEmissiveItems, false);
 
    public RenderItem(TextureManager var1, ModelManager var2, ItemColors var3) {
       this.textureManager = var1;
-      this.itemModelMesher = new ItemModelMesher(var2);
+      this.modelManager = var2;
+      if (Reflector.ItemModelMesherForge_Constructor.exists()) {
+         this.itemModelMesher = (ItemModelMesher)Reflector.newInstance(Reflector.ItemModelMesherForge_Constructor, new Object[]{var2});
+      } else {
+         this.itemModelMesher = new ItemModelMesher(var2);
+      }
+
       this.registerItems();
       this.itemColors = var3;
    }
 
    public ItemModelMesher getItemModelMesher() {
       return this.itemModelMesher;
@@ -91,97 +99,166 @@
    }
 
    private void renderModel(IBakedModel var1, ItemStack var2) {
       this.renderModel(var1, -1, var2);
    }
 
-   private void renderModel(IBakedModel var1, int var2) {
+   public void renderModel(IBakedModel var1, int var2) {
       this.renderModel(var1, var2, ItemStack.EMPTY);
    }
 
    private void renderModel(IBakedModel var1, int var2, ItemStack var3) {
       Tessellator var4 = Tessellator.getInstance();
       BufferBuilder var5 = var4.getBuffer();
+      boolean var6 = Minecraft.getMinecraft().getTextureMapBlocks().isTextureBound();
+      boolean var7 = Config.isMultiTexture() && var6;
+      if (var7) {
+         var5.setBlockLayer(BlockRenderLayer.SOLID);
+      }
+
       var5.begin(7, DefaultVertexFormats.ITEM);
 
-      for (EnumFacing var9 : EnumFacing.values()) {
-         this.renderQuads(var5, var1.getQuads(null, var9, 0L), var2, var3);
+      for (EnumFacing var11 : EnumFacing.VALUES) {
+         this.renderQuads(var5, var1.getQuads((IBlockState)null, var11, 0L), var2, var3);
       }
 
-      this.renderQuads(var5, var1.getQuads(null, null, 0L), var2, var3);
+      this.renderQuads(var5, var1.getQuads((IBlockState)null, (EnumFacing)null, 0L), var2, var3);
       var4.draw();
+      if (var7) {
+         var5.setBlockLayer(null);
+         GlStateManager.bindCurrentTexture();
+      }
    }
 
    public void renderItem(ItemStack var1, IBakedModel var2) {
       if (!var1.isEmpty()) {
          GlStateManager.pushMatrix();
          GlStateManager.translate(-0.5F, -0.5F, -0.5F);
          if (var2.isBuiltInRenderer()) {
             GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
             GlStateManager.enableRescaleNormal();
-            TileEntityItemStackRenderer.instance.renderByItem(var1);
+            if (Reflector.ForgeItem_getTileEntityItemStackRenderer.exists()) {
+               TileEntityItemStackRenderer var5 = (TileEntityItemStackRenderer)Reflector.call(
+                  var1.getItem(), Reflector.ForgeItem_getTileEntityItemStackRenderer, new Object[0]
+               );
+               var5.renderByItem(var1);
+            } else {
+               TileEntityItemStackRenderer.instance.renderByItem(var1);
+            }
          } else {
+            if (Config.isCustomItems()) {
+               var2 = CustomItems.getCustomItemModel(var1, var2, this.modelLocation, false);
+               this.modelLocation = null;
+            }
+
+            this.renderModelHasEmissive = false;
             this.renderModel(var2, var1);
-            if (var1.hasEffect()) {
+            if (this.renderModelHasEmissive) {
+               float var3 = OpenGlHelper.lastBrightnessX;
+               float var4 = OpenGlHelper.lastBrightnessY;
+               OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240.0F, var4);
+               this.renderModelEmissive = true;
+               this.renderModel(var2, var1);
+               this.renderModelEmissive = false;
+               OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, var3, var4);
+            }
+
+            if (var1.hasEffect() && (!Config.isCustomItems() || !CustomItems.renderCustomEffect(this, var1, var2))) {
                this.renderEffect(var2);
             }
          }
 
          GlStateManager.popMatrix();
       }
    }
 
    private void renderEffect(IBakedModel var1) {
-      GlStateManager.depthMask(false);
-      GlStateManager.depthFunc(514);
-      GlStateManager.disableLighting();
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
-      this.textureManager.bindTexture(RES_ITEM_GLINT);
-      GlStateManager.matrixMode(5890);
-      GlStateManager.pushMatrix();
-      GlStateManager.scale(8.0F, 8.0F, 8.0F);
-      float var2 = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F / 8.0F;
-      GlStateManager.translate(var2, 0.0F, 0.0F);
-      GlStateManager.rotate(-50.0F, 0.0F, 0.0F, 1.0F);
-      this.renderModel(var1, -8372020);
-      GlStateManager.popMatrix();
-      GlStateManager.pushMatrix();
-      GlStateManager.scale(8.0F, 8.0F, 8.0F);
-      float var3 = (float)(Minecraft.getSystemTime() % 4873L) / 4873.0F / 8.0F;
-      GlStateManager.translate(-var3, 0.0F, 0.0F);
-      GlStateManager.rotate(10.0F, 0.0F, 0.0F, 1.0F);
-      this.renderModel(var1, -8372020);
-      GlStateManager.popMatrix();
-      GlStateManager.matrixMode(5888);
-      GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
-      GlStateManager.enableLighting();
-      GlStateManager.depthFunc(515);
-      GlStateManager.depthMask(true);
-      this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+      if (!Config.isCustomItems() || CustomItems.isUseGlint()) {
+         if (!Config.isShaders() || !Shaders.isShadowPass) {
+            GlStateManager.depthMask(false);
+            GlStateManager.depthFunc(514);
+            GlStateManager.disableLighting();
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
+            this.textureManager.bindTexture(RES_ITEM_GLINT);
+            if (Config.isShaders() && !this.renderItemGui) {
+               ShadersRender.renderEnchantedGlintBegin();
+            }
+
+            GlStateManager.matrixMode(5890);
+            GlStateManager.pushMatrix();
+            GlStateManager.scale(8.0F, 8.0F, 8.0F);
+            float var2 = (float)(Minecraft.getSystemTime() % 3000L) / 3000.0F / 8.0F;
+            GlStateManager.translate(var2, 0.0F, 0.0F);
+            GlStateManager.rotate(-50.0F, 0.0F, 0.0F, 1.0F);
+            this.renderModel(var1, -8372020);
+            GlStateManager.popMatrix();
+            GlStateManager.pushMatrix();
+            GlStateManager.scale(8.0F, 8.0F, 8.0F);
+            float var3 = (float)(Minecraft.getSystemTime() % 4873L) / 4873.0F / 8.0F;
+            GlStateManager.translate(-var3, 0.0F, 0.0F);
+            GlStateManager.rotate(10.0F, 0.0F, 0.0F, 1.0F);
+            this.renderModel(var1, -8372020);
+            GlStateManager.popMatrix();
+            GlStateManager.matrixMode(5888);
+            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
+            GlStateManager.enableLighting();
+            GlStateManager.depthFunc(515);
+            GlStateManager.depthMask(true);
+            this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+            if (Config.isShaders() && !this.renderItemGui) {
+               ShadersRender.renderEnchantedGlintEnd();
+            }
+         }
+      }
    }
 
    private void putQuadNormal(BufferBuilder var1, BakedQuad var2) {
       Vec3i var3 = var2.getFace().getDirectionVec();
       var1.putNormal(var3.getX(), var3.getY(), var3.getZ());
    }
 
    private void renderQuad(BufferBuilder var1, BakedQuad var2, int var3) {
-      var1.addVertexData(var2.getVertexData());
-      var1.putColor4(var3);
+      if (this.renderModelEmissive) {
+         if (var2.getQuadEmissive() == null) {
+            return;
+         }
+
+         var2 = var2.getQuadEmissive();
+      } else if (var2.getQuadEmissive() != null) {
+         this.renderModelHasEmissive = true;
+      }
+
+      if (var1.isMultiTexture()) {
+         var1.addVertexData(var2.getVertexDataSingle());
+      } else {
+         var1.addVertexData(var2.getVertexData());
+      }
+
+      var1.putSprite(var2.getSprite());
+      if (Reflector.ForgeHooksClient_putQuadColor.exists()) {
+         Reflector.call(Reflector.ForgeHooksClient_putQuadColor, new Object[]{var1, var2, var3});
+      } else {
+         var1.putColor4(var3);
+      }
+
       this.putQuadNormal(var1, var2);
    }
 
    private void renderQuads(BufferBuilder var1, List<BakedQuad> var2, int var3, ItemStack var4) {
       boolean var5 = var3 == -1 && !var4.isEmpty();
       int var6 = 0;
 
       for (int var7 = var2.size(); var6 < var7; var6++) {
          BakedQuad var8 = (BakedQuad)var2.get(var6);
          int var9 = var3;
          if (var5 && var8.hasTintIndex()) {
             var9 = this.itemColors.colorMultiplier(var4, var8.getTintIndex());
+            if (Config.isCustomColors()) {
+               var9 = CustomColors.getColorFromItemStack(var4, var8.getTintIndex(), var9);
+            }
+
             if (EntityRenderer.anaglyphEnable) {
                var9 = TextureUtil.anaglyphColor(var9);
             }
 
             var9 |= -16777216;
          }
@@ -192,38 +269,51 @@
 
    public boolean shouldRenderItemIn3D(ItemStack var1) {
       IBakedModel var2 = this.itemModelMesher.getItemModel(var1);
       return var2 == null ? false : var2.isGui3d();
    }
 
-   public void renderItem(ItemStack var1, ItemCameraTransforms.TransformType var2) {
+   public void renderItem(ItemStack var1, TransformType var2) {
       if (!var1.isEmpty()) {
-         IBakedModel var3 = this.getItemModelWithOverrides(var1, null, null);
+         IBakedModel var3 = this.getItemModelWithOverrides(var1, (World)null, (EntityLivingBase)null);
          this.renderItemModel(var1, var3, var2, false);
       }
    }
 
    public IBakedModel getItemModelWithOverrides(ItemStack var1, @Nullable World var2, @Nullable EntityLivingBase var3) {
       IBakedModel var4 = this.itemModelMesher.getItemModel(var1);
       Item var5 = var1.getItem();
-      if (var5 != null && var5.hasCustomProperties()) {
-         ResourceLocation var6 = var4.getOverrides().applyOverride(var1, var2, var3);
-         return var6 == null ? var4 : this.itemModelMesher.getModelManager().getModel(new ModelResourceLocation(var6, "inventory"));
+      if (Config.isCustomItems()) {
+         if (var5 != null && var5.hasCustomProperties()) {
+            this.modelLocation = var4.getOverrides().applyOverride(var1, var2, var3);
+         }
+
+         IBakedModel var6 = CustomItems.getCustomItemModel(var1, var4, this.modelLocation, true);
+         if (var6 != var4) {
+            return var6;
+         }
+      }
+
+      if (Reflector.ModelLoader_getInventoryVariant.exists()) {
+         return var4.getOverrides().handleItemState(var4, var1, var2, var3);
+      } else if (var5 != null && var5.hasCustomProperties()) {
+         ResourceLocation var7 = var4.getOverrides().applyOverride(var1, var2, var3);
+         return var7 == null ? var4 : this.itemModelMesher.getModelManager().getModel(new ModelResourceLocation(var7, "inventory"));
       } else {
          return var4;
       }
    }
 
-   public void renderItem(ItemStack var1, EntityLivingBase var2, ItemCameraTransforms.TransformType var3, boolean var4) {
+   public void renderItem(ItemStack var1, EntityLivingBase var2, TransformType var3, boolean var4) {
       if (!var1.isEmpty() && var2 != null) {
          IBakedModel var5 = this.getItemModelWithOverrides(var1, var2.world, var2);
          this.renderItemModel(var1, var5, var3, var4);
       }
    }
 
-   protected void renderItemModel(ItemStack var1, IBakedModel var2, ItemCameraTransforms.TransformType var3, boolean var4) {
+   protected void renderItemModel(ItemStack var1, IBakedModel var2, TransformType var3, boolean var4) {
       if (!var1.isEmpty()) {
          this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
          this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
          GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
          GlStateManager.enableRescaleNormal();
          GlStateManager.alphaFunc(516, 0.1F);
@@ -232,19 +322,25 @@
             GlStateManager.SourceFactor.SRC_ALPHA,
             GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
             GlStateManager.SourceFactor.ONE,
             GlStateManager.DestFactor.ZERO
          );
          GlStateManager.pushMatrix();
-         ItemCameraTransforms var5 = var2.getItemCameraTransforms();
-         ItemCameraTransforms.applyTransformSide(var5.getTransform(var3), var4);
-         if (this.isThereOneNegativeScale(var5.getTransform(var3))) {
-            GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
+         if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
+            var2 = (IBakedModel)Reflector.call(Reflector.ForgeHooksClient_handleCameraTransforms, new Object[]{var2, var3, var4});
+         } else {
+            ItemCameraTransforms var5 = var2.getItemCameraTransforms();
+            ItemCameraTransforms.applyTransformSide(var5.getTransform(var3), var4);
+            if (this.isThereOneNegativeScale(var5.getTransform(var3))) {
+               GlStateManager.cullFace(GlStateManager.CullFace.FRONT);
+            }
          }
 
+         CustomItems.setRenderOffHand(var4);
          this.renderItem(var1, var2);
+         CustomItems.setRenderOffHand(false);
          GlStateManager.cullFace(GlStateManager.CullFace.BACK);
          GlStateManager.popMatrix();
          GlStateManager.disableRescaleNormal();
          GlStateManager.disableBlend();
          this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
          this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
@@ -253,34 +349,41 @@
 
    private boolean isThereOneNegativeScale(ItemTransformVec3f var1) {
       return var1.scale.x < 0.0F ^ var1.scale.y < 0.0F ^ var1.scale.z < 0.0F;
    }
 
    public void renderItemIntoGUI(ItemStack var1, int var2, int var3) {
-      this.renderItemModelIntoGUI(var1, var2, var3, this.getItemModelWithOverrides(var1, null, null));
+      this.renderItemModelIntoGUI(var1, var2, var3, this.getItemModelWithOverrides(var1, (World)null, (EntityLivingBase)null));
    }
 
    protected void renderItemModelIntoGUI(ItemStack var1, int var2, int var3, IBakedModel var4) {
+      this.renderItemGui = true;
       GlStateManager.pushMatrix();
       this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).setBlurMipmap(false, false);
       GlStateManager.enableRescaleNormal();
       GlStateManager.enableAlpha();
       GlStateManager.alphaFunc(516, 0.1F);
       GlStateManager.enableBlend();
       GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
       GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
       this.setupGuiTransform(var2, var3, var4.isGui3d());
-      var4.getItemCameraTransforms().applyTransform(ItemCameraTransforms.TransformType.GUI);
+      if (Reflector.ForgeHooksClient_handleCameraTransforms.exists()) {
+         var4 = (IBakedModel)Reflector.call(Reflector.ForgeHooksClient_handleCameraTransforms, new Object[]{var4, TransformType.GUI, false});
+      } else {
+         var4.getItemCameraTransforms().applyTransform(TransformType.GUI);
+      }
+
       this.renderItem(var1, var4);
       GlStateManager.disableAlpha();
       GlStateManager.disableRescaleNormal();
       GlStateManager.disableLighting();
       GlStateManager.popMatrix();
       this.textureManager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
       this.textureManager.getTexture(TextureMap.LOCATION_BLOCKS_TEXTURE).restoreLastBlurMipmap();
+      this.renderItemGui = false;
    }
 
    private void setupGuiTransform(int var1, int var2, boolean var3) {
       GlStateManager.translate((float)var1, (float)var2, 100.0F + this.zLevel);
       GlStateManager.translate(8.0F, 8.0F, 0.0F);
       GlStateManager.scale(1.0F, -1.0F, 1.0F);
@@ -298,21 +401,25 @@
 
    public void renderItemAndEffectIntoGUI(@Nullable EntityLivingBase var1, final ItemStack var2, int var3, int var4) {
       if (!var2.isEmpty()) {
          this.zLevel += 50.0F;
 
          try {
-            this.renderItemModelIntoGUI(var2, var3, var4, this.getItemModelWithOverrides(var2, null, var1));
+            this.renderItemModelIntoGUI(var2, var3, var4, this.getItemModelWithOverrides(var2, (World)null, var1));
          } catch (Throwable var8) {
             CrashReport var6 = CrashReport.makeCrashReport(var8, "Rendering item");
             CrashReportCategory var7 = var6.makeCategory("Item being rendered");
             var7.addDetail("Item Type", new ICrashReportDetail<String>() {
                public String call() throws Exception {
                   return String.valueOf(var2.getItem());
                }
             });
+            if (Reflector.IForgeRegistryEntry_Impl_getRegistryName.exists()) {
+               var7.addDetail("Registry Name", ReflectorForge.getDetailItemRegistryName(var2.getItem()));
+            }
+
             var7.addDetail("Item Aux", new ICrashReportDetail<String>() {
                public String call() throws Exception {
                   return String.valueOf(var2.getMetadata());
                }
             });
             var7.addDetail("Item NBT", new ICrashReportDetail<String>() {
@@ -330,58 +437,81 @@
 
          this.zLevel -= 50.0F;
       }
    }
 
    public void renderItemOverlays(FontRenderer var1, ItemStack var2, int var3, int var4) {
-      this.renderItemOverlayIntoGUI(var1, var2, var3, var4, null);
+      this.renderItemOverlayIntoGUI(var1, var2, var3, var4, (String)null);
    }
 
    public void renderItemOverlayIntoGUI(FontRenderer var1, ItemStack var2, int var3, int var4, @Nullable String var5) {
       if (!var2.isEmpty()) {
          if (var2.getCount() != 1 || var5 != null) {
             String var6 = var5 == null ? String.valueOf(var2.getCount()) : var5;
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableBlend();
             var1.drawStringWithShadow(var6, var3 + 19 - 2 - var1.getStringWidth(var6), var4 + 6 + 3, 16777215);
             GlStateManager.enableLighting();
             GlStateManager.enableDepth();
+            GlStateManager.enableBlend();
          }
 
-         if (var2.isItemDamaged()) {
+         if (ReflectorForge.isItemDamaged(var2)) {
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableTexture2D();
             GlStateManager.disableAlpha();
             GlStateManager.disableBlend();
-            Tessellator var13 = Tessellator.getInstance();
-            BufferBuilder var7 = var13.getBuffer();
+            Tessellator var16 = Tessellator.getInstance();
+            BufferBuilder var7 = var16.getBuffer();
             float var8 = var2.getItemDamage();
             float var9 = var2.getMaxDamage();
             float var10 = Math.max(0.0F, (var9 - var8) / var9);
             int var11 = Math.round(13.0F - var8 * 13.0F / var9);
             int var12 = MathHelper.hsvToRGB(var10 / 3.0F, 1.0F, 1.0F);
+            if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
+               double var13 = Reflector.callDouble(var2.getItem(), Reflector.ForgeItem_getDurabilityForDisplay, new Object[]{var2});
+               int var15 = Reflector.callInt(var2.getItem(), Reflector.ForgeItem_getRGBDurabilityForDisplay, new Object[]{var2});
+               var11 = Math.round(13.0F - (float)var13 * 13.0F);
+               var12 = var15;
+            }
+
+            if (Config.isCustomColors()) {
+               var12 = CustomColors.getDurabilityColor(var10, var12);
+            }
+
+            if (Reflector.ForgeItem_getDurabilityForDisplay.exists() && Reflector.ForgeItem_getRGBDurabilityForDisplay.exists()) {
+               double var21 = Reflector.callDouble(var2.getItem(), Reflector.ForgeItem_getDurabilityForDisplay, new Object[]{var2});
+               int var22 = Reflector.callInt(var2.getItem(), Reflector.ForgeItem_getRGBDurabilityForDisplay, new Object[]{var2});
+               var11 = Math.round(13.0F - (float)var21 * 13.0F);
+               var12 = var22;
+            }
+
+            if (Config.isCustomColors()) {
+               var12 = CustomColors.getDurabilityColor(var10, var12);
+            }
+
             this.draw(var7, var3 + 2, var4 + 13, 13, 2, 0, 0, 0, 255);
             this.draw(var7, var3 + 2, var4 + 13, var11, 1, var12 >> 16 & 0xFF, var12 >> 8 & 0xFF, var12 & 0xFF, 255);
             GlStateManager.enableBlend();
             GlStateManager.enableAlpha();
             GlStateManager.enableTexture2D();
             GlStateManager.enableLighting();
             GlStateManager.enableDepth();
          }
 
-         EntityPlayerSP var14 = Minecraft.getMinecraft().player;
-         float var15 = var14 == null ? 0.0F : var14.getCooldownTracker().getCooldown(var2.getItem(), Minecraft.getMinecraft().getRenderPartialTicks());
-         if (var15 > 0.0F) {
+         EntityPlayerSP var17 = Minecraft.getMinecraft().player;
+         float var18 = var17 == null ? 0.0F : var17.getCooldownTracker().getCooldown(var2.getItem(), Minecraft.getMinecraft().getRenderPartialTicks());
+         if (var18 > 0.0F) {
             GlStateManager.disableLighting();
             GlStateManager.disableDepth();
             GlStateManager.disableTexture2D();
-            Tessellator var16 = Tessellator.getInstance();
-            BufferBuilder var17 = var16.getBuffer();
-            this.draw(var17, var3, var4 + MathHelper.floor(16.0F * (1.0F - var15)), 16, MathHelper.ceil(16.0F * var15), 255, 255, 255, 127);
+            Tessellator var19 = Tessellator.getInstance();
+            BufferBuilder var20 = var19.getBuffer();
+            this.draw(var20, var3, var4 + MathHelper.floor(16.0F * (1.0F - var18)), 16, MathHelper.ceil(16.0F * var18), 255, 255, 255, 127);
             GlStateManager.enableTexture2D();
             GlStateManager.enableLighting();
             GlStateManager.enableDepth();
          }
       }
    }
@@ -412,76 +542,76 @@
       this.registerBlock(Blocks.CARPET, EnumDyeColor.PINK.getMetadata(), "pink_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.PURPLE.getMetadata(), "purple_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.RED.getMetadata(), "red_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.SILVER.getMetadata(), "silver_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.WHITE.getMetadata(), "white_carpet");
       this.registerBlock(Blocks.CARPET, EnumDyeColor.YELLOW.getMetadata(), "yellow_carpet");
-      this.registerBlock(Blocks.COBBLESTONE_WALL, BlockWall.EnumType.MOSSY.getMetadata(), "mossy_cobblestone_wall");
-      this.registerBlock(Blocks.COBBLESTONE_WALL, BlockWall.EnumType.NORMAL.getMetadata(), "cobblestone_wall");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.COARSE_DIRT.getMetadata(), "coarse_dirt");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.DIRT.getMetadata(), "dirt");
-      this.registerBlock(Blocks.DIRT, BlockDirt.DirtType.PODZOL.getMetadata(), "podzol");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.FERN.getMeta(), "double_fern");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.GRASS.getMeta(), "double_grass");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.PAEONIA.getMeta(), "paeonia");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.ROSE.getMeta(), "double_rose");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.SUNFLOWER.getMeta(), "sunflower");
-      this.registerBlock(Blocks.DOUBLE_PLANT, BlockDoublePlant.EnumPlantType.SYRINGA.getMeta(), "syringa");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.OAK.getMetadata(), "oak_leaves");
-      this.registerBlock(Blocks.LEAVES, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_leaves");
-      this.registerBlock(Blocks.LEAVES2, BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_leaves");
-      this.registerBlock(Blocks.LEAVES2, BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_leaves");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.OAK.getMetadata(), "oak_log");
-      this.registerBlock(Blocks.LOG, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_log");
-      this.registerBlock(Blocks.LOG2, BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_log");
-      this.registerBlock(Blocks.LOG2, BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_log");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.CHISELED_STONEBRICK.getMetadata(), "chiseled_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.COBBLESTONE.getMetadata(), "cobblestone_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.CRACKED_STONEBRICK.getMetadata(), "cracked_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.MOSSY_STONEBRICK.getMetadata(), "mossy_brick_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.STONE.getMetadata(), "stone_monster_egg");
-      this.registerBlock(Blocks.MONSTER_EGG, BlockSilverfish.EnumType.STONEBRICK.getMetadata(), "stone_brick_monster_egg");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.OAK.getMetadata(), "oak_planks");
-      this.registerBlock(Blocks.PLANKS, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_planks");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.BRICKS.getMetadata(), "prismarine_bricks");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.DARK.getMetadata(), "dark_prismarine");
-      this.registerBlock(Blocks.PRISMARINE, BlockPrismarine.EnumType.ROUGH.getMetadata(), "prismarine");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.CHISELED.getMetadata(), "chiseled_quartz_block");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.DEFAULT.getMetadata(), "quartz_block");
-      this.registerBlock(Blocks.QUARTZ_BLOCK, BlockQuartz.EnumType.LINES_Y.getMetadata(), "quartz_column");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.ALLIUM.getMeta(), "allium");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.BLUE_ORCHID.getMeta(), "blue_orchid");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.HOUSTONIA.getMeta(), "houstonia");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.ORANGE_TULIP.getMeta(), "orange_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.OXEYE_DAISY.getMeta(), "oxeye_daisy");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.PINK_TULIP.getMeta(), "pink_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.POPPY.getMeta(), "poppy");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.RED_TULIP.getMeta(), "red_tulip");
-      this.registerBlock(Blocks.RED_FLOWER, BlockFlower.EnumFlowerType.WHITE_TULIP.getMeta(), "white_tulip");
-      this.registerBlock(Blocks.SAND, BlockSand.EnumType.RED_SAND.getMetadata(), "red_sand");
-      this.registerBlock(Blocks.SAND, BlockSand.EnumType.SAND.getMetadata(), "sand");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.CHISELED.getMetadata(), "chiseled_sandstone");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.DEFAULT.getMetadata(), "sandstone");
-      this.registerBlock(Blocks.SANDSTONE, BlockSandStone.EnumType.SMOOTH.getMetadata(), "smooth_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.CHISELED.getMetadata(), "chiseled_red_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.DEFAULT.getMetadata(), "red_sandstone");
-      this.registerBlock(Blocks.RED_SANDSTONE, BlockRedSandstone.EnumType.SMOOTH.getMetadata(), "smooth_red_sandstone");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.OAK.getMetadata(), "oak_sapling");
-      this.registerBlock(Blocks.SAPLING, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_sapling");
+      this.registerBlock(Blocks.COBBLESTONE_WALL, EnumType.MOSSY.getMetadata(), "mossy_cobblestone_wall");
+      this.registerBlock(Blocks.COBBLESTONE_WALL, EnumType.NORMAL.getMetadata(), "cobblestone_wall");
+      this.registerBlock(Blocks.DIRT, DirtType.COARSE_DIRT.getMetadata(), "coarse_dirt");
+      this.registerBlock(Blocks.DIRT, DirtType.DIRT.getMetadata(), "dirt");
+      this.registerBlock(Blocks.DIRT, DirtType.PODZOL.getMetadata(), "podzol");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.FERN.getMeta(), "double_fern");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.GRASS.getMeta(), "double_grass");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.PAEONIA.getMeta(), "paeonia");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.ROSE.getMeta(), "double_rose");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.SUNFLOWER.getMeta(), "sunflower");
+      this.registerBlock(Blocks.DOUBLE_PLANT, EnumPlantType.SYRINGA.getMeta(), "syringa");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_leaves");
+      this.registerBlock(Blocks.LEAVES, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_leaves");
+      this.registerBlock(Blocks.LEAVES2, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_leaves");
+      this.registerBlock(Blocks.LEAVES2, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_leaves");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_log");
+      this.registerBlock(Blocks.LOG, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_log");
+      this.registerBlock(Blocks.LOG2, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata() - 4, "acacia_log");
+      this.registerBlock(Blocks.LOG2, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata() - 4, "dark_oak_log");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.CHISELED_STONEBRICK.getMetadata(), "chiseled_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.COBBLESTONE.getMetadata(), "cobblestone_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.CRACKED_STONEBRICK.getMetadata(), "cracked_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.MOSSY_STONEBRICK.getMetadata(), "mossy_brick_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.STONE.getMetadata(), "stone_monster_egg");
+      this.registerBlock(Blocks.MONSTER_EGG, net.minecraft.block.BlockSilverfish.EnumType.STONEBRICK.getMetadata(), "stone_brick_monster_egg");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_planks");
+      this.registerBlock(Blocks.PLANKS, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_planks");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.BRICKS.getMetadata(), "prismarine_bricks");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.DARK.getMetadata(), "dark_prismarine");
+      this.registerBlock(Blocks.PRISMARINE, net.minecraft.block.BlockPrismarine.EnumType.ROUGH.getMetadata(), "prismarine");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.CHISELED.getMetadata(), "chiseled_quartz_block");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.DEFAULT.getMetadata(), "quartz_block");
+      this.registerBlock(Blocks.QUARTZ_BLOCK, net.minecraft.block.BlockQuartz.EnumType.LINES_Y.getMetadata(), "quartz_column");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.ALLIUM.getMeta(), "allium");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.BLUE_ORCHID.getMeta(), "blue_orchid");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.HOUSTONIA.getMeta(), "houstonia");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.ORANGE_TULIP.getMeta(), "orange_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.OXEYE_DAISY.getMeta(), "oxeye_daisy");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.PINK_TULIP.getMeta(), "pink_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.POPPY.getMeta(), "poppy");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.RED_TULIP.getMeta(), "red_tulip");
+      this.registerBlock(Blocks.RED_FLOWER, EnumFlowerType.WHITE_TULIP.getMeta(), "white_tulip");
+      this.registerBlock(Blocks.SAND, net.minecraft.block.BlockSand.EnumType.RED_SAND.getMetadata(), "red_sand");
+      this.registerBlock(Blocks.SAND, net.minecraft.block.BlockSand.EnumType.SAND.getMetadata(), "sand");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.CHISELED.getMetadata(), "chiseled_sandstone");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.DEFAULT.getMetadata(), "sandstone");
+      this.registerBlock(Blocks.SANDSTONE, net.minecraft.block.BlockSandStone.EnumType.SMOOTH.getMetadata(), "smooth_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.CHISELED.getMetadata(), "chiseled_red_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.DEFAULT.getMetadata(), "red_sandstone");
+      this.registerBlock(Blocks.RED_SANDSTONE, net.minecraft.block.BlockRedSandstone.EnumType.SMOOTH.getMetadata(), "smooth_red_sandstone");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_sapling");
+      this.registerBlock(Blocks.SAPLING, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_sapling");
       this.registerBlock(Blocks.SPONGE, 0, "sponge");
       this.registerBlock(Blocks.SPONGE, 1, "sponge_wet");
       this.registerBlock(Blocks.STAINED_GLASS, EnumDyeColor.BLACK.getMetadata(), "black_stained_glass");
       this.registerBlock(Blocks.STAINED_GLASS, EnumDyeColor.BLUE.getMetadata(), "blue_stained_glass");
       this.registerBlock(Blocks.STAINED_GLASS, EnumDyeColor.BROWN.getMetadata(), "brown_stained_glass");
       this.registerBlock(Blocks.STAINED_GLASS, EnumDyeColor.CYAN.getMetadata(), "cyan_stained_glass");
@@ -526,41 +656,41 @@
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.PINK.getMetadata(), "pink_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.PURPLE.getMetadata(), "purple_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.RED.getMetadata(), "red_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.SILVER.getMetadata(), "silver_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.WHITE.getMetadata(), "white_stained_hardened_clay");
       this.registerBlock(Blocks.STAINED_HARDENED_CLAY, EnumDyeColor.YELLOW.getMetadata(), "yellow_stained_hardened_clay");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.ANDESITE.getMetadata(), "andesite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.ANDESITE_SMOOTH.getMetadata(), "andesite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.DIORITE.getMetadata(), "diorite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.DIORITE_SMOOTH.getMetadata(), "diorite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.GRANITE.getMetadata(), "granite");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.GRANITE_SMOOTH.getMetadata(), "granite_smooth");
-      this.registerBlock(Blocks.STONE, BlockStone.EnumType.STONE.getMetadata(), "stone");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.CRACKED.getMetadata(), "cracked_stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.DEFAULT.getMetadata(), "stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.CHISELED.getMetadata(), "chiseled_stonebrick");
-      this.registerBlock(Blocks.STONEBRICK, BlockStoneBrick.EnumType.MOSSY.getMetadata(), "mossy_stonebrick");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.BRICK.getMetadata(), "brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.COBBLESTONE.getMetadata(), "cobblestone_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.WOOD.getMetadata(), "old_wood_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.NETHERBRICK.getMetadata(), "nether_brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.QUARTZ.getMetadata(), "quartz_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.SAND.getMetadata(), "sandstone_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.SMOOTHBRICK.getMetadata(), "stone_brick_slab");
-      this.registerBlock(Blocks.STONE_SLAB, BlockStoneSlab.EnumType.STONE.getMetadata(), "stone_slab");
-      this.registerBlock(Blocks.STONE_SLAB2, BlockStoneSlabNew.EnumType.RED_SANDSTONE.getMetadata(), "red_sandstone_slab");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.DEAD_BUSH.getMeta(), "dead_bush");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.FERN.getMeta(), "fern");
-      this.registerBlock(Blocks.TALLGRASS, BlockTallGrass.EnumType.GRASS.getMeta(), "tall_grass");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.OAK.getMetadata(), "oak_slab");
-      this.registerBlock(Blocks.WOODEN_SLAB, BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_slab");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.ANDESITE.getMetadata(), "andesite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.ANDESITE_SMOOTH.getMetadata(), "andesite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.DIORITE.getMetadata(), "diorite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.DIORITE_SMOOTH.getMetadata(), "diorite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.GRANITE.getMetadata(), "granite");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.GRANITE_SMOOTH.getMetadata(), "granite_smooth");
+      this.registerBlock(Blocks.STONE, net.minecraft.block.BlockStone.EnumType.STONE.getMetadata(), "stone");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.CRACKED.getMetadata(), "cracked_stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.DEFAULT.getMetadata(), "stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.CHISELED.getMetadata(), "chiseled_stonebrick");
+      this.registerBlock(Blocks.STONEBRICK, net.minecraft.block.BlockStoneBrick.EnumType.MOSSY.getMetadata(), "mossy_stonebrick");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.BRICK.getMetadata(), "brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.COBBLESTONE.getMetadata(), "cobblestone_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.WOOD.getMetadata(), "old_wood_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.NETHERBRICK.getMetadata(), "nether_brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.QUARTZ.getMetadata(), "quartz_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.SAND.getMetadata(), "sandstone_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.SMOOTHBRICK.getMetadata(), "stone_brick_slab");
+      this.registerBlock(Blocks.STONE_SLAB, net.minecraft.block.BlockStoneSlab.EnumType.STONE.getMetadata(), "stone_slab");
+      this.registerBlock(Blocks.STONE_SLAB2, net.minecraft.block.BlockStoneSlabNew.EnumType.RED_SANDSTONE.getMetadata(), "red_sandstone_slab");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.DEAD_BUSH.getMeta(), "dead_bush");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.FERN.getMeta(), "fern");
+      this.registerBlock(Blocks.TALLGRASS, net.minecraft.block.BlockTallGrass.EnumType.GRASS.getMeta(), "tall_grass");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.ACACIA.getMetadata(), "acacia_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.BIRCH.getMetadata(), "birch_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.DARK_OAK.getMetadata(), "dark_oak_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.JUNGLE.getMetadata(), "jungle_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.OAK.getMetadata(), "oak_slab");
+      this.registerBlock(Blocks.WOODEN_SLAB, net.minecraft.block.BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce_slab");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BLACK.getMetadata(), "black_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BLUE.getMetadata(), "blue_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.BROWN.getMetadata(), "brown_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.CYAN.getMetadata(), "cyan_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.GRAY.getMetadata(), "gray_wool");
       this.registerBlock(Blocks.WOOL, EnumDyeColor.GREEN.getMetadata(), "green_wool");
@@ -683,13 +813,13 @@
       this.registerBlock(Blocks.TRIPWIRE_HOOK, "tripwire_hook");
       this.registerBlock(Blocks.VINE, "vine");
       this.registerBlock(Blocks.WATERLILY, "waterlily");
       this.registerBlock(Blocks.WEB, "web");
       this.registerBlock(Blocks.WOODEN_BUTTON, "wooden_button");
       this.registerBlock(Blocks.WOODEN_PRESSURE_PLATE, "wooden_pressure_plate");
-      this.registerBlock(Blocks.YELLOW_FLOWER, BlockFlower.EnumFlowerType.DANDELION.getMeta(), "dandelion");
+      this.registerBlock(Blocks.YELLOW_FLOWER, EnumFlowerType.DANDELION.getMeta(), "dandelion");
       this.registerBlock(Blocks.END_ROD, "end_rod");
       this.registerBlock(Blocks.CHORUS_PLANT, "chorus_plant");
       this.registerBlock(Blocks.CHORUS_FLOWER, "chorus_flower");
       this.registerBlock(Blocks.PURPUR_BLOCK, "purpur_block");
       this.registerBlock(Blocks.PURPUR_PILLAR, "purpur_pillar");
       this.registerBlock(Blocks.PURPUR_STAIRS, "purpur_stairs");
@@ -847,18 +977,18 @@
       this.registerItem(Items.FURNACE_MINECART, "furnace_minecart");
       this.registerItem(Items.EGG, "egg");
       this.registerItem(Items.COMPASS, "compass");
       this.registerItem(Items.FISHING_ROD, "fishing_rod");
       this.registerItem(Items.CLOCK, "clock");
       this.registerItem(Items.GLOWSTONE_DUST, "glowstone_dust");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.COD.getMetadata(), "cod");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.SALMON.getMetadata(), "salmon");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.CLOWNFISH.getMetadata(), "clownfish");
-      this.registerItem(Items.FISH, ItemFishFood.FishType.PUFFERFISH.getMetadata(), "pufferfish");
-      this.registerItem(Items.COOKED_FISH, ItemFishFood.FishType.COD.getMetadata(), "cooked_cod");
-      this.registerItem(Items.COOKED_FISH, ItemFishFood.FishType.SALMON.getMetadata(), "cooked_salmon");
+      this.registerItem(Items.FISH, FishType.COD.getMetadata(), "cod");
+      this.registerItem(Items.FISH, FishType.SALMON.getMetadata(), "salmon");
+      this.registerItem(Items.FISH, FishType.CLOWNFISH.getMetadata(), "clownfish");
+      this.registerItem(Items.FISH, FishType.PUFFERFISH.getMetadata(), "pufferfish");
+      this.registerItem(Items.COOKED_FISH, FishType.COD.getMetadata(), "cooked_cod");
+      this.registerItem(Items.COOKED_FISH, FishType.SALMON.getMetadata(), "cooked_salmon");
       this.registerItem(Items.DYE, EnumDyeColor.BLACK.getDyeDamage(), "dye_black");
       this.registerItem(Items.DYE, EnumDyeColor.RED.getDyeDamage(), "dye_red");
       this.registerItem(Items.DYE, EnumDyeColor.GREEN.getDyeDamage(), "dye_green");
       this.registerItem(Items.DYE, EnumDyeColor.BROWN.getDyeDamage(), "dye_brown");
       this.registerItem(Items.DYE, EnumDyeColor.BLUE.getDyeDamage(), "dye_blue");
       this.registerItem(Items.DYE, EnumDyeColor.PURPLE.getDyeDamage(), "dye_purple");
@@ -913,13 +1043,12 @@
       this.registerItem(Items.MAGMA_CREAM, "magma_cream");
       this.registerItem(Items.BREWING_STAND, "brewing_stand");
       this.registerItem(Items.CAULDRON, "cauldron");
       this.registerItem(Items.ENDER_EYE, "ender_eye");
       this.registerItem(Items.SPECKLED_MELON, "speckled_melon");
       this.itemModelMesher.register(Items.SPAWN_EGG, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("spawn_egg", "inventory");
          }
       });
       this.registerItem(Items.EXPERIENCE_BOTTLE, "experience_bottle");
       this.registerItem(Items.FIRE_CHARGE, "fire_charge");
@@ -953,25 +1082,22 @@
       this.registerItem(Items.IRON_HORSE_ARMOR, "iron_horse_armor");
       this.registerItem(Items.GOLDEN_HORSE_ARMOR, "golden_horse_armor");
       this.registerItem(Items.DIAMOND_HORSE_ARMOR, "diamond_horse_armor");
       this.registerItem(Items.LEAD, "lead");
       this.registerItem(Items.NAME_TAG, "name_tag");
       this.itemModelMesher.register(Items.BANNER, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("banner", "inventory");
          }
       });
       this.itemModelMesher.register(Items.BED, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("bed", "inventory");
          }
       });
       this.itemModelMesher.register(Items.SHIELD, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("shield", "inventory");
          }
       });
       this.registerItem(Items.ELYTRA, "elytra");
       this.registerItem(Items.CHORUS_FRUIT, "chorus_fruit");
@@ -991,39 +1117,39 @@
       this.registerItem(Items.RECORD_11, "record_11");
       this.registerItem(Items.RECORD_WAIT, "record_wait");
       this.registerItem(Items.PRISMARINE_SHARD, "prismarine_shard");
       this.registerItem(Items.PRISMARINE_CRYSTALS, "prismarine_crystals");
       this.registerItem(Items.KNOWLEDGE_BOOK, "knowledge_book");
       this.itemModelMesher.register(Items.ENCHANTED_BOOK, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("enchanted_book", "inventory");
          }
       });
       this.itemModelMesher.register(Items.FILLED_MAP, new ItemMeshDefinition() {
-         @Override
          public ModelResourceLocation getModelLocation(ItemStack var1) {
             return new ModelResourceLocation("filled_map", "inventory");
          }
       });
       this.registerBlock(Blocks.COMMAND_BLOCK, "command_block");
       this.registerItem(Items.FIREWORKS, "fireworks");
       this.registerItem(Items.COMMAND_BLOCK_MINECART, "command_block_minecart");
       this.registerBlock(Blocks.BARRIER, "barrier");
       this.registerBlock(Blocks.MOB_SPAWNER, "mob_spawner");
       this.registerItem(Items.WRITTEN_BOOK, "written_book");
-      this.registerBlock(Blocks.BROWN_MUSHROOM_BLOCK, BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "brown_mushroom_block");
-      this.registerBlock(Blocks.RED_MUSHROOM_BLOCK, BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "red_mushroom_block");
+      this.registerBlock(Blocks.BROWN_MUSHROOM_BLOCK, net.minecraft.block.BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "brown_mushroom_block");
+      this.registerBlock(Blocks.RED_MUSHROOM_BLOCK, net.minecraft.block.BlockHugeMushroom.EnumType.ALL_INSIDE.getMetadata(), "red_mushroom_block");
       this.registerBlock(Blocks.DRAGON_EGG, "dragon_egg");
       this.registerBlock(Blocks.REPEATING_COMMAND_BLOCK, "repeating_command_block");
       this.registerBlock(Blocks.CHAIN_COMMAND_BLOCK, "chain_command_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.SAVE.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.LOAD.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.CORNER.getModeId(), "structure_block");
-      this.registerBlock(Blocks.STRUCTURE_BLOCK, TileEntityStructure.Mode.DATA.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.SAVE.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.LOAD.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.CORNER.getModeId(), "structure_block");
+      this.registerBlock(Blocks.STRUCTURE_BLOCK, Mode.DATA.getModeId(), "structure_block");
+      if (Reflector.ModelLoader_onRegisterItems.exists()) {
+         Reflector.call(Reflector.ModelLoader_onRegisterItems, new Object[]{this.itemModelMesher});
+      }
    }
 
-   @Override
    public void onResourceManagerReload(IResourceManager var1) {
       this.itemModelMesher.rebuildCache();
    }
 }
--- net/minecraft/client/renderer/RenderList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/RenderList.java	Mon Aug 18 09:39:52 2025
@@ -1,23 +1,85 @@
 package net.minecraft.client.renderer;
 
+import java.nio.Buffer;
+import java.nio.IntBuffer;
 import net.minecraft.client.renderer.chunk.ListedRenderChunk;
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.util.BlockRenderLayer;
 
 public class RenderList extends ChunkRenderContainer {
+   private double viewEntityX;
+   private double viewEntityY;
+   private double viewEntityZ;
+   IntBuffer bufferLists = GLAllocation.createDirectIntBuffer(16);
+
    @Override
    public void renderChunkLayer(BlockRenderLayer var1) {
       if (this.initialized) {
-         for (RenderChunk var3 : this.renderChunks) {
-            ListedRenderChunk var4 = (ListedRenderChunk)var3;
-            GlStateManager.pushMatrix();
-            this.preRenderChunk(var3);
-            GlStateManager.callList(var4.getDisplayList(var1, var4.getCompiledChunk()));
-            GlStateManager.popMatrix();
+         if (!Config.isRenderRegions()) {
+            for (RenderChunk var9 : this.renderChunks) {
+               ListedRenderChunk var10 = (ListedRenderChunk)var9;
+               GlStateManager.pushMatrix();
+               this.preRenderChunk(var9);
+               GlStateManager.callList(var10.getDisplayList(var1, var10.h()));
+               GlStateManager.popMatrix();
+            }
+         } else {
+            int var2 = Integer.MIN_VALUE;
+            int var3 = Integer.MIN_VALUE;
+
+            for (RenderChunk var5 : this.renderChunks) {
+               ListedRenderChunk var6 = (ListedRenderChunk)var5;
+               if (var2 != var5.regionX || var3 != var5.regionZ) {
+                  if (this.bufferLists.position() > 0) {
+                     this.drawRegion(var2, var3, this.bufferLists);
+                  }
+
+                  var2 = var5.regionX;
+                  var3 = var5.regionZ;
+               }
+
+               if (this.bufferLists.position() >= this.bufferLists.capacity()) {
+                  IntBuffer var7 = GLAllocation.createDirectIntBuffer(this.bufferLists.capacity() * 2);
+                  ((Buffer)this.bufferLists).flip();
+                  var7.put(this.bufferLists);
+                  this.bufferLists = var7;
+               }
+
+               this.bufferLists.put(var6.getDisplayList(var1, var6.h()));
+            }
+
+            if (this.bufferLists.position() > 0) {
+               this.drawRegion(var2, var3, this.bufferLists);
+            }
+         }
+
+         if (Config.isMultiTexture()) {
+            GlStateManager.bindCurrentTexture();
          }
 
          GlStateManager.resetColor();
          this.renderChunks.clear();
       }
+   }
+
+   @Override
+   public void initialize(double var1, double var3, double var5) {
+      this.viewEntityX = var1;
+      this.viewEntityY = var3;
+      this.viewEntityZ = var5;
+      super.initialize(var1, var3, var5);
+   }
+
+   private void drawRegion(int var1, int var2, IntBuffer var3) {
+      GlStateManager.pushMatrix();
+      this.preRenderRegion(var1, 0, var2);
+      ((Buffer)var3).flip();
+      GlStateManager.callLists(var3);
+      ((Buffer)var3).clear();
+      GlStateManager.popMatrix();
+   }
+
+   public void preRenderRegion(int var1, int var2, int var3) {
+      GlStateManager.translate((float)(var1 - this.viewEntityX), (float)(var2 - this.viewEntityY), (float)(var3 - this.viewEntityZ));
    }
 }
--- net/minecraft/client/renderer/StitcherException.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/StitcherException.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/Tessellator.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/Tessellator.java	Mon Aug 18 09:39:52 2025
@@ -1,8 +1,10 @@
 package net.minecraft.client.renderer;
 
+import net.optifine.SmartAnimations;
+
 public class Tessellator {
    private final BufferBuilder buffer;
    private final WorldVertexBufferUploader vboUploader = new WorldVertexBufferUploader();
    private static final Tessellator INSTANCE = new Tessellator(2097152);
 
    public static Tessellator getInstance() {
@@ -11,12 +13,16 @@
 
    public Tessellator(int var1) {
       this.buffer = new BufferBuilder(var1);
    }
 
    public void draw() {
+      if (this.buffer.animatedSprites != null) {
+         SmartAnimations.spritesRendered(this.buffer.animatedSprites);
+      }
+
       this.buffer.finishDrawing();
       this.vboUploader.draw(this.buffer);
    }
 
    public BufferBuilder getBuffer() {
       return this.buffer;
--- net/minecraft/client/renderer/ThreadDownloadImageData.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ThreadDownloadImageData.java	Mon Aug 18 09:39:52 2025
@@ -1,21 +1,29 @@
 package net.minecraft.client.renderer;
 
 import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.Proxy;
 import java.net.URL;
+import java.net.Proxy.Type;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.texture.SimpleTexture;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.resources.IResourceManager;
 import net.minecraft.util.ResourceLocation;
+import net.optifine.http.HttpPipeline;
+import net.optifine.http.HttpRequest;
+import net.optifine.http.HttpResponse;
+import net.optifine.player.CapeImageBuffer;
+import net.optifine.shaders.ShadersTex;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class ThreadDownloadImageData extends SimpleTexture {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -27,29 +35,35 @@
    private final IImageBuffer imageBuffer;
    @Nullable
    private BufferedImage bufferedImage;
    @Nullable
    private Thread imageThread;
    private boolean textureUploaded;
+   public Boolean imageFound = null;
+   public boolean pipeline = false;
 
    public ThreadDownloadImageData(@Nullable File var1, String var2, ResourceLocation var3, @Nullable IImageBuffer var4) {
       super(var3);
       this.cacheFile = var1;
       this.imageUrl = var2;
       this.imageBuffer = var4;
    }
 
    private void checkTextureUploaded() {
-      if (!this.textureUploaded) {
-         if (this.bufferedImage != null) {
-            if (this.textureLocation != null) {
-               this.deleteGlTexture();
-            }
+      if (!this.textureUploaded && this.bufferedImage != null) {
+         this.textureUploaded = true;
+         if (this.textureLocation != null) {
+            this.deleteGlTexture();
+         }
 
+         if (Config.isShaders()) {
+            ShadersTex.loadSimpleTexture(
+               super.getGlTextureId(), this.bufferedImage, false, false, Config.getResourceManager(), this.textureLocation, this.getMultiTexID()
+            );
+         } else {
             TextureUtil.uploadTextureImage(super.getGlTextureId(), this.bufferedImage);
-            this.textureUploaded = true;
          }
       }
    }
 
    @Override
    public int getGlTextureId() {
@@ -59,12 +73,14 @@
 
    public void setBufferedImage(BufferedImage var1) {
       this.bufferedImage = var1;
       if (this.imageBuffer != null) {
          this.imageBuffer.skinAvailable();
       }
+
+      this.imageFound = this.bufferedImage != null;
    }
 
    @Override
    public void loadTexture(IResourceManager var1) throws IOException {
       if (this.bufferedImage == null && this.textureLocation != null) {
          super.loadTexture(var1);
@@ -76,12 +92,14 @@
 
             try {
                this.bufferedImage = ImageIO.read(this.cacheFile);
                if (this.imageBuffer != null) {
                   this.setBufferedImage(this.imageBuffer.parseUserSkin(this.bufferedImage));
                }
+
+               this.loadingFinished();
             } catch (IOException var3) {
                LOGGER.error("Couldn't load skin {}", this.cacheFile, var3);
                this.loadTextureFromServer();
             }
          } else {
             this.loadTextureFromServer();
@@ -93,19 +111,28 @@
       this.imageThread = new Thread("Texture Downloader #" + TEXTURE_DOWNLOADER_THREAD_ID.incrementAndGet()) {
          @Override
          public void run() {
             HttpURLConnection var1 = null;
             ThreadDownloadImageData.LOGGER
                .debug("Downloading http texture from {} to {}", ThreadDownloadImageData.this.imageUrl, ThreadDownloadImageData.this.cacheFile);
+            if (ThreadDownloadImageData.this.shouldPipeline()) {
+               ThreadDownloadImageData.this.loadPipelined();
+            } else {
+               try {
+                  var1 = (HttpURLConnection)new URL(ThreadDownloadImageData.this.imageUrl).openConnection(Minecraft.getMinecraft().getProxy());
+                  var1.setDoInput(true);
+                  var1.setDoOutput(false);
+                  var1.connect();
+                  if (var1.getResponseCode() / 100 != 2) {
+                     if (var1.getErrorStream() != null) {
+                        Config.readAll(var1.getErrorStream());
+                     }
+
+                     return;
+                  }
 
-            try {
-               var1 = (HttpURLConnection)new URL(ThreadDownloadImageData.this.imageUrl).openConnection(Minecraft.getMinecraft().getProxy());
-               var1.setDoInput(true);
-               var1.setDoOutput(false);
-               var1.connect();
-               if (var1.getResponseCode() / 100 == 2) {
                   BufferedImage var2;
                   if (ThreadDownloadImageData.this.cacheFile != null) {
                      FileUtils.copyInputStreamToFile(var1.getInputStream(), ThreadDownloadImageData.this.cacheFile);
                      var2 = ImageIO.read(ThreadDownloadImageData.this.cacheFile);
                   } else {
                      var2 = TextureUtil.readBufferedImage(var1.getInputStream());
@@ -113,22 +140,74 @@
 
                   if (ThreadDownloadImageData.this.imageBuffer != null) {
                      var2 = ThreadDownloadImageData.this.imageBuffer.parseUserSkin(var2);
                   }
 
                   ThreadDownloadImageData.this.setBufferedImage(var2);
+               } catch (Exception var6) {
+                  ThreadDownloadImageData.LOGGER.error("Couldn't download http texture: " + var6.getMessage());
                   return;
-               }
-            } catch (Exception var6) {
-               ThreadDownloadImageData.LOGGER.error("Couldn't download http texture", var6);
-               return;
-            } finally {
-               if (var1 != null) {
-                  var1.disconnect();
+               } finally {
+                  if (var1 != null) {
+                     var1.disconnect();
+                  }
+
+                  ThreadDownloadImageData.this.loadingFinished();
                }
             }
          }
       };
       this.imageThread.setDaemon(true);
       this.imageThread.start();
+   }
+
+   private boolean shouldPipeline() {
+      if (!this.pipeline) {
+         return false;
+      } else {
+         Proxy var1 = Minecraft.getMinecraft().getProxy();
+         return var1.type() != Type.DIRECT && var1.type() != Type.SOCKS ? false : this.imageUrl.startsWith("http://");
+      }
+   }
+
+   private void loadPipelined() {
+      try {
+         HttpRequest var1 = HttpPipeline.makeRequest(this.imageUrl, Minecraft.getMinecraft().getProxy());
+         HttpResponse var2 = HttpPipeline.executeRequest(var1);
+         if (var2.getStatus() / 100 == 2) {
+            byte[] var4 = var2.getBody();
+            ByteArrayInputStream var5 = new ByteArrayInputStream(var4);
+            BufferedImage var3;
+            if (this.cacheFile != null) {
+               FileUtils.copyInputStreamToFile(var5, this.cacheFile);
+               var3 = ImageIO.read(this.cacheFile);
+            } else {
+               var3 = TextureUtil.readBufferedImage(var5);
+            }
+
+            if (this.imageBuffer != null) {
+               var3 = this.imageBuffer.parseUserSkin(var3);
+            }
+
+            this.setBufferedImage(var3);
+            return;
+         }
+      } catch (Exception var9) {
+         LOGGER.error("Couldn't download http texture: " + var9.getClass().getName() + ": " + var9.getMessage());
+         return;
+      } finally {
+         this.loadingFinished();
+      }
+   }
+
+   private void loadingFinished() {
+      this.imageFound = this.bufferedImage != null;
+      if (this.imageBuffer instanceof CapeImageBuffer) {
+         CapeImageBuffer var1 = (CapeImageBuffer)this.imageBuffer;
+         var1.cleanup();
+      }
+   }
+
+   public IImageBuffer getImageBuffer() {
+      return this.imageBuffer;
    }
 }
--- net/minecraft/client/renderer/VboRenderList.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/VboRenderList.java	Mon Aug 18 09:39:52 2025
@@ -1,36 +1,91 @@
 package net.minecraft.client.renderer;
 
 import net.minecraft.client.renderer.chunk.RenderChunk;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
 import net.minecraft.util.BlockRenderLayer;
+import net.optifine.render.VboRegion;
+import net.optifine.shaders.ShadersRender;
 
 public class VboRenderList extends ChunkRenderContainer {
+   private double viewEntityX;
+   private double viewEntityY;
+   private double viewEntityZ;
+
    @Override
    public void renderChunkLayer(BlockRenderLayer var1) {
       if (this.initialized) {
-         for (RenderChunk var3 : this.renderChunks) {
-            VertexBuffer var4 = var3.getVertexBufferByLayer(var1.ordinal());
-            GlStateManager.pushMatrix();
-            this.preRenderChunk(var3);
-            var3.multModelviewMatrix();
-            var4.bindBuffer();
-            this.setupArrayPointers();
-            var4.drawArrays(7);
-            GlStateManager.popMatrix();
+         if (!Config.isRenderRegions()) {
+            for (RenderChunk var10 : this.renderChunks) {
+               VertexBuffer var11 = var10.getVertexBufferByLayer(var1.ordinal());
+               GlStateManager.pushMatrix();
+               this.preRenderChunk(var10);
+               var10.multModelviewMatrix();
+               var11.bindBuffer();
+               this.setupArrayPointers();
+               var11.drawArrays(7);
+               GlStateManager.popMatrix();
+            }
+         } else {
+            int var2 = Integer.MIN_VALUE;
+            int var3 = Integer.MIN_VALUE;
+            VboRegion var4 = null;
+
+            for (RenderChunk var6 : this.renderChunks) {
+               VertexBuffer var7 = var6.getVertexBufferByLayer(var1.ordinal());
+               VboRegion var8 = var7.getVboRegion();
+               if (var8 != var4 || var2 != var6.regionX || var3 != var6.regionZ) {
+                  if (var4 != null) {
+                     this.drawRegion(var2, var3, var4);
+                  }
+
+                  var2 = var6.regionX;
+                  var3 = var6.regionZ;
+                  var4 = var8;
+               }
+
+               var7.drawArrays(7);
+            }
+
+            if (var4 != null) {
+               this.drawRegion(var2, var3, var4);
+            }
          }
 
          OpenGlHelper.glBindBuffer(OpenGlHelper.GL_ARRAY_BUFFER, 0);
          GlStateManager.resetColor();
          this.renderChunks.clear();
       }
    }
 
-   private void setupArrayPointers() {
-      GlStateManager.glVertexPointer(3, 5126, 28, 0);
-      GlStateManager.glColorPointer(4, 5121, 28, 12);
-      GlStateManager.glTexCoordPointer(2, 5126, 28, 16);
-      OpenGlHelper.setClientActiveTexture(OpenGlHelper.lightmapTexUnit);
-      GlStateManager.glTexCoordPointer(2, 5122, 28, 24);
-      OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+   public void setupArrayPointers() {
+      if (Config.isShaders()) {
+         ShadersRender.setupArrayPointersVbo();
+      } else {
+         GlStateManager.glVertexPointer(3, 5126, 28, 0);
+         GlStateManager.glColorPointer(4, 5121, 28, 12);
+         GlStateManager.glTexCoordPointer(2, 5126, 28, 16);
+         OpenGlHelper.setClientActiveTexture(OpenGlHelper.lightmapTexUnit);
+         GlStateManager.glTexCoordPointer(2, 5122, 28, 24);
+         OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+      }
+   }
+
+   @Override
+   public void initialize(double var1, double var3, double var5) {
+      this.viewEntityX = var1;
+      this.viewEntityY = var3;
+      this.viewEntityZ = var5;
+      super.initialize(var1, var3, var5);
+   }
+
+   private void drawRegion(int var1, int var2, VboRegion var3) {
+      GlStateManager.pushMatrix();
+      this.preRenderRegion(var1, 0, var2);
+      var3.finishDraw(this);
+      GlStateManager.popMatrix();
+   }
+
+   public void preRenderRegion(int var1, int var2, int var3) {
+      GlStateManager.translate((float)(var1 - this.viewEntityX), (float)(var2 - this.viewEntityY), (float)(var3 - this.viewEntityZ));
    }
 }
--- net/minecraft/client/renderer/Vector3d.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/Vector3d.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/renderer/VertexBufferUploader.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/VertexBufferUploader.java	Mon Aug 18 09:39:52 2025
@@ -4,14 +4,19 @@
 
 public class VertexBufferUploader extends WorldVertexBufferUploader {
    private VertexBuffer vertexBuffer;
 
    @Override
    public void draw(BufferBuilder var1) {
-      var1.reset();
+      if (var1.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
+         var1.quadsToTriangles();
+         this.vertexBuffer.setDrawMode(var1.getDrawMode());
+      }
+
       this.vertexBuffer.bufferData(var1.getByteBuffer());
+      var1.reset();
    }
 
    public void setVertexBuffer(VertexBuffer var1) {
       this.vertexBuffer = var1;
    }
 }
--- net/minecraft/client/renderer/ViewFrustum.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/ViewFrustum.java	Mon Aug 18 09:39:52 2025
@@ -1,22 +1,29 @@
 package net.minecraft.client.renderer;
 
+import java.util.HashMap;
+import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.client.renderer.chunk.IRenderChunkFactory;
 import net.minecraft.client.renderer.chunk.RenderChunk;
+import net.minecraft.util.BlockRenderLayer;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.World;
+import net.optifine.render.VboRegion;
 
 public class ViewFrustum {
    protected final RenderGlobal renderGlobal;
    protected final World world;
    protected int countChunksY;
    protected int countChunksX;
    protected int countChunksZ;
    public RenderChunk[] renderChunks;
+   private Map<ChunkPos, VboRegion[]> mapVboRegions = new HashMap<>();
 
    public ViewFrustum(World var1, int var2, RenderGlobal var3, IRenderChunkFactory var4) {
       this.renderGlobal = var3;
       this.world = var1;
       this.setCountChunksXYZ(var2);
       this.createRenderChunks(var4);
@@ -30,21 +37,37 @@
       for (int var4 = 0; var4 < this.countChunksX; var4++) {
          for (int var5 = 0; var5 < this.countChunksY; var5++) {
             for (int var6 = 0; var6 < this.countChunksZ; var6++) {
                int var7 = (var6 * this.countChunksY + var5) * this.countChunksX + var4;
                this.renderChunks[var7] = var1.create(this.world, this.renderGlobal, var3++);
                this.renderChunks[var7].setPosition(var4 * 16, var5 * 16, var6 * 16);
+               if (Config.isVbo() && Config.isRenderRegions()) {
+                  this.updateVboRegion(this.renderChunks[var7]);
+               }
             }
          }
       }
+
+      for (int var10 = 0; var10 < this.renderChunks.length; var10++) {
+         RenderChunk var11 = this.renderChunks[var10];
+
+         for (int var12 = 0; var12 < EnumFacing.VALUES.length; var12++) {
+            EnumFacing var13 = EnumFacing.VALUES[var12];
+            BlockPos var8 = var11.getBlockPosOffset16(var13);
+            RenderChunk var9 = this.getRenderChunk(var8);
+            var11.setRenderChunkNeighbour(var13, var9);
+         }
+      }
    }
 
    public void deleteGlResources() {
       for (RenderChunk var4 : this.renderChunks) {
          var4.deleteGlResources();
       }
+
+      this.deleteVboRegions();
    }
 
    protected void setCountChunksXYZ(int var1) {
       int var2 = var1 * 2 + 1;
       this.countChunksX = var2;
       this.countChunksY = 16;
@@ -113,16 +136,16 @@
             }
          }
       }
    }
 
    @Nullable
-   protected RenderChunk getRenderChunk(BlockPos var1) {
-      int var2 = MathHelper.intFloorDiv(var1.getX(), 16);
-      int var3 = MathHelper.intFloorDiv(var1.getY(), 16);
-      int var4 = MathHelper.intFloorDiv(var1.getZ(), 16);
+   public RenderChunk getRenderChunk(BlockPos var1) {
+      int var2 = var1.getX() >> 4;
+      int var3 = var1.getY() >> 4;
+      int var4 = var1.getZ() >> 4;
       if (var3 >= 0 && var3 < this.countChunksY) {
          var2 %= this.countChunksX;
          if (var2 < 0) {
             var2 += this.countChunksX;
          }
 
@@ -133,8 +156,50 @@
 
          int var5 = (var4 * this.countChunksY + var3) * this.countChunksX + var2;
          return this.renderChunks[var5];
       } else {
          return null;
       }
+   }
+
+   private void updateVboRegion(RenderChunk var1) {
+      BlockPos var2 = var1.getPosition();
+      int var3 = var2.getX() >> 8 << 8;
+      int var4 = var2.getZ() >> 8 << 8;
+      ChunkPos var5 = new ChunkPos(var3, var4);
+      BlockRenderLayer[] var6 = BlockRenderLayer.values();
+      VboRegion[] var7 = this.mapVboRegions.get(var5);
+      if (var7 == null) {
+         var7 = new VboRegion[var6.length];
+
+         for (int var8 = 0; var8 < var6.length; var8++) {
+            var7[var8] = new VboRegion(var6[var8]);
+         }
+
+         this.mapVboRegions.put(var5, var7);
+      }
+
+      for (int var10 = 0; var10 < var6.length; var10++) {
+         VboRegion var9 = var7[var10];
+         if (var9 != null) {
+            var1.getVertexBufferByLayer(var10).setVboRegion(var9);
+         }
+      }
+   }
+
+   public void deleteVboRegions() {
+      for (ChunkPos var3 : this.mapVboRegions.keySet()) {
+         VboRegion[] var4 = this.mapVboRegions.get(var3);
+
+         for (int var5 = 0; var5 < var4.length; var5++) {
+            VboRegion var6 = var4[var5];
+            if (var6 != null) {
+               var6.deleteGlBuffers();
+            }
+
+            var4[var5] = null;
+         }
+      }
+
+      this.mapVboRegions.clear();
    }
 }
--- net/minecraft/client/renderer/WorldVertexBufferUploader.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/renderer/WorldVertexBufferUploader.java	Mon Aug 18 09:39:52 2025
@@ -2,70 +2,94 @@
 
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.util.List;
 import net.minecraft.client.renderer.vertex.VertexFormat;
 import net.minecraft.client.renderer.vertex.VertexFormatElement;
+import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.SVertexBuilder;
 
 public class WorldVertexBufferUploader {
    public void draw(BufferBuilder var1) {
       if (var1.getVertexCount() > 0) {
+         if (var1.getDrawMode() == 7 && Config.isQuadsToTriangles()) {
+            var1.quadsToTriangles();
+         }
+
          VertexFormat var2 = var1.getVertexFormat();
          int var3 = var2.getSize();
          ByteBuffer var4 = var1.getByteBuffer();
          List var5 = var2.getElements();
+         boolean var6 = Reflector.ForgeVertexFormatElementEnumUseage_preDraw.exists();
+         boolean var7 = Reflector.ForgeVertexFormatElementEnumUseage_postDraw.exists();
 
-         for (int var6 = 0; var6 < var5.size(); var6++) {
-            VertexFormatElement var7 = (VertexFormatElement)var5.get(var6);
-            VertexFormatElement.EnumUsage var8 = var7.getUsage();
-            int var9 = var7.getType().getGlConstant();
-            int var10 = var7.getIndex();
-            ((Buffer)var4).position(var2.getOffset(var6));
-            switch (var8) {
-               case POSITION:
-                  GlStateManager.glVertexPointer(var7.getElementCount(), var9, var3, var4);
-                  GlStateManager.glEnableClientState(32884);
-                  break;
-               case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var10);
-                  GlStateManager.glTexCoordPointer(var7.getElementCount(), var9, var3, var4);
-                  GlStateManager.glEnableClientState(32888);
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
-                  break;
-               case COLOR:
-                  GlStateManager.glColorPointer(var7.getElementCount(), var9, var3, var4);
-                  GlStateManager.glEnableClientState(32886);
-                  break;
-               case NORMAL:
-                  GlStateManager.glNormalPointer(var9, var3, var4);
-                  GlStateManager.glEnableClientState(32885);
+         for (int var8 = 0; var8 < var5.size(); var8++) {
+            VertexFormatElement var9 = (VertexFormatElement)var5.get(var8);
+            EnumUsage var10 = var9.getUsage();
+            if (var6) {
+               Reflector.callVoid(var10, Reflector.ForgeVertexFormatElementEnumUseage_preDraw, new Object[]{var2, var8, var3, var4});
+            } else {
+               int var11 = var9.getType().getGlConstant();
+               int var12 = var9.getIndex();
+               ((Buffer)var4).position(var2.getOffset(var8));
+               switch (var10) {
+                  case POSITION:
+                     GlStateManager.glVertexPointer(var9.getElementCount(), var11, var3, var4);
+                     GlStateManager.glEnableClientState(32884);
+                     break;
+                  case UV:
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var12);
+                     GlStateManager.glTexCoordPointer(var9.getElementCount(), var11, var3, var4);
+                     GlStateManager.glEnableClientState(32888);
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+                     break;
+                  case COLOR:
+                     GlStateManager.glColorPointer(var9.getElementCount(), var11, var3, var4);
+                     GlStateManager.glEnableClientState(32886);
+                     break;
+                  case NORMAL:
+                     GlStateManager.glNormalPointer(var11, var3, var4);
+                     GlStateManager.glEnableClientState(32885);
+               }
             }
          }
 
-         GlStateManager.glDrawArrays(var1.getDrawMode(), 0, var1.getVertexCount());
-         int var11 = 0;
+         if (var1.isMultiTexture()) {
+            var1.drawMultiTexture();
+         } else if (Config.isShaders()) {
+            SVertexBuilder.drawArrays(var1.getDrawMode(), 0, var1.getVertexCount(), var1);
+         } else {
+            GlStateManager.glDrawArrays(var1.getDrawMode(), 0, var1.getVertexCount());
+         }
+
+         int var14 = 0;
 
-         for (int var12 = var5.size(); var11 < var12; var11++) {
-            VertexFormatElement var13 = (VertexFormatElement)var5.get(var11);
-            VertexFormatElement.EnumUsage var14 = var13.getUsage();
-            int var15 = var13.getIndex();
-            switch (var14) {
-               case POSITION:
-                  GlStateManager.glDisableClientState(32884);
-                  break;
-               case UV:
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var15);
-                  GlStateManager.glDisableClientState(32888);
-                  OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
-                  break;
-               case COLOR:
-                  GlStateManager.glDisableClientState(32886);
-                  GlStateManager.resetColor();
-                  break;
-               case NORMAL:
-                  GlStateManager.glDisableClientState(32885);
+         for (int var15 = var5.size(); var14 < var15; var14++) {
+            VertexFormatElement var16 = (VertexFormatElement)var5.get(var14);
+            EnumUsage var17 = var16.getUsage();
+            if (var7) {
+               Reflector.callVoid(var17, Reflector.ForgeVertexFormatElementEnumUseage_postDraw, new Object[]{var2, var14, var3, var4});
+            } else {
+               int var13 = var16.getIndex();
+               switch (var17) {
+                  case POSITION:
+                     GlStateManager.glDisableClientState(32884);
+                     break;
+                  case UV:
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit + var13);
+                     GlStateManager.glDisableClientState(32888);
+                     OpenGlHelper.setClientActiveTexture(OpenGlHelper.defaultTexUnit);
+                     break;
+                  case COLOR:
+                     GlStateManager.glDisableClientState(32886);
+                     GlStateManager.resetColor();
+                     break;
+                  case NORMAL:
+                     GlStateManager.glDisableClientState(32885);
+               }
             }
          }
       }
 
       var1.reset();
    }
--- net/minecraft/client/resources/data/AnimationFrame.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/AnimationFrame.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/AnimationMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/AnimationMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/AnimationMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/AnimationMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/BaseMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/BaseMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/FontMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/FontMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/FontMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/FontMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/IMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/IMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/IMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/IMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/LanguageMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/LanguageMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/LanguageMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/LanguageMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/MetadataSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/MetadataSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/PackMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/PackMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/PackMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/PackMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/TextureMetadataSection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/TextureMetadataSection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/data/TextureMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/data/TextureMetadataSectionSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/AbstractResourcePack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/AbstractResourcePack.java	Mon Aug 18 09:39:52 2025
@@ -17,13 +17,13 @@
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public abstract class AbstractResourcePack implements IResourcePack {
    private static final Logger LOGGER = LogManager.getLogger();
-   protected final File resourcePackFile;
+   public final File resourcePackFile;
 
    public AbstractResourcePack(File var1) {
       this.resourcePackFile = var1;
    }
 
    private static String locationToName(ResourceLocation var0) {
@@ -31,31 +31,28 @@
    }
 
    protected static String getRelativeName(File var0, File var1) {
       return var0.toURI().relativize(var1.toURI()).getPath();
    }
 
-   @Override
    public InputStream getInputStream(ResourceLocation var1) throws IOException {
       return this.getInputStreamByName(locationToName(var1));
    }
 
-   @Override
    public boolean resourceExists(ResourceLocation var1) {
       return this.hasResourceName(locationToName(var1));
    }
 
    protected abstract InputStream getInputStreamByName(String var1) throws IOException;
 
    protected abstract boolean hasResourceName(String var1);
 
    protected void logNameNotLowercase(String var1) {
       LOGGER.warn("ResourcePack: ignored non-lowercase namespace: {} in {}", var1, this.resourcePackFile);
    }
 
-   @Override
    public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer var1, String var2) throws IOException {
       return readMetadata(var1, this.getInputStreamByName("pack.mcmeta"), var2);
    }
 
    static <T extends IMetadataSection> T readMetadata(MetadataSerializer var0, InputStream var1, String var2) {
       Object var3 = null;
@@ -67,19 +64,17 @@
       } catch (RuntimeException var9) {
          throw new JsonParseException(var9);
       } finally {
          IOUtils.closeQuietly(var4);
       }
 
-      return var0.parseMetadataSection(var2, (JsonObject)var3);
+      return (T)var0.parseMetadataSection(var2, (JsonObject)var3);
    }
 
-   @Override
    public BufferedImage getPackImage() throws IOException {
       return TextureUtil.readBufferedImage(this.getInputStreamByName("pack.png"));
    }
 
-   @Override
    public String getPackName() {
       return this.resourcePackFile.getName();
    }
 }
--- net/minecraft/client/resources/DefaultPlayerSkin.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/DefaultPlayerSkin.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/DefaultResourcePack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/DefaultResourcePack.java	Mon Aug 18 09:39:52 2025
@@ -11,22 +11,24 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.resources.data.IMetadataSection;
 import net.minecraft.client.resources.data.MetadataSerializer;
 import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.Util;
+import net.optifine.reflect.ReflectorForge;
 
 public class DefaultResourcePack implements IResourcePack {
    public static final Set<String> DEFAULT_RESOURCE_DOMAINS = ImmutableSet.of("minecraft", "realms");
    private final ResourceIndex resourceIndex;
+   private static final boolean ON_WINDOWS = Util.getOSType() == Util.EnumOS.WINDOWS;
 
    public DefaultResourcePack(ResourceIndex var1) {
       this.resourceIndex = var1;
    }
 
-   @Override
    public InputStream getInputStream(ResourceLocation var1) throws IOException {
       InputStream var2 = this.getInputStreamAssets(var1);
       if (var2 != null) {
          return var2;
       } else {
          InputStream var3 = this.getResourceStream(var1);
@@ -36,56 +38,68 @@
             throw new FileNotFoundException(var1.getPath());
          }
       }
    }
 
    @Nullable
-   public InputStream getInputStreamAssets(ResourceLocation var1) throws FileNotFoundException {
+   public InputStream getInputStreamAssets(ResourceLocation var1) throws IOException, FileNotFoundException {
       File var2 = this.resourceIndex.getFile(var1);
       return var2 != null && var2.isFile() ? new FileInputStream(var2) : null;
    }
 
    @Nullable
    private InputStream getResourceStream(ResourceLocation var1) {
       String var2 = "/assets/" + var1.getNamespace() + "/" + var1.getPath();
-
-      try {
-         URL var3 = DefaultResourcePack.class.getResource(var2);
-         return var3 != null && FolderResourcePack.validatePath(new File(var3.getFile()), var2) ? DefaultResourcePack.class.getResourceAsStream(var2) : null;
-      } catch (IOException var4) {
-         return DefaultResourcePack.class.getResourceAsStream(var2);
+      InputStream var3 = ReflectorForge.getOptiFineResourceStream(var2);
+      if (var3 != null) {
+         return var3;
+      } else {
+         try {
+            URL var4 = DefaultResourcePack.class.getResource(var2);
+            return var4 != null && this.validatePath(new File(var4.getFile()), var2) ? DefaultResourcePack.class.getResourceAsStream(var2) : null;
+         } catch (IOException var5) {
+            return DefaultResourcePack.class.getResourceAsStream(var2);
+         }
       }
    }
 
-   @Override
    public boolean resourceExists(ResourceLocation var1) {
       return this.getResourceStream(var1) != null || this.resourceIndex.isFileExisting(var1);
    }
 
-   @Override
    public Set<String> getResourceDomains() {
       return DEFAULT_RESOURCE_DOMAINS;
    }
 
    @Nullable
-   @Override
    public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer var1, String var2) throws IOException {
       try {
          FileInputStream var3 = new FileInputStream(this.resourceIndex.getPackMcmeta());
          return AbstractResourcePack.readMetadata(var1, var3, var2);
       } catch (RuntimeException var4) {
          return null;
       } catch (FileNotFoundException var5) {
          return null;
       }
    }
 
-   @Override
    public BufferedImage getPackImage() throws IOException {
       return TextureUtil.readBufferedImage(DefaultResourcePack.class.getResourceAsStream("/" + new ResourceLocation("pack.png").getPath()));
    }
 
-   @Override
    public String getPackName() {
       return "Default";
+   }
+
+   private boolean validatePath(File var1, String var2) throws IOException {
+      String var3 = var1.getPath();
+      if (var3.startsWith("file:")) {
+         if (ON_WINDOWS) {
+            var3 = var3.replace("\\", "/");
+         }
+
+         return var3.endsWith(var2);
+      } else {
+         return FolderResourcePack.validatePath(var1, var2);
+      }
    }
 }
--- net/minecraft/client/resources/FallbackResourceManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/FallbackResourceManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/FileResourcePack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/FileResourcePack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/FolderResourcePack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/FolderResourcePack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/FoliageColorReloadListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/FoliageColorReloadListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/GrassColorReloadListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/GrassColorReloadListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/I18n.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/I18n.java	Mon Aug 18 09:39:52 2025
@@ -1,8 +1,10 @@
 package net.minecraft.client.resources;
 
+import java.util.Map;
+
 public class I18n {
    private static Locale i18nLocale;
 
    static void setLocale(Locale var0) {
       i18nLocale = var0;
    }
@@ -10,8 +12,12 @@
    public static String format(String var0, Object... var1) {
       return i18nLocale.formatMessage(var0, var1);
    }
 
    public static boolean hasKey(String var0) {
       return i18nLocale.hasKey(var0);
+   }
+
+   public static Map getLocaleProperties() {
+      return i18nLocale.properties;
    }
 }
--- net/minecraft/client/resources/IReloadableResourceManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/IReloadableResourceManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/IResource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/IResource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/IResourceManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/IResourceManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/IResourceManagerReloadListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/IResourceManagerReloadListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/IResourcePack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/IResourcePack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/Language.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/Language.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/LanguageManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/LanguageManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/LegacyV2Adapter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/LegacyV2Adapter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/Locale.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/Locale.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourceIndex.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourceIndex.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourceIndexFolder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourceIndexFolder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackFileNotFoundException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackFileNotFoundException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackListEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackListEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackListEntryDefault.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackListEntryDefault.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackListEntryFound.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackListEntryFound.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackListEntryServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackListEntryServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/ResourcePackRepository.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/ResourcePackRepository.java	Mon Aug 18 09:39:52 2025
@@ -16,12 +16,13 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiScreenWorking;
@@ -35,12 +36,13 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.text.TextFormatting;
 import org.apache.commons.codec.digest.DigestUtils;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.comparator.LastModifiedFileComparator;
+import org.apache.commons.io.filefilter.IOFileFilter;
 import org.apache.commons.io.filefilter.TrueFileFilter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class ResourcePackRepository {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -59,13 +61,13 @@
    private final File dirServerResourcepacks;
    public final MetadataSerializer rprMetadataSerializer;
    private IResourcePack serverResourcePack;
    private final ReentrantLock lock = new ReentrantLock();
    private ListenableFuture<Object> downloadingPacks;
    private List<ResourcePackRepository.Entry> repositoryEntriesAll = Lists.newArrayList();
-   private final List<ResourcePackRepository.Entry> repositoryEntries = Lists.newArrayList();
+   public final List<ResourcePackRepository.Entry> repositoryEntries = Lists.newArrayList();
 
    public ResourcePackRepository(File var1, File var2, IResourcePack var3, MetadataSerializer var4, GameSettings var5) {
       this.dirResourcepacks = var1;
       this.dirServerResourcepacks = var2;
       this.rprDefaultResourcePack = var3;
       this.rprMetadataSerializer = var4;
@@ -118,13 +120,13 @@
          var2 = new FolderResourcePack(var1);
       } else {
          var2 = new FileResourcePack(var1);
       }
 
       try {
-         PackMetadataSection var3 = ((IResourcePack)var2).getPackMetadata(this.rprMetadataSerializer, "pack");
+         PackMetadataSection var3 = (PackMetadataSection)var2.getPackMetadata(this.rprMetadataSerializer, "pack");
          if (var3 != null && var3.getPackFormat() == 2) {
             return new LegacyV2Adapter((IResourcePack)var2);
          }
       } catch (Exception var4) {
       }
 
@@ -241,30 +243,37 @@
       } finally {
          this.lock.unlock();
       }
    }
 
    private boolean checkHash(String var1, File var2) {
+      FileInputStream var3 = null;
+
+      boolean var5;
       try {
-         String var3 = DigestUtils.sha1Hex(new FileInputStream(var2));
+         String var4 = DigestUtils.sha1Hex(var3 = new FileInputStream(var2));
          if (var1.isEmpty()) {
             LOGGER.info("Found file {} without verification hash", var2);
             return true;
          }
 
-         if (var3.toLowerCase(java.util.Locale.ROOT).equals(var1.toLowerCase(java.util.Locale.ROOT))) {
-            LOGGER.info("Found file {} matching requested hash {}", var2, var1);
-            return true;
+         if (!var4.toLowerCase(Locale.ROOT).equals(var1.toLowerCase(Locale.ROOT))) {
+            LOGGER.warn("File {} had wrong hash (expected {}, found {}).", var2, var1, var4);
+            return false;
          }
 
-         LOGGER.warn("File {} had wrong hash (expected {}, found {}).", var2, var1, var3);
-      } catch (IOException var4) {
-         LOGGER.warn("File {} couldn't be hashed.", var2, var4);
+         LOGGER.info("Found file {} matching requested hash {}", var2, var1);
+         var5 = true;
+      } catch (IOException var9) {
+         LOGGER.warn("File {} couldn't be hashed.", var2, var9);
+         return false;
+      } finally {
+         IOUtils.closeQuietly(var3);
       }
 
-      return false;
+      return var5;
    }
 
    private boolean validatePack(File var1) {
       ResourcePackRepository.Entry var2 = new ResourcePackRepository.Entry(var1);
 
       try {
@@ -275,13 +284,13 @@
          return false;
       }
    }
 
    private void deleteOldServerResourcesPacks() {
       try {
-         ArrayList var1 = Lists.newArrayList(FileUtils.listFiles(this.dirServerResourcepacks, TrueFileFilter.TRUE, null));
+         ArrayList var1 = Lists.newArrayList(FileUtils.listFiles(this.dirServerResourcepacks, TrueFileFilter.TRUE, (IOFileFilter)null));
          Collections.sort(var1, LastModifiedFileComparator.LASTMODIFIED_REVERSE);
          int var2 = 0;
 
          for (File var4 : var1) {
             if (var2++ >= 10) {
                LOGGER.info("Deleting old server resource pack {}", var4.getName());
@@ -336,31 +345,32 @@
 
       private Entry(IResourcePack var2) {
          this.reResourcePack = var2;
       }
 
       public void updateResourcePack() throws IOException {
-         this.rePackMetadataSection = this.reResourcePack.getPackMetadata(ResourcePackRepository.this.rprMetadataSerializer, "pack");
+         this.rePackMetadataSection = (PackMetadataSection)this.reResourcePack.getPackMetadata(ResourcePackRepository.this.rprMetadataSerializer, "pack");
          this.closeResourcePack();
       }
 
       public void bindTexturePackIcon(TextureManager var1) {
          BufferedImage var2 = null;
-
-         try {
-            var2 = this.reResourcePack.getPackImage();
-         } catch (IOException var5) {
-         }
-
-         if (var2 == null) {
+         if (this.locationTexturePackIcon == null) {
             try {
-               var2 = TextureUtil.readBufferedImage(
-                  Minecraft.getMinecraft().getResourceManager().getResource(ResourcePackRepository.UNKNOWN_PACK_TEXTURE).getInputStream()
-               );
-            } catch (IOException var4) {
-               throw new Error("Couldn't bind resource pack icon", var4);
+               var2 = this.reResourcePack.getPackImage();
+            } catch (IOException var5) {
+            }
+
+            if (var2 == null) {
+               try {
+                  var2 = TextureUtil.readBufferedImage(
+                     Minecraft.getMinecraft().getResourceManager().getResource(ResourcePackRepository.UNKNOWN_PACK_TEXTURE).getInputStream()
+                  );
+               } catch (IOException var4) {
+                  throw new Error("Couldn't bind resource pack icon", var4);
+               }
             }
          }
 
          if (this.locationTexturePackIcon == null) {
             this.locationTexturePackIcon = var1.getDynamicTextureLocation("texturepackicon", new DynamicTexture(var2));
          }
--- net/minecraft/client/resources/SimpleReloadableResourceManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/SimpleReloadableResourceManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/SimpleResource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/SimpleResource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/resources/SkinManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/resources/SkinManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/settings/CreativeSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/settings/CreativeSettings.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/settings/GameSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/settings/GameSettings.java	Mon Aug 18 09:39:52 2025
@@ -3,47 +3,65 @@
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.gson.Gson;
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiNewChat;
+import net.minecraft.client.gui.GuiScreen;
 import net.minecraft.client.gui.chat.NarratorChatListener;
+import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.resources.I18n;
 import net.minecraft.client.tutorial.TutorialSteps;
-import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EnumPlayerModelParts;
+import net.minecraft.entity.player.EntityPlayer.EnumChatVisibility;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.play.client.CPacketClientSettings;
 import net.minecraft.util.EnumHandSide;
 import net.minecraft.util.JsonUtils;
 import net.minecraft.util.SoundCategory;
 import net.minecraft.util.datafix.FixTypes;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.EnumDifficulty;
+import net.minecraftforge.client.resource.IResourceType;
+import net.optifine.ClearWater;
+import net.optifine.CustomColors;
+import net.optifine.CustomGuis;
+import net.optifine.CustomSky;
+import net.optifine.DynamicLights;
+import net.optifine.Lang;
+import net.optifine.NaturalTextures;
+import net.optifine.RandomEntities;
+import net.optifine.reflect.Reflector;
+import net.optifine.shaders.Shaders;
+import net.optifine.util.KeyUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
 import org.lwjgl.opengl.Display;
+import org.lwjgl.opengl.DisplayMode;
 
 public class GameSettings {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final Gson GSON = new Gson();
    private static final Type TYPE_LIST_STRING = new ParameterizedType() {
       @Override
@@ -81,13 +99,13 @@
    public int limitFramerate = 120;
    public int clouds = 2;
    public boolean fancyGraphics = true;
    public int ambientOcclusion = 2;
    public List<String> resourcePacks = Lists.newArrayList();
    public List<String> incompatibleResourcePacks = Lists.newArrayList();
-   public EntityPlayer.EnumChatVisibility chatVisibility = EntityPlayer.EnumChatVisibility.FULL;
+   public EnumChatVisibility chatVisibility = EnumChatVisibility.FULL;
    public boolean chatColours = true;
    public boolean chatLinks = true;
    public boolean chatLinksPrompt = true;
    public float chatOpacity = 1.0F;
    public boolean snooperEnabled = true;
    public boolean fullScreen;
@@ -149,75 +167,216 @@
       new KeyBinding("key.hotbar.7", 8, "key.categories.inventory"),
       new KeyBinding("key.hotbar.8", 9, "key.categories.inventory"),
       new KeyBinding("key.hotbar.9", 10, "key.categories.inventory")
    };
    public KeyBinding keyBindSaveToolbar = new KeyBinding("key.saveToolbarActivator", 46, "key.categories.creative");
    public KeyBinding keyBindLoadToolbar = new KeyBinding("key.loadToolbarActivator", 45, "key.categories.creative");
-   public KeyBinding[] keyBindings = (KeyBinding[])ArrayUtils.addAll(
-      new KeyBinding[]{
-         this.keyBindAttack,
-         this.keyBindUseItem,
-         this.keyBindForward,
-         this.keyBindLeft,
-         this.keyBindBack,
-         this.keyBindRight,
-         this.keyBindJump,
-         this.keyBindSneak,
-         this.keyBindSprint,
-         this.keyBindDrop,
-         this.keyBindInventory,
-         this.keyBindChat,
-         this.keyBindPlayerList,
-         this.keyBindPickBlock,
-         this.keyBindCommand,
-         this.keyBindScreenshot,
-         this.keyBindTogglePerspective,
-         this.keyBindSmoothCamera,
-         this.keyBindFullscreen,
-         this.keyBindSpectatorOutlines,
-         this.keyBindSwapHands,
-         this.keyBindSaveToolbar,
-         this.keyBindLoadToolbar,
-         this.keyBindAdvancements
-      },
-      this.keyBindsHotbar
-   );
+   public KeyBinding[] keyBindings;
    protected Minecraft mc;
    private File optionsFile;
-   public EnumDifficulty difficulty = EnumDifficulty.NORMAL;
+   public EnumDifficulty difficulty;
    public boolean hideGUI;
    public int thirdPersonView;
    public boolean showDebugInfo;
    public boolean showDebugProfilerChart;
    public boolean showLagometer;
-   public String lastServer = "";
+   public String lastServer;
    public boolean smoothCamera;
    public boolean debugCamEnable;
-   public float fovSetting = 70.0F;
+   public float fovSetting;
    public float gammaSetting;
    public float saturation;
    public int guiScale;
    public int particleSetting;
    public int narrator;
-   public String language = "en_us";
+   public String language;
    public boolean forceUnicodeFont;
+   public int ofFogType = 1;
+   public float ofFogStart = 0.8F;
+   public int ofMipmapType = 0;
+   public boolean ofOcclusionFancy = false;
+   public boolean ofSmoothFps = false;
+   public boolean ofSmoothWorld = Config.isSingleProcessor();
+   public boolean ofLazyChunkLoading = Config.isSingleProcessor();
+   public boolean ofRenderRegions = false;
+   public boolean ofSmartAnimations = false;
+   public float ofAoLevel = 1.0F;
+   public int ofAaLevel = 0;
+   public int ofAfLevel = 1;
+   public int ofClouds = 0;
+   public float ofCloudsHeight = 0.0F;
+   public int ofTrees = 0;
+   public int ofRain = 0;
+   public int ofDroppedItems = 0;
+   public int ofBetterGrass = 3;
+   public int ofAutoSaveTicks = 4000;
+   public boolean ofLagometer = false;
+   public boolean ofProfiler = false;
+   public boolean ofShowFps = false;
+   public boolean ofWeather = true;
+   public boolean ofSky = true;
+   public boolean ofStars = true;
+   public boolean ofSunMoon = true;
+   public int ofVignette = 0;
+   public int ofChunkUpdates = 1;
+   public boolean ofChunkUpdatesDynamic = false;
+   public int ofTime = 0;
+   public boolean ofClearWater = false;
+   public boolean ofBetterSnow = false;
+   public String ofFullscreenMode = "Default";
+   public boolean ofSwampColors = true;
+   public boolean ofRandomEntities = true;
+   public boolean ofSmoothBiomes = true;
+   public boolean ofCustomFonts = true;
+   public boolean ofCustomColors = true;
+   public boolean ofCustomSky = true;
+   public boolean ofShowCapes = true;
+   public int ofConnectedTextures = 2;
+   public boolean ofCustomItems = true;
+   public boolean ofNaturalTextures = false;
+   public boolean ofEmissiveTextures = true;
+   public boolean ofFastMath = false;
+   public boolean ofFastRender = false;
+   public int ofTranslucentBlocks = 0;
+   public boolean ofDynamicFov = true;
+   public boolean ofAlternateBlocks = true;
+   public int ofDynamicLights = 3;
+   public boolean ofCustomEntityModels = true;
+   public boolean ofCustomGuis = true;
+   public boolean ofShowGlErrors = true;
+   public int ofScreenshotSize = 1;
+   public int ofAnimatedWater = 0;
+   public int ofAnimatedLava = 0;
+   public boolean ofAnimatedFire = true;
+   public boolean ofAnimatedPortal = true;
+   public boolean ofAnimatedRedstone = true;
+   public boolean ofAnimatedExplosion = true;
+   public boolean ofAnimatedFlame = true;
+   public boolean ofAnimatedSmoke = true;
+   public boolean ofVoidParticles = true;
+   public boolean ofWaterParticles = true;
+   public boolean ofRainSplash = true;
+   public boolean ofPortalParticles = true;
+   public boolean ofPotionParticles = true;
+   public boolean ofFireworkParticles = true;
+   public boolean ofDrippingWaterLava = true;
+   public boolean ofAnimatedTerrain = true;
+   public boolean ofAnimatedTextures = true;
+   public static final int DEFAULT = 0;
+   public static final int FAST = 1;
+   public static final int FANCY = 2;
+   public static final int OFF = 3;
+   public static final int SMART = 4;
+   public static final int ANIM_ON = 0;
+   public static final int ANIM_GENERATED = 1;
+   public static final int ANIM_OFF = 2;
+   public static final String DEFAULT_STR = "Default";
+   private static final int[] OF_TREES_VALUES = new int[]{0, 1, 4, 2};
+   private static final int[] OF_DYNAMIC_LIGHTS = new int[]{3, 1, 2};
+   private static final String[] KEYS_DYNAMIC_LIGHTS = new String[]{"options.off", "options.graphics.fast", "options.graphics.fancy"};
+   public KeyBinding ofKeyBindZoom;
+   private File optionsFileOF;
+   private boolean needsResourceRefresh = false;
 
    public GameSettings(Minecraft var1, File var2) {
+      this.setForgeKeybindProperties();
+      this.keyBindings = (KeyBinding[])ArrayUtils.addAll(
+         new KeyBinding[]{
+            this.keyBindAttack,
+            this.keyBindUseItem,
+            this.keyBindForward,
+            this.keyBindLeft,
+            this.keyBindBack,
+            this.keyBindRight,
+            this.keyBindJump,
+            this.keyBindSneak,
+            this.keyBindSprint,
+            this.keyBindDrop,
+            this.keyBindInventory,
+            this.keyBindChat,
+            this.keyBindPlayerList,
+            this.keyBindPickBlock,
+            this.keyBindCommand,
+            this.keyBindScreenshot,
+            this.keyBindTogglePerspective,
+            this.keyBindSmoothCamera,
+            this.keyBindFullscreen,
+            this.keyBindSpectatorOutlines,
+            this.keyBindSwapHands,
+            this.keyBindSaveToolbar,
+            this.keyBindLoadToolbar,
+            this.keyBindAdvancements
+         },
+         this.keyBindsHotbar
+      );
+      this.difficulty = EnumDifficulty.NORMAL;
+      this.lastServer = "";
+      this.fovSetting = 70.0F;
+      this.language = "en_us";
       this.mc = var1;
       this.optionsFile = new File(var2, "options.txt");
       if (var1.isJava64bit() && Runtime.getRuntime().maxMemory() >= 1000000000L) {
          GameSettings.Options.RENDER_DISTANCE.setValueMax(32.0F);
+         long var3 = 1000000L;
+         if (Runtime.getRuntime().maxMemory() >= 1500L * var3) {
+            GameSettings.Options.RENDER_DISTANCE.setValueMax(48.0F);
+         }
+
+         if (Runtime.getRuntime().maxMemory() >= 2500L * var3) {
+            GameSettings.Options.RENDER_DISTANCE.setValueMax(64.0F);
+         }
       } else {
          GameSettings.Options.RENDER_DISTANCE.setValueMax(16.0F);
       }
 
       this.renderDistanceChunks = var1.isJava64bit() ? 12 : 8;
+      this.optionsFileOF = new File(var2, "optionsof.txt");
+      this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+      this.ofKeyBindZoom = new KeyBinding("of.key.zoom", 46, "key.categories.misc");
+      this.keyBindings = (KeyBinding[])ArrayUtils.add(this.keyBindings, this.ofKeyBindZoom);
+      KeyUtils.fixKeyConflicts(this.keyBindings, new KeyBinding[]{this.ofKeyBindZoom});
+      this.renderDistanceChunks = 8;
       this.loadOptions();
+      Config.initGameSettings(this);
    }
 
    public GameSettings() {
+      this.setForgeKeybindProperties();
+      this.keyBindings = (KeyBinding[])ArrayUtils.addAll(
+         new KeyBinding[]{
+            this.keyBindAttack,
+            this.keyBindUseItem,
+            this.keyBindForward,
+            this.keyBindLeft,
+            this.keyBindBack,
+            this.keyBindRight,
+            this.keyBindJump,
+            this.keyBindSneak,
+            this.keyBindSprint,
+            this.keyBindDrop,
+            this.keyBindInventory,
+            this.keyBindChat,
+            this.keyBindPlayerList,
+            this.keyBindPickBlock,
+            this.keyBindCommand,
+            this.keyBindScreenshot,
+            this.keyBindTogglePerspective,
+            this.keyBindSmoothCamera,
+            this.keyBindFullscreen,
+            this.keyBindSpectatorOutlines,
+            this.keyBindSwapHands,
+            this.keyBindSaveToolbar,
+            this.keyBindLoadToolbar,
+            this.keyBindAdvancements
+         },
+         this.keyBindsHotbar
+      );
+      this.difficulty = EnumDifficulty.NORMAL;
+      this.lastServer = "";
+      this.fovSetting = 70.0F;
+      this.language = "en_us";
    }
 
    public static String getKeyDisplayString(int var0) {
       if (var0 < 0) {
          switch (var0) {
             case -100:
@@ -233,25 +392,26 @@
          return var0 < 256 ? Keyboard.getKeyName(var0) : String.format("%c", (char)(var0 - 256)).toUpperCase();
       }
    }
 
    public static boolean isKeyDown(KeyBinding var0) {
       int var1 = var0.getKeyCode();
-      if (var1 == 0 || var1 >= 256) {
-         return false;
-      } else {
+      if (var1 != 0 && var1 < 256) {
          return var1 < 0 ? Mouse.isButtonDown(var1 + 100) : Keyboard.isKeyDown(var1);
+      } else {
+         return false;
       }
    }
 
    public void setOptionKeyBinding(KeyBinding var1, int var2) {
       var1.setKeyCode(var2);
       this.saveOptions();
    }
 
    public void setOptionFloatValue(GameSettings.Options var1, float var2) {
+      this.setOptionFloatValueOF(var1, var2);
       if (var1 == GameSettings.Options.SENSITIVITY) {
          this.mouseSensitivity = var2;
       }
 
       if (var1 == GameSettings.Options.FOV) {
          this.fovSetting = var2;
@@ -260,12 +420,19 @@
       if (var1 == GameSettings.Options.GAMMA) {
          this.gammaSetting = var2;
       }
 
       if (var1 == GameSettings.Options.FRAMERATE_LIMIT) {
          this.limitFramerate = (int)var2;
+         this.enableVsync = false;
+         if (this.limitFramerate <= 0) {
+            this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+            this.enableVsync = true;
+         }
+
+         this.updateVSync();
       }
 
       if (var1 == GameSettings.Options.CHAT_OPACITY) {
          this.chatOpacity = var2;
          this.mc.ingameGUI.getChatGUI().refreshChat();
       }
@@ -305,12 +472,13 @@
          this.renderDistanceChunks = (int)var2;
          this.mc.renderGlobal.setDisplayListEntitiesDirty();
       }
    }
 
    public void setOptionValue(GameSettings.Options var1, int var2) {
+      this.setOptionValueOF(var1, var2);
       if (var1 == GameSettings.Options.RENDER_DISTANCE) {
          this.setOptionFloatValue(var1, MathHelper.clamp((float)(this.renderDistanceChunks + var2), var1.getValueMin(), var1.getValueMax()));
       }
 
       if (var1 == GameSettings.Options.MAIN_HAND) {
          this.mainHand = this.mainHand.opposite();
@@ -318,13 +486,32 @@
 
       if (var1 == GameSettings.Options.INVERT_MOUSE) {
          this.invertMouse = !this.invertMouse;
       }
 
       if (var1 == GameSettings.Options.GUI_SCALE) {
-         this.guiScale = this.guiScale + var2 & 3;
+         this.guiScale += var2;
+         if (GuiScreen.isShiftKeyDown()) {
+            this.guiScale = 0;
+         }
+
+         DisplayMode var3 = Config.getLargestDisplayMode();
+         int var4 = var3.getWidth() / 320;
+         int var5 = var3.getHeight() / 240;
+         int var6 = Math.min(var4, var5);
+         if (this.guiScale < 0) {
+            this.guiScale = var6 - 1;
+         }
+
+         if (this.mc.isUnicode() && this.guiScale % 2 != 0) {
+            this.guiScale += var2;
+         }
+
+         if (this.guiScale < 0 || this.guiScale >= var6) {
+            this.guiScale = 0;
+         }
       }
 
       if (var1 == GameSettings.Options.PARTICLES) {
          this.particleSetting = (this.particleSetting + var2) % 3;
       }
 
@@ -343,28 +530,39 @@
 
       if (var1 == GameSettings.Options.FBO_ENABLE) {
          this.fboEnable = !this.fboEnable;
       }
 
       if (var1 == GameSettings.Options.ANAGLYPH) {
+         if (!this.anaglyph && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.an.shaders1"), Lang.get("of.message.an.shaders2"));
+            return;
+         }
+
          this.anaglyph = !this.anaglyph;
          this.mc.refreshResources();
+         if (Reflector.FMLClientHandler_refreshResources.exists()) {
+            Object var7 = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+            IResourceType var8 = (IResourceType)Reflector.VanillaResourceType_TEXTURES.getValue();
+            Reflector.call(var7, Reflector.FMLClientHandler_refreshResources, new IResourceType[]{var8});
+         }
       }
 
       if (var1 == GameSettings.Options.GRAPHICS) {
          this.fancyGraphics = !this.fancyGraphics;
+         this.updateRenderClouds();
          this.mc.renderGlobal.loadRenderers();
       }
 
       if (var1 == GameSettings.Options.AMBIENT_OCCLUSION) {
          this.ambientOcclusion = (this.ambientOcclusion + var2) % 3;
          this.mc.renderGlobal.loadRenderers();
       }
 
       if (var1 == GameSettings.Options.CHAT_VISIBILITY) {
-         this.chatVisibility = EntityPlayer.EnumChatVisibility.getEnumChatVisibility((this.chatVisibility.getChatVisibility() + var2) % 3);
+         this.chatVisibility = EnumChatVisibility.getEnumChatVisibility((this.chatVisibility.getChatVisibility() + var2) % 3);
       }
 
       if (var1 == GameSettings.Options.CHAT_COLOR) {
          this.chatColours = !this.chatColours;
       }
 
@@ -436,13 +634,16 @@
       }
 
       this.saveOptions();
    }
 
    public float getOptionFloatValue(GameSettings.Options var1) {
-      if (var1 == GameSettings.Options.FOV) {
+      float var2 = this.getOptionFloatValueOF(var1);
+      if (var2 != Float.MAX_VALUE) {
+         return var2;
+      } else if (var1 == GameSettings.Options.FOV) {
          return this.fovSetting;
       } else if (var1 == GameSettings.Options.GAMMA) {
          return this.gammaSetting;
       } else if (var1 == GameSettings.Options.SATURATION) {
          return this.saturation;
       } else if (var1 == GameSettings.Options.SENSITIVITY) {
@@ -517,552 +718,2052 @@
       }
 
       return I18n.format(var0[var1]);
    }
 
    public String getKeyBinding(GameSettings.Options var1) {
-      Object var2 = I18n.format(var1.getTranslation()) + ": ";
-      if (var1.isFloat()) {
-         float var6 = this.getOptionFloatValue(var1);
-         float var4 = var1.normalizeValue(var6);
-         if (var1 == GameSettings.Options.SENSITIVITY) {
-            if (var4 == 0.0F) {
-               return var2 + I18n.format("options.sensitivity.min");
-            } else {
-               return var4 == 1.0F ? var2 + I18n.format("options.sensitivity.max") : var2 + (int)(var4 * 200.0F) + "%";
-            }
-         } else if (var1 == GameSettings.Options.FOV) {
-            if (var6 == 70.0F) {
-               return var2 + I18n.format("options.fov.min");
+      String var2 = this.getKeyBindingOF(var1);
+      if (var2 != null) {
+         return var2;
+      } else {
+         Object var3 = I18n.format(var1.getTranslation()) + ": ";
+         if (var1.isFloat()) {
+            float var7 = this.getOptionFloatValue(var1);
+            float var5 = var1.normalizeValue(var7);
+            if (var1 == GameSettings.Options.SENSITIVITY) {
+               if (var5 == 0.0F) {
+                  return var3 + I18n.format("options.sensitivity.min");
+               } else {
+                  return var5 == 1.0F ? var3 + I18n.format("options.sensitivity.max") : var3 + (int)(var5 * 200.0F) + "%";
+               }
+            } else if (var1 == GameSettings.Options.FOV) {
+               if (var7 == 70.0F) {
+                  return var3 + I18n.format("options.fov.min");
+               } else {
+                  return var7 == 110.0F ? var3 + I18n.format("options.fov.max") : var3 + (int)var7;
+               }
+            } else if (var1 == GameSettings.Options.FRAMERATE_LIMIT) {
+               return var7 == var1.valueMax ? var3 + I18n.format("options.framerateLimit.max") : var3 + I18n.format("options.framerate", (int)var7);
+            } else if (var1 == GameSettings.Options.RENDER_CLOUDS) {
+               return var7 == var1.valueMin ? var3 + I18n.format("options.cloudHeight.min") : var3 + ((int)var7 + 128);
+            } else if (var1 == GameSettings.Options.GAMMA) {
+               if (var5 == 0.0F) {
+                  return var3 + I18n.format("options.gamma.min");
+               } else {
+                  return var5 == 1.0F ? var3 + I18n.format("options.gamma.max") : var3 + "+" + (int)(var5 * 100.0F) + "%";
+               }
+            } else if (var1 == GameSettings.Options.SATURATION) {
+               return var3 + (int)(var5 * 400.0F) + "%";
+            } else if (var1 == GameSettings.Options.CHAT_OPACITY) {
+               return var3 + (int)(var5 * 90.0F + 10.0F) + "%";
+            } else if (var1 == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
+               return var3 + GuiNewChat.calculateChatboxHeight(var5) + "px";
+            } else if (var1 == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
+               return var3 + GuiNewChat.calculateChatboxHeight(var5) + "px";
+            } else if (var1 == GameSettings.Options.CHAT_WIDTH) {
+               return var3 + GuiNewChat.calculateChatboxWidth(var5) + "px";
+            } else if (var1 == GameSettings.Options.RENDER_DISTANCE) {
+               return var3 + I18n.format("options.chunks", (int)var7);
+            } else if (var1 == GameSettings.Options.MIPMAP_LEVELS) {
+               if (var7 >= 4.0) {
+                  return var3 + Lang.get("of.general.max");
+               } else {
+                  return var7 == 0.0F ? var3 + I18n.format("options.off") : var3 + (int)var7;
+               }
             } else {
-               return var6 == 110.0F ? var2 + I18n.format("options.fov.max") : var2 + (int)var6;
+               return var5 == 0.0F ? var3 + I18n.format("options.off") : var3 + (int)(var5 * 100.0F) + "%";
             }
-         } else if (var1 == GameSettings.Options.FRAMERATE_LIMIT) {
-            return var6 == var1.valueMax ? var2 + I18n.format("options.framerateLimit.max") : var2 + I18n.format("options.framerate", (int)var6);
+         } else if (var1.isBoolean()) {
+            boolean var6 = this.getOptionOrdinalValue(var1);
+            return var6 ? var3 + I18n.format("options.on") : var3 + I18n.format("options.off");
+         } else if (var1 == GameSettings.Options.MAIN_HAND) {
+            return var3 + this.mainHand;
+         } else if (var1 == GameSettings.Options.GUI_SCALE) {
+            return this.guiScale >= GUISCALES.length ? var3 + this.guiScale + "x" : var3 + getTranslation(GUISCALES, this.guiScale);
+         } else if (var1 == GameSettings.Options.CHAT_VISIBILITY) {
+            return var3 + I18n.format(this.chatVisibility.getResourceKey());
+         } else if (var1 == GameSettings.Options.PARTICLES) {
+            return var3 + getTranslation(PARTICLES, this.particleSetting);
+         } else if (var1 == GameSettings.Options.AMBIENT_OCCLUSION) {
+            return var3 + getTranslation(AMBIENT_OCCLUSIONS, this.ambientOcclusion);
          } else if (var1 == GameSettings.Options.RENDER_CLOUDS) {
-            return var6 == var1.valueMin ? var2 + I18n.format("options.cloudHeight.min") : var2 + ((int)var6 + 128);
-         } else if (var1 == GameSettings.Options.GAMMA) {
-            if (var4 == 0.0F) {
-               return var2 + I18n.format("options.gamma.min");
+            return var3 + getTranslation(CLOUDS_TYPES, this.clouds);
+         } else if (var1 == GameSettings.Options.GRAPHICS) {
+            if (this.fancyGraphics) {
+               return var3 + I18n.format("options.graphics.fancy");
             } else {
-               return var4 == 1.0F ? var2 + I18n.format("options.gamma.max") : var2 + "+" + (int)(var4 * 100.0F) + "%";
+               String var4 = "options.graphics.fast";
+               return var3 + I18n.format("options.graphics.fast");
             }
-         } else if (var1 == GameSettings.Options.SATURATION) {
-            return var2 + (int)(var4 * 400.0F) + "%";
-         } else if (var1 == GameSettings.Options.CHAT_OPACITY) {
-            return var2 + (int)(var4 * 90.0F + 10.0F) + "%";
-         } else if (var1 == GameSettings.Options.CHAT_HEIGHT_UNFOCUSED) {
-            return var2 + GuiNewChat.calculateChatboxHeight(var4) + "px";
-         } else if (var1 == GameSettings.Options.CHAT_HEIGHT_FOCUSED) {
-            return var2 + GuiNewChat.calculateChatboxHeight(var4) + "px";
-         } else if (var1 == GameSettings.Options.CHAT_WIDTH) {
-            return var2 + GuiNewChat.calculateChatboxWidth(var4) + "px";
-         } else if (var1 == GameSettings.Options.RENDER_DISTANCE) {
-            return var2 + I18n.format("options.chunks", (int)var6);
-         } else if (var1 == GameSettings.Options.MIPMAP_LEVELS) {
-            return var6 == 0.0F ? var2 + I18n.format("options.off") : var2 + (int)var6;
+         } else if (var1 == GameSettings.Options.ATTACK_INDICATOR) {
+            return var3 + getTranslation(ATTACK_INDICATORS, this.attackIndicator);
+         } else if (var1 == GameSettings.Options.NARRATOR) {
+            return NarratorChatListener.INSTANCE.isActive()
+               ? var3 + getTranslation(NARRATOR_MODES, this.narrator)
+               : var3 + I18n.format("options.narrator.notavailable");
          } else {
-            return var4 == 0.0F ? var2 + I18n.format("options.off") : var2 + (int)(var4 * 100.0F) + "%";
+            return (String)var3;
          }
-      } else if (var1.isBoolean()) {
-         boolean var5 = this.getOptionOrdinalValue(var1);
-         return var5 ? var2 + I18n.format("options.on") : var2 + I18n.format("options.off");
-      } else if (var1 == GameSettings.Options.MAIN_HAND) {
-         return var2 + this.mainHand;
-      } else if (var1 == GameSettings.Options.GUI_SCALE) {
-         return var2 + getTranslation(GUISCALES, this.guiScale);
-      } else if (var1 == GameSettings.Options.CHAT_VISIBILITY) {
-         return var2 + I18n.format(this.chatVisibility.getResourceKey());
-      } else if (var1 == GameSettings.Options.PARTICLES) {
-         return var2 + getTranslation(PARTICLES, this.particleSetting);
-      } else if (var1 == GameSettings.Options.AMBIENT_OCCLUSION) {
-         return var2 + getTranslation(AMBIENT_OCCLUSIONS, this.ambientOcclusion);
-      } else if (var1 == GameSettings.Options.RENDER_CLOUDS) {
-         return var2 + getTranslation(CLOUDS_TYPES, this.clouds);
-      } else if (var1 == GameSettings.Options.GRAPHICS) {
-         if (this.fancyGraphics) {
-            return var2 + I18n.format("options.graphics.fancy");
-         } else {
-            String var3 = "options.graphics.fast";
-            return var2 + I18n.format("options.graphics.fast");
+      }
+   }
+
+   public void loadOptions() {
+      FileInputStream var1 = null;
+
+      label542: {
+         try {
+            if (this.optionsFile.exists()) {
+               this.soundLevels.clear();
+               List var2 = IOUtils.readLines(var1 = new FileInputStream(this.optionsFile), StandardCharsets.UTF_8);
+               NBTTagCompound var3 = new NBTTagCompound();
+
+               for (String var5 : var2) {
+                  try {
+                     Iterator var6 = COLON_SPLITTER.omitEmptyStrings().limit(2).split(var5).iterator();
+                     var3.setString((String)var6.next(), (String)var6.next());
+                  } catch (Exception var18) {
+                     LOGGER.warn("Skipping bad option: {}", var5);
+                  }
+               }
+
+               var3 = this.dataFix(var3);
+
+               for (String var24 : var3.getKeySet()) {
+                  String var25 = var3.getString(var24);
+
+                  try {
+                     if ("mouseSensitivity".equals(var24)) {
+                        this.mouseSensitivity = this.parseFloat(var25);
+                     }
+
+                     if ("fov".equals(var24)) {
+                        this.fovSetting = this.parseFloat(var25) * 40.0F + 70.0F;
+                     }
+
+                     if ("gamma".equals(var24)) {
+                        this.gammaSetting = this.parseFloat(var25);
+                     }
+
+                     if ("saturation".equals(var24)) {
+                        this.saturation = this.parseFloat(var25);
+                     }
+
+                     if ("invertYMouse".equals(var24)) {
+                        this.invertMouse = "true".equals(var25);
+                     }
+
+                     if ("renderDistance".equals(var24)) {
+                        this.renderDistanceChunks = Integer.parseInt(var25);
+                     }
+
+                     if ("guiScale".equals(var24)) {
+                        this.guiScale = Integer.parseInt(var25);
+                     }
+
+                     if ("particles".equals(var24)) {
+                        this.particleSetting = Integer.parseInt(var25);
+                     }
+
+                     if ("bobView".equals(var24)) {
+                        this.viewBobbing = "true".equals(var25);
+                     }
+
+                     if ("anaglyph3d".equals(var24)) {
+                        this.anaglyph = "true".equals(var25);
+                     }
+
+                     if ("maxFps".equals(var24)) {
+                        this.limitFramerate = Integer.parseInt(var25);
+                        if (this.enableVsync) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+
+                        if (this.limitFramerate <= 0) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+                     }
+
+                     if ("fboEnable".equals(var24)) {
+                        this.fboEnable = "true".equals(var25);
+                     }
+
+                     if ("difficulty".equals(var24)) {
+                        this.difficulty = EnumDifficulty.byId(Integer.parseInt(var25));
+                     }
+
+                     if ("fancyGraphics".equals(var24)) {
+                        this.fancyGraphics = "true".equals(var25);
+                        this.updateRenderClouds();
+                     }
+
+                     if ("tutorialStep".equals(var24)) {
+                        this.tutorialStep = TutorialSteps.getTutorial(var25);
+                     }
+
+                     if ("ao".equals(var24)) {
+                        if ("true".equals(var25)) {
+                           this.ambientOcclusion = 2;
+                        } else if ("false".equals(var25)) {
+                           this.ambientOcclusion = 0;
+                        } else {
+                           this.ambientOcclusion = Integer.parseInt(var25);
+                        }
+                     }
+
+                     if ("renderClouds".equals(var24)) {
+                        if ("true".equals(var25)) {
+                           this.clouds = 2;
+                        } else if ("false".equals(var25)) {
+                           this.clouds = 0;
+                        } else if ("fast".equals(var25)) {
+                           this.clouds = 1;
+                        }
+                     }
+
+                     if ("attackIndicator".equals(var24)) {
+                        if ("0".equals(var25)) {
+                           this.attackIndicator = 0;
+                        } else if ("1".equals(var25)) {
+                           this.attackIndicator = 1;
+                        } else if ("2".equals(var25)) {
+                           this.attackIndicator = 2;
+                        }
+                     }
+
+                     if ("resourcePacks".equals(var24)) {
+                        this.resourcePacks = (List<String>)JsonUtils.gsonDeserialize(GSON, var25, TYPE_LIST_STRING);
+                        if (this.resourcePacks == null) {
+                           this.resourcePacks = Lists.newArrayList();
+                        }
+                     }
+
+                     if ("incompatibleResourcePacks".equals(var24)) {
+                        this.incompatibleResourcePacks = (List<String>)JsonUtils.gsonDeserialize(GSON, var25, TYPE_LIST_STRING);
+                        if (this.incompatibleResourcePacks == null) {
+                           this.incompatibleResourcePacks = Lists.newArrayList();
+                        }
+                     }
+
+                     if ("lastServer".equals(var24)) {
+                        this.lastServer = var25;
+                     }
+
+                     if ("lang".equals(var24)) {
+                        this.language = var25;
+                     }
+
+                     if ("chatVisibility".equals(var24)) {
+                        this.chatVisibility = EnumChatVisibility.getEnumChatVisibility(Integer.parseInt(var25));
+                     }
+
+                     if ("chatColors".equals(var24)) {
+                        this.chatColours = "true".equals(var25);
+                     }
+
+                     if ("chatLinks".equals(var24)) {
+                        this.chatLinks = "true".equals(var25);
+                     }
+
+                     if ("chatLinksPrompt".equals(var24)) {
+                        this.chatLinksPrompt = "true".equals(var25);
+                     }
+
+                     if ("chatOpacity".equals(var24)) {
+                        this.chatOpacity = this.parseFloat(var25);
+                     }
+
+                     if ("snooperEnabled".equals(var24)) {
+                        this.snooperEnabled = "true".equals(var25);
+                     }
+
+                     if ("fullscreen".equals(var24)) {
+                        this.fullScreen = "true".equals(var25);
+                     }
+
+                     if ("enableVsync".equals(var24)) {
+                        this.enableVsync = "true".equals(var25);
+                        if (this.enableVsync) {
+                           this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+                        }
+
+                        this.updateVSync();
+                     }
+
+                     if ("useVbo".equals(var24)) {
+                        this.useVbo = "true".equals(var25);
+                     }
+
+                     if ("hideServerAddress".equals(var24)) {
+                        this.hideServerAddress = "true".equals(var25);
+                     }
+
+                     if ("advancedItemTooltips".equals(var24)) {
+                        this.advancedItemTooltips = "true".equals(var25);
+                     }
+
+                     if ("pauseOnLostFocus".equals(var24)) {
+                        this.pauseOnLostFocus = "true".equals(var25);
+                     }
+
+                     if ("touchscreen".equals(var24)) {
+                        this.touchscreen = "true".equals(var25);
+                     }
+
+                     if ("overrideHeight".equals(var24)) {
+                        this.overrideHeight = Integer.parseInt(var25);
+                     }
+
+                     if ("overrideWidth".equals(var24)) {
+                        this.overrideWidth = Integer.parseInt(var25);
+                     }
+
+                     if ("heldItemTooltips".equals(var24)) {
+                        this.heldItemTooltips = "true".equals(var25);
+                     }
+
+                     if ("chatHeightFocused".equals(var24)) {
+                        this.chatHeightFocused = this.parseFloat(var25);
+                     }
+
+                     if ("chatHeightUnfocused".equals(var24)) {
+                        this.chatHeightUnfocused = this.parseFloat(var25);
+                     }
+
+                     if ("chatScale".equals(var24)) {
+                        this.chatScale = this.parseFloat(var25);
+                     }
+
+                     if ("chatWidth".equals(var24)) {
+                        this.chatWidth = this.parseFloat(var25);
+                     }
+
+                     if ("mipmapLevels".equals(var24)) {
+                        this.mipmapLevels = Integer.parseInt(var25);
+                     }
+
+                     if ("forceUnicodeFont".equals(var24)) {
+                        this.forceUnicodeFont = "true".equals(var25);
+                     }
+
+                     if ("reducedDebugInfo".equals(var24)) {
+                        this.reducedDebugInfo = "true".equals(var25);
+                     }
+
+                     if ("useNativeTransport".equals(var24)) {
+                        this.useNativeTransport = "true".equals(var25);
+                     }
+
+                     if ("entityShadows".equals(var24)) {
+                        this.entityShadows = "true".equals(var25);
+                     }
+
+                     if ("mainHand".equals(var24)) {
+                        this.mainHand = "left".equals(var25) ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
+                     }
+
+                     if ("showSubtitles".equals(var24)) {
+                        this.showSubtitles = "true".equals(var25);
+                     }
+
+                     if ("realmsNotifications".equals(var24)) {
+                        this.realmsNotifications = "true".equals(var25);
+                     }
+
+                     if ("enableWeakAttacks".equals(var24)) {
+                        this.enableWeakAttacks = "true".equals(var25);
+                     }
+
+                     if ("autoJump".equals(var24)) {
+                        this.autoJump = "true".equals(var25);
+                     }
+
+                     if ("narrator".equals(var24)) {
+                        this.narrator = Integer.parseInt(var25);
+                     }
+
+                     for (KeyBinding var10 : this.keyBindings) {
+                        if (var24.equals("key_" + var10.getKeyDescription())) {
+                           if (Reflector.KeyModifier_valueFromString.exists()) {
+                              if (var25.indexOf(58) != -1) {
+                                 String[] var11 = var25.split(":");
+                                 Object var12 = Reflector.call(Reflector.KeyModifier_valueFromString, new Object[]{var11[1]});
+                                 Reflector.call(var10, Reflector.ForgeKeyBinding_setKeyModifierAndCode, new Object[]{var12, Integer.parseInt(var11[0])});
+                              } else {
+                                 Object var34 = Reflector.getFieldValue(Reflector.KeyModifier_NONE);
+                                 Reflector.call(var10, Reflector.ForgeKeyBinding_setKeyModifierAndCode, new Object[]{var34, Integer.parseInt(var25)});
+                              }
+                           } else {
+                              var10.setKeyCode(Integer.parseInt(var25));
+                           }
+                        }
+                     }
+
+                     for (SoundCategory var32 : SoundCategory.values()) {
+                        if (var24.equals("soundCategory_" + var32.getName())) {
+                           this.soundLevels.put(var32, this.parseFloat(var25));
+                        }
+                     }
+
+                     for (EnumPlayerModelParts var33 : EnumPlayerModelParts.values()) {
+                        if (var24.equals("modelPart_" + var33.getPartName())) {
+                           this.setModelPartEnabled(var33, "true".equals(var25));
+                        }
+                     }
+                  } catch (Exception var19) {
+                     LOGGER.warn("Skipping bad option: {}:{}", var24, var25);
+                     var19.printStackTrace();
+                  }
+               }
+
+               KeyBinding.resetKeyBindingArrayAndHash();
+               break label542;
+            }
+         } catch (Exception var20) {
+            LOGGER.error("Failed to load options", var20);
+            break label542;
+         } finally {
+            IOUtils.closeQuietly(var1);
          }
-      } else if (var1 == GameSettings.Options.ATTACK_INDICATOR) {
-         return var2 + getTranslation(ATTACK_INDICATORS, this.attackIndicator);
-      } else if (var1 == GameSettings.Options.NARRATOR) {
-         return NarratorChatListener.INSTANCE.isActive()
-            ? var2 + getTranslation(NARRATOR_MODES, this.narrator)
-            : var2 + I18n.format("options.narrator.notavailable");
+
+         return;
+      }
+
+      this.loadOfOptions();
+   }
+
+   private NBTTagCompound dataFix(NBTTagCompound var1) {
+      int var2 = 0;
+
+      try {
+         var2 = Integer.parseInt(var1.getString("version"));
+      } catch (RuntimeException var4) {
+      }
+
+      return this.mc.getDataFixer().process(FixTypes.OPTIONS, var1, var2);
+   }
+
+   private float parseFloat(String var1) {
+      if ("true".equals(var1)) {
+         return 1.0F;
       } else {
-         return (String)var2;
+         return "false".equals(var1) ? 0.0F : Float.parseFloat(var1);
       }
    }
 
-   public void loadOptions() {
+   public void saveOptions() {
+      if (Reflector.FMLClientHandler.exists()) {
+         Object var1 = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+         if (var1 != null && Reflector.callBoolean(var1, Reflector.FMLClientHandler_isLoading, new Object[0])) {
+            return;
+         }
+      }
+
+      PrintWriter var14 = null;
+
       try {
-         if (!this.optionsFile.exists()) {
+         var14 = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFile), StandardCharsets.UTF_8));
+         var14.println("version:1343");
+         var14.println("invertYMouse:" + this.invertMouse);
+         var14.println("mouseSensitivity:" + this.mouseSensitivity);
+         var14.println("fov:" + (this.fovSetting - 70.0F) / 40.0F);
+         var14.println("gamma:" + this.gammaSetting);
+         var14.println("saturation:" + this.saturation);
+         var14.println("renderDistance:" + this.renderDistanceChunks);
+         var14.println("guiScale:" + this.guiScale);
+         var14.println("particles:" + this.particleSetting);
+         var14.println("bobView:" + this.viewBobbing);
+         var14.println("anaglyph3d:" + this.anaglyph);
+         var14.println("maxFps:" + this.limitFramerate);
+         var14.println("fboEnable:" + this.fboEnable);
+         var14.println("difficulty:" + this.difficulty.getId());
+         var14.println("fancyGraphics:" + this.fancyGraphics);
+         var14.println("ao:" + this.ambientOcclusion);
+         switch (this.clouds) {
+            case 0:
+               var14.println("renderClouds:false");
+               break;
+            case 1:
+               var14.println("renderClouds:fast");
+               break;
+            case 2:
+               var14.println("renderClouds:true");
+         }
+
+         var14.println("resourcePacks:" + GSON.toJson(this.resourcePacks));
+         var14.println("incompatibleResourcePacks:" + GSON.toJson(this.incompatibleResourcePacks));
+         var14.println("lastServer:" + this.lastServer);
+         var14.println("lang:" + this.language);
+         var14.println("chatVisibility:" + this.chatVisibility.getChatVisibility());
+         var14.println("chatColors:" + this.chatColours);
+         var14.println("chatLinks:" + this.chatLinks);
+         var14.println("chatLinksPrompt:" + this.chatLinksPrompt);
+         var14.println("chatOpacity:" + this.chatOpacity);
+         var14.println("snooperEnabled:" + this.snooperEnabled);
+         var14.println("fullscreen:" + this.fullScreen);
+         var14.println("enableVsync:" + this.enableVsync);
+         var14.println("useVbo:" + this.useVbo);
+         var14.println("hideServerAddress:" + this.hideServerAddress);
+         var14.println("advancedItemTooltips:" + this.advancedItemTooltips);
+         var14.println("pauseOnLostFocus:" + this.pauseOnLostFocus);
+         var14.println("touchscreen:" + this.touchscreen);
+         var14.println("overrideWidth:" + this.overrideWidth);
+         var14.println("overrideHeight:" + this.overrideHeight);
+         var14.println("heldItemTooltips:" + this.heldItemTooltips);
+         var14.println("chatHeightFocused:" + this.chatHeightFocused);
+         var14.println("chatHeightUnfocused:" + this.chatHeightUnfocused);
+         var14.println("chatScale:" + this.chatScale);
+         var14.println("chatWidth:" + this.chatWidth);
+         var14.println("mipmapLevels:" + this.mipmapLevels);
+         var14.println("forceUnicodeFont:" + this.forceUnicodeFont);
+         var14.println("reducedDebugInfo:" + this.reducedDebugInfo);
+         var14.println("useNativeTransport:" + this.useNativeTransport);
+         var14.println("entityShadows:" + this.entityShadows);
+         var14.println("mainHand:" + (this.mainHand == EnumHandSide.LEFT ? "left" : "right"));
+         var14.println("attackIndicator:" + this.attackIndicator);
+         var14.println("showSubtitles:" + this.showSubtitles);
+         var14.println("realmsNotifications:" + this.realmsNotifications);
+         var14.println("enableWeakAttacks:" + this.enableWeakAttacks);
+         var14.println("autoJump:" + this.autoJump);
+         var14.println("narrator:" + this.narrator);
+         var14.println("tutorialStep:" + this.tutorialStep.getName());
+
+         for (KeyBinding var5 : this.keyBindings) {
+            if (Reflector.ForgeKeyBinding_getKeyModifier.exists()) {
+               String var6 = "key_" + var5.getKeyDescription() + ":" + var5.getKeyCode();
+               Object var7 = Reflector.call(var5, Reflector.ForgeKeyBinding_getKeyModifier, new Object[0]);
+               Object var8 = Reflector.getFieldValue(Reflector.KeyModifier_NONE);
+               var14.println(var7 != var8 ? var6 + ":" + var7 : var6);
+            } else {
+               var14.println("key_" + var5.getKeyDescription() + ":" + var5.getKeyCode());
+            }
+         }
+
+         for (SoundCategory var21 : SoundCategory.values()) {
+            var14.println("soundCategory_" + var21.getName() + ":" + this.getSoundLevel(var21));
+         }
+
+         for (EnumPlayerModelParts var22 : EnumPlayerModelParts.values()) {
+            var14.println("modelPart_" + var22.getPartName() + ":" + this.setModelParts.contains(var22));
+         }
+      } catch (Exception var12) {
+         LOGGER.error("Failed to save options", var12);
+      } finally {
+         IOUtils.closeQuietly(var14);
+      }
+
+      this.saveOfOptions();
+      this.sendSettingsToServer();
+   }
+
+   public float getSoundLevel(SoundCategory var1) {
+      return this.soundLevels.containsKey(var1) ? this.soundLevels.get(var1) : 1.0F;
+   }
+
+   public void setSoundLevel(SoundCategory var1, float var2) {
+      this.mc.getSoundHandler().setSoundLevel(var1, var2);
+      this.soundLevels.put(var1, var2);
+   }
+
+   public void sendSettingsToServer() {
+      if (this.mc.player != null) {
+         int var1 = 0;
+
+         for (EnumPlayerModelParts var3 : this.setModelParts) {
+            var1 |= var3.getPartMask();
+         }
+
+         this.mc
+            .player
+            .connection
+            .sendPacket(new CPacketClientSettings(this.language, this.renderDistanceChunks, this.chatVisibility, this.chatColours, var1, this.mainHand));
+      }
+   }
+
+   public Set<EnumPlayerModelParts> getModelParts() {
+      return ImmutableSet.copyOf(this.setModelParts);
+   }
+
+   public void setModelPartEnabled(EnumPlayerModelParts var1, boolean var2) {
+      if (var2) {
+         this.setModelParts.add(var1);
+      } else {
+         this.setModelParts.remove(var1);
+      }
+
+      this.sendSettingsToServer();
+   }
+
+   public void switchModelPartEnabled(EnumPlayerModelParts var1) {
+      if (this.getModelParts().contains(var1)) {
+         this.setModelParts.remove(var1);
+      } else {
+         this.setModelParts.add(var1);
+      }
+
+      this.sendSettingsToServer();
+   }
+
+   public int shouldRenderClouds() {
+      return this.renderDistanceChunks >= 4 ? this.clouds : 0;
+   }
+
+   public boolean isUsingNativeTransport() {
+      return this.useNativeTransport;
+   }
+
+   private void setOptionFloatValueOF(GameSettings.Options var1, float var2) {
+      if (var1 == GameSettings.Options.CLOUD_HEIGHT) {
+         this.ofCloudsHeight = var2;
+         this.mc.renderGlobal.resetClouds();
+      }
+
+      if (var1 == GameSettings.Options.AO_LEVEL) {
+         this.ofAoLevel = var2;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.AA_LEVEL) {
+         int var3 = (int)var2;
+         if (var3 > 0 && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.aa.shaders1"), Lang.get("of.message.aa.shaders2"));
             return;
          }
 
-         this.soundLevels.clear();
-         List var1 = IOUtils.readLines(new FileInputStream(this.optionsFile));
-         NBTTagCompound var2 = new NBTTagCompound();
+         int[] var4 = new int[]{0, 2, 4, 6, 8, 12, 16};
+         this.ofAaLevel = 0;
 
-         for (String var4 : var1) {
-            try {
-               Iterator var5 = COLON_SPLITTER.omitEmptyStrings().limit(2).split(var4).iterator();
-               var2.setString((String)var5.next(), (String)var5.next());
-            } catch (Exception var10) {
-               LOGGER.warn("Skipping bad option: {}", var4);
+         for (int var5 = 0; var5 < var4.length; var5++) {
+            if (var3 >= var4[var5]) {
+               this.ofAaLevel = var4[var5];
             }
          }
 
-         var2 = this.dataFix(var2);
+         this.ofAaLevel = Config.limit(this.ofAaLevel, 0, 16);
+      }
+
+      if (var1 == GameSettings.Options.AF_LEVEL) {
+         int var6 = (int)var2;
+         if (var6 > 1 && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.af.shaders1"), Lang.get("of.message.af.shaders2"));
+            return;
+         }
+
+         this.ofAfLevel = 1;
+
+         while (this.ofAfLevel * 2 <= var6) {
+            this.ofAfLevel *= 2;
+         }
+
+         this.ofAfLevel = Config.limit(this.ofAfLevel, 1, 16);
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.MIPMAP_TYPE) {
+         int var7 = (int)var2;
+         this.ofMipmapType = Config.limit(var7, 0, 3);
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.FULLSCREEN_MODE) {
+         int var8 = (int)var2 - 1;
+         String[] var9 = Config.getDisplayModeNames();
+         if (var8 < 0 || var8 >= var9.length) {
+            this.ofFullscreenMode = "Default";
+            return;
+         }
+
+         this.ofFullscreenMode = var9[var8];
+      }
+   }
+
+   private float getOptionFloatValueOF(GameSettings.Options var1) {
+      if (var1 == GameSettings.Options.CLOUD_HEIGHT) {
+         return this.ofCloudsHeight;
+      } else if (var1 == GameSettings.Options.AO_LEVEL) {
+         return this.ofAoLevel;
+      } else if (var1 == GameSettings.Options.AA_LEVEL) {
+         return this.ofAaLevel;
+      } else if (var1 == GameSettings.Options.AF_LEVEL) {
+         return this.ofAfLevel;
+      } else if (var1 == GameSettings.Options.MIPMAP_TYPE) {
+         return this.ofMipmapType;
+      } else if (var1 == GameSettings.Options.FRAMERATE_LIMIT) {
+         return this.limitFramerate == GameSettings.Options.FRAMERATE_LIMIT.getValueMax() && this.enableVsync ? 0.0F : this.limitFramerate;
+      } else if (var1 == GameSettings.Options.FULLSCREEN_MODE) {
+         if (this.ofFullscreenMode.equals("Default")) {
+            return 0.0F;
+         } else {
+            List var2 = Arrays.asList(Config.getDisplayModeNames());
+            int var3 = var2.indexOf(this.ofFullscreenMode);
+            return var3 < 0 ? 0.0F : var3 + 1;
+         }
+      } else {
+         return Float.MAX_VALUE;
+      }
+   }
+
+   private void setOptionValueOF(GameSettings.Options var1, int var2) {
+      if (var1 == GameSettings.Options.FOG_FANCY) {
+         switch (this.ofFogType) {
+            case 1:
+               this.ofFogType = 2;
+               if (!Config.isFancyFogAvailable()) {
+                  this.ofFogType = 3;
+               }
+               break;
+            case 2:
+               this.ofFogType = 3;
+               break;
+            case 3:
+               this.ofFogType = 1;
+               break;
+            default:
+               this.ofFogType = 1;
+         }
+      }
+
+      if (var1 == GameSettings.Options.FOG_START) {
+         this.ofFogStart += 0.2F;
+         if (this.ofFogStart > 0.81F) {
+            this.ofFogStart = 0.2F;
+         }
+      }
+
+      if (var1 == GameSettings.Options.SMOOTH_FPS) {
+         this.ofSmoothFps = !this.ofSmoothFps;
+      }
+
+      if (var1 == GameSettings.Options.SMOOTH_WORLD) {
+         this.ofSmoothWorld = !this.ofSmoothWorld;
+         Config.updateThreadPriorities();
+      }
+
+      if (var1 == GameSettings.Options.CLOUDS) {
+         this.ofClouds++;
+         if (this.ofClouds > 3) {
+            this.ofClouds = 0;
+         }
+
+         this.updateRenderClouds();
+         this.mc.renderGlobal.resetClouds();
+      }
+
+      if (var1 == GameSettings.Options.TREES) {
+         this.ofTrees = nextValue(this.ofTrees, OF_TREES_VALUES);
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.DROPPED_ITEMS) {
+         this.ofDroppedItems++;
+         if (this.ofDroppedItems > 2) {
+            this.ofDroppedItems = 0;
+         }
+      }
+
+      if (var1 == GameSettings.Options.RAIN) {
+         this.ofRain++;
+         if (this.ofRain > 3) {
+            this.ofRain = 0;
+         }
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_WATER) {
+         this.ofAnimatedWater++;
+         if (this.ofAnimatedWater == 1) {
+            this.ofAnimatedWater++;
+         }
+
+         if (this.ofAnimatedWater > 2) {
+            this.ofAnimatedWater = 0;
+         }
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_LAVA) {
+         this.ofAnimatedLava++;
+         if (this.ofAnimatedLava == 1) {
+            this.ofAnimatedLava++;
+         }
+
+         if (this.ofAnimatedLava > 2) {
+            this.ofAnimatedLava = 0;
+         }
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_FIRE) {
+         this.ofAnimatedFire = !this.ofAnimatedFire;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_PORTAL) {
+         this.ofAnimatedPortal = !this.ofAnimatedPortal;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_REDSTONE) {
+         this.ofAnimatedRedstone = !this.ofAnimatedRedstone;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_EXPLOSION) {
+         this.ofAnimatedExplosion = !this.ofAnimatedExplosion;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_FLAME) {
+         this.ofAnimatedFlame = !this.ofAnimatedFlame;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_SMOKE) {
+         this.ofAnimatedSmoke = !this.ofAnimatedSmoke;
+      }
+
+      if (var1 == GameSettings.Options.VOID_PARTICLES) {
+         this.ofVoidParticles = !this.ofVoidParticles;
+      }
+
+      if (var1 == GameSettings.Options.WATER_PARTICLES) {
+         this.ofWaterParticles = !this.ofWaterParticles;
+      }
+
+      if (var1 == GameSettings.Options.PORTAL_PARTICLES) {
+         this.ofPortalParticles = !this.ofPortalParticles;
+      }
+
+      if (var1 == GameSettings.Options.POTION_PARTICLES) {
+         this.ofPotionParticles = !this.ofPotionParticles;
+      }
+
+      if (var1 == GameSettings.Options.FIREWORK_PARTICLES) {
+         this.ofFireworkParticles = !this.ofFireworkParticles;
+      }
 
-         for (String var15 : var2.getKeySet()) {
-            String var16 = var2.getString(var15);
+      if (var1 == GameSettings.Options.DRIPPING_WATER_LAVA) {
+         this.ofDrippingWaterLava = !this.ofDrippingWaterLava;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_TERRAIN) {
+         this.ofAnimatedTerrain = !this.ofAnimatedTerrain;
+      }
+
+      if (var1 == GameSettings.Options.ANIMATED_TEXTURES) {
+         this.ofAnimatedTextures = !this.ofAnimatedTextures;
+      }
+
+      if (var1 == GameSettings.Options.RAIN_SPLASH) {
+         this.ofRainSplash = !this.ofRainSplash;
+      }
+
+      if (var1 == GameSettings.Options.LAGOMETER) {
+         this.ofLagometer = !this.ofLagometer;
+      }
+
+      if (var1 == GameSettings.Options.SHOW_FPS) {
+         this.ofShowFps = !this.ofShowFps;
+      }
+
+      if (var1 == GameSettings.Options.AUTOSAVE_TICKS) {
+         short var3 = 900;
+         this.ofAutoSaveTicks = Math.max(this.ofAutoSaveTicks / var3 * var3, var3);
+         this.ofAutoSaveTicks *= 2;
+         if (this.ofAutoSaveTicks > 32 * var3) {
+            this.ofAutoSaveTicks = var3;
+         }
+      }
+
+      if (var1 == GameSettings.Options.BETTER_GRASS) {
+         this.ofBetterGrass++;
+         if (this.ofBetterGrass > 3) {
+            this.ofBetterGrass = 1;
+         }
+
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.CONNECTED_TEXTURES) {
+         this.ofConnectedTextures++;
+         if (this.ofConnectedTextures > 3) {
+            this.ofConnectedTextures = 1;
+         }
+
+         if (this.ofConnectedTextures == 2) {
+            this.mc.renderGlobal.loadRenderers();
+         } else {
+            this.mc.refreshResources();
+         }
+      }
+
+      if (var1 == GameSettings.Options.WEATHER) {
+         this.ofWeather = !this.ofWeather;
+      }
+
+      if (var1 == GameSettings.Options.SKY) {
+         this.ofSky = !this.ofSky;
+      }
+
+      if (var1 == GameSettings.Options.STARS) {
+         this.ofStars = !this.ofStars;
+      }
+
+      if (var1 == GameSettings.Options.SUN_MOON) {
+         this.ofSunMoon = !this.ofSunMoon;
+      }
+
+      if (var1 == GameSettings.Options.VIGNETTE) {
+         this.ofVignette++;
+         if (this.ofVignette > 2) {
+            this.ofVignette = 0;
+         }
+      }
+
+      if (var1 == GameSettings.Options.CHUNK_UPDATES) {
+         this.ofChunkUpdates++;
+         if (this.ofChunkUpdates > 5) {
+            this.ofChunkUpdates = 1;
+         }
+      }
+
+      if (var1 == GameSettings.Options.CHUNK_UPDATES_DYNAMIC) {
+         this.ofChunkUpdatesDynamic = !this.ofChunkUpdatesDynamic;
+      }
+
+      if (var1 == GameSettings.Options.TIME) {
+         this.ofTime++;
+         if (this.ofTime > 2) {
+            this.ofTime = 0;
+         }
+      }
 
+      if (var1 == GameSettings.Options.CLEAR_WATER) {
+         this.ofClearWater = !this.ofClearWater;
+         this.updateWaterOpacity();
+      }
+
+      if (var1 == GameSettings.Options.PROFILER) {
+         this.ofProfiler = !this.ofProfiler;
+      }
+
+      if (var1 == GameSettings.Options.BETTER_SNOW) {
+         this.ofBetterSnow = !this.ofBetterSnow;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.SWAMP_COLORS) {
+         this.ofSwampColors = !this.ofSwampColors;
+         CustomColors.updateUseDefaultGrassFoliageColors();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.RANDOM_ENTITIES) {
+         this.ofRandomEntities = !this.ofRandomEntities;
+         RandomEntities.update();
+      }
+
+      if (var1 == GameSettings.Options.SMOOTH_BIOMES) {
+         this.ofSmoothBiomes = !this.ofSmoothBiomes;
+         CustomColors.updateUseDefaultGrassFoliageColors();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_FONTS) {
+         this.ofCustomFonts = !this.ofCustomFonts;
+         this.mc.fontRenderer.onResourceManagerReload(Config.getResourceManager());
+         this.mc.standardGalacticFontRenderer.onResourceManagerReload(Config.getResourceManager());
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_COLORS) {
+         this.ofCustomColors = !this.ofCustomColors;
+         CustomColors.update();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_ITEMS) {
+         this.ofCustomItems = !this.ofCustomItems;
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_SKY) {
+         this.ofCustomSky = !this.ofCustomSky;
+         CustomSky.update();
+      }
+
+      if (var1 == GameSettings.Options.SHOW_CAPES) {
+         this.ofShowCapes = !this.ofShowCapes;
+      }
+
+      if (var1 == GameSettings.Options.NATURAL_TEXTURES) {
+         this.ofNaturalTextures = !this.ofNaturalTextures;
+         NaturalTextures.update();
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.EMISSIVE_TEXTURES) {
+         this.ofEmissiveTextures = !this.ofEmissiveTextures;
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.FAST_MATH) {
+         this.ofFastMath = !this.ofFastMath;
+         MathHelper.fastMath = this.ofFastMath;
+      }
+
+      if (var1 == GameSettings.Options.FAST_RENDER) {
+         if (!this.ofFastRender && Config.isShaders()) {
+            Config.showGuiMessage(Lang.get("of.message.fr.shaders1"), Lang.get("of.message.fr.shaders2"));
+            return;
+         }
+
+         this.ofFastRender = !this.ofFastRender;
+         if (this.ofFastRender) {
+            this.mc.entityRenderer.stopUseShader();
+         }
+
+         Config.updateFramebufferSize();
+      }
+
+      if (var1 == GameSettings.Options.TRANSLUCENT_BLOCKS) {
+         if (this.ofTranslucentBlocks == 0) {
+            this.ofTranslucentBlocks = 1;
+         } else if (this.ofTranslucentBlocks == 1) {
+            this.ofTranslucentBlocks = 2;
+         } else if (this.ofTranslucentBlocks == 2) {
+            this.ofTranslucentBlocks = 0;
+         } else {
+            this.ofTranslucentBlocks = 0;
+         }
+
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.LAZY_CHUNK_LOADING) {
+         this.ofLazyChunkLoading = !this.ofLazyChunkLoading;
+      }
+
+      if (var1 == GameSettings.Options.RENDER_REGIONS) {
+         this.ofRenderRegions = !this.ofRenderRegions;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.SMART_ANIMATIONS) {
+         this.ofSmartAnimations = !this.ofSmartAnimations;
+         this.mc.renderGlobal.loadRenderers();
+      }
+
+      if (var1 == GameSettings.Options.DYNAMIC_FOV) {
+         this.ofDynamicFov = !this.ofDynamicFov;
+      }
+
+      if (var1 == GameSettings.Options.ALTERNATE_BLOCKS) {
+         this.ofAlternateBlocks = !this.ofAlternateBlocks;
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.DYNAMIC_LIGHTS) {
+         this.ofDynamicLights = nextValue(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+         DynamicLights.removeLights(this.mc.renderGlobal);
+      }
+
+      if (var1 == GameSettings.Options.SCREENSHOT_SIZE) {
+         this.ofScreenshotSize++;
+         if (this.ofScreenshotSize > 4) {
+            this.ofScreenshotSize = 1;
+         }
+
+         if (!OpenGlHelper.isFramebufferEnabled()) {
+            this.ofScreenshotSize = 1;
+         }
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_ENTITY_MODELS) {
+         this.ofCustomEntityModels = !this.ofCustomEntityModels;
+         this.mc.refreshResources();
+      }
+
+      if (var1 == GameSettings.Options.CUSTOM_GUIS) {
+         this.ofCustomGuis = !this.ofCustomGuis;
+         CustomGuis.update();
+      }
+
+      if (var1 == GameSettings.Options.SHOW_GL_ERRORS) {
+         this.ofShowGlErrors = !this.ofShowGlErrors;
+      }
+
+      if (var1 == GameSettings.Options.HELD_ITEM_TOOLTIPS) {
+         this.heldItemTooltips = !this.heldItemTooltips;
+      }
+
+      if (var1 == GameSettings.Options.ADVANCED_TOOLTIPS) {
+         this.advancedItemTooltips = !this.advancedItemTooltips;
+      }
+   }
+
+   private String getKeyBindingOF(GameSettings.Options var1) {
+      String var2 = I18n.format(var1.getTranslation()) + ": ";
+      if (var2 == null) {
+         var2 = var1.getTranslation();
+      }
+
+      if (var1 == GameSettings.Options.RENDER_DISTANCE) {
+         int var12 = (int)this.getOptionFloatValue(var1);
+         String var5 = I18n.format("of.options.renderDistance.tiny");
+         byte var6 = 2;
+         if (var12 >= 4) {
+            var5 = I18n.format("of.options.renderDistance.short");
+            var6 = 4;
+         }
+
+         if (var12 >= 8) {
+            var5 = I18n.format("of.options.renderDistance.normal");
+            var6 = 8;
+         }
+
+         if (var12 >= 16) {
+            var5 = I18n.format("of.options.renderDistance.far");
+            var6 = 16;
+         }
+
+         if (var12 >= 32) {
+            var5 = Lang.get("of.options.renderDistance.extreme");
+            var6 = 32;
+         }
+
+         if (var12 >= 48) {
+            var5 = Lang.get("of.options.renderDistance.insane");
+            var6 = 48;
+         }
+
+         if (var12 >= 64) {
+            var5 = Lang.get("of.options.renderDistance.ludicrous");
+            var6 = 64;
+         }
+
+         int var7 = this.renderDistanceChunks - var6;
+         String var8 = var5;
+         if (var7 > 0) {
+            var8 = var5 + "+";
+         }
+
+         return var2 + var12 + " " + var8 + "";
+      } else if (var1 == GameSettings.Options.FOG_FANCY) {
+         switch (this.ofFogType) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (var1 == GameSettings.Options.FOG_START) {
+         return var2 + this.ofFogStart;
+      } else if (var1 == GameSettings.Options.MIPMAP_TYPE) {
+         switch (this.ofMipmapType) {
+            case 0:
+               return var2 + Lang.get("of.options.mipmap.nearest");
+            case 1:
+               return var2 + Lang.get("of.options.mipmap.linear");
+            case 2:
+               return var2 + Lang.get("of.options.mipmap.bilinear");
+            case 3:
+               return var2 + Lang.get("of.options.mipmap.trilinear");
+            default:
+               return var2 + "of.options.mipmap.nearest";
+         }
+      } else if (var1 == GameSettings.Options.SMOOTH_FPS) {
+         return this.ofSmoothFps ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SMOOTH_WORLD) {
+         return this.ofSmoothWorld ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CLOUDS) {
+         switch (this.ofClouds) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.TREES) {
+         switch (this.ofTrees) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+            default:
+               return var2 + Lang.getDefault();
+            case 4:
+               return var2 + Lang.get("of.general.smart");
+         }
+      } else if (var1 == GameSettings.Options.DROPPED_ITEMS) {
+         switch (this.ofDroppedItems) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.RAIN) {
+         switch (this.ofRain) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            case 3:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.ANIMATED_WATER) {
+         switch (this.ofAnimatedWater) {
+            case 1:
+               return var2 + Lang.get("of.options.animation.dynamic");
+            case 2:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOn();
+         }
+      } else if (var1 == GameSettings.Options.ANIMATED_LAVA) {
+         switch (this.ofAnimatedLava) {
+            case 1:
+               return var2 + Lang.get("of.options.animation.dynamic");
+            case 2:
+               return var2 + Lang.getOff();
+            default:
+               return var2 + Lang.getOn();
+         }
+      } else if (var1 == GameSettings.Options.ANIMATED_FIRE) {
+         return this.ofAnimatedFire ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_PORTAL) {
+         return this.ofAnimatedPortal ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_REDSTONE) {
+         return this.ofAnimatedRedstone ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_EXPLOSION) {
+         return this.ofAnimatedExplosion ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_FLAME) {
+         return this.ofAnimatedFlame ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_SMOKE) {
+         return this.ofAnimatedSmoke ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.VOID_PARTICLES) {
+         return this.ofVoidParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.WATER_PARTICLES) {
+         return this.ofWaterParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.PORTAL_PARTICLES) {
+         return this.ofPortalParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.POTION_PARTICLES) {
+         return this.ofPotionParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.FIREWORK_PARTICLES) {
+         return this.ofFireworkParticles ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.DRIPPING_WATER_LAVA) {
+         return this.ofDrippingWaterLava ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_TERRAIN) {
+         return this.ofAnimatedTerrain ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ANIMATED_TEXTURES) {
+         return this.ofAnimatedTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.RAIN_SPLASH) {
+         return this.ofRainSplash ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.LAGOMETER) {
+         return this.ofLagometer ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SHOW_FPS) {
+         return this.ofShowFps ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.AUTOSAVE_TICKS) {
+         short var11 = 900;
+         if (this.ofAutoSaveTicks <= var11) {
+            return var2 + Lang.get("of.options.save.45s");
+         } else if (this.ofAutoSaveTicks <= 2 * var11) {
+            return var2 + Lang.get("of.options.save.90s");
+         } else if (this.ofAutoSaveTicks <= 4 * var11) {
+            return var2 + Lang.get("of.options.save.3min");
+         } else if (this.ofAutoSaveTicks <= 8 * var11) {
+            return var2 + Lang.get("of.options.save.6min");
+         } else {
+            return this.ofAutoSaveTicks <= 16 * var11 ? var2 + Lang.get("of.options.save.12min") : var2 + Lang.get("of.options.save.24min");
+         }
+      } else if (var1 == GameSettings.Options.BETTER_GRASS) {
+         switch (this.ofBetterGrass) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (var1 == GameSettings.Options.CONNECTED_TEXTURES) {
+         switch (this.ofConnectedTextures) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getOff();
+         }
+      } else if (var1 == GameSettings.Options.WEATHER) {
+         return this.ofWeather ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SKY) {
+         return this.ofSky ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.STARS) {
+         return this.ofStars ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SUN_MOON) {
+         return this.ofSunMoon ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.VIGNETTE) {
+         switch (this.ofVignette) {
+            case 1:
+               return var2 + Lang.getFast();
+            case 2:
+               return var2 + Lang.getFancy();
+            default:
+               return var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.CHUNK_UPDATES) {
+         return var2 + this.ofChunkUpdates;
+      } else if (var1 == GameSettings.Options.CHUNK_UPDATES_DYNAMIC) {
+         return this.ofChunkUpdatesDynamic ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.TIME) {
+         if (this.ofTime == 1) {
+            return var2 + Lang.get("of.options.time.dayOnly");
+         } else {
+            return this.ofTime == 2 ? var2 + Lang.get("of.options.time.nightOnly") : var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.CLEAR_WATER) {
+         return this.ofClearWater ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.AA_LEVEL) {
+         String var10 = "";
+         if (this.ofAaLevel != Config.getAntialiasingLevel()) {
+            var10 = " (" + Lang.get("of.general.restart") + ")";
+         }
+
+         return this.ofAaLevel == 0 ? var2 + Lang.getOff() + var10 : var2 + this.ofAaLevel + var10;
+      } else if (var1 == GameSettings.Options.AF_LEVEL) {
+         return this.ofAfLevel == 1 ? var2 + Lang.getOff() : var2 + this.ofAfLevel;
+      } else if (var1 == GameSettings.Options.PROFILER) {
+         return this.ofProfiler ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.BETTER_SNOW) {
+         return this.ofBetterSnow ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SWAMP_COLORS) {
+         return this.ofSwampColors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.RANDOM_ENTITIES) {
+         return this.ofRandomEntities ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SMOOTH_BIOMES) {
+         return this.ofSmoothBiomes ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CUSTOM_FONTS) {
+         return this.ofCustomFonts ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CUSTOM_COLORS) {
+         return this.ofCustomColors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CUSTOM_SKY) {
+         return this.ofCustomSky ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SHOW_CAPES) {
+         return this.ofShowCapes ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CUSTOM_ITEMS) {
+         return this.ofCustomItems ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.NATURAL_TEXTURES) {
+         return this.ofNaturalTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.EMISSIVE_TEXTURES) {
+         return this.ofEmissiveTextures ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.FAST_MATH) {
+         return this.ofFastMath ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.FAST_RENDER) {
+         return this.ofFastRender ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.TRANSLUCENT_BLOCKS) {
+         if (this.ofTranslucentBlocks == 1) {
+            return var2 + Lang.getFast();
+         } else {
+            return this.ofTranslucentBlocks == 2 ? var2 + Lang.getFancy() : var2 + Lang.getDefault();
+         }
+      } else if (var1 == GameSettings.Options.LAZY_CHUNK_LOADING) {
+         return this.ofLazyChunkLoading ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.RENDER_REGIONS) {
+         return this.ofRenderRegions ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SMART_ANIMATIONS) {
+         return this.ofSmartAnimations ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.DYNAMIC_FOV) {
+         return this.ofDynamicFov ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ALTERNATE_BLOCKS) {
+         return this.ofAlternateBlocks ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.DYNAMIC_LIGHTS) {
+         int var9 = indexOf(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+         return var2 + getTranslation(KEYS_DYNAMIC_LIGHTS, var9);
+      } else if (var1 == GameSettings.Options.SCREENSHOT_SIZE) {
+         return this.ofScreenshotSize <= 1 ? var2 + Lang.getDefault() : var2 + this.ofScreenshotSize + "x";
+      } else if (var1 == GameSettings.Options.CUSTOM_ENTITY_MODELS) {
+         return this.ofCustomEntityModels ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.CUSTOM_GUIS) {
+         return this.ofCustomGuis ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.SHOW_GL_ERRORS) {
+         return this.ofShowGlErrors ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.FULLSCREEN_MODE) {
+         return this.ofFullscreenMode.equals("Default") ? var2 + Lang.getDefault() : var2 + this.ofFullscreenMode;
+      } else if (var1 == GameSettings.Options.HELD_ITEM_TOOLTIPS) {
+         return this.heldItemTooltips ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.ADVANCED_TOOLTIPS) {
+         return this.advancedItemTooltips ? var2 + Lang.getOn() : var2 + Lang.getOff();
+      } else if (var1 == GameSettings.Options.FRAMERATE_LIMIT) {
+         float var4 = this.getOptionFloatValue(var1);
+         if (var4 == 0.0F) {
+            return var2 + Lang.get("of.options.framerateLimit.vsync");
+         } else {
+            return var4 == var1.valueMax ? var2 + I18n.format("options.framerateLimit.max") : var2 + (int)var4 + " fps";
+         }
+      } else {
+         return null;
+      }
+   }
+
+   public void loadOfOptions() {
+      try {
+         File var1 = this.optionsFileOF;
+         if (!var1.exists()) {
+            var1 = this.optionsFile;
+         }
+
+         if (!var1.exists()) {
+            return;
+         }
+
+         BufferedReader var2 = new BufferedReader(new InputStreamReader(new FileInputStream(var1), StandardCharsets.UTF_8));
+         String var3 = "";
+
+         while ((var3 = var2.readLine()) != null) {
             try {
-               if ("mouseSensitivity".equals(var15)) {
-                  this.mouseSensitivity = this.parseFloat(var16);
+               String[] var4 = var3.split(":");
+               if (var4[0].equals("ofRenderDistanceChunks") && var4.length >= 2) {
+                  this.renderDistanceChunks = Integer.valueOf(var4[1]);
+                  this.renderDistanceChunks = Config.limit(this.renderDistanceChunks, 2, 1024);
                }
 
-               if ("fov".equals(var15)) {
-                  this.fovSetting = this.parseFloat(var16) * 40.0F + 70.0F;
+               if (var4[0].equals("ofFogType") && var4.length >= 2) {
+                  this.ofFogType = Integer.valueOf(var4[1]);
+                  this.ofFogType = Config.limit(this.ofFogType, 1, 3);
                }
 
-               if ("gamma".equals(var15)) {
-                  this.gammaSetting = this.parseFloat(var16);
+               if (var4[0].equals("ofFogStart") && var4.length >= 2) {
+                  this.ofFogStart = Float.valueOf(var4[1]);
+                  if (this.ofFogStart < 0.2F) {
+                     this.ofFogStart = 0.2F;
+                  }
+
+                  if (this.ofFogStart > 0.81F) {
+                     this.ofFogStart = 0.8F;
+                  }
                }
 
-               if ("saturation".equals(var15)) {
-                  this.saturation = this.parseFloat(var16);
+               if (var4[0].equals("ofMipmapType") && var4.length >= 2) {
+                  this.ofMipmapType = Integer.valueOf(var4[1]);
+                  this.ofMipmapType = Config.limit(this.ofMipmapType, 0, 3);
                }
 
-               if ("invertYMouse".equals(var15)) {
-                  this.invertMouse = "true".equals(var16);
+               if (var4[0].equals("ofOcclusionFancy") && var4.length >= 2) {
+                  this.ofOcclusionFancy = Boolean.valueOf(var4[1]);
                }
 
-               if ("renderDistance".equals(var15)) {
-                  this.renderDistanceChunks = Integer.parseInt(var16);
+               if (var4[0].equals("ofSmoothFps") && var4.length >= 2) {
+                  this.ofSmoothFps = Boolean.valueOf(var4[1]);
                }
 
-               if ("guiScale".equals(var15)) {
-                  this.guiScale = Integer.parseInt(var16);
+               if (var4[0].equals("ofSmoothWorld") && var4.length >= 2) {
+                  this.ofSmoothWorld = Boolean.valueOf(var4[1]);
                }
 
-               if ("particles".equals(var15)) {
-                  this.particleSetting = Integer.parseInt(var16);
+               if (var4[0].equals("ofAoLevel") && var4.length >= 2) {
+                  this.ofAoLevel = Float.valueOf(var4[1]);
+                  this.ofAoLevel = Config.limit(this.ofAoLevel, 0.0F, 1.0F);
                }
 
-               if ("bobView".equals(var15)) {
-                  this.viewBobbing = "true".equals(var16);
+               if (var4[0].equals("ofClouds") && var4.length >= 2) {
+                  this.ofClouds = Integer.valueOf(var4[1]);
+                  this.ofClouds = Config.limit(this.ofClouds, 0, 3);
+                  this.updateRenderClouds();
                }
 
-               if ("anaglyph3d".equals(var15)) {
-                  this.anaglyph = "true".equals(var16);
+               if (var4[0].equals("ofCloudsHeight") && var4.length >= 2) {
+                  this.ofCloudsHeight = Float.valueOf(var4[1]);
+                  this.ofCloudsHeight = Config.limit(this.ofCloudsHeight, 0.0F, 1.0F);
                }
 
-               if ("maxFps".equals(var15)) {
-                  this.limitFramerate = Integer.parseInt(var16);
+               if (var4[0].equals("ofTrees") && var4.length >= 2) {
+                  this.ofTrees = Integer.valueOf(var4[1]);
+                  this.ofTrees = limit(this.ofTrees, OF_TREES_VALUES);
                }
 
-               if ("fboEnable".equals(var15)) {
-                  this.fboEnable = "true".equals(var16);
+               if (var4[0].equals("ofDroppedItems") && var4.length >= 2) {
+                  this.ofDroppedItems = Integer.valueOf(var4[1]);
+                  this.ofDroppedItems = Config.limit(this.ofDroppedItems, 0, 2);
                }
 
-               if ("difficulty".equals(var15)) {
-                  this.difficulty = EnumDifficulty.byId(Integer.parseInt(var16));
+               if (var4[0].equals("ofRain") && var4.length >= 2) {
+                  this.ofRain = Integer.valueOf(var4[1]);
+                  this.ofRain = Config.limit(this.ofRain, 0, 3);
                }
 
-               if ("fancyGraphics".equals(var15)) {
-                  this.fancyGraphics = "true".equals(var16);
+               if (var4[0].equals("ofAnimatedWater") && var4.length >= 2) {
+                  this.ofAnimatedWater = Integer.valueOf(var4[1]);
+                  this.ofAnimatedWater = Config.limit(this.ofAnimatedWater, 0, 2);
                }
 
-               if ("tutorialStep".equals(var15)) {
-                  this.tutorialStep = TutorialSteps.getTutorial(var16);
+               if (var4[0].equals("ofAnimatedLava") && var4.length >= 2) {
+                  this.ofAnimatedLava = Integer.valueOf(var4[1]);
+                  this.ofAnimatedLava = Config.limit(this.ofAnimatedLava, 0, 2);
                }
 
-               if ("ao".equals(var15)) {
-                  if ("true".equals(var16)) {
-                     this.ambientOcclusion = 2;
-                  } else if ("false".equals(var16)) {
-                     this.ambientOcclusion = 0;
-                  } else {
-                     this.ambientOcclusion = Integer.parseInt(var16);
-                  }
+               if (var4[0].equals("ofAnimatedFire") && var4.length >= 2) {
+                  this.ofAnimatedFire = Boolean.valueOf(var4[1]);
                }
 
-               if ("renderClouds".equals(var15)) {
-                  if ("true".equals(var16)) {
-                     this.clouds = 2;
-                  } else if ("false".equals(var16)) {
-                     this.clouds = 0;
-                  } else if ("fast".equals(var16)) {
-                     this.clouds = 1;
-                  }
+               if (var4[0].equals("ofAnimatedPortal") && var4.length >= 2) {
+                  this.ofAnimatedPortal = Boolean.valueOf(var4[1]);
                }
 
-               if ("attackIndicator".equals(var15)) {
-                  if ("0".equals(var16)) {
-                     this.attackIndicator = 0;
-                  } else if ("1".equals(var16)) {
-                     this.attackIndicator = 1;
-                  } else if ("2".equals(var16)) {
-                     this.attackIndicator = 2;
-                  }
+               if (var4[0].equals("ofAnimatedRedstone") && var4.length >= 2) {
+                  this.ofAnimatedRedstone = Boolean.valueOf(var4[1]);
                }
 
-               if ("resourcePacks".equals(var15)) {
-                  this.resourcePacks = JsonUtils.gsonDeserialize(GSON, var16, TYPE_LIST_STRING);
-                  if (this.resourcePacks == null) {
-                     this.resourcePacks = Lists.newArrayList();
-                  }
+               if (var4[0].equals("ofAnimatedExplosion") && var4.length >= 2) {
+                  this.ofAnimatedExplosion = Boolean.valueOf(var4[1]);
                }
 
-               if ("incompatibleResourcePacks".equals(var15)) {
-                  this.incompatibleResourcePacks = JsonUtils.gsonDeserialize(GSON, var16, TYPE_LIST_STRING);
-                  if (this.incompatibleResourcePacks == null) {
-                     this.incompatibleResourcePacks = Lists.newArrayList();
-                  }
+               if (var4[0].equals("ofAnimatedFlame") && var4.length >= 2) {
+                  this.ofAnimatedFlame = Boolean.valueOf(var4[1]);
                }
 
-               if ("lastServer".equals(var15)) {
-                  this.lastServer = var16;
+               if (var4[0].equals("ofAnimatedSmoke") && var4.length >= 2) {
+                  this.ofAnimatedSmoke = Boolean.valueOf(var4[1]);
                }
 
-               if ("lang".equals(var15)) {
-                  this.language = var16;
+               if (var4[0].equals("ofVoidParticles") && var4.length >= 2) {
+                  this.ofVoidParticles = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatVisibility".equals(var15)) {
-                  this.chatVisibility = EntityPlayer.EnumChatVisibility.getEnumChatVisibility(Integer.parseInt(var16));
+               if (var4[0].equals("ofWaterParticles") && var4.length >= 2) {
+                  this.ofWaterParticles = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatColors".equals(var15)) {
-                  this.chatColours = "true".equals(var16);
+               if (var4[0].equals("ofPortalParticles") && var4.length >= 2) {
+                  this.ofPortalParticles = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatLinks".equals(var15)) {
-                  this.chatLinks = "true".equals(var16);
+               if (var4[0].equals("ofPotionParticles") && var4.length >= 2) {
+                  this.ofPotionParticles = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatLinksPrompt".equals(var15)) {
-                  this.chatLinksPrompt = "true".equals(var16);
+               if (var4[0].equals("ofFireworkParticles") && var4.length >= 2) {
+                  this.ofFireworkParticles = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatOpacity".equals(var15)) {
-                  this.chatOpacity = this.parseFloat(var16);
+               if (var4[0].equals("ofDrippingWaterLava") && var4.length >= 2) {
+                  this.ofDrippingWaterLava = Boolean.valueOf(var4[1]);
                }
 
-               if ("snooperEnabled".equals(var15)) {
-                  this.snooperEnabled = "true".equals(var16);
+               if (var4[0].equals("ofAnimatedTerrain") && var4.length >= 2) {
+                  this.ofAnimatedTerrain = Boolean.valueOf(var4[1]);
                }
 
-               if ("fullscreen".equals(var15)) {
-                  this.fullScreen = "true".equals(var16);
+               if (var4[0].equals("ofAnimatedTextures") && var4.length >= 2) {
+                  this.ofAnimatedTextures = Boolean.valueOf(var4[1]);
                }
 
-               if ("enableVsync".equals(var15)) {
-                  this.enableVsync = "true".equals(var16);
+               if (var4[0].equals("ofRainSplash") && var4.length >= 2) {
+                  this.ofRainSplash = Boolean.valueOf(var4[1]);
                }
 
-               if ("useVbo".equals(var15)) {
-                  this.useVbo = "true".equals(var16);
+               if (var4[0].equals("ofLagometer") && var4.length >= 2) {
+                  this.ofLagometer = Boolean.valueOf(var4[1]);
                }
 
-               if ("hideServerAddress".equals(var15)) {
-                  this.hideServerAddress = "true".equals(var16);
+               if (var4[0].equals("ofShowFps") && var4.length >= 2) {
+                  this.ofShowFps = Boolean.valueOf(var4[1]);
                }
 
-               if ("advancedItemTooltips".equals(var15)) {
-                  this.advancedItemTooltips = "true".equals(var16);
+               if (var4[0].equals("ofAutoSaveTicks") && var4.length >= 2) {
+                  this.ofAutoSaveTicks = Integer.valueOf(var4[1]);
+                  this.ofAutoSaveTicks = Config.limit(this.ofAutoSaveTicks, 40, 40000);
                }
 
-               if ("pauseOnLostFocus".equals(var15)) {
-                  this.pauseOnLostFocus = "true".equals(var16);
+               if (var4[0].equals("ofBetterGrass") && var4.length >= 2) {
+                  this.ofBetterGrass = Integer.valueOf(var4[1]);
+                  this.ofBetterGrass = Config.limit(this.ofBetterGrass, 1, 3);
                }
 
-               if ("touchscreen".equals(var15)) {
-                  this.touchscreen = "true".equals(var16);
+               if (var4[0].equals("ofConnectedTextures") && var4.length >= 2) {
+                  this.ofConnectedTextures = Integer.valueOf(var4[1]);
+                  this.ofConnectedTextures = Config.limit(this.ofConnectedTextures, 1, 3);
                }
 
-               if ("overrideHeight".equals(var15)) {
-                  this.overrideHeight = Integer.parseInt(var16);
+               if (var4[0].equals("ofWeather") && var4.length >= 2) {
+                  this.ofWeather = Boolean.valueOf(var4[1]);
                }
 
-               if ("overrideWidth".equals(var15)) {
-                  this.overrideWidth = Integer.parseInt(var16);
+               if (var4[0].equals("ofSky") && var4.length >= 2) {
+                  this.ofSky = Boolean.valueOf(var4[1]);
                }
 
-               if ("heldItemTooltips".equals(var15)) {
-                  this.heldItemTooltips = "true".equals(var16);
+               if (var4[0].equals("ofStars") && var4.length >= 2) {
+                  this.ofStars = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatHeightFocused".equals(var15)) {
-                  this.chatHeightFocused = this.parseFloat(var16);
+               if (var4[0].equals("ofSunMoon") && var4.length >= 2) {
+                  this.ofSunMoon = Boolean.valueOf(var4[1]);
                }
 
-               if ("chatHeightUnfocused".equals(var15)) {
-                  this.chatHeightUnfocused = this.parseFloat(var16);
+               if (var4[0].equals("ofVignette") && var4.length >= 2) {
+                  this.ofVignette = Integer.valueOf(var4[1]);
+                  this.ofVignette = Config.limit(this.ofVignette, 0, 2);
                }
 
-               if ("chatScale".equals(var15)) {
-                  this.chatScale = this.parseFloat(var16);
+               if (var4[0].equals("ofChunkUpdates") && var4.length >= 2) {
+                  this.ofChunkUpdates = Integer.valueOf(var4[1]);
+                  this.ofChunkUpdates = Config.limit(this.ofChunkUpdates, 1, 5);
                }
 
-               if ("chatWidth".equals(var15)) {
-                  this.chatWidth = this.parseFloat(var16);
+               if (var4[0].equals("ofChunkUpdatesDynamic") && var4.length >= 2) {
+                  this.ofChunkUpdatesDynamic = Boolean.valueOf(var4[1]);
                }
 
-               if ("mipmapLevels".equals(var15)) {
-                  this.mipmapLevels = Integer.parseInt(var16);
+               if (var4[0].equals("ofTime") && var4.length >= 2) {
+                  this.ofTime = Integer.valueOf(var4[1]);
+                  this.ofTime = Config.limit(this.ofTime, 0, 2);
                }
 
-               if ("forceUnicodeFont".equals(var15)) {
-                  this.forceUnicodeFont = "true".equals(var16);
+               if (var4[0].equals("ofClearWater") && var4.length >= 2) {
+                  this.ofClearWater = Boolean.valueOf(var4[1]);
+                  this.updateWaterOpacity();
                }
 
-               if ("reducedDebugInfo".equals(var15)) {
-                  this.reducedDebugInfo = "true".equals(var16);
+               if (var4[0].equals("ofAaLevel") && var4.length >= 2) {
+                  this.ofAaLevel = Integer.valueOf(var4[1]);
+                  this.ofAaLevel = Config.limit(this.ofAaLevel, 0, 16);
                }
 
-               if ("useNativeTransport".equals(var15)) {
-                  this.useNativeTransport = "true".equals(var16);
+               if (var4[0].equals("ofAfLevel") && var4.length >= 2) {
+                  this.ofAfLevel = Integer.valueOf(var4[1]);
+                  this.ofAfLevel = Config.limit(this.ofAfLevel, 1, 16);
                }
 
-               if ("entityShadows".equals(var15)) {
-                  this.entityShadows = "true".equals(var16);
+               if (var4[0].equals("ofProfiler") && var4.length >= 2) {
+                  this.ofProfiler = Boolean.valueOf(var4[1]);
                }
 
-               if ("mainHand".equals(var15)) {
-                  this.mainHand = "left".equals(var16) ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
+               if (var4[0].equals("ofBetterSnow") && var4.length >= 2) {
+                  this.ofBetterSnow = Boolean.valueOf(var4[1]);
                }
 
-               if ("showSubtitles".equals(var15)) {
-                  this.showSubtitles = "true".equals(var16);
+               if (var4[0].equals("ofSwampColors") && var4.length >= 2) {
+                  this.ofSwampColors = Boolean.valueOf(var4[1]);
                }
 
-               if ("realmsNotifications".equals(var15)) {
-                  this.realmsNotifications = "true".equals(var16);
+               if (var4[0].equals("ofRandomEntities") && var4.length >= 2) {
+                  this.ofRandomEntities = Boolean.valueOf(var4[1]);
                }
 
-               if ("enableWeakAttacks".equals(var15)) {
-                  this.enableWeakAttacks = "true".equals(var16);
+               if (var4[0].equals("ofSmoothBiomes") && var4.length >= 2) {
+                  this.ofSmoothBiomes = Boolean.valueOf(var4[1]);
                }
 
-               if ("autoJump".equals(var15)) {
-                  this.autoJump = "true".equals(var16);
+               if (var4[0].equals("ofCustomFonts") && var4.length >= 2) {
+                  this.ofCustomFonts = Boolean.valueOf(var4[1]);
                }
 
-               if ("narrator".equals(var15)) {
-                  this.narrator = Integer.parseInt(var16);
+               if (var4[0].equals("ofCustomColors") && var4.length >= 2) {
+                  this.ofCustomColors = Boolean.valueOf(var4[1]);
                }
 
-               for (KeyBinding var9 : this.keyBindings) {
-                  if (var15.equals("key_" + var9.getKeyDescription())) {
-                     var9.setKeyCode(Integer.parseInt(var16));
-                  }
+               if (var4[0].equals("ofCustomItems") && var4.length >= 2) {
+                  this.ofCustomItems = Boolean.valueOf(var4[1]);
                }
 
-               for (SoundCategory var23 : SoundCategory.values()) {
-                  if (var15.equals("soundCategory_" + var23.getName())) {
-                     this.soundLevels.put(var23, this.parseFloat(var16));
-                  }
+               if (var4[0].equals("ofCustomSky") && var4.length >= 2) {
+                  this.ofCustomSky = Boolean.valueOf(var4[1]);
                }
 
-               for (EnumPlayerModelParts var24 : EnumPlayerModelParts.values()) {
-                  if (var15.equals("modelPart_" + var24.getPartName())) {
-                     this.setModelPartEnabled(var24, "true".equals(var16));
-                  }
+               if (var4[0].equals("ofShowCapes") && var4.length >= 2) {
+                  this.ofShowCapes = Boolean.valueOf(var4[1]);
                }
-            } catch (Exception var11) {
-               LOGGER.warn("Skipping bad option: {}:{}", var15, var16);
-            }
-         }
 
-         KeyBinding.resetKeyBindingArrayAndHash();
-      } catch (Exception var12) {
-         LOGGER.error("Failed to load options", var12);
-      }
-   }
+               if (var4[0].equals("ofNaturalTextures") && var4.length >= 2) {
+                  this.ofNaturalTextures = Boolean.valueOf(var4[1]);
+               }
 
-   private NBTTagCompound dataFix(NBTTagCompound var1) {
-      int var2 = 0;
+               if (var4[0].equals("ofEmissiveTextures") && var4.length >= 2) {
+                  this.ofEmissiveTextures = Boolean.valueOf(var4[1]);
+               }
 
-      try {
-         var2 = Integer.parseInt(var1.getString("version"));
-      } catch (RuntimeException var4) {
-      }
+               if (var4[0].equals("ofLazyChunkLoading") && var4.length >= 2) {
+                  this.ofLazyChunkLoading = Boolean.valueOf(var4[1]);
+               }
 
-      return this.mc.getDataFixer().process(FixTypes.OPTIONS, var1, var2);
-   }
+               if (var4[0].equals("ofRenderRegions") && var4.length >= 2) {
+                  this.ofRenderRegions = Boolean.valueOf(var4[1]);
+               }
 
-   private float parseFloat(String var1) {
-      if ("true".equals(var1)) {
-         return 1.0F;
-      } else {
-         return "false".equals(var1) ? 0.0F : Float.parseFloat(var1);
-      }
-   }
+               if (var4[0].equals("ofSmartAnimations") && var4.length >= 2) {
+                  this.ofSmartAnimations = Boolean.valueOf(var4[1]);
+               }
 
-   public void saveOptions() {
-      PrintWriter var1 = null;
+               if (var4[0].equals("ofDynamicFov") && var4.length >= 2) {
+                  this.ofDynamicFov = Boolean.valueOf(var4[1]);
+               }
 
-      try {
-         var1 = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFile), StandardCharsets.UTF_8));
-         var1.println("version:1343");
-         var1.println("invertYMouse:" + this.invertMouse);
-         var1.println("mouseSensitivity:" + this.mouseSensitivity);
-         var1.println("fov:" + (this.fovSetting - 70.0F) / 40.0F);
-         var1.println("gamma:" + this.gammaSetting);
-         var1.println("saturation:" + this.saturation);
-         var1.println("renderDistance:" + this.renderDistanceChunks);
-         var1.println("guiScale:" + this.guiScale);
-         var1.println("particles:" + this.particleSetting);
-         var1.println("bobView:" + this.viewBobbing);
-         var1.println("anaglyph3d:" + this.anaglyph);
-         var1.println("maxFps:" + this.limitFramerate);
-         var1.println("fboEnable:" + this.fboEnable);
-         var1.println("difficulty:" + this.difficulty.getId());
-         var1.println("fancyGraphics:" + this.fancyGraphics);
-         var1.println("ao:" + this.ambientOcclusion);
-         switch (this.clouds) {
-            case 0:
-               var1.println("renderClouds:false");
-               break;
-            case 1:
-               var1.println("renderClouds:fast");
-               break;
-            case 2:
-               var1.println("renderClouds:true");
-         }
+               if (var4[0].equals("ofAlternateBlocks") && var4.length >= 2) {
+                  this.ofAlternateBlocks = Boolean.valueOf(var4[1]);
+               }
 
-         var1.println("resourcePacks:" + GSON.toJson(this.resourcePacks));
-         var1.println("incompatibleResourcePacks:" + GSON.toJson(this.incompatibleResourcePacks));
-         var1.println("lastServer:" + this.lastServer);
-         var1.println("lang:" + this.language);
-         var1.println("chatVisibility:" + this.chatVisibility.getChatVisibility());
-         var1.println("chatColors:" + this.chatColours);
-         var1.println("chatLinks:" + this.chatLinks);
-         var1.println("chatLinksPrompt:" + this.chatLinksPrompt);
-         var1.println("chatOpacity:" + this.chatOpacity);
-         var1.println("snooperEnabled:" + this.snooperEnabled);
-         var1.println("fullscreen:" + this.fullScreen);
-         var1.println("enableVsync:" + this.enableVsync);
-         var1.println("useVbo:" + this.useVbo);
-         var1.println("hideServerAddress:" + this.hideServerAddress);
-         var1.println("advancedItemTooltips:" + this.advancedItemTooltips);
-         var1.println("pauseOnLostFocus:" + this.pauseOnLostFocus);
-         var1.println("touchscreen:" + this.touchscreen);
-         var1.println("overrideWidth:" + this.overrideWidth);
-         var1.println("overrideHeight:" + this.overrideHeight);
-         var1.println("heldItemTooltips:" + this.heldItemTooltips);
-         var1.println("chatHeightFocused:" + this.chatHeightFocused);
-         var1.println("chatHeightUnfocused:" + this.chatHeightUnfocused);
-         var1.println("chatScale:" + this.chatScale);
-         var1.println("chatWidth:" + this.chatWidth);
-         var1.println("mipmapLevels:" + this.mipmapLevels);
-         var1.println("forceUnicodeFont:" + this.forceUnicodeFont);
-         var1.println("reducedDebugInfo:" + this.reducedDebugInfo);
-         var1.println("useNativeTransport:" + this.useNativeTransport);
-         var1.println("entityShadows:" + this.entityShadows);
-         var1.println("mainHand:" + (this.mainHand == EnumHandSide.LEFT ? "left" : "right"));
-         var1.println("attackIndicator:" + this.attackIndicator);
-         var1.println("showSubtitles:" + this.showSubtitles);
-         var1.println("realmsNotifications:" + this.realmsNotifications);
-         var1.println("enableWeakAttacks:" + this.enableWeakAttacks);
-         var1.println("autoJump:" + this.autoJump);
-         var1.println("narrator:" + this.narrator);
-         var1.println("tutorialStep:" + this.tutorialStep.getName());
+               if (var4[0].equals("ofDynamicLights") && var4.length >= 2) {
+                  this.ofDynamicLights = Integer.valueOf(var4[1]);
+                  this.ofDynamicLights = limit(this.ofDynamicLights, OF_DYNAMIC_LIGHTS);
+               }
 
-         for (KeyBinding var5 : this.keyBindings) {
-            var1.println("key_" + var5.getKeyDescription() + ":" + var5.getKeyCode());
-         }
+               if (var4[0].equals("ofScreenshotSize") && var4.length >= 2) {
+                  this.ofScreenshotSize = Integer.valueOf(var4[1]);
+                  this.ofScreenshotSize = Config.limit(this.ofScreenshotSize, 1, 4);
+               }
 
-         for (SoundCategory var17 : SoundCategory.values()) {
-            var1.println("soundCategory_" + var17.getName() + ":" + this.getSoundLevel(var17));
-         }
+               if (var4[0].equals("ofCustomEntityModels") && var4.length >= 2) {
+                  this.ofCustomEntityModels = Boolean.valueOf(var4[1]);
+               }
 
-         for (EnumPlayerModelParts var18 : EnumPlayerModelParts.values()) {
-            var1.println("modelPart_" + var18.getPartName() + ":" + this.setModelParts.contains(var18));
-         }
-      } catch (Exception var9) {
-         LOGGER.error("Failed to save options", var9);
-      } finally {
-         IOUtils.closeQuietly(var1);
-      }
+               if (var4[0].equals("ofCustomGuis") && var4.length >= 2) {
+                  this.ofCustomGuis = Boolean.valueOf(var4[1]);
+               }
 
-      this.sendSettingsToServer();
-   }
+               if (var4[0].equals("ofShowGlErrors") && var4.length >= 2) {
+                  this.ofShowGlErrors = Boolean.valueOf(var4[1]);
+               }
 
-   public float getSoundLevel(SoundCategory var1) {
-      return this.soundLevels.containsKey(var1) ? this.soundLevels.get(var1) : 1.0F;
-   }
+               if (var4[0].equals("ofFullscreenMode") && var4.length >= 2) {
+                  this.ofFullscreenMode = var4[1];
+               }
 
-   public void setSoundLevel(SoundCategory var1, float var2) {
-      this.mc.getSoundHandler().setSoundLevel(var1, var2);
-      this.soundLevels.put(var1, var2);
-   }
+               if (var4[0].equals("ofFastMath") && var4.length >= 2) {
+                  this.ofFastMath = Boolean.valueOf(var4[1]);
+                  MathHelper.fastMath = this.ofFastMath;
+               }
 
-   public void sendSettingsToServer() {
-      if (this.mc.player != null) {
-         int var1 = 0;
+               if (var4[0].equals("ofFastRender") && var4.length >= 2) {
+                  this.ofFastRender = Boolean.valueOf(var4[1]);
+               }
 
-         for (EnumPlayerModelParts var3 : this.setModelParts) {
-            var1 |= var3.getPartMask();
+               if (var4[0].equals("ofTranslucentBlocks") && var4.length >= 2) {
+                  this.ofTranslucentBlocks = Integer.valueOf(var4[1]);
+                  this.ofTranslucentBlocks = Config.limit(this.ofTranslucentBlocks, 0, 2);
+               }
+
+               if (var4[0].equals("key_" + this.ofKeyBindZoom.getKeyDescription())) {
+                  this.ofKeyBindZoom.setKeyCode(Integer.parseInt(var4[1]));
+               }
+            } catch (Exception var5) {
+               Config.dbg("Skipping bad option: " + var3);
+               var5.printStackTrace();
+            }
          }
 
-         this.mc
-            .player
-            .connection
-            .sendPacket(new CPacketClientSettings(this.language, this.renderDistanceChunks, this.chatVisibility, this.chatColours, var1, this.mainHand));
+         KeyUtils.fixKeyConflicts(this.keyBindings, new KeyBinding[]{this.ofKeyBindZoom});
+         KeyBinding.resetKeyBindingArrayAndHash();
+         var2.close();
+      } catch (Exception var6) {
+         Config.warn("Failed to load options");
+         var6.printStackTrace();
       }
    }
 
-   public Set<EnumPlayerModelParts> getModelParts() {
-      return ImmutableSet.copyOf(this.setModelParts);
+   public void saveOfOptions() {
+      try {
+         PrintWriter var1 = new PrintWriter(new OutputStreamWriter(new FileOutputStream(this.optionsFileOF), StandardCharsets.UTF_8));
+         var1.println("ofFogType:" + this.ofFogType);
+         var1.println("ofFogStart:" + this.ofFogStart);
+         var1.println("ofMipmapType:" + this.ofMipmapType);
+         var1.println("ofOcclusionFancy:" + this.ofOcclusionFancy);
+         var1.println("ofSmoothFps:" + this.ofSmoothFps);
+         var1.println("ofSmoothWorld:" + this.ofSmoothWorld);
+         var1.println("ofAoLevel:" + this.ofAoLevel);
+         var1.println("ofClouds:" + this.ofClouds);
+         var1.println("ofCloudsHeight:" + this.ofCloudsHeight);
+         var1.println("ofTrees:" + this.ofTrees);
+         var1.println("ofDroppedItems:" + this.ofDroppedItems);
+         var1.println("ofRain:" + this.ofRain);
+         var1.println("ofAnimatedWater:" + this.ofAnimatedWater);
+         var1.println("ofAnimatedLava:" + this.ofAnimatedLava);
+         var1.println("ofAnimatedFire:" + this.ofAnimatedFire);
+         var1.println("ofAnimatedPortal:" + this.ofAnimatedPortal);
+         var1.println("ofAnimatedRedstone:" + this.ofAnimatedRedstone);
+         var1.println("ofAnimatedExplosion:" + this.ofAnimatedExplosion);
+         var1.println("ofAnimatedFlame:" + this.ofAnimatedFlame);
+         var1.println("ofAnimatedSmoke:" + this.ofAnimatedSmoke);
+         var1.println("ofVoidParticles:" + this.ofVoidParticles);
+         var1.println("ofWaterParticles:" + this.ofWaterParticles);
+         var1.println("ofPortalParticles:" + this.ofPortalParticles);
+         var1.println("ofPotionParticles:" + this.ofPotionParticles);
+         var1.println("ofFireworkParticles:" + this.ofFireworkParticles);
+         var1.println("ofDrippingWaterLava:" + this.ofDrippingWaterLava);
+         var1.println("ofAnimatedTerrain:" + this.ofAnimatedTerrain);
+         var1.println("ofAnimatedTextures:" + this.ofAnimatedTextures);
+         var1.println("ofRainSplash:" + this.ofRainSplash);
+         var1.println("ofLagometer:" + this.ofLagometer);
+         var1.println("ofShowFps:" + this.ofShowFps);
+         var1.println("ofAutoSaveTicks:" + this.ofAutoSaveTicks);
+         var1.println("ofBetterGrass:" + this.ofBetterGrass);
+         var1.println("ofConnectedTextures:" + this.ofConnectedTextures);
+         var1.println("ofWeather:" + this.ofWeather);
+         var1.println("ofSky:" + this.ofSky);
+         var1.println("ofStars:" + this.ofStars);
+         var1.println("ofSunMoon:" + this.ofSunMoon);
+         var1.println("ofVignette:" + this.ofVignette);
+         var1.println("ofChunkUpdates:" + this.ofChunkUpdates);
+         var1.println("ofChunkUpdatesDynamic:" + this.ofChunkUpdatesDynamic);
+         var1.println("ofTime:" + this.ofTime);
+         var1.println("ofClearWater:" + this.ofClearWater);
+         var1.println("ofAaLevel:" + this.ofAaLevel);
+         var1.println("ofAfLevel:" + this.ofAfLevel);
+         var1.println("ofProfiler:" + this.ofProfiler);
+         var1.println("ofBetterSnow:" + this.ofBetterSnow);
+         var1.println("ofSwampColors:" + this.ofSwampColors);
+         var1.println("ofRandomEntities:" + this.ofRandomEntities);
+         var1.println("ofSmoothBiomes:" + this.ofSmoothBiomes);
+         var1.println("ofCustomFonts:" + this.ofCustomFonts);
+         var1.println("ofCustomColors:" + this.ofCustomColors);
+         var1.println("ofCustomItems:" + this.ofCustomItems);
+         var1.println("ofCustomSky:" + this.ofCustomSky);
+         var1.println("ofShowCapes:" + this.ofShowCapes);
+         var1.println("ofNaturalTextures:" + this.ofNaturalTextures);
+         var1.println("ofEmissiveTextures:" + this.ofEmissiveTextures);
+         var1.println("ofLazyChunkLoading:" + this.ofLazyChunkLoading);
+         var1.println("ofRenderRegions:" + this.ofRenderRegions);
+         var1.println("ofSmartAnimations:" + this.ofSmartAnimations);
+         var1.println("ofDynamicFov:" + this.ofDynamicFov);
+         var1.println("ofAlternateBlocks:" + this.ofAlternateBlocks);
+         var1.println("ofDynamicLights:" + this.ofDynamicLights);
+         var1.println("ofScreenshotSize:" + this.ofScreenshotSize);
+         var1.println("ofCustomEntityModels:" + this.ofCustomEntityModels);
+         var1.println("ofCustomGuis:" + this.ofCustomGuis);
+         var1.println("ofShowGlErrors:" + this.ofShowGlErrors);
+         var1.println("ofFullscreenMode:" + this.ofFullscreenMode);
+         var1.println("ofFastMath:" + this.ofFastMath);
+         var1.println("ofFastRender:" + this.ofFastRender);
+         var1.println("ofTranslucentBlocks:" + this.ofTranslucentBlocks);
+         var1.println("key_" + this.ofKeyBindZoom.getKeyDescription() + ":" + this.ofKeyBindZoom.getKeyCode());
+         var1.close();
+      } catch (Exception var2) {
+         Config.warn("Failed to save options");
+         var2.printStackTrace();
+      }
+   }
+
+   private void updateRenderClouds() {
+      switch (this.ofClouds) {
+         case 1:
+            this.clouds = 1;
+            break;
+         case 2:
+            this.clouds = 2;
+            break;
+         case 3:
+            this.clouds = 0;
+            break;
+         default:
+            if (this.fancyGraphics) {
+               this.clouds = 2;
+            } else {
+               this.clouds = 1;
+            }
+      }
    }
 
-   public void setModelPartEnabled(EnumPlayerModelParts var1, boolean var2) {
-      if (var2) {
-         this.setModelParts.add(var1);
+   public void resetSettings() {
+      this.renderDistanceChunks = 8;
+      this.viewBobbing = true;
+      this.anaglyph = false;
+      this.limitFramerate = (int)GameSettings.Options.FRAMERATE_LIMIT.getValueMax();
+      this.enableVsync = false;
+      this.updateVSync();
+      this.mipmapLevels = 4;
+      this.fancyGraphics = true;
+      this.ambientOcclusion = 2;
+      this.clouds = 2;
+      this.fovSetting = 70.0F;
+      this.gammaSetting = 0.0F;
+      this.guiScale = 0;
+      this.particleSetting = 0;
+      this.heldItemTooltips = true;
+      this.useVbo = false;
+      this.forceUnicodeFont = false;
+      this.ofFogType = 1;
+      this.ofFogStart = 0.8F;
+      this.ofMipmapType = 0;
+      this.ofOcclusionFancy = false;
+      this.ofSmartAnimations = false;
+      this.ofSmoothFps = false;
+      Config.updateAvailableProcessors();
+      this.ofSmoothWorld = Config.isSingleProcessor();
+      this.ofLazyChunkLoading = false;
+      this.ofRenderRegions = false;
+      this.ofFastMath = false;
+      this.ofFastRender = false;
+      this.ofTranslucentBlocks = 0;
+      this.ofDynamicFov = true;
+      this.ofAlternateBlocks = true;
+      this.ofDynamicLights = 3;
+      this.ofScreenshotSize = 1;
+      this.ofCustomEntityModels = true;
+      this.ofCustomGuis = true;
+      this.ofShowGlErrors = true;
+      this.ofAoLevel = 1.0F;
+      this.ofAaLevel = 0;
+      this.ofAfLevel = 1;
+      this.ofClouds = 0;
+      this.ofCloudsHeight = 0.0F;
+      this.ofTrees = 0;
+      this.ofRain = 0;
+      this.ofBetterGrass = 3;
+      this.ofAutoSaveTicks = 4000;
+      this.ofLagometer = false;
+      this.ofShowFps = false;
+      this.ofProfiler = false;
+      this.ofWeather = true;
+      this.ofSky = true;
+      this.ofStars = true;
+      this.ofSunMoon = true;
+      this.ofVignette = 0;
+      this.ofChunkUpdates = 1;
+      this.ofChunkUpdatesDynamic = false;
+      this.ofTime = 0;
+      this.ofClearWater = false;
+      this.ofBetterSnow = false;
+      this.ofFullscreenMode = "Default";
+      this.ofSwampColors = true;
+      this.ofRandomEntities = true;
+      this.ofSmoothBiomes = true;
+      this.ofCustomFonts = true;
+      this.ofCustomColors = true;
+      this.ofCustomItems = true;
+      this.ofCustomSky = true;
+      this.ofShowCapes = true;
+      this.ofConnectedTextures = 2;
+      this.ofNaturalTextures = false;
+      this.ofEmissiveTextures = true;
+      this.ofAnimatedWater = 0;
+      this.ofAnimatedLava = 0;
+      this.ofAnimatedFire = true;
+      this.ofAnimatedPortal = true;
+      this.ofAnimatedRedstone = true;
+      this.ofAnimatedExplosion = true;
+      this.ofAnimatedFlame = true;
+      this.ofAnimatedSmoke = true;
+      this.ofVoidParticles = true;
+      this.ofWaterParticles = true;
+      this.ofRainSplash = true;
+      this.ofPortalParticles = true;
+      this.ofPotionParticles = true;
+      this.ofFireworkParticles = true;
+      this.ofDrippingWaterLava = true;
+      this.ofAnimatedTerrain = true;
+      this.ofAnimatedTextures = true;
+      Shaders.setShaderPack("OFF");
+      Shaders.configAntialiasingLevel = 0;
+      Shaders.uninit();
+      Shaders.storeConfig();
+      this.updateWaterOpacity();
+      this.mc.refreshResources();
+      this.saveOptions();
+   }
+
+   public void updateVSync() {
+      Display.setVSyncEnabled(this.enableVsync);
+   }
+
+   private void updateWaterOpacity() {
+      if (Config.isIntegratedServerRunning()) {
+         Config.waterOpacityChanged = true;
+      }
+
+      ClearWater.updateWaterOpacity(this, this.mc.world);
+   }
+
+   public void setAllAnimations(boolean var1) {
+      int var2 = var1 ? 0 : 2;
+      this.ofAnimatedWater = var2;
+      this.ofAnimatedLava = var2;
+      this.ofAnimatedFire = var1;
+      this.ofAnimatedPortal = var1;
+      this.ofAnimatedRedstone = var1;
+      this.ofAnimatedExplosion = var1;
+      this.ofAnimatedFlame = var1;
+      this.ofAnimatedSmoke = var1;
+      this.ofVoidParticles = var1;
+      this.ofWaterParticles = var1;
+      this.ofRainSplash = var1;
+      this.ofPortalParticles = var1;
+      this.ofPotionParticles = var1;
+      this.ofFireworkParticles = var1;
+      this.particleSetting = var1 ? 0 : 2;
+      this.ofDrippingWaterLava = var1;
+      this.ofAnimatedTerrain = var1;
+      this.ofAnimatedTextures = var1;
+   }
+
+   private static int nextValue(int var0, int[] var1) {
+      int var2 = indexOf(var0, var1);
+      if (var2 < 0) {
+         return var1[0];
       } else {
-         this.setModelParts.remove(var1);
+         if (++var2 >= var1.length) {
+            var2 = 0;
+         }
+
+         return var1[var2];
       }
+   }
 
-      this.sendSettingsToServer();
+   private static int limit(int var0, int[] var1) {
+      int var2 = indexOf(var0, var1);
+      return var2 < 0 ? var1[0] : var0;
    }
 
-   public void switchModelPartEnabled(EnumPlayerModelParts var1) {
-      if (this.getModelParts().contains(var1)) {
-         this.setModelParts.remove(var1);
-      } else {
-         this.setModelParts.add(var1);
+   private static int indexOf(int var0, int[] var1) {
+      for (int var2 = 0; var2 < var1.length; var2++) {
+         if (var1[var2] == var0) {
+            return var2;
+         }
       }
 
-      this.sendSettingsToServer();
+      return -1;
    }
 
-   public int shouldRenderClouds() {
-      return this.renderDistanceChunks >= 4 ? this.clouds : 0;
+   private void setForgeKeybindProperties() {
+      if (Reflector.KeyConflictContext_IN_GAME.exists()) {
+         if (Reflector.ForgeKeyBinding_setKeyConflictContext.exists()) {
+            Object var1 = Reflector.getFieldValue(Reflector.KeyConflictContext_IN_GAME);
+            Reflector.call(this.keyBindForward, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindLeft, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindBack, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindRight, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindJump, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindSneak, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindSprint, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindAttack, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindChat, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindPlayerList, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindCommand, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindTogglePerspective, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindSmoothCamera, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+            Reflector.call(this.keyBindSwapHands, Reflector.ForgeKeyBinding_setKeyConflictContext, new Object[]{var1});
+         }
+      }
    }
 
-   public boolean isUsingNativeTransport() {
-      return this.useNativeTransport;
+   public void onGuiClosed() {
+      if (this.needsResourceRefresh) {
+         this.mc.scheduleResourcesRefresh();
+         this.needsResourceRefresh = false;
+      }
    }
 
    public static enum Options {
       INVERT_MOUSE("options.invertMouse", false, true),
       SENSITIVITY("options.sensitivity", true, false),
       FOV("options.fov", true, false, 30.0F, 110.0F, 1.0F),
       GAMMA("options.gamma", true, false),
       SATURATION("options.saturation", true, false),
       RENDER_DISTANCE("options.renderDistance", true, false, 2.0F, 16.0F, 1.0F),
       VIEW_BOBBING("options.viewBobbing", false, true),
       ANAGLYPH("options.anaglyph", false, true),
-      FRAMERATE_LIMIT("options.framerateLimit", true, false, 10.0F, 260.0F, 10.0F),
+      FRAMERATE_LIMIT("options.framerateLimit", true, false, 0.0F, 260.0F, 5.0F),
       FBO_ENABLE("options.fboEnable", false, true),
       RENDER_CLOUDS("options.renderClouds", false, false),
       GRAPHICS("options.graphics", false, false),
       AMBIENT_OCCLUSION("options.ao", false, false),
       GUI_SCALE("options.guiScale", false, false),
       PARTICLES("options.particles", false, false),
@@ -1087,13 +2788,85 @@
       MAIN_HAND("options.mainHand", false, false),
       ATTACK_INDICATOR("options.attackIndicator", false, false),
       ENABLE_WEAK_ATTACKS("options.enableWeakAttacks", false, true),
       SHOW_SUBTITLES("options.showSubtitles", false, true),
       REALMS_NOTIFICATIONS("options.realmsNotifications", false, true),
       AUTO_JUMP("options.autoJump", false, true),
-      NARRATOR("options.narrator", false, false);
+      NARRATOR("options.narrator", false, false),
+      FOG_FANCY("of.options.FOG_FANCY", false, false),
+      FOG_START("of.options.FOG_START", false, false),
+      MIPMAP_TYPE("of.options.MIPMAP_TYPE", true, false, 0.0F, 3.0F, 1.0F),
+      SMOOTH_FPS("of.options.SMOOTH_FPS", false, false),
+      CLOUDS("of.options.CLOUDS", false, false),
+      CLOUD_HEIGHT("of.options.CLOUD_HEIGHT", true, false),
+      TREES("of.options.TREES", false, false),
+      RAIN("of.options.RAIN", false, false),
+      ANIMATED_WATER("of.options.ANIMATED_WATER", false, false),
+      ANIMATED_LAVA("of.options.ANIMATED_LAVA", false, false),
+      ANIMATED_FIRE("of.options.ANIMATED_FIRE", false, false),
+      ANIMATED_PORTAL("of.options.ANIMATED_PORTAL", false, false),
+      AO_LEVEL("of.options.AO_LEVEL", true, false),
+      LAGOMETER("of.options.LAGOMETER", false, false),
+      SHOW_FPS("of.options.SHOW_FPS", false, false),
+      AUTOSAVE_TICKS("of.options.AUTOSAVE_TICKS", false, false),
+      BETTER_GRASS("of.options.BETTER_GRASS", false, false),
+      ANIMATED_REDSTONE("of.options.ANIMATED_REDSTONE", false, false),
+      ANIMATED_EXPLOSION("of.options.ANIMATED_EXPLOSION", false, false),
+      ANIMATED_FLAME("of.options.ANIMATED_FLAME", false, false),
+      ANIMATED_SMOKE("of.options.ANIMATED_SMOKE", false, false),
+      WEATHER("of.options.WEATHER", false, false),
+      SKY("of.options.SKY", false, false),
+      STARS("of.options.STARS", false, false),
+      SUN_MOON("of.options.SUN_MOON", false, false),
+      VIGNETTE("of.options.VIGNETTE", false, false),
+      CHUNK_UPDATES("of.options.CHUNK_UPDATES", false, false),
+      CHUNK_UPDATES_DYNAMIC("of.options.CHUNK_UPDATES_DYNAMIC", false, false),
+      TIME("of.options.TIME", false, false),
+      CLEAR_WATER("of.options.CLEAR_WATER", false, false),
+      SMOOTH_WORLD("of.options.SMOOTH_WORLD", false, false),
+      VOID_PARTICLES("of.options.VOID_PARTICLES", false, false),
+      WATER_PARTICLES("of.options.WATER_PARTICLES", false, false),
+      RAIN_SPLASH("of.options.RAIN_SPLASH", false, false),
+      PORTAL_PARTICLES("of.options.PORTAL_PARTICLES", false, false),
+      POTION_PARTICLES("of.options.POTION_PARTICLES", false, false),
+      FIREWORK_PARTICLES("of.options.FIREWORK_PARTICLES", false, false),
+      PROFILER("of.options.PROFILER", false, false),
+      DRIPPING_WATER_LAVA("of.options.DRIPPING_WATER_LAVA", false, false),
+      BETTER_SNOW("of.options.BETTER_SNOW", false, false),
+      FULLSCREEN_MODE("of.options.FULLSCREEN_MODE", true, false, 0.0F, Config.getDisplayModes().length, 1.0F),
+      ANIMATED_TERRAIN("of.options.ANIMATED_TERRAIN", false, false),
+      SWAMP_COLORS("of.options.SWAMP_COLORS", false, false),
+      RANDOM_ENTITIES("of.options.RANDOM_ENTITIES", false, false),
+      SMOOTH_BIOMES("of.options.SMOOTH_BIOMES", false, false),
+      CUSTOM_FONTS("of.options.CUSTOM_FONTS", false, false),
+      CUSTOM_COLORS("of.options.CUSTOM_COLORS", false, false),
+      SHOW_CAPES("of.options.SHOW_CAPES", false, false),
+      CONNECTED_TEXTURES("of.options.CONNECTED_TEXTURES", false, false),
+      CUSTOM_ITEMS("of.options.CUSTOM_ITEMS", false, false),
+      AA_LEVEL("of.options.AA_LEVEL", true, false, 0.0F, 16.0F, 1.0F),
+      AF_LEVEL("of.options.AF_LEVEL", true, false, 1.0F, 16.0F, 1.0F),
+      ANIMATED_TEXTURES("of.options.ANIMATED_TEXTURES", false, false),
+      NATURAL_TEXTURES("of.options.NATURAL_TEXTURES", false, false),
+      EMISSIVE_TEXTURES("of.options.EMISSIVE_TEXTURES", false, false),
+      HELD_ITEM_TOOLTIPS("of.options.HELD_ITEM_TOOLTIPS", false, false),
+      DROPPED_ITEMS("of.options.DROPPED_ITEMS", false, false),
+      LAZY_CHUNK_LOADING("of.options.LAZY_CHUNK_LOADING", false, false),
+      CUSTOM_SKY("of.options.CUSTOM_SKY", false, false),
+      FAST_MATH("of.options.FAST_MATH", false, false),
+      FAST_RENDER("of.options.FAST_RENDER", false, false),
+      TRANSLUCENT_BLOCKS("of.options.TRANSLUCENT_BLOCKS", false, false),
+      DYNAMIC_FOV("of.options.DYNAMIC_FOV", false, false),
+      DYNAMIC_LIGHTS("of.options.DYNAMIC_LIGHTS", false, false),
+      ALTERNATE_BLOCKS("of.options.ALTERNATE_BLOCKS", false, false),
+      CUSTOM_ENTITY_MODELS("of.options.CUSTOM_ENTITY_MODELS", false, false),
+      ADVANCED_TOOLTIPS("of.options.ADVANCED_TOOLTIPS", false, false),
+      SCREENSHOT_SIZE("of.options.SCREENSHOT_SIZE", false, false),
+      CUSTOM_GUIS("of.options.CUSTOM_GUIS", false, false),
+      RENDER_REGIONS("of.options.RENDER_REGIONS", false, false),
+      SHOW_GL_ERRORS("of.options.SHOW_GL_ERRORS", false, false),
+      SMART_ANIMATIONS("of.options.SMART_ANIMATIONS", false, false);
 
       private final boolean isFloat;
       private final boolean isBoolean;
       private final String translation;
       private final float valueStep;
       private float valueMin;
--- net/minecraft/client/settings/HotbarSnapshot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/settings/HotbarSnapshot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/settings/KeyBinding.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/settings/KeyBinding.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/Framebuffer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/Framebuffer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/Shader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/Shader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderDefault.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderDefault.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderGroup.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderGroup.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderLinkHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderLinkHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderLoader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderLoader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/shader/ShaderUniform.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/shader/ShaderUniform.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/CompletedTutorialStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/CompletedTutorialStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/CraftPlanksStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/CraftPlanksStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/FindTreeStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/FindTreeStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/ITutorialStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/ITutorialStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/MovementStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/MovementStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/OpenInventoryStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/OpenInventoryStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/PunchTreeStep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/PunchTreeStep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/Tutorial.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/Tutorial.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/tutorial/TutorialSteps.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/tutorial/TutorialSteps.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/ISearchTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/ISearchTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/ITooltipFlag.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/ITooltipFlag.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/JsonBlendingMode.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/JsonBlendingMode.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/JsonException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/JsonException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/RecipeBookClient.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/RecipeBookClient.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/RecipeItemHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/RecipeItemHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/SearchTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/SearchTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/SearchTreeManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/SearchTreeManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/util/SuffixArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/client/util/SuffixArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/client/AnvilConverterException.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/AnvilConverterException.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/ClientBrandRetriever.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/ClientBrandRetriever.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/client/LoadingScreenRenderer.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/LoadingScreenRenderer.java	Mon Aug 18 09:39:52 2025
@@ -7,12 +7,15 @@
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.Tessellator;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.MinecraftError;
+import net.optifine.CustomLoadingScreen;
+import net.optifine.CustomLoadingScreens;
+import net.optifine.reflect.Reflector;
 
 public class LoadingScreenRenderer implements IProgressUpdate {
    private String message = "";
    private final Minecraft mc;
    private String currentlyDisplayedText = "";
    private long systemTime = Minecraft.getSystemTime();
@@ -24,19 +27,17 @@
       this.mc = var1;
       this.scaledResolution = new ScaledResolution(var1);
       this.framebuffer = new Framebuffer(var1.displayWidth, var1.displayHeight, false);
       this.framebuffer.setFramebufferFilter(9728);
    }
 
-   @Override
    public void resetProgressAndMessage(String var1) {
       this.loadingSuccess = false;
       this.displayString(var1);
    }
 
-   @Override
    public void displaySavingString(String var1) {
       this.loadingSuccess = true;
       this.displayString(var1);
    }
 
    private void displayString(String var1) {
@@ -60,13 +61,12 @@
          GlStateManager.matrixMode(5888);
          GlStateManager.loadIdentity();
          GlStateManager.translate(0.0F, 0.0F, -200.0F);
       }
    }
 
-   @Override
    public void displayLoadingString(String var1) {
       if (!this.mc.running) {
          if (!this.loadingSuccess) {
             throw new MinecraftError();
          }
       } else {
@@ -74,13 +74,12 @@
          this.message = var1;
          this.setLoadingProgress(-1);
          this.systemTime = 0L;
       }
    }
 
-   @Override
    public void setLoadingProgress(int var1) {
       if (!this.mc.running) {
          if (!this.loadingSuccess) {
             throw new MinecraftError();
          }
       } else {
@@ -105,67 +104,85 @@
             GlStateManager.loadIdentity();
             GlStateManager.translate(0.0F, 0.0F, -200.0F);
             if (!OpenGlHelper.isFramebufferEnabled()) {
                GlStateManager.clear(16640);
             }
 
-            Tessellator var8 = Tessellator.getInstance();
-            BufferBuilder var9 = var8.getBuffer();
-            this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
-            float var10 = 32.0F;
-            var9.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
-            var9.pos(0.0, var7, 0.0).tex(0.0, var7 / 32.0F).color(64, 64, 64, 255).endVertex();
-            var9.pos(var6, var7, 0.0).tex(var6 / 32.0F, var7 / 32.0F).color(64, 64, 64, 255).endVertex();
-            var9.pos(var6, 0.0, 0.0).tex(var6 / 32.0F, 0.0).color(64, 64, 64, 255).endVertex();
-            var9.pos(0.0, 0.0, 0.0).tex(0.0, 0.0).color(64, 64, 64, 255).endVertex();
-            var8.draw();
-            if (var1 >= 0) {
-               byte var11 = 100;
-               byte var12 = 2;
-               int var13 = var6 / 2 - 50;
-               int var14 = var7 / 2 + 16;
-               GlStateManager.disableTexture2D();
-               var9.begin(7, DefaultVertexFormats.POSITION_COLOR);
-               var9.pos(var13, var14, 0.0).color(128, 128, 128, 255).endVertex();
-               var9.pos(var13, var14 + 2, 0.0).color(128, 128, 128, 255).endVertex();
-               var9.pos(var13 + 100, var14 + 2, 0.0).color(128, 128, 128, 255).endVertex();
-               var9.pos(var13 + 100, var14, 0.0).color(128, 128, 128, 255).endVertex();
-               var9.pos(var13, var14, 0.0).color(128, 255, 128, 255).endVertex();
-               var9.pos(var13, var14 + 2, 0.0).color(128, 255, 128, 255).endVertex();
-               var9.pos(var13 + var1, var14 + 2, 0.0).color(128, 255, 128, 255).endVertex();
-               var9.pos(var13 + var1, var14, 0.0).color(128, 255, 128, 255).endVertex();
-               var8.draw();
-               GlStateManager.enableTexture2D();
-            }
-
-            GlStateManager.enableBlend();
-            GlStateManager.tryBlendFuncSeparate(
-               GlStateManager.SourceFactor.SRC_ALPHA,
-               GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
-               GlStateManager.SourceFactor.ONE,
-               GlStateManager.DestFactor.ZERO
-            );
-            this.mc
-               .fontRenderer
-               .drawStringWithShadow(
-                  this.currentlyDisplayedText, (var6 - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2, var7 / 2 - 4 - 16, 16777215
+            boolean var8 = true;
+            if (Reflector.FMLClientHandler_handleLoadingScreen.exists()) {
+               Object var9 = Reflector.call(Reflector.FMLClientHandler_instance, new Object[0]);
+               if (var9 != null) {
+                  var8 = !Reflector.callBoolean(var9, Reflector.FMLClientHandler_handleLoadingScreen, new Object[]{var4});
+               }
+            }
+
+            if (var8) {
+               Tessellator var17 = Tessellator.getInstance();
+               BufferBuilder var10 = var17.getBuffer();
+               CustomLoadingScreen var11 = CustomLoadingScreens.getCustomLoadingScreen();
+               if (var11 != null) {
+                  var11.drawBackground(var4.getScaledWidth(), var4.getScaledHeight());
+               } else {
+                  this.mc.getTextureManager().bindTexture(Gui.OPTIONS_BACKGROUND);
+                  float var12 = 32.0F;
+                  var10.begin(7, DefaultVertexFormats.POSITION_TEX_COLOR);
+                  var10.pos(0.0, var7, 0.0).tex(0.0, var7 / 32.0F).color(64, 64, 64, 255).endVertex();
+                  var10.pos(var6, var7, 0.0).tex(var6 / 32.0F, var7 / 32.0F).color(64, 64, 64, 255).endVertex();
+                  var10.pos(var6, 0.0, 0.0).tex(var6 / 32.0F, 0.0).color(64, 64, 64, 255).endVertex();
+                  var10.pos(0.0, 0.0, 0.0).tex(0.0, 0.0).color(64, 64, 64, 255).endVertex();
+                  var17.draw();
+               }
+
+               if (var1 >= 0) {
+                  byte var18 = 100;
+                  byte var13 = 2;
+                  int var14 = var6 / 2 - 50;
+                  int var15 = var7 / 2 + 16;
+                  GlStateManager.disableTexture2D();
+                  var10.begin(7, DefaultVertexFormats.POSITION_COLOR);
+                  var10.pos(var14, var15, 0.0).color(128, 128, 128, 255).endVertex();
+                  var10.pos(var14, var15 + 2, 0.0).color(128, 128, 128, 255).endVertex();
+                  var10.pos(var14 + 100, var15 + 2, 0.0).color(128, 128, 128, 255).endVertex();
+                  var10.pos(var14 + 100, var15, 0.0).color(128, 128, 128, 255).endVertex();
+                  var10.pos(var14, var15, 0.0).color(128, 255, 128, 255).endVertex();
+                  var10.pos(var14, var15 + 2, 0.0).color(128, 255, 128, 255).endVertex();
+                  var10.pos(var14 + var1, var15 + 2, 0.0).color(128, 255, 128, 255).endVertex();
+                  var10.pos(var14 + var1, var15, 0.0).color(128, 255, 128, 255).endVertex();
+                  var17.draw();
+                  GlStateManager.enableTexture2D();
+               }
+
+               GlStateManager.enableBlend();
+               GlStateManager.tryBlendFuncSeparate(
+                  GlStateManager.SourceFactor.SRC_ALPHA,
+                  GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
+                  GlStateManager.SourceFactor.ONE,
+                  GlStateManager.DestFactor.ZERO
                );
-            this.mc.fontRenderer.drawStringWithShadow(this.message, (var6 - this.mc.fontRenderer.getStringWidth(this.message)) / 2, var7 / 2 - 4 + 8, 16777215);
+               this.mc
+                  .fontRenderer
+                  .drawStringWithShadow(
+                     this.currentlyDisplayedText, (var6 - this.mc.fontRenderer.getStringWidth(this.currentlyDisplayedText)) / 2, var7 / 2 - 4 - 16, 16777215
+                  );
+               this.mc
+                  .fontRenderer
+                  .drawStringWithShadow(this.message, (var6 - this.mc.fontRenderer.getStringWidth(this.message)) / 2, var7 / 2 - 4 + 8, 16777215);
+            }
+
             this.framebuffer.unbindFramebuffer();
             if (OpenGlHelper.isFramebufferEnabled()) {
                this.framebuffer.framebufferRender(var6 * var5, var7 * var5);
             }
 
             this.mc.updateDisplay();
 
             try {
                Thread.yield();
-            } catch (Exception var15) {
+            } catch (Exception var16) {
             }
          }
       }
    }
 
-   @Override
    public void setDoneWorking() {
    }
 }
--- net/minecraft/client/Minecraft.java	Mon Aug 18 09:39:28 2025
+++ net/minecraft/client/Minecraft.java	Mon Aug 18 09:39:28 2025
--- net/minecraft/command/server/CommandBanIp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandBanIp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandBanPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandBanPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandBroadcast.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandBroadcast.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandDeOp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandDeOp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandEmote.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandEmote.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandListBans.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandListBans.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandListPlayers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandListPlayers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandMessage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandMessage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandMessageRaw.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandMessageRaw.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandOp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandOp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandPardonIp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandPardonIp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandPardonPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandPardonPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandPublishLocalServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandPublishLocalServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSaveAll.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSaveAll.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSaveOff.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSaveOff.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSaveOn.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSaveOn.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandScoreboard.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandScoreboard.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSetBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSetBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSetDefaultSpawnpoint.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSetDefaultSpawnpoint.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandStop.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandStop.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandSummon.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandSummon.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandTeleport.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandTeleport.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandTestFor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandTestFor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandTestForBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandTestForBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/server/CommandWhitelist.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/server/CommandWhitelist.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/AdvancementCommand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/AdvancementCommand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandBlockData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandBlockData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandClearInventory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandClearInventory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandClone.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandClone.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandCompare.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandCompare.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandDebug.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandDebug.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandDefaultGameMode.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandDefaultGameMode.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandDifficulty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandDifficulty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandEnchant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandEnchant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandEntityData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandEntityData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandExecuteAt.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandExecuteAt.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandFill.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandFill.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandFunction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandFunction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandGameMode.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandGameMode.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandGameRule.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandGameRule.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandGive.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandGive.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandHelp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandHelp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandKill.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandKill.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandLocate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandLocate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandNotFoundException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandNotFoundException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandParticle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandParticle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandPlaySound.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandPlaySound.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandReload.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandReload.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandReplaceItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandReplaceItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandResultStats.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandResultStats.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandSenderWrapper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandSenderWrapper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandServerKick.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandServerKick.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandSetPlayerTimeout.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandSetPlayerTimeout.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandSetSpawnpoint.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandSetSpawnpoint.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandShowSeed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandShowSeed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandSpreadPlayers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandSpreadPlayers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandStats.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandStats.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandStopSound.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandStopSound.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandTime.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandTime.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandTitle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandTitle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandToggleDownfall.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandToggleDownfall.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandTP.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandTP.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandTrigger.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandTrigger.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandWeather.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandWeather.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandWorldBorder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandWorldBorder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/CommandXP.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/CommandXP.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/EntityNotFoundException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/EntityNotFoundException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/EntitySelector.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/EntitySelector.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/FunctionObject.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/FunctionObject.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/ICommand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/ICommand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/ICommandListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/ICommandListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/ICommandManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/ICommandManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/ICommandSender.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/ICommandSender.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/InvalidBlockStateException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/InvalidBlockStateException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/NumberInvalidException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/NumberInvalidException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/PlayerNotFoundException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/PlayerNotFoundException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/RecipeCommand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/RecipeCommand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/ServerCommandManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/ServerCommandManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/SyntaxErrorException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/SyntaxErrorException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/command/WrongUsageException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/command/WrongUsageException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/crash/CrashReport.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/crash/CrashReport.java	Mon Aug 18 09:39:52 2025
@@ -11,12 +11,14 @@
 import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.List;
 import net.minecraft.util.ReportedException;
 import net.minecraft.world.gen.layer.IntCache;
+import net.optifine.CrashReporter;
+import net.optifine.reflect.Reflector;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class CrashReport {
@@ -25,12 +27,13 @@
    private final Throwable cause;
    private final CrashReportCategory systemDetailsCategory = new CrashReportCategory(this, "System Details");
    private final List<CrashReportCategory> crashReportSections = Lists.newArrayList();
    private File crashReportFile;
    private boolean firstCategoryInCrashReport = true;
    private StackTraceElement[] stacktrace = new StackTraceElement[0];
+   private boolean reported = false;
 
    public CrashReport(String var1, Throwable var2) {
       this.description = var1;
       this.cause = var2;
       this.populateEnvironment();
    }
@@ -90,12 +93,16 @@
       });
       this.systemDetailsCategory.addDetail("IntCache", new ICrashReportDetail<String>() {
          public String call() throws Exception {
             return IntCache.getCacheSizes();
          }
       });
+      if (Reflector.FMLCommonHandler_enhanceCrashReport.exists()) {
+         Object var1 = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         Reflector.callString(var1, Reflector.FMLCommonHandler_enhanceCrashReport, new Object[]{this, this.systemDetailsCategory});
+      }
    }
 
    public String getDescription() {
       return this.description;
    }
 
@@ -158,14 +165,20 @@
       }
 
       return var4;
    }
 
    public String getCompleteReport() {
+      if (!this.reported) {
+         this.reported = true;
+         CrashReporter.onCrashReport(this, this.systemDetailsCategory);
+      }
+
       StringBuilder var1 = new StringBuilder();
       var1.append("---- Minecraft Crash Report ----\n");
+      Reflector.call(Reflector.CoreModManager_onCrash, new Object[]{var1});
       var1.append("// ");
       var1.append(getWittyComment());
       var1.append("\n\n");
       var1.append("Time: ");
       var1.append(new SimpleDateFormat().format(new Date()));
       var1.append("\n");
@@ -195,26 +208,26 @@
          if (var1.getParentFile() != null) {
             var1.getParentFile().mkdirs();
          }
 
          OutputStreamWriter var2 = null;
 
-         boolean var4;
+         boolean var3;
          try {
             var2 = new OutputStreamWriter(new FileOutputStream(var1), StandardCharsets.UTF_8);
             var2.write(this.getCompleteReport());
             this.crashReportFile = var1;
             return true;
-         } catch (Throwable var8) {
-            LOGGER.error("Could not save crash report to {}", var1, var8);
-            var4 = false;
+         } catch (Throwable var9) {
+            LOGGER.error("Could not save crash report to {}", var1, var9);
+            var3 = false;
          } finally {
             IOUtils.closeQuietly(var2);
          }
 
-         return var4;
+         return var3;
       }
    }
 
    public CrashReportCategory getCategory() {
       return this.systemDetailsCategory;
    }
--- net/minecraft/crash/CrashReportCategory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/crash/CrashReportCategory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/crash/ICrashReportDetail.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/crash/ICrashReportDetail.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/creativetab/CreativeTabs.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/creativetab/CreativeTabs.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/BehaviorDefaultDispenseItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/BehaviorDefaultDispenseItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/BehaviorProjectileDispense.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/BehaviorProjectileDispense.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/IBehaviorDispenseItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/IBehaviorDispenseItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/IBlockSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/IBlockSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/ILocatableSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/ILocatableSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/ILocation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/ILocation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/IPosition.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/IPosition.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/dispenser/PositionImpl.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/dispenser/PositionImpl.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/Enchantment.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/Enchantment.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentArrowDamage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentArrowDamage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentArrowFire.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentArrowFire.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentArrowInfinite.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentArrowInfinite.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentArrowKnockback.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentArrowKnockback.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentBindingCurse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentBindingCurse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentDamage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentDamage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentDigging.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentDigging.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentDurability.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentDurability.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentFireAspect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentFireAspect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentFishingSpeed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentFishingSpeed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentFrostWalker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentFrostWalker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentKnockback.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentKnockback.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentLootBonus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentLootBonus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentMending.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentMending.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentOxygen.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentOxygen.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentProtection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentProtection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentSweepingEdge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentSweepingEdge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentThorns.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentThorns.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentUntouching.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentUntouching.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentVanishingCurse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentVanishingCurse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentWaterWalker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentWaterWalker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnchantmentWaterWorker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnchantmentWaterWorker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/enchantment/EnumEnchantmentType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/enchantment/EnumEnchantmentType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/AbstractAttributeMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/AbstractAttributeMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/AttributeMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/AttributeMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/AttributeModifier.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/AttributeModifier.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/BaseAttribute.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/BaseAttribute.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/IAttribute.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/IAttribute.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/IAttributeInstance.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/IAttributeInstance.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/ModifiableAttributeInstance.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/ModifiableAttributeInstance.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/attributes/RangedAttribute.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/attributes/RangedAttribute.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIAttackMelee.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIAttackMelee.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIAttackRanged.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIAttackRanged.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIAttackRangedBow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIAttackRangedBow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIAvoidEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIAvoidEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIBeg.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIBeg.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIBreakDoor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIBreakDoor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAICreeperSwell.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAICreeperSwell.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIDefendVillage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIDefendVillage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIDoorInteract.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIDoorInteract.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIEatGrass.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIEatGrass.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFindEntityNearest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFindEntityNearest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFindEntityNearestPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFindEntityNearestPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFleeSun.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFleeSun.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFollow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFollow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFollowGolem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFollowGolem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFollowOwner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFollowOwner.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFollowOwnerFlying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFollowOwnerFlying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIFollowParent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIFollowParent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIHarvestFarmland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIHarvestFarmland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIHurtByTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIHurtByTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILandOnOwnersShoulder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILandOnOwnersShoulder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILeapAtTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILeapAtTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILlamaFollowCaravan.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILlamaFollowCaravan.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILookAtTradePlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILookAtTradePlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILookAtVillager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILookAtVillager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAILookIdle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAILookIdle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMoveIndoors.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMoveIndoors.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMoveThroughVillage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMoveThroughVillage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMoveToBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMoveToBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMoveTowardsRestriction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMoveTowardsRestriction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIMoveTowardsTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIMoveTowardsTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAINearestAttackableTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAINearestAttackableTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIOcelotAttack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIOcelotAttack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIOcelotSit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIOcelotSit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIOpenDoor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIOpenDoor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIOwnerHurtByTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIOwnerHurtByTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIOwnerHurtTarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIOwnerHurtTarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIPanic.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIPanic.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIPlay.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIPlay.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIRestrictOpenDoor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIRestrictOpenDoor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIRestrictSun.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIRestrictSun.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIRunAroundLikeCrazy.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIRunAroundLikeCrazy.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAISit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAISit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAISkeletonRiders.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAISkeletonRiders.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAISwimming.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAISwimming.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAITarget.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAITarget.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAITargetNonTamed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAITargetNonTamed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAITasks.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAITasks.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAITempt.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAITempt.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAITradePlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAITradePlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIVillagerInteract.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIVillagerInteract.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIVillagerMate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIVillagerMate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIWander.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIWander.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIWanderAvoidWater.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIWanderAvoidWater.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIWanderAvoidWaterFlying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIWanderAvoidWaterFlying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIWatchClosest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIWatchClosest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIWatchClosest2.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIWatchClosest2.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityAIZombieAttack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityAIZombieAttack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityFlyHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityFlyHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityJumpHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityJumpHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityLookHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityLookHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntityMoveHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntityMoveHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/EntitySenses.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/EntitySenses.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/ai/RandomPositionGenerator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/ai/RandomPositionGenerator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/IPhase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/IPhase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseChargingPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseChargingPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseDying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseDying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseHoldingPattern.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseHoldingPattern.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseHover.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseHover.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseLanding.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseLanding.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseLandingApproach.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseLandingApproach.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseSittingAttacking.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseSittingAttacking.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseSittingBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseSittingBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseSittingFlaming.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseSittingFlaming.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseSittingScanning.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseSittingScanning.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseStrafePlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseStrafePlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/dragon/phase/PhaseTakeoff.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/dragon/phase/PhaseTakeoff.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/EntityDragon.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/EntityDragon.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/boss/EntityWither.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/boss/EntityWither.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/effect/EntityLightningBolt.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/effect/EntityLightningBolt.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/effect/EntityWeatherEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/effect/EntityWeatherEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityArmorStand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityArmorStand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityBoat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityBoat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityEnderCrystal.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityEnderCrystal.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityEnderEye.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityEnderEye.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityEnderPearl.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityEnderPearl.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityExpBottle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityExpBottle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityFallingBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityFallingBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityFireworkRocket.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityFireworkRocket.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityItemFrame.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityItemFrame.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartCommandBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartCommandBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartContainer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartContainer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartEmpty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartEmpty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartFurnace.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartFurnace.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartHopper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartHopper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartMobSpawner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartMobSpawner.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityMinecartTNT.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityMinecartTNT.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityPainting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityPainting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityTNTPrimed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityTNTPrimed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/item/EntityXPOrb.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/item/EntityXPOrb.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/AbstractIllager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/AbstractIllager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/AbstractSkeleton.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/AbstractSkeleton.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityBlaze.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityBlaze.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityCaveSpider.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityCaveSpider.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityCreeper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityCreeper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityElderGuardian.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityElderGuardian.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityEnderman.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityEnderman.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityEndermite.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityEndermite.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityEvoker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityEvoker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityGhast.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityGhast.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityGiantZombie.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityGiantZombie.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityGolem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityGolem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityGuardian.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityGuardian.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityHusk.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityHusk.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityIllusionIllager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityIllusionIllager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityIronGolem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityIronGolem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityMagmaCube.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityMagmaCube.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityMob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityMob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityPigZombie.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityPigZombie.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityPolarBear.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityPolarBear.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityShulker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityShulker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySilverfish.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySilverfish.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySkeleton.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySkeleton.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySlime.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySlime.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySnowman.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySnowman.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySpellcasterIllager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySpellcasterIllager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntitySpider.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntitySpider.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityStray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityStray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityVex.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityVex.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityVindicator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityVindicator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityWitch.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityWitch.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityWitherSkeleton.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityWitherSkeleton.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityZombie.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityZombie.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/EntityZombieVillager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/EntityZombieVillager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/monster/IMob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/monster/IMob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/AbstractChestHorse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/AbstractChestHorse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/AbstractHorse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/AbstractHorse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityAmbientCreature.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityAmbientCreature.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityAnimal.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityAnimal.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityBat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityBat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityChicken.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityChicken.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityCow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityCow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityDonkey.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityDonkey.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityFlying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityFlying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityHorse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityHorse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityLlama.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityLlama.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityMooshroom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityMooshroom.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityMule.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityMule.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityOcelot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityOcelot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityParrot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityParrot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityPig.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityPig.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityRabbit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityRabbit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntitySheep.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntitySheep.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityShoulderRiding.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityShoulderRiding.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntitySkeletonHorse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntitySkeletonHorse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntitySquid.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntitySquid.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityTameable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityTameable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityVillager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityVillager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityWaterMob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityWaterMob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityWolf.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityWolf.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/EntityZombieHorse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/EntityZombieHorse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/HorseArmorType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/HorseArmorType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/passive/IAnimals.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/passive/IAnimals.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/player/EntityPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/player/EntityPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/player/EntityPlayerMP.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/player/EntityPlayerMP.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/player/EnumPlayerModelParts.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/player/EnumPlayerModelParts.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/player/InventoryPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/player/InventoryPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/player/PlayerCapabilities.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/player/PlayerCapabilities.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityDragonFireball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityDragonFireball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityEgg.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityEgg.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityEvokerFangs.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityEvokerFangs.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityFireball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityFireball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityFishHook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityFishHook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityLargeFireball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityLargeFireball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityLlamaSpit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityLlamaSpit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityPotion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityPotion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityShulkerBullet.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityShulkerBullet.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntitySmallFireball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntitySmallFireball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntitySnowball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntitySnowball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntitySpectralArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntitySpectralArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityThrowable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityThrowable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityTippedArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityTippedArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/EntityWitherSkull.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/EntityWitherSkull.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/projectile/ProjectileHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/projectile/ProjectileHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/Entity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/Entity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityAgeable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityAgeable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityAreaEffectCloud.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityAreaEffectCloud.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityBodyHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityBodyHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityCreature.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityCreature.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityFlying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityFlying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityHanging.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityHanging.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityLeashKnot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityLeashKnot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityLiving.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityLiving.java	Mon Aug 18 09:39:52 2025
@@ -2,29 +2,32 @@
 
 import com.google.common.collect.Maps;
 import java.util.Arrays;
 import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
+import java.util.function.BiPredicate;
 import javax.annotation.Nullable;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.ai.EntityAITasks;
 import net.minecraft.entity.ai.EntityJumpHelper;
 import net.minecraft.entity.ai.EntityLookHelper;
 import net.minecraft.entity.ai.EntityMoveHelper;
 import net.minecraft.entity.ai.EntitySenses;
 import net.minecraft.entity.ai.attributes.AttributeModifier;
 import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityMob;
 import net.minecraft.entity.monster.IMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.EntityEquipmentSlot;
+import net.minecraft.inventory.EntityEquipmentSlot.Type;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemArmor;
 import net.minecraft.item.ItemBow;
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.ItemSword;
 import net.minecraft.nbt.NBTTagCompound;
@@ -34,12 +37,13 @@
 import net.minecraft.network.datasync.DataSerializers;
 import net.minecraft.network.datasync.EntityDataManager;
 import net.minecraft.network.play.server.SPacketEntityAttach;
 import net.minecraft.pathfinding.PathNavigate;
 import net.minecraft.pathfinding.PathNavigateGround;
 import net.minecraft.pathfinding.PathNodeType;
+import net.minecraft.scoreboard.Team;
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.EnumHandSide;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.NonNullList;
 import net.minecraft.util.ResourceLocation;
@@ -48,16 +52,19 @@
 import net.minecraft.util.datafix.FixTypes;
 import net.minecraft.util.datafix.walkers.ItemStackDataLists;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumDifficulty;
+import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
+import net.minecraft.world.WorldEntitySpawner;
 import net.minecraft.world.WorldServer;
-import net.minecraft.world.storage.loot.LootContext;
 import net.minecraft.world.storage.loot.LootTable;
+import net.minecraft.world.storage.loot.LootContext.Builder;
+import net.optifine.reflect.Reflector;
 
 public abstract class EntityLiving extends EntityLivingBase {
    private static final DataParameter<Byte> AI_FLAGS = EntityDataManager.createKey(EntityLiving.class, DataSerializers.BYTE);
    public int livingSoundTime;
    protected int experienceValue;
    private final EntityLookHelper lookHelper;
@@ -78,12 +85,14 @@
    private final Map<PathNodeType, Float> mapPathPriority = Maps.newEnumMap(PathNodeType.class);
    private ResourceLocation deathLootTable;
    private long deathLootTableSeed;
    private boolean isLeashed;
    private Entity leashHolder;
    private NBTTagCompound leashNBTTag;
+   private UUID teamUuid = null;
+   private String teamUuidString = null;
 
    public EntityLiving(World var1) {
       super(var1);
       this.tasks = new EntityAITasks(var1 != null && var1.profiler != null ? var1.profiler : null);
       this.targetTasks = new EntityAITasks(var1 != null && var1.profiler != null ? var1.profiler : null);
       this.lookHelper = new EntityLookHelper(this);
@@ -99,13 +108,12 @@
       }
    }
 
    protected void initEntityAI() {
    }
 
-   @Override
    protected void applyEntityAttributes() {
       super.applyEntityAttributes();
       this.getAttributeMap().registerAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(16.0);
    }
 
    protected PathNavigate createNavigator(World var1) {
@@ -149,22 +157,22 @@
    public EntityLivingBase getAttackTarget() {
       return this.attackTarget;
    }
 
    public void setAttackTarget(@Nullable EntityLivingBase var1) {
       this.attackTarget = var1;
+      Reflector.callVoid(Reflector.ForgeHooks_onLivingSetAttackTarget, new Object[]{this, var1});
    }
 
    public boolean canAttackClass(Class<? extends EntityLivingBase> var1) {
       return var1 != EntityGhast.class;
    }
 
    public void eatGrassBonus() {
    }
 
-   @Override
    protected void entityInit() {
       super.entityInit();
       this.dataManager.register(AI_FLAGS, (byte)0);
    }
 
    public int getTalkInterval() {
@@ -175,47 +183,44 @@
       SoundEvent var1 = this.getAmbientSound();
       if (var1 != null) {
          this.playSound(var1, this.getSoundVolume(), this.getSoundPitch());
       }
    }
 
-   @Override
    public void onEntityUpdate() {
       super.onEntityUpdate();
       this.world.profiler.startSection("mobBaseTick");
       if (this.isEntityAlive() && this.rand.nextInt(1000) < this.livingSoundTime++) {
          this.applyEntityAI();
          this.playLivingSound();
       }
 
       this.world.profiler.endSection();
    }
 
-   @Override
    protected void playHurtSound(DamageSource var1) {
       this.applyEntityAI();
       super.playHurtSound(var1);
    }
 
    private void applyEntityAI() {
       this.livingSoundTime = -this.getTalkInterval();
    }
 
-   @Override
    protected int getExperiencePoints(EntityPlayer var1) {
       if (this.experienceValue > 0) {
          int var2 = this.experienceValue;
 
          for (int var3 = 0; var3 < this.inventoryArmor.size(); var3++) {
-            if (!this.inventoryArmor.get(var3).isEmpty() && this.inventoryArmorDropChances[var3] <= 1.0F) {
+            if (!((ItemStack)this.inventoryArmor.get(var3)).isEmpty() && this.inventoryArmorDropChances[var3] <= 1.0F) {
                var2 += 1 + this.rand.nextInt(3);
             }
          }
 
          for (int var4 = 0; var4 < this.inventoryHands.size(); var4++) {
-            if (!this.inventoryHands.get(var4).isEmpty() && this.inventoryHandsDropChances[var4] <= 1.0F) {
+            if (!((ItemStack)this.inventoryHands.get(var4)).isEmpty() && this.inventoryHandsDropChances[var4] <= 1.0F) {
                var2 += 1 + this.rand.nextInt(3);
             }
          }
 
          return var2;
       } else {
@@ -235,45 +240,47 @@
                   EnumParticleTypes.EXPLOSION_NORMAL,
                   this.posX + this.rand.nextFloat() * this.width * 2.0F - this.width - var2 * 10.0,
                   this.posY + this.rand.nextFloat() * this.height - var4 * 10.0,
                   this.posZ + this.rand.nextFloat() * this.width * 2.0F - this.width - var6 * 10.0,
                   var2,
                   var4,
-                  var6
+                  var6,
+                  new int[0]
                );
          }
       } else {
          this.world.setEntityState(this, (byte)20);
       }
    }
 
-   @Override
    public void handleStatusUpdate(byte var1) {
       if (var1 == 20) {
          this.spawnExplosionParticle();
       } else {
          super.handleStatusUpdate(var1);
       }
    }
 
-   @Override
    public void onUpdate() {
-      super.onUpdate();
-      if (!this.world.isRemote) {
-         this.updateLeashedState();
-         if (this.ticksExisted % 5 == 0) {
-            boolean var1 = !(this.getControllingPassenger() instanceof EntityLiving);
-            boolean var2 = !(this.getRidingEntity() instanceof EntityBoat);
-            this.tasks.setControlFlag(1, var1);
-            this.tasks.setControlFlag(4, var1 && var2);
-            this.tasks.setControlFlag(2, var1);
+      if (Config.isSmoothWorld() && this.canSkipUpdate()) {
+         this.onUpdateMinimal();
+      } else {
+         super.onUpdate();
+         if (!this.world.isRemote) {
+            this.updateLeashedState();
+            if (this.ticksExisted % 5 == 0) {
+               boolean var1 = !(this.getControllingPassenger() instanceof EntityLiving);
+               boolean var2 = !(this.getRidingEntity() instanceof EntityBoat);
+               this.tasks.setControlFlag(1, var1);
+               this.tasks.setControlFlag(4, var1 && var2);
+               this.tasks.setControlFlag(2, var1);
+            }
          }
       }
    }
 
-   @Override
    protected float updateDistance(float var1, float var2) {
       this.bodyHelper.updateRenderAngles();
       return var2;
    }
 
    @Nullable
@@ -283,13 +290,12 @@
 
    @Nullable
    protected Item getDropItem() {
       return null;
    }
 
-   @Override
    protected void dropFewItems(boolean var1, int var2) {
       Item var3 = this.getDropItem();
       if (var3 != null) {
          int var4 = this.rand.nextInt(3);
          if (var2 > 0) {
             var4 += this.rand.nextInt(var2 + 1);
@@ -299,16 +305,15 @@
             this.dropItem(var3, 1);
          }
       }
    }
 
    public static void registerFixesMob(DataFixer var0, Class<?> var1) {
-      var0.registerWalker(FixTypes.ENTITY, new ItemStackDataLists(var1, "ArmorItems", "HandItems"));
+      var0.registerWalker(FixTypes.ENTITY, new ItemStackDataLists(var1, new String[]{"ArmorItems", "HandItems"}));
    }
 
-   @Override
    public void writeEntityToNBT(NBTTagCompound var1) {
       super.writeEntityToNBT(var1);
       var1.setBoolean("CanPickUpLoot", this.canPickUpLoot());
       var1.setBoolean("PersistenceRequired", this.persistenceRequired);
       NBTTagList var2 = new NBTTagList();
 
@@ -374,13 +379,12 @@
 
       if (this.isAIDisabled()) {
          var1.setBoolean("NoAI", this.isAIDisabled());
       }
    }
 
-   @Override
    public void readEntityFromNBT(NBTTagCompound var1) {
       super.readEntityFromNBT(var1);
       if (var1.hasKey("CanPickUpLoot", 1)) {
          this.setCanPickUpLoot(var1.getBoolean("CanPickUpLoot"));
       }
 
@@ -433,29 +437,28 @@
 
    @Nullable
    protected ResourceLocation getLootTable() {
       return null;
    }
 
-   @Override
    protected void dropLoot(boolean var1, int var2, DamageSource var3) {
       ResourceLocation var4 = this.deathLootTable;
       if (var4 == null) {
          var4 = this.getLootTable();
       }
 
       if (var4 != null) {
          LootTable var5 = this.world.getLootTableManager().getLootTableFromLocation(var4);
          this.deathLootTable = null;
-         LootContext.Builder var6 = new LootContext.Builder((WorldServer)this.world).withLootedEntity(this).withDamageSource(var3);
+         Builder var6 = new Builder((WorldServer)this.world).withLootedEntity(this).withDamageSource(var3);
          if (var1 && this.attackingPlayer != null) {
             var6 = var6.withPlayer(this.attackingPlayer).withLuck(this.attackingPlayer.getLuck());
          }
 
-         for (ItemStack var9 : var5.generateLootForPools(this.deathLootTableSeed == 0L ? this.rand : new Random(this.deathLootTableSeed), var6.build())) {
-            this.entityDropItem(var9, 0.0F);
+         for (ItemStack var8 : var5.generateLootForPools(this.deathLootTableSeed == 0L ? this.rand : new Random(this.deathLootTableSeed), var6.build())) {
+            this.entityDropItem(var8, 0.0F);
          }
 
          this.dropEquipment(var1, var2);
       } else {
          super.dropLoot(var1, var2, var3);
       }
@@ -470,23 +473,26 @@
    }
 
    public void setMoveStrafing(float var1) {
       this.moveStrafing = var1;
    }
 
-   @Override
    public void setAIMoveSpeed(float var1) {
       super.setAIMoveSpeed(var1);
       this.setMoveForward(var1);
    }
 
-   @Override
    public void onLivingUpdate() {
       super.onLivingUpdate();
       this.world.profiler.startSection("looting");
-      if (!this.world.isRemote && this.canPickUpLoot() && !this.dead && this.world.getGameRules().getBoolean("mobGriefing")) {
+      boolean var1 = this.world.getGameRules().getBoolean("mobGriefing");
+      if (Reflector.ForgeEventFactory_getMobGriefingEvent.exists()) {
+         var1 = Reflector.callBoolean(Reflector.ForgeEventFactory_getMobGriefingEvent, new Object[]{this.world, this});
+      }
+
+      if (!this.world.isRemote && this.canPickUpLoot() && !this.dead && var1) {
          for (EntityItem var3 : this.world.getEntitiesWithinAABB(EntityItem.class, this.getEntityBoundingBox().grow(1.0, 0.0, 1.0))) {
             if (!var3.isDead && !var3.getItem().isEmpty() && !var3.cannotPickup()) {
                this.updateEquipmentIfNeeded(var3);
             }
          }
       }
@@ -497,13 +503,13 @@
    protected void updateEquipmentIfNeeded(EntityItem var1) {
       ItemStack var2 = var1.getItem();
       EntityEquipmentSlot var3 = getSlotForItemStack(var2);
       boolean var4 = true;
       ItemStack var5 = this.getItemStackFromSlot(var3);
       if (!var5.isEmpty()) {
-         if (var3.getSlotType() == EntityEquipmentSlot.Type.HAND) {
+         if (var3.getSlotType() == Type.HAND) {
             if (var2.getItem() instanceof ItemSword && !(var5.getItem() instanceof ItemSword)) {
                var4 = true;
             } else if (var2.getItem() instanceof ItemSword && var5.getItem() instanceof ItemSword) {
                ItemSword var6 = (ItemSword)var2.getItem();
                ItemSword var7 = (ItemSword)var5.getItem();
                if (var6.getAttackDamage() == var7.getAttackDamage()) {
@@ -569,35 +575,41 @@
 
    protected boolean canDespawn() {
       return true;
    }
 
    protected void despawnEntity() {
+      Object var1 = null;
+      Object var2 = Reflector.getFieldValue(Reflector.Event_Result_DEFAULT);
+      Object var3 = Reflector.getFieldValue(Reflector.Event_Result_DENY);
       if (this.persistenceRequired) {
          this.idleTime = 0;
-      } else {
-         EntityPlayer var1 = this.world.getClosestPlayerToEntity(this, -1.0);
-         if (var1 != null) {
-            double var2 = var1.posX - this.posX;
-            double var4 = var1.posY - this.posY;
-            double var6 = var1.posZ - this.posZ;
-            double var8 = var2 * var2 + var4 * var4 + var6 * var6;
-            if (this.canDespawn() && var8 > 16384.0) {
+      } else if ((this.idleTime & 31) != 31 || (var1 = Reflector.call(Reflector.ForgeEventFactory_canEntityDespawn, new Object[]{this})) == var2) {
+         EntityPlayer var4 = this.world.getClosestPlayerToEntity(this, -1.0);
+         if (var4 != null) {
+            double var5 = var4.posX - this.posX;
+            double var7 = var4.posY - this.posY;
+            double var9 = var4.posZ - this.posZ;
+            double var11 = var5 * var5 + var7 * var7 + var9 * var9;
+            if (this.canDespawn() && var11 > 16384.0) {
                this.setDead();
             }
 
-            if (this.idleTime > 600 && this.rand.nextInt(800) == 0 && var8 > 1024.0 && this.canDespawn()) {
+            if (this.idleTime > 600 && this.rand.nextInt(800) == 0 && var11 > 1024.0 && this.canDespawn()) {
                this.setDead();
-            } else if (var8 < 1024.0) {
+            } else if (var11 < 1024.0) {
                this.idleTime = 0;
             }
          }
+      } else if (var1 == var3) {
+         this.idleTime = 0;
+      } else {
+         this.setDead();
       }
    }
 
-   @Override
    protected final void updateEntityActionState() {
       this.idleTime++;
       this.world.profiler.startSection("checkDespawn");
       this.despawnEntity();
       this.world.profiler.endSection();
       this.world.profiler.startSection("sensing");
@@ -642,24 +654,24 @@
    public int getHorizontalFaceSpeed() {
       return 10;
    }
 
    public void faceEntity(Entity var1, float var2, float var3) {
       double var4 = var1.posX - this.posX;
-      double var8 = var1.posZ - this.posZ;
-      double var6;
+      double var6 = var1.posZ - this.posZ;
+      double var8;
       if (var1 instanceof EntityLivingBase) {
          EntityLivingBase var10 = (EntityLivingBase)var1;
-         var6 = var10.posY + var10.getEyeHeight() - (this.posY + this.getEyeHeight());
+         var8 = var10.posY + var10.getEyeHeight() - (this.posY + this.getEyeHeight());
       } else {
-         var6 = (var1.getEntityBoundingBox().minY + var1.getEntityBoundingBox().maxY) / 2.0 - (this.posY + this.getEyeHeight());
+         var8 = (var1.getEntityBoundingBox().minY + var1.getEntityBoundingBox().maxY) / 2.0 - (this.posY + this.getEyeHeight());
       }
 
-      double var14 = MathHelper.sqrt(var4 * var4 + var8 * var8);
-      float var12 = (float)(MathHelper.atan2(var8, var4) * 180.0F / (float)Math.PI) - 90.0F;
-      float var13 = (float)(-(MathHelper.atan2(var6, var14) * 180.0F / (float)Math.PI));
+      double var14 = MathHelper.sqrt(var4 * var4 + var6 * var6);
+      float var12 = (float)(MathHelper.atan2(var6, var4) * (180.0 / Math.PI)) - 90.0F;
+      float var13 = (float)(-(MathHelper.atan2(var8, var14) * (180.0 / Math.PI)));
       this.rotationPitch = this.updateRotation(this.rotationPitch, var13, var3);
       this.rotationYaw = this.updateRotation(this.rotationYaw, var12, var2);
    }
 
    private float updateRotation(float var1, float var2, float var3) {
       float var4 = MathHelper.wrapDegrees(var2 - var1);
@@ -673,13 +685,13 @@
 
       return var1 + var4;
    }
 
    public boolean getCanSpawnHere() {
       IBlockState var1 = this.world.getBlockState(new BlockPos(this).down());
-      return var1.canEntitySpawn(this);
+      return var1.a(this);
    }
 
    public boolean isNotColliding() {
       return !this.world.containsAnyLiquid(this.getEntityBoundingBox())
          && this.world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty()
          && this.world.checkNoEntityCollision(this.getEntityBoundingBox(), this);
@@ -690,13 +702,12 @@
    }
 
    public int getMaxSpawnedInChunk() {
       return 4;
    }
 
-   @Override
    public int getMaxFallHeight() {
       if (this.getAttackTarget() == null) {
          return 3;
       } else {
          int var1 = (int)(this.getHealth() - this.getMaxHealth() * 0.33F);
          var1 -= (3 - this.world.getDifficulty().getId()) * 4;
@@ -705,46 +716,41 @@
          }
 
          return var1 + 3;
       }
    }
 
-   @Override
    public Iterable<ItemStack> getHeldEquipment() {
       return this.inventoryHands;
    }
 
-   @Override
    public Iterable<ItemStack> getArmorInventoryList() {
       return this.inventoryArmor;
    }
 
-   @Override
    public ItemStack getItemStackFromSlot(EntityEquipmentSlot var1) {
       switch (var1.getSlotType()) {
          case HAND:
-            return this.inventoryHands.get(var1.getIndex());
+            return (ItemStack)this.inventoryHands.get(var1.getIndex());
          case ARMOR:
-            return this.inventoryArmor.get(var1.getIndex());
+            return (ItemStack)this.inventoryArmor.get(var1.getIndex());
          default:
             return ItemStack.EMPTY;
       }
    }
 
-   @Override
    public void setItemStackToSlot(EntityEquipmentSlot var1, ItemStack var2) {
       switch (var1.getSlotType()) {
          case HAND:
             this.inventoryHands.set(var1.getIndex(), var2);
             break;
          case ARMOR:
             this.inventoryArmor.set(var1.getIndex(), var2);
       }
    }
 
-   @Override
    protected void dropEquipment(boolean var1, int var2) {
       for (EntityEquipmentSlot var6 : EntityEquipmentSlot.values()) {
          ItemStack var7 = this.getItemStackFromSlot(var6);
          double var8;
          switch (var6.getSlotType()) {
             case HAND:
@@ -784,13 +790,13 @@
             var2++;
          }
 
          boolean var4 = true;
 
          for (EntityEquipmentSlot var8 : EntityEquipmentSlot.values()) {
-            if (var8.getSlotType() == EntityEquipmentSlot.Type.ARMOR) {
+            if (var8.getSlotType() == Type.ARMOR) {
                ItemStack var9 = this.getItemStackFromSlot(var8);
                if (!var4 && this.rand.nextFloat() < var3) {
                   break;
                }
 
                var4 = false;
@@ -803,20 +809,32 @@
             }
          }
       }
    }
 
    public static EntityEquipmentSlot getSlotForItemStack(ItemStack var0) {
+      if (Reflector.ForgeItem_getEquipmentSlot.exists()) {
+         EntityEquipmentSlot var1 = (EntityEquipmentSlot)Reflector.call(var0.getItem(), Reflector.ForgeItem_getEquipmentSlot, new Object[]{var0});
+         if (var1 != null) {
+            return var1;
+         }
+      }
+
       if (var0.getItem() == Item.getItemFromBlock(Blocks.PUMPKIN) || var0.getItem() == Items.SKULL) {
          return EntityEquipmentSlot.HEAD;
       } else if (var0.getItem() instanceof ItemArmor) {
          return ((ItemArmor)var0.getItem()).armorType;
       } else if (var0.getItem() == Items.ELYTRA) {
          return EntityEquipmentSlot.CHEST;
       } else {
-         return var0.getItem() == Items.SHIELD ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
+         boolean var2 = var0.getItem() == Items.SHIELD;
+         if (Reflector.ForgeItem_isShield.exists()) {
+            var2 = Reflector.callBoolean(var0.getItem(), Reflector.ForgeItem_isShield, new Object[]{var0, null});
+         }
+
+         return var2 ? EntityEquipmentSlot.OFFHAND : EntityEquipmentSlot.MAINHAND;
       }
    }
 
    @Nullable
    public static Item getArmorByChance(EntityEquipmentSlot var0, int var1) {
       switch (var0) {
@@ -880,13 +898,13 @@
             EntityEquipmentSlot.MAINHAND,
             EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItemMainhand(), (int)(5.0F + var2 * this.rand.nextInt(18)), false)
          );
       }
 
       for (EntityEquipmentSlot var6 : EntityEquipmentSlot.values()) {
-         if (var6.getSlotType() == EntityEquipmentSlot.Type.ARMOR) {
+         if (var6.getSlotType() == Type.ARMOR) {
             ItemStack var7 = this.getItemStackFromSlot(var6);
             if (!var7.isEmpty() && this.rand.nextFloat() < 0.5F * var2) {
                this.setItemStackToSlot(var6, EnchantmentHelper.addRandomEnchantment(this.rand, var7, (int)(5.0F + var2 * this.rand.nextInt(18)), false));
             }
          }
       }
@@ -932,13 +950,12 @@
    }
 
    public boolean isNoDespawnRequired() {
       return this.persistenceRequired;
    }
 
-   @Override
    public final boolean processInitialInteract(EntityPlayer var1, EnumHand var2) {
       if (this.getLeashed() && this.getLeashHolder() == var1) {
          this.clearLeashed(true, !var1.capabilities.isCreativeMode);
          return true;
       } else {
          ItemStack var3 = var1.getHeldItem(var2);
@@ -978,13 +995,13 @@
          this.leashHolder = null;
          if (!this.world.isRemote && var2) {
             this.dropItem(Items.LEAD, 1);
          }
 
          if (!this.world.isRemote && var1 && this.world instanceof WorldServer) {
-            ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityAttach(this, null));
+            ((WorldServer)this.world).getEntityTracker().sendToTracking(this, new SPacketEntityAttach(this, (Entity)null));
          }
       }
    }
 
    public boolean canBeLeashedTo(EntityPlayer var1) {
       return !this.getLeashed() && !(this instanceof IMob);
@@ -1007,13 +1024,12 @@
 
       if (this.isRiding()) {
          this.dismountRidingEntity();
       }
    }
 
-   @Override
    public boolean startRiding(Entity var1, boolean var2) {
       boolean var3 = super.startRiding(var1, var2);
       if (var3 && this.getLeashed()) {
          this.clearLeashed(true, true);
       }
 
@@ -1022,35 +1038,34 @@
 
    private void recreateLeash() {
       if (this.isLeashed && this.leashNBTTag != null) {
          if (this.leashNBTTag.hasUniqueId("UUID")) {
             UUID var1 = this.leashNBTTag.getUniqueId("UUID");
 
-            for (EntityLivingBase var4 : this.world.getEntitiesWithinAABB(EntityLivingBase.class, this.getEntityBoundingBox().grow(10.0))) {
-               if (var4.getUniqueID().equals(var1)) {
-                  this.setLeashHolder(var4, true);
+            for (EntityLivingBase var3 : this.world.getEntitiesWithinAABB(EntityLivingBase.class, this.getEntityBoundingBox().grow(10.0))) {
+               if (var3.getUniqueID().equals(var1)) {
+                  this.setLeashHolder(var3, true);
                   break;
                }
             }
          } else if (this.leashNBTTag.hasKey("X", 99) && this.leashNBTTag.hasKey("Y", 99) && this.leashNBTTag.hasKey("Z", 99)) {
-            BlockPos var5 = new BlockPos(this.leashNBTTag.getInteger("X"), this.leashNBTTag.getInteger("Y"), this.leashNBTTag.getInteger("Z"));
-            EntityLeashKnot var6 = EntityLeashKnot.getKnotForPosition(this.world, var5);
-            if (var6 == null) {
-               var6 = EntityLeashKnot.createKnot(this.world, var5);
+            BlockPos var4 = new BlockPos(this.leashNBTTag.getInteger("X"), this.leashNBTTag.getInteger("Y"), this.leashNBTTag.getInteger("Z"));
+            EntityLeashKnot var5 = EntityLeashKnot.getKnotForPosition(this.world, var4);
+            if (var5 == null) {
+               var5 = EntityLeashKnot.createKnot(this.world, var4);
             }
 
-            this.setLeashHolder(var6, true);
+            this.setLeashHolder(var5, true);
          } else {
             this.clearLeashed(false, true);
          }
       }
 
       this.leashNBTTag = null;
    }
 
-   @Override
    public boolean replaceItemInInventory(int var1, ItemStack var2) {
       EntityEquipmentSlot var3;
       if (var1 == 98) {
          var3 = EntityEquipmentSlot.MAINHAND;
       } else if (var1 == 99) {
          var3 = EntityEquipmentSlot.OFFHAND;
@@ -1073,52 +1088,108 @@
       } else {
          this.setItemStackToSlot(var3, var2);
          return true;
       }
    }
 
-   @Override
    public boolean canPassengerSteer() {
       return this.canBeSteered() && super.canPassengerSteer();
    }
 
    public static boolean isItemStackInSlot(EntityEquipmentSlot var0, ItemStack var1) {
       EntityEquipmentSlot var2 = getSlotForItemStack(var1);
       return var2 == var0
          || var2 == EntityEquipmentSlot.MAINHAND && var0 == EntityEquipmentSlot.OFFHAND
          || var2 == EntityEquipmentSlot.OFFHAND && var0 == EntityEquipmentSlot.MAINHAND;
    }
 
-   @Override
    public boolean isServerWorld() {
       return super.isServerWorld() && !this.isAIDisabled();
    }
 
    public void setNoAI(boolean var1) {
-      byte var2 = this.dataManager.get(AI_FLAGS);
+      byte var2 = this.dataManager.<Byte>get(AI_FLAGS);
       this.dataManager.set(AI_FLAGS, var1 ? (byte)(var2 | 1) : (byte)(var2 & -2));
    }
 
    public void setLeftHanded(boolean var1) {
-      byte var2 = this.dataManager.get(AI_FLAGS);
+      byte var2 = this.dataManager.<Byte>get(AI_FLAGS);
       this.dataManager.set(AI_FLAGS, var1 ? (byte)(var2 | 2) : (byte)(var2 & -3));
    }
 
    public boolean isAIDisabled() {
-      return (this.dataManager.get(AI_FLAGS) & 1) != 0;
+      return (this.dataManager.<Byte>get(AI_FLAGS) & 1) != 0;
    }
 
    public boolean isLeftHanded() {
-      return (this.dataManager.get(AI_FLAGS) & 2) != 0;
+      return (this.dataManager.<Byte>get(AI_FLAGS) & 2) != 0;
    }
 
-   @Override
    public EnumHandSide getPrimaryHand() {
       return this.isLeftHanded() ? EnumHandSide.LEFT : EnumHandSide.RIGHT;
    }
 
+   private boolean canSkipUpdate() {
+      if (this.isChild()) {
+         return false;
+      } else if (this.hurtTime > 0) {
+         return false;
+      } else if (this.ticksExisted < 20) {
+         return false;
+      } else {
+         World var1 = this.getEntityWorld();
+         if (var1 == null) {
+            return false;
+         } else if (var1.playerEntities.size() != 1) {
+            return false;
+         } else {
+            Entity var2 = (Entity)var1.playerEntities.get(0);
+            double var3 = Math.max(Math.abs(this.posX - var2.posX) - 16.0, 0.0);
+            double var5 = Math.max(Math.abs(this.posZ - var2.posZ) - 16.0, 0.0);
+            double var7 = var3 * var3 + var5 * var5;
+            return !this.isInRangeToRenderDist(var7);
+         }
+      }
+   }
+
+   private void onUpdateMinimal() {
+      this.idleTime++;
+      if (this instanceof EntityMob) {
+         float var1 = this.getBrightness();
+         if (var1 > 0.5F) {
+            this.idleTime += 2;
+         }
+      }
+
+      this.despawnEntity();
+   }
+
+   public Team getTeam() {
+      UUID var1 = this.getUniqueID();
+      if (this.teamUuid != var1) {
+         this.teamUuid = var1;
+         this.teamUuidString = var1.toString();
+      }
+
+      return this.world.getScoreboard().getPlayersTeam(this.teamUuidString);
+   }
+
    public static enum SpawnPlacementType {
       ON_GROUND,
       IN_AIR,
       IN_WATER;
+
+      private final BiPredicate<IBlockAccess, BlockPos> spawnPredicate;
+
+      private SpawnPlacementType() {
+         this.spawnPredicate = null;
+      }
+
+      private SpawnPlacementType(BiPredicate<IBlockAccess, BlockPos> var3) {
+         this.spawnPredicate = var3;
+      }
+
+      public boolean canSpawnAt(World var1, BlockPos var2) {
+         return this.spawnPredicate != null ? this.spawnPredicate.test(var1, var2) : WorldEntitySpawner.canCreatureTypeSpawnBody(this, var1, var2);
+      }
    }
 }
--- net/minecraft/entity/EntityLivingBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityLivingBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntitySpawnPlacementRegistry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntitySpawnPlacementRegistry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityTracker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityTracker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EntityTrackerEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EntityTrackerEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EnumCreatureAttribute.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EnumCreatureAttribute.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/EnumCreatureType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/EnumCreatureType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IEntityLivingData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IEntityLivingData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IEntityMultiPart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IEntityMultiPart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IEntityOwnable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IEntityOwnable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IJumpingMount.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IJumpingMount.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IMerchant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IMerchant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/INpc.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/INpc.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IProjectile.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IProjectile.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/IRangedAttackMob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/IRangedAttackMob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/MoverType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/MoverType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/MultiPartEntityPart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/MultiPartEntityPart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/NpcMerchant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/NpcMerchant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/entity/SharedMonsterAttributes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/entity/SharedMonsterAttributes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/Biomes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/Biomes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/Blocks.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/Blocks.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/Bootstrap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/Bootstrap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/Enchantments.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/Enchantments.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/Items.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/Items.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/MobEffects.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/MobEffects.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/PotionTypes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/PotionTypes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/init/SoundEvents.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/init/SoundEvents.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ClickType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ClickType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/Container.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/Container.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerBeacon.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerBeacon.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerBrewingStand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerBrewingStand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerDispenser.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerDispenser.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerEnchantment.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerEnchantment.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerFurnace.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerFurnace.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerHopper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerHopper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerHorseChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerHorseChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerHorseInventory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerHorseInventory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerMerchant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerMerchant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerRepair.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerRepair.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerShulkerBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerShulkerBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ContainerWorkbench.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ContainerWorkbench.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/EntityEquipmentSlot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/EntityEquipmentSlot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/IContainerListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/IContainerListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/IInventory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/IInventory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/IInventoryChangedListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/IInventoryChangedListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryBasic.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryBasic.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryCrafting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryCrafting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryCraftResult.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryCraftResult.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryEnderChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryEnderChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryLargeChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryLargeChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/InventoryMerchant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/InventoryMerchant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ISidedInventory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ISidedInventory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/ItemStackHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/ItemStackHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/Slot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/Slot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/SlotCrafting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/SlotCrafting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/SlotFurnaceFuel.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/SlotFurnaceFuel.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/SlotFurnaceOutput.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/SlotFurnaceOutput.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/SlotMerchantResult.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/SlotMerchantResult.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/inventory/SlotShulkerBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/inventory/SlotShulkerBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/CraftingManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/CraftingManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/FurnaceRecipes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/FurnaceRecipes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/Ingredient.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/Ingredient.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/IRecipe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/IRecipe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipeBookCloning.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipeBookCloning.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipeFireworks.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipeFireworks.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipeRepairItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipeRepairItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipesArmorDyes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipesArmorDyes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipesBanners.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipesBanners.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipesMapCloning.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipesMapCloning.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipesMapExtending.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipesMapExtending.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/RecipeTippedArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/RecipeTippedArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/ShapedRecipes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/ShapedRecipes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/ShapelessRecipes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/ShapelessRecipes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/ShieldRecipes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/ShieldRecipes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/crafting/ShulkerBoxRecipes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/crafting/ShulkerBoxRecipes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/EnumAction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/EnumAction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/EnumDyeColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/EnumDyeColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/EnumRarity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/EnumRarity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/IItemPropertyGetter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/IItemPropertyGetter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/Item.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/Item.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemAir.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemAir.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemAnvilBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemAnvilBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemAppleGold.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemAppleGold.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemArmor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemArmor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemArmorStand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemArmorStand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemAxe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemAxe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBanner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBanner.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBlockSpecial.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBlockSpecial.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBoat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBoat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBucket.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBucket.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemBucketMilk.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemBucketMilk.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemCarrotOnAStick.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemCarrotOnAStick.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemChorusFruit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemChorusFruit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemClock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemClock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemCloth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemCloth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemCoal.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemCoal.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemColored.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemColored.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemCompass.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemCompass.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemDoor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemDoor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemDye.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemDye.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEgg.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEgg.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemElytra.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemElytra.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEmptyMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEmptyMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEnchantedBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEnchantedBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEndCrystal.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEndCrystal.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEnderEye.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEnderEye.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemEnderPearl.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemEnderPearl.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemExpBottle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemExpBottle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFireball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFireball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFirework.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFirework.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFireworkCharge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFireworkCharge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFishFood.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFishFood.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFishingRod.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFishingRod.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFlintAndSteel.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFlintAndSteel.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemFood.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemFood.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemGlassBottle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemGlassBottle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemHangingEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemHangingEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemHoe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemHoe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemKnowledgeBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemKnowledgeBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemLead.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemLead.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemLeaves.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemLeaves.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemLilyPad.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemLilyPad.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemLingeringPotion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemLingeringPotion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemMapBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemMapBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemMinecart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemMinecart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemMonsterPlacer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemMonsterPlacer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemMultiTexture.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemMultiTexture.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemNameTag.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemNameTag.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemPickaxe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemPickaxe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemPiston.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemPiston.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemPotion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemPotion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemRecord.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemRecord.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemRedstone.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemRedstone.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSaddle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSaddle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSeedFood.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSeedFood.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSeeds.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSeeds.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemShears.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemShears.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemShield.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemShield.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemShulkerBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemShulkerBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSign.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSign.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSimpleFoiled.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSimpleFoiled.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSkull.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSkull.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSlab.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSlab.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSnow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSnow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSnowball.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSnowball.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSoup.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSoup.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSpade.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSpade.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSpectralArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSpectralArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSplashPotion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSplashPotion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemStack.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemStack.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemSword.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemSword.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemTippedArrow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemTippedArrow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemTool.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemTool.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemWritableBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemWritableBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/item/ItemWrittenBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/item/ItemWrittenBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/CompressedStreamTools.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/CompressedStreamTools.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/JsonToNBT.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/JsonToNBT.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTPrimitive.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTPrimitive.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTSizeTracker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTSizeTracker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagByte.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagByte.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagByteArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagByteArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagCompound.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagCompound.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagDouble.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagDouble.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagEnd.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagEnd.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagFloat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagFloat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagInt.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagInt.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagIntArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagIntArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagLong.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagLong.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagLongArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagLongArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagShort.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagShort.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTTagString.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTTagString.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/nbt/NBTUtil.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/nbt/NBTUtil.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/datasync/DataParameter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/datasync/DataParameter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/datasync/DataSerializer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/datasync/DataSerializer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/datasync/DataSerializers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/datasync/DataSerializers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/datasync/EntityDataManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/datasync/EntityDataManager.java	Mon Aug 18 09:39:52 2025
@@ -11,26 +11,31 @@
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
+import net.minecraft.init.Biomes;
 import net.minecraft.network.PacketBuffer;
 import net.minecraft.util.ReportedException;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.biome.Biome;
 import org.apache.commons.lang3.ObjectUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class EntityDataManager {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final Map<Class<? extends Entity>, Integer> NEXT_ID_MAP = Maps.newHashMap();
    private final Entity entity;
    private final Map<Integer, EntityDataManager.DataEntry<?>> entries = Maps.newHashMap();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private boolean empty = true;
    private boolean dirty;
+   public Biome spawnBiome = Biomes.PLAINS;
+   public BlockPos spawnPosition = BlockPos.ORIGIN;
 
    public EntityDataManager(Entity var1) {
       this.entity = var1;
    }
 
    public static <T> DataParameter<T> createKey(Class<? extends Entity> var0, DataSerializer<T> var1) {
@@ -293,10 +298,10 @@
 
       public void setDirty(boolean var1) {
          this.dirty = var1;
       }
 
       public EntityDataManager.DataEntry<T> copy() {
-         return new EntityDataManager.DataEntry<>(this.key, this.key.getSerializer().copyValue(this.value));
+         return new EntityDataManager.DataEntry<>(this.key, (T)this.key.getSerializer().copyValue(this.value));
       }
    }
 }
--- net/minecraft/network/handshake/client/C00Handshake.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/handshake/client/C00Handshake.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/handshake/INetHandlerHandshakeServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/handshake/INetHandlerHandshakeServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/client/CPacketEncryptionResponse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/client/CPacketEncryptionResponse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/client/CPacketLoginStart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/client/CPacketLoginStart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/server/SPacketDisconnect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/server/SPacketDisconnect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/server/SPacketEnableCompression.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/server/SPacketEnableCompression.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/server/SPacketEncryptionRequest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/server/SPacketEncryptionRequest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/server/SPacketLoginSuccess.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/server/SPacketLoginSuccess.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/INetHandlerLoginClient.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/INetHandlerLoginClient.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/login/INetHandlerLoginServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/login/INetHandlerLoginServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketAnimation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketAnimation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketChatMessage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketChatMessage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketClickWindow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketClickWindow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketClientSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketClientSettings.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketClientStatus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketClientStatus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketCloseWindow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketCloseWindow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketConfirmTeleport.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketConfirmTeleport.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketConfirmTransaction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketConfirmTransaction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketCreativeInventoryAction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketCreativeInventoryAction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketCustomPayload.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketCustomPayload.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketEnchantItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketEnchantItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketEntityAction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketEntityAction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketHeldItemChange.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketHeldItemChange.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketInput.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketInput.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketKeepAlive.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketKeepAlive.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlaceRecipe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlaceRecipe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlayerAbilities.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlayerAbilities.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlayerDigging.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlayerDigging.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlayerTryUseItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlayerTryUseItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketPlayerTryUseItemOnBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketPlayerTryUseItemOnBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketRecipeInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketRecipeInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketResourcePackStatus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketResourcePackStatus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketSeenAdvancements.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketSeenAdvancements.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketSpectate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketSpectate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketSteerBoat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketSteerBoat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketTabComplete.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketTabComplete.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketUpdateSign.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketUpdateSign.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketUseEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketUseEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/client/CPacketVehicleMove.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/client/CPacketVehicleMove.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketAdvancementInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketAdvancementInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketAnimation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketAnimation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketBlockAction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketBlockAction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketBlockBreakAnim.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketBlockBreakAnim.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketBlockChange.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketBlockChange.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCamera.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCamera.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketChangeGameState.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketChangeGameState.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketChat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketChat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketChunkData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketChunkData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCloseWindow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCloseWindow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCollectItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCollectItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCombatEvent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCombatEvent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketConfirmTransaction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketConfirmTransaction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCooldown.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCooldown.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCustomPayload.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCustomPayload.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketCustomSound.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketCustomSound.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketDestroyEntities.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketDestroyEntities.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketDisconnect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketDisconnect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketDisplayObjective.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketDisplayObjective.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityAttach.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityAttach.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityEquipment.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityEquipment.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityHeadLook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityHeadLook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityMetadata.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityMetadata.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityProperties.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityProperties.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityStatus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityStatus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityTeleport.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityTeleport.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketEntityVelocity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketEntityVelocity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketExplosion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketExplosion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketHeldItemChange.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketHeldItemChange.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketJoinGame.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketJoinGame.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketKeepAlive.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketKeepAlive.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketMaps.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketMaps.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketMoveVehicle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketMoveVehicle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketMultiBlockChange.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketMultiBlockChange.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketOpenWindow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketOpenWindow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketParticles.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketParticles.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketPlaceGhostRecipe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketPlaceGhostRecipe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketPlayerAbilities.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketPlayerAbilities.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketPlayerListHeaderFooter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketPlayerListHeaderFooter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketPlayerListItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketPlayerListItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketPlayerPosLook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketPlayerPosLook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketRecipeBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketRecipeBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketRemoveEntityEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketRemoveEntityEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketResourcePackSend.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketResourcePackSend.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketRespawn.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketRespawn.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketScoreboardObjective.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketScoreboardObjective.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSelectAdvancementsTab.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSelectAdvancementsTab.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketServerDifficulty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketServerDifficulty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSetExperience.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSetExperience.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSetPassengers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSetPassengers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSetSlot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSetSlot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSignEditorOpen.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSignEditorOpen.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSoundEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSoundEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnExperienceOrb.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnExperienceOrb.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnGlobalEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnGlobalEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnMob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnMob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnObject.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnObject.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnPainting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnPainting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketSpawnPosition.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketSpawnPosition.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketStatistics.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketStatistics.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketTabComplete.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketTabComplete.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketTeams.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketTeams.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketTimeUpdate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketTimeUpdate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketTitle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketTitle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUnloadChunk.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUnloadChunk.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUpdateBossInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUpdateBossInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUpdateHealth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUpdateHealth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUpdateScore.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUpdateScore.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUpdateTileEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUpdateTileEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketUseBed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketUseBed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketWindowItems.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketWindowItems.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketWindowProperty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketWindowProperty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/server/SPacketWorldBorder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/server/SPacketWorldBorder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/INetHandlerPlayClient.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/INetHandlerPlayClient.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/play/INetHandlerPlayServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/play/INetHandlerPlayServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/rcon/RConConsoleSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/rcon/RConConsoleSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/client/CPacketPing.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/client/CPacketPing.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/client/CPacketServerQuery.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/client/CPacketServerQuery.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/server/SPacketPong.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/server/SPacketPong.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/server/SPacketServerInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/server/SPacketServerInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/INetHandlerStatusClient.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/INetHandlerStatusClient.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/status/INetHandlerStatusServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/status/INetHandlerStatusServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/EnumConnectionState.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/EnumConnectionState.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/EnumPacketDirection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/EnumPacketDirection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/INetHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/INetHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/LegacyPingHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/LegacyPingHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NetHandlerPlayServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NetHandlerPlayServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyCompressionDecoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyCompressionDecoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyCompressionEncoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyCompressionEncoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyEncryptingDecoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyEncryptingDecoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyEncryptingEncoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyEncryptingEncoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyEncryptionTranslator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyEncryptionTranslator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyPacketDecoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyPacketDecoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyPacketEncoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyPacketEncoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyVarint21FrameDecoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyVarint21FrameDecoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NettyVarint21FrameEncoder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NettyVarint21FrameEncoder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NetworkManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NetworkManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/NetworkSystem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/NetworkSystem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/Packet.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/Packet.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/PacketBuffer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/PacketBuffer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/PacketThreadUtil.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/PacketThreadUtil.java	Mon Aug 18 09:39:52 2025
@@ -1,17 +1,41 @@
 package net.minecraft.network;
 
+import net.minecraft.network.play.server.SPacketJoinGame;
+import net.minecraft.network.play.server.SPacketPlayerPosLook;
+import net.minecraft.network.play.server.SPacketRespawn;
 import net.minecraft.util.IThreadListener;
 
 public class PacketThreadUtil {
+   public static int lastDimensionId = Integer.MIN_VALUE;
+
    public static <T extends INetHandler> void checkThreadAndEnqueue(final Packet<T> var0, final T var1, IThreadListener var2) throws ThreadQuickExitException {
       if (!var2.isCallingFromMinecraftThread()) {
          var2.addScheduledTask(new Runnable() {
             @Override
             public void run() {
+               PacketThreadUtil.clientPreProcessPacket(var0);
                var0.processPacket(var1);
             }
          });
          throw ThreadQuickExitException.INSTANCE;
+      } else {
+         clientPreProcessPacket(var0);
+      }
+   }
+
+   protected static void clientPreProcessPacket(Packet var0) {
+      if (var0 instanceof SPacketPlayerPosLook) {
+         Config.getRenderGlobal().onPlayerPositionSet();
+      }
+
+      if (var0 instanceof SPacketRespawn) {
+         SPacketRespawn var1 = (SPacketRespawn)var0;
+         lastDimensionId = var1.getDimensionID();
+      } else if (var0 instanceof SPacketJoinGame) {
+         SPacketJoinGame var2 = (SPacketJoinGame)var0;
+         lastDimensionId = var2.getDimension();
+      } else {
+         lastDimensionId = Integer.MIN_VALUE;
       }
    }
 }
--- net/minecraft/network/ServerStatusResponse.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/ServerStatusResponse.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/network/ThreadQuickExitException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/network/ThreadQuickExitException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/FlyingNodeProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/FlyingNodeProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/NodeProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/NodeProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/Path.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/Path.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathFinder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathFinder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathHeap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathHeap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNavigate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNavigate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNavigateClimber.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNavigateClimber.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNavigateFlying.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNavigateFlying.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNavigateGround.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNavigateGround.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNavigateSwimmer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNavigateSwimmer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathNodeType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathNodeType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathPoint.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathPoint.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/PathWorldListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/PathWorldListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/SwimNodeProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/SwimNodeProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/pathfinding/WalkNodeProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/pathfinding/WalkNodeProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/Potion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/Potion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionAbsorption.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionAbsorption.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionAttackDamage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionAttackDamage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionEffect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionEffect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionHealth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionHealth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionHealthBoost.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionHealthBoost.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/potion/PotionUtils.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/potion/PotionUtils.java	Mon Aug 18 09:39:52 2025
@@ -15,12 +15,13 @@
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.Tuple;
 import net.minecraft.util.text.TextFormatting;
 import net.minecraft.util.text.translation.I18n;
+import net.optifine.CustomColors;
 
 public class PotionUtils {
    public static List<PotionEffect> getEffectsFromStack(ItemStack var0) {
       return getEffectsFromTag(var0.getTagCompound());
    }
 
@@ -75,22 +76,26 @@
       return var0 == PotionTypes.EMPTY ? 16253176 : getPotionColorFromEffectList(var0.getEffects());
    }
 
    public static int getPotionColorFromEffectList(Collection<PotionEffect> var0) {
       int var1 = 3694022;
       if (var0.isEmpty()) {
-         return 3694022;
+         return Config.isCustomColors() ? CustomColors.getPotionColor(null, var1) : 3694022;
       } else {
          float var2 = 0.0F;
          float var3 = 0.0F;
          float var4 = 0.0F;
          int var5 = 0;
 
          for (PotionEffect var7 : var0) {
             if (var7.doesShowParticles()) {
                int var8 = var7.getPotion().getLiquidColor();
+               if (Config.isCustomColors()) {
+                  var8 = CustomColors.getPotionColor(var7.getPotion(), var8);
+               }
+
                int var9 = var7.getAmplifier() + 1;
                var2 += var9 * (var8 >> 16 & 0xFF) / 255.0F;
                var3 += var9 * (var8 >> 8 & 0xFF) / 255.0F;
                var4 += var9 * (var8 >> 0 & 0xFF) / 255.0F;
                var5 += var9;
             }
@@ -113,19 +118,19 @@
 
    public static PotionType getPotionTypeFromNBT(@Nullable NBTTagCompound var0) {
       return var0 == null ? PotionTypes.EMPTY : PotionType.getPotionTypeForName(var0.getString("Potion"));
    }
 
    public static ItemStack addPotionToItemStack(ItemStack var0, PotionType var1) {
-      ResourceLocation var2 = PotionType.REGISTRY.getNameForObject(var1);
+      ResourceLocation var2 = (ResourceLocation)PotionType.REGISTRY.getNameForObject(var1);
       if (var1 == PotionTypes.EMPTY) {
          if (var0.hasTagCompound()) {
             NBTTagCompound var3 = var0.getTagCompound();
             var3.removeTag("Potion");
             if (var3.isEmpty()) {
-               var0.setTagCompound(null);
+               var0.setTagCompound((NBTTagCompound)null);
             }
          }
       } else {
          NBTTagCompound var4 = var0.hasTagCompound() ? var0.getTagCompound() : new NBTTagCompound();
          var4.setString("Potion", var2.toString());
          var0.setTagCompound(var4);
@@ -165,13 +170,13 @@
             if (!var9.isEmpty()) {
                for (Entry var11 : var9.entrySet()) {
                   AttributeModifier var12 = (AttributeModifier)var11.getValue();
                   AttributeModifier var13 = new AttributeModifier(
                      var12.getName(), var8.getAttributeModifierAmount(var6.getAmplifier(), var12), var12.getOperation()
                   );
-                  var4.add(new Tuple<>(((IAttribute)var11.getKey()).getName(), var13));
+                  var4.add(new Tuple(((IAttribute)var11.getKey()).getName(), var13));
                }
             }
 
             if (var6.getAmplifier() > 0) {
                var7 = var7 + " " + I18n.translateToLocal("potion.potency." + var6.getAmplifier()).trim();
             }
--- net/minecraft/profiler/ISnooperInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/profiler/ISnooperInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/profiler/Profiler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/profiler/Profiler.java	Mon Aug 18 09:39:52 2025
@@ -4,132 +4,183 @@
 import com.google.common.collect.Maps;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Supplier;
+import net.minecraft.client.renderer.GlStateManager;
+import net.optifine.Lagometer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class Profiler {
    private static final Logger LOGGER = LogManager.getLogger();
    private final List<String> sectionList = Lists.newArrayList();
    private final List<Long> timestampList = Lists.newArrayList();
    public boolean profilingEnabled;
    private String profilingSection = "";
    private final Map<String, Long> profilingMap = Maps.newHashMap();
+   public boolean profilerGlobalEnabled = true;
+   private boolean profilerLocalEnabled = this.profilerGlobalEnabled;
+   private static final String SCHEDULED_EXECUTABLES = "scheduledExecutables";
+   private static final String TICK = "tick";
+   private static final String PRE_RENDER_ERRORS = "preRenderErrors";
+   private static final String RENDER = "render";
+   private static final String DISPLAY = "display";
+   private static final int HASH_SCHEDULED_EXECUTABLES = "scheduledExecutables".hashCode();
+   private static final int HASH_TICK = "tick".hashCode();
+   private static final int HASH_PRE_RENDER_ERRORS = "preRenderErrors".hashCode();
+   private static final int HASH_RENDER = "render".hashCode();
+   private static final int HASH_DISPLAY = "display".hashCode();
 
    public void clearProfiling() {
       this.profilingMap.clear();
       this.profilingSection = "";
       this.sectionList.clear();
+      this.profilerLocalEnabled = this.profilerGlobalEnabled;
    }
 
    public void startSection(String var1) {
-      if (this.profilingEnabled) {
-         if (!this.profilingSection.isEmpty()) {
-            this.profilingSection = this.profilingSection + ".";
+      if (Lagometer.isActive()) {
+         int var2 = var1.hashCode();
+         if (var2 == HASH_SCHEDULED_EXECUTABLES && var1.equals("scheduledExecutables")) {
+            Lagometer.timerScheduledExecutables.start();
+         } else if (var2 == HASH_TICK && var1.equals("tick") && Config.isMinecraftThread()) {
+            Lagometer.timerScheduledExecutables.end();
+            Lagometer.timerTick.start();
+         } else if (var2 == HASH_PRE_RENDER_ERRORS && var1.equals("preRenderErrors")) {
+            Lagometer.timerTick.end();
+         }
+      }
+
+      if (Config.isFastRender()) {
+         int var3 = var1.hashCode();
+         if (var3 == HASH_RENDER && var1.equals("render")) {
+            GlStateManager.clearEnabled = false;
+         } else if (var3 == HASH_DISPLAY && var1.equals("display")) {
+            GlStateManager.clearEnabled = true;
          }
+      }
+
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            if (!this.profilingSection.isEmpty()) {
+               this.profilingSection = this.profilingSection + ".";
+            }
 
-         this.profilingSection = this.profilingSection + var1;
-         this.sectionList.add(this.profilingSection);
-         this.timestampList.add(System.nanoTime());
+            this.profilingSection = this.profilingSection + var1;
+            this.sectionList.add(this.profilingSection);
+            this.timestampList.add(System.nanoTime());
+         }
       }
    }
 
    public void func_194340_a(Supplier<String> var1) {
-      if (this.profilingEnabled) {
-         this.startSection((String)var1.get());
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            this.startSection((String)var1.get());
+         }
       }
    }
 
    public void endSection() {
-      if (this.profilingEnabled) {
-         long var1 = System.nanoTime();
-         long var3 = this.timestampList.remove(this.timestampList.size() - 1);
-         this.sectionList.remove(this.sectionList.size() - 1);
-         long var5 = var1 - var3;
-         if (this.profilingMap.containsKey(this.profilingSection)) {
-            this.profilingMap.put(this.profilingSection, this.profilingMap.get(this.profilingSection) + var5);
-         } else {
-            this.profilingMap.put(this.profilingSection, var5);
-         }
+      if (this.profilerLocalEnabled) {
+         if (this.profilingEnabled) {
+            long var1 = System.nanoTime();
+            long var3 = this.timestampList.remove(this.timestampList.size() - 1);
+            this.sectionList.remove(this.sectionList.size() - 1);
+            long var5 = var1 - var3;
+            if (this.profilingMap.containsKey(this.profilingSection)) {
+               this.profilingMap.put(this.profilingSection, this.profilingMap.get(this.profilingSection) + var5);
+            } else {
+               this.profilingMap.put(this.profilingSection, var5);
+            }
 
-         if (var5 > 100000000L) {
-            LOGGER.warn("Something's taking too long! '{}' took aprox {} ms", this.profilingSection, var5 / 1000000.0);
-         }
+            if (var5 > 100000000L) {
+               LOGGER.warn("Something's taking too long! '{}' took aprox {} ms", this.profilingSection, var5 / 1000000.0);
+            }
 
-         this.profilingSection = this.sectionList.isEmpty() ? "" : this.sectionList.get(this.sectionList.size() - 1);
+            this.profilingSection = this.sectionList.isEmpty() ? "" : this.sectionList.get(this.sectionList.size() - 1);
+         }
       }
    }
 
    public List<Profiler.Result> getProfilingData(String var1) {
       if (!this.profilingEnabled) {
          return Collections.emptyList();
       } else {
-         String var2 = var1;
-         long var3 = this.profilingMap.containsKey("root") ? this.profilingMap.get("root") : 0L;
-         long var5 = this.profilingMap.containsKey(var1) ? this.profilingMap.get(var1) : -1L;
-         ArrayList var7 = Lists.newArrayList();
+         long var2 = this.profilingMap.containsKey("root") ? this.profilingMap.get("root") : 0L;
+         long var4 = this.profilingMap.containsKey(var1) ? this.profilingMap.get(var1) : -1L;
+         ArrayList var6 = Lists.newArrayList();
          if (!var1.isEmpty()) {
             var1 = var1 + ".";
          }
 
-         long var8 = 0L;
+         long var7 = 0L;
 
-         for (String var11 : this.profilingMap.keySet()) {
-            if (var11.length() > var1.length() && var11.startsWith(var1) && var11.indexOf(".", var1.length() + 1) < 0) {
-               var8 += this.profilingMap.get(var11);
+         for (String var10 : this.profilingMap.keySet()) {
+            if (var10.length() > var1.length() && var10.startsWith(var1) && var10.indexOf(".", var1.length() + 1) < 0) {
+               var7 += this.profilingMap.get(var10);
             }
          }
 
-         float var20 = (float)var8;
-         if (var8 < var5) {
-            var8 = var5;
-         }
-
-         if (var3 < var8) {
-            var3 = var8;
-         }
-
-         for (String var12 : this.profilingMap.keySet()) {
-            if (var12.length() > var1.length() && var12.startsWith(var1) && var12.indexOf(".", var1.length() + 1) < 0) {
-               long var13 = this.profilingMap.get(var12);
-               double var15 = var13 * 100.0 / var8;
-               double var17 = var13 * 100.0 / var3;
-               String var19 = var12.substring(var1.length());
-               var7.add(new Profiler.Result(var19, var15, var17));
+         float var19 = (float)var7;
+         if (var7 < var4) {
+            var7 = var4;
+         }
+
+         if (var2 < var7) {
+            var2 = var7;
+         }
+
+         for (String var11 : this.profilingMap.keySet()) {
+            if (var11.length() > var1.length() && var11.startsWith(var1) && var11.indexOf(".", var1.length() + 1) < 0) {
+               long var12 = this.profilingMap.get(var11);
+               double var14 = var12 * 100.0 / var7;
+               double var16 = var12 * 100.0 / var2;
+               String var18 = var11.substring(var1.length());
+               var6.add(new Profiler.Result(var18, var14, var16));
             }
          }
 
-         for (String var23 : this.profilingMap.keySet()) {
-            this.profilingMap.put(var23, this.profilingMap.get(var23) * 999L / 1000L);
+         for (String var22 : this.profilingMap.keySet()) {
+            this.profilingMap.put(var22, this.profilingMap.get(var22) * 950L / 1000L);
          }
 
-         if ((float)var8 > var20) {
-            var7.add(new Profiler.Result("unspecified", ((float)var8 - var20) * 100.0 / var8, ((float)var8 - var20) * 100.0 / var3));
+         if ((float)var7 > var19) {
+            var6.add(new Profiler.Result("unspecified", ((float)var7 - var19) * 100.0 / var7, ((float)var7 - var19) * 100.0 / var2));
          }
 
-         Collections.sort(var7);
-         var7.add(0, new Profiler.Result(var2, 100.0, var8 * 100.0 / var3));
-         return var7;
+         Collections.sort(var6);
+         var6.add(0, new Profiler.Result(var1, 100.0, var7 * 100.0 / var2));
+         return var6;
       }
    }
 
    public void endStartSection(String var1) {
-      this.endSection();
-      this.startSection(var1);
+      if (this.profilerLocalEnabled) {
+         this.endSection();
+         this.startSection(var1);
+      }
    }
 
    public void func_194339_b(Supplier<String> var1) {
-      this.endSection();
-      this.func_194340_a(var1);
+      if (this.profilerLocalEnabled) {
+         this.endSection();
+         this.func_194340_a(var1);
+      }
    }
 
    public String getNameOfLastSection() {
       return this.sectionList.isEmpty() ? "[UNKNOWN]" : this.sectionList.get(this.sectionList.size() - 1);
+   }
+
+   public void startSection(Class<?> var1) {
+      if (this.profilingEnabled) {
+         this.startSection(var1.getSimpleName());
+      }
    }
 
    public static final class Result implements Comparable<Profiler.Result> {
       public double usePercentage;
       public double totalUsePercentage;
       public String profilerName;
--- net/minecraft/profiler/Snooper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/profiler/Snooper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/DisconnectedRealmsScreen.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/DisconnectedRealmsScreen.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/Realms.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/Realms.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsAnvilLevelStorageSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsAnvilLevelStorageSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsBridge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsBridge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsBufferBuilder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsBufferBuilder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsButton.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsButton.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsClickableScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsClickableScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsConnect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsConnect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsDefaultVertexFormat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsDefaultVertexFormat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsEditBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsEditBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsLevelSummary.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsLevelSummary.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsMth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsMth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsScreen.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsScreen.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsServerAddress.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsServerAddress.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsSharedConstants.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsSharedConstants.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsSimpleScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsSimpleScrolledSelectionList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsSliderButton.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsSliderButton.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsVertexFormat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsVertexFormat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/RealmsVertexFormatElement.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/RealmsVertexFormatElement.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/realms/Tezzelator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/realms/Tezzelator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/IScoreCriteria.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/IScoreCriteria.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/Score.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/Score.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/Scoreboard.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/Scoreboard.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreboardSaveData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreboardSaveData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreCriteria.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreCriteria.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreCriteriaColored.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreCriteriaColored.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreCriteriaHealth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreCriteriaHealth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreCriteriaReadOnly.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreCriteriaReadOnly.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreCriteriaStat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreCriteriaStat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScoreObjective.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScoreObjective.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ScorePlayerTeam.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ScorePlayerTeam.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/ServerScoreboard.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/ServerScoreboard.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/scoreboard/Team.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/scoreboard/Team.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/integrated/IntegratedPlayerList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/integrated/IntegratedPlayerList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/integrated/IntegratedServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/integrated/IntegratedServer.java	Mon Aug 18 09:39:52 2025
@@ -4,45 +4,60 @@
 import com.google.common.util.concurrent.Futures;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import java.io.File;
 import java.io.IOException;
+import java.net.InetAddress;
+import java.util.Arrays;
+import java.util.concurrent.FutureTask;
 import net.minecraft.client.ClientBrandRetriever;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.multiplayer.ThreadLanServerPing;
 import net.minecraft.command.ServerCommandManager;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.PacketThreadUtil;
+import net.minecraft.network.play.server.SPacketChangeGameState;
 import net.minecraft.profiler.Snooper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerProfileCache;
 import net.minecraft.util.CryptManager;
 import net.minecraft.util.HttpUtil;
 import net.minecraft.util.Util;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.EnumDifficulty;
 import net.minecraft.world.GameType;
 import net.minecraft.world.ServerWorldEventHandler;
+import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldServerDemo;
 import net.minecraft.world.WorldServerMulti;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.WorldType;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
+import net.optifine.ClearWater;
+import net.optifine.reflect.Reflector;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class IntegratedServer extends MinecraftServer {
    private static final Logger LOGGER = LogManager.getLogger();
    private final Minecraft mc;
    private final WorldSettings worldSettings;
    private boolean isGamePaused;
    private boolean isPublic;
    private ThreadLanServerPing lanServerPing;
+   private long ticksSaveLast = 0L;
+   public World difficultyUpdateWorld = null;
+   public BlockPos difficultyUpdatePos = null;
+   public DifficultyInstance difficultyLast = null;
 
    public IntegratedServer(
       Minecraft var1,
       String var2,
       String var3,
       WorldSettings var4,
@@ -58,97 +73,152 @@
       this.setDemo(var1.isDemo());
       this.canCreateBonusChest(var4.isBonusChestEnabled());
       this.setBuildLimit(256);
       this.setPlayerList(new IntegratedPlayerList(this));
       this.mc = var1;
       this.worldSettings = this.isDemo() ? WorldServerDemo.DEMO_WORLD_SETTINGS : var4;
+      ISaveHandler var9 = this.getActiveAnvilConverter().getSaveLoader(var2, false);
+      WorldInfo var10 = var9.loadWorldInfo();
+      if (var10 != null) {
+         NBTTagCompound var11 = var10.getPlayerNBTTagCompound();
+         if (var11 != null && var11.hasKey("Dimension")) {
+            int var12 = var11.getInteger("Dimension");
+            PacketThreadUtil.lastDimensionId = var12;
+            this.mc.loadingScreen.setLoadingProgress(-1);
+         }
+      }
    }
 
-   @Override
-   protected ServerCommandManager createCommandManager() {
+   public ServerCommandManager createCommandManager() {
       return new IntegratedServerCommandManager(this);
    }
 
-   @Override
-   protected void loadAllWorlds(String var1, String var2, long var3, WorldType var5, String var6) {
+   public void loadAllWorlds(String var1, String var2, long var3, WorldType var5, String var6) {
       this.convertMapIfNeeded(var1);
-      this.worlds = new WorldServer[3];
-      this.timeOfLastDimensionTick = new long[this.worlds.length][100];
-      ISaveHandler var7 = this.getActiveAnvilConverter().getSaveLoader(var1, true);
-      this.setResourcePackFromWorld(this.getFolderName(), var7);
-      WorldInfo var8 = var7.loadWorldInfo();
-      if (var8 == null) {
-         var8 = new WorldInfo(this.worldSettings, var2);
+      boolean var7 = Reflector.DimensionManager.exists();
+      if (!var7) {
+         this.worlds = new WorldServer[3];
+         this.timeOfLastDimensionTick = new long[this.worlds.length][100];
+      }
+
+      ISaveHandler var8 = this.getActiveAnvilConverter().getSaveLoader(var1, true);
+      this.setResourcePackFromWorld(this.getFolderName(), var8);
+      WorldInfo var9 = var8.loadWorldInfo();
+      if (var9 == null) {
+         var9 = new WorldInfo(this.worldSettings, var2);
       } else {
-         var8.setWorldName(var2);
+         var9.setWorldName(var2);
       }
 
-      for (int var9 = 0; var9 < this.worlds.length; var9++) {
-         byte var10 = 0;
-         if (var9 == 1) {
-            var10 = -1;
+      if (var7) {
+         WorldServer var10 = this.isDemo()
+            ? (WorldServer)new WorldServerDemo(this, var8, var9, 0, this.profiler).b()
+            : (WorldServer)new WorldServer(this, var8, var9, 0, this.profiler).init();
+         var10.initialize(this.worldSettings);
+         Integer[] var11 = (Integer[])Reflector.call(Reflector.DimensionManager_getStaticDimensionIDs, new Object[0]);
+         Integer[] var12 = var11;
+         int var13 = var11.length;
+
+         for (int var14 = 0; var14 < var13; var14++) {
+            int var15 = var12[var14];
+            WorldServer var16 = var15 == 0 ? var10 : (WorldServer)new WorldServerMulti(this, var8, var15, var10, this.profiler).init();
+            var16.addEventListener(new ServerWorldEventHandler(this, var16));
+            if (!this.isSinglePlayer()) {
+               var16.getWorldInfo().setGameType(this.getGameType());
+            }
+
+            if (Reflector.EventBus.exists()) {
+               Reflector.postForgeBusEvent(Reflector.WorldEvent_Load_Constructor, new Object[]{var16});
+            }
          }
 
-         if (var9 == 2) {
-            var10 = 1;
+         this.getPlayerList().setPlayerManager(new WorldServer[]{var10});
+         if (var10.getWorldInfo().getDifficulty() == null) {
+            this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
          }
+      } else {
+         for (int var17 = 0; var17 < this.worlds.length; var17++) {
+            byte var18 = 0;
+            if (var17 == 1) {
+               var18 = -1;
+            }
+
+            if (var17 == 2) {
+               var18 = 1;
+            }
 
-         if (var9 == 0) {
-            if (this.isDemo()) {
-               this.worlds[var9] = (WorldServer)new WorldServerDemo(this, var7, var8, var10, this.profiler).init();
+            if (var17 == 0) {
+               if (this.isDemo()) {
+                  this.worlds[var17] = (WorldServer)new WorldServerDemo(this, var8, var9, var18, this.profiler).b();
+               } else {
+                  this.worlds[var17] = (WorldServer)new WorldServer(this, var8, var9, var18, this.profiler).init();
+               }
+
+               this.worlds[var17].initialize(this.worldSettings);
             } else {
-               this.worlds[var9] = (WorldServer)new WorldServer(this, var7, var8, var10, this.profiler).init();
+               this.worlds[var17] = (WorldServer)new WorldServerMulti(this, var8, var18, this.worlds[0], this.profiler).init();
             }
 
-            this.worlds[var9].initialize(this.worldSettings);
-         } else {
-            this.worlds[var9] = (WorldServer)new WorldServerMulti(this, var7, var10, this.worlds[0], this.profiler).init();
+            this.worlds[var17].addEventListener(new ServerWorldEventHandler(this, this.worlds[var17]));
          }
 
-         this.worlds[var9].addEventListener(new ServerWorldEventHandler(this, this.worlds[var9]));
-      }
-
-      this.getPlayerList().setPlayerManager(this.worlds);
-      if (this.worlds[0].getWorldInfo().getDifficulty() == null) {
-         this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
+         this.getPlayerList().setPlayerManager(this.worlds);
+         if (this.worlds[0].getWorldInfo().getDifficulty() == null) {
+            this.setDifficultyForAllWorlds(this.mc.gameSettings.difficulty);
+         }
       }
 
       this.initialWorldChunkLoad();
    }
 
-   @Override
-   protected boolean init() throws IOException {
+   public boolean init() throws IOException {
       LOGGER.info("Starting integrated minecraft server version 1.12.2");
       this.setOnlineMode(true);
       this.setCanSpawnAnimals(true);
       this.setCanSpawnNPCs(true);
       this.setAllowPvp(true);
       this.setAllowFlight(true);
       LOGGER.info("Generating keypair");
       this.setKeyPair(CryptManager.generateKeyPair());
+      if (Reflector.FMLCommonHandler_handleServerAboutToStart.exists()) {
+         Object var1 = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         if (!Reflector.callBoolean(var1, Reflector.FMLCommonHandler_handleServerAboutToStart, new Object[]{this})) {
+            return false;
+         }
+      }
+
       this.loadAllWorlds(
          this.getFolderName(), this.getWorldName(), this.worldSettings.getSeed(), this.worldSettings.getTerrainType(), this.worldSettings.getGeneratorOptions()
       );
       this.setMOTD(this.getServerOwner() + " - " + this.worlds[0].getWorldInfo().getWorldName());
+      if (Reflector.FMLCommonHandler_handleServerStarting.exists()) {
+         Object var2 = Reflector.call(Reflector.FMLCommonHandler_instance, new Object[0]);
+         if (Reflector.FMLCommonHandler_handleServerStarting.getReturnType() == boolean.class) {
+            return Reflector.callBoolean(var2, Reflector.FMLCommonHandler_handleServerStarting, new Object[]{this});
+         }
+
+         Reflector.callVoid(var2, Reflector.FMLCommonHandler_handleServerStarting, new Object[]{this});
+      }
+
       return true;
    }
 
-   @Override
-   protected void tick() {
+   public void tick() {
+      this.onTick();
       boolean var1 = this.isGamePaused;
       this.isGamePaused = Minecraft.getMinecraft().getConnection() != null && Minecraft.getMinecraft().isGamePaused();
       if (!var1 && this.isGamePaused) {
          LOGGER.info("Saving and pausing game...");
          this.getPlayerList().saveAllPlayerData();
          this.saveAllWorlds(false);
       }
 
       if (this.isGamePaused) {
          synchronized (this.futureTaskQueue) {
             while (!this.futureTaskQueue.isEmpty()) {
-               Util.runTask(this.futureTaskQueue.poll(), LOGGER);
+               Util.runTask((FutureTask)this.futureTaskQueue.poll(), LOGGER);
             }
          }
       } else {
          super.tick();
          if (this.mc.gameSettings.renderDistanceChunks != this.getPlayerList().getViewDistance()) {
             LOGGER.info("Changing view distance to {}, from {}", this.mc.gameSettings.renderDistanceChunks, this.getPlayerList().getViewDistance());
@@ -171,68 +241,66 @@
                }
             }
          }
       }
    }
 
-   @Override
    public boolean canStructuresSpawn() {
       return false;
    }
 
-   @Override
    public GameType getGameType() {
       return this.worldSettings.getGameType();
    }
 
-   @Override
    public EnumDifficulty getDifficulty() {
-      return this.mc.world.getWorldInfo().getDifficulty();
+      return this.mc.world == null ? this.mc.gameSettings.difficulty : this.mc.world.getWorldInfo().getDifficulty();
    }
 
-   @Override
    public boolean isHardcore() {
       return this.worldSettings.getHardcoreEnabled();
    }
 
-   @Override
    public boolean shouldBroadcastRconToOps() {
       return true;
    }
 
-   @Override
    public boolean shouldBroadcastConsoleToOps() {
       return true;
    }
 
-   @Override
-   protected void saveAllWorlds(boolean var1) {
+   public void saveAllWorlds(boolean var1) {
+      if (var1) {
+         int var2 = this.getTickCounter();
+         int var3 = this.mc.gameSettings.ofAutoSaveTicks;
+         if (var2 < this.ticksSaveLast + var3) {
+            return;
+         }
+
+         this.ticksSaveLast = var2;
+      }
+
       super.saveAllWorlds(var1);
    }
 
-   @Override
    public File getDataDirectory() {
       return this.mc.gameDir;
    }
 
-   @Override
    public boolean isDedicatedServer() {
       return false;
    }
 
-   @Override
    public boolean shouldUseNativeTransport() {
       return false;
    }
 
-   @Override
-   protected void finalTick(CrashReport var1) {
+   public void finalTick(CrashReport var1) {
       this.mc.crashed(var1);
    }
 
-   @Override
    public CrashReport addServerInfoToCrashReport(CrashReport var1) {
       var1 = super.addServerInfoToCrashReport(var1);
       var1.getCategory().addDetail("Type", new ICrashReportDetail<String>() {
          public String call() throws Exception {
             return "Integrated Server (map_client.txt)";
          }
@@ -258,32 +326,28 @@
                }
             }
          );
       return var1;
    }
 
-   @Override
    public void setDifficultyForAllWorlds(EnumDifficulty var1) {
       super.setDifficultyForAllWorlds(var1);
       if (this.mc.world != null) {
          this.mc.world.getWorldInfo().setDifficulty(var1);
       }
    }
 
-   @Override
    public void addServerStatsToSnooper(Snooper var1) {
       super.addServerStatsToSnooper(var1);
       var1.addClientStat("snooper_partner", this.mc.getPlayerUsageSnooper().getUniqueID());
    }
 
-   @Override
    public boolean isSnooperEnabled() {
       return Minecraft.getMinecraft().isSnooperEnabled();
    }
 
-   @Override
    public String shareToLAN(GameType var1, boolean var2) {
       try {
          int var3 = -1;
 
          try {
             var3 = HttpUtil.getSuitableLanPort();
@@ -291,13 +355,13 @@
          }
 
          if (var3 <= 0) {
             var3 = 25564;
          }
 
-         this.getNetworkSystem().addEndpoint(null, var3);
+         this.getNetworkSystem().addEndpoint((InetAddress)null, var3);
          LOGGER.info("Started on {}", var3);
          this.isPublic = true;
          this.lanServerPing = new ThreadLanServerPing(this.getMOTD(), var3 + "");
          this.lanServerPing.start();
          this.getPlayerList().setGameType(var1);
          this.getPlayerList().setCommandsAllowedForAll(var2);
@@ -305,54 +369,127 @@
          return var3 + "";
       } catch (IOException var6) {
          return null;
       }
    }
 
-   @Override
    public void stopServer() {
       super.stopServer();
       if (this.lanServerPing != null) {
          this.lanServerPing.interrupt();
          this.lanServerPing = null;
       }
    }
 
-   @Override
    public void initiateShutdown() {
-      Futures.getUnchecked(this.addScheduledTask(new Runnable() {
-         @Override
-         public void run() {
-            for (EntityPlayerMP var3 : Lists.newArrayList(IntegratedServer.this.getPlayerList().getPlayers())) {
-               if (!var3.getUniqueID().equals(IntegratedServer.this.mc.player.getUniqueID())) {
-                  IntegratedServer.this.getPlayerList().playerLoggedOut(var3);
+      if (!Reflector.MinecraftForge.exists() || this.isServerRunning()) {
+         Futures.getUnchecked(this.addScheduledTask(new Runnable() {
+            @Override
+            public void run() {
+               for (EntityPlayerMP var2 : Lists.newArrayList(IntegratedServer.this.getPlayerList().getPlayers())) {
+                  if (!var2.getUniqueID().equals(IntegratedServer.this.mc.player.getUniqueID())) {
+                     IntegratedServer.this.getPlayerList().playerLoggedOut(var2);
+                  }
                }
             }
-         }
-      }));
+         }));
+      }
+
       super.initiateShutdown();
       if (this.lanServerPing != null) {
          this.lanServerPing.interrupt();
          this.lanServerPing = null;
       }
    }
 
    public boolean getPublic() {
       return this.isPublic;
    }
 
-   @Override
    public void setGameType(GameType var1) {
       super.setGameType(var1);
       this.getPlayerList().setGameType(var1);
    }
 
-   @Override
    public boolean isCommandBlockEnabled() {
       return true;
    }
 
-   @Override
    public int getOpPermissionLevel() {
       return 4;
+   }
+
+   private void onTick() {
+      for (WorldServer var3 : Arrays.asList(this.worlds)) {
+         this.onTick(var3);
+      }
+   }
+
+   public DifficultyInstance getDifficultyAsync(World var1, BlockPos var2) {
+      this.difficultyUpdateWorld = var1;
+      this.difficultyUpdatePos = var2;
+      return this.difficultyLast;
+   }
+
+   private void onTick(WorldServer var1) {
+      if (!Config.isTimeDefault()) {
+         this.fixWorldTime(var1);
+      }
+
+      if (!Config.isWeatherEnabled()) {
+         this.fixWorldWeather(var1);
+      }
+
+      if (Config.waterOpacityChanged) {
+         Config.waterOpacityChanged = false;
+         ClearWater.updateWaterOpacity(Config.getGameSettings(), var1);
+      }
+
+      if (this.difficultyUpdateWorld == var1 && this.difficultyUpdatePos != null) {
+         this.difficultyLast = var1.getDifficultyForLocation(this.difficultyUpdatePos);
+         this.difficultyUpdateWorld = null;
+         this.difficultyUpdatePos = null;
+      }
+   }
+
+   private void fixWorldWeather(WorldServer var1) {
+      WorldInfo var2 = var1.getWorldInfo();
+      if (var2.isRaining() || var2.isThundering()) {
+         var2.setRainTime(0);
+         var2.setRaining(false);
+         var1.setRainStrength(0.0F);
+         var2.setThunderTime(0);
+         var2.setThundering(false);
+         var1.setThunderStrength(0.0F);
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(2, 0.0F));
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(7, 0.0F));
+         this.getPlayerList().sendPacketToAllPlayers(new SPacketChangeGameState(8, 0.0F));
+      }
+   }
+
+   private void fixWorldTime(WorldServer var1) {
+      WorldInfo var2 = var1.getWorldInfo();
+      if (var2.getGameType().getID() == 1) {
+         long var3 = var1.getWorldTime();
+         long var5 = var3 % 24000L;
+         if (Config.isTimeDayOnly()) {
+            if (var5 <= 1000L) {
+               var1.setWorldTime(var3 - var5 + 1001L);
+            }
+
+            if (var5 >= 11000L) {
+               var1.setWorldTime(var3 - var5 + 24001L);
+            }
+         }
+
+         if (Config.isTimeNightOnly()) {
+            if (var5 <= 14000L) {
+               var1.setWorldTime(var3 - var5 + 14001L);
+            }
+
+            if (var5 >= 22000L) {
+               var1.setWorldTime(var3 - var5 + 24000L + 14001L);
+            }
+         }
+      }
    }
 }
--- net/minecraft/server/integrated/IntegratedServerCommandManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/integrated/IntegratedServerCommandManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/DemoPlayerInteractionManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/DemoPlayerInteractionManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/PlayerChunkMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PlayerChunkMap.java	Mon Aug 18 09:39:52 2025
@@ -6,23 +6,29 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.PriorityQueue;
 import java.util.Set;
+import java.util.Map.Entry;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.WorldProvider;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.ChunkPosComparator;
 
 public class PlayerChunkMap {
    private static final Predicate<EntityPlayerMP> NOT_SPECTATOR = new Predicate<EntityPlayerMP>() {
       public boolean apply(@Nullable EntityPlayerMP var1) {
          return var1 != null && !var1.isSpectator();
       }
@@ -40,12 +46,13 @@
    private final List<PlayerChunkMapEntry> entriesWithoutChunks = Lists.newLinkedList();
    private final List<PlayerChunkMapEntry> entries = Lists.newArrayList();
    private int playerViewRadius;
    private long previousTotalWorldTime;
    private boolean sortMissingChunks = true;
    private boolean sortSendToPlayers = true;
+   private final Map<EntityPlayerMP, Set<ChunkPos>> mapPlayerPendingEntries = new HashMap<>();
 
    public PlayerChunkMap(WorldServer var1) {
       this.world = var1;
       this.setPlayerViewRadius(var1.getMinecraftServer().getPlayerList().getViewDistance());
    }
 
@@ -78,90 +85,118 @@
             return (Chunk)this.endOfData();
          }
       };
    }
 
    public void tick() {
-      long var1 = this.world.getTotalWorldTime();
-      if (var1 - this.previousTotalWorldTime > 8000L) {
-         this.previousTotalWorldTime = var1;
-
-         for (int var3 = 0; var3 < this.entries.size(); var3++) {
-            PlayerChunkMapEntry var4 = this.entries.get(var3);
-            var4.update();
-            var4.updateChunkInhabitedTime();
+      Set var1 = this.mapPlayerPendingEntries.entrySet();
+      Iterator var2 = var1.iterator();
+
+      while (var2.hasNext()) {
+         Entry var3 = (Entry)var2.next();
+         Set var4 = (Set)var3.getValue();
+         if (!var4.isEmpty()) {
+            EntityPlayerMP var5 = (EntityPlayerMP)var3.getKey();
+            if (var5.getServerWorld() != this.world) {
+               var2.remove();
+            } else {
+               int var6 = this.playerViewRadius / 3 + 1;
+               if (!Config.isLazyChunkLoading()) {
+                  var6 = this.playerViewRadius * 2 + 1;
+               }
+
+               for (ChunkPos var9 : this.getNearest(var4, var5, var6)) {
+                  PlayerChunkMapEntry var10 = this.getOrCreateEntry(var9.x, var9.z);
+                  if (!var10.containsPlayer(var5)) {
+                     var10.addPlayer(var5);
+                  }
+
+                  var4.remove(var9);
+               }
+            }
+         }
+      }
+
+      long var11 = this.world.getTotalWorldTime();
+      if (var11 - this.previousTotalWorldTime > 8000L) {
+         this.previousTotalWorldTime = var11;
+
+         for (int var12 = 0; var12 < this.entries.size(); var12++) {
+            PlayerChunkMapEntry var17 = this.entries.get(var12);
+            var17.update();
+            var17.updateChunkInhabitedTime();
          }
       }
 
       if (!this.dirtyEntries.isEmpty()) {
-         for (PlayerChunkMapEntry var13 : this.dirtyEntries) {
-            var13.update();
+         for (PlayerChunkMapEntry var18 : this.dirtyEntries) {
+            var18.update();
          }
 
          this.dirtyEntries.clear();
       }
 
-      if (this.sortMissingChunks && var1 % 4L == 0L) {
+      if (this.sortMissingChunks && var11 % 4L == 0L) {
          this.sortMissingChunks = false;
          Collections.sort(this.entriesWithoutChunks, new Comparator<PlayerChunkMapEntry>() {
-            public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
-               return ComparisonChain.start().compare(var1.getClosestPlayerDistance(), var2.getClosestPlayerDistance()).result();
+            public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2x) {
+               return ComparisonChain.start().compare(var1.getClosestPlayerDistance(), var2x.getClosestPlayerDistance()).result();
             }
          });
       }
 
-      if (this.sortSendToPlayers && var1 % 4L == 2L) {
+      if (this.sortSendToPlayers && var11 % 4L == 2L) {
          this.sortSendToPlayers = false;
          Collections.sort(this.pendingSendToPlayers, new Comparator<PlayerChunkMapEntry>() {
             public int compare(PlayerChunkMapEntry var1, PlayerChunkMapEntry var2) {
                return ComparisonChain.start().compare(var1.getClosestPlayerDistance(), var2.getClosestPlayerDistance()).result();
             }
          });
       }
 
       if (!this.entriesWithoutChunks.isEmpty()) {
-         long var10 = System.nanoTime() + 50000000L;
-         int var5 = 49;
-         Iterator var6 = this.entriesWithoutChunks.iterator();
-
-         while (var6.hasNext()) {
-            PlayerChunkMapEntry var7 = (PlayerChunkMapEntry)var6.next();
-            if (var7.getChunk() == null) {
-               boolean var8 = var7.hasPlayerMatching(CAN_GENERATE_CHUNKS);
-               if (var7.providePlayerChunk(var8)) {
-                  var6.remove();
-                  if (var7.sendToPlayers()) {
-                     this.pendingSendToPlayers.remove(var7);
+         long var14 = System.nanoTime() + 50000000L;
+         int var20 = 49;
+         Iterator var22 = this.entriesWithoutChunks.iterator();
+
+         while (var22.hasNext()) {
+            PlayerChunkMapEntry var23 = (PlayerChunkMapEntry)var22.next();
+            if (var23.getChunk() == null) {
+               boolean var24 = var23.hasPlayerMatching(CAN_GENERATE_CHUNKS);
+               if (var23.providePlayerChunk(var24)) {
+                  var22.remove();
+                  if (var23.sendToPlayers()) {
+                     this.pendingSendToPlayers.remove(var23);
                   }
 
-                  if (--var5 < 0 || System.nanoTime() > var10) {
+                  if (--var20 < 0 || System.nanoTime() > var14) {
                      break;
                   }
                }
             }
          }
       }
 
       if (!this.pendingSendToPlayers.isEmpty()) {
-         int var11 = 81;
-         Iterator var14 = this.pendingSendToPlayers.iterator();
+         int var15 = 81;
+         Iterator var19 = this.pendingSendToPlayers.iterator();
 
-         while (var14.hasNext()) {
-            PlayerChunkMapEntry var15 = (PlayerChunkMapEntry)var14.next();
-            if (var15.sendToPlayers()) {
-               var14.remove();
-               if (--var11 < 0) {
+         while (var19.hasNext()) {
+            PlayerChunkMapEntry var21 = (PlayerChunkMapEntry)var19.next();
+            if (var21.sendToPlayers()) {
+               var19.remove();
+               if (--var15 < 0) {
                   break;
                }
             }
          }
       }
 
       if (this.players.isEmpty()) {
-         WorldProvider var12 = this.world.provider;
-         if (!var12.canRespawnHere()) {
+         WorldProvider var16 = this.world.provider;
+         if (!var16.canRespawnHere()) {
             this.world.getChunkProvider().queueUnloadAll();
          }
       }
    }
 
    public boolean contains(int var1, int var2) {
@@ -204,24 +239,35 @@
 
    public void addPlayer(EntityPlayerMP var1) {
       int var2 = (int)var1.posX >> 4;
       int var3 = (int)var1.posZ >> 4;
       var1.managedPosX = var1.posX;
       var1.managedPosZ = var1.posZ;
-
-      for (int var4 = var2 - this.playerViewRadius; var4 <= var2 + this.playerViewRadius; var4++) {
-         for (int var5 = var3 - this.playerViewRadius; var5 <= var3 + this.playerViewRadius; var5++) {
-            this.getOrCreateEntry(var4, var5).addPlayer(var1);
+      int var4 = Math.min(this.playerViewRadius, 8);
+      int var5 = var2 - var4;
+      int var6 = var2 + var4;
+      int var7 = var3 - var4;
+      int var8 = var3 + var4;
+      Set var9 = this.getPendingEntriesSafe(var1);
+
+      for (int var10 = var2 - this.playerViewRadius; var10 <= var2 + this.playerViewRadius; var10++) {
+         for (int var11 = var3 - this.playerViewRadius; var11 <= var3 + this.playerViewRadius; var11++) {
+            if (var10 >= var5 && var10 <= var6 && var11 >= var7 && var11 <= var8) {
+               this.getOrCreateEntry(var10, var11).addPlayer(var1);
+            } else {
+               var9.add(new ChunkPos(var10, var11));
+            }
          }
       }
 
       this.players.add(var1);
       this.markSortPending();
    }
 
    public void removePlayer(EntityPlayerMP var1) {
+      this.mapPlayerPendingEntries.remove(var1);
       int var2 = (int)var1.managedPosX >> 4;
       int var3 = (int)var1.managedPosZ >> 4;
 
       for (int var4 = var2 - this.playerViewRadius; var4 <= var2 + this.playerViewRadius; var4++) {
          for (int var5 = var3 - this.playerViewRadius; var5 <= var3 + this.playerViewRadius; var5++) {
             PlayerChunkMapEntry var6 = this.getEntry(var4, var5);
@@ -235,38 +281,45 @@
       this.markSortPending();
    }
 
    private boolean overlaps(int var1, int var2, int var3, int var4, int var5) {
       int var6 = var1 - var3;
       int var7 = var2 - var4;
-      return var6 < -var5 || var6 > var5 ? false : var7 >= -var5 && var7 <= var5;
+      return var6 >= -var5 && var6 <= var5 ? var7 >= -var5 && var7 <= var5 : false;
    }
 
    public void updateMovingPlayer(EntityPlayerMP var1) {
       int var2 = (int)var1.posX >> 4;
       int var3 = (int)var1.posZ >> 4;
       double var4 = var1.managedPosX - var1.posX;
       double var6 = var1.managedPosZ - var1.posZ;
       double var8 = var4 * var4 + var6 * var6;
-      if (!(var8 < 64.0)) {
+      if (var8 >= 64.0) {
          int var10 = (int)var1.managedPosX >> 4;
          int var11 = (int)var1.managedPosZ >> 4;
          int var12 = this.playerViewRadius;
          int var13 = var2 - var10;
          int var14 = var3 - var11;
          if (var13 != 0 || var14 != 0) {
-            for (int var15 = var2 - var12; var15 <= var2 + var12; var15++) {
-               for (int var16 = var3 - var12; var16 <= var3 + var12; var16++) {
-                  if (!this.overlaps(var15, var16, var10, var11, var12)) {
-                     this.getOrCreateEntry(var15, var16).addPlayer(var1);
+            Set var15 = this.getPendingEntriesSafe(var1);
+
+            for (int var16 = var2 - var12; var16 <= var2 + var12; var16++) {
+               for (int var17 = var3 - var12; var17 <= var3 + var12; var17++) {
+                  if (!this.overlaps(var16, var17, var10, var11, var12)) {
+                     if (Config.isLazyChunkLoading()) {
+                        var15.add(new ChunkPos(var16, var17));
+                     } else {
+                        this.getOrCreateEntry(var16, var17).addPlayer(var1);
+                     }
                   }
 
-                  if (!this.overlaps(var15 - var13, var16 - var14, var2, var3, var12)) {
-                     PlayerChunkMapEntry var17 = this.getEntry(var15 - var13, var16 - var14);
-                     if (var17 != null) {
-                        var17.removePlayer(var1);
+                  if (!this.overlaps(var16 - var13, var17 - var14, var2, var3, var12)) {
+                     var15.remove(new ChunkPos(var16 - var13, var17 - var14));
+                     PlayerChunkMapEntry var18 = this.getEntry(var16 - var13, var17 - var14);
+                     if (var18 != null) {
+                        var18.removePlayer(var1);
                      }
                   }
                }
             }
 
             var1.managedPosX = var1.posX;
@@ -279,33 +332,42 @@
    public boolean isPlayerWatchingChunk(EntityPlayerMP var1, int var2, int var3) {
       PlayerChunkMapEntry var4 = this.getEntry(var2, var3);
       return var4 != null && var4.containsPlayer(var1) && var4.isSentToPlayers();
    }
 
    public void setPlayerViewRadius(int var1) {
-      var1 = MathHelper.clamp(var1, 3, 32);
+      var1 = MathHelper.clamp(var1, 3, 64);
       if (var1 != this.playerViewRadius) {
          int var2 = var1 - this.playerViewRadius;
 
-         for (EntityPlayerMP var5 : Lists.newArrayList(this.players)) {
-            int var6 = (int)var5.posX >> 4;
-            int var7 = (int)var5.posZ >> 4;
+         for (EntityPlayerMP var4 : Lists.newArrayList(this.players)) {
+            int var5 = (int)var4.posX >> 4;
+            int var6 = (int)var4.posZ >> 4;
+            Set var7 = this.getPendingEntriesSafe(var4);
             if (var2 > 0) {
-               for (int var12 = var6 - var1; var12 <= var6 + var1; var12++) {
-                  for (int var13 = var7 - var1; var13 <= var7 + var1; var13++) {
-                     PlayerChunkMapEntry var10 = this.getOrCreateEntry(var12, var13);
-                     if (!var10.containsPlayer(var5)) {
-                        var10.addPlayer(var5);
+               for (int var12 = var5 - var1; var12 <= var5 + var1; var12++) {
+                  for (int var13 = var6 - var1; var13 <= var6 + var1; var13++) {
+                     if (Config.isLazyChunkLoading()) {
+                        var7.add(new ChunkPos(var12, var13));
+                     } else {
+                        PlayerChunkMapEntry var14 = this.getOrCreateEntry(var12, var13);
+                        if (!var14.containsPlayer(var4)) {
+                           var14.addPlayer(var4);
+                        }
                      }
                   }
                }
             } else {
-               for (int var8 = var6 - this.playerViewRadius; var8 <= var6 + this.playerViewRadius; var8++) {
-                  for (int var9 = var7 - this.playerViewRadius; var9 <= var7 + this.playerViewRadius; var9++) {
-                     if (!this.overlaps(var8, var9, var6, var7, var1)) {
-                        this.getOrCreateEntry(var8, var9).removePlayer(var5);
+               for (int var8 = var5 - this.playerViewRadius; var8 <= var5 + this.playerViewRadius; var8++) {
+                  for (int var9 = var6 - this.playerViewRadius; var9 <= var6 + this.playerViewRadius; var9++) {
+                     if (!this.overlaps(var8, var9, var5, var6, var1)) {
+                        var7.remove(new ChunkPos(var8, var9));
+                        PlayerChunkMapEntry var10 = this.getEntry(var8, var9);
+                        if (var10 != null) {
+                           var10.removePlayer(var4);
+                        }
                      }
                   }
                }
             }
          }
 
@@ -340,9 +402,58 @@
       this.dirtyEntries.remove(var1);
       this.pendingSendToPlayers.remove(var1);
       this.entriesWithoutChunks.remove(var1);
       Chunk var5 = var1.getChunk();
       if (var5 != null) {
          this.getWorldServer().getChunkProvider().queueUnload(var5);
+      }
+   }
+
+   private PriorityQueue<ChunkPos> getNearest(Set<ChunkPos> var1, EntityPlayerMP var2, int var3) {
+      float var4 = var2.rotationYaw + 90.0F;
+
+      while (var4 <= -180.0F) {
+         var4 += 360.0F;
+      }
+
+      while (var4 > 180.0F) {
+         var4 -= 360.0F;
+      }
+
+      double var5 = var4 * (Math.PI / 180.0);
+      double var7 = var2.rotationPitch;
+      double var9 = var7 * (Math.PI / 180.0);
+      ChunkPosComparator var11 = new ChunkPosComparator(var2.chunkCoordX, var2.chunkCoordZ, var5, var9);
+      Comparator var12 = Collections.reverseOrder(var11);
+      PriorityQueue var13 = new PriorityQueue(var12);
+
+      for (ChunkPos var15 : var1) {
+         if (var13.size() < var3) {
+            var13.add(var15);
+         } else {
+            ChunkPos var16 = (ChunkPos)var13.peek();
+            if (var11.compare(var15, var16) < 0) {
+               var13.remove();
+               var13.add(var15);
+            }
+         }
+      }
+
+      return var13;
+   }
+
+   private Set<ChunkPos> getPendingEntriesSafe(EntityPlayerMP var1) {
+      Set var2 = this.mapPlayerPendingEntries.get(var1);
+      if (var2 != null) {
+         return var2;
+      } else {
+         int var3 = Math.min(this.playerViewRadius, 8);
+         int var4 = this.playerViewRadius * 2 + 1;
+         int var5 = var3 * 2 + 1;
+         int var6 = var4 * var4 - var5 * var5;
+         var6 = Math.max(var6, 16);
+         HashSet var7 = new HashSet(var6);
+         this.mapPlayerPendingEntries.put(var1, var7);
+         return var7;
       }
    }
 }
--- net/minecraft/server/management/PlayerChunkMapEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PlayerChunkMapEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/PlayerInteractionManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PlayerInteractionManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/PlayerList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PlayerList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/PlayerProfileCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PlayerProfileCache.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/PreYggdrasilConverter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/PreYggdrasilConverter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListBans.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListBans.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListBansEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListBansEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListEntryBan.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListEntryBan.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListIPBans.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListIPBans.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListIPBansEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListIPBansEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListOps.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListOps.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListOpsEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListOpsEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListWhitelist.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListWhitelist.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/management/UserListWhitelistEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/management/UserListWhitelistEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/network/NetHandlerHandshakeTCP.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/network/NetHandlerHandshakeTCP.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/network/NetHandlerLoginServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/network/NetHandlerLoginServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/network/NetHandlerStatusServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/network/NetHandlerStatusServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/DebugLoggingPrintStream.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/DebugLoggingPrintStream.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/server/MinecraftServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/server/MinecraftServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/IStatType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/IStatType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/RecipeBook.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/RecipeBook.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/RecipeBookServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/RecipeBookServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatBasic.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatBasic.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatCrafting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatCrafting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatisticsManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatisticsManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatisticsManagerServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatisticsManagerServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/stats/StatList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/stats/StatList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/BannerPattern.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/BannerPattern.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/CommandBlockBaseLogic.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/CommandBlockBaseLogic.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/IHopper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/IHopper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/MobSpawnerBaseLogic.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/MobSpawnerBaseLogic.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityBanner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityBanner.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityBeacon.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityBeacon.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityBed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityBed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityBrewingStand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityBrewingStand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityCommandBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityCommandBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityComparator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityComparator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityDaylightDetector.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityDaylightDetector.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityDispenser.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityDispenser.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityDropper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityDropper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityEnchantmentTable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityEnchantmentTable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityEnderChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityEnderChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityEndGateway.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityEndGateway.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityEndPortal.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityEndPortal.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityFlowerPot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityFlowerPot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityFurnace.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityFurnace.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityHopper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityHopper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityLockable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityLockable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityLockableLoot.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityLockableLoot.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityMobSpawner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityMobSpawner.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityNote.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityNote.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityPiston.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityPiston.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityShulkerBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityShulkerBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntitySign.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntitySign.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntitySkull.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntitySkull.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/tileentity/TileEntityStructure.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/tileentity/TileEntityStructure.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/AddBedTileEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/AddBedTileEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ArmorStandSilent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ArmorStandSilent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/BannerItemColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/BannerItemColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/BedItemColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/BedItemColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/BookPagesStrictJSON.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/BookPagesStrictJSON.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/CookedFishIDTypo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/CookedFishIDTypo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ElderGuardianSplit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ElderGuardianSplit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/EntityArmorAndHeld.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/EntityArmorAndHeld.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/EntityHealth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/EntityHealth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/EntityId.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/EntityId.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ForceVBOOn.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ForceVBOOn.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/HorseSaddle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/HorseSaddle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/HorseSplit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/HorseSplit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ItemIntIDToString.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ItemIntIDToString.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/MinecartEntityTypes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/MinecartEntityTypes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/OptionsLowerCaseLanguage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/OptionsLowerCaseLanguage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/PaintingDirection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/PaintingDirection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/PotionItems.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/PotionItems.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/PotionWater.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/PotionWater.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/RedundantChanceTags.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/RedundantChanceTags.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/RidingToPassengers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/RidingToPassengers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ShulkerBoxEntityColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ShulkerBoxEntityColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ShulkerBoxItemColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ShulkerBoxItemColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ShulkerBoxTileColor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ShulkerBoxTileColor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/SignStrictJSON.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/SignStrictJSON.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/SkeletonSplit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/SkeletonSplit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/SpawnEggNames.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/SpawnEggNames.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/SpawnerEntityTypes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/SpawnerEntityTypes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/StringToUUID.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/StringToUUID.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/TileEntityId.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/TileEntityId.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/TotemItemRename.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/TotemItemRename.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ZombieProfToType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ZombieProfToType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/fixes/ZombieSplit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/fixes/ZombieSplit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/walkers/BlockEntityTag.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/walkers/BlockEntityTag.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/walkers/EntityTag.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/walkers/EntityTag.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/walkers/Filtered.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/walkers/Filtered.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/walkers/ItemStackData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/walkers/ItemStackData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/walkers/ItemStackDataLists.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/walkers/ItemStackDataLists.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/DataFixer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/DataFixer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/DataFixesManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/DataFixesManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/FixTypes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/FixTypes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/IDataFixer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/IDataFixer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/IDataWalker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/IDataWalker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/IFixableData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/IFixableData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/datafix/IFixType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/datafix/IFixType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/AxisAlignedBB.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/AxisAlignedBB.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/BlockPos.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/BlockPos.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/Cartesian.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/Cartesian.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/ChunkPos.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/ChunkPos.java	Mon Aug 18 09:39:52 2025
@@ -2,12 +2,13 @@
 
 import net.minecraft.entity.Entity;
 
 public class ChunkPos {
    public final int x;
    public final int z;
+   private int cachedHashCode = 0;
 
    public ChunkPos(int var1, int var2) {
       this.x = var1;
       this.z = var2;
    }
 
@@ -19,15 +20,20 @@
    public static long asLong(int var0, int var1) {
       return var0 & 4294967295L | (var1 & 4294967295L) << 32;
    }
 
    @Override
    public int hashCode() {
-      int var1 = 1664525 * this.x + 1013904223;
-      int var2 = 1664525 * (this.z ^ -559038737) + 1013904223;
-      return var1 ^ var2;
+      if (this.cachedHashCode != 0) {
+         return this.cachedHashCode;
+      } else {
+         int var1 = 1664525 * this.x + 1013904223;
+         int var2 = 1664525 * (this.z ^ -559038737) + 1013904223;
+         this.cachedHashCode = var1 ^ var2;
+         return this.cachedHashCode;
+      }
    }
 
    @Override
    public boolean equals(Object var1) {
       if (this == var1) {
          return true;
--- net/minecraft/util/math/MathHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/MathHelper.java	Mon Aug 18 09:39:52 2025
@@ -1,26 +1,38 @@
 package net.minecraft.util.math;
 
 import java.util.Random;
 import java.util.UUID;
+import net.optifine.util.MathUtils;
 
 public class MathHelper {
    public static final float SQRT_2 = sqrt(2.0F);
+   private static final int SIN_BITS = 12;
+   private static final int SIN_MASK = 4095;
+   private static final int SIN_COUNT = 4096;
+   private static final int SIN_COUNT_D4 = 1024;
+   public static final float PI = MathUtils.roundToFloat(Math.PI);
+   public static final float PI2 = MathUtils.roundToFloat(Math.PI * 2);
+   public static final float PId2 = MathUtils.roundToFloat(Math.PI / 2);
+   private static final float radToIndex = MathUtils.roundToFloat(651.8986469044033);
+   public static final float deg2Rad = MathUtils.roundToFloat(Math.PI / 180.0);
+   private static final float[] SIN_TABLE_FAST = new float[4096];
+   public static boolean fastMath = false;
    private static final float[] SIN_TABLE = new float[65536];
    private static final Random RANDOM = new Random();
    private static final int[] MULTIPLY_DE_BRUIJN_BIT_POSITION;
    private static final double FRAC_BIAS;
    private static final double[] ASINE_TAB;
    private static final double[] COS_TAB;
 
    public static float sin(float var0) {
-      return SIN_TABLE[(int)(var0 * 10430.378F) & 65535];
+      return fastMath ? SIN_TABLE_FAST[(int)(var0 * radToIndex) & 4095] : SIN_TABLE[(int)(var0 * 10430.378F) & 65535];
    }
 
    public static float cos(float var0) {
-      return SIN_TABLE[(int)(var0 * 10430.378F + 16384.0F) & 65535];
+      return fastMath ? SIN_TABLE_FAST[(int)(var0 * radToIndex + 1024.0F) & 4095] : SIN_TABLE[(int)(var0 * 10430.378F + 16384.0F) & 65535];
    }
 
    public static float sqrt(float var0) {
       return (float)Math.sqrt(var0);
    }
 
@@ -422,21 +434,25 @@
 
    static {
       for (int var0 = 0; var0 < 65536; var0++) {
          SIN_TABLE[var0] = (float)Math.sin(var0 * Math.PI * 2.0 / 65536.0);
       }
 
+      for (int var5 = 0; var5 < SIN_TABLE_FAST.length; var5++) {
+         SIN_TABLE_FAST[var5] = MathUtils.roundToFloat(Math.sin(var5 * Math.PI * 2.0 / 4096.0));
+      }
+
       MULTIPLY_DE_BRUIJN_BIT_POSITION = new int[]{
          0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
       };
       FRAC_BIAS = Double.longBitsToDouble(4805340802404319232L);
       ASINE_TAB = new double[257];
       COS_TAB = new double[257];
 
-      for (int var5 = 0; var5 < 257; var5++) {
-         double var1 = var5 / 256.0;
+      for (int var6 = 0; var6 < 257; var6++) {
+         double var1 = var6 / 256.0;
          double var3 = Math.asin(var1);
-         COS_TAB[var5] = Math.cos(var3);
-         ASINE_TAB[var5] = var3;
+         COS_TAB[var6] = Math.cos(var3);
+         ASINE_TAB[var6] = var3;
       }
    }
 }
--- net/minecraft/util/math/RayTraceResult.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/RayTraceResult.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/Rotations.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/Rotations.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/Vec2f.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/Vec2f.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/Vec3d.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/Vec3d.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/math/Vec3i.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/math/Vec3i.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/registry/IRegistry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/registry/IRegistry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/registry/RegistryDefaulted.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/registry/RegistryDefaulted.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/registry/RegistryNamespaced.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/registry/RegistryNamespaced.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/registry/RegistryNamespacedDefaultedByKey.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/registry/RegistryNamespacedDefaultedByKey.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/registry/RegistrySimple.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/registry/RegistrySimple.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/event/ClickEvent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/event/ClickEvent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/event/HoverEvent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/event/HoverEvent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/translation/I18n.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/translation/I18n.java	Mon Aug 18 09:39:52 2025
--- net/minecraft/util/text/translation/LanguageMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/translation/LanguageMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/ChatType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/ChatType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/ITextComponent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/ITextComponent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/Style.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/Style.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentKeybind.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentKeybind.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentScore.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentScore.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentSelector.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentSelector.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentString.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentString.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentTranslation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentTranslation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentTranslationFormatException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentTranslationFormatException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextComponentUtils.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextComponentUtils.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/text/TextFormatting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/text/TextFormatting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ActionResult.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ActionResult.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/BitArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/BitArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/BlockRenderLayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/BlockRenderLayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ChatAllowedCharacters.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ChatAllowedCharacters.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ClassInheritanceMultiMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ClassInheritanceMultiMap.java	Mon Aug 18 09:39:52 2025
@@ -7,36 +7,43 @@
 import java.util.AbstractSet;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import net.optifine.util.IteratorCache;
 
 public class ClassInheritanceMultiMap<T> extends AbstractSet<T> {
-   private static final Set<Class<?>> ALL_KNOWN = Sets.newHashSet();
+   private static final Set<Class<?>> ALL_KNOWN = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final Map<Class<?>, List<T>> map = Maps.newHashMap();
    private final Set<Class<?>> knownKeys = Sets.newIdentityHashSet();
    private final Class<T> baseClass;
    private final List<T> values = Lists.newArrayList();
+   public boolean empty;
 
    public ClassInheritanceMultiMap(Class<T> var1) {
       this.baseClass = var1;
       this.knownKeys.add(var1);
       this.map.put(var1, this.values);
 
       for (Class var3 : ALL_KNOWN) {
          this.createLookup(var3);
       }
+
+      this.empty = this.values.size() == 0;
    }
 
    protected void createLookup(Class<?> var1) {
       ALL_KNOWN.add(var1);
+      int var2 = this.values.size();
 
-      for (Object var3 : this.values) {
-         if (var1.isAssignableFrom(var3.getClass())) {
-            this.addForClass((T)var3, var1);
+      for (int var3 = 0; var3 < var2; var3++) {
+         Object var4 = this.values.get(var3);
+         if (var1.isAssignableFrom(var4.getClass())) {
+            this.addForClass((T)var4, var1);
          }
       }
 
       this.knownKeys.add(var1);
    }
 
@@ -57,22 +64,25 @@
       for (Class var3 : this.knownKeys) {
          if (var3.isAssignableFrom(var1.getClass())) {
             this.addForClass((T)var1, var3);
          }
       }
 
+      this.empty = this.values.size() == 0;
       return true;
    }
 
    private void addForClass(T var1, Class<?> var2) {
       List var3 = this.map.get(var2);
       if (var3 == null) {
          this.map.put(var2, Lists.newArrayList(new Object[]{var1}));
       } else {
          var3.add(var1);
       }
+
+      this.empty = this.values.size() == 0;
    }
 
    @Override
    public boolean remove(Object var1) {
       Object var2 = var1;
       boolean var3 = false;
@@ -83,12 +93,13 @@
             if (var6 != null && var6.remove(var2)) {
                var3 = true;
             }
          }
       }
 
+      this.empty = this.values.size() == 0;
       return var3;
    }
 
    @Override
    public boolean contains(Object var1) {
       return Iterators.contains(this.getByClass(var1.getClass()).iterator(), var1);
@@ -108,14 +119,19 @@
          }
       };
    }
 
    @Override
    public Iterator<T> iterator() {
-      return (Iterator<T>)(this.values.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.values.iterator()));
+      return this.values.isEmpty() ? Collections.emptyIterator() : IteratorCache.getReadOnly(this.values);
    }
 
    @Override
    public int size() {
       return this.values.size();
+   }
+
+   @Override
+   public boolean isEmpty() {
+      return this.empty;
    }
 }
--- net/minecraft/util/CombatEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CombatEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/CombatRules.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CombatRules.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/CombatTracker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CombatTracker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/CooldownTracker.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CooldownTracker.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/CooldownTrackerServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CooldownTrackerServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/CryptManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/CryptManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/DamageSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/DamageSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnchantmentNameParts.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnchantmentNameParts.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EntityDamageSource.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EntityDamageSource.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EntityDamageSourceIndirect.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EntityDamageSourceIndirect.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EntitySelectors.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EntitySelectors.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumActionResult.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumActionResult.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumBlockRenderType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumBlockRenderType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumFacing.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumFacing.java	Mon Aug 18 09:39:52 2025
@@ -25,13 +25,13 @@
    private final int opposite;
    private final int horizontalIndex;
    private final String name;
    private final EnumFacing.Axis axis;
    private final EnumFacing.AxisDirection axisDirection;
    private final Vec3i directionVec;
-   private static final EnumFacing[] VALUES = new EnumFacing[6];
+   public static final EnumFacing[] VALUES = new EnumFacing[6];
    private static final EnumFacing[] HORIZONTALS = new EnumFacing[4];
    private static final Map<String, EnumFacing> NAME_LOOKUP = Maps.newHashMap();
 
    private EnumFacing(int var3, int var4, int var5, String var6, EnumFacing.AxisDirection var7, EnumFacing.Axis var8, Vec3i var9) {
       this.index = var3;
       this.horizontalIndex = var5;
@@ -52,13 +52,13 @@
 
    public EnumFacing.AxisDirection getAxisDirection() {
       return this.axisDirection;
    }
 
    public EnumFacing getOpposite() {
-      return byIndex(this.opposite);
+      return VALUES[this.opposite];
    }
 
    public EnumFacing rotateAround(EnumFacing.Axis var1) {
       switch (var1) {
          case X:
             if (this != WEST && this != EAST) {
@@ -208,13 +208,12 @@
 
    @Override
    public String toString() {
       return this.name;
    }
 
-   @Override
    public String getName() {
       return this.name;
    }
 
    public static EnumFacing getFacingFromAxis(EnumFacing.AxisDirection var0, EnumFacing.Axis var1) {
       for (EnumFacing var5 : values()) {
@@ -297,13 +296,12 @@
       }
 
       public EnumFacing.Plane getPlane() {
          return this.plane;
       }
 
-      @Override
       public String getName() {
          return this.name;
       }
 
       static {
          for (EnumFacing.Axis var3 : values()) {
--- net/minecraft/util/EnumHand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumHand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumHandSide.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumHandSide.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumParticleTypes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumParticleTypes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/EnumTypeAdapterFactory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/EnumTypeAdapterFactory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/FoodStats.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/FoodStats.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/FrameTimer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/FrameTimer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/HttpUtil.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/HttpUtil.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IJsonSerializable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IJsonSerializable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IntegerCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IntegerCache.java	Mon Aug 18 09:39:52 2025
@@ -1,13 +1,13 @@
 package net.minecraft.util;
 
 public class IntegerCache {
    private static final Integer[] CACHE = new Integer[65535];
 
    public static Integer getInteger(int var0) {
-      return var0 > 0 && var0 < CACHE.length ? CACHE[var0] : var0;
+      return var0 >= 0 && var0 < CACHE.length ? CACHE[var0] : new Integer(var0);
    }
 
    static {
       int var0 = 0;
 
       for (int var1 = CACHE.length; var0 < var1; var0++) {
--- net/minecraft/util/IntHashMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IntHashMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IntIdentityHashBiMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IntIdentityHashBiMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IObjectIntIterable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IObjectIntIterable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IProgressUpdate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IProgressUpdate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IStringSerializable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IStringSerializable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ITabCompleter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ITabCompleter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/IThreadListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/IThreadListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ITickable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ITickable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/JsonUtils.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/JsonUtils.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/LazyLoadBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/LazyLoadBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/LoggingPrintStream.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/LoggingPrintStream.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/LowerStringMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/LowerStringMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MapPopulator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MapPopulator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MinecraftError.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MinecraftError.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Mirror.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Mirror.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MouseFilter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MouseFilter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MouseHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MouseHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MovementInput.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MovementInput.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/MovementInputFromOptions.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/MovementInputFromOptions.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/NonNullList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/NonNullList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ObjectIntIdentityMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ObjectIntIdentityMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ReportedException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ReportedException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ResourceLocation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ResourceLocation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Rotation.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Rotation.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/ScreenShotHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ScreenShotHelper.java	Mon Aug 18 09:39:52 2025
@@ -6,54 +6,98 @@
 import java.nio.IntBuffer;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.shader.Framebuffer;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.util.text.TextComponentTranslation;
 import net.minecraft.util.text.event.ClickEvent;
+import net.minecraft.util.text.event.ClickEvent.Action;
+import net.optifine.reflect.Reflector;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.lwjgl.BufferUtils;
 
 public class ScreenShotHelper {
    private static final Logger LOGGER = LogManager.getLogger();
    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss");
    private static IntBuffer pixelBuffer;
    private static int[] pixelValues;
 
    public static ITextComponent saveScreenshot(File var0, int var1, int var2, Framebuffer var3) {
-      return saveScreenshot(var0, null, var1, var2, var3);
+      return saveScreenshot(var0, (String)null, var1, var2, var3);
    }
 
    public static ITextComponent saveScreenshot(File var0, @Nullable String var1, int var2, int var3, Framebuffer var4) {
       try {
          File var5 = new File(var0, "screenshots");
          var5.mkdir();
-         BufferedImage var6 = createScreenshot(var2, var3, var4);
-         File var7;
+         Minecraft var6 = Minecraft.getMinecraft();
+         int var7 = Config.getGameSettings().guiScale;
+         ScaledResolution var8 = new ScaledResolution(var6);
+         int var9 = var8.getScaleFactor();
+         int var10 = Config.getScreenshotSize();
+         boolean var11 = OpenGlHelper.isFramebufferEnabled() && var10 > 1;
+         if (var11) {
+            Config.getGameSettings().guiScale = var9 * var10;
+            resize(var2 * var10, var3 * var10);
+            GlStateManager.pushMatrix();
+            GlStateManager.clear(16640);
+            var6.getFramebuffer().bindFramebuffer(true);
+            var6.entityRenderer.updateCameraAndRender(var6.getRenderPartialTicks(), System.nanoTime());
+         }
+
+         BufferedImage var12 = createScreenshot(var2, var3, var4);
+         if (var11) {
+            var6.getFramebuffer().unbindFramebuffer();
+            GlStateManager.popMatrix();
+            Config.getGameSettings().guiScale = var7;
+            resize(var2, var3);
+         }
+
+         File var13;
          if (var1 == null) {
-            var7 = getTimestampedPNGFileForDirectory(var5);
+            var13 = getTimestampedPNGFileForDirectory(var5);
          } else {
-            var7 = new File(var5, var1);
+            var13 = new File(var5, var1);
+         }
+
+         var13 = var13.getCanonicalFile();
+         Object var14 = null;
+         if (Reflector.ForgeHooksClient_onScreenshot.exists()) {
+            var14 = Reflector.call(Reflector.ForgeHooksClient_onScreenshot, new Object[]{var12, var13});
+            if (Reflector.callBoolean(var14, Reflector.Event_isCanceled, new Object[0])) {
+               return (ITextComponent)Reflector.call(var14, Reflector.ScreenshotEvent_getCancelMessage, new Object[0]);
+            }
+
+            var13 = (File)Reflector.call(var14, Reflector.ScreenshotEvent_getScreenshotFile, new Object[0]);
+         }
+
+         ImageIO.write(var12, "png", var13);
+         TextComponentString var15 = new TextComponentString(var13.getName());
+         var15.getStyle().setClickEvent(new ClickEvent(Action.OPEN_FILE, var13.getAbsolutePath()));
+         var15.getStyle().setUnderlined(true);
+         if (var14 != null) {
+            ITextComponent var16 = (ITextComponent)Reflector.call(var14, Reflector.ScreenshotEvent_getResultMessage, new Object[0]);
+            if (var16 != null) {
+               return var16;
+            }
          }
 
-         ImageIO.write(var6, "png", var7);
-         TextComponentString var8 = new TextComponentString(var7.getName());
-         var8.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_FILE, var7.getAbsolutePath()));
-         var8.getStyle().setUnderlined(true);
-         return new TextComponentTranslation("screenshot.success", var8);
-      } catch (Exception var9) {
-         LOGGER.warn("Couldn't save screenshot", var9);
-         return new TextComponentTranslation("screenshot.failure", var9.getMessage());
+         return new TextComponentTranslation("screenshot.success", new Object[]{var15});
+      } catch (Exception var17) {
+         LOGGER.warn("Couldn't save screenshot", var17);
+         return new TextComponentTranslation("screenshot.failure", new Object[]{var17.getMessage()});
       }
    }
 
    public static BufferedImage createScreenshot(int var0, int var1, Framebuffer var2) {
       if (OpenGlHelper.isFramebufferEnabled()) {
          var0 = var2.framebufferTextureWidth;
@@ -81,19 +125,39 @@
       BufferedImage var4 = new BufferedImage(var0, var1, 1);
       var4.setRGB(0, 0, var0, var1, pixelValues, 0, var0);
       return var4;
    }
 
    private static File getTimestampedPNGFileForDirectory(File var0) {
-      String var2 = DATE_FORMAT.format(new Date()).toString();
-      int var3 = 1;
+      String var1 = DATE_FORMAT.format(new Date()).toString();
+      int var2 = 1;
 
       while (true) {
-         File var1 = new File(var0, var2 + (var3 == 1 ? "" : "_" + var3) + ".png");
-         if (!var1.exists()) {
-            return var1;
+         File var3 = new File(var0, var1 + (var2 == 1 ? "" : "_" + var2) + ".png");
+         if (!var3.exists()) {
+            return var3;
          }
 
-         var3++;
+         var2++;
+      }
+   }
+
+   private static void resize(int var0, int var1) {
+      Minecraft var2 = Minecraft.getMinecraft();
+      var2.displayWidth = Math.max(1, var0);
+      var2.displayHeight = Math.max(1, var1);
+      if (var2.currentScreen != null) {
+         ScaledResolution var3 = new ScaledResolution(var2);
+         var2.currentScreen.onResize(var2, var3.getScaledWidth(), var3.getScaledHeight());
+      }
+
+      updateFramebufferSize();
+   }
+
+   private static void updateFramebufferSize() {
+      Minecraft var0 = Minecraft.getMinecraft();
+      var0.getFramebuffer().createBindFramebuffer(var0.displayWidth, var0.displayHeight);
+      if (var0.entityRenderer != null) {
+         var0.entityRenderer.updateShaderGroupSize(var0.displayWidth, var0.displayHeight);
       }
    }
 }
--- net/minecraft/util/ServerRecipeBookHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/ServerRecipeBookHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Session.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Session.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/SoundCategory.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/SoundCategory.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/SoundEvent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/SoundEvent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/StringUtils.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/StringUtils.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/TabCompleter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/TabCompleter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Timer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Timer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Tuple.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Tuple.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/TupleIntJsonSerializable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/TupleIntJsonSerializable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/Util.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/Util.java	Mon Aug 18 09:39:52 2025
@@ -27,16 +27,20 @@
 
    @Nullable
    public static <V> V runTask(FutureTask<V> var0, Logger var1) {
       try {
          var0.run();
          return (V)var0.get();
-      } catch (ExecutionException var3) {
-         var1.fatal("Error executing task", var3);
-      } catch (InterruptedException var4) {
+      } catch (ExecutionException var4) {
          var1.fatal("Error executing task", var4);
+         if (var4.getCause() instanceof OutOfMemoryError) {
+            OutOfMemoryError var3 = (OutOfMemoryError)var4.getCause();
+            throw var3;
+         }
+      } catch (InterruptedException var5) {
+         var1.fatal("Error executing task", var5);
       }
 
       return null;
    }
 
    public static <T> T getLastElement(List<T> var0) {
--- net/minecraft/util/WeightedRandom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/WeightedRandom.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/util/WeightedSpawnerEntity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/util/WeightedSpawnerEntity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/MerchantRecipe.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/MerchantRecipe.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/MerchantRecipeList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/MerchantRecipeList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/Village.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/Village.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/VillageCollection.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/VillageCollection.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/VillageDoorInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/VillageDoorInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/village/VillageSiege.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/village/VillageSiege.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/Biome.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/Biome.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeBeach.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeBeach.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeCache.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeColorHelper.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeColorHelper.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeDecorator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeDecorator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeDesert.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeDesert.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeEnd.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeEnd.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeEndDecorator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeEndDecorator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeForest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeForest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeForestMutated.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeForestMutated.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeHell.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeHell.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeHellDecorator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeHellDecorator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeHills.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeHills.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeJungle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeJungle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeMesa.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeMesa.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeMushroomIsland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeMushroomIsland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeOcean.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeOcean.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomePlains.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomePlains.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeProvider.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeProvider.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeProviderSingle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeProviderSingle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeRiver.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeRiver.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeSavanna.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeSavanna.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeSavannaMutated.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeSavannaMutated.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeSnow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeSnow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeStoneBeach.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeStoneBeach.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeSwamp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeSwamp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeTaiga.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeTaiga.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeVoid.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeVoid.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/biome/BiomeVoidDecorator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/biome/BiomeVoidDecorator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/border/EnumBorderStatus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/border/EnumBorderStatus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/border/IBorderListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/border/IBorderListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/border/WorldBorder.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/border/WorldBorder.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/AnvilChunkLoader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/AnvilChunkLoader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/AnvilSaveConverter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/AnvilSaveConverter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/AnvilSaveHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/AnvilSaveHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/ChunkLoader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/ChunkLoader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/ExtendedBlockStorage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/ExtendedBlockStorage.java	Mon Aug 18 09:39:52 2025
@@ -2,12 +2,13 @@
 
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.init.Blocks;
 import net.minecraft.world.chunk.BlockStateContainer;
 import net.minecraft.world.chunk.NibbleArray;
+import net.optifine.reflect.Reflector;
 
 public class ExtendedBlockStorage {
    private final int yBase;
    private int blockRefCount;
    private int tickRefCount;
    private final BlockStateContainer data;
@@ -25,12 +26,16 @@
 
    public IBlockState get(int var1, int var2, int var3) {
       return this.data.get(var1, var2, var3);
    }
 
    public void set(int var1, int var2, int var3, IBlockState var4) {
+      if (Reflector.IExtendedBlockState.isInstance(var4)) {
+         var4 = (IBlockState)Reflector.call(var4, Reflector.IExtendedBlockState_getClean, new Object[0]);
+      }
+
       IBlockState var5 = this.get(var1, var2, var3);
       Block var6 = var5.getBlock();
       Block var7 = var4.getBlock();
       if (var6 != Blocks.AIR) {
          this.blockRefCount--;
          if (var6.getTickRandomly()) {
@@ -74,28 +79,33 @@
 
    public int getBlockLight(int var1, int var2, int var3) {
       return this.blockLight.get(var1, var2, var3);
    }
 
    public void recalculateRefCounts() {
-      this.blockRefCount = 0;
-      this.tickRefCount = 0;
-
-      for (int var1 = 0; var1 < 16; var1++) {
-         for (int var2 = 0; var2 < 16; var2++) {
-            for (int var3 = 0; var3 < 16; var3++) {
-               Block var4 = this.get(var1, var2, var3).getBlock();
-               if (var4 != Blocks.AIR) {
-                  this.blockRefCount++;
-                  if (var4.getTickRandomly()) {
-                     this.tickRefCount++;
+      IBlockState var1 = Blocks.AIR.getDefaultState();
+      int var2 = 0;
+      int var3 = 0;
+
+      for (int var4 = 0; var4 < 16; var4++) {
+         for (int var5 = 0; var5 < 16; var5++) {
+            for (int var6 = 0; var6 < 16; var6++) {
+               IBlockState var7 = this.data.get(var6, var4, var5);
+               if (var7 != var1) {
+                  var2++;
+                  Block var8 = var7.getBlock();
+                  if (var8.getTickRandomly()) {
+                     var3++;
                   }
                }
             }
          }
       }
+
+      this.blockRefCount = var2;
+      this.tickRefCount = var3;
    }
 
    public BlockStateContainer getData() {
       return this.data;
    }
 
@@ -110,8 +120,12 @@
    public void setBlockLight(NibbleArray var1) {
       this.blockLight = var1;
    }
 
    public void setSkyLight(NibbleArray var1) {
       this.skyLight = var1;
+   }
+
+   public int getBlockRefCount() {
+      return this.blockRefCount;
    }
 }
--- net/minecraft/world/chunk/storage/IChunkLoader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/IChunkLoader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/NibbleArrayReader.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/NibbleArrayReader.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/RegionFile.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/RegionFile.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/storage/RegionFileCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/storage/RegionFileCache.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/BlockStateContainer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/BlockStateContainer.java	Mon Aug 18 09:39:52 2025
@@ -38,13 +38,12 @@
 
          this.palette.idFor(AIR_BLOCK_STATE);
          this.storage = new BitArray(this.bits, 4096);
       }
    }
 
-   @Override
    public int onResize(int var1, IBlockState var2) {
       BitArray var3 = this.storage;
       IBlockStatePalette var4 = this.palette;
       this.setBits(var1);
 
       for (int var5 = 0; var5 < var3.size(); var5++) {
@@ -119,13 +118,13 @@
       for (int var4 = 0; var4 < 4096; var4++) {
          int var5 = var4 & 15;
          int var6 = var4 >> 8 & 15;
          int var7 = var4 >> 4 & 15;
          int var8 = var3 == null ? 0 : var3.get(var5, var6, var7);
          int var9 = var8 << 12 | (var1[var4] & 255) << 4 | var2.get(var5, var6, var7);
-         this.set(var4, Block.BLOCK_STATE_IDS.getByValue(var9));
+         this.set(var4, (IBlockState)Block.BLOCK_STATE_IDS.getByValue(var9));
       }
    }
 
    public int getSerializedSize() {
       return 1 + this.palette.getSerializedSize() + PacketBuffer.getVarIntSize(this.storage.size()) + this.storage.getBackingLongArray().length * 8;
    }
--- net/minecraft/world/chunk/BlockStatePaletteHashMap.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/BlockStatePaletteHashMap.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/BlockStatePaletteLinear.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/BlockStatePaletteLinear.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/BlockStatePaletteRegistry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/BlockStatePaletteRegistry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/Chunk.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/Chunk.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/ChunkPrimer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/ChunkPrimer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/EmptyChunk.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/EmptyChunk.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/IBlockStatePalette.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/IBlockStatePalette.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/IBlockStatePaletteResizer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/IBlockStatePaletteResizer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/IChunkProvider.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/IChunkProvider.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/chunk/NibbleArray.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/chunk/NibbleArray.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/end/DragonFightManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/end/DragonFightManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/end/DragonSpawnManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/end/DragonSpawnManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenAbstractTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenAbstractTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenBigMushroom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenBigMushroom.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenBigTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenBigTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenBirchTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenBirchTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenBlockBlob.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenBlockBlob.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenBush.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenBush.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenCactus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenCactus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenCanopyTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenCanopyTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenClay.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenClay.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenDeadBush.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenDeadBush.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenDesertWells.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenDesertWells.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenDoublePlant.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenDoublePlant.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenDungeons.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenDungeons.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenEndGateway.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenEndGateway.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenEndIsland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenEndIsland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenEndPodium.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenEndPodium.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenerator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenerator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGeneratorBonusChest.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGeneratorBonusChest.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenFire.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenFire.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenFlowers.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenFlowers.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenFossils.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenFossils.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenGlowStone1.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenGlowStone1.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenGlowStone2.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenGlowStone2.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenHellLava.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenHellLava.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenHugeTrees.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenHugeTrees.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenIcePath.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenIcePath.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenIceSpike.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenIceSpike.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenLakes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenLakes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenLiquids.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenLiquids.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenMegaJungle.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenMegaJungle.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenMegaPineTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenMegaPineTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenMelon.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenMelon.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenMinable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenMinable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenPumpkin.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenPumpkin.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenReed.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenReed.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenSand.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenSand.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenSavannaTree.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenSavannaTree.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenShrub.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenShrub.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenSpikes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenSpikes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenSwamp.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenSwamp.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenTaiga1.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenTaiga1.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenTaiga2.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenTaiga2.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenTallGrass.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenTallGrass.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenTrees.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenTrees.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenVines.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenVines.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/feature/WorldGenWaterlily.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/feature/WorldGenWaterlily.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerAddIsland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerAddIsland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerAddMushroomIsland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerAddMushroomIsland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerAddSnow.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerAddSnow.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerBiome.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerBiome.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerBiomeEdge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerBiomeEdge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerDeepOcean.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerDeepOcean.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerEdge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerEdge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerFuzzyZoom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerFuzzyZoom.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerHills.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerHills.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerIsland.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerIsland.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerRareBiome.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerRareBiome.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerRemoveTooMuchOcean.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerRemoveTooMuchOcean.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerRiver.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerRiver.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerRiverInit.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerRiverInit.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerRiverMix.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerRiverMix.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerShore.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerShore.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerSmooth.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerSmooth.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerVoronoiZoom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerVoronoiZoom.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/layer/GenLayerZoom.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/GenLayerZoom.java	Mon Aug 18 09:39:52 2025
@@ -3,13 +3,12 @@
 public class GenLayerZoom extends GenLayer {
    public GenLayerZoom(long var1, GenLayer var3) {
       super(var1);
       super.parent = var3;
    }
 
-   @Override
    public int[] getInts(int var1, int var2, int var3, int var4) {
       int var5 = var1 >> 1;
       int var6 = var2 >> 1;
       int var7 = (var3 >> 1) + 2;
       int var8 = (var4 >> 1) + 2;
       int[] var9 = this.parent.getInts(var5, var6, var7, var8);
@@ -24,14 +23,14 @@
 
          for (int var17 = var9[var15 + 0 + (var13 + 1) * var7]; var15 < var7 - 1; var15++) {
             this.initChunkSeed(var15 + var5 << 1, var13 + var6 << 1);
             int var18 = var9[var15 + 1 + (var13 + 0) * var7];
             int var19 = var9[var15 + 1 + (var13 + 1) * var7];
             var12[var14] = var16;
-            var12[var14++ + var10] = this.selectRandom(new int[]{var16, var17});
-            var12[var14] = this.selectRandom(new int[]{var16, var18});
+            var12[var14++ + var10] = this.selectRandom2(var16, var17);
+            var12[var14] = this.selectRandom2(var16, var18);
             var12[var14++ + var10] = this.selectModeOrRandom(var16, var18, var17, var19);
             var16 = var18;
             var17 = var19;
          }
       }
 
@@ -49,8 +48,13 @@
 
       for (int var5 = 0; var5 < var3; var5++) {
          var4 = new GenLayerZoom(var0 + var5, (GenLayer)var4);
       }
 
       return (GenLayer)var4;
+   }
+
+   protected int selectRandom2(int var1, int var2) {
+      int var3 = this.nextInt(2);
+      return var3 == 0 ? var1 : var2;
    }
 }
--- net/minecraft/world/gen/layer/IntCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/layer/IntCache.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/template/BlockRotationProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/template/BlockRotationProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/template/ITemplateProcessor.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/template/ITemplateProcessor.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/template/PlacementSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/template/PlacementSettings.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/template/Template.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/template/Template.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/template/TemplateManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/template/TemplateManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/ComponentScatteredFeaturePieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/ComponentScatteredFeaturePieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenEndCity.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenEndCity.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenMineshaft.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenMineshaft.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenNetherBridge.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenNetherBridge.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenScatteredFeature.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenScatteredFeature.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenStronghold.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenStronghold.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenStructure.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenStructure.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenStructureData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenStructureData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenStructureIO.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenStructureIO.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/MapGenVillage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/MapGenVillage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureBoundingBox.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureBoundingBox.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureComponent.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureComponent.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureComponentTemplate.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureComponentTemplate.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureEndCityPieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureEndCityPieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureMineshaftPieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureMineshaftPieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureMineshaftStart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureMineshaftStart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureNetherBridgePieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureNetherBridgePieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureOceanMonument.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureOceanMonument.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureOceanMonumentPieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureOceanMonumentPieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureStart.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureStart.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureStrongholdPieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureStrongholdPieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/StructureVillagePieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/StructureVillagePieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/WoodlandMansion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/WoodlandMansion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/structure/WoodlandMansionPieces.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/structure/WoodlandMansionPieces.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorDebug.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorDebug.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorEnd.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorEnd.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorFlat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorFlat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorHell.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorHell.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorOverworld.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorOverworld.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkGeneratorSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkGeneratorSettings.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/ChunkProviderServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/ChunkProviderServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/FlatGeneratorInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/FlatGeneratorInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/FlatLayerInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/FlatLayerInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/IChunkGenerator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/IChunkGenerator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/MapGenBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/MapGenBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/MapGenCaves.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/MapGenCaves.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/MapGenCavesHell.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/MapGenCavesHell.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/MapGenRavine.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/MapGenRavine.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/NoiseGenerator.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/NoiseGenerator.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/NoiseGeneratorImproved.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/NoiseGeneratorImproved.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/NoiseGeneratorOctaves.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/NoiseGeneratorOctaves.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/NoiseGeneratorPerlin.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/NoiseGeneratorPerlin.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/gen/NoiseGeneratorSimplex.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/gen/NoiseGeneratorSimplex.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/EntityHasProperty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/EntityHasProperty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/EntityHasScore.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/EntityHasScore.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/KilledByPlayer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/KilledByPlayer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/LootCondition.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/LootCondition.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/LootConditionManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/LootConditionManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/RandomChance.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/RandomChance.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/conditions/RandomChanceWithLooting.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/conditions/RandomChanceWithLooting.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/EnchantRandomly.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/EnchantRandomly.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/EnchantWithLevels.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/EnchantWithLevels.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/LootFunction.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/LootFunction.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/LootFunctionManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/LootFunctionManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/LootingEnchantBonus.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/LootingEnchantBonus.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/SetAttributes.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/SetAttributes.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/SetCount.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/SetCount.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/SetDamage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/SetDamage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/SetMetadata.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/SetMetadata.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/SetNBT.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/SetNBT.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/functions/Smelt.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/functions/Smelt.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/properties/EntityOnFire.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/properties/EntityOnFire.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/properties/EntityProperty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/properties/EntityProperty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/properties/EntityPropertyManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/properties/EntityPropertyManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/ILootContainer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/ILootContainer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootContext.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootContext.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootEntryEmpty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootEntryEmpty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootEntryItem.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootEntryItem.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootEntryTable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootEntryTable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootPool.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootPool.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootTable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootTable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootTableList.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootTableList.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/LootTableManager.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/LootTableManager.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/loot/RandomValueRange.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/loot/RandomValueRange.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/DerivedWorldInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/DerivedWorldInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/IPlayerFileData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/IPlayerFileData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/ISaveFormat.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/ISaveFormat.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/ISaveHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/ISaveHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/IThreadedFileIO.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/IThreadedFileIO.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/MapData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/MapData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/MapDecoration.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/MapDecoration.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/MapStorage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/MapStorage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/SaveDataMemoryStorage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/SaveDataMemoryStorage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/SaveFormatOld.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/SaveFormatOld.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/SaveHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/SaveHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/SaveHandlerMP.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/SaveHandlerMP.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/ThreadedFileIOBase.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/ThreadedFileIOBase.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/WorldInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/WorldInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/WorldSavedData.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/WorldSavedData.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/WorldSavedDataCallableSave.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/WorldSavedDataCallableSave.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/storage/WorldSummary.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/storage/WorldSummary.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/BossInfo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/BossInfo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/BossInfoServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/BossInfoServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/ChunkCache.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/ChunkCache.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/ColorizerFoliage.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/ColorizerFoliage.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/ColorizerGrass.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/ColorizerGrass.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/DifficultyInstance.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/DifficultyInstance.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/DimensionType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/DimensionType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/EnumDifficulty.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/EnumDifficulty.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/EnumSkyBlock.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/EnumSkyBlock.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/Explosion.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/Explosion.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/GameRules.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/GameRules.java	Mon Aug 18 09:39:52 2025
@@ -71,14 +71,14 @@
       }
 
       return var1;
    }
 
    public void readFromNBT(NBTTagCompound var1) {
-      for (String var4 : var1.getKeySet()) {
-         this.setOrCreateGameRule(var4, var1.getString(var4));
+      for (String var3 : var1.getKeySet()) {
+         this.setOrCreateGameRule(var3, var1.getString(var3));
       }
    }
 
    public String[] getRules() {
       Set var1 = this.rules.keySet();
       return var1.toArray(new String[var1.size()]);
@@ -104,12 +104,24 @@
          this.type = var2;
          this.setValue(var1);
       }
 
       public void setValue(String var1) {
          this.valueString = var1;
+         if (var1 != null) {
+            if (var1.equals("false")) {
+               this.valueBoolean = false;
+               return;
+            }
+
+            if (var1.equals("true")) {
+               this.valueBoolean = true;
+               return;
+            }
+         }
+
          this.valueBoolean = Boolean.parseBoolean(var1);
          this.valueInteger = this.valueBoolean ? 1 : 0;
 
          try {
             this.valueInteger = Integer.parseInt(var1);
          } catch (NumberFormatException var4) {
--- net/minecraft/world/GameType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/GameType.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/IBlockAccess.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/IBlockAccess.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/IInteractionObject.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/IInteractionObject.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/ILockableContainer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/ILockableContainer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/IWorldEventListener.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/IWorldEventListener.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/IWorldNameable.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/IWorldNameable.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/LockCode.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/LockCode.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/MinecraftException.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/MinecraftException.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/NextTickListEntry.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/NextTickListEntry.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/ServerWorldEventHandler.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/ServerWorldEventHandler.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/Teleporter.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/Teleporter.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/World.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/World.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldEntitySpawner.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldEntitySpawner.java	Mon Aug 18 09:39:52 2025
@@ -1,10 +1,15 @@
 package net.minecraft.world;
 
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockRailBase;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
@@ -16,180 +21,253 @@
 import net.minecraft.init.Blocks;
 import net.minecraft.server.management.PlayerChunkMapEntry;
 import net.minecraft.util.WeightedRandom;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.BlockPos.MutableBlockPos;
 import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.Biome.SpawnListEntry;
 import net.minecraft.world.chunk.Chunk;
+import net.optifine.BlockPosM;
+import net.optifine.reflect.Reflector;
+import net.optifine.reflect.ReflectorForge;
 
 public final class WorldEntitySpawner {
    private static final int MOB_COUNT_DIV = (int)Math.pow(17.0, 2.0);
    private final Set<ChunkPos> eligibleChunksForSpawning = Sets.newHashSet();
+   private Map<Class, EntityLiving> mapSampleEntitiesByClass = new HashMap<>();
+   private int lastPlayerChunkX = Integer.MAX_VALUE;
+   private int lastPlayerChunkZ = Integer.MAX_VALUE;
+   private int countChunkPos;
 
    public int findChunksForSpawning(WorldServer var1, boolean var2, boolean var3, boolean var4) {
       if (!var2 && !var3) {
          return 0;
       } else {
-         this.eligibleChunksForSpawning.clear();
-         int var5 = 0;
+         boolean var5 = true;
+         EntityPlayer var6 = null;
+         if (var1.playerEntities.size() == 1) {
+            var6 = (EntityPlayer)var1.playerEntities.get(0);
+            if (this.eligibleChunksForSpawning.size() > 0
+               && var6 != null
+               && var6.chunkCoordX == this.lastPlayerChunkX
+               && var6.chunkCoordZ == this.lastPlayerChunkZ) {
+               var5 = false;
+            }
+         }
 
-         for (EntityPlayer var7 : var1.playerEntities) {
-            if (!var7.isSpectator()) {
-               int var8 = MathHelper.floor(var7.posX / 16.0);
-               int var9 = MathHelper.floor(var7.posZ / 16.0);
-               byte var10 = 8;
-
-               for (int var11 = -8; var11 <= 8; var11++) {
-                  for (int var12 = -8; var12 <= 8; var12++) {
-                     boolean var13 = var11 == -8 || var11 == 8 || var12 == -8 || var12 == 8;
-                     ChunkPos var14 = new ChunkPos(var11 + var8, var12 + var9);
-                     if (!this.eligibleChunksForSpawning.contains(var14)) {
-                        var5++;
-                        if (!var13 && var1.getWorldBorder().contains(var14)) {
-                           PlayerChunkMapEntry var15 = var1.getPlayerChunkMap().getEntry(var14.x, var14.z);
-                           if (var15 != null && var15.isSentToPlayers()) {
-                              this.eligibleChunksForSpawning.add(var14);
+         if (var5) {
+            this.eligibleChunksForSpawning.clear();
+            int var7 = 0;
+
+            for (EntityPlayer var9 : var1.playerEntities) {
+               if (!var9.isSpectator()) {
+                  int var10 = MathHelper.floor(var9.posX / 16.0);
+                  int var11 = MathHelper.floor(var9.posZ / 16.0);
+                  byte var12 = 8;
+
+                  for (int var13 = -8; var13 <= 8; var13++) {
+                     for (int var14 = -8; var14 <= 8; var14++) {
+                        boolean var15 = var13 == -8 || var13 == 8 || var14 == -8 || var14 == 8;
+                        ChunkPos var16 = new ChunkPos(var13 + var10, var14 + var11);
+                        if (!this.eligibleChunksForSpawning.contains(var16)) {
+                           var7++;
+                           if (!var15 && var1.getWorldBorder().contains(var16)) {
+                              PlayerChunkMapEntry var17 = var1.getPlayerChunkMap().getEntry(var16.x, var16.z);
+                              if (var17 != null && var17.isSentToPlayers()) {
+                                 this.eligibleChunksForSpawning.add(var16);
+                              }
                            }
                         }
                      }
                   }
                }
             }
+
+            this.countChunkPos = var7;
+            if (var6 != null) {
+               this.lastPlayerChunkX = var6.chunkCoordX;
+               this.lastPlayerChunkZ = var6.chunkCoordZ;
+            }
          }
 
-         int var37 = 0;
-         BlockPos var38 = var1.getSpawnPoint();
+         int var41 = 0;
+         BlockPos var42 = var1.getSpawnPoint();
+         BlockPosM var43 = new BlockPosM(0, 0, 0);
+         MutableBlockPos var44 = new MutableBlockPos();
+
+         for (EnumCreatureType var48 : EnumCreatureType.values()) {
+            if ((!var48.getPeacefulCreature() || var3) && (var48.getPeacefulCreature() || var2) && (!var48.getAnimal() || var4)) {
+               int var49 = Reflector.ForgeWorld_countEntities.exists()
+                  ? Reflector.callInt(var1, Reflector.ForgeWorld_countEntities, new Object[]{var48, true})
+                  : var1.countEntities(var48.getCreatureClass());
+               int var50 = var48.getMaxNumberOfCreature() * this.countChunkPos / MOB_COUNT_DIV;
+               if (var49 <= var50) {
+                  Object var51 = this.eligibleChunksForSpawning;
+                  if (Reflector.ForgeHooksClient.exists()) {
+                     ArrayList var18 = Lists.newArrayList((Iterable)var51);
+                     Collections.shuffle(var18);
+                     var51 = var18;
+                  }
 
-         for (EnumCreatureType var42 : EnumCreatureType.values()) {
-            if ((!var42.getPeacefulCreature() || var3) && (var42.getPeacefulCreature() || var2) && (!var42.getAnimal() || var4)) {
-               int var43 = var1.countEntities(var42.getCreatureClass());
-               int var44 = var42.getMaxNumberOfCreature() * var5 / MOB_COUNT_DIV;
-               if (var43 <= var44) {
-                  BlockPos.MutableBlockPos var45 = new BlockPos.MutableBlockPos();
-
-                  label134:
-                  for (ChunkPos var16 : this.eligibleChunksForSpawning) {
-                     BlockPos var17 = getRandomChunkPosition(var1, var16.x, var16.z);
-                     int var18 = var17.getX();
-                     int var19 = var17.getY();
-                     int var20 = var17.getZ();
-                     IBlockState var21 = var1.getBlockState(var17);
-                     if (!var21.isNormalCube()) {
-                        int var22 = 0;
-
-                        for (int var23 = 0; var23 < 3; var23++) {
-                           int var24 = var18;
-                           int var25 = var19;
-                           int var26 = var20;
-                           byte var27 = 6;
-                           Biome.SpawnListEntry var28 = null;
-                           IEntityLivingData var29 = null;
-                           int var30 = MathHelper.ceil(Math.random() * 4.0);
-
-                           for (int var31 = 0; var31 < var30; var31++) {
-                              var24 += var1.rand.nextInt(6) - var1.rand.nextInt(6);
-                              var25 += var1.rand.nextInt(1) - var1.rand.nextInt(1);
-                              var26 += var1.rand.nextInt(6) - var1.rand.nextInt(6);
-                              var45.setPos(var24, var25, var26);
-                              float var32 = var24 + 0.5F;
-                              float var33 = var26 + 0.5F;
-                              if (!var1.isAnyPlayerWithinRangeAt(var32, var25, var33, 24.0) && !(var38.distanceSq(var32, var25, var33) < 576.0)) {
-                                 if (var28 == null) {
-                                    var28 = var1.getSpawnListEntryForTypeAt(var42, var45);
-                                    if (var28 == null) {
+                  label176:
+                  for (ChunkPos var19 : var51) {
+                     BlockPosM var20 = getRandomChunkPosition(var1, var19.x, var19.z, var43);
+                     int var21 = var20.getX();
+                     int var22 = var20.getY();
+                     int var23 = var20.getZ();
+                     IBlockState var24 = var1.getBlockState(var20);
+                     if (!var24.l()) {
+                        int var25 = 0;
+
+                        for (int var26 = 0; var26 < 3; var26++) {
+                           int var27 = var21;
+                           int var28 = var22;
+                           int var29 = var23;
+                           byte var30 = 6;
+                           SpawnListEntry var31 = null;
+                           IEntityLivingData var32 = null;
+                           int var33 = MathHelper.ceil(Math.random() * 4.0);
+
+                           for (int var34 = 0; var34 < var33; var34++) {
+                              var27 += var1.rand.nextInt(6) - var1.rand.nextInt(6);
+                              var28 += var1.rand.nextInt(1) - var1.rand.nextInt(1);
+                              var29 += var1.rand.nextInt(6) - var1.rand.nextInt(6);
+                              var44.setPos(var27, var28, var29);
+                              float var35 = var27 + 0.5F;
+                              float var36 = var29 + 0.5F;
+                              if (!var1.isAnyPlayerWithinRangeAt(var35, var28, var36, 24.0) && var42.distanceSq(var35, var28, var36) >= 576.0) {
+                                 if (var31 == null) {
+                                    var31 = var1.getSpawnListEntryForTypeAt(var48, var44);
+                                    if (var31 == null) {
                                        break;
                                     }
                                  }
 
-                                 if (var1.canCreatureTypeSpawnHere(var42, var28, var45)
-                                    && canCreatureTypeSpawnAtLocation(EntitySpawnPlacementRegistry.getPlacementForEntity(var28.entityClass), var1, var45)) {
-                                    EntityLiving var34;
+                                 if (var1.canCreatureTypeSpawnHere(var48, var31, var44)
+                                    && canCreatureTypeSpawnAtLocation(EntitySpawnPlacementRegistry.getPlacementForEntity(var31.entityClass), var1, var44)) {
+                                    EntityLiving var37;
                                     try {
-                                       var34 = var28.entityClass.getConstructor(World.class).newInstance(var1);
-                                    } catch (Exception var36) {
-                                       var36.printStackTrace();
-                                       return var37;
+                                       var37 = this.mapSampleEntitiesByClass.get(var31.entityClass);
+                                       if (var37 == null) {
+                                          if (Reflector.ForgeBiomeSpawnListEntry_newInstance.exists()) {
+                                             var37 = (EntityLiving)Reflector.call(var31, Reflector.ForgeBiomeSpawnListEntry_newInstance, new Object[]{var1});
+                                          } else {
+                                             var37 = (EntityLiving)var31.entityClass.getConstructor(World.class).newInstance(var1);
+                                          }
+
+                                          this.mapSampleEntitiesByClass.put(var31.entityClass, var37);
+                                       }
+                                    } catch (Exception var40) {
+                                       var40.printStackTrace();
+                                       return var41;
                                     }
 
-                                    var34.setLocationAndAngles(var32, var25, var33, var1.rand.nextFloat() * 360.0F, 0.0F);
-                                    if (var34.getCanSpawnHere() && var34.isNotColliding()) {
-                                       var29 = var34.onInitialSpawn(var1.getDifficultyForLocation(new BlockPos(var34)), var29);
-                                       if (var34.isNotColliding()) {
-                                          var22++;
-                                          var1.spawnEntity(var34);
+                                    var37.setLocationAndAngles(var35, var28, var36, var1.rand.nextFloat() * 360.0F, 0.0F);
+                                    boolean var38 = Reflector.ForgeEventFactory_canEntitySpawn.exists()
+                                       ? ReflectorForge.canEntitySpawn(var37, var1, var35, var28, var36)
+                                       : var37.getCanSpawnHere() && var37.isNotColliding();
+                                    if (var38) {
+                                       this.mapSampleEntitiesByClass.remove(var31.entityClass);
+                                       if (!ReflectorForge.doSpecialSpawn(var37, var1, var35, var28, var36)) {
+                                          var32 = var37.onInitialSpawn(var1.getDifficultyForLocation(new BlockPos(var37)), var32);
+                                       }
+
+                                       if (var37.isNotColliding()) {
+                                          var25++;
+                                          var1.spawnEntity(var37);
                                        } else {
-                                          var34.setDead();
+                                          var37.setDead();
                                        }
 
-                                       if (var22 >= var34.getMaxSpawnedInChunk()) {
-                                          continue label134;
+                                       int var39 = Reflector.ForgeEventFactory_getMaxSpawnPackSize.exists()
+                                          ? Reflector.callInt(Reflector.ForgeEventFactory_getMaxSpawnPackSize, new Object[]{var37})
+                                          : var37.getMaxSpawnedInChunk();
+                                       if (var25 >= var39) {
+                                          continue label176;
                                        }
                                     }
 
-                                    var37 += var22;
+                                    var41 += var25;
                                  }
                               }
                            }
                         }
                      }
                   }
                }
             }
          }
 
-         return var37;
+         return var41;
       }
    }
 
    private static BlockPos getRandomChunkPosition(World var0, int var1, int var2) {
       Chunk var3 = var0.getChunk(var1, var2);
       int var4 = var1 * 16 + var0.rand.nextInt(16);
       int var5 = var2 * 16 + var0.rand.nextInt(16);
       int var6 = MathHelper.roundUp(var3.getHeight(new BlockPos(var4, 0, var5)) + 1, 16);
       int var7 = var0.rand.nextInt(var6 > 0 ? var6 : var3.getTopFilledSegment() + 16 - 1);
       return new BlockPos(var4, var7, var5);
    }
 
+   private static BlockPosM getRandomChunkPosition(World var0, int var1, int var2, BlockPosM var3) {
+      Chunk var4 = var0.getChunk(var1, var2);
+      int var5 = var1 * 16 + var0.rand.nextInt(16);
+      int var6 = var2 * 16 + var0.rand.nextInt(16);
+      int var7 = MathHelper.roundUp(var4.getHeightValue(var5 & 15, var6 & 15) + 1, 16);
+      int var8 = var0.rand.nextInt(var7 > 0 ? var7 : var4.getTopFilledSegment() + 16 - 1);
+      var3.setXyz(var5, var8, var6);
+      return var3;
+   }
+
    public static boolean isValidEmptySpawnBlock(IBlockState var0) {
-      if (var0.isBlockNormalCube()) {
+      if (var0.k()) {
          return false;
-      } else if (var0.canProvidePower()) {
+      } else if (var0.m()) {
          return false;
       } else {
-         return var0.getMaterial().isLiquid() ? false : !BlockRailBase.isRailBlock(var0);
+         return var0.a().isLiquid() ? false : !BlockRailBase.isRailBlock(var0);
       }
    }
 
    public static boolean canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType var0, World var1, BlockPos var2) {
       if (!var1.getWorldBorder().contains(var2)) {
          return false;
       } else {
-         IBlockState var3 = var1.getBlockState(var2);
-         if (var0 == EntityLiving.SpawnPlacementType.IN_WATER) {
-            return var3.getMaterial() == Material.WATER
-               && var1.getBlockState(var2.down()).getMaterial() == Material.WATER
-               && !var1.getBlockState(var2.up()).isNormalCube();
+         return var0 == null ? false : var0.canSpawnAt(var1, var2);
+      }
+   }
+
+   public static boolean canCreatureTypeSpawnBody(EntityLiving.SpawnPlacementType var0, World var1, BlockPos var2) {
+      IBlockState var3 = var1.getBlockState(var2);
+      if (var0 == EntityLiving.SpawnPlacementType.IN_WATER) {
+         return var3.a() == Material.WATER && var1.getBlockState(var2.down()).a() == Material.WATER && !var1.getBlockState(var2.up()).l();
+      } else {
+         BlockPos var4 = var2.down();
+         IBlockState var5 = var1.getBlockState(var4);
+         boolean var6 = Reflector.ForgeBlock_canCreatureSpawn.exists()
+            ? Reflector.callBoolean(var5.getBlock(), Reflector.ForgeBlock_canCreatureSpawn, new Object[]{var5, var1, var4, var0})
+            : var5.q();
+         if (!var6) {
+            return false;
          } else {
-            BlockPos var4 = var2.down();
-            if (!var1.getBlockState(var4).isTopSolid()) {
-               return false;
-            } else {
-               Block var5 = var1.getBlockState(var4).getBlock();
-               boolean var6 = var5 != Blocks.BEDROCK && var5 != Blocks.BARRIER;
-               return var6 && isValidEmptySpawnBlock(var3) && isValidEmptySpawnBlock(var1.getBlockState(var2.up()));
-            }
+            Block var7 = var1.getBlockState(var4).getBlock();
+            boolean var8 = var7 != Blocks.BEDROCK && var7 != Blocks.BARRIER;
+            return var8 && isValidEmptySpawnBlock(var3) && isValidEmptySpawnBlock(var1.getBlockState(var2.up()));
          }
       }
    }
 
    public static void performWorldGenSpawning(World var0, Biome var1, int var2, int var3, int var4, int var5, Random var6) {
       List var7 = var1.getSpawnableList(EnumCreatureType.CREATURE);
       if (!var7.isEmpty()) {
          while (var6.nextFloat() < var1.getSpawningChance()) {
-            Biome.SpawnListEntry var8 = WeightedRandom.getRandomItem(var0.rand, var7);
+            SpawnListEntry var8 = (SpawnListEntry)WeightedRandom.getRandomItem(var0.rand, var7);
             int var9 = var8.minGroupCount + var6.nextInt(1 + var8.maxGroupCount - var8.minGroupCount);
             IEntityLivingData var10 = null;
             int var11 = var2 + var6.nextInt(var4);
             int var12 = var3 + var6.nextInt(var5);
             int var13 = var11;
             int var14 = var12;
@@ -199,16 +277,29 @@
 
                for (int var17 = 0; !var16 && var17 < 4; var17++) {
                   BlockPos var18 = var0.getTopSolidOrLiquidBlock(new BlockPos(var11, 0, var12));
                   if (canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType.ON_GROUND, var0, var18)) {
                      EntityLiving var19;
                      try {
-                        var19 = var8.entityClass.getConstructor(World.class).newInstance(var0);
+                        if (Reflector.ForgeBiomeSpawnListEntry_newInstance.exists()) {
+                           var19 = (EntityLiving)Reflector.call(var8, Reflector.ForgeBiomeSpawnListEntry_newInstance, new Object[]{var0});
+                        } else {
+                           var19 = (EntityLiving)var8.entityClass.getConstructor(World.class).newInstance(var0);
+                        }
                      } catch (Exception var21) {
                         var21.printStackTrace();
                         continue;
+                     }
+
+                     if (Reflector.ForgeEventFactory_canEntitySpawn.exists()) {
+                        Object var20 = Reflector.call(
+                           Reflector.ForgeEventFactory_canEntitySpawn, new Object[]{var19, var0, var11 + 0.5F, var18.getY(), var12 + 0.5F, false}
+                        );
+                        if (var20 == ReflectorForge.EVENT_RESULT_DENY) {
+                           continue;
+                        }
                      }
 
                      var19.setLocationAndAngles(var11 + 0.5F, var18.getY(), var12 + 0.5F, var6.nextFloat() * 360.0F, 0.0F);
                      var0.spawnEntity(var19);
                      var10 = var19.onInitialSpawn(var0.getDifficultyForLocation(new BlockPos(var19)), var10);
                      var16 = true;
--- net/minecraft/world/WorldProvider.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldProvider.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldProviderEnd.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldProviderEnd.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldProviderHell.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldProviderHell.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldProviderSurface.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldProviderSurface.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldServer.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldServer.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldServerDemo.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldServerDemo.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldServerMulti.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldServerMulti.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldSettings.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldSettings.java	Mon Aug 18 09:39:30 2025
--- net/minecraft/world/WorldType.java	Mon Aug 18 09:39:30 2025
+++ net/minecraft/world/WorldType.java	Mon Aug 18 09:39:30 2025
